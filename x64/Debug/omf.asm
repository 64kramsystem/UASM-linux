; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
$SG12452 DB	01H DUP (?)
$SG12719 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	LastCodeBufSize:DWORD
_DATA	ENDS
CONST	SEGMENT
SymDebParm DQ	FLAT:$SG12213
	DQ	FLAT:$SG12214
	DQ	FLAT:$SG12215
	DQ	FLAT:$SG12216
CONST	ENDS
_DATA	SEGMENT
$SG12290 DB	'omf.c', 00H
	ORG $+2
$SG12303 DB	'omf.c', 00H
	ORG $+2
$SG12314 DB	'omf.c', 00H
	ORG $+2
$SG12334 DB	'omf_OutSelect: data in code segment (%s), starting at %X'
	DB	0aH, 00H
	ORG $+2
$SG12413 DB	'NULL', 00H
	ORG $+7
$SG12337 DB	'omf_OutSelect: writing coment record about data in code:'
	DB	' start=%X curofs=%X', 0aH, 00H
	ORG $+3
$SG12400 DB	'omf_write_ledata enter, buffer=%p start ofs=%X, size=%X', 0aH
	DB	00H
	ORG $+3
$SG12443 DB	01H, 00H
	ORG $+2
$SG12414 DB	'omf_FlushCurrSeg() enter, CurrSeg=%s, currsrc=%u', 0aH, 00H
	ORG $+2
$SG12810 DB	01H, 'CV', 00H
$SG12422 DB	'omf_write_theadr(%s) enter', 0aH, 00H
	ORG $+4
$SG12423 DB	'omf_write_theadr() exit', 0aH, 00H
	ORG $+3
$SG12515 DB	'omf.c', 00H
	ORG $+6
$SG12446 DB	'omf_set_filepos: reset file pos to %X', 0aH, 00H
	ORG $+1
$SG12464 DB	'omf_write_lib() enter', 0aH, 00H
	ORG $+1
$SG12465 DB	'omf_write_lib() exit', 0aH, 00H
	ORG $+2
$SG12501 DB	'omf_write_grpdef enter', 0aH, 00H
$SG12503 DB	'omf_write_grpdef exit', 0aH, 00H
	ORG $+1
$SG12526 DB	'omf_write_segdef enter', 0aH, 00H
$SG12530 DB	'omf_write_segdef(%s): len=%X use32=%u align=%u comb=%u s'
	DB	'eg_lname=%u class_lname=%u ovl_lname=%u', 0aH, 00H
	ORG $+3
$SG12589 DB	'omf.c', 00H
	ORG $+6
$SG12532 DB	'omf_write_segdef exit', 0aH, 00H
	ORG $+1
$SG12555 DB	'omf_write_lnames() enter', 0aH, 00H
	ORG $+6
$SG12561 DB	'omf_write_lnames: %u=%s', 0aH, 00H
	ORG $+3
$SG12592 DB	'omf.c', 00H
	ORG $+6
$SG12565 DB	'omf_write_lnames() exit, items=%u', 0aH, 00H
	ORG $+5
$SG12619 DB	'omf_write_extdef enter', 0aH, 00H
$SG12620 DB	'omf_write_extdef: %s', 0aH, 00H
	ORG $+2
$SG12624 DB	'omf_write_extdef: write record, names=%u, size=%u, MAX=%'
	DB	'u', 0aH, 00H
	ORG $+5
$SG12627 DB	'omf_write_extdef exit, index=%u', 0aH, 00H
	ORG $+3
$SG12683 DB	'omf.c', 00H
	ORG $+6
$SG12680 DB	'omf_write_comdef enter', 0aH, 00H
$SG12684 DB	'omf_write_comdef: %s, size=%u, sym.total_size=%u, sym.to'
	DB	'tal_length=%u, sym.isfar=%u', 0aH, 00H
	ORG $+3
$SG12688 DB	'omf_write_comdef: numsize=%u, length=%u, varsize=%u', 0aH
	DB	00H
	ORG $+3
$SG12689 DB	'omf_write_comdef: numsize=%u, value=%u', 0aH, 00H
$SG12692 DB	'omf_write_comdef exit', 0aH, 00H
	ORG $+1
$SG12699 DB	'GetFileTimeStamp(%s): _stat() did return 0', 0aH, 00H
	ORG $+4
$SG12716 DB	'omf_write_autodep() enter', 0aH, 00H
	ORG $+5
$SG12718 DB	'omf_write_autodep(): write record: file=%s, time=%X', 0aH
	DB	00H
	ORG $+3
$SG12720 DB	'omf_write_autodep() exit', 0aH, 00H
	ORG $+6
$SG12762 DB	'omf_write_pub enter', 0aH, 00H
	ORG $+3
$SG12776 DB	'omf_write_pub exit', 0aH, 00H
	ORG $+4
$SG12786 DB	'omf_write_modend( fixup=%p, displ=%X)', 0aH, 00H
	ORG $+1
$SG12841 DB	'omf_init enter', 0aH, 00H
$SG12213 DB	'$$SYMBOLS', 00H
	ORG $+2
$SG12214 DB	'DEBSYM', 00H
	ORG $+5
$SG12215 DB	'$$TYPES', 00H
$SG12216 DB	'DEBTYP', 00H
	ORG $+1
$SG12225 DB	'omf_InitRec(%p, %X)', 0aH, 00H
	ORG $+3
$SG12241 DB	'omf.c', 00H
	ORG $+2
$SG12254 DB	'omf.c', 00H
	ORG $+2
$SG12267 DB	'omf.c', 00H
	ORG $+2
$SG12277 DB	'omf.c', 00H
_DATA	ENDS
PUBLIC	omf_init
PUBLIC	omf_set_filepos
PUBLIC	omf_OutSelect
PUBLIC	omf_FlushCurrSeg
PUBLIC	omf_check_flush
PUBLIC	omf_GetGrpIdx
EXTRN	__report_rangecheckfailure:PROC
EXTRN	_localtime64:PROC
EXTRN	_stat64i32:PROC
EXTRN	_fileno:PROC
EXTRN	fseek:PROC
EXTRN	ftell:PROC
EXTRN	memcpy:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	_strupr:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	DoDebugMsg1:PROC
EXTRN	EmitWarn:PROC
EXTRN	SizeFromMemtype:PROC
EXTRN	GetSymOfssize:PROC
EXTRN	GetCurrOffset:PROC
EXTRN	CreateIntSegment:PROC
EXTRN	GetSegIdx:PROC
EXTRN	GetGroup:PROC
EXTRN	Mangle:PROC
EXTRN	omf_write_record:PROC
EXTRN	OmfFixGenFix:PROC
EXTRN	OmfFixGenFixModend:PROC
EXTRN	InternalError:PROC
EXTRN	get_curr_srcfile:PROC
EXTRN	GetFName:PROC
EXTRN	_chsize:PROC
EXTRN	cv_write_debug_tables:PROC
EXTRN	SortSegments:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	write_to_file:BYTE
EXTRN	SymTables:BYTE
EXTRN	LinnumQueue:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
	ALIGN	4

seg_pos	DD	01H DUP (?)
public_pos DD	01H DUP (?)
end_of_header DD 01H DUP (?)
startitem DD	01H DUP (?)
startext DD	01H DUP (?)
ln_srcfile DD	01H DUP (?)
ln_is32	DB	01H DUP (?)
	ALIGN	4

ln_size	DW	01H DUP (?)
	ALIGN	8

SymDebSeg DQ	02H DUP (?)
?sel_start@?1??omf_OutSelect@@9@9 DD 01H DUP (?)	; `omf_OutSelect'::`2'::sel_start
_BSS	ENDS
pdata	SEGMENT
$pdata$localtime DD imagerel localtime
	DD	imagerel localtime+24
	DD	imagerel $unwind$localtime
$pdata$omf_init DD imagerel $LN3
	DD	imagerel $LN3+138
	DD	imagerel $unwind$omf_init
$pdata$omf_set_filepos DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$omf_set_filepos
$pdata$omf_OutSelect DD imagerel $LN12
	DD	imagerel $LN12+507
	DD	imagerel $unwind$omf_OutSelect
$pdata$omf_FlushCurrSeg DD imagerel $LN6
	DD	imagerel $LN6+118
	DD	imagerel $unwind$omf_FlushCurrSeg
$pdata$omf_check_flush DD imagerel $LN13
	DD	imagerel $LN13+272
	DD	imagerel $unwind$omf_check_flush
$pdata$omf_InitRec DD imagerel omf_InitRec
	DD	imagerel omf_InitRec+101
	DD	imagerel $unwind$omf_InitRec
$pdata$timet2dostime DD imagerel timet2dostime
	DD	imagerel timet2dostime+129
	DD	imagerel $unwind$timet2dostime
$pdata$Put8 DD	imagerel Put8
	DD	imagerel Put8+112
	DD	imagerel $unwind$Put8
$pdata$Put16 DD	imagerel Put16
	DD	imagerel Put16+116
	DD	imagerel $unwind$Put16
$pdata$Put32 DD	imagerel Put32
	DD	imagerel Put32+113
	DD	imagerel $unwind$Put32
$pdata$PutIndex DD imagerel PutIndex
	DD	imagerel PutIndex+182
	DD	imagerel $unwind$PutIndex
$pdata$PutData DD imagerel PutData
	DD	imagerel PutData+131
	DD	imagerel $unwind$PutData
$pdata$PutName DD imagerel PutName
	DD	imagerel PutName+138
	DD	imagerel $unwind$PutName
$pdata$AttachData DD imagerel AttachData
	DD	imagerel AttachData+92
	DD	imagerel $unwind$AttachData
$pdata$omf_GetGrpIdx DD imagerel $LN5
	DD	imagerel $LN5+49
	DD	imagerel $unwind$omf_GetGrpIdx
$pdata$omf_write_linnum DD imagerel omf_write_linnum
	DD	imagerel omf_write_linnum+371
	DD	imagerel $unwind$omf_write_linnum
$pdata$omf_write_fixupp DD imagerel omf_write_fixupp
	DD	imagerel omf_write_fixupp+398
	DD	imagerel $unwind$omf_write_fixupp
$pdata$get_omfalign DD imagerel get_omfalign
	DD	imagerel get_omfalign+121
	DD	imagerel $unwind$get_omfalign
$pdata$omf_write_ledata DD imagerel omf_write_ledata
	DD	imagerel omf_write_ledata+840
	DD	imagerel $unwind$omf_write_ledata
$pdata$omf_write_theadr DD imagerel omf_write_theadr
	DD	imagerel omf_write_theadr+157
	DD	imagerel $unwind$omf_write_theadr
$pdata$omf_end_of_pass1 DD imagerel omf_end_of_pass1
	DD	imagerel omf_end_of_pass1+92
	DD	imagerel $unwind$omf_end_of_pass1
$pdata$omf_write_dosseg DD imagerel omf_write_dosseg
	DD	imagerel omf_write_dosseg+89
	DD	imagerel $unwind$omf_write_dosseg
$pdata$omf_write_lib DD imagerel omf_write_lib
	DD	imagerel omf_write_lib+182
	DD	imagerel $unwind$omf_write_lib
$pdata$omf_write_export DD imagerel omf_write_export
	DD	imagerel omf_write_export+456
	DD	imagerel $unwind$omf_write_export
$pdata$omf_write_grpdef DD imagerel omf_write_grpdef
	DD	imagerel omf_write_grpdef+353
	DD	imagerel $unwind$omf_write_grpdef
$pdata$omf_write_segdef DD imagerel omf_write_segdef
	DD	imagerel omf_write_segdef+744
	DD	imagerel $unwind$omf_write_segdef
$pdata$omf_write_lnames DD imagerel omf_write_lnames
	DD	imagerel omf_write_lnames+591
	DD	imagerel $unwind$omf_write_lnames
$pdata$GetExt DD imagerel GetExt
	DD	imagerel GetExt+519
	DD	imagerel $unwind$GetExt
$pdata$omf_write_extdef DD imagerel omf_write_extdef
	DD	imagerel omf_write_extdef+864
	DD	imagerel $unwind$omf_write_extdef
$pdata$put_comdef_number DD imagerel put_comdef_number
	DD	imagerel put_comdef_number+232
	DD	imagerel $unwind$put_comdef_number
$pdata$omf_write_comdef DD imagerel omf_write_comdef
	DD	imagerel omf_write_comdef+1037
	DD	imagerel $unwind$omf_write_comdef
$pdata$GetFileTimeStamp DD imagerel GetFileTimeStamp
	DD	imagerel GetFileTimeStamp+87
	DD	imagerel $unwind$GetFileTimeStamp
$pdata$omf_write_autodep DD imagerel omf_write_autodep
	DD	imagerel omf_write_autodep+387
	DD	imagerel $unwind$omf_write_autodep
$pdata$omf_write_alias DD imagerel omf_write_alias
	DD	imagerel omf_write_alias+341
	DD	imagerel $unwind$omf_write_alias
$pdata$omf_write_pubdef DD imagerel omf_write_pubdef
	DD	imagerel omf_write_pubdef+974
	DD	imagerel $unwind$omf_write_pubdef
$pdata$omf_write_modend DD imagerel omf_write_modend
	DD	imagerel omf_write_modend+260
	DD	imagerel $unwind$omf_write_modend
$pdata$omf_cv_flushfunc DD imagerel omf_cv_flushfunc
	DD	imagerel omf_cv_flushfunc+164
	DD	imagerel $unwind$omf_cv_flushfunc
$pdata$omf_write_header_dbgcv DD imagerel omf_write_header_dbgcv
	DD	imagerel omf_write_header_dbgcv+331
	DD	imagerel $unwind$omf_write_header_dbgcv
$pdata$omf_write_debug_tables DD imagerel omf_write_debug_tables
	DD	imagerel omf_write_debug_tables+207
	DD	imagerel $unwind$omf_write_debug_tables
$pdata$omf_write_module DD imagerel omf_write_module
	DD	imagerel omf_write_module+209
	DD	imagerel $unwind$omf_write_module
$pdata$omf_write_header_initial DD imagerel omf_write_header_initial
	DD	imagerel omf_write_header_initial+298
	DD	imagerel $unwind$omf_write_header_initial
pdata	ENDS
xdata	SEGMENT
$unwind$localtime DD 010901H
	DD	04209H
$unwind$omf_init DD 010901H
	DD	04209H
$unwind$omf_set_filepos DD 010401H
	DD	04204H
$unwind$omf_OutSelect DD 011719H
	DD	0e208H
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$omf_FlushCurrSeg DD 010401H
	DD	06204H
$unwind$omf_check_flush DD 010901H
	DD	08209H
$unwind$omf_InitRec DD 010d01H
	DD	0420dH
$unwind$timet2dostime DD 010901H
	DD	08209H
$unwind$Put8 DD	010d01H
	DD	0620dH
$unwind$Put16 DD 010e01H
	DD	0620eH
$unwind$Put32 DD 010d01H
	DD	0620dH
$unwind$PutIndex DD 010d01H
	DD	0620dH
$unwind$PutData DD 011301H
	DD	06213H
$unwind$PutName DD 011301H
	DD	06213H
$unwind$AttachData DD 011301H
	DD	06213H
$unwind$omf_GetGrpIdx DD 010901H
	DD	02209H
$unwind$omf_write_linnum DD 021d19H
	DD	013010bH
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$omf_write_fixupp DD 021f19H
	DD	0110110H
	DD	imagerel __GSHandlerCheck
	DD	078H
$unwind$get_omfalign DD 010801H
	DD	06208H
$unwind$omf_write_ledata DD 011819H
	DD	0e209H
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$omf_write_theadr DD 011819H
	DD	0c209H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$omf_end_of_pass1 DD 011319H
	DD	0c204H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$omf_write_dosseg DD 011319H
	DD	0c204H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$omf_write_lib DD 011319H
	DD	0e204H
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$omf_write_export DD 021619H
	DD	0110107H
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$omf_write_grpdef DD 011319H
	DD	0e204H
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$omf_write_segdef DD 021919H
	DD	0150107H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$omf_write_lnames DD 021919H
	DD	0930107H
	DD	imagerel __GSHandlerCheck
	DD	0480H
$unwind$GetExt DD 010901H
	DD	06209H
$unwind$omf_write_extdef DD 021919H
	DD	0b50107H
	DD	imagerel __GSHandlerCheck
	DD	0590H
$unwind$put_comdef_number DD 010d01H
	DD	0620dH
$unwind$omf_write_comdef DD 021e19H
	DD	0b7010cH
	DD	imagerel __GSHandlerCheck
	DD	05a0H
$unwind$GetFileTimeStamp DD 011819H
	DD	0c209H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$omf_write_autodep DD 011319H
	DD	0e204H
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$omf_write_alias DD 021919H
	DD	06f0107H
	DD	imagerel __GSHandlerCheck
	DD	0360H
$unwind$omf_write_pubdef DD 021919H
	DD	01b0107H
	DD	imagerel __GSHandlerCheck
	DD	0c8H
$unwind$omf_write_modend DD 011c19H
	DD	0e20dH
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$omf_cv_flushfunc DD 011801H
	DD	06218H
$unwind$omf_write_header_dbgcv DD 021919H
	DD	0130107H
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$omf_write_debug_tables DD 010401H
	DD	06204H
$unwind$omf_write_module DD 010901H
	DD	06209H
$unwind$omf_write_header_initial DD 010901H
	DD	06209H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
ext_idx$ = 32
modinfo$ = 64
omf_write_header_initial PROC

; 1618 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1619 :     uint_16 ext_idx;
; 1620 : 
; 1621 :     if ( write_to_file == FALSE )

	movzx	eax, BYTE PTR write_to_file
	test	eax, eax
	jne	SHORT $LN2@omf_write_

; 1622 :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN1@omf_write_
$LN2@omf_write_:

; 1623 : 
; 1624 :     omf_write_theadr( CurrFName[ASM] ); /* write THEADR record, main src filename */

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:ModuleInfo+128
	mov	rcx, QWORD PTR [rcx+rax]
	call	omf_write_theadr

; 1625 :     /* v2.11: coment record "ms extensions present" now written here */
; 1626 :     if ( Options.debug_symbols ) /* -Zi option set? */

	movzx	eax, BYTE PTR Options+2
	test	eax, eax
	je	SHORT $LN3@omf_write_

; 1627 :         omf_write_header_dbgcv();

	call	omf_write_header_dbgcv
$LN3@omf_write_:

; 1628 :     /* if( Options.no_dependencies == FALSE ) */
; 1629 :     if( Options.line_numbers )

	movzx	eax, BYTE PTR Options+1
	test	eax, eax
	je	SHORT $LN4@omf_write_

; 1630 :         omf_write_autodep(); /* write dependency COMENT records ( known by Borland & OW ) */

	call	omf_write_autodep
$LN4@omf_write_:

; 1631 :     if( ModuleInfo.segorder == SEGORDER_DOSSEG )

	cmp	DWORD PTR ModuleInfo+380, 1
	jne	SHORT $LN5@omf_write_

; 1632 :         omf_write_dosseg(); /* write dosseg COMENT records */

	call	omf_write_dosseg
	jmp	SHORT $LN6@omf_write_
$LN5@omf_write_:

; 1633 :     else if( ModuleInfo.segorder == SEGORDER_ALPHA )

	cmp	DWORD PTR ModuleInfo+380, 2
	jne	SHORT $LN7@omf_write_

; 1634 :         SortSegments( 1 );

	mov	ecx, 1
	call	SortSegments
$LN7@omf_write_:
$LN6@omf_write_:

; 1635 :     omf_write_lib(); /* write default lib COMENT records */

	call	omf_write_lib

; 1636 :     omf_write_lnames(); /* write LNAMES records */

	call	omf_write_lnames

; 1637 : 
; 1638 :     /* write SEGDEF records. Since these records contain the segment's length,
; 1639 :      * the records have to be written again after the final assembly pass.
; 1640 :      * hence the start position of those records has to be saved.
; 1641 :      */
; 1642 :     seg_pos = ftell( CurrFile[OBJ] );

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rcx, QWORD PTR [rcx+rax]
	call	ftell
	mov	DWORD PTR seg_pos, eax

; 1643 :     omf_write_segdef();

	call	omf_write_segdef

; 1644 :     omf_write_grpdef(); /* write GRPDEF records */

	call	omf_write_grpdef

; 1645 :     ext_idx = omf_write_extdef(); /* write EXTDEF records */

	call	omf_write_extdef
	mov	WORD PTR ext_idx$[rsp], ax

; 1646 :     startext = omf_write_comdef( ext_idx ); /* write COMDEF records */

	movzx	ecx, WORD PTR ext_idx$[rsp]
	call	omf_write_comdef
	movzx	eax, ax
	mov	DWORD PTR startext, eax

; 1647 :     omf_write_alias(); /* write ALIAS records */

	call	omf_write_alias

; 1648 : 
; 1649 :     /* write PUBDEF records. Since the final value of offsets isn't known after
; 1650 :      * the first pass, this has to be called again after the final pass.
; 1651 :      */
; 1652 :     public_pos = ftell( CurrFile[OBJ] );

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rcx, QWORD PTR [rcx+rax]
	call	ftell
	mov	DWORD PTR public_pos, eax

; 1653 :     omf_write_pubdef();

	call	omf_write_pubdef

; 1654 :     omf_write_export(); /* write export COMENT records */

	call	omf_write_export

; 1655 : 
; 1656 :     /* (optionally) write end-of-pass-one COMENT record
; 1657 :      * v2.10: don't write record if starting address is present.
; 1658 :      * the TIS OMF spec v1.1. warns that this
; 1659 :      * comment record is NOT to be present if
; 1660 :      * the MODEND record contains a starting address!
; 1661 :      */
; 1662 :     if ( !ModuleInfo.g.start_fixup )

	cmp	QWORD PTR ModuleInfo+208, 0
	jne	SHORT $LN8@omf_write_

; 1663 :         omf_end_of_pass1();

	call	omf_end_of_pass1
$LN8@omf_write_:

; 1664 :     end_of_header = ftell( CurrFile[OBJ] );

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rcx, QWORD PTR [rcx+rax]
	call	ftell
	mov	DWORD PTR end_of_header, eax

; 1665 :     return( NOT_ERROR );

	xor	eax, eax
$LN1@omf_write_:

; 1666 : }

	add	rsp, 56					; 00000038H
	ret	0
omf_write_header_initial ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
size$ = 32
fh$ = 36
modinfo$ = 64
omf_write_module PROC

; 1563 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1564 : #if TRUNCATE
; 1565 :     int fh;
; 1566 :     uint_32 size;
; 1567 : #endif
; 1568 :     /* -if Zi is set, write symbols and types */
; 1569 :     if ( Options.debug_symbols )

	movzx	eax, BYTE PTR Options+2
	test	eax, eax
	je	SHORT $LN2@omf_write_

; 1570 :         omf_write_debug_tables();

	call	omf_write_debug_tables
$LN2@omf_write_:

; 1571 :     omf_write_modend( modinfo->g.start_fixup, modinfo->g.start_displ );

	mov	rax, QWORD PTR modinfo$[rsp]
	mov	edx, DWORD PTR [rax+216]
	mov	rax, QWORD PTR modinfo$[rsp]
	mov	rcx, QWORD PTR [rax+208]
	call	omf_write_modend

; 1572 : #if FASTMEM==0
; 1573 :     LclFree( modinfo->g.start_fixup );
; 1574 : #endif
; 1575 : 
; 1576 : #if TRUNCATE
; 1577 :     /* under some very rare conditions, the object
; 1578 :      * module might become shorter! Hence the file
; 1579 :      * must be truncated now. The problem is that there
; 1580 :      * is no stream function for this task.
; 1581 :      * the final solution will be to save the segment contents
; 1582 :      * in buffers and write the object module once everything
; 1583 :      * is done ( as it is done for the other formats already).
; 1584 :      * v2.03: most likely no longer necessary, since the file
; 1585 :      * won't become shorter anymore.
; 1586 :      */
; 1587 :     size = ftell( CurrFile[OBJ] );

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rcx, QWORD PTR [rcx+rax]
	call	ftell
	mov	DWORD PTR size$[rsp], eax

; 1588 : #if defined(__UNIX__) || defined(__CYGWIN__) || defined(__DJGPP__)
; 1589 :     fh = fileno( CurrFile[OBJ] );
; 1590 :     if ( ftruncate( fh, size ) ); /* gcc warns if return value of ftruncate() is "ignored" */
; 1591 : #elif defined(__BORLANDC__)
; 1592 :     fh = _fileno( CurrFile[OBJ] );
; 1593 :     chsize( fh, size );
; 1594 : #else
; 1595 :     fh = _fileno( CurrFile[OBJ] );

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	mov	rcx, QWORD PTR [rcx+rax]
	call	_fileno
	mov	DWORD PTR fh$[rsp], eax

; 1596 :     _chsize( fh, size );

	mov	edx, DWORD PTR size$[rsp]
	mov	ecx, DWORD PTR fh$[rsp]
	call	_chsize

; 1597 : #endif
; 1598 : 
; 1599 : #endif
; 1600 : 
; 1601 :     /* write SEGDEF records. Since these records contain the segment's length,
; 1602 :      * the records have to be written again after the final assembly pass.
; 1603 :      */
; 1604 :     fseek( CurrFile[OBJ] , seg_pos, SEEK_SET );

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	xor	r8d, r8d
	mov	edx, DWORD PTR seg_pos
	mov	rcx, QWORD PTR [rcx+rax]
	call	fseek

; 1605 :     omf_write_segdef();

	call	omf_write_segdef

; 1606 :     /* write PUBDEF records. Since the final value of offsets isn't known after
; 1607 :      * the first pass, this has to be called again after the final pass.
; 1608 :      */
; 1609 :     fseek( CurrFile[OBJ], public_pos, SEEK_SET);

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	xor	r8d, r8d
	mov	edx, DWORD PTR public_pos
	mov	rcx, QWORD PTR [rcx+rax]
	call	fseek

; 1610 :     omf_write_pubdef();

	call	omf_write_pubdef

; 1611 :     return( NOT_ERROR );

	xor	eax, eax

; 1612 : }

	add	rsp, 56					; 00000038H
	ret	0
omf_write_module ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
tv91 = 32
tv83 = 40
omf_write_debug_tables PROC

; 1547 : {

	sub	rsp, 56					; 00000038H

; 1548 :     if ( SymDebSeg[DBGS_SYMBOLS] && SymDebSeg[DBGS_TYPES] ) {

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymDebSeg
	cmp	QWORD PTR [rcx+rax], 0
	je	$LN2@omf_write_
	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymDebSeg
	cmp	QWORD PTR [rcx+rax], 0
	je	$LN2@omf_write_

; 1549 :         SymDebSeg[DBGS_SYMBOLS]->e.seginfo->CodeBuffer = CurrSource;

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymDebSeg
	mov	rax, QWORD PTR [rcx+rax]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR ModuleInfo+464
	mov	QWORD PTR [rax+16], rcx

; 1550 :         SymDebSeg[DBGS_TYPES]->e.seginfo->CodeBuffer = CurrSource + 1024;

	mov	rax, QWORD PTR ModuleInfo+464
	add	rax, 1024				; 00000400H
	mov	ecx, 8
	imul	rcx, rcx, 1
	lea	rdx, OFFSET FLAT:SymDebSeg
	mov	rcx, QWORD PTR [rdx+rcx]
	mov	rcx, QWORD PTR [rcx+104]
	mov	QWORD PTR [rcx+16], rax

; 1551 :         cv_write_debug_tables( SymDebSeg[DBGS_SYMBOLS], SymDebSeg[DBGS_TYPES], NULL );

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymDebSeg
	mov	edx, 8
	imul	rdx, rdx, 0
	mov	QWORD PTR tv83[rsp], rdx
	lea	r8, OFFSET FLAT:SymDebSeg
	mov	QWORD PTR tv91[rsp], r8
	xor	r8d, r8d
	mov	rdx, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR tv91[rsp]
	mov	rax, QWORD PTR tv83[rsp]
	mov	rcx, QWORD PTR [rcx+rax]
	call	cv_write_debug_tables
$LN2@omf_write_:

; 1552 :     }
; 1553 : }

	add	rsp, 56					; 00000038H
	ret	0
omf_write_debug_tables ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
i$ = 48
tv75 = 56
tv139 = 64
tv85 = 72
obj$ = 80
__$ArrayPad$ = 128
omf_write_header_dbgcv PROC

; 1525 : {

	sub	rsp, 152				; 00000098H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1526 :     int i;
; 1527 :     struct omf_rec obj;
; 1528 : 
; 1529 :     omf_InitRec( &obj, CMD_COMENT );

	mov	dl, 136					; 00000088H
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 1530 :     obj.d.coment.attr = 0x00;

	mov	BYTE PTR obj$[rsp+20], 0

; 1531 :     obj.d.coment.cmt_class = CMT_MS_OMF; /* MS extensions present */

	mov	BYTE PTR obj$[rsp+21], 161		; 000000a1H

; 1532 :     AttachData( &obj, "\001CV", 3 );

	mov	r8d, 3
	lea	rdx, OFFSET FLAT:$SG12810
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 1533 :     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record

; 1534 :     for ( i = 0; i < DBGS_MAX; i++ ) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@omf_write_
$LN2@omf_write_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@omf_write_:
	cmp	DWORD PTR i$[rsp], 2
	jge	$LN3@omf_write_

; 1535 :         if ( SymDebSeg[i] = (struct dsym *)CreateIntSegment( SymDebParm[i].name, SymDebParm[i].cname, 0, USE32, TRUE ) ) {

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:SymDebParm
	movsxd	rdx, DWORD PTR i$[rsp]
	imul	rdx, rdx, 16
	mov	QWORD PTR tv85[rsp], rdx
	lea	r8, OFFSET FLAT:SymDebParm
	mov	QWORD PTR tv139[rsp], r8
	mov	BYTE PTR [rsp+32], 1
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR [rcx+rax+8]
	mov	rcx, QWORD PTR tv139[rsp]
	mov	rax, QWORD PTR tv85[rsp]
	mov	rcx, QWORD PTR [rcx+rax]
	call	CreateIntSegment
	mov	QWORD PTR tv75[rsp], rax
	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:SymDebSeg
	mov	rdx, QWORD PTR tv75[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx
	cmp	QWORD PTR tv75[rsp], 0
	je	SHORT $LN5@omf_write_

; 1536 :             SymDebSeg[i]->e.seginfo->force32 = TRUE; /* without this a 32-bit segdef is emitted only if segsize > 64kB */

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:SymDebSeg
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+107]
	or	al, 4
	movsxd	rcx, DWORD PTR i$[rsp]
	lea	rdx, OFFSET FLAT:SymDebSeg
	mov	rcx, QWORD PTR [rdx+rcx*8]
	mov	rcx, QWORD PTR [rcx+104]
	mov	BYTE PTR [rcx+107], al

; 1537 :             SymDebSeg[i]->e.seginfo->flushfunc = omf_cv_flushfunc;

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:SymDebSeg
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	rax, QWORD PTR [rax+104]
	lea	rcx, OFFSET FLAT:omf_cv_flushfunc
	mov	QWORD PTR [rax+32], rcx
$LN5@omf_write_:

; 1538 :         }
; 1539 :     }

	jmp	$LN2@omf_write_
$LN3@omf_write_:

; 1540 :     return;
; 1541 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 152				; 00000098H
	ret	0
omf_write_header_dbgcv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
buffer$ = 32
seg$ = 64
curr$ = 72
size$ = 80
pv$ = 88
omf_cv_flushfunc PROC

; 1506 : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1507 :     uint_8 *buffer = seg->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR buffer$[rsp], rax

; 1508 : 
; 1509 :     if ( ( curr - buffer ) && ( ( curr - buffer ) + size ) > ( 1024 - 8 ) ) {

	mov	rax, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR curr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	test	rax, rax
	je	SHORT $LN2@omf_cv_flu
	mov	rax, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR curr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	ecx, DWORD PTR size$[rsp]
	add	rax, rcx
	cmp	rax, 1016				; 000003f8H
	jle	SHORT $LN2@omf_cv_flu

; 1510 :         seg->e.seginfo->current_loc = seg->e.seginfo->start_loc + ( curr - buffer );

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	rdx, QWORD PTR curr$[rsp]
	sub	rdx, rcx
	mov	rcx, rdx
	add	rax, rcx
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	DWORD PTR [rcx+12], eax

; 1511 :         omf_write_ledata( seg );

	mov	rcx, QWORD PTR seg$[rsp]
	call	omf_write_ledata

; 1512 :         return( buffer );

	mov	rax, QWORD PTR buffer$[rsp]
	jmp	SHORT $LN1@omf_cv_flu
$LN2@omf_cv_flu:

; 1513 :     }
; 1514 :     return( curr );

	mov	rax, QWORD PTR curr$[rsp]
$LN1@omf_cv_flu:

; 1515 : }

	add	rsp, 56					; 00000038H
	ret	0
omf_cv_flushfunc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
tv74 = 32
tv82 = 36
obj$ = 40
buffer$ = 88
__$ArrayPad$ = 104
fixup$ = 128
displ$ = 136
omf_write_modend PROC

; 1481 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1482 :     struct omf_rec  obj;
; 1483 :     uint_8 buffer[FIX_GEN_MODEND_MAX];
; 1484 : 
; 1485 :     DebugMsg(("omf_write_modend( fixup=%p, displ=%" I32_SPEC "X)\n", fixup, displ ));

	mov	r8d, DWORD PTR displ$[rsp]
	mov	rdx, QWORD PTR fixup$[rsp]
	lea	rcx, OFFSET FLAT:$SG12786
	call	DoDebugMsg

; 1486 : 
; 1487 :     omf_InitRec( &obj, CMD_MODEND );

	mov	dl, 138					; 0000008aH
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 1488 : 
; 1489 :     if( fixup == NULL ) {

	cmp	QWORD PTR fixup$[rsp], 0
	jne	SHORT $LN2@omf_write_

; 1490 :         obj.d.modend.main_module = FALSE;

	mov	BYTE PTR obj$[rsp+20], 0

; 1491 :         obj.d.modend.start_addrs = FALSE;

	mov	BYTE PTR obj$[rsp+21], 0

; 1492 :     } else {

	jmp	$LN3@omf_write_
$LN2@omf_write_:

; 1493 :         obj.d.modend.start_addrs = TRUE;

	mov	BYTE PTR obj$[rsp+21], 1

; 1494 :         obj.d.modend.main_module = TRUE;

	mov	BYTE PTR obj$[rsp+20], 1

; 1495 :         obj.is_32 = ( GetSymOfssize( fixup->sym ) > USE16 ? 1 : 0 ); /* USE16 or USE32 */

	mov	rax, QWORD PTR fixup$[rsp]
	mov	rcx, QWORD PTR [rax+56]
	call	GetSymOfssize
	test	eax, eax
	jle	SHORT $LN5@omf_write_
	mov	DWORD PTR tv74[rsp], 1
	jmp	SHORT $LN6@omf_write_
$LN5@omf_write_:
	mov	DWORD PTR tv74[rsp], 0
$LN6@omf_write_:
	movzx	eax, BYTE PTR tv74[rsp]
	mov	BYTE PTR obj$[rsp+17], al

; 1496 :         AttachData( &obj, buffer, 0 );

	xor	r8d, r8d
	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 1497 :         obj.length = OmfFixGenFixModend( fixup, buffer, displ, obj.is_32 ? FIX_GEN_MS386 : FIX_GEN_INTEL );

	movzx	eax, BYTE PTR obj$[rsp+17]
	test	eax, eax
	je	SHORT $LN7@omf_write_
	mov	DWORD PTR tv82[rsp], 1
	jmp	SHORT $LN8@omf_write_
$LN7@omf_write_:
	mov	DWORD PTR tv82[rsp], 0
$LN8@omf_write_:
	mov	r9d, DWORD PTR tv82[rsp]
	mov	r8d, DWORD PTR displ$[rsp]
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR fixup$[rsp]
	call	OmfFixGenFixModend
	mov	DWORD PTR obj$[rsp], eax
$LN3@omf_write_:

; 1498 :     }
; 1499 :     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record

; 1500 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
omf_write_modend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
is32$1 = 32
curr32$2 = 33
data$3 = 40
sym$4 = 48
len$5 = 56
size$6 = 60
tv144 = 64
tv156 = 68
q$ = 72
seg$7 = 80
curr_seg$8 = 88
recsize$9 = 96
obj$10 = 104
obj$11 = 152
__$ArrayPad$ = 200
omf_write_pubdef PROC

; 1369 : {

	sub	rsp, 216				; 000000d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1370 :     struct qnode        *q;
; 1371 : 
; 1372 :     DebugMsg1(("omf_write_pub enter\n"));

	lea	rcx, OFFSET FLAT:$SG12762
	call	DoDebugMsg1

; 1373 : 
; 1374 :     /* v2.07: struct pubdef_data has been modified to match
; 1375 :      * the data to be written to the object module more closely.
; 1376 :      * This fixed a possible overrun if too many publics were written.
; 1377 :      * v2.11: now the data matches exactly the OMF PUBDEF record
; 1378 :      * and is just attached.
; 1379 :      */
; 1380 : 
; 1381 :     q = ModuleInfo.g.PubQueue.head;

	mov	rax, QWORD PTR ModuleInfo+16
	mov	QWORD PTR q$[rsp], rax
$LN2@omf_write_:

; 1382 :     while ( q ) {

	cmp	QWORD PTR q$[rsp], 0
	je	$LN3@omf_write_

; 1383 :         struct asym     *curr_seg;
; 1384 :         uint_8          *data;
; 1385 :         unsigned        size;
; 1386 :         uint_8          curr32;
; 1387 :         uint_8          is32;
; 1388 : 
; 1389 :         for ( size = 0, data = StringBufferEnd; q; q = q->next ) {

	mov	DWORD PTR size$6[rsp], 0
	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR data$3[rsp], rax
	jmp	SHORT $LN6@omf_write_
$LN4@omf_write_:
	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR q$[rsp], rax
$LN6@omf_write_:
	cmp	QWORD PTR q$[rsp], 0
	je	$LN5@omf_write_

; 1390 :             unsigned    recsize;
; 1391 :             unsigned    len;
; 1392 :             struct asym *sym;
; 1393 :             sym = q->sym;

	mov	rax, QWORD PTR q$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR sym$4[rsp], rax

; 1394 : #if COMDATSUPP
; 1395 :             /* COMDAT symbol? Then write an LNAME record */
; 1396 :             if ( sym->segment && ((struct dsym *)sym->segment)->e.seginfo->comdat_selection ) {

	mov	rax, QWORD PTR sym$4[rsp]
	cmp	QWORD PTR [rax+32], 0
	je	$LN7@omf_write_
	mov	rax, QWORD PTR sym$4[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+108]
	shr	al, 3
	and	al, 7
	movzx	eax, al
	test	eax, eax
	je	$LN7@omf_write_

; 1397 :                 struct dsym *seg = (struct dsym *)sym->segment;

	mov	rax, QWORD PTR sym$4[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR seg$7[rsp], rax

; 1398 :                 if ( seg->e.seginfo->comdat_idx == 0 ) {

	mov	rax, QWORD PTR seg$7[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, WORD PTR [rax+88]
	test	eax, eax
	jne	$LN8@omf_write_

; 1399 :                     struct omf_rec obj;
; 1400 :                     seg->e.seginfo->comdat_idx = ++startitem;

	mov	eax, DWORD PTR startitem
	inc	eax
	mov	DWORD PTR startitem, eax
	mov	rax, QWORD PTR seg$7[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	ecx, WORD PTR startitem
	mov	WORD PTR [rax+88], cx

; 1401 :                     seg->sym.used = sym->used;

	mov	rax, QWORD PTR sym$4[rsp]
	movzx	eax, BYTE PTR [rax+48]
	and	al, 1
	and	al, 1
	mov	rcx, QWORD PTR seg$7[rsp]
	movzx	ecx, BYTE PTR [rcx+48]
	and	cl, 254					; 000000feH
	or	cl, al
	movzx	eax, cl
	mov	rcx, QWORD PTR seg$7[rsp]
	mov	BYTE PTR [rcx+48], al

; 1402 :                     omf_InitRec( &obj, CMD_LNAMES );

	mov	dl, 150					; 00000096H
	lea	rcx, QWORD PTR obj$11[rsp]
	call	omf_InitRec

; 1403 :                     len = Mangle( sym, StringBufferEnd + 1 );

	mov	rax, QWORD PTR ModuleInfo+488
	inc	rax
	mov	rdx, rax
	mov	rcx, QWORD PTR sym$4[rsp]
	call	Mangle
	mov	DWORD PTR len$5[rsp], eax

; 1404 :                     *StringBufferEnd = len;

	mov	rax, QWORD PTR ModuleInfo+488
	movzx	ecx, BYTE PTR len$5[rsp]
	mov	BYTE PTR [rax], cl

; 1405 :                     if ( ModuleInfo.case_sensitive == FALSE )

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN10@omf_write_

; 1406 :                         _strupr( StringBufferEnd + 1 );

	mov	rax, QWORD PTR ModuleInfo+488
	inc	rax
	mov	rcx, rax
	call	_strupr
$LN10@omf_write_:

; 1407 :                     AttachData( &obj, StringBufferEnd, len + 1 );

	mov	eax, DWORD PTR len$5[rsp]
	inc	eax
	mov	eax, eax
	mov	r8d, eax
	mov	rdx, QWORD PTR ModuleInfo+488
	lea	rcx, QWORD PTR obj$11[rsp]
	call	AttachData

; 1408 :                     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$11[rsp]
	call	omf_write_record
$LN8@omf_write_:

; 1409 :                 } else if ( Parse_Pass == PASS_1 ) {
; 1410 :                     /* ??? */
; 1411 :                 }
; 1412 :                 continue;

	jmp	$LN4@omf_write_
$LN7@omf_write_:

; 1413 :             }
; 1414 : #endif
; 1415 :             /* for constants, Masm checks if the value will fit in a 16-bit field,
; 1416 :              * either signed ( -32768 ... 32767 ) or unsigned ( 0 ... 65635 ).
; 1417 :              * As a result, the following code:
; 1418 :              * E1 equ 32768
; 1419 :              * E2 equ -32768
; 1420 :              * PUBLIC E1, E2
; 1421 :              * will store both equates with value 8000h in the 16-bit PUBDEF record!!!
; 1422 :              * HJWasm behaves differently, resulting in negative values to be stored as 32-bit.
; 1423 :              */
; 1424 : #if 1
; 1425 :             is32 = ( sym->offset > 0xffffUL ? 1 : 0 );

	mov	rax, QWORD PTR sym$4[rsp]
	cmp	DWORD PTR [rax+16], 65535		; 0000ffffH
	jbe	SHORT $LN21@omf_write_
	mov	DWORD PTR tv144[rsp], 1
	jmp	SHORT $LN22@omf_write_
$LN21@omf_write_:
	mov	DWORD PTR tv144[rsp], 0
$LN22@omf_write_:
	movzx	eax, BYTE PTR tv144[rsp]
	mov	BYTE PTR is32$1[rsp], al

; 1426 : #else
; 1427 :             is32 = ( sym->offset > 0xffff || sym->offset < -32768 ? 1 : 0 ); /* this is what Masm does */
; 1428 : #endif
; 1429 :             /* check if public fits in current record yet.
; 1430 :              * 4 bytes omf record overhead, 4 for base info, 1+1+4/2 for name_size, type & offset
; 1431 :              */
; 1432 :             recsize = size + sym->name_size + MANGLE_BYTES + 4+4+1+1+( is32 ? 4 : 2 );

	movzx	eax, BYTE PTR is32$1[rsp]
	test	eax, eax
	je	SHORT $LN23@omf_write_
	mov	DWORD PTR tv156[rsp], 4
	jmp	SHORT $LN24@omf_write_
$LN23@omf_write_:
	mov	DWORD PTR tv156[rsp], 2
$LN24@omf_write_:
	mov	rax, QWORD PTR sym$4[rsp]
	movzx	eax, BYTE PTR [rax+80]
	mov	ecx, DWORD PTR size$6[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR tv156[rsp]
	lea	eax, DWORD PTR [rax+rcx+18]
	mov	DWORD PTR recsize$9[rsp], eax

; 1433 :             /* exit loop if segment or offset magnitude changes, or record becomes too big */
; 1434 :             if( size && ( sym->segment != curr_seg || is32 != curr32 || recsize > MAX_PUB_LENGTH ) )

	cmp	DWORD PTR size$6[rsp], 0
	je	SHORT $LN12@omf_write_
	mov	rax, QWORD PTR sym$4[rsp]
	mov	rcx, QWORD PTR curr_seg$8[rsp]
	cmp	QWORD PTR [rax+32], rcx
	jne	SHORT $LN13@omf_write_
	movzx	eax, BYTE PTR is32$1[rsp]
	movzx	ecx, BYTE PTR curr32$2[rsp]
	cmp	eax, ecx
	jne	SHORT $LN13@omf_write_
	cmp	DWORD PTR recsize$9[rsp], 1024		; 00000400H
	jbe	SHORT $LN12@omf_write_
$LN13@omf_write_:

; 1435 :                 break;

	jmp	$LN5@omf_write_
$LN12@omf_write_:

; 1436 :             len = Mangle( sym, data + 1 );

	mov	rax, QWORD PTR data$3[rsp]
	inc	rax
	mov	rdx, rax
	mov	rcx, QWORD PTR sym$4[rsp]
	call	Mangle
	mov	DWORD PTR len$5[rsp], eax

; 1437 : #if MAX_ID_LEN > MAX_ID_LEN_OMF
; 1438 :             if ( len > 255 )
; 1439 :                 len = 255; /* length is 1 byte only */
; 1440 : #endif
; 1441 :             if ( ModuleInfo.convert_uppercase )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN14@omf_write_

; 1442 :                 _strupr( data + 1 );

	mov	rax, QWORD PTR data$3[rsp]
	inc	rax
	mov	rcx, rax
	call	_strupr
$LN14@omf_write_:

; 1443 :             curr_seg = sym->segment;

	mov	rax, QWORD PTR sym$4[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR curr_seg$8[rsp], rax

; 1444 :             curr32 = is32;

	movzx	eax, BYTE PTR is32$1[rsp]
	mov	BYTE PTR curr32$2[rsp], al

; 1445 : 
; 1446 :             *data = len;

	mov	rax, QWORD PTR data$3[rsp]
	movzx	ecx, BYTE PTR len$5[rsp]
	mov	BYTE PTR [rax], cl

; 1447 :             data += len + 1;

	mov	eax, DWORD PTR len$5[rsp]
	inc	eax
	mov	eax, eax
	mov	rcx, QWORD PTR data$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR data$3[rsp], rax

; 1448 :             if ( curr32 ) {

	movzx	eax, BYTE PTR curr32$2[rsp]
	test	eax, eax
	je	SHORT $LN15@omf_write_

; 1449 :                 *(uint_32 *)data = sym->offset;

	mov	rax, QWORD PTR data$3[rsp]
	mov	rcx, QWORD PTR sym$4[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	mov	DWORD PTR [rax], ecx

; 1450 :                 data += sizeof( uint_32 );

	mov	rax, QWORD PTR data$3[rsp]
	add	rax, 4
	mov	QWORD PTR data$3[rsp], rax

; 1451 :             } else {

	jmp	SHORT $LN16@omf_write_
$LN15@omf_write_:

; 1452 :                 *(uint_16 *)data = sym->offset;

	mov	rax, QWORD PTR data$3[rsp]
	mov	rcx, QWORD PTR sym$4[rsp]
	movzx	ecx, WORD PTR [rcx+16]
	mov	WORD PTR [rax], cx

; 1453 :                 data += sizeof( uint_16 );

	mov	rax, QWORD PTR data$3[rsp]
	add	rax, 2
	mov	QWORD PTR data$3[rsp], rax
$LN16@omf_write_:

; 1454 :             }
; 1455 :             *data++ = 0; /* type field */

	mov	rax, QWORD PTR data$3[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR data$3[rsp]
	inc	rax
	mov	QWORD PTR data$3[rsp], rax

; 1456 :             size = (char *)data - StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	rcx, QWORD PTR data$3[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR size$6[rsp], eax

; 1457 :         }

	jmp	$LN4@omf_write_
$LN5@omf_write_:

; 1458 :         if ( size ) {

	cmp	DWORD PTR size$6[rsp], 0
	je	SHORT $LN17@omf_write_

; 1459 :             struct omf_rec      obj;
; 1460 :             omf_InitRec( &obj, CMD_PUBDEF );

	mov	dl, 144					; 00000090H
	lea	rcx, QWORD PTR obj$10[rsp]
	call	omf_InitRec

; 1461 :             AttachData( &obj, StringBufferEnd, size );

	mov	eax, DWORD PTR size$6[rsp]
	mov	r8d, eax
	mov	rdx, QWORD PTR ModuleInfo+488
	lea	rcx, QWORD PTR obj$10[rsp]
	call	AttachData

; 1462 :             obj.is_32 = curr32;

	movzx	eax, BYTE PTR curr32$2[rsp]
	mov	BYTE PTR obj$10[rsp+17], al

; 1463 :             if( curr_seg == NULL ) { /* absolute symbol, no segment */

	cmp	QWORD PTR curr_seg$8[rsp], 0
	jne	SHORT $LN18@omf_write_

; 1464 :                 obj.d.pubdef.base.grp_idx = 0;

	xor	eax, eax
	mov	WORD PTR obj$10[rsp+20], ax

; 1465 :                 obj.d.pubdef.base.seg_idx = 0;

	xor	eax, eax
	mov	WORD PTR obj$10[rsp+22], ax

; 1466 :             } else {

	jmp	SHORT $LN19@omf_write_
$LN18@omf_write_:

; 1467 :                 obj.d.pubdef.base.seg_idx = GetSegIdx( curr_seg );

	mov	rcx, QWORD PTR curr_seg$8[rsp]
	call	GetSegIdx
	mov	WORD PTR obj$10[rsp+22], ax

; 1468 :                 obj.d.pubdef.base.grp_idx = omf_GetGrpIdx( GetGroup( curr_seg ) );

	mov	rcx, QWORD PTR curr_seg$8[rsp]
	call	GetGroup
	mov	rcx, rax
	call	omf_GetGrpIdx
	mov	WORD PTR obj$10[rsp+20], ax
$LN19@omf_write_:

; 1469 :             }
; 1470 :             obj.d.pubdef.base.frame = 0;

	xor	eax, eax
	mov	WORD PTR obj$10[rsp+24], ax

; 1471 :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$10[rsp]
	call	omf_write_record
$LN17@omf_write_:

; 1472 :         }
; 1473 :     }

	jmp	$LN2@omf_write_
$LN3@omf_write_:

; 1474 : 
; 1475 :     DebugMsg1(("omf_write_pub exit\n"));

	lea	rcx, OFFSET FLAT:$SG12776
	call	DoDebugMsg1

; 1476 :     return( NOT_ERROR );

	xor	eax, eax

; 1477 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 216				; 000000d8H
	ret	0
omf_write_pubdef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
len1$ = 32
len2$ = 33
p$ = 40
curr$ = 48
obj$ = 56
tmp$ = 112
buff$ = 368
__$ArrayPad$ = 864
omf_write_alias PROC

; 1318 : {

	sub	rsp, 888				; 00000378H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1319 :     struct omf_rec      obj;
; 1320 :     char                *p;
; 1321 :     uint_8              len1;
; 1322 :     uint_8              len2;
; 1323 :     //bool                first = TRUE;
; 1324 :     struct dsym         *curr;
; 1325 :     char                tmp[MAX_ID_LEN + MANGLE_BYTES + 1];
; 1326 :     unsigned char       buff[2*MAX_ID_LEN_OMF + 2];
; 1327 : 
; 1328 :     for( curr = SymTables[TAB_ALIAS].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 5
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@omf_write_
$LN2@omf_write_:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rsp], rax
$LN4@omf_write_:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN3@omf_write_

; 1329 : 
; 1330 :         /* output an alias record for this alias */
; 1331 :         /* v2.10: use the decorated names */
; 1332 :         //len1 = curr->sym.name_size;
; 1333 :         len1 = Mangle( &curr->sym, tmp );

	mov	rax, QWORD PTR curr$[rsp]
	lea	rdx, QWORD PTR tmp$[rsp]
	mov	rcx, rax
	call	Mangle
	mov	BYTE PTR len1$[rsp], al

; 1334 : #if MAX_ID_LEN > MAX_ID_LEN_OMF
; 1335 :         if ( len1 > MAX_ID_LEN_OMF )
; 1336 :             len1 = MAX_ID_LEN_OMF;
; 1337 : #endif
; 1338 :         p = buff;

	lea	rax, QWORD PTR buff$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 1339 :         *p++ = len1;

	mov	rax, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR len1$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 1340 :         memcpy( p, tmp, len1 );

	movzx	eax, BYTE PTR len1$[rsp]
	mov	r8d, eax
	lea	rdx, QWORD PTR tmp$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	memcpy

; 1341 :         p += len1;

	movzx	eax, BYTE PTR len1$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax

; 1342 : 
; 1343 :         //len2 = curr->sym.substitute->name_size;
; 1344 :         len2 = Mangle( curr->sym.substitute, tmp );

	lea	rdx, QWORD PTR tmp$[rsp]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	Mangle
	mov	BYTE PTR len2$[rsp], al

; 1345 : #if MAX_ID_LEN > MAX_ID_LEN_OMF
; 1346 :         if ( len2 > MAX_ID_LEN_OMF )
; 1347 :             len2 = MAX_ID_LEN_OMF;
; 1348 : #endif
; 1349 :         *p++ = len2;

	mov	rax, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR len2$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 1350 :         memcpy( p, tmp, len2 );

	movzx	eax, BYTE PTR len2$[rsp]
	mov	r8d, eax
	lea	rdx, QWORD PTR tmp$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	call	memcpy

; 1351 : 
; 1352 :         omf_InitRec( &obj, CMD_ALIAS );

	mov	dl, 198					; 000000c6H
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 1353 :         AttachData( &obj, buff, len1 + len2 + 2 );

	movzx	eax, BYTE PTR len1$[rsp]
	movzx	ecx, BYTE PTR len2$[rsp]
	lea	eax, DWORD PTR [rax+rcx+2]
	cdqe
	mov	r8, rax
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 1354 :         omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record

; 1355 :         //first = FALSE;
; 1356 :     }

	jmp	$LN2@omf_write_
$LN3@omf_write_:

; 1357 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 888				; 00000378H
	ret	0
omf_write_alias ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
len$ = 32
idx$ = 36
curr$ = 40
p$ = 48
obj$ = 56
__$ArrayPad$ = 104
omf_write_autodep PROC

; 1279 : {

	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1280 :     struct omf_rec  obj;
; 1281 :     struct fname_item *curr;
; 1282 :     char            *p = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR p$[rsp], rax

; 1283 :     unsigned int    len;
; 1284 :     unsigned        idx;
; 1285 : 
; 1286 :     DebugMsg(("omf_write_autodep() enter\n"));

	lea	rcx, OFFSET FLAT:$SG12716
	call	DoDebugMsg

; 1287 :     for( idx = 0, curr = ModuleInfo.g.FNames; idx < ModuleInfo.g.cnt_fnames; idx++, curr++ ) {

	mov	DWORD PTR idx$[rsp], 0
	mov	rax, QWORD PTR ModuleInfo+160
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@omf_write_
$LN2@omf_write_:
	mov	eax, DWORD PTR idx$[rsp]
	inc	eax
	mov	DWORD PTR idx$[rsp], eax
	mov	rax, QWORD PTR curr$[rsp]
	add	rax, 16
	mov	QWORD PTR curr$[rsp], rax
$LN4@omf_write_:
	mov	eax, DWORD PTR ModuleInfo+168
	cmp	DWORD PTR idx$[rsp], eax
	jae	$LN3@omf_write_

; 1288 :         omf_InitRec( &obj, CMD_COMENT );

	mov	dl, 136					; 00000088H
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 1289 :         obj.d.coment.attr = CMT_TNP;

	mov	BYTE PTR obj$[rsp+20], 128		; 00000080H

; 1290 :         obj.d.coment.cmt_class = CMT_DEPENDENCY; /* 0xE9 */

	mov	BYTE PTR obj$[rsp+21], 233		; 000000e9H

; 1291 : 
; 1292 :         len = strlen( curr->fname );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	strlen
	mov	DWORD PTR len$[rsp], eax

; 1293 : #if MAX_STRING_LEN > 255
; 1294 :         if ( len > 255 )

	cmp	DWORD PTR len$[rsp], 255		; 000000ffH
	jbe	SHORT $LN5@omf_write_

; 1295 :             len = 255; /* length is 1 byte only */

	mov	DWORD PTR len$[rsp], 255		; 000000ffH
$LN5@omf_write_:

; 1296 : #endif
; 1297 :         /* v2.11: field mtime removed, timestamp read when needed */
; 1298 :         //*((time_t *)p) = timet2dostime( curr->mtime );
; 1299 :         *((time_t *)p) = timet2dostime( GetFileTimeStamp( curr->fname ) );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	GetFileTimeStamp
	mov	rcx, rax
	call	timet2dostime
	mov	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR [rcx], rax

; 1300 :         *(p + 4) = (unsigned char)len;

	mov	rax, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR len$[rsp]
	mov	BYTE PTR [rax+4], cl

; 1301 :         memcpy( p + 5, curr->fname, len );

	mov	eax, DWORD PTR len$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, 5
	mov	r8d, eax
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax]
	call	memcpy

; 1302 :         AttachData( &obj, (uint_8 *)p, len + 5 );

	mov	eax, DWORD PTR len$[rsp]
	add	eax, 5
	mov	eax, eax
	mov	r8d, eax
	mov	rdx, QWORD PTR p$[rsp]
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 1303 :         DebugMsg(("omf_write_autodep(): write record: file=%s, time=%X\n", curr->fname, *((time_t *)p) ));

	mov	rax, QWORD PTR p$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG12718
	call	DoDebugMsg

; 1304 :         omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record

; 1305 :     }

	jmp	$LN2@omf_write_
$LN3@omf_write_:

; 1306 :     /* one NULL dependency record must be on the end */
; 1307 :     omf_InitRec( &obj, CMD_COMENT );

	mov	dl, 136					; 00000088H
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 1308 :     obj.d.coment.attr = CMT_TNP;

	mov	BYTE PTR obj$[rsp+20], 128		; 00000080H

; 1309 :     obj.d.coment.cmt_class = CMT_DEPENDENCY;

	mov	BYTE PTR obj$[rsp+21], 233		; 000000e9H

; 1310 :     AttachData( &obj, (uint_8 *)"", 0 );

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:$SG12719
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 1311 :     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record

; 1312 :     DebugMsg(("omf_write_autodep() exit\n"));

	lea	rcx, OFFSET FLAT:$SG12720
	call	DoDebugMsg

; 1313 :     return( NOT_ERROR );

	xor	eax, eax

; 1314 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
omf_write_autodep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
statbuf$ = 32
__$ArrayPad$ = 80
filename$ = 112
GetFileTimeStamp PROC

; 1263 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1264 :     struct _stat statbuf;
; 1265 : 
; 1266 :     if( _stat( filename, &statbuf ) != 0 ) {

	lea	rdx, QWORD PTR statbuf$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	call	_stat64i32
	test	eax, eax
	je	SHORT $LN2@GetFileTim

; 1267 :         DebugMsg(("GetFileTimeStamp(%s): _stat() did return 0\n", filename ));

	mov	rdx, QWORD PTR filename$[rsp]
	lea	rcx, OFFSET FLAT:$SG12699
	call	DoDebugMsg

; 1268 :         return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@GetFileTim
$LN2@GetFileTim:

; 1269 :     }
; 1270 :     return( statbuf.st_mtime );

	mov	rax, QWORD PTR statbuf$[rsp+32]
$LN1@GetFileTim:

; 1271 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
GetFileTimeStamp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
recsize$ = 48
numsize$ = 52
curr$ = 56
varsize$ = 64
num$ = 68
symsize$ = 72
start$ = 76
tv128 = 80
$T1 = 88
obj$ = 96
number$ = 144
buffer$ = 160
data$ = 416
__$ArrayPad$ = 1440
index$ = 1472
omf_write_comdef PROC

; 1179 : {

	mov	WORD PTR [rsp+8], cx
	sub	rsp, 1464				; 000005b8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1180 :     struct omf_rec obj;
; 1181 :     struct dsym    *curr;
; 1182 :     unsigned    num;
; 1183 :     unsigned    recsize;
; 1184 :     unsigned    numsize;
; 1185 :     unsigned    symsize;
; 1186 :     uint_32     varsize;
; 1187 :     unsigned    start = 0; /* record's start index (not used) */

	mov	DWORD PTR start$[rsp], 0

; 1188 :     char        buffer[MAX_ID_LEN + MANGLE_BYTES + 1];
; 1189 :     char        data[MAX_EXT_LENGTH];
; 1190 :     char        number[16];
; 1191 : 
; 1192 :     DebugMsg1(("omf_write_comdef enter\n"));

	lea	rcx, OFFSET FLAT:$SG12680
	call	DoDebugMsg1

; 1193 :     curr = SymTables[TAB_EXT].head;

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
$LN2@omf_write_:

; 1194 :     while ( curr ) {

	cmp	QWORD PTR curr$[rsp], 0
	je	$LN3@omf_write_

; 1195 :         for( num = 0, recsize = 0; curr != NULL ; curr = curr->next ) {

	mov	DWORD PTR num$[rsp], 0
	mov	DWORD PTR recsize$[rsp], 0
	jmp	SHORT $LN6@omf_write_
$LN4@omf_write_:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rsp], rax
$LN6@omf_write_:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN5@omf_write_

; 1196 :             if ( curr->sym.iscomm == FALSE )

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@omf_write_

; 1197 :                 continue;

	jmp	SHORT $LN4@omf_write_
$LN7@omf_write_:

; 1198 :             symsize = Mangle( &curr->sym, buffer );

	mov	rax, QWORD PTR curr$[rsp]
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rax
	call	Mangle
	mov	DWORD PTR symsize$[rsp], eax

; 1199 : #if MAX_ID_LEN > 255
; 1200 :             if ( symsize > 255 )
; 1201 :                 symsize = 255; /* length is 1 byte only */
; 1202 : #endif
; 1203 :             /* v2.11: case mapping was missing */
; 1204 :             if ( ModuleInfo.convert_uppercase )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@omf_write_

; 1205 :                 _strupr( buffer );

	lea	rcx, QWORD PTR buffer$[rsp]
	call	_strupr
$LN8@omf_write_:

; 1206 : 
; 1207 :             varsize = SizeFromMemtype( curr->sym.mem_type, ModuleInfo.Ofssize, curr->sym.type );

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	rcx, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rcx+88]
	mov	edx, eax
	mov	rax, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rax+44]
	call	SizeFromMemtype
	mov	DWORD PTR varsize$[rsp], eax

; 1208 : 
; 1209 :             /**/ myassert( index );

	movzx	eax, WORD PTR index$[rsp]
	test	eax, eax
	je	SHORT $LN15@omf_write_
	mov	DWORD PTR tv128[rsp], 0
	jmp	SHORT $LN16@omf_write_
$LN15@omf_write_:
	mov	edx, 1209				; 000004b9H
	lea	rcx, OFFSET FLAT:$SG12683
	call	InternalError
	mov	DWORD PTR tv128[rsp], eax
$LN16@omf_write_:

; 1210 :             curr->sym.ext_idx = index++; /* v2.09: set external index here */

	movzx	eax, WORD PTR index$[rsp]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	DWORD PTR [rcx+96], eax
	movzx	eax, WORD PTR index$[rsp]
	inc	ax
	mov	WORD PTR index$[rsp], ax

; 1211 : 
; 1212 :             DebugMsg1(("omf_write_comdef: %s, size=%u, sym.total_size=%u, sym.total_length=%u, sym.isfar=%u\n",

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+72]
	mov	DWORD PTR [rsp+32], eax
	mov	rax, QWORD PTR curr$[rsp]
	mov	r9d, DWORD PTR [rax+64]
	mov	r8d, DWORD PTR varsize$[rsp]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12684
	call	DoDebugMsg1

; 1213 :                       curr->sym.name, varsize, curr->sym.total_size, curr->sym.total_length, curr->sym.isfar ));
; 1214 :             if ( varsize == 0 )

	cmp	DWORD PTR varsize$[rsp], 0
	jne	SHORT $LN9@omf_write_

; 1215 :                 varsize = curr->sym.total_size / curr->sym.total_length;

	xor	edx, edx
	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	rcx, QWORD PTR curr$[rsp]
	div	DWORD PTR [rcx+72]
	mov	DWORD PTR varsize$[rsp], eax
$LN9@omf_write_:

; 1216 : 
; 1217 :             numsize = 1;

	mov	DWORD PTR numsize$[rsp], 1

; 1218 :             if ( curr->sym.isfar == TRUE ) {

	mov	rax, QWORD PTR curr$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 4
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	$LN10@omf_write_

; 1219 :                 number[0] = COMDEF_FAR;  /* 0x61 */

	mov	eax, 1
	imul	rax, rax, 0
	mov	BYTE PTR number$[rsp+rax], 97		; 00000061H

; 1220 :                 numsize += put_comdef_number( &number[1], curr->sym.total_length );

	mov	eax, 1
	imul	rax, rax, 1
	lea	rax, QWORD PTR number$[rsp+rax]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	edx, DWORD PTR [rcx+72]
	mov	rcx, rax
	call	put_comdef_number
	mov	ecx, DWORD PTR numsize$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR numsize$[rsp], eax

; 1221 :                 numsize += put_comdef_number( &number[numsize], varsize );

	mov	eax, DWORD PTR numsize$[rsp]
	lea	rax, QWORD PTR number$[rsp+rax]
	mov	edx, DWORD PTR varsize$[rsp]
	mov	rcx, rax
	call	put_comdef_number
	mov	ecx, DWORD PTR numsize$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR numsize$[rsp], eax

; 1222 :                 DebugMsg(("omf_write_comdef: numsize=%u, length=%u, varsize=%u\n",

	mov	r9d, DWORD PTR varsize$[rsp]
	mov	rax, QWORD PTR curr$[rsp]
	mov	r8d, DWORD PTR [rax+72]
	mov	edx, DWORD PTR numsize$[rsp]
	lea	rcx, OFFSET FLAT:$SG12688
	call	DoDebugMsg

; 1223 :                           numsize, curr->sym.total_length, varsize ));
; 1224 :             } else {

	jmp	SHORT $LN11@omf_write_
$LN10@omf_write_:

; 1225 :                 number[0] = COMDEF_NEAR; /* 0x62 */

	mov	eax, 1
	imul	rax, rax, 0
	mov	BYTE PTR number$[rsp+rax], 98		; 00000062H

; 1226 :                 numsize += put_comdef_number( &number[1], curr->sym.total_length * varsize );

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+72]
	imul	eax, DWORD PTR varsize$[rsp]
	mov	ecx, 1
	imul	rcx, rcx, 1
	lea	rcx, QWORD PTR number$[rsp+rcx]
	mov	edx, eax
	call	put_comdef_number
	mov	ecx, DWORD PTR numsize$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR numsize$[rsp], eax

; 1227 :                 DebugMsg1(("omf_write_comdef: numsize=%u, value=%u\n",

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+72]
	imul	eax, DWORD PTR varsize$[rsp]
	mov	r8d, eax
	mov	edx, DWORD PTR numsize$[rsp]
	lea	rcx, OFFSET FLAT:$SG12689
	call	DoDebugMsg1
$LN11@omf_write_:

; 1228 :                           numsize, curr->sym.total_length * varsize ));
; 1229 :             }
; 1230 :             /* make sure the record's size doesn't exceed 1024.
; 1231 :              * 2 = 1 (name len) + 1 (type index)
; 1232 :              */
; 1233 :             if ( ( recsize + symsize + numsize + 2 ) > MAX_EXT_LENGTH )

	mov	eax, DWORD PTR symsize$[rsp]
	mov	ecx, DWORD PTR recsize$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR numsize$[rsp]
	lea	eax, DWORD PTR [rax+rcx+2]
	cmp	eax, 1020				; 000003fcH
	jbe	SHORT $LN12@omf_write_

; 1234 :                 break;

	jmp	$LN5@omf_write_
$LN12@omf_write_:

; 1235 : 
; 1236 :             /* copy name ( including size prefix ), type, number */
; 1237 :             data[recsize++] = (char)symsize;

	mov	eax, DWORD PTR recsize$[rsp]
	movzx	ecx, BYTE PTR symsize$[rsp]
	mov	BYTE PTR data$[rsp+rax], cl
	mov	eax, DWORD PTR recsize$[rsp]
	inc	eax
	mov	DWORD PTR recsize$[rsp], eax

; 1238 :             memcpy( data + recsize, buffer, symsize );

	mov	eax, DWORD PTR symsize$[rsp]
	mov	ecx, DWORD PTR recsize$[rsp]
	lea	rcx, QWORD PTR data$[rsp+rcx]
	mov	r8d, eax
	lea	rdx, QWORD PTR buffer$[rsp]
	call	memcpy

; 1239 :             recsize += symsize;

	mov	eax, DWORD PTR symsize$[rsp]
	mov	ecx, DWORD PTR recsize$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR recsize$[rsp], eax

; 1240 :             data[recsize++] = 0;      /* for the type index */

	mov	eax, DWORD PTR recsize$[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	eax, DWORD PTR recsize$[rsp]
	inc	eax
	mov	DWORD PTR recsize$[rsp], eax
	cmp	QWORD PTR $T1[rsp], 1020		; 000003fcH
	jae	SHORT $LN17@omf_write_
	jmp	SHORT $LN18@omf_write_
$LN17@omf_write_:
	call	__report_rangecheckfailure
$LN18@omf_write_:
	mov	rax, QWORD PTR $T1[rsp]
	mov	BYTE PTR data$[rsp+rax], 0

; 1241 :             memcpy( data + recsize, number, numsize );

	mov	eax, DWORD PTR numsize$[rsp]
	mov	ecx, DWORD PTR recsize$[rsp]
	lea	rcx, QWORD PTR data$[rsp+rcx]
	mov	r8d, eax
	lea	rdx, QWORD PTR number$[rsp]
	call	memcpy

; 1242 :             recsize += numsize;

	mov	eax, DWORD PTR numsize$[rsp]
	mov	ecx, DWORD PTR recsize$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR recsize$[rsp], eax

; 1243 : 
; 1244 :             num++;

	mov	eax, DWORD PTR num$[rsp]
	inc	eax
	mov	DWORD PTR num$[rsp], eax

; 1245 : 
; 1246 :         } /* end for */

	jmp	$LN4@omf_write_
$LN5@omf_write_:

; 1247 : 
; 1248 :         if( num > 0 ) {

	cmp	DWORD PTR num$[rsp], 0
	jbe	SHORT $LN13@omf_write_

; 1249 :             omf_InitRec( &obj, CMD_COMDEF );

	mov	dl, 176					; 000000b0H
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 1250 :             obj.d.comdef.first_idx = start; /* unused */

	movzx	eax, WORD PTR start$[rsp]
	mov	WORD PTR obj$[rsp+20], ax

; 1251 :             AttachData( &obj, (uint_8 *)data, recsize );

	mov	eax, DWORD PTR recsize$[rsp]
	mov	r8d, eax
	lea	rdx, QWORD PTR data$[rsp]
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 1252 :             obj.d.comdef.num_names = num; /* unused */

	movzx	eax, WORD PTR num$[rsp]
	mov	WORD PTR obj$[rsp+22], ax

; 1253 :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record

; 1254 :             start += num;

	mov	eax, DWORD PTR num$[rsp]
	mov	ecx, DWORD PTR start$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR start$[rsp], eax
$LN13@omf_write_:

; 1255 :         }
; 1256 :     }

	jmp	$LN2@omf_write_
$LN3@omf_write_:

; 1257 :     DebugMsg1(("omf_write_comdef exit\n"));

	lea	rcx, OFFSET FLAT:$SG12692
	call	DoDebugMsg1

; 1258 :     return( index );

	movzx	eax, WORD PTR index$[rsp]
$LN14@omf_write_:

; 1259 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1464				; 000005b8H
	ret	0
omf_write_comdef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
tv66 = 32
i$ = 36
symsize$ = 40
buffer$ = 64
value$ = 72
put_comdef_number PROC

; 1149 : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1150 :     unsigned i;
; 1151 :     unsigned symsize;
; 1152 : 
; 1153 :     symsize = get_size_of_comdef_number( value );

	mov	ecx, DWORD PTR value$[rsp]
	call	get_size_of_comdef_number
	mov	DWORD PTR symsize$[rsp], eax

; 1154 :     switch( symsize ) {

	mov	eax, DWORD PTR symsize$[rsp]
	mov	DWORD PTR tv66[rsp], eax
	cmp	DWORD PTR tv66[rsp], 1
	je	SHORT $LN7@put_comdef
	cmp	DWORD PTR tv66[rsp], 3
	je	SHORT $LN8@put_comdef
	cmp	DWORD PTR tv66[rsp], 4
	je	SHORT $LN9@put_comdef
	cmp	DWORD PTR tv66[rsp], 5
	je	SHORT $LN10@put_comdef
	jmp	SHORT $LN2@put_comdef
$LN7@put_comdef:

; 1155 :     case 1:  *buffer = value; break;

	mov	rax, QWORD PTR buffer$[rsp]
	movzx	ecx, BYTE PTR value$[rsp]
	mov	BYTE PTR [rax], cl
	jmp	SHORT $LN2@put_comdef
$LN8@put_comdef:

; 1156 :     case 3:  *buffer++ = COMDEF_LEAF_2;  break; /* 0x81 */

	mov	rax, QWORD PTR buffer$[rsp]
	mov	BYTE PTR [rax], 129			; 00000081H
	mov	rax, QWORD PTR buffer$[rsp]
	inc	rax
	mov	QWORD PTR buffer$[rsp], rax
	jmp	SHORT $LN2@put_comdef
$LN9@put_comdef:

; 1157 :     case 4:  *buffer++ = COMDEF_LEAF_3;  break; /* 0x84 */

	mov	rax, QWORD PTR buffer$[rsp]
	mov	BYTE PTR [rax], 132			; 00000084H
	mov	rax, QWORD PTR buffer$[rsp]
	inc	rax
	mov	QWORD PTR buffer$[rsp], rax
	jmp	SHORT $LN2@put_comdef
$LN10@put_comdef:

; 1158 :     case 5:  *buffer++ = COMDEF_LEAF_4;  break; /* 0x88 */

	mov	rax, QWORD PTR buffer$[rsp]
	mov	BYTE PTR [rax], 136			; 00000088H
	mov	rax, QWORD PTR buffer$[rsp]
	inc	rax
	mov	QWORD PTR buffer$[rsp], rax
$LN2@put_comdef:

; 1159 :     }
; 1160 : 
; 1161 :     for( i = 1; i < symsize; i++ ) {

	mov	DWORD PTR i$[rsp], 1
	jmp	SHORT $LN6@put_comdef
$LN4@put_comdef:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN6@put_comdef:
	mov	eax, DWORD PTR symsize$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	SHORT $LN5@put_comdef

; 1162 :         *buffer++ = value % ( UCHAR_MAX + 1 );

	xor	edx, edx
	mov	eax, DWORD PTR value$[rsp]
	mov	ecx, 256				; 00000100H
	div	ecx
	mov	eax, edx
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR buffer$[rsp]
	inc	rax
	mov	QWORD PTR buffer$[rsp], rax

; 1163 :         value >>= 8;

	mov	eax, DWORD PTR value$[rsp]
	shr	eax, 8
	mov	DWORD PTR value$[rsp], eax

; 1164 :     }

	jmp	SHORT $LN4@put_comdef
$LN5@put_comdef:

; 1165 :     return( symsize );

	mov	eax, DWORD PTR symsize$[rsp]

; 1166 : }

	add	rsp, 56					; 00000038H
	ret	0
put_comdef_number ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
value$ = 8
get_size_of_comdef_number PROC

; 1129 : {

	mov	DWORD PTR [rsp+8], ecx

; 1130 :     /* The spec allows up to 128 in a one byte size field, but lots
; 1131 :        of software has problems with that, so we'll restrict ourselves
; 1132 :        to 127.
; 1133 :     */
; 1134 :     if( value < 128 ) {

	cmp	DWORD PTR value$[rsp], 128		; 00000080H
	jae	SHORT $LN2@get_size_o

; 1135 :         return( 1 );    /* 1 byte value */

	mov	eax, 1
	jmp	SHORT $LN1@get_size_o
	jmp	SHORT $LN3@get_size_o
$LN2@get_size_o:

; 1136 :     } else if( value <= USHRT_MAX ) {

	cmp	DWORD PTR value$[rsp], 65535		; 0000ffffH
	ja	SHORT $LN4@get_size_o

; 1137 :         return( 3 );    /* 1 byte flag + 2 byte value */

	mov	eax, 3
	jmp	SHORT $LN1@get_size_o
	jmp	SHORT $LN5@get_size_o
$LN4@get_size_o:

; 1138 :     } else if( value <= THREE_BYTE_MAX ) {

	cmp	DWORD PTR value$[rsp], 16777215		; 00ffffffH
	ja	SHORT $LN6@get_size_o

; 1139 :         return( 4 );    /* 1 byte flag + 3 byte value */

	mov	eax, 4
	jmp	SHORT $LN1@get_size_o

; 1140 :     } else { /* if( value <= ULONG_MAX ) */

	jmp	SHORT $LN7@get_size_o
$LN6@get_size_o:

; 1141 :         return( 5 );    /* 1 byte flag + 4 byte value */

	mov	eax, 5
$LN7@get_size_o:
$LN5@get_size_o:
$LN3@get_size_o:
$LN1@get_size_o:

; 1142 :     }
; 1143 : }

	ret	0
get_size_of_comdef_number ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
rec_size$ = 32
symext$ = 40
len$ = 48
sym$ = 56
r$ = 64
$T1 = 80
obj$ = 88
buffer$ = 144
data$ = 400
__$ArrayPad$ = 1424
omf_write_extdef PROC

; 1035 : {

	sub	rsp, 1448				; 000005a8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1036 :     struct omf_rec obj;
; 1037 :     struct asym *sym;
; 1038 :     struct dsym *symext;
; 1039 :     unsigned    rec_size;
; 1040 :     unsigned    len;
; 1041 :     struct readext r;
; 1042 :     char        data[MAX_EXT_LENGTH];
; 1043 :     unsigned char buffer[MAX_ID_LEN + MANGLE_BYTES + 1];
; 1044 : 
; 1045 :     DebugMsg1(("omf_write_extdef enter\n"));

	lea	rcx, OFFSET FLAT:$SG12619
	call	DoDebugMsg1

; 1046 : 
; 1047 :     r.p = SymTables[TAB_EXT].head;

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR r$[rsp], rax

; 1048 :     r.index = 1;

	mov	eax, 1
	mov	WORD PTR r$[rsp+8], ax

; 1049 :     r.method = 0;

	mov	BYTE PTR r$[rsp+10], 0

; 1050 :     obj.d.extdef.first_idx = 0;

	xor	eax, eax
	mov	WORD PTR obj$[rsp+20], ax

; 1051 : 
; 1052 :     /* scan the EXTERN/EXTERNDEF items */
; 1053 : 
; 1054 :     sym = GetExt( &r );

	lea	rcx, QWORD PTR r$[rsp]
	call	GetExt
	mov	QWORD PTR sym$[rsp], rax
$LN2@omf_write_:

; 1055 :     while ( sym ) {

	cmp	QWORD PTR sym$[rsp], 0
	je	$LN3@omf_write_

; 1056 :         for ( rec_size = 0, obj.d.extdef.num_names = 0; sym; sym = GetExt( &r ) ) {

	mov	DWORD PTR rec_size$[rsp], 0
	xor	eax, eax
	mov	WORD PTR obj$[rsp+22], ax
	jmp	SHORT $LN6@omf_write_
$LN4@omf_write_:
	lea	rcx, QWORD PTR r$[rsp]
	call	GetExt
	mov	QWORD PTR sym$[rsp], rax
$LN6@omf_write_:
	cmp	QWORD PTR sym$[rsp], 0
	je	$LN5@omf_write_

; 1057 :             //DebugMsg(("omf_write_extdef: %s, weak=%u, used=%u\n", curr->sym.name, curr->sym.weak, curr->sym.used ));
; 1058 :             DebugMsg1(("omf_write_extdef: %s\n", sym->name));

	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12620
	call	DoDebugMsg1

; 1059 :             len = Mangle( sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	call	Mangle
	mov	DWORD PTR len$[rsp], eax

; 1060 : #if MAX_ID_LEN > 255
; 1061 :             if ( len > 255 )
; 1062 :                 len = 255; /* length is 1 byte only */
; 1063 : #endif
; 1064 :             if ( ModuleInfo.convert_uppercase )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN13@omf_write_

; 1065 :                 _strupr( buffer );

	lea	rcx, QWORD PTR buffer$[rsp]
	call	_strupr
$LN13@omf_write_:

; 1066 : 
; 1067 :             if( rec_size + len + 2 >= MAX_EXT_LENGTH ) {

	mov	eax, DWORD PTR rec_size$[rsp]
	mov	ecx, DWORD PTR len$[rsp]
	lea	eax, DWORD PTR [rax+rcx+2]
	cmp	eax, 1020				; 000003fcH
	jb	SHORT $LN14@omf_write_

; 1068 :                 break;

	jmp	$LN5@omf_write_
$LN14@omf_write_:

; 1069 :             }
; 1070 :             obj.d.extdef.num_names++;

	movzx	eax, WORD PTR obj$[rsp+22]
	inc	ax
	mov	WORD PTR obj$[rsp+22], ax

; 1071 : 
; 1072 :             data[rec_size++] = (char)len;

	mov	eax, DWORD PTR rec_size$[rsp]
	movzx	ecx, BYTE PTR len$[rsp]
	mov	BYTE PTR data$[rsp+rax], cl
	mov	eax, DWORD PTR rec_size$[rsp]
	inc	eax
	mov	DWORD PTR rec_size$[rsp], eax

; 1073 :             memcpy( data + rec_size, buffer, len );

	mov	eax, DWORD PTR len$[rsp]
	mov	ecx, DWORD PTR rec_size$[rsp]
	lea	rcx, QWORD PTR data$[rsp+rcx]
	mov	r8d, eax
	lea	rdx, QWORD PTR buffer$[rsp]
	call	memcpy

; 1074 :             rec_size += len;

	mov	eax, DWORD PTR len$[rsp]
	mov	ecx, DWORD PTR rec_size$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR rec_size$[rsp], eax

; 1075 :             data[rec_size++] = 0;      /* for the type index */

	mov	eax, DWORD PTR rec_size$[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	eax, DWORD PTR rec_size$[rsp]
	inc	eax
	mov	DWORD PTR rec_size$[rsp], eax
	cmp	QWORD PTR $T1[rsp], 1020		; 000003fcH
	jae	SHORT $LN19@omf_write_
	jmp	SHORT $LN20@omf_write_
$LN19@omf_write_:
	call	__report_rangecheckfailure
$LN20@omf_write_:
	mov	rax, QWORD PTR $T1[rsp]
	mov	BYTE PTR data$[rsp+rax], 0

; 1076 :         }

	jmp	$LN4@omf_write_
$LN5@omf_write_:

; 1077 :         if ( rec_size ) {

	cmp	DWORD PTR rec_size$[rsp], 0
	je	SHORT $LN15@omf_write_

; 1078 :             DebugMsg1(("omf_write_extdef: write record, names=%u, size=%u, MAX=%u\n", obj.d.extdef.num_names, rec_size, MAX_EXT_LENGTH ));

	movzx	eax, WORD PTR obj$[rsp+22]
	mov	r9d, 1020				; 000003fcH
	mov	r8d, DWORD PTR rec_size$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12624
	call	DoDebugMsg1

; 1079 :             omf_InitRec( &obj, CMD_EXTDEF );

	mov	dl, 140					; 0000008cH
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 1080 :             AttachData( &obj, (uint_8 *)data, rec_size );

	mov	eax, DWORD PTR rec_size$[rsp]
	mov	r8d, eax
	lea	rdx, QWORD PTR data$[rsp]
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 1081 :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record

; 1082 :             obj.d.extdef.first_idx += obj.d.extdef.num_names;

	movzx	eax, WORD PTR obj$[rsp+22]
	movzx	ecx, WORD PTR obj$[rsp+20]
	add	ecx, eax
	mov	eax, ecx
	mov	WORD PTR obj$[rsp+20], ax
$LN15@omf_write_:

; 1083 :         }
; 1084 :     }

	jmp	$LN2@omf_write_
$LN3@omf_write_:

; 1085 : 
; 1086 :     /* v2.04: write WKEXT coment records.
; 1087 :      * those items are defined via "EXTERN (altname)" syntax.
; 1088 :      * After the records have been written, the indices in
; 1089 :      * altname are no longer needed.
; 1090 :      */
; 1091 : 
; 1092 :     for ( symext = SymTables[TAB_EXT].head; symext; symext = symext->next ) {

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR symext$[rsp], rax
	jmp	SHORT $LN9@omf_write_
$LN7@omf_write_:
	mov	rax, QWORD PTR symext$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR symext$[rsp], rax
$LN9@omf_write_:
	cmp	QWORD PTR symext$[rsp], 0
	je	$LN8@omf_write_

; 1093 :         if ( symext->sym.iscomm == FALSE && symext->sym.altname ) {

	mov	rax, QWORD PTR symext$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN16@omf_write_
	mov	rax, QWORD PTR symext$[rsp]
	cmp	QWORD PTR [rax+72], 0
	je	SHORT $LN16@omf_write_

; 1094 :             omf_InitRec( &obj, CMD_COMENT );

	mov	dl, 136					; 00000088H
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 1095 :             obj.d.coment.attr = CMT_TNP;

	mov	BYTE PTR obj$[rsp+20], 128		; 00000080H

; 1096 :             obj.d.coment.cmt_class = CMT_WKEXT;

	mov	BYTE PTR obj$[rsp+21], 168		; 000000a8H

; 1097 :             AttachData( &obj, buffer, 4 );

	mov	r8d, 4
	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 1098 :             PutIndex( &obj, symext->sym.ext_idx1 );

	mov	rax, QWORD PTR symext$[rsp]
	movzx	eax, WORD PTR [rax+96]
	mov	edx, eax
	lea	rcx, QWORD PTR obj$[rsp]
	call	PutIndex

; 1099 :             PutIndex( &obj, symext->sym.altname->ext_idx2 );

	mov	rax, QWORD PTR symext$[rsp]
	mov	rax, QWORD PTR [rax+72]
	movzx	eax, WORD PTR [rax+98]
	mov	edx, eax
	lea	rcx, QWORD PTR obj$[rsp]
	call	PutIndex

; 1100 :             TruncRec( &obj );

	mov	eax, DWORD PTR obj$[rsp+4]
	mov	DWORD PTR obj$[rsp], eax

; 1101 :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record
$LN16@omf_write_:

; 1102 :         }
; 1103 :     }

	jmp	$LN7@omf_write_
$LN8@omf_write_:

; 1104 :     /* v2.05: reset the indices - this must be done only after ALL WKEXT
; 1105 :      * records have been written!
; 1106 :      */
; 1107 :     for ( symext = SymTables[TAB_EXT].head; symext; symext = symext->next ) {

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR symext$[rsp], rax
	jmp	SHORT $LN12@omf_write_
$LN10@omf_write_:
	mov	rax, QWORD PTR symext$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR symext$[rsp], rax
$LN12@omf_write_:
	cmp	QWORD PTR symext$[rsp], 0
	je	SHORT $LN11@omf_write_

; 1108 :             /* v2.09: don't touch the index if the alternate name is an external
; 1109 :              * - else an invalid object file will be created!
; 1110 :              */
; 1111 :         if ( symext->sym.iscomm == FALSE && symext->sym.altname && symext->sym.altname->state != SYM_EXTERNAL )

	mov	rax, QWORD PTR symext$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN17@omf_write_
	mov	rax, QWORD PTR symext$[rsp]
	cmp	QWORD PTR [rax+72], 0
	je	SHORT $LN17@omf_write_
	mov	rax, QWORD PTR symext$[rsp]
	mov	rax, QWORD PTR [rax+72]
	cmp	DWORD PTR [rax+40], 2
	je	SHORT $LN17@omf_write_

; 1112 :             symext->sym.altname->ext_idx = 0;

	mov	rax, QWORD PTR symext$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	DWORD PTR [rax+96], 0
$LN17@omf_write_:

; 1113 :     }

	jmp	SHORT $LN10@omf_write_
$LN11@omf_write_:

; 1114 :     /* v2.09: write COMM items here. This allows to handle
; 1115 :      * the external index field entirely in omf.c
; 1116 :      * v2.11: removed again, since omf_write_extdef() is no
; 1117 :      * longer called externally.
; 1118 :      */
; 1119 :     //omf_write_comdef( r.index );
; 1120 : 
; 1121 :     DebugMsg1(("omf_write_extdef exit, index=%u\n", r.index ));

	movzx	eax, WORD PTR r$[rsp+8]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG12627
	call	DoDebugMsg1

; 1122 :     return( r.index );

	movzx	eax, WORD PTR r$[rsp+8]
$LN18@omf_write_:

; 1123 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1448				; 000005a8H
	ret	0
omf_write_extdef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
tv92 = 32
tv167 = 36
sym$ = 40
r$ = 64
GetExt	PROC

; 997  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 998  :     struct asym *sym;
; 999  :     if ( r->method == 0 ) {

	mov	rax, QWORD PTR r$[rsp]
	movzx	eax, BYTE PTR [rax+10]
	test	eax, eax
	jne	$LN8@GetExt
$LN2@GetExt:

; 1000 :         for ( ; r->p; ) {

	mov	rax, QWORD PTR r$[rsp]
	cmp	QWORD PTR [rax], 0
	je	$LN3@GetExt

; 1001 :             sym = (struct asym *)r->p;

	mov	rax, QWORD PTR r$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR sym$[rsp], rax

; 1002 :             r->p = r->p->next;

	mov	rax, QWORD PTR r$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR r$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR [rcx], rax

; 1003 :             if ( sym->iscomm == TRUE )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN9@GetExt

; 1004 :                 continue;

	jmp	SHORT $LN2@GetExt
$LN9@GetExt:

; 1005 :             if ( sym->altname && sym->altname->included == FALSE ) {

	mov	rax, QWORD PTR sym$[rsp]
	cmp	QWORD PTR [rax+72], 0
	je	$LN10@GetExt
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+72]
	movzx	eax, BYTE PTR [rax+49]
	shr	al, 6
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	$LN10@GetExt

; 1006 :                 /**/ myassert( r->index ); /* overflow occured? */

	mov	rax, QWORD PTR r$[rsp]
	movzx	eax, WORD PTR [rax+8]
	test	eax, eax
	je	SHORT $LN14@GetExt
	mov	DWORD PTR tv92[rsp], 0
	jmp	SHORT $LN15@GetExt
$LN14@GetExt:
	mov	edx, 1006				; 000003eeH
	lea	rcx, OFFSET FLAT:$SG12589
	call	InternalError
	mov	DWORD PTR tv92[rsp], eax
$LN15@GetExt:

; 1007 :                 sym->altname->ext_idx2 = r->index++;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR r$[rsp]
	movzx	ecx, WORD PTR [rcx+8]
	mov	WORD PTR [rax+98], cx
	mov	rax, QWORD PTR r$[rsp]
	movzx	eax, WORD PTR [rax+8]
	inc	ax
	mov	rcx, QWORD PTR r$[rsp]
	mov	WORD PTR [rcx+8], ax

; 1008 :                 sym->altname->included = TRUE;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+72]
	movzx	eax, BYTE PTR [rax+49]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR [rcx+72]
	mov	BYTE PTR [rcx+49], al

; 1009 :                 return( sym->altname );

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+72]
	jmp	$LN1@GetExt
$LN10@GetExt:

; 1010 :             }
; 1011 :         }

	jmp	$LN2@GetExt
$LN3@GetExt:

; 1012 :         r->method++;

	mov	rax, QWORD PTR r$[rsp]
	movzx	eax, BYTE PTR [rax+10]
	inc	al
	mov	rcx, QWORD PTR r$[rsp]
	mov	BYTE PTR [rcx+10], al

; 1013 :         r->p = SymTables[TAB_EXT].head;

	mov	eax, 16
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, QWORD PTR r$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR [rdx], rax
$LN8@GetExt:
$LN5@GetExt:

; 1014 :     }
; 1015 :     for ( ; r->p; ) {

	mov	rax, QWORD PTR r$[rsp]
	cmp	QWORD PTR [rax], 0
	je	$LN6@GetExt

; 1016 :         sym = (struct asym *)r->p;

	mov	rax, QWORD PTR r$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR sym$[rsp], rax

; 1017 :         r->p = r->p->next;

	mov	rax, QWORD PTR r$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR r$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR [rcx], rax

; 1018 :         if ( sym->iscomm == TRUE || sym->weak == TRUE )

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	je	SHORT $LN12@GetExt
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+55]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN11@GetExt
$LN12@GetExt:

; 1019 :             continue;

	jmp	SHORT $LN5@GetExt
$LN11@GetExt:

; 1020 :         /**/ myassert( r->index ); /* overflow occured? */

	mov	rax, QWORD PTR r$[rsp]
	movzx	eax, WORD PTR [rax+8]
	test	eax, eax
	je	SHORT $LN16@GetExt
	mov	DWORD PTR tv167[rsp], 0
	jmp	SHORT $LN17@GetExt
$LN16@GetExt:
	mov	edx, 1020				; 000003fcH
	lea	rcx, OFFSET FLAT:$SG12592
	call	InternalError
	mov	DWORD PTR tv167[rsp], eax
$LN17@GetExt:

; 1021 :         sym->ext_idx1 = r->index++;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rcx, QWORD PTR r$[rsp]
	movzx	ecx, WORD PTR [rcx+8]
	mov	WORD PTR [rax+96], cx
	mov	rax, QWORD PTR r$[rsp]
	movzx	eax, WORD PTR [rax+8]
	inc	ax
	mov	rcx, QWORD PTR r$[rsp]
	mov	WORD PTR [rcx+8], ax

; 1022 :         //r->p->sym.included = TRUE;
; 1023 :         return( sym );

	mov	rax, QWORD PTR sym$[rsp]
	jmp	SHORT $LN1@GetExt

; 1024 :     }

	jmp	$LN5@GetExt
$LN6@GetExt:

; 1025 :     return( NULL );

	xor	eax, eax
$LN1@GetExt:

; 1026 : }

	add	rsp, 56					; 00000038H
	ret	0
GetExt	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
items$ = 32
p$ = 40
sym$ = 48
size$ = 56
tv140 = 60
curr$ = 64
tv69 = 72
obj$ = 80
buffer$ = 128
__$ArrayPad$ = 1152
omf_write_lnames PROC

; 923  : {

	sub	rsp, 1176				; 00000498H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 924  :     int         size;
; 925  :     int         items;
; 926  :     unsigned char *p;
; 927  :     //void        *pv = NULL;
; 928  :     struct qnode *curr;
; 929  :     struct asym *sym;
; 930  :     struct omf_rec obj;
; 931  :     unsigned char buffer[MAX_LNAME_SIZE];
; 932  : 
; 933  :     DebugMsg1(("omf_write_lnames() enter\n"));

	lea	rcx, OFFSET FLAT:$SG12555
	call	DoDebugMsg1

; 934  :     p = buffer;

	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 935  :     *p++ = NULLC; /* start with the NULL entry */

	mov	rax, QWORD PTR p$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 936  :     items = 1;

	mov	DWORD PTR items$[rsp], 1

; 937  :     startitem = 1;

	mov	DWORD PTR startitem, 1

; 938  : 
; 939  :     for ( curr = ModuleInfo.g.LnameQueue.head; ; curr = curr->next ) {

	mov	rax, QWORD PTR ModuleInfo+32
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@omf_write_
$LN2@omf_write_:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR curr$[rsp], rax
$LN4@omf_write_:

; 940  :         //sym = GetLnameData( &pv );
; 941  :         sym = ( curr ? (struct asym *)(curr->elmt) : NULL );

	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN16@omf_write_
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN17@omf_write_
$LN16@omf_write_:
	mov	QWORD PTR tv69[rsp], 0
$LN17@omf_write_:
	mov	rax, QWORD PTR tv69[rsp]
	mov	QWORD PTR sym$[rsp], rax

; 942  :         size = p - buffer;

	lea	rax, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR size$[rsp], eax

; 943  :         /* v2.04: changed extra bytes from 1 to 4 (CMD, RECLEN, CHKSUM) */
; 944  :         //if ( sym == NULL || ( ( size + sym->name_size + 1 ) > MAX_LNAME_SIZE )) {
; 945  :         if ( sym == NULL || ( ( size + sym->name_size + 4 ) > MAX_LNAME_SIZE )) {

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN8@omf_write_
	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+80]
	mov	ecx, DWORD PTR size$[rsp]
	lea	eax, DWORD PTR [rcx+rax+4]
	cmp	eax, 1024				; 00000400H
	jle	SHORT $LN7@omf_write_
$LN8@omf_write_:

; 946  :             if( size ) {

	cmp	DWORD PTR size$[rsp], 0
	je	SHORT $LN9@omf_write_

; 947  :                 omf_InitRec( &obj, CMD_LNAMES );

	mov	dl, 150					; 00000096H
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 948  :                 /* first_idx and num_names are NOT
; 949  :                  * written to the LNAMES record!
; 950  :                  * In fact, they aren't used at all.
; 951  :                  */
; 952  :                 obj.d.lnames.first_idx = startitem;

	movzx	eax, WORD PTR startitem
	mov	WORD PTR obj$[rsp+20], ax

; 953  :                 obj.d.lnames.num_names = items;

	movzx	eax, WORD PTR items$[rsp]
	mov	WORD PTR obj$[rsp+22], ax

; 954  :                 AttachData( &obj, buffer, size );

	movsxd	rax, DWORD PTR size$[rsp]
	mov	r8, rax
	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 955  :                 omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record

; 956  :                 startitem = items;

	mov	eax, DWORD PTR items$[rsp]
	mov	DWORD PTR startitem, eax
$LN9@omf_write_:

; 957  :             }
; 958  :             if ( sym == NULL )

	cmp	QWORD PTR sym$[rsp], 0
	jne	SHORT $LN10@omf_write_

; 959  :                 break;

	jmp	$LN3@omf_write_
$LN10@omf_write_:

; 960  :             p = buffer;

	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR p$[rsp], rax
$LN7@omf_write_:

; 961  :         }
; 962  :         *p++ = (char)sym->name_size;

	mov	rax, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR sym$[rsp]
	movzx	ecx, BYTE PTR [rcx+80]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 963  :         /* copy 1 byte more - the NULLC - for _strupr() */
; 964  :         memcpy( p, sym->name, sym->name_size + 1 );

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+80]
	inc	eax
	cdqe
	mov	r8, rax
	mov	rax, QWORD PTR sym$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR p$[rsp]
	call	memcpy

; 965  :         /* lnames are converted for casemaps ALL and NOTPUBLIC */
; 966  :         if ( ModuleInfo.case_sensitive == FALSE )

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN11@omf_write_

; 967  :             _strupr( p );

	mov	rcx, QWORD PTR p$[rsp]
	call	_strupr
$LN11@omf_write_:

; 968  :         DebugMsg1(("omf_write_lnames: %u=%s\n", items, p ));

	mov	r8, QWORD PTR p$[rsp]
	mov	edx, DWORD PTR items$[rsp]
	lea	rcx, OFFSET FLAT:$SG12561
	call	DoDebugMsg1

; 969  :         p += sym->name_size; /* overwrite the null char */

	mov	rax, QWORD PTR sym$[rsp]
	movzx	eax, BYTE PTR [rax+80]
	mov	rcx, QWORD PTR p$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rsp], rax

; 970  :         items++;

	mov	eax, DWORD PTR items$[rsp]
	inc	eax
	mov	DWORD PTR items$[rsp], eax

; 971  :         /* v2.12: lname_idx fields now set in OMF only */
; 972  :         switch ( sym->state ) {

	mov	rax, QWORD PTR sym$[rsp]
	mov	eax, DWORD PTR [rax+40]
	mov	DWORD PTR tv140[rsp], eax
	cmp	DWORD PTR tv140[rsp], 3
	je	SHORT $LN12@omf_write_
	cmp	DWORD PTR tv140[rsp], 4
	je	SHORT $LN13@omf_write_
	jmp	SHORT $LN14@omf_write_
$LN12@omf_write_:

; 973  :         case SYM_SEG: ((struct dsym *)sym)->e.seginfo->lname_idx = items; break;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	ecx, DWORD PTR items$[rsp]
	mov	DWORD PTR [rax+76], ecx
	jmp	SHORT $LN5@omf_write_
$LN13@omf_write_:

; 974  :         case SYM_GRP: ((struct dsym *)sym)->e.grpinfo->lname_idx = items; break;

	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	ecx, DWORD PTR items$[rsp]
	mov	DWORD PTR [rax+12], ecx
	jmp	SHORT $LN5@omf_write_
$LN14@omf_write_:

; 975  :         default:      sym->class_lname_idx = items;                       break;

	mov	rax, QWORD PTR sym$[rsp]
	mov	ecx, DWORD PTR items$[rsp]
	mov	DWORD PTR [rax+16], ecx
$LN5@omf_write_:

; 976  :         }
; 977  :     };

	jmp	$LN2@omf_write_
$LN3@omf_write_:

; 978  : 
; 979  :     DebugMsg1(("omf_write_lnames() exit, items=%u\n", items ));

	mov	edx, DWORD PTR items$[rsp]
	lea	rcx, OFFSET FLAT:$SG12565
	call	DoDebugMsg1

; 980  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1176				; 00000498H
	ret	0
omf_write_lnames ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
curr$ = 80
tv90 = 88
tv130 = 92
tv152 = 96
buffer$1 = 100
obj$ = 104
__$ArrayPad$ = 152
omf_write_segdef PROC

; 855  : {

	sub	rsp, 168				; 000000a8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 856  :     struct dsym    *curr;
; 857  :     struct omf_rec obj;
; 858  : 
; 859  :     DebugMsg1(("omf_write_segdef enter\n"));

	lea	rcx, OFFSET FLAT:$SG12526
	call	DoDebugMsg1

; 860  : 
; 861  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 2
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@omf_write_
$LN2@omf_write_:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rsp], rax
$LN4@omf_write_:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN3@omf_write_

; 862  : 
; 863  : #if COMDATSUPP
; 864  :         if ( curr->e.seginfo->comdat_selection )

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+108]
	shr	al, 3
	and	al, 7
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@omf_write_

; 865  :             continue;

	jmp	SHORT $LN2@omf_write_
$LN5@omf_write_:

; 866  : #endif
; 867  :         omf_InitRec( &obj, CMD_SEGDEF );

	mov	dl, 152					; 00000098H
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 868  :         if ( curr->e.seginfo->Ofssize > USE16 ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+104]
	test	eax, eax
	jle	SHORT $LN6@omf_write_

; 869  :             obj.is_32 = ( ( curr->e.seginfo->force32 || ( curr->sym.max_offset >= 0x10000 ) ) ? 1 : 0 );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+107]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN10@omf_write_
	mov	rax, QWORD PTR curr$[rsp]
	cmp	DWORD PTR [rax+64], 65536		; 00010000H
	jge	SHORT $LN10@omf_write_
	mov	DWORD PTR tv90[rsp], 0
	jmp	SHORT $LN11@omf_write_
$LN10@omf_write_:
	mov	DWORD PTR tv90[rsp], 1
$LN11@omf_write_:
	movzx	eax, BYTE PTR tv90[rsp]
	mov	BYTE PTR obj$[rsp+17], al

; 870  :         } else {

	jmp	SHORT $LN7@omf_write_
$LN6@omf_write_:

; 871  :             obj.is_32 = 0;

	mov	BYTE PTR obj$[rsp+17], 0
$LN7@omf_write_:

; 872  :         }
; 873  : 
; 874  :         obj.d.segdef.idx             = curr->e.seginfo->seg_idx;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, WORD PTR [rax+68]
	mov	WORD PTR obj$[rsp+20], ax

; 875  :         obj.d.segdef.use_32          = ( curr->e.seginfo->Ofssize > USE16 ? 1 : 0 );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+104]
	test	eax, eax
	jle	SHORT $LN12@omf_write_
	mov	DWORD PTR tv130[rsp], 1
	jmp	SHORT $LN13@omf_write_
$LN12@omf_write_:
	mov	DWORD PTR tv130[rsp], 0
$LN13@omf_write_:
	movzx	eax, BYTE PTR tv130[rsp]
	mov	BYTE PTR obj$[rsp+22], al

; 876  :         obj.d.segdef.align           = get_omfalign( curr->e.seginfo->alignment );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	ecx, BYTE PTR [rax+106]
	call	get_omfalign
	mov	BYTE PTR obj$[rsp+23], al

; 877  :         obj.d.segdef.combine         = curr->e.seginfo->combine;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+108]
	and	al, 7
	mov	BYTE PTR obj$[rsp+24], al

; 878  :         obj.d.segdef.abs.frame       = curr->e.seginfo->abs_frame;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, WORD PTR [rax+88]
	mov	WORD PTR obj$[rsp+28], ax

; 879  :         obj.d.segdef.abs.offset      = curr->e.seginfo->abs_offset;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rax+96]
	mov	DWORD PTR obj$[rsp+32], eax

; 880  :         obj.d.segdef.seg_length      = curr->sym.max_offset;

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR obj$[rsp+36], eax

; 881  :         obj.d.segdef.seg_lname_idx   = curr->e.seginfo->lname_idx;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, WORD PTR [rax+76]
	mov	WORD PTR obj$[rsp+40], ax

; 882  :         obj.d.segdef.class_lname_idx = ( curr->e.seginfo->clsym ? curr->e.seginfo->clsym->class_lname_idx : 1 );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	QWORD PTR [rax+80], 0
	je	SHORT $LN14@omf_write_
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rax+80]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR tv152[rsp], eax
	jmp	SHORT $LN15@omf_write_
$LN14@omf_write_:
	mov	DWORD PTR tv152[rsp], 1
$LN15@omf_write_:
	movzx	eax, WORD PTR tv152[rsp]
	mov	WORD PTR obj$[rsp+42], ax

; 883  :         obj.d.segdef.ovl_lname_idx   = 1;

	mov	eax, 1
	mov	WORD PTR obj$[rsp+44], ax

; 884  : 
; 885  :         omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record

; 886  :         DebugMsg1(("omf_write_segdef(%s): len=%" I32_SPEC "X use32=%u align=%u comb=%u seg_lname=%u class_lname=%u ovl_lname=%u\n",

	movzx	eax, WORD PTR obj$[rsp+44]
	movzx	ecx, WORD PTR obj$[rsp+42]
	movzx	edx, WORD PTR obj$[rsp+40]
	movzx	r8d, BYTE PTR obj$[rsp+24]
	movzx	r9d, BYTE PTR obj$[rsp+23]
	movzx	r10d, BYTE PTR obj$[rsp+22]
	mov	DWORD PTR [rsp+64], eax
	mov	DWORD PTR [rsp+56], ecx
	mov	DWORD PTR [rsp+48], edx
	mov	DWORD PTR [rsp+40], r8d
	mov	DWORD PTR [rsp+32], r9d
	mov	r9d, r10d
	mov	r8d, DWORD PTR obj$[rsp+36]
	mov	rax, QWORD PTR curr$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12530
	call	DoDebugMsg1

; 887  :                   curr->sym.name,
; 888  :                   obj.d.segdef.seg_length,
; 889  :                   obj.d.segdef.use_32,
; 890  :                   obj.d.segdef.align,
; 891  :                   obj.d.segdef.combine,
; 892  :                   obj.d.segdef.seg_lname_idx,
; 893  :                   obj.d.segdef.class_lname_idx,
; 894  :                   obj.d.segdef.ovl_lname_idx
; 895  :                  ));
; 896  :         /* write a comment for the linker.
; 897  :          * this is something not done by Masm, it has
; 898  :          * been inherited from Wasm.
; 899  :          */
; 900  :         if( curr->e.seginfo->segtype == SEGTYPE_CODE && Options.no_opt_farcall == FALSE ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+72], 1
	jne	SHORT $LN8@omf_write_
	movzx	eax, BYTE PTR Options+129
	test	eax, eax
	jne	SHORT $LN8@omf_write_

; 901  :             uint_8 buffer[4];
; 902  :             omf_InitRec( &obj, CMD_COMENT );

	mov	dl, 136					; 00000088H
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 903  :             obj.d.coment.attr = CMT_TNP;

	mov	BYTE PTR obj$[rsp+20], 128		; 00000080H

; 904  :             obj.d.coment.cmt_class = CMT_LINKER_DIRECTIVE;

	mov	BYTE PTR obj$[rsp+21], 254		; 000000feH

; 905  :             AttachData( &obj, buffer, 3 );

	mov	r8d, 3
	lea	rdx, QWORD PTR buffer$1[rsp]
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 906  :             Put8( &obj, LDIR_OPT_FAR_CALLS );

	mov	dl, 79					; 0000004fH
	lea	rcx, QWORD PTR obj$[rsp]
	call	Put8

; 907  :             PutIndex( &obj, curr->e.seginfo->seg_idx );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	edx, DWORD PTR [rax+68]
	lea	rcx, QWORD PTR obj$[rsp]
	call	PutIndex

; 908  :             /* v2.04: added. cut off the 3. byte if not needed */
; 909  :             TruncRec( &obj );

	mov	eax, DWORD PTR obj$[rsp+4]
	mov	DWORD PTR obj$[rsp], eax

; 910  :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record
$LN8@omf_write_:

; 911  :         }
; 912  :     }

	jmp	$LN2@omf_write_
$LN3@omf_write_:

; 913  :     DebugMsg1(("omf_write_segdef exit\n"));

	lea	rcx, OFFSET FLAT:$SG12532
	call	DoDebugMsg1

; 914  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 168				; 000000a8H
	ret	0
omf_write_segdef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
curr$ = 32
seg$ = 40
segminfo$ = 48
grp$ = 56
__$ArrayPad$ = 104
omf_write_grpdef PROC

; 783  : {

	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 784  :     struct dsym     *curr;
; 785  :     struct dsym     *segminfo;
; 786  :     struct seg_item *seg;
; 787  :     struct omf_rec  grp;
; 788  :     //char            writeseg;
; 789  : 
; 790  :     DebugMsg1(("omf_write_grpdef enter\n"));

	lea	rcx, OFFSET FLAT:$SG12501
	call	DoDebugMsg1

; 791  :     //line_num = LineNumber;
; 792  : 
; 793  :     /* size of group records may exceed 1024! */
; 794  :     for( curr = SymTables[TAB_GRP].head; curr; curr = curr->next ) {

	mov	eax, 16
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@omf_write_
$LN2@omf_write_:
	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	QWORD PTR curr$[rsp], rax
$LN4@omf_write_:
	cmp	QWORD PTR curr$[rsp], 0
	je	$LN3@omf_write_

; 795  : 
; 796  :         omf_InitRec( &grp, CMD_GRPDEF );

	mov	dl, 154					; 0000009aH
	lea	rcx, QWORD PTR grp$[rsp]
	call	omf_InitRec

; 797  : 
; 798  :         grp.d.grpdef.idx = curr->e.grpinfo->grp_idx;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, WORD PTR [rax+8]
	mov	WORD PTR grp$[rsp+20], ax

; 799  : 
; 800  :         /* we might need:
; 801  :          * - 1 or 2 bytes for the group name index
; 802  :          * - 2 or 3 bytes for each segment in the group
; 803  :          */
; 804  :         AttachData( &grp, StringBufferEnd, 2 + 3 * curr->e.grpinfo->numseg );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	imul	eax, DWORD PTR [rax+16], 3
	add	eax, 2
	mov	eax, eax
	mov	r8d, eax
	mov	rdx, QWORD PTR ModuleInfo+488
	lea	rcx, QWORD PTR grp$[rsp]
	call	AttachData

; 805  :         /* v2.01: the LName index of the group may be > 0xff */
; 806  :         /* v2.03: use the group index directly */
; 807  :         PutIndex( &grp, curr->e.grpinfo->lname_idx );

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	edx, DWORD PTR [rax+12]
	lea	rcx, QWORD PTR grp$[rsp]
	call	PutIndex

; 808  : 
; 809  :         for( seg = curr->e.grpinfo->seglist; seg; seg = seg->next ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR seg$[rsp], rax
	jmp	SHORT $LN7@omf_write_
$LN5@omf_write_:
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR seg$[rsp], rax
$LN7@omf_write_:
	cmp	QWORD PTR seg$[rsp], 0
	je	SHORT $LN6@omf_write_

; 810  :             //writeseg = TRUE;
; 811  :             segminfo = (struct dsym *)(seg->seg);

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR segminfo$[rsp], rax

; 812  :             Put8( &grp, GRP_SEGIDX );

	mov	dl, 255					; 000000ffH
	lea	rcx, QWORD PTR grp$[rsp]
	call	Put8

; 813  :             PutIndex( &grp, segminfo->e.seginfo->seg_idx );

	mov	rax, QWORD PTR segminfo$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	edx, DWORD PTR [rax+68]
	lea	rcx, QWORD PTR grp$[rsp]
	call	PutIndex

; 814  :             /* truncate the group record if it comes near output buffer limit! */
; 815  :             if ( grp.curoff > OBJ_BUFFER_SIZE - 10 ) {

	cmp	DWORD PTR grp$[rsp+4], 4070		; 00000fe6H
	jbe	SHORT $LN8@omf_write_

; 816  :                 EmitWarn( 2, GROUP_DEFINITION_TOO_LARGE, curr->sym.name );

	mov	rax, QWORD PTR curr$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	edx, 267				; 0000010bH
	mov	ecx, 2
	call	EmitWarn

; 817  :                 break;

	jmp	SHORT $LN6@omf_write_
$LN8@omf_write_:

; 818  :             }
; 819  :         }

	jmp	SHORT $LN5@omf_write_
$LN6@omf_write_:

; 820  :         TruncRec( &grp );

	mov	eax, DWORD PTR grp$[rsp+4]
	mov	DWORD PTR grp$[rsp], eax

; 821  :         omf_write_record( &grp );

	lea	rcx, QWORD PTR grp$[rsp]
	call	omf_write_record

; 822  :     }

	jmp	$LN2@omf_write_
$LN3@omf_write_:

; 823  :     DebugMsg1(("omf_write_grpdef exit\n"));

	lea	rcx, OFFSET FLAT:$SG12503
	call	DoDebugMsg1

; 824  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
omf_write_grpdef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
parmcnt$ = 32
len$ = 36
dir$ = 40
data$ = 48
parm$ = 56
obj$ = 64
__$ArrayPad$ = 112
omf_write_export PROC

; 717  : {

	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 718  :     uint_8      parmcnt;
; 719  :     struct dsym *dir;
; 720  :     struct dsym *parm;
; 721  :     struct omf_rec obj;
; 722  :     int         len;
; 723  :     uint_8      *data;
; 724  : 
; 725  : #if DLLIMPORT && WRITEIMPDEF /* writing import records in OMF not supported yet */
; 726  :     omf_write_import();
; 727  : #endif
; 728  : 
; 729  :     for( dir = SymTables[TAB_PROC].head; dir != NULL; dir = dir->nextproc ) {

	mov	eax, 16
	imul	rax, rax, 4
	lea	rcx, OFFSET FLAT:SymTables
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR dir$[rsp], rax
	jmp	SHORT $LN4@omf_write_
$LN2@omf_write_:
	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+120]
	mov	QWORD PTR dir$[rsp], rax
$LN4@omf_write_:
	cmp	QWORD PTR dir$[rsp], 0
	je	$LN3@omf_write_

; 730  :         if( dir->e.procinfo->isexport ) {

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+128]
	shr	al, 2
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN8@omf_write_

; 731  : 
; 732  :             omf_InitRec( &obj, CMD_COMENT );

	mov	dl, 136					; 00000088H
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 733  :             obj.d.coment.attr = 0x00;

	mov	BYTE PTR obj$[rsp+20], 0

; 734  :             obj.d.coment.cmt_class = CMT_OMF_EXT;

	mov	BYTE PTR obj$[rsp+21], 160		; 000000a0H

; 735  :             data = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR data$[rsp], rax

; 736  : 
; 737  :             /* structure of EXPDEF "comment":
; 738  :              * type          db CMT_EXT_EXPDEF (=02)
; 739  :              * exported_flag db ?
; 740  :              * ex_name_len   db ?
; 741  :              * exported_name db ex_name_len dup (?)
; 742  :              * int_name_len  db 0     ;always 0
; 743  :              * ;internal_name db int_name_len dup (?)
; 744  :              * ;ordinal      dw ?     ;optional
; 745  :              */
; 746  :             if ( Options.no_export_decoration == FALSE )

	movzx	eax, BYTE PTR Options+135
	test	eax, eax
	jne	SHORT $LN9@omf_write_

; 747  :                 len = Mangle( &dir->sym, data+3 );

	mov	rax, QWORD PTR data$[rsp]
	add	rax, 3
	mov	rcx, QWORD PTR dir$[rsp]
	mov	rdx, rax
	call	Mangle
	mov	DWORD PTR len$[rsp], eax
	jmp	SHORT $LN10@omf_write_
$LN9@omf_write_:

; 748  :             else {
; 749  :                 strcpy( data+3, dir->sym.name );

	mov	rax, QWORD PTR data$[rsp]
	add	rax, 3
	mov	rcx, QWORD PTR dir$[rsp]
	mov	rdx, QWORD PTR [rcx+8]
	mov	rcx, rax
	call	strcpy

; 750  :                 len = dir->sym.name_size;

	mov	rax, QWORD PTR dir$[rsp]
	movzx	eax, BYTE PTR [rax+80]
	mov	DWORD PTR len$[rsp], eax
$LN10@omf_write_:

; 751  :             }
; 752  :             /* v2.11: case mapping was missing */
; 753  :             if ( ModuleInfo.convert_uppercase )

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN11@omf_write_

; 754  :                 _strupr( data+3 );

	mov	rax, QWORD PTR data$[rsp]
	add	rax, 3
	mov	rcx, rax
	call	_strupr
$LN11@omf_write_:

; 755  : #if MAX_ID_LEN > 255
; 756  :             if ( len > 255 )
; 757  :                 len = 255; /* restrict name to 255 chars */
; 758  : #endif
; 759  :             AttachData( &obj, data, len + 4 );

	mov	eax, DWORD PTR len$[rsp]
	add	eax, 4
	cdqe
	mov	r8, rax
	mov	rdx, QWORD PTR data$[rsp]
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 760  :             Put8( &obj, CMT_EXT_EXPDEF );

	mov	dl, 2
	lea	rcx, QWORD PTR obj$[rsp]
	call	Put8

; 761  :             /* write the "Exported Flag" byte:
; 762  :              * bits 0-4: parameter count
; 763  :              * bit 5: no data (entry doesn't use initialized data )
; 764  :              * bit 6: resident (name should be kept resident)
; 765  :              * bit 7: ordinal ( if 1, 2 byte index must follow name)
; 766  :              */
; 767  :             for ( parm = dir->e.procinfo->paralist, parmcnt = 0; parm; parm = parm->nextparam, parmcnt++ );

	mov	rax, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR parm$[rsp], rax
	mov	BYTE PTR parmcnt$[rsp], 0
	jmp	SHORT $LN7@omf_write_
$LN5@omf_write_:
	mov	rax, QWORD PTR parm$[rsp]
	mov	rax, QWORD PTR [rax+120]
	mov	QWORD PTR parm$[rsp], rax
	movzx	eax, BYTE PTR parmcnt$[rsp]
	inc	al
	mov	BYTE PTR parmcnt$[rsp], al
$LN7@omf_write_:
	cmp	QWORD PTR parm$[rsp], 0
	je	SHORT $LN6@omf_write_
	jmp	SHORT $LN5@omf_write_
$LN6@omf_write_:

; 768  :             parmcnt &= 0x1F; /* ensure bits 5-7 are still 0 */

	movzx	eax, BYTE PTR parmcnt$[rsp]
	and	eax, 31
	mov	BYTE PTR parmcnt$[rsp], al

; 769  :             Put8( &obj, parmcnt ); /* v2.01: changed from fix 0x00 */

	movzx	edx, BYTE PTR parmcnt$[rsp]
	lea	rcx, QWORD PTR obj$[rsp]
	call	Put8

; 770  :             Put8( &obj, len );

	movzx	edx, BYTE PTR len$[rsp]
	lea	rcx, QWORD PTR obj$[rsp]
	call	Put8

; 771  :             obj.curoff += len;

	mov	eax, DWORD PTR len$[rsp]
	mov	ecx, DWORD PTR obj$[rsp+4]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR obj$[rsp+4], eax

; 772  :             Put8( &obj, 0 );

	xor	edx, edx
	lea	rcx, QWORD PTR obj$[rsp]
	call	Put8

; 773  :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record
$LN8@omf_write_:

; 774  :         }
; 775  :     }

	jmp	$LN2@omf_write_
$LN3@omf_write_:

; 776  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	ret	0
omf_write_export ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
curr$ = 32
name$ = 40
next$ = 48
obj$ = 56
__$ArrayPad$ = 104
omf_write_lib PROC

; 643  : {

	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 644  :     struct omf_rec      obj;
; 645  :     struct qitem        *curr;
; 646  :     struct qitem        *next;
; 647  :     char                *name;
; 648  : 
; 649  :     DebugMsg1(("omf_write_lib() enter\n"));

	lea	rcx, OFFSET FLAT:$SG12464
	call	DoDebugMsg1

; 650  :     for( curr = ModuleInfo.g.LibQueue.head; curr; curr = next ) {

	mov	rax, QWORD PTR ModuleInfo+64
	mov	QWORD PTR curr$[rsp], rax
	jmp	SHORT $LN4@omf_write_
$LN2@omf_write_:
	mov	rax, QWORD PTR next$[rsp]
	mov	QWORD PTR curr$[rsp], rax
$LN4@omf_write_:
	cmp	QWORD PTR curr$[rsp], 0
	je	SHORT $LN3@omf_write_

; 651  :         next = curr->next;

	mov	rax, QWORD PTR curr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR next$[rsp], rax

; 652  :         name = curr->value;

	mov	rax, QWORD PTR curr$[rsp]
	add	rax, 8
	mov	QWORD PTR name$[rsp], rax

; 653  :         omf_InitRec( &obj, CMD_COMENT );

	mov	dl, 136					; 00000088H
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 654  :         obj.d.coment.attr = CMT_TNP;

	mov	BYTE PTR obj$[rsp+20], 128		; 00000080H

; 655  :         obj.d.coment.cmt_class = CMT_DEFAULT_LIBRARY;

	mov	BYTE PTR obj$[rsp+21], 159		; 0000009fH

; 656  :         AttachData( &obj, (uint_8 *)name, strlen( name ) );

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	mov	r8, rax
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 657  :         omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record

; 658  :     }

	jmp	SHORT $LN2@omf_write_
$LN3@omf_write_:

; 659  :     DebugMsg1(("omf_write_lib() exit\n"));

	lea	rcx, OFFSET FLAT:$SG12465
	call	DoDebugMsg1

; 660  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
omf_write_lib ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
obj$ = 32
__$ArrayPad$ = 80
omf_write_dosseg PROC

; 631  : {

	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 632  :     struct omf_rec obj;
; 633  : 
; 634  :     omf_InitRec( &obj, CMD_COMENT );

	mov	dl, 136					; 00000088H
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 635  :     obj.d.coment.attr = CMT_TNP;

	mov	BYTE PTR obj$[rsp+20], 128		; 00000080H

; 636  :     obj.d.coment.cmt_class = CMT_DOSSEG;

	mov	BYTE PTR obj$[rsp+21], 158		; 0000009eH

; 637  :     AttachData( &obj, (uint_8 *)"", 0 );

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:$SG12452
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 638  :     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record

; 639  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
omf_write_dosseg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
obj$ = 32
__$ArrayPad$ = 80
omf_end_of_pass1 PROC

; 606  : {

	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 607  :     struct omf_rec obj;
; 608  : 
; 609  :     omf_InitRec( &obj, CMD_COMENT );

	mov	dl, 136					; 00000088H
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 610  :     obj.d.coment.attr = 0x00;

	mov	BYTE PTR obj$[rsp+20], 0

; 611  :     obj.d.coment.cmt_class = CMT_MS_END_PASS_1;

	mov	BYTE PTR obj$[rsp+21], 162		; 000000a2H

; 612  :     AttachData( &obj, (uint_8 *)"\x001", 1 );

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:$SG12443
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 613  :     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record

; 614  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
omf_end_of_pass1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
len$ = 32
obj$ = 40
__$ArrayPad$ = 88
name$ = 112
omf_write_theadr PROC

; 525  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 526  :     struct omf_rec obj;
; 527  :     unsigned    len;
; 528  :     //const struct fname_item *fn;
; 529  : 
; 530  :     DebugMsg1(("omf_write_theadr(%s) enter\n", name));

	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, OFFSET FLAT:$SG12422
	call	DoDebugMsg1

; 531  : 
; 532  :     omf_InitRec( &obj, CMD_THEADR );

	mov	dl, 128					; 00000080H
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 533  : 
; 534  :     /* v2.08: use the name given at the cmdline, that's what Masm does.
; 535  :      * Masm emits either a relative or a full path, depending on what
; 536  :      * was given as filename!
; 537  :      */
; 538  :     len = strlen( name );

	mov	rcx, QWORD PTR name$[rsp]
	call	strlen
	mov	DWORD PTR len$[rsp], eax

; 539  :     AttachData( &obj, StringBufferEnd, len + 1 );

	mov	eax, DWORD PTR len$[rsp]
	inc	eax
	mov	eax, eax
	mov	r8d, eax
	mov	rdx, QWORD PTR ModuleInfo+488
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 540  :     PutName( &obj, name, len );

	mov	eax, DWORD PTR len$[rsp]
	mov	r8d, eax
	mov	rdx, QWORD PTR name$[rsp]
	lea	rcx, QWORD PTR obj$[rsp]
	call	PutName

; 541  :     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record

; 542  : 
; 543  :     DebugMsg1(("omf_write_theadr() exit\n"));

	lea	rcx, OFFSET FLAT:$SG12423
	call	DoDebugMsg1

; 544  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
omf_write_theadr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
size$ = 32
tv156 = 36
tv159 = 40
obj$ = 48
__$ArrayPad$ = 96
seg$ = 128
omf_write_ledata PROC

; 421  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 422  :     struct omf_rec  obj;
; 423  :     int_32          size;
; 424  : 
; 425  :     size = seg->e.seginfo->current_loc - seg->e.seginfo->start_loc;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	ecx, DWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, ecx
	mov	DWORD PTR size$[rsp], eax

; 426  :     DebugMsg1(( "omf_write_ledata enter, buffer=%p start ofs=%" I32_SPEC "X, size=%" I32_SPEC "X\n",

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	r9d, DWORD PTR size$[rsp]
	mov	r8d, DWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+16]
	lea	rcx, OFFSET FLAT:$SG12400
	call	DoDebugMsg1

; 427  :               seg->e.seginfo->CodeBuffer, seg->e.seginfo->start_loc, size ));
; 428  :     if( size > 0 && write_to_file == TRUE ) {

	cmp	DWORD PTR size$[rsp], 0
	jle	$LN2@omf_write_
	movzx	eax, BYTE PTR write_to_file
	cmp	eax, 1
	jne	$LN2@omf_write_

; 429  :         LastCodeBufSize = size;

	mov	eax, DWORD PTR size$[rsp]
	mov	DWORD PTR LastCodeBufSize, eax

; 430  : #if COMDATSUPP
; 431  :         if ( seg->e.seginfo->comdat_selection ) {

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+108]
	shr	al, 3
	and	al, 7
	movzx	eax, al
	test	eax, eax
	je	$LN3@omf_write_

; 432  :             /* if the COMDAT symbol has been referenced in a FIXUPP,
; 433  :              * a CEXTDEF has to be written.
; 434  :              */
; 435  :             if ( seg->sym.used ) {

	mov	rax, QWORD PTR seg$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN5@omf_write_

; 436  :                 omf_InitRec( &obj, CMD_CEXTDEF );

	mov	dl, 188					; 000000bcH
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 437  :                 AttachData( &obj, StringBufferEnd, 2 * sizeof( uint_16 ) );

	mov	r8d, 4
	mov	rdx, QWORD PTR ModuleInfo+488
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 438  :                 PutIndex( &obj, seg->e.seginfo->comdat_idx ); /* Index */

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, WORD PTR [rax+88]
	mov	edx, eax
	lea	rcx, QWORD PTR obj$[rsp]
	call	PutIndex

; 439  :                 PutIndex( &obj, 0 ); /* Type */

	xor	edx, edx
	lea	rcx, QWORD PTR obj$[rsp]
	call	PutIndex

; 440  :                 TruncRec( &obj );

	mov	eax, DWORD PTR obj$[rsp+4]
	mov	DWORD PTR obj$[rsp], eax

; 441  :                 omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record

; 442  :                 if ( seg->e.seginfo->seg_idx == 0 )

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+68], 0
	jne	SHORT $LN6@omf_write_

; 443  :                     seg->e.seginfo->seg_idx = startext++;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	ecx, DWORD PTR startext
	mov	DWORD PTR [rax+68], ecx
	mov	eax, DWORD PTR startext
	inc	eax
	mov	DWORD PTR startext, eax
$LN6@omf_write_:
$LN5@omf_write_:

; 444  :             }
; 445  : 
; 446  :             omf_InitRec( &obj, CMD_COMDAT );

	mov	dl, 194					; 000000c2H
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 447  :             AttachData( &obj, seg->e.seginfo->CodeBuffer, size );

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	r8, rax
	mov	rdx, QWORD PTR [rcx+16]
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 448  :             if( seg->e.seginfo->start_loc > 0xffffUL )

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+8], 65535		; 0000ffffH
	jbe	SHORT $LN7@omf_write_

; 449  :                 obj.is_32 = 1;

	mov	BYTE PTR obj$[rsp+17], 1
$LN7@omf_write_:

; 450  :             obj.d.comdat.flags = 0;

	mov	BYTE PTR obj$[rsp+20], 0

; 451  :             /* low 4-bits is allocation type */
; 452  :             if ( seg->e.seginfo->segtype == SEGTYPE_CODE ) {

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+72], 1
	jne	SHORT $LN8@omf_write_

; 453  :                 obj.d.comdat.attributes = ( ModuleInfo.model == MODEL_FLAT ? COMDAT_CODE32 : COMDAT_FAR_CODE );

	cmp	DWORD PTR ModuleInfo+360, 7
	jne	SHORT $LN13@omf_write_
	mov	DWORD PTR tv156[rsp], 3
	jmp	SHORT $LN14@omf_write_
$LN13@omf_write_:
	mov	DWORD PTR tv156[rsp], 1
$LN14@omf_write_:
	movzx	eax, BYTE PTR tv156[rsp]
	mov	BYTE PTR obj$[rsp+21], al

; 454  :             } else {

	jmp	SHORT $LN9@omf_write_
$LN8@omf_write_:

; 455  :                 obj.d.comdat.attributes = ( ModuleInfo.model == MODEL_FLAT ? COMDAT_DATA32 : COMDAT_FAR_DATA );

	cmp	DWORD PTR ModuleInfo+360, 7
	jne	SHORT $LN15@omf_write_
	mov	DWORD PTR tv159[rsp], 4
	jmp	SHORT $LN16@omf_write_
$LN15@omf_write_:
	mov	DWORD PTR tv159[rsp], 2
$LN16@omf_write_:
	movzx	eax, BYTE PTR tv159[rsp]
	mov	BYTE PTR obj$[rsp+21], al
$LN9@omf_write_:

; 456  :             }
; 457  :             obj.d.comdat.align = get_omfalign( seg->e.seginfo->alignment );

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	ecx, BYTE PTR [rax+106]
	call	get_omfalign
	mov	BYTE PTR obj$[rsp+22], al

; 458  :             obj.d.comdat.offset = seg->e.seginfo->start_loc;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR obj$[rsp+24], eax

; 459  :             obj.d.comdat.type_idx = 0;

	xor	eax, eax
	mov	WORD PTR obj$[rsp+28], ax

; 460  :             obj.d.comdat.public_lname_idx = seg->e.seginfo->comdat_idx;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, WORD PTR [rax+88]
	mov	WORD PTR obj$[rsp+36], ax

; 461  :             /* todo: error if comdat_idx is 0 */
; 462  :         } else {

	jmp	SHORT $LN4@omf_write_
$LN3@omf_write_:

; 463  : #endif
; 464  :             omf_InitRec( &obj, CMD_LEDATA );

	mov	dl, 160					; 000000a0H
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 465  :             AttachData( &obj, seg->e.seginfo->CodeBuffer, size );

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	r8, rax
	mov	rdx, QWORD PTR [rcx+16]
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 466  :             obj.d.ledata.idx = seg->e.seginfo->seg_idx;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, WORD PTR [rax+68]
	mov	WORD PTR obj$[rsp+20], ax

; 467  :             obj.d.ledata.offset = seg->e.seginfo->start_loc;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR obj$[rsp+24], eax

; 468  :             if( obj.d.ledata.offset > 0xffffUL )

	cmp	DWORD PTR obj$[rsp+24], 65535		; 0000ffffH
	jbe	SHORT $LN10@omf_write_

; 469  :                 obj.is_32 = 1;

	mov	BYTE PTR obj$[rsp+17], 1
$LN10@omf_write_:
$LN4@omf_write_:

; 470  : #if COMDATSUPP
; 471  :         }
; 472  : #endif
; 473  :         omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record

; 474  : 
; 475  :         /* process Fixup, if any */
; 476  :         if( seg->e.seginfo->FixupList.head != NULL ) {

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	cmp	QWORD PTR [rax+40], 0
	je	SHORT $LN11@omf_write_

; 477  : #if FASTMEM==0
; 478  :             struct fixup *fix;
; 479  :             struct fixup *next;
; 480  : #endif
; 481  :             omf_write_fixupp( seg, 0 );

	xor	edx, edx
	mov	rcx, QWORD PTR seg$[rsp]
	call	omf_write_fixupp

; 482  :             omf_write_fixupp( seg, 1 );

	mov	dl, 1
	mov	rcx, QWORD PTR seg$[rsp]
	call	omf_write_fixupp

; 483  : #if FASTMEM==0
; 484  :             for( fix = seg->e.seginfo->FixupList.head; fix; ) {
; 485  :                 next = fix->nextrlc;
; 486  :                 LclFree( fix );
; 487  :                 fix = next;
; 488  :             }
; 489  : #endif
; 490  :             seg->e.seginfo->FixupList.head = seg->e.seginfo->FixupList.tail = NULL;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR [rax+48], 0
	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR [rax+40], 0
$LN11@omf_write_:
$LN2@omf_write_:

; 491  :         }
; 492  :     }
; 493  :     seg->e.seginfo->start_loc = seg->e.seginfo->current_loc;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR seg$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+8], eax

; 494  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
omf_write_ledata ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
tv65 = 32
tv78 = 36
alignment$ = 64
get_omfalign PROC

; 828  : {

	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 56					; 00000038H

; 829  :     switch ( alignment ) {

	movzx	eax, BYTE PTR alignment$[rsp]
	mov	BYTE PTR tv65[rsp], al
	cmp	BYTE PTR tv65[rsp], 1
	je	SHORT $LN4@get_omfali
	cmp	BYTE PTR tv65[rsp], 2
	je	SHORT $LN5@get_omfali
	cmp	BYTE PTR tv65[rsp], 4
	je	SHORT $LN6@get_omfali
	cmp	BYTE PTR tv65[rsp], 8
	je	SHORT $LN7@get_omfali
	cmp	BYTE PTR tv65[rsp], 255			; 000000ffH
	je	SHORT $LN8@get_omfali
	jmp	SHORT $LN2@get_omfali
$LN4@get_omfali:

; 830  :     case  1:  return( SEGDEF_ALIGN_WORD );

	mov	al, 2
	jmp	SHORT $LN1@get_omfali
$LN5@get_omfali:

; 831  :     case  2:  return( SEGDEF_ALIGN_DWORD );

	mov	al, 5
	jmp	SHORT $LN1@get_omfali
$LN6@get_omfali:

; 832  :     case  4:  return( SEGDEF_ALIGN_PARA );

	mov	al, 3
	jmp	SHORT $LN1@get_omfali
$LN7@get_omfali:

; 833  :     case  8:  return( SEGDEF_ALIGN_PAGE );

	mov	al, 4
	jmp	SHORT $LN1@get_omfali
$LN8@get_omfali:

; 834  : #if PAGE4K /* PharLab peculiarity; this is invalid for MS OMF */
; 835  :     case 12:
; 836  :         if ( Parse_Pass == PASS_1 )
; 837  :             EmitWarn( 2, NO_4KPAGE_ALIGNED_SEGMENTS_IN_MS386 );
; 838  :         return( SEGDEF_ALIGN_4KPAGE );
; 839  : #endif
; 840  :     case MAX_SEGALIGNMENT: return( SEGDEF_ALIGN_ABS );

	xor	al, al
	jmp	SHORT $LN1@get_omfali
$LN2@get_omfali:

; 841  :     }
; 842  :     /* value 0 is byte alignment, anything elso is "unexpected" */
; 843  :     /**/myassert( alignment == 0 );

	movzx	eax, BYTE PTR alignment$[rsp]
	test	eax, eax
	jne	SHORT $LN10@get_omfali
	mov	DWORD PTR tv78[rsp], 0
	jmp	SHORT $LN11@get_omfali
$LN10@get_omfali:
	mov	edx, 843				; 0000034bH
	lea	rcx, OFFSET FLAT:$SG12515
	call	InternalError
	mov	DWORD PTR tv78[rsp], eax
$LN11@get_omfali:

; 844  :     return( SEGDEF_ALIGN_BYTE );

	mov	al, 1
$LN1@get_omfali:

; 845  : }

	add	rsp, 56					; 00000038H
	ret	0
get_omfalign ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
size$ = 32
tv73 = 36
fix$ = 40
tv66 = 48
data$ = 56
type$ = 64
obj$ = 72
__$ArrayPad$ = 120
seg$ = 144
is32$ = 152
omf_write_fixupp PROC

; 381  : {

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 382  :     uint_8 *data;
; 383  :     unsigned size;
; 384  :     struct fixup *fix;
; 385  :     enum fixup_types type = ( is32 ? FIX_GEN_MS386 : FIX_GEN_INTEL );

	movsx	eax, BYTE PTR is32$[rsp]
	test	eax, eax
	je	SHORT $LN16@omf_write_
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN17@omf_write_
$LN16@omf_write_:
	mov	DWORD PTR tv66[rsp], 0
$LN17@omf_write_:
	mov	eax, DWORD PTR tv66[rsp]
	mov	DWORD PTR type$[rsp], eax

; 386  :     struct omf_rec  obj;
; 387  : 
; 388  :     fix = seg->e.seginfo->FixupList.head;

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR fix$[rsp], rax
$LN2@omf_write_:

; 389  :     while ( fix ) {

	cmp	QWORD PTR fix$[rsp], 0
	je	$LN3@omf_write_

; 390  :         for( data = StringBufferEnd, size = 0; fix; fix = fix->nextrlc ) {

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR data$[rsp], rax
	mov	DWORD PTR size$[rsp], 0
	jmp	SHORT $LN6@omf_write_
$LN4@omf_write_:
	mov	rax, QWORD PTR fix$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR fix$[rsp], rax
$LN6@omf_write_:
	cmp	QWORD PTR fix$[rsp], 0
	je	$LN5@omf_write_

; 391  :             switch( fix->type ) {

	mov	rax, QWORD PTR fix$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv73[rsp], eax
	cmp	DWORD PTR tv73[rsp], 3
	je	SHORT $LN9@omf_write_
	cmp	DWORD PTR tv73[rsp], 6
	je	SHORT $LN9@omf_write_
	cmp	DWORD PTR tv73[rsp], 10
	je	SHORT $LN9@omf_write_
	jmp	SHORT $LN11@omf_write_
$LN9@omf_write_:

; 392  :             case FIX_RELOFF32:
; 393  :             case FIX_OFF32:
; 394  :             case FIX_PTR32:
; 395  :                 if ( !is32 ) continue;

	movsx	eax, BYTE PTR is32$[rsp]
	test	eax, eax
	jne	SHORT $LN10@omf_write_
	jmp	SHORT $LN4@omf_write_
$LN10@omf_write_:

; 396  :                 break;

	jmp	SHORT $LN7@omf_write_
$LN11@omf_write_:

; 397  :             default:
; 398  :                 if ( is32 ) continue;

	movsx	eax, BYTE PTR is32$[rsp]
	test	eax, eax
	je	SHORT $LN12@omf_write_
	jmp	SHORT $LN4@omf_write_
$LN12@omf_write_:
$LN7@omf_write_:

; 399  :                 break;
; 400  :             }
; 401  :             if ( size > 1020 - FIX_GEN_MAX )

	cmp	DWORD PTR size$[rsp], 1009		; 000003f1H
	jbe	SHORT $LN13@omf_write_

; 402  :                 break;

	jmp	SHORT $LN5@omf_write_
$LN13@omf_write_:

; 403  :             data += OmfFixGenFix( fix, seg->e.seginfo->start_loc, data, type );

	mov	rax, QWORD PTR seg$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	r9d, DWORD PTR type$[rsp]
	mov	r8, QWORD PTR data$[rsp]
	mov	edx, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR fix$[rsp]
	call	OmfFixGenFix
	mov	eax, eax
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR data$[rsp], rax

; 404  :             size = (char *)data - StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	rcx, QWORD PTR data$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR size$[rsp], eax

; 405  :         }

	jmp	$LN4@omf_write_
$LN5@omf_write_:

; 406  :         if ( size ) {

	cmp	DWORD PTR size$[rsp], 0
	je	SHORT $LN14@omf_write_

; 407  :             omf_InitRec( &obj, CMD_FIXUPP );

	mov	dl, 156					; 0000009cH
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 408  :             obj.is_32 = is32;

	movzx	eax, BYTE PTR is32$[rsp]
	mov	BYTE PTR obj$[rsp+17], al

; 409  :             AttachData( &obj, StringBufferEnd, size );

	mov	eax, DWORD PTR size$[rsp]
	mov	r8d, eax
	mov	rdx, QWORD PTR ModuleInfo+488
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 410  :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record
$LN14@omf_write_:

; 411  :         }
; 412  :     }

	jmp	$LN2@omf_write_
$LN3@omf_write_:

; 413  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	ret	0
omf_write_fixupp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
data$ = 32
size$ = 40
node$ = 48
ofssize$ = 56
tv66 = 64
next$ = 72
obj$ = 80
__$ArrayPad$ = 128
is32$ = 160
omf_write_linnum PROC

; 348  : {

	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 152				; 00000098H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 349  :     unsigned             ofssize = ( is32 ? sizeof( uint_32) : sizeof( uint_16 ) );

	movzx	eax, BYTE PTR is32$[rsp]
	test	eax, eax
	je	SHORT $LN7@omf_write_
	mov	QWORD PTR tv66[rsp], 4
	jmp	SHORT $LN8@omf_write_
$LN7@omf_write_:
	mov	QWORD PTR tv66[rsp], 2
$LN8@omf_write_:
	mov	eax, DWORD PTR tv66[rsp]
	mov	DWORD PTR ofssize$[rsp], eax

; 350  :     unsigned             size;
; 351  :     uint_8               *data;
; 352  :     struct line_num_info *node;
; 353  :     struct line_num_info *next;
; 354  :     struct omf_rec       obj;
; 355  : 
; 356  :     for( node = LinnumQueue.head, data = StringBufferEnd; node; node = next ) {

	mov	rax, QWORD PTR LinnumQueue
	mov	QWORD PTR node$[rsp], rax
	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR data$[rsp], rax
	jmp	SHORT $LN4@omf_write_
$LN2@omf_write_:
	mov	rax, QWORD PTR next$[rsp]
	mov	QWORD PTR node$[rsp], rax
$LN4@omf_write_:
	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN3@omf_write_

; 357  :         next = node->next;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR next$[rsp], rax

; 358  :         *(uint_16 *)data = node->number;

	mov	rax, QWORD PTR data$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	movzx	ecx, WORD PTR [rcx+8]
	mov	WORD PTR [rax], cx

; 359  :         data += sizeof( uint_16 );

	mov	rax, QWORD PTR data$[rsp]
	add	rax, 2
	mov	QWORD PTR data$[rsp], rax

; 360  :         *(uint_32 *)data = node->offset;

	mov	rax, QWORD PTR data$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	mov	DWORD PTR [rax], ecx

; 361  :         data += ofssize;

	mov	eax, DWORD PTR ofssize$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR data$[rsp], rax

; 362  :         LclFree( node );
; 363  :     }

	jmp	SHORT $LN2@omf_write_
$LN3@omf_write_:

; 364  :     LinnumQueue.head = NULL;

	mov	QWORD PTR LinnumQueue, 0

; 365  : 
; 366  :     size = (char *)data - StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	rcx, QWORD PTR data$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR size$[rsp], eax

; 367  :     if( size ) {

	cmp	DWORD PTR size$[rsp], 0
	je	SHORT $LN5@omf_write_

; 368  :         omf_InitRec( &obj, CMD_LINNUM );

	mov	dl, 148					; 00000094H
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 369  :         obj.is_32 = is32;

	movzx	eax, BYTE PTR is32$[rsp]
	mov	BYTE PTR obj$[rsp+17], al

; 370  :         AttachData( &obj, StringBufferEnd, size );

	mov	eax, DWORD PTR size$[rsp]
	mov	r8d, eax
	mov	rdx, QWORD PTR ModuleInfo+488
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 371  :         obj.d.linnum.base.grp_idx = omf_GetGrpIdx( GetGroup( &CurrSeg->sym ) ); /* fixme ? */

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, rax
	call	GetGroup
	mov	rcx, rax
	call	omf_GetGrpIdx
	mov	WORD PTR obj$[rsp+20], ax

; 372  :         obj.d.linnum.base.seg_idx = CurrSeg->e.seginfo->seg_idx;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, WORD PTR [rax+68]
	mov	WORD PTR obj$[rsp+22], ax

; 373  :         obj.d.linnum.base.frame = 0; /* field not used here */

	xor	eax, eax
	mov	WORD PTR obj$[rsp+24], ax

; 374  :         omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record
$LN5@omf_write_:

; 375  :     }
; 376  :     return;
; 377  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 152				; 00000098H
	ret	0
omf_write_linnum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
tv67 = 0
sym$ = 32
omf_GetGrpIdx PROC

; 276  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 277  :     return( sym ? ((struct dsym *)sym)->e.grpinfo->grp_idx : 0 );

	cmp	QWORD PTR sym$[rsp], 0
	je	SHORT $LN3@omf_GetGrp
	mov	rax, QWORD PTR sym$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR tv67[rsp], eax
	jmp	SHORT $LN4@omf_GetGrp
$LN3@omf_GetGrp:
	mov	DWORD PTR tv67[rsp], 0
$LN4@omf_GetGrp:
	mov	eax, DWORD PTR tv67[rsp]

; 278  : }

	add	rsp, 24
	ret	0
omf_GetGrpIdx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
tv69 = 32
objr$ = 64
data$ = 72
len$ = 80
AttachData PROC

; 256  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 257  : /**/myassert( objr->data == NULL );

	mov	rax, QWORD PTR objr$[rsp]
	cmp	QWORD PTR [rax+8], 0
	jne	SHORT $LN3@AttachData
	mov	DWORD PTR tv69[rsp], 0
	jmp	SHORT $LN4@AttachData
$LN3@AttachData:
	mov	edx, 257				; 00000101H
	lea	rcx, OFFSET FLAT:$SG12314
	call	InternalError
	mov	DWORD PTR tv69[rsp], eax
$LN4@AttachData:

; 258  :     objr->data = data;

	mov	rax, QWORD PTR objr$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 259  :     objr->length = len;

	mov	rax, QWORD PTR objr$[rsp]
	mov	ecx, DWORD PTR len$[rsp]
	mov	DWORD PTR [rax], ecx

; 260  : }

	add	rsp, 56					; 00000038H
	ret	0
AttachData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
tv70 = 32
objr$ = 64
name$ = 72
len$ = 80
PutName	PROC

; 242  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 243  :     /**/myassert( objr != NULL && objr->data != NULL );

	cmp	QWORD PTR objr$[rsp], 0
	je	SHORT $LN3@PutName
	mov	rax, QWORD PTR objr$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@PutName
	mov	DWORD PTR tv70[rsp], 0
	jmp	SHORT $LN4@PutName
$LN3@PutName:
	mov	edx, 243				; 000000f3H
	lea	rcx, OFFSET FLAT:$SG12303
	call	InternalError
	mov	DWORD PTR tv70[rsp], eax
$LN4@PutName:

; 244  : #if MAX_ID_LEN > MAX_ID_LEN_OMF
; 245  :     if ( len > MAX_ID_LEN_OMF ) {
; 246  :         EmitWarn( 1, IDENTIFIER_TOO_LONG );
; 247  :         len = MAX_ID_LEN_OMF;
; 248  :     }
; 249  : #endif
; 250  :     objr->data[objr->curoff++] = len;

	mov	rax, QWORD PTR objr$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR objr$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	edx, BYTE PTR len$[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR objr$[rsp]
	mov	eax, DWORD PTR [rax+4]
	inc	eax
	mov	rcx, QWORD PTR objr$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 251  :     PutData( objr, (uint_8 *)name, len );

	mov	r8, QWORD PTR len$[rsp]
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR objr$[rsp]
	call	PutData

; 252  : }

	add	rsp, 56					; 00000038H
	ret	0
PutName	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
tv70 = 32
objr$ = 64
data$ = 72
len$ = 80
PutData	PROC

; 234  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 235  :     /**/myassert( objr != NULL && objr->data != NULL );

	cmp	QWORD PTR objr$[rsp], 0
	je	SHORT $LN3@PutData
	mov	rax, QWORD PTR objr$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@PutData
	mov	DWORD PTR tv70[rsp], 0
	jmp	SHORT $LN4@PutData
$LN3@PutData:
	mov	edx, 235				; 000000ebH
	lea	rcx, OFFSET FLAT:$SG12290
	call	InternalError
	mov	DWORD PTR tv70[rsp], eax
$LN4@PutData:

; 236  :     memcpy( objr->data + objr->curoff, data, len );

	mov	rax, QWORD PTR objr$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR objr$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	r8, QWORD PTR len$[rsp]
	mov	rdx, QWORD PTR data$[rsp]
	mov	rcx, rax
	call	memcpy

; 237  :     objr->curoff += len;

	mov	rax, QWORD PTR objr$[rsp]
	mov	eax, DWORD PTR [rax+4]
	add	rax, QWORD PTR len$[rsp]
	mov	rcx, QWORD PTR objr$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 238  : }

	add	rsp, 56					; 00000038H
	ret	0
PutData	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
tv71 = 32
objr$ = 64
idx$ = 72
PutIndex PROC

; 224  : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 225  : /**/myassert( objr != NULL && objr->data != NULL && idx <= 0x7FFF );

	cmp	QWORD PTR objr$[rsp], 0
	je	SHORT $LN4@PutIndex
	mov	rax, QWORD PTR objr$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN4@PutIndex
	cmp	DWORD PTR idx$[rsp], 32767		; 00007fffH
	ja	SHORT $LN4@PutIndex
	mov	DWORD PTR tv71[rsp], 0
	jmp	SHORT $LN5@PutIndex
$LN4@PutIndex:
	mov	edx, 225				; 000000e1H
	lea	rcx, OFFSET FLAT:$SG12277
	call	InternalError
	mov	DWORD PTR tv71[rsp], eax
$LN5@PutIndex:

; 226  :     if( idx > 0x7f ) {

	cmp	DWORD PTR idx$[rsp], 127		; 0000007fH
	jbe	SHORT $LN2@PutIndex

; 227  :         objr->data[objr->curoff++] = ( idx >> 8 ) | 0x80;

	mov	eax, DWORD PTR idx$[rsp]
	shr	eax, 8
	bts	eax, 7
	mov	rcx, QWORD PTR objr$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	mov	rdx, QWORD PTR objr$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR objr$[rsp]
	mov	eax, DWORD PTR [rax+4]
	inc	eax
	mov	rcx, QWORD PTR objr$[rsp]
	mov	DWORD PTR [rcx+4], eax
$LN2@PutIndex:

; 228  :     }
; 229  :     objr->data[objr->curoff++] = idx & 0xff;

	mov	eax, DWORD PTR idx$[rsp]
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR objr$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	mov	rdx, QWORD PTR objr$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	mov	BYTE PTR [rdx+rcx], al
	mov	rax, QWORD PTR objr$[rsp]
	mov	eax, DWORD PTR [rax+4]
	inc	eax
	mov	rcx, QWORD PTR objr$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 230  : }

	add	rsp, 56					; 00000038H
	ret	0
PutIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
tv70 = 32
objr$ = 64
value$ = 72
Put32	PROC

; 194  : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 195  : /**/myassert( objr != NULL && objr->data != NULL );

	cmp	QWORD PTR objr$[rsp], 0
	je	SHORT $LN3@Put32
	mov	rax, QWORD PTR objr$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@Put32
	mov	DWORD PTR tv70[rsp], 0
	jmp	SHORT $LN4@Put32
$LN3@Put32:
	mov	edx, 195				; 000000c3H
	lea	rcx, OFFSET FLAT:$SG12267
	call	InternalError
	mov	DWORD PTR tv70[rsp], eax
$LN4@Put32:

; 196  : 
; 197  :     WriteU32( objr->data + objr->curoff, value );

	mov	rax, QWORD PTR objr$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR objr$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	edx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rax+rcx], edx

; 198  :     objr->curoff += sizeof( uint_32 );

	mov	rax, QWORD PTR objr$[rsp]
	mov	eax, DWORD PTR [rax+4]
	add	rax, 4
	mov	rcx, QWORD PTR objr$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 199  : }

	add	rsp, 56					; 00000038H
	ret	0
Put32	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
tv70 = 32
objr$ = 64
value$ = 72
Put16	PROC

; 185  : {

	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 186  : /**/myassert( objr != NULL && objr->data != NULL );

	cmp	QWORD PTR objr$[rsp], 0
	je	SHORT $LN3@Put16
	mov	rax, QWORD PTR objr$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@Put16
	mov	DWORD PTR tv70[rsp], 0
	jmp	SHORT $LN4@Put16
$LN3@Put16:
	mov	edx, 186				; 000000baH
	lea	rcx, OFFSET FLAT:$SG12254
	call	InternalError
	mov	DWORD PTR tv70[rsp], eax
$LN4@Put16:

; 187  : 
; 188  :     WriteU16( objr->data + objr->curoff, value );

	mov	rax, QWORD PTR objr$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR objr$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	edx, WORD PTR value$[rsp]
	mov	WORD PTR [rax+rcx], dx

; 189  :     objr->curoff += sizeof( uint_16 );

	mov	rax, QWORD PTR objr$[rsp]
	mov	eax, DWORD PTR [rax+4]
	add	rax, 2
	mov	rcx, QWORD PTR objr$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 190  : }

	add	rsp, 56					; 00000038H
	ret	0
Put16	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
tv70 = 32
objr$ = 64
value$ = 72
Put8	PROC

; 178  : {

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 179  : /**/myassert( objr != NULL && objr->data != NULL );

	cmp	QWORD PTR objr$[rsp], 0
	je	SHORT $LN3@Put8
	mov	rax, QWORD PTR objr$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@Put8
	mov	DWORD PTR tv70[rsp], 0
	jmp	SHORT $LN4@Put8
$LN3@Put8:
	mov	edx, 179				; 000000b3H
	lea	rcx, OFFSET FLAT:$SG12241
	call	InternalError
	mov	DWORD PTR tv70[rsp], eax
$LN4@Put8:

; 180  :     objr->data[ objr->curoff++ ] = value;

	mov	rax, QWORD PTR objr$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR objr$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	edx, BYTE PTR value$[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	rax, QWORD PTR objr$[rsp]
	mov	eax, DWORD PTR [rax+4]
	inc	eax
	mov	rcx, QWORD PTR objr$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 181  : }

	add	rsp, 56					; 00000038H
	ret	0
Put8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
tv80 = 32
ltime$ = 40
dt$ = 48
x$ = 80
timet2dostime PROC

; 162  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 163  :     struct tm *    ltime;
; 164  :     union DOS_DATETIME dt;
; 165  : 
; 166  :     ltime = localtime( &x );

	lea	rcx, QWORD PTR x$[rsp]
	call	localtime
	mov	QWORD PTR ltime$[rsp], rax

; 167  :     dt.dos.date = (( ltime->tm_year - 80 ) << DATE_YEAR_B )

	mov	rax, QWORD PTR ltime$[rsp]
	mov	eax, DWORD PTR [rax+20]
	sub	eax, 80					; 00000050H
	shl	eax, 9
	mov	rcx, QWORD PTR ltime$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	inc	ecx
	shl	ecx, 5
	or	eax, ecx
	mov	rcx, QWORD PTR ltime$[rsp]
	or	eax, DWORD PTR [rcx+12]
	mov	WORD PTR dt$[rsp+2], ax

; 168  :              | (( ltime->tm_mon + 1 ) << DATE_MON_B )
; 169  :              | (( ltime->tm_mday ) << DATE_DAY_B );
; 170  :     dt.dos.time = (( ltime->tm_hour ) << TIME_HOUR_B )

	mov	rax, QWORD PTR ltime$[rsp]
	mov	eax, DWORD PTR [rax+8]
	shl	eax, 11
	mov	rcx, QWORD PTR ltime$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	shl	ecx, 5
	or	eax, ecx
	mov	DWORD PTR tv80[rsp], eax
	mov	rcx, QWORD PTR ltime$[rsp]
	mov	eax, DWORD PTR [rcx]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR tv80[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	WORD PTR dt$[rsp], ax

; 171  :              | (( ltime->tm_min ) << TIME_MIN_B )
; 172  :              | (( ltime->tm_sec / 2 ) << TIME_SEC_B );
; 173  :     return( dt.timet );

	mov	rax, QWORD PTR dt$[rsp]

; 174  : }

	add	rsp, 72					; 00000048H
	ret	0
timet2dostime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
obj$ = 48
command$ = 56
omf_InitRec PROC

; 150  : {

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 151  :     obj->length = 0;

	mov	rax, QWORD PTR obj$[rsp]
	mov	DWORD PTR [rax], 0

; 152  :     obj->curoff = 0;

	mov	rax, QWORD PTR obj$[rsp]
	mov	DWORD PTR [rax+4], 0

; 153  :     obj->data = NULL;

	mov	rax, QWORD PTR obj$[rsp]
	mov	QWORD PTR [rax+8], 0

; 154  :     obj->command = command;

	mov	rax, QWORD PTR obj$[rsp]
	movzx	ecx, BYTE PTR command$[rsp]
	mov	BYTE PTR [rax+16], cl

; 155  :     obj->is_32 = 0;

	mov	rax, QWORD PTR obj$[rsp]
	mov	BYTE PTR [rax+17], 0

; 156  :     DebugMsg1(("omf_InitRec(%p, %X)\n", obj, command ));

	movzx	eax, BYTE PTR command$[rsp]
	mov	r8d, eax
	mov	rdx, QWORD PTR obj$[rsp]
	lea	rcx, OFFSET FLAT:$SG12225
	call	DoDebugMsg1

; 157  :     return;
; 158  : }

	add	rsp, 40					; 00000028H
	ret	0
omf_InitRec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
is_32$ = 32
size$ = 36
tv75 = 40
tv83 = 48
curr$ = 80
omf_check_flush PROC

; 562  : {

$LN13:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 563  :     uint_8 is_32;
; 564  :     uint_16 size;
; 565  : #if MULTIHDR
; 566  :     if ( curr->srcfile != ln_srcfile ) {

	mov	rax, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR ln_srcfile
	cmp	DWORD PTR [rax+16], ecx
	je	SHORT $LN2@omf_check_

; 567  :         if ( LinnumQueue.head )

	cmp	QWORD PTR LinnumQueue, 0
	je	SHORT $LN3@omf_check_

; 568  :             omf_FlushCurrSeg();

	call	omf_FlushCurrSeg
$LN3@omf_check_:

; 569  :         /* todo: for Borland, there's a COMENT ( CMT_SRCFILE ) that could be written
; 570  :          * instead of THEADR.
; 571  :          */
; 572  :         omf_write_theadr( GetFName( curr->srcfile )->fname );

	mov	rax, QWORD PTR curr$[rsp]
	mov	ecx, DWORD PTR [rax+16]
	call	GetFName
	mov	rcx, QWORD PTR [rax]
	call	omf_write_theadr

; 573  :         ln_srcfile = curr->srcfile;

	mov	rax, QWORD PTR curr$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR ln_srcfile, eax

; 574  :         return;

	jmp	$LN1@omf_check_
$LN2@omf_check_:

; 575  :     }
; 576  : #endif
; 577  :     /* if there's a change in offset magnitude ( 16 -> 32 or 32 -> 16 ),
; 578  :      * do flush ( Masm compatible ).
; 579  :      */
; 580  :     is_32 = ( curr->offset > 0xffff ? TRUE : FALSE );

	mov	rax, QWORD PTR curr$[rsp]
	cmp	DWORD PTR [rax+12], 65535		; 0000ffffH
	jbe	SHORT $LN9@omf_check_
	mov	DWORD PTR tv75[rsp], 1
	jmp	SHORT $LN10@omf_check_
$LN9@omf_check_:
	mov	DWORD PTR tv75[rsp], 0
$LN10@omf_check_:
	movzx	eax, BYTE PTR tv75[rsp]
	mov	BYTE PTR is_32$[rsp], al

; 581  :     if ( ln_is32 != is_32 ) {

	movzx	eax, BYTE PTR ln_is32
	movzx	ecx, BYTE PTR is_32$[rsp]
	cmp	eax, ecx
	je	SHORT $LN4@omf_check_

; 582  :         if ( LinnumQueue.head )

	cmp	QWORD PTR LinnumQueue, 0
	je	SHORT $LN5@omf_check_

; 583  :             omf_FlushCurrSeg();

	call	omf_FlushCurrSeg
$LN5@omf_check_:

; 584  :         ln_is32 = is_32;

	movzx	eax, BYTE PTR is_32$[rsp]
	mov	BYTE PTR ln_is32, al

; 585  :         return;

	jmp	SHORT $LN1@omf_check_
$LN4@omf_check_:

; 586  :     }
; 587  :     /* line number item consists of 16-bit line# and 16- or 32-bit offset */
; 588  :     size = sizeof( uint_16 ) + ( is_32 ? sizeof( uint_32 ) : sizeof( uint_16 ) );

	movzx	eax, BYTE PTR is_32$[rsp]
	test	eax, eax
	je	SHORT $LN11@omf_check_
	mov	QWORD PTR tv83[rsp], 4
	jmp	SHORT $LN12@omf_check_
$LN11@omf_check_:
	mov	QWORD PTR tv83[rsp], 2
$LN12@omf_check_:
	mov	rax, QWORD PTR tv83[rsp]
	add	rax, 2
	mov	WORD PTR size$[rsp], ax

; 589  :     /* if the size of the linnum data exceeds 1016,
; 590  :      * do flush ( Masm compatible ).
; 591  :      */
; 592  :     if ( ln_size + size > 1024 - 8 ) {

	movzx	eax, WORD PTR ln_size
	movzx	ecx, WORD PTR size$[rsp]
	add	eax, ecx
	cmp	eax, 1016				; 000003f8H
	jle	SHORT $LN6@omf_check_

; 593  :         if ( LinnumQueue.head )

	cmp	QWORD PTR LinnumQueue, 0
	je	SHORT $LN7@omf_check_

; 594  :             omf_FlushCurrSeg();

	call	omf_FlushCurrSeg
$LN7@omf_check_:
$LN6@omf_check_:

; 595  :     }
; 596  :     ln_size += size;

	movzx	eax, WORD PTR size$[rsp]
	movzx	ecx, WORD PTR ln_size
	add	ecx, eax
	mov	eax, ecx
	mov	WORD PTR ln_size, ax
$LN1@omf_check_:

; 597  :     return;
; 598  : };

	add	rsp, 72					; 00000048H
	ret	0
omf_check_flush ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
tv68 = 32
omf_FlushCurrSeg PROC

; 503  : {

$LN6:
	sub	rsp, 56					; 00000038H

; 504  :     //unsigned i;
; 505  :     //unsigned size;
; 506  : 
; 507  :     DebugMsg1(( "omf_FlushCurrSeg() enter, CurrSeg=%s, currsrc=%u\n", CurrSeg ? CurrSeg->sym.name : "NULL", get_curr_srcfile() ));

	cmp	QWORD PTR ModuleInfo+432, 0
	je	SHORT $LN4@omf_FlushC
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv68[rsp], rax
	jmp	SHORT $LN5@omf_FlushC
$LN4@omf_FlushC:
	lea	rax, OFFSET FLAT:$SG12413
	mov	QWORD PTR tv68[rsp], rax
$LN5@omf_FlushC:
	call	get_curr_srcfile
	mov	r8d, eax
	mov	rdx, QWORD PTR tv68[rsp]
	lea	rcx, OFFSET FLAT:$SG12414
	call	DoDebugMsg1

; 508  : 
; 509  :     omf_write_ledata( CurrSeg );

	mov	rcx, QWORD PTR ModuleInfo+432
	call	omf_write_ledata

; 510  :     /* add line numbers if debugging info is desired */
; 511  :     //if( write_to_file && Options.line_numbers ) {
; 512  :     if( Options.line_numbers ) {

	movzx	eax, BYTE PTR Options+1
	test	eax, eax
	je	SHORT $LN2@omf_FlushC

; 513  :         omf_write_linnum( ln_is32 );

	movzx	ecx, BYTE PTR ln_is32
	call	omf_write_linnum

; 514  :         ln_size = 0;

	xor	eax, eax
	mov	WORD PTR ln_size, ax
$LN2@omf_FlushC:

; 515  :     }
; 516  :     //if ( Options.no_comment_data_in_code_records == FALSE )
; 517  :     //    omf_OutSelect( FALSE );
; 518  :     return;
; 519  : }

	add	rsp, 56					; 00000038H
	ret	0
omf_FlushCurrSeg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
currofs$ = 32
sel_idx$ = 36
obj$ = 40
buffer$ = 88
__$ArrayPad$ = 104
is_data$ = 128
omf_OutSelect PROC

; 286  : {

$LN12:
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 287  :     struct omf_rec      obj;
; 288  :     uint_32             currofs;
; 289  :     int                 sel_idx;
; 290  :     static uint_32      sel_start;  /* start offset of data items */
; 291  :     unsigned char       buffer[12]; /* max is 11 ( see below ) */
; 292  : 
; 293  :     if( is_data ) {

	movzx	eax, BYTE PTR is_data$[rsp]
	test	eax, eax
	je	SHORT $LN2@omf_OutSel

; 294  :         /* do nothing if it isn't the first data item or
; 295  :          * if current segment isn't code
; 296  :          */
; 297  :         if( CurrSeg->e.seginfo->data_in_code ||

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+107]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@omf_OutSel
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+72], 1
	je	SHORT $LN4@omf_OutSel
$LN5@omf_OutSel:

; 298  :            ( CurrSeg->e.seginfo->segtype != SEGTYPE_CODE ) )
; 299  :             return;

	jmp	$LN1@omf_OutSel
$LN4@omf_OutSel:

; 300  :         sel_start = GetCurrOffset();

	call	GetCurrOffset
	mov	DWORD PTR ?sel_start@?1??omf_OutSelect@@9@9, eax

; 301  :         CurrSeg->e.seginfo->data_in_code = TRUE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+107]
	or	al, 8
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+104]
	mov	BYTE PTR [rcx+107], al

; 302  :         DebugMsg(("omf_OutSelect: data in code segment (%s), starting at %" I32_SPEC "X\n", CurrSeg->sym.name, sel_start ));

	mov	r8d, DWORD PTR ?sel_start@?1??omf_OutSelect@@9@9
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG12334
	call	DoDebugMsg
	jmp	$LN3@omf_OutSel
$LN2@omf_OutSel:

; 303  :     } else if ( CurrSeg->e.seginfo->data_in_code ) { /* data items written? */

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+107]
	shr	al, 3
	and	al, 1
	movzx	eax, al
	test	eax, eax
	je	$LN6@omf_OutSel

; 304  :         
; 305  :         CurrSeg->e.seginfo->data_in_code = FALSE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+107]
	and	al, 247					; 000000f7H
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rcx+104]
	mov	BYTE PTR [rcx+107], al

; 306  : 
; 307  :         if( write_to_file == TRUE ) {

	movzx	eax, BYTE PTR write_to_file
	cmp	eax, 1
	jne	$LN7@omf_OutSel

; 308  :             omf_InitRec( &obj, CMD_COMENT );

	mov	dl, 136					; 00000088H
	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_InitRec

; 309  :             obj.d.coment.attr = CMT_TNP;

	mov	BYTE PTR obj$[rsp+20], 128		; 00000080H

; 310  :             obj.d.coment.cmt_class = CMT_DISASM_DIRECTIVE;

	mov	BYTE PTR obj$[rsp+21], 253		; 000000fdH

; 311  : 
; 312  :             sel_idx = GetSegIdx( &CurrSeg->sym );

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, rax
	call	GetSegIdx
	mov	DWORD PTR sel_idx$[rsp], eax

; 313  : 
; 314  :             //AllocData( objr, 11 );  /* 11 = 1 + 2 + 4 + 4 */
; 315  :             AttachData( &obj, buffer, 11 );  /* 11 = 1 + 2 + 4 + 4 */

	mov	r8d, 11
	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR obj$[rsp]
	call	AttachData

; 316  :             currofs = GetCurrOffset();

	call	GetCurrOffset
	mov	DWORD PTR currofs$[rsp], eax

; 317  :             DebugMsg(("omf_OutSelect: writing coment record about data in code: start=%" I32_SPEC "X curofs=%" I32_SPEC "X\n", sel_start, currofs ));

	mov	r8d, DWORD PTR currofs$[rsp]
	mov	edx, DWORD PTR ?sel_start@?1??omf_OutSelect@@9@9
	lea	rcx, OFFSET FLAT:$SG12337
	call	DoDebugMsg

; 318  :             if( ( sel_start > 0xffffUL ) || ( currofs > 0xffffUL ) ) {

	cmp	DWORD PTR ?sel_start@?1??omf_OutSelect@@9@9, 65535 ; 0000ffffH
	ja	SHORT $LN10@omf_OutSel
	cmp	DWORD PTR currofs$[rsp], 65535		; 0000ffffH
	jbe	SHORT $LN8@omf_OutSel
$LN10@omf_OutSel:

; 319  :                 Put8( &obj, DDIR_SCAN_TABLE_32 );

	mov	dl, 83					; 00000053H
	lea	rcx, QWORD PTR obj$[rsp]
	call	Put8

; 320  :                 PutIndex( &obj, sel_idx );

	mov	edx, DWORD PTR sel_idx$[rsp]
	lea	rcx, QWORD PTR obj$[rsp]
	call	PutIndex

; 321  :                 Put32( &obj, sel_start );

	mov	edx, DWORD PTR ?sel_start@?1??omf_OutSelect@@9@9
	lea	rcx, QWORD PTR obj$[rsp]
	call	Put32

; 322  :                 Put32( &obj, currofs );

	mov	edx, DWORD PTR currofs$[rsp]
	lea	rcx, QWORD PTR obj$[rsp]
	call	Put32

; 323  :             } else {

	jmp	SHORT $LN9@omf_OutSel
$LN8@omf_OutSel:

; 324  :                 Put8( &obj, DDIR_SCAN_TABLE );

	mov	dl, 115					; 00000073H
	lea	rcx, QWORD PTR obj$[rsp]
	call	Put8

; 325  :                 PutIndex( &obj, sel_idx );

	mov	edx, DWORD PTR sel_idx$[rsp]
	lea	rcx, QWORD PTR obj$[rsp]
	call	PutIndex

; 326  :                 Put16( &obj, sel_start );

	movzx	edx, WORD PTR ?sel_start@?1??omf_OutSelect@@9@9
	lea	rcx, QWORD PTR obj$[rsp]
	call	Put16

; 327  :                 Put16( &obj, currofs );

	movzx	edx, WORD PTR currofs$[rsp]
	lea	rcx, QWORD PTR obj$[rsp]
	call	Put16
$LN9@omf_OutSel:

; 328  :             }
; 329  :             TruncRec( &obj );

	mov	eax, DWORD PTR obj$[rsp+4]
	mov	DWORD PTR obj$[rsp], eax

; 330  :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record
$LN7@omf_OutSel:
$LN6@omf_OutSel:
$LN3@omf_OutSel:
$LN1@omf_OutSel:

; 331  :         }
; 332  :     }
; 333  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
omf_OutSelect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
omf_set_filepos PROC

; 622  : {

$LN3:
	sub	rsp, 40					; 00000028H

; 623  :     DebugMsg1(( "omf_set_filepos: reset file pos to %X\n", end_of_header ));

	mov	edx, DWORD PTR end_of_header
	lea	rcx, OFFSET FLAT:$SG12446
	call	DoDebugMsg1

; 624  : #if MULTIHDR
; 625  : #endif
; 626  :     fseek( CurrFile[OBJ], end_of_header, SEEK_SET );

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:ModuleInfo+96
	xor	r8d, r8d
	mov	edx, DWORD PTR end_of_header
	mov	rcx, QWORD PTR [rcx+rax]
	call	fseek

; 627  : }

	add	rsp, 40					; 00000028H
	ret	0
omf_set_filepos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_TEXT	SEGMENT
modinfo$ = 48
omf_init PROC

; 1672 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1673 :     DebugMsg(("omf_init enter\n"));

	lea	rcx, OFFSET FLAT:$SG12841
	call	DoDebugMsg

; 1674 :     modinfo->g.WriteModule = omf_write_module;

	mov	rax, QWORD PTR modinfo$[rsp]
	lea	rcx, OFFSET FLAT:omf_write_module
	mov	QWORD PTR [rax+288], rcx

; 1675 :     modinfo->g.Pass1Checks = omf_write_header_initial;

	mov	rax, QWORD PTR modinfo$[rsp]
	lea	rcx, OFFSET FLAT:omf_write_header_initial
	mov	QWORD PTR [rax+304], rcx

; 1676 :     SymDebSeg[DBGS_SYMBOLS] = NULL;

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:SymDebSeg
	mov	QWORD PTR [rcx+rax], 0

; 1677 :     SymDebSeg[DBGS_TYPES] = NULL;

	mov	eax, 8
	imul	rax, rax, 1
	lea	rcx, OFFSET FLAT:SymDebSeg
	mov	QWORD PTR [rcx+rax], 0

; 1678 : #if MULTIHDR
; 1679 :     ln_srcfile = modinfo->srcfile;

	mov	rax, QWORD PTR modinfo$[rsp]
	mov	eax, DWORD PTR [rax+428]
	mov	DWORD PTR ln_srcfile, eax

; 1680 : #endif
; 1681 :     ln_size = 0;

	xor	eax, eax
	mov	WORD PTR ln_size, ax

; 1682 :     return;
; 1683 : }

	add	rsp, 40					; 00000028H
	ret	0
omf_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
localtime PROC

; 508  :         {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 509  :             #pragma warning(push)
; 510  :             #pragma warning(disable: 4996)
; 511  :             return _localtime64(_Time);

	mov	rcx, QWORD PTR _Time$[rsp]
	call	_localtime64

; 512  :             #pragma warning(pop)
; 513  :         }

	add	rsp, 40					; 00000028H
	ret	0
localtime ENDP
_TEXT	ENDS
END
