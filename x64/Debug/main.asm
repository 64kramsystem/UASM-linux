; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	broadflags:BYTE
COMM	evex:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
$SG8063	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG8061	DB	'HJWASM', 00H
	ORG $+1
$SG8065	DB	'main: _findfirst(%s) failed', 0aH, 00H
	ORG $+3
$SG8066	DB	'main: fname=%s', 0aH, 00H
$SG8069	DB	'%s', 00H
	ORG $+5
$SG8071	DB	'main: exit, return code=%u', 0aH, 00H
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	main
EXTRN	signal:PROC
EXTRN	__acrt_iob_func:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	exit:PROC
EXTRN	getenv:PROC
EXTRN	memcpy:PROC
EXTRN	strcpy:PROC
EXTRN	DoDebugMsg:PROC
EXTRN	EmitError:PROC
EXTRN	EmitErr:PROC
EXTRN	ErrnoStr:PROC
EXTRN	write_logo:PROC
EXTRN	AssembleModule:PROC
EXTRN	close_files:PROC
EXTRN	MsgGetEx:PROC
EXTRN	ParseCmdline:PROC
EXTRN	CmdlineFini:PROC
EXTRN	GetFNamePart:PROC
EXTRN	_findclose:PROC
EXTRN	_findfirst64i32:PROC
EXTRN	_findnext64i32:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	Options:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$genfailure DD imagerel genfailure
	DD	imagerel genfailure+45
	DD	imagerel $unwind$genfailure
$pdata$main DD	imagerel $LN13
	DD	imagerel $LN13+616
	DD	imagerel $unwind$main
pdata	ENDS
xdata	SEGMENT
$unwind$genfailure DD 010801H
	DD	04208H
$unwind$main DD	022219H
	DD	0550110H
	DD	imagerel __GSHandlerCheck
	DD	0290H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\main.c
_TEXT	SEGMENT
numFiles$ = 32
rc$ = 36
dirsize$ = 40
numArgs$ = 44
pEnv$ = 48
fh$ = 56
pfn$ = 64
finfo$ = 80
fname$ = 384
__$ArrayPad$ = 656
argc$ = 688
argv$ = 696
main	PROC

; 62   : {

$LN13:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 680				; 000002a8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 63   : 	char    *pEnv;
; 64   : 	int     numArgs = 0;

	mov	DWORD PTR numArgs$[rsp], 0

; 65   : 	int     numFiles = 0;

	mov	DWORD PTR numFiles$[rsp], 0

; 66   : 	int     rc = 0;

	mov	DWORD PTR rc$[rsp], 0

; 67   : 
; 68   : #if WILDCARDS
; 69   : 	/* v2.11: _findfirst/next/close() handle, should be of type intptr_t.
; 70   : 	* since this type isn't necessarily defined, type long is used as substitute.
; 71   : 	*/
; 72   : 
; 73   : 	size_t    fh;
; 74   : 	const char *pfn;
; 75   : 	int     dirsize;
; 76   : 	struct  _finddata_t finfo;
; 77   : 	char    fname[FILENAME_MAX];
; 78   : #endif
; 79   : 
; 80   : #if 0 //def DEBUG_OUT    /* DebugMsg() cannot be used that early */
; 81   : 	int i;
; 82   : 	for ( i = 1; i < argc; i++ ) {
; 83   : 		printf("argv[%u]=>%s<\n", i, argv[i] );
; 84   : 	}
; 85   : #endif
; 86   : 
; 87   : #ifdef TRMEM
; 88   : 	tm_Init();
; 89   : #endif
; 90   : 
; 91   : 	pEnv = getenv("HJWASM");

	lea	rcx, OFFSET FLAT:$SG8061
	call	getenv
	mov	QWORD PTR pEnv$[rsp], rax

; 92   : 	if (pEnv == NULL)

	cmp	QWORD PTR pEnv$[rsp], 0
	jne	SHORT $LN7@main

; 93   : 		pEnv = "";

	lea	rax, OFFSET FLAT:$SG8063
	mov	QWORD PTR pEnv$[rsp], rax
$LN7@main:

; 94   : 	argv[0] = pEnv;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR argv$[rsp]
	mov	rdx, QWORD PTR pEnv$[rsp]
	mov	QWORD PTR [rcx+rax], rdx

; 95   : 
; 96   : #ifndef DEBUG_OUT
; 97   : 	signal(SIGSEGV, genfailure);
; 98   : #endif
; 99   : 
; 100  : #if CATCHBREAK
; 101  : 	signal(SIGBREAK, genfailure);

	lea	rdx, OFFSET FLAT:genfailure
	mov	ecx, 21
	call	signal
$LN2@main:

; 102  : #else
; 103  : 	signal(SIGTERM, genfailure);
; 104  : #endif
; 105  : 	/* ParseCmdLine() returns NULL if no source file name has been found (anymore) */
; 106  : 	while (ParseCmdline((const char **)argv, &numArgs)) {

	lea	rdx, QWORD PTR numArgs$[rsp]
	mov	rcx, QWORD PTR argv$[rsp]
	call	ParseCmdline
	test	rax, rax
	je	$LN3@main

; 107  : 		numFiles++;

	mov	eax, DWORD PTR numFiles$[rsp]
	inc	eax
	mov	DWORD PTR numFiles$[rsp], eax

; 108  : 		write_logo();

	call	write_logo

; 109  : #if WILDCARDS
; 110  : 		if ((fh = _findfirst(Options.names[ASM], &finfo)) == -1) {

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:Options+32
	lea	rdx, QWORD PTR finfo$[rsp]
	mov	rcx, QWORD PTR [rcx+rax]
	call	_findfirst64i32
	mov	QWORD PTR fh$[rsp], rax
	cmp	QWORD PTR fh$[rsp], -1
	jne	SHORT $LN8@main

; 111  : 			DebugMsg(("main: _findfirst(%s) failed\n", Options.names[ASM]));

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:Options+32
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:$SG8065
	call	DoDebugMsg

; 112  : 			EmitErr(CANNOT_OPEN_FILE, Options.names[ASM], ErrnoStr());

	call	ErrnoStr
	mov	ecx, 8
	imul	rcx, rcx, 0
	lea	rdx, OFFSET FLAT:Options+32
	mov	r8, rax
	mov	rdx, QWORD PTR [rdx+rcx]
	mov	ecx, 106				; 0000006aH
	call	EmitErr

; 113  : 			break;

	jmp	$LN3@main
$LN8@main:

; 114  : 		}
; 115  : 		/* v2.12: _splitpath()/_makepath() removed */
; 116  : 		//_splitpath( Options.names[ASM], drv, dir, NULL, NULL );
; 117  : 		//DebugMsg(("main: _splitpath(%s): drv=\"%s\" dir=\"%s\"\n", Options.names[ASM], drv, dir ));
; 118  : 		pfn = GetFNamePart(Options.names[ASM]);

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:Options+32
	mov	rcx, QWORD PTR [rcx+rax]
	call	GetFNamePart
	mov	QWORD PTR pfn$[rsp], rax

; 119  : 		dirsize = pfn - Options.names[ASM];

	mov	eax, 8
	imul	rax, rax, 0
	lea	rcx, OFFSET FLAT:Options+32
	mov	rax, QWORD PTR [rcx+rax]
	mov	rcx, QWORD PTR pfn$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	DWORD PTR dirsize$[rsp], eax

; 120  : 		memcpy(fname, Options.names[ASM], dirsize);

	movsxd	rax, DWORD PTR dirsize$[rsp]
	mov	ecx, 8
	imul	rcx, rcx, 0
	lea	rdx, OFFSET FLAT:Options+32
	mov	r8, rax
	mov	rdx, QWORD PTR [rdx+rcx]
	lea	rcx, QWORD PTR fname$[rsp]
	call	memcpy
$LN6@main:

; 121  : 			do {
; 122  : 				/* v2.12: _splitpath()/_makepath() removed */
; 123  : 				//_makepath( fname, drv, dir, finfo.name, NULL );
; 124  : 				//DebugMsg(("main: _makepath(\"%s\", \"%s\", \"%s\")=\"%s\"\n", drv, dir, finfo.name, fname ));
; 125  : 				strcpy(&fname[dirsize], finfo.name);

	movsxd	rax, DWORD PTR dirsize$[rsp]
	lea	rax, QWORD PTR fname$[rsp+rax]
	lea	rdx, QWORD PTR finfo$[rsp+36]
	mov	rcx, rax
	call	strcpy

; 126  : 				DebugMsg(("main: fname=%s\n", fname));

	lea	rdx, QWORD PTR fname$[rsp]
	lea	rcx, OFFSET FLAT:$SG8066
	call	DoDebugMsg

; 127  : 				rc = AssembleModule(fname);  /* assemble 1 module */

	lea	rcx, QWORD PTR fname$[rsp]
	call	AssembleModule
	mov	DWORD PTR rc$[rsp], eax

; 128  : 			} while ((_findnext(fh, &finfo) != -1));

	lea	rdx, QWORD PTR finfo$[rsp]
	mov	rcx, QWORD PTR fh$[rsp]
	call	_findnext64i32
	cmp	eax, -1
	jne	SHORT $LN6@main

; 129  : 		    _findclose(fh);

	mov	rcx, QWORD PTR fh$[rsp]
	call	_findclose

; 130  : #else
; 131  : 		rc = AssembleModule( Options.names[ASM] );
; 132  : #endif
; 133  : 	};

	jmp	$LN2@main
$LN3@main:

; 134  : 	CmdlineFini();

	call	CmdlineFini

; 135  : 	if (numArgs == 0) {

	cmp	DWORD PTR numArgs$[rsp], 0
	jne	SHORT $LN9@main

; 136  : 		write_logo();

	call	write_logo

; 137  : 		printf("%s", MsgGetEx(MSG_USAGE));

	xor	ecx, ecx
	call	MsgGetEx
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG8069
	call	printf

; 138  : 	}

	jmp	SHORT $LN10@main
$LN9@main:

; 139  : 	else if (numFiles == 0)

	cmp	DWORD PTR numFiles$[rsp], 0
	jne	SHORT $LN11@main

; 140  : 		EmitError(NO_FILENAME_SPECIFIED);

	mov	ecx, 104				; 00000068H
	call	EmitError
$LN11@main:
$LN10@main:

; 141  : 
; 142  : #ifdef TRMEM
; 143  : 	tm_Fini();
; 144  : #endif
; 145  : 
; 146  : 	DebugMsg(("main: exit, return code=%u\n", 1 - rc));

	mov	eax, 1
	sub	eax, DWORD PTR rc$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG8071
	call	DoDebugMsg

; 147  : 	return(1 - rc); /* zero if no errors */

	mov	eax, 1
	sub	eax, DWORD PTR rc$[rsp]

; 148  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 680				; 000002a8H
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\main.c
_TEXT	SEGMENT
signo$ = 48
genfailure PROC

; 50   : {

	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 51   : #if CATCHBREAK
; 52   :     if (signo != SIGBREAK)

	cmp	DWORD PTR signo$[rsp], 21
	je	SHORT $LN2@genfailure

; 53   : #else
; 54   :     if (signo != SIGTERM)
; 55   : #endif
; 56   :         EmitError( GENERAL_FAILURE );

	mov	ecx, 168				; 000000a8H
	call	EmitError
$LN2@genfailure:

; 57   :     close_files();

	call	close_files

; 58   :     exit( EXIT_FAILURE );

	mov	ecx, 1
	call	exit
$LN3@genfailure:

; 59   : }

	add	rsp, 40					; 00000028H
	ret	0
genfailure ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 950  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	__acrt_iob_func
	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, rax
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 955  :     __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 956  :     return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 957  : }

	add	rsp, 56					; 00000038H
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _Stream$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 640  : }

	add	rsp, 56					; 00000038H
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
