; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	__real@3810000000000000
PUBLIC	__real@47efffffe0000000
PUBLIC	__real@bff0000000000000
PUBLIC	atofloat
EXTRN	strtod:NEAR
EXTRN	_errno:NEAR
EXTRN	strtotb:NEAR
EXTRN	EmitWarn:NEAR
EXTRN	Parse_Pass:DWORD
EXTRN	EmitErr:NEAR
EXTRN	myatoi128:NEAR
EXTRN	_fltused:DWORD
EXTRN	memset:NEAR
;	COMDAT __real@bff0000000000000
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\atofloat.c
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@47efffffe0000000
CONST	SEGMENT
__real@47efffffe0000000 DQ 047efffffe0000000r	; 3.40282e+038
CONST	ENDS
;	COMDAT __real@3810000000000000
CONST	SEGMENT
__real@3810000000000000 DQ 03810000000000000r	; 1.17549e-038
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
xdata	SEGMENT
$unwind$atofloat DD 092001H
	DD	077420H
	DD	08641bH
	DD	095416H
	DD	0a3411H
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$atofloat DD @imagerel($LN26#)
	DD	@imagerel($LN26#+139)
	DD	@imagerel($unwind$atofloat#)
pdata	ENDS
xdata	SEGMENT
$chain$4$atofloat DD 020621H
	DD	026806H
	DD	@imagerel($LN26#)
	DD	@imagerel($LN26#+139)
	DD	@imagerel($unwind$atofloat#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$atofloat DD @imagerel($LN26#+139)
	DD	@imagerel($LN26#+372)
	DD	@imagerel($chain$4$atofloat#)
pdata	ENDS
xdata	SEGMENT
$chain$5$atofloat DD 021H
	DD	@imagerel($LN26#)
	DD	@imagerel($LN26#+139)
	DD	@imagerel($unwind$atofloat#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$atofloat DD @imagerel($LN26#+372)
	DD	@imagerel($LN26#+397)
	DD	@imagerel($chain$5$atofloat#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
out$ = 96
inp$ = 104
size$ = 112
negative$ = 120
ftype$ = 128
atofloat PROC NEAR

; 26   : {

$LN26:
	sub	rsp, 88					; 00000058H

; 27   :     //const char *inp;
; 28   :     double  double_value;
; 29   :     float   float_value;
; 30   : 
; 31   :     /* v2.04: accept and handle 'real number designator' */
; 32   :     if ( ftype ) {

	cmp	BYTE PTR ftype$[rsp], 0
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+56], rdi
	mov	ebx, r8d
	movzx	edi, r9b
	mov	rbp, rdx
	mov	rsi, rcx
	je	SHORT $LN18@atofloat

; 33   :         uint_8 *p;
; 34   :         uint_8 *end;
; 35   :         /* convert hex string with float "designator" to float.
; 36   :          * this is supposed to work with real4, real8 and real10.
; 37   :          * v2.11: use myatoi128() for conversion ( this function
; 38   :          *        always initializes and reads a 16-byte number ).
; 39   :          *        then check that the number fits in the variable.
; 40   :          */
; 41   :         myatoi128( inp, (uint_64 *)out, 16, strlen( inp ) - 1 );

	xor	eax, eax
	mov	rdi, rdx
	mov	rcx, -1
	repne scasb
	lea	r8d, QWORD PTR [rax+16]
	mov	rdx, rsi
	not	rcx
	lea	r9d, DWORD PTR [rcx-2]
	mov	rcx, rbp
	call	myatoi128

; 42   :         for ( p = (uint_8 *)out + size, end = (uint_8 *)out + 16; p < end; p++ )

	lea	rdx, QWORD PTR [rsi+rbx]
	lea	rax, QWORD PTR [rsi+16]
	cmp	rdx, rax
	jae	$LN11@atofloat
$LL17@atofloat:

; 43   :             if ( *p != NULLC ) {

	cmp	BYTE PTR [rdx], 0
	jne	SHORT $LN22@atofloat
	inc	rdx
	cmp	rdx, rax
	jb	SHORT $LL17@atofloat
	jmp	$LN11@atofloat
$LN22@atofloat:

; 44   :                 EmitErr( INVALID_DATA_INITIALIZER, inp );

	mov	rdx, rbp
	mov	ecx, 231				; 000000e7H
	call	EmitErr

; 45   :                 break;
; 46   :             }
; 47   :     } else {

	jmp	$LN11@atofloat
$LN18@atofloat:

; 48   :         switch ( size ) {

	cmp	ebx, 4
	movdqa	XMMWORD PTR [rsp+32], xmm6
	je	$LN10@atofloat
	cmp	ebx, 8
	je	SHORT $LN6@atofloat
	cmp	ebx, 10
	je	SHORT $LN3@atofloat

; 89   :         default:
; 90   :             /* sizes != 4,8 or 10 aren't accepted.
; 91   :              * Masm ignores silently, HJWasm also unless -W4 is set.
; 92   :              */
; 93   :             if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN1@atofloat

; 94   :                 EmitWarn( 4, FP_INITIALIZER_IGNORED );

	mov	edx, 74					; 0000004aH
	lea	ecx, QWORD PTR [rdx-70]
	call	EmitWarn
$LN1@atofloat:

; 95   :             memset( (char *)out, 0, size );

	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rsi
	call	memset
	jmp	$LN25@atofloat
$LN3@atofloat:

; 86   :         case 10:
; 87   :             strtotb( inp, (struct TB_LD *)out, negative );

	mov	rdx, rcx
	movzx	r8d, dil
	mov	rcx, rbp
	call	strtotb

; 88   :             break;

	jmp	$LN25@atofloat
$LN6@atofloat:

; 73   :             break;
; 74   :         case 8:
; 75   :             errno = 0; /* v2.11: init errno; errno is set on over- and under-flow */

	call	_errno

; 76   :             double_value = strtod( inp, NULL );

	xor	edx, edx
	mov	rcx, rbp
	mov	DWORD PTR [rax], 0
	call	strtod
	movsdx	xmm6, xmm0

; 77   :             /* v2.11: check added */
; 78   :             if ( errno == ERANGE ) {

	call	_errno
	cmp	DWORD PTR [rax], 34			; 00000022H
	jne	SHORT $LN5@atofloat

; 79   :                 DebugMsg(("atofloat(%s, 8): magnitude too large\n", inp ));
; 80   :                 EmitErr( MAGNITUDE_TOO_LARGE_FOR_SPECIFIED_SIZE );

	mov	ecx, 76					; 0000004cH
	call	EmitErr
$LN5@atofloat:

; 81   :             }
; 82   :             if( negative )

	test	dil, dil
	je	SHORT $LN4@atofloat

; 83   :                 double_value *= -1;

	mulsd	xmm6, QWORD PTR __real@bff0000000000000
$LN4@atofloat:

; 84   :             *(double *)out = double_value;

	movsdx	QWORD PTR [rsi], xmm6

; 85   :             break;

	jmp	SHORT $LN25@atofloat
$LN10@atofloat:

; 49   :         case 4:
; 50   : #if USESTRTOF
; 51   :             errno = 0;
; 52   :             float_value = strtof( inp, NULL );
; 53   :             if ( errno == ERANGE ) {
; 54   :                 DebugMsg(("atofloat(%s, 4): magnitude too large\n", inp ));
; 55   :                 EmitErr( MAGNITUDE_TOO_LARGE_FOR_SPECIFIED_SIZE );
; 56   :             }
; 57   :             if( negative )
; 58   :                 float_value *= -1;
; 59   : #else
; 60   :             double_value = strtod( inp, NULL );

	xor	edx, edx
	mov	rcx, rbp
	call	strtod

; 61   :             /* v2.06: check FLT_MAX added */
; 62   :             /* v2.11: check FLT_MIN (min positive value) added */
; 63   :             //if ( double_value > FLT_MAX )
; 64   :             if ( double_value > FLT_MAX || ( double_value < FLT_MIN && double_value != 0 ) ) {

	comisd	xmm0, QWORD PTR __real@47efffffe0000000
	movsdx	xmm6, xmm0
	ja	SHORT $LN24@atofloat
	movlpd	xmm1, QWORD PTR __real@3810000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN9@atofloat
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	jp	SHORT $LN24@atofloat
	je	SHORT $LN9@atofloat
$LN24@atofloat:

; 65   :                 DebugMsg(("atofloat(%s, 4): magnitude too large; FLT_MAX=%e FLT_MIN=%e\n", inp, FLT_MAX, FLT_MIN ));
; 66   :                 EmitErr( MAGNITUDE_TOO_LARGE_FOR_SPECIFIED_SIZE );

	mov	ecx, 76					; 0000004cH
	call	EmitErr
$LN9@atofloat:

; 67   :             }
; 68   :             if( negative )

	test	dil, dil
	je	SHORT $LN7@atofloat

; 69   :                 double_value *= -1;

	mulsd	xmm6, QWORD PTR __real@bff0000000000000
$LN7@atofloat:

; 70   :             float_value = double_value;
; 71   : #endif
; 72   :             *(float *)out = float_value;

	cvtsd2ss xmm0, xmm6
	movss	DWORD PTR [rsi], xmm0
$LN25@atofloat:
	movdqa	xmm6, XMMWORD PTR [rsp+32]
$LN11@atofloat:
	mov	rdi, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+80]

; 96   :         }
; 97   :     }
; 98   :     return;
; 99   : }

	add	rsp, 88					; 00000058H
	ret	0
atofloat ENDP
_TEXT	ENDS
END
