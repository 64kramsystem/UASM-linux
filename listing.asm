; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG6445	DB	01H DUP (?)
	ALIGN	4

$SG6434	DB	01H DUP (?)
	ALIGN	4

$SG6417	DB	01H DUP (?)
	ALIGN	4

$SG6410	DB	01H DUP (?)
	ALIGN	4

$SG6399	DB	01H DUP (?)
	ALIGN	4

$SG6365	DB	01H DUP (?)
	ALIGN	4

$SG6319	DB	01H DUP (?)
	ALIGN	4

$SG6309	DB	01H DUP (?)
	ALIGN	4

$SG6299	DB	01H DUP (?)
	ALIGN	4

$SG6279	DB	01H DUP (?)
	ALIGN	4

$SG6262	DB	01H DUP (?)
	ALIGN	4

$SG6254	DB	01H DUP (?)
	ALIGN	4

$SG6234	DB	01H DUP (?)
	ALIGN	4

$SG6215	DB	01H DUP (?)
	ALIGN	4

?prefix@?1??log_struct@@9@9 DD 01H DUP (?)		; `log_struct'::`2'::prefix
$SG6154	DB	01H DUP (?)
	ALIGN	4

$SG6134	DB	01H DUP (?)
	ALIGN	4

$SG5896	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	list_pos:DWORD
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
dots	DB	' . . . . . . . . . . . . . . . .', 00H
	ORG $+7
szFmtProcStk DB	'  %s %s        %-17s %s %c %04X', 00H
CONST	ENDS
_DATA	SEGMENT
$SG5852	DB	'Byte', 00H
	ORG $+3
$SG5853	DB	'Word', 00H
	ORG $+3
$SG5854	DB	'DWord', 00H
	ORG $+2
$SG5855	DB	'FWord', 00H
	ORG $+2
$SG5856	DB	'QWord', 00H
	ORG $+2
$SG5857	DB	'TByte', 00H
	ORG $+2
$SG5858	DB	'Para', 00H
	ORG $+3
$SG5859	DB	'XmmWord', 00H
$SG5860	DB	'YmmWord', 00H
$SG5861	DB	'ZmmWord', 00H
$SG5862	DB	'Page', 00H
	ORG $+3
$SG5863	DB	'Near', 00H
	ORG $+3
$SG5864	DB	'Near16', 00H
	ORG $+1
$SG5865	DB	'Near32', 00H
	ORG $+1
$SG5866	DB	'Near64', 00H
	ORG $+1
$SG5867	DB	'Far', 00H
$SG5868	DB	'Far16', 00H
	ORG $+2
$SG5869	DB	'Far32', 00H
	ORG $+2
$SG5870	DB	'Far64', 00H
	ORG $+2
$SG5871	DB	'L Near', 00H
	ORG $+5
$SG5872	DB	'L Near16', 00H
	ORG $+7
$SG5873	DB	'L Near32', 00H
	ORG $+7
$SG5874	DB	'L Near64', 00H
	ORG $+3
$SG5875	DB	'L Far', 00H
	ORG $+6
$SG5876	DB	'L Far16', 00H
$SG5877	DB	'L Far32', 00H
$SG5878	DB	'L Far64', 00H
$SG5879	DB	'Ptr', 00H
$SG5880	DB	'Proc', 00H
	ORG $+3
$SG5881	DB	'Func', 00H
	ORG $+3
$SG5882	DB	'Number', 00H
	ORG $+5
$SG5883	DB	'Private', 00H
$SG5884	DB	'Stack', 00H
	ORG $+2
$SG5885	DB	'Public', 00H
	ORG $+1
$SG5886	DB	'Common', 00H
	ORG $+1
$SG5887	DB	'External', 00H
	ORG $+7
$SG5888	DB	'Undefined', 00H
	ORG $+2
$SG5889	DB	'GROUP', 00H
	ORG $+2
$SG5890	DB	'No Seg', 00H
	ORG $+1
$SG5891	DB	'Text', 00H
	ORG $+3
$SG5892	DB	'Alias', 00H
	ORG $+2
$SG5893	DB	'Abs', 00H
$SG5894	DB	'COMM', 00H
	ORG $+3
$SG5895	DB	'VARARG', 00H
	ORG $+1
$SG5897	DB	'C', 00H
	ORG $+6
$SG5898	DB	'SYSCALL', 00H
$SG5899	DB	'STDCALL', 00H
$SG5900	DB	'PASCAL', 00H
	ORG $+1
$SG5901	DB	'FORTRAN', 00H
$SG5902	DB	'BASIC', 00H
	ORG $+2
$SG5903	DB	'FASTCALL', 00H
	ORG $+7
$SG5904	DB	'Macros:', 00H
$SG5905	DB	'                N a m e                 Type', 00H
	ORG $+3
$SG5906	DB	'Structures and Unions:', 00H
	ORG $+1
$SG5907	DB	'                N a m e                 Size/Ofs   Type', 00H
$SG5908	DB	'Records:', 00H
	ORG $+15
$SG5909	DB	'                N a m e                 Width   # fields'
	DB	0aH, '                                        Shift   Width   '
	DB	' Mask   Initial', 00H
	ORG $+3
$SG5910	DB	'Types:', 00H
	ORG $+5
$SG5911	DB	'                N a m e                 Size    Attr', 00H
	ORG $+3
$SG5912	DB	'Segments and Groups:', 00H
	ORG $+3
$SG5913	DB	'                N a m e                 Size     Length '
	DB	'  Align   Combine Class', 00H
$SG5914	DB	'Procedures, parameters and locals:', 00H
	ORG $+13
$SG5915	DB	'                N a m e                 Type     Value  '
	DB	'  Segment  Length', 00H
	ORG $+6
$SG5916	DB	'Symbols:', 00H
	ORG $+7
$SG5917	DB	'                N a m e                 Type       Value'
	DB	'     Attr', 00H
_DATA	ENDS
CONST	SEGMENT
	ORG $+8
strings	DQ	FLAT:$SG5852
	DQ	FLAT:$SG5853
	DQ	FLAT:$SG5854
	DQ	FLAT:$SG5855
	DQ	FLAT:$SG5856
	DQ	FLAT:$SG5857
	DQ	FLAT:$SG5858
	DQ	FLAT:$SG5859
	DQ	FLAT:$SG5860
	DQ	FLAT:$SG5861
	DQ	FLAT:$SG5862
	DQ	FLAT:$SG5863
	DQ	FLAT:$SG5864
	DQ	FLAT:$SG5865
	DQ	FLAT:$SG5866
	DQ	FLAT:$SG5867
	DQ	FLAT:$SG5868
	DQ	FLAT:$SG5869
	DQ	FLAT:$SG5870
	DQ	FLAT:$SG5871
	DQ	FLAT:$SG5872
	DQ	FLAT:$SG5873
	DQ	FLAT:$SG5874
	DQ	FLAT:$SG5875
	DQ	FLAT:$SG5876
	DQ	FLAT:$SG5877
	DQ	FLAT:$SG5878
	DQ	FLAT:$SG5879
	DQ	FLAT:$SG5880
	DQ	FLAT:$SG5881
	DQ	FLAT:$SG5882
	DQ	FLAT:$SG5883
	DQ	FLAT:$SG5884
	DQ	FLAT:$SG5885
	DQ	FLAT:$SG5886
	DQ	FLAT:$SG5887
	DQ	FLAT:$SG5888
	DQ	FLAT:$SG5889
	DQ	FLAT:$SG5890
	DQ	FLAT:$SG5891
	DQ	FLAT:$SG5892
	DQ	FLAT:$SG5893
	DQ	FLAT:$SG5894
	DQ	FLAT:$SG5895
	DQ	FLAT:$SG5896
	DQ	FLAT:$SG5897
	DQ	FLAT:$SG5898
	DQ	FLAT:$SG5899
	DQ	FLAT:$SG5900
	DQ	FLAT:$SG5901
	DQ	FLAT:$SG5902
	DQ	FLAT:$SG5903
	DQ	FLAT:$SG5904
	DQ	FLAT:$SG5905
	DQ	FLAT:$SG5906
	DQ	FLAT:$SG5907
	DQ	FLAT:$SG5908
	DQ	FLAT:$SG5909
	DQ	FLAT:$SG5910
	DQ	FLAT:$SG5911
	DQ	FLAT:$SG5912
	DQ	FLAT:$SG5913
	DQ	FLAT:$SG5914
	DQ	FLAT:$SG5915
	DQ	FLAT:$SG5916
	DQ	FLAT:$SG5917
szCount	DB	'count', 00H
	ORG $+2
maccap	DW	034H
	DW	035H
	DW	00H
	ORG $+2
strcap	DW	036H
	DW	037H
	DW	00H
	ORG $+2
reccap	DW	038H
	DW	039H
	DW	00H
	ORG $+2
tdcap	DW	03aH
	DW	03bH
	DW	00H
	ORG $+2
segcap	DW	03cH
	DW	03dH
	DW	00H
	ORG $+2
prccap	DW	03eH
	DW	03fH
	DW	00H
	ORG $+10
cr	DW	00H
	DW	00H
	ORG $+4
	DQ	FLAT:maccap
	DQ	FLAT:log_macro
	DW	01H
	DW	00H
	ORG $+4
	DQ	FLAT:strcap
	DQ	FLAT:log_struct
	DW	02H
	DW	00H
	ORG $+4
	DQ	FLAT:reccap
	DQ	FLAT:log_record
	DW	03H
	DW	00H
	ORG $+4
	DQ	FLAT:tdcap
	DQ	FLAT:log_typedef
	DW	04H
	DW	00H
	ORG $+4
	DQ	FLAT:segcap
	DQ	FLAT:log_segment
	DW	05H
	DW	01H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:log_group
	DW	06H
	DW	00H
	ORG $+4
	DQ	FLAT:prccap
	DQ	FLAT:log_proc
CONST	ENDS
_DATA	SEGMENT
	ORG $+2
$SG6009	DB	'%08X', 00H
	ORG $+3
$SG6027	DB	'%02X', 00H
	ORG $+3
$SG6033	DB	'%02X', 00H
	ORG $+3
$SG6036	DB	'%08X', 00H
	ORG $+7
$SG6041	DB	'%-25I64X', 00H
	ORG $+3
$SG6043	DB	'%-25X', 00H
	ORG $+2
$SG6055	DB	'%08X', 00H
	ORG $+3
$SG6059	DB	'%08X', 00H
	ORG $+3
$SG6063	DB	0dH, 0aH, 00H
	ORG $+1
$SG6068	DB	'%u', 00H
	ORG $+1
$SG6075	DB	0dH, 0aH, 00H
	ORG $+1
$SG6079	DB	0dH, 0aH, 00H
	ORG $+1
$SG6092	DB	0dH, 0aH, 00H
	ORG $+1
$SG6114	DB	'%u', 00H
	ORG $+1
$SG6127	DB	'?', 00H
	ORG $+2
$SG6135	DB	'%s %s        %s', 00H
$SG6180	DB	'%s %s ', 00H
	ORG $+1
$SG6192	DB	'?', 00H
	ORG $+2
$SG6198	DB	'?', 00H
	ORG $+2
$SG6219	DB	' ', 00H
	ORG $+6
$SG6222	DB	'%s %s        %8X (%u)', 00H
	ORG $+2
$SG6224	DB	'%s %s        %8X', 00H
	ORG $+7
$SG6226	DB	'%s %s        %8X', 00H
	ORG $+3
$SG6238	DB	' ', 00H
	ORG $+2
$SG6239	DB	'%s %s        %8X   ', 00H
$SG6241	DB	'%s', 00H
	ORG $+1
$SG6243	DB	'[%u]', 00H
	ORG $+3
$SG6258	DB	'%s %s      %6X  %7X', 00H
$SG6267	DB	'?', 00H
	ORG $+2
$SG6268	DB	'  %s %s      %6X  %7X  %016I64X %s', 00H
	ORG $+1
$SG6271	DB	'?', 00H
	ORG $+2
$SG6272	DB	'  %s %s      %6X  %7X  %08X %s', 00H
	ORG $+1
$SG6281	DB	' ', 00H
	ORG $+2
$SG6283	DB	' ', 00H
	ORG $+2
$SG6284	DB	' ', 00H
	ORG $+6
$SG6287	DB	'%s %s    %8u  %s', 00H
	ORG $+7
$SG6300	DB	'%s %s        ', 00H
	ORG $+2
$SG6302	DB	'32 Bit   %08X ', 00H
	ORG $+1
$SG6305	DB	'64 Bit   %08X ', 00H
	ORG $+1
$SG6307	DB	'16 Bit   %04X     ', 00H
	ORG $+5
$SG6308	DB	'%-7s %-8s', 00H
	ORG $+2
$SG6310	DB	'''%s''', 00H
	ORG $+7
$SG6320	DB	'%s %s        %s', 00H
$SG6347	DB	' ', 00H
	ORG $+6
$SG6367	DB	'%s %s        P %-6s %08X %-8s ', 00H
	ORG $+1
$SG6369	DB	'%s %s        P %-6s %04X     %-8s ', 00H
	ORG $+1
$SG6370	DB	'%0*X ', 00H
	ORG $+2
$SG6372	DB	'%-9s', 00H
	ORG $+3
$SG6375	DB	'%-9s', 00H
	ORG $+3
$SG6377	DB	'*%-8s ', 00H
	ORG $+1
$SG6378	DB	'%-9s ', 00H
	ORG $+6
$SG6380	DB	'(%.8s) ', 00H
$SG6381	DB	'%s', 00H
	ORG $+1
$SG6384	DB	'  ', 00H
	ORG $+1
$SG6402	DB	'  %s %s        %-17s %s', 00H
$SG6420	DB	'%s[%u]', 00H
	ORG $+1
$SG6436	DB	'  %s %s        L %-6s %08X %s', 00H
	ORG $+2
$SG6438	DB	'  %s %s        L %-6s %04X     %s', 00H
	ORG $+6
$SG6451	DB	'%s %s        ', 00H
	ORG $+2
$SG6454	DB	'%s[%u]', 00H
	ORG $+1
$SG6455	DB	'%-10s ', 00H
	ORG $+1
$SG6458	DB	'%-10s ', 00H
	ORG $+1
$SG6461	DB	'%-10s ', 00H
	ORG $+1
$SG6463	DB	' %8Xh ', 00H
	ORG $+1
$SG6467	DB	' %I64Xh ', 00H
	ORG $+7
$SG6470	DB	'-%08Xh ', 00H
$SG6472	DB	' %8Xh ', 00H
	ORG $+1
$SG6474	DB	' %8Xh ', 00H
	ORG $+1
$SG6476	DB	'%s ', 00H
$SG6478	DB	'%s=%u ', 00H
	ORG $+1
$SG6480	DB	'%s ', 00H
$SG6482	DB	'*%s ', 00H
	ORG $+3
$SG6483	DB	'%s ', 00H
$SG6486	DB	'%s ', 00H
$SG6487	DB	'%s', 00H
	ORG $+5
$SG6489	DB	'%s %s        %s   %s', 00H
	ORG $+3
$SG6491	DB	'%s %s        %s  %s', 00H
_DATA	ENDS
PUBLIC	LstWrite
EXTRN	fwrite:NEAR
EXTRN	LastCodeBufSize:DWORD
EXTRN	sprintf:NEAR
EXTRN	GetCurrOffset:NEAR
EXTRN	Options:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	get_curr_srcfile:NEAR
EXTRN	fseek:NEAR
EXTRN	LineStoreCurr:QWORD
EXTRN	UseSavedState:BYTE
EXTRN	Parse_Pass:DWORD
EXTRN	MacroLevel:BYTE
EXTRN	ModuleInfo:BYTE
xdata	SEGMENT
$unwind$LstWrite DD 025113f01H
	DD	0df43fH
	DD	0ee434H
	DD	0fd428H
	DD	015c424H
	DD	014741dH
	DD	0136416H
	DD	0123412H
	DD	0f209230eH
	DD	05002H
xdata	ENDS
pdata	SEGMENT
$pdata$LstWrite DD @imagerel($LN96#)
	DD	@imagerel($LN96#+1616)
	DD	@imagerel($unwind$LstWrite#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\listing.c
pdata	ENDS
_TEXT	SEGMENT
srcfile$1$ = 0
ll$ = 8
type$ = 112
oldofs$ = 120
value$ = 128
LstWrite PROC NEAR

; 141  : {

$LN96:
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	mov	QWORD PTR [rbp+112], rbx
	mov	QWORD PTR [rbp+120], rsi
	mov	QWORD PTR [rbp+128], rdi
	mov	QWORD PTR [rbp+136], r12
	mov	QWORD PTR [rbp+88], r13
	mov	esi, edx

; 142  :     uint_32 newofs;
; 143  :     struct asym *sym = value;
; 144  :     int     len;
; 145  :     int     len2;
; 146  :     int     idx;
; 147  :     int     srcfile;
; 148  :     char    *p1;
; 149  :     char    *p2;
; 150  :     char    *pSrcline;
; 151  :     struct lstleft *pll;
; 152  :     struct lstleft ll;
; 153  :     //char    buffer2[MAX_LINE_LEN]; /* stores text macro value */
; 154  : 
; 155  :     if ( ModuleInfo.list == FALSE || CurrFile[LST] == NULL || ( ModuleInfo.line_flags & LOF_LISTED ) )

	mov	edx, DWORD PTR ModuleInfo+408
	mov	QWORD PTR [rbp+80], r14
	mov	rbx, r8
	bt	edx, 12
	mov	QWORD PTR [rbp+72], r15
	movsxd	r12, ecx
	jae	$LN63@LstWrite
	mov	rcx, QWORD PTR ModuleInfo+112
	test	rcx, rcx
	je	$LN63@LstWrite
	movzx	eax, BYTE PTR ModuleInfo+398
	test	al, 1
	jne	$LN63@LstWrite

; 156  :         return;
; 157  :     if ( ModuleInfo.GeneratedCode && ( ModuleInfo.list_generated_code == FALSE ) )

	mov	edi, DWORD PTR ModuleInfo+456
	test	edi, edi
	je	SHORT $LN62@LstWrite
	bt	edx, 15
	jae	$LN63@LstWrite
$LN62@LstWrite:

; 158  :         return;
; 159  :     if ( MacroLevel ) {

	cmp	BYTE PTR MacroLevel, 0
	je	SHORT $LN59@LstWrite

; 160  :         switch ( ModuleInfo.list_macro ) {

	cmp	DWORD PTR ModuleInfo+400, 0
	je	$LN63@LstWrite
$LN59@LstWrite:

; 161  :         case LM_NOLISTMACRO:
; 162  :             return;
; 163  :         case LM_LISTMACRO:
; 164  :             /* todo: filter certain macro lines */
; 165  :             break;
; 166  :         }
; 167  :     }
; 168  : 
; 169  :     ModuleInfo.line_flags |= LOF_LISTED;
; 170  : 
; 171  :     DebugMsg1(("LstWrite( %u, %" I32_SPEC "u ): enter [ pos=%" I32_SPEC "u, GeneratedCode=%u, MacroLevel=%u ]\n", type, oldofs, list_pos, ModuleInfo.GeneratedCode, MacroLevel ));
; 172  :     pSrcline = CurrSource;

	mov	r15, QWORD PTR ModuleInfo+464
	or	al, 1

; 173  : #if FASTPASS
; 174  :     if ( ( Parse_Pass > PASS_1 ) && UseSavedState ) {

	xor	r13d, r13d
	cmp	DWORD PTR Parse_Pass, r13d
	mov	BYTE PTR ModuleInfo+398, al
	jbe	SHORT $LN56@LstWrite
	cmp	BYTE PTR UseSavedState, r13b
	je	SHORT $LN56@LstWrite

; 175  :         if ( ModuleInfo.GeneratedCode == 0 ) {

	test	edi, edi
	jne	SHORT $LN81@LstWrite

; 176  :             if ( !( ModuleInfo.line_flags & LOF_SKIPPOS ) )

	test	al, 2
	mov	rdx, QWORD PTR LineStoreCurr
	jne	SHORT $LN80@LstWrite

; 177  :                 list_pos = LineStoreCurr->list_pos;

	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR list_pos, eax
$LN80@LstWrite:

; 178  : #if USELSLINE /* either use CurrSource + CurrComment or LineStoreCurr->line (see assemble.c, OnePass() */
; 179  :             pSrcline = LineStoreCurr->line;
; 180  :             if ( ModuleInfo.CurrComment ) { /* if comment was removed, readd it! */

	cmp	QWORD PTR ModuleInfo+472, r13
	lea	r15, QWORD PTR [rdx+16]
	je	SHORT $LN81@LstWrite

; 181  :                 *( LineStoreCurr->line + strlen( LineStoreCurr->line ) ) = ';';

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, r15
	repne scasb
	not	rcx
	mov	BYTE PTR [rcx+rdx+15], 59		; 0000003bH

; 182  :                 ModuleInfo.CurrComment = NULL;

	mov	rcx, QWORD PTR ModuleInfo+112
	mov	QWORD PTR ModuleInfo+472, r13
$LN81@LstWrite:

; 183  :             }
; 184  : #endif
; 185  :             DebugMsg1(("LstWrite: Pass=%u, stored pos=%" I32_SPEC "u\n", Parse_Pass+1, list_pos ));
; 186  :         }
; 187  :         fseek( CurrFile[LST], list_pos, SEEK_SET );

	mov	edx, DWORD PTR list_pos
	xor	r8d, r8d
	call	fseek
$LN56@LstWrite:

; 188  :     }
; 189  : #endif
; 190  : 
; 191  :     ll.next = NULL;

	mov	QWORD PTR ll$[rbp], r13

; 192  :     memset( ll.buffer, ' ', sizeof( ll.buffer ) );

	mov	r13, 2314885530818453536		; 2020202020202020H
	mov	QWORD PTR ll$[rbp+8], r13
	mov	QWORD PTR ll$[rbp+16], r13
	mov	QWORD PTR ll$[rbp+24], r13
	mov	QWORD PTR ll$[rbp+32], r13

; 193  :     srcfile = get_curr_srcfile();

	call	get_curr_srcfile

; 194  : 
; 195  :     switch ( type ) {

	cmp	r12d, 8
	mov	r14d, eax
	mov	DWORD PTR srcfile$1$[rbp], eax
	ja	$LN15@LstWrite
	lea	rax, OFFSET FLAT:__ImageBase
	mov	edx, DWORD PTR $LN79@LstWrite[rax+r12*4]
	add	rdx, rax
	jmp	rdx
$LN50@LstWrite:

; 196  :     case LSTTYPE_DATA:
; 197  :         if ( Parse_Pass == PASS_1 && Options.first_pass_listing == FALSE ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN49@LstWrite
	cmp	BYTE PTR Options+149, 0
	je	$LN92@LstWrite
$LN49@LstWrite:

; 198  :             break;
; 199  :         }
; 200  :         /* no break */
; 201  :     case LSTTYPE_CODE:
; 202  :         newofs = GetCurrOffset();

	call	GetCurrOffset

; 203  :         sprintf( ll.buffer, "%08" I32_SPEC "X", oldofs );

	lea	rdx, OFFSET FLAT:$SG6009
	lea	rcx, QWORD PTR ll$[rbp+8]
	mov	r8d, esi
	mov	r13d, eax
	call	sprintf

; 204  :         ll.buffer[OFSSIZE] = ' ';
; 205  : 
; 206  :         if ( CurrSeg == NULL )

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	BYTE PTR ll$[rbp+16], 32		; 00000020H
	test	rcx, rcx
	je	$LN86@LstWrite

; 207  :             break;
; 208  :         //if ( write_to_file == FALSE )
; 209  :         if ( Options.first_pass_listing ) {

	cmp	BYTE PTR Options+149, 0
	je	SHORT $LN46@LstWrite

; 210  :             if ( Parse_Pass > PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	ja	$LN94@LstWrite

; 211  :                 break;
; 212  : #ifdef DEBUG_OUT
; 213  :         } else if ( Options.max_passes == 1 ) {
; 214  :             ; /* write a listing in pass 1 */
; 215  : #endif
; 216  :         } else if ( Parse_Pass == PASS_1 )  /* changed v1.96 */

	jmp	SHORT $LN43@LstWrite
$LN46@LstWrite:
	cmp	DWORD PTR Parse_Pass, 0
	je	$LN92@LstWrite
$LN43@LstWrite:

; 217  :             break;
; 218  : 
; 219  :         len = CODEBYTES;
; 220  :         p2 = ll.buffer + OFSSIZE + 2;
; 221  : 
; 222  :         if ( CurrSeg->e.seginfo->CodeBuffer == NULL ||
; 223  :             CurrSeg->e.seginfo->written == FALSE ) {

	mov	rax, QWORD PTR [rcx+104]
	mov	ebx, 9
	lea	rdi, QWORD PTR ll$[rbp+18]
	cmp	QWORD PTR [rax+16], 0
	je	$LN71@LstWrite
	test	BYTE PTR [rax+107], 32			; 00000020H
	je	$LN71@LstWrite

; 231  :         }
; 232  : 
; 233  :         /* OMF hold just a small buffer for one LEDATA record */
; 234  :         /* if it has been flushed, use LastCodeBufSize */
; 235  :         idx = (CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc)
; 236  :             - (newofs - oldofs);

	mov	r12d, DWORD PTR [rax+12]
	sub	r12d, DWORD PTR [rax+8]
	sub	r12d, r13d
	add	r12d, esi

; 237  :         if ( Options.output_format == OFORMAT_OMF ) {

	cmp	DWORD PTR Options+156, 1
	jne	SHORT $LN38@LstWrite

; 238  :             /* v2.11: additional check to make the hack more robust [ test case:  db 800000h dup (0) ] */
; 239  :             if ( ( idx+LastCodeBufSize ) < 0 )

	mov	edx, DWORD PTR LastCodeBufSize
	lea	eax, DWORD PTR [rdx+r12]
	test	eax, eax
	js	$LN86@LstWrite

; 240  :                 break; /* just exit. The code bytes area will remain empty */
; 241  :             while ( idx < 0 && len ) {

	test	r12d, r12d
	movsxd	r14, r12d
	jns	SHORT $LN83@LstWrite
	jmp	SHORT $LN36@LstWrite
$LL82@LstWrite:
	mov	edx, DWORD PTR LastCodeBufSize
$LN36@LstWrite:
	test	ebx, ebx
	je	SHORT $LN83@LstWrite

; 242  :                 sprintf( p2, "%02X", CurrSeg->e.seginfo->CodeBuffer[idx+LastCodeBufSize] );

	mov	rax, QWORD PTR [rcx+104]
	movsxd	rcx, edx
	mov	rdx, QWORD PTR [rax+16]
	add	rdx, rcx
	mov	rcx, rdi
	movzx	r8d, BYTE PTR [rdx+r14]
	lea	rdx, OFFSET FLAT:$SG6027
	call	sprintf

; 243  :                 p2 += 2;
; 244  :                 idx++;
; 245  :                 oldofs++;
; 246  :                 len--;
; 247  :             }
; 248  :         } else if (idx < 0)

	mov	rcx, QWORD PTR ModuleInfo+432
	add	rdi, 2
	inc	r12d
	inc	esi
	dec	ebx
	inc	r14
	js	SHORT $LL82@LstWrite
	jmp	SHORT $LN83@LstWrite
$LN38@LstWrite:
	test	r12d, r12d
	mov	r8d, 0
	cmovs	r12d, r8d
$LN83@LstWrite:

; 249  :             idx = 0;
; 250  : 
; 251  :         while ( oldofs < newofs && len ) {

	cmp	esi, r13d
	movsxd	r12, r12d
	jae	SHORT $LN85@LstWrite
	jmp	SHORT $LN32@LstWrite
	npad	2
$LL84@LstWrite:
	mov	rcx, QWORD PTR ModuleInfo+432
$LN32@LstWrite:
	test	ebx, ebx
	je	SHORT $LN85@LstWrite

; 252  :             sprintf( p2, "%02X", CurrSeg->e.seginfo->CodeBuffer[idx] );

	mov	rax, QWORD PTR [rcx+104]
	lea	rdx, OFFSET FLAT:$SG6033
	mov	rcx, QWORD PTR [rax+16]
	movzx	r8d, BYTE PTR [rcx+r12]
	mov	rcx, rdi
	call	sprintf

; 253  :             p2 += 2;
; 254  :             idx++;
; 255  :             oldofs++;

	inc	esi
	add	rdi, 2
	inc	r12

; 256  :             len--;

	dec	ebx
	cmp	esi, r13d
	jb	SHORT $LL84@LstWrite
$LN85@LstWrite:

; 257  :         }
; 258  :         *p2 = ' ';
; 259  :         break;

	mov	r14d, DWORD PTR srcfile$1$[rbp]
	mov	BYTE PTR [rdi], 32			; 00000020H
	jmp	$LN86@LstWrite
$LN71@LstWrite:

; 224  :             while ( oldofs < newofs && len ) {

	cmp	esi, r13d
	jae	$LN86@LstWrite
	npad	4
$LL40@LstWrite:
	test	ebx, ebx
	je	$LN86@LstWrite

; 225  :                 *p2++ = '0';

	mov	BYTE PTR [rdi], 48			; 00000030H

; 226  :                 *p2++ = '0';
; 227  :                 oldofs++;

	inc	esi
	mov	BYTE PTR [rdi+1], 48			; 00000030H
	add	rdi, 2

; 228  :                 len--;

	dec	ebx
	cmp	esi, r13d
	jb	SHORT $LL40@LstWrite

; 229  :             }
; 230  :             break;

	jmp	$LN86@LstWrite
$LN30@LstWrite:

; 260  :     case LSTTYPE_EQUATE:
; 261  :         /* v2.10: display current offset if equate is an alias for a label in this segment */
; 262  :         idx = 1;
; 263  :         if ( sym->segment && sym->segment == &CurrSeg->sym ) {

	mov	rax, QWORD PTR [rbx+32]
	mov	ecx, 1
	test	rax, rax
	je	SHORT $LN29@LstWrite
	cmp	rax, QWORD PTR ModuleInfo+432
	jne	SHORT $LN29@LstWrite

; 264  :             sprintf( ll.buffer, "%08" I32_SPEC "X", GetCurrOffset() );

	call	GetCurrOffset
	lea	rdx, OFFSET FLAT:$SG6036
	lea	rcx, QWORD PTR ll$[rbp+8]
	mov	r8d, eax
	call	sprintf

; 265  :             idx = 10;

	mov	ecx, 10
$LN29@LstWrite:

; 266  :         }
; 267  :         ll.buffer[idx] = '=';

	movsxd	rax, ecx
	mov	BYTE PTR ll$[rbp+rax+8], 61		; 0000003dH

; 268  : #if AMD64_SUPPORT
; 269  :         if ( sym->value3264 != 0 && ( sym->value3264 != -1 || sym->value >= 0 ) )

	movsxd	rax, DWORD PTR [rbx+64]
	test	eax, eax
	je	SHORT $LN28@LstWrite
	cmp	eax, -1
	jne	SHORT $LN27@LstWrite
	cmp	DWORD PTR [rbx+16], 0
	jl	SHORT $LN28@LstWrite
$LN27@LstWrite:

; 270  :             sprintf( &ll.buffer[idx+2], "%-" PREFFMTSTR I64_SPEC "X", (uint_64)sym->value + ( (uint_64)sym->value3264 << 32 ) );

	mov	r8, rax
	movsxd	rax, DWORD PTR [rbx+16]
	lea	rdx, OFFSET FLAT:$SG6041
	shl	r8, 32					; 00000020H
	add	r8, rax
	lea	eax, DWORD PTR [rcx+2]
	movsxd	rcx, eax
	lea	rcx, QWORD PTR ll$[rbp+rcx+8]
	call	sprintf

; 274  :         ll.buffer[28] = ' ';

	mov	BYTE PTR ll$[rbp+36], 32		; 00000020H

; 275  :         break;

	jmp	$LN86@LstWrite
$LN28@LstWrite:

; 271  :         else
; 272  : #endif
; 273  :             sprintf( &ll.buffer[idx+2], "%-" PREFFMTSTR I32_SPEC "X", sym->value );

	mov	r8d, DWORD PTR [rbx+16]
	lea	eax, DWORD PTR [rcx+2]
	lea	rdx, OFFSET FLAT:$SG6043
	movsxd	rcx, eax
	lea	rcx, QWORD PTR ll$[rbp+rcx+8]
	call	sprintf

; 274  :         ll.buffer[28] = ' ';

	mov	BYTE PTR ll$[rbp+36], 32		; 00000020H

; 275  :         break;

	jmp	$LN86@LstWrite
$LN25@LstWrite:

; 276  :     case LSTTYPE_TMACRO:
; 277  :         ll.buffer[1] = '=';
; 278  :         //GetLiteralValue( buffer2, sym->string_ptr );
; 279  :         //strcpy( buffer2, sym->string_ptr );
; 280  :         for ( p1 = sym->string_ptr, p2 = &ll.buffer[3], pll = &ll; *p1; ) {

	mov	rdx, QWORD PTR [rbx+16]
	mov	BYTE PTR ll$[rbp+9], 61			; 0000003dH
	lea	rcx, QWORD PTR ll$[rbp+11]
	cmp	BYTE PTR [rdx], 0
	lea	rdi, QWORD PTR ll$[rbp]
	je	SHORT $LN86@LstWrite
	xor	r8d, r8d
	npad	6
$LL24@LstWrite:

; 281  :             if ( p2 >= &pll->buffer[28] ) {

	lea	rax, QWORD PTR [rdi+36]
	cmp	rcx, rax
	jb	SHORT $LN22@LstWrite

; 282  :                 struct lstleft *next = myalloca( sizeof( struct lstleft ) );

	mov	eax, DWORD PTR [rsp]
	sub	rsp, 48					; 00000030H
	mov	eax, DWORD PTR [rsp+32]
	lea	rcx, QWORD PTR [rsp+32]

; 283  :                 pll->next = next;

	mov	QWORD PTR [rdi], rcx

; 284  :                 pll = next;
; 285  :                 pll->next = NULL;

	mov	QWORD PTR [rcx], r8

; 286  :                 memset( pll->buffer, ' ', sizeof( pll->buffer) );

	mov	QWORD PTR [rcx+8], r13
	mov	QWORD PTR [rcx+16], r13
	mov	QWORD PTR [rcx+24], r13
	mov	rdi, rcx
	mov	QWORD PTR [rcx+32], r13

; 287  :                 p2 = &pll->buffer[3];

	add	rcx, 11
$LN22@LstWrite:

; 288  :             }
; 289  :             *p2++ = *p1++;

	movzx	eax, BYTE PTR [rdx]
	inc	rdx
	inc	rcx
	mov	BYTE PTR [rcx-1], al
	cmp	BYTE PTR [rdx], r8b
	jne	SHORT $LL24@LstWrite

; 290  :         }
; 291  :         break;

	jmp	SHORT $LN86@LstWrite
$LN21@LstWrite:

; 292  :     case LSTTYPE_MACROLINE:
; 293  :         ll.buffer[1] = '>';

	mov	BYTE PTR ll$[rbp+9], 62			; 0000003eH

; 294  :         pSrcline = value;

	mov	r15, rbx

; 295  :         break;

	jmp	SHORT $LN86@LstWrite
$LN20@LstWrite:

; 296  :     case LSTTYPE_LABEL:
; 297  :         oldofs = GetCurrOffset();

	call	GetCurrOffset
	mov	esi, eax
$LN19@LstWrite:

; 298  :         /* no break */
; 299  :     case LSTTYPE_STRUCT:
; 300  :         sprintf( ll.buffer, "%08" I32_SPEC "X", oldofs );

	mov	r8d, esi
	lea	rdx, OFFSET FLAT:$SG6055
$LN95@LstWrite:

; 305  :             sprintf( ll.buffer, "%08" I32_SPEC "X", oldofs );

	lea	rcx, QWORD PTR ll$[rbp+8]
	call	sprintf

; 306  :             ll.buffer[8] = ' ';

	mov	BYTE PTR ll$[rbp+16], 32		; 00000020H
$LN86@LstWrite:

; 315  :         }
; 316  :         break;
; 317  :     }
; 318  : 
; 319  : #if FASTPASS
; 320  :     if ( Parse_Pass == PASS_1 || UseSavedState == FALSE ) {

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN92@LstWrite
$LN94@LstWrite:
	cmp	BYTE PTR UseSavedState, 0
	je	SHORT $LN92@LstWrite

; 330  :             ll.buffer[30] = 'C';
; 331  :         }
; 332  : #ifdef DEBUG_OUT
; 333  :         ll.last = NULLC;
; 334  : #endif
; 335  : #if FASTPASS
; 336  :     } else {
; 337  :         idx = OFSSIZE + 2 + 2 * CODEBYTES;

	mov	edi, 28
	jmp	$LN9@LstWrite
$LN18@LstWrite:

; 301  :         ll.buffer[8] = ' ';
; 302  :         break;
; 303  :     case LSTTYPE_DIRECTIVE:
; 304  :         if ( CurrSeg || value ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	jne	SHORT $LN16@LstWrite
	test	rbx, rbx
	je	SHORT $LN86@LstWrite
$LN16@LstWrite:

; 305  :             sprintf( ll.buffer, "%08" I32_SPEC "X", oldofs );

	mov	r8d, esi
	lea	rdx, OFFSET FLAT:$SG6059

; 307  :         }
; 308  :         break;

	jmp	SHORT $LN95@LstWrite
$LN15@LstWrite:

; 309  :     default: /* LSTTYPE_MACRO */
; 310  :         if ( *pSrcline == NULLC && ModuleInfo.CurrComment == NULL && srcfile == ModuleInfo.srcfile ) {

	cmp	BYTE PTR [r15], 0
	jne	SHORT $LN86@LstWrite
	cmp	QWORD PTR ModuleInfo+472, 0
	jne	SHORT $LN86@LstWrite
	cmp	r14d, DWORD PTR ModuleInfo+428
	jne	SHORT $LN86@LstWrite

; 311  :             DebugMsg1(("LstWrite: type=%u, writing CRLF\n", type ));
; 312  :             fwrite( NLSTR, 1, NLSIZ, CurrFile[LST] );

	mov	r9, QWORD PTR ModuleInfo+112
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6063
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite

; 313  :             list_pos += NLSIZ;

	add	DWORD PTR list_pos, 2

; 314  :             return;

	jmp	$LN63@LstWrite
$LN92@LstWrite:

; 321  : #endif
; 322  :         idx = sizeof( ll.buffer );
; 323  :         if ( ModuleInfo.GeneratedCode )

	movzx	eax, BYTE PTR ll$[rbp+36]
	cmp	DWORD PTR ModuleInfo+456, 0
	mov	ecx, 42					; 0000002aH
	cmovne	eax, ecx
	mov	edi, 32					; 00000020H
	mov	BYTE PTR ll$[rbp+36], al

; 324  :             ll.buffer[28] = '*';
; 325  :         if ( MacroLevel ) {

	movzx	eax, BYTE PTR MacroLevel
	test	al, al
	je	SHORT $LN10@LstWrite

; 326  :             len = sprintf( &ll.buffer[29], "%u", MacroLevel );

	lea	rdx, OFFSET FLAT:$SG6068
	lea	rcx, QWORD PTR ll$[rbp+37]

; 327  :             ll.buffer[29+len] = ' ';

	movzx	r8d, al
	call	sprintf
	movsxd	rcx, eax
	mov	BYTE PTR ll$[rbp+rcx+37], dil
$LN10@LstWrite:

; 328  :         }
; 329  :         if ( srcfile != ModuleInfo.srcfile ) {

	movzx	eax, BYTE PTR ll$[rbp+38]
	cmp	r14d, DWORD PTR ModuleInfo+428
	mov	ecx, 67					; 00000043H
	cmovne	eax, ecx
	mov	BYTE PTR ll$[rbp+38], al
$LN9@LstWrite:

; 338  : #ifdef DEBUG_OUT
; 339  :         ll.buffer[idx] = NULLC;
; 340  : #endif
; 341  :     }
; 342  : #endif
; 343  :     fwrite( ll.buffer, 1, idx, CurrFile[LST] );

	mov	r9, QWORD PTR ModuleInfo+112
	lea	rcx, QWORD PTR ll$[rbp+8]
	movsxd	r8, edi
	mov	edx, 1
	call	fwrite

; 344  : 
; 345  :     len = strlen( pSrcline );
; 346  :     len2 = ( ModuleInfo.CurrComment ? strlen( ModuleInfo.CurrComment ) : 0 );

	mov	r10, QWORD PTR ModuleInfo+472
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, r15
	repne scasb
	test	r10, r10
	not	rcx
	lea	rdx, QWORD PTR [rcx-1]
	je	SHORT $LN67@LstWrite
	mov	rcx, -1
	mov	rdi, r10
	repne scasb
	not	rcx
	lea	rdi, QWORD PTR [rcx-1]
	jmp	SHORT $LN68@LstWrite
$LN67@LstWrite:
	mov	edi, eax
$LN68@LstWrite:

; 347  : 
; 348  :     list_pos += sizeof( ll.buffer ) + len + len2 + NLSIZ;
; 349  :     DebugMsg1(("LstWrite: writing (%u b) >%s< [%u/%u], new pos=%" I32_SPEC "u\n", idx, ll.buffer, len, len2, list_pos ));
; 350  : 
; 351  :     /* write source and comment part */
; 352  : #if FASTPASS
; 353  :     if ( Parse_Pass == PASS_1 || UseSavedState == FALSE ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	eax, DWORD PTR list_pos
	lea	ecx, DWORD PTR [rdi+rdx]
	lea	ecx, DWORD PTR [rax+rcx+34]
	mov	DWORD PTR list_pos, ecx
	je	SHORT $LN6@LstWrite
	cmp	BYTE PTR UseSavedState, 0
	jne	SHORT $LN7@LstWrite
$LN6@LstWrite:

; 354  : #endif
; 355  :         if ( len )

	test	edx, edx
	je	SHORT $LN5@LstWrite

; 356  :             fwrite( pSrcline, 1, len, CurrFile[LST] );

	mov	r9, QWORD PTR ModuleInfo+112
	movsxd	r8, edx
	mov	rcx, r15
	mov	edx, 1
	call	fwrite
	mov	r10, QWORD PTR ModuleInfo+472
$LN5@LstWrite:

; 357  :         if ( len2 ) {

	test	edi, edi
	je	SHORT $LN4@LstWrite

; 358  :             fwrite( ModuleInfo.CurrComment, 1, len2, CurrFile[LST] );

	mov	r9, QWORD PTR ModuleInfo+112
	movsxd	r8, edi
	mov	edx, 1
	mov	rcx, r10
	call	fwrite
$LN4@LstWrite:

; 359  :             DebugMsg1(("LstWrite: writing (%u b) >%s%s<\n", len + len2 + NLSIZ, pSrcline, ModuleInfo.CurrComment ));
; 360  :         }
; 361  : #ifdef DEBUG_OUT
; 362  :         else DebugMsg1(("LstWrite: writing (%u b) >%s<\n", len + NLSIZ, pSrcline ));
; 363  : #endif
; 364  :         fwrite( NLSTR, 1, NLSIZ, CurrFile[LST] );

	mov	r9, QWORD PTR ModuleInfo+112
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6075
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
$LN7@LstWrite:

; 365  : #if FASTPASS
; 366  :     }
; 367  : #endif
; 368  : 
; 369  :     /* write optional additional lines.
; 370  :      * currently works in pass one only.
; 371  :      */
; 372  :     for ( pll = ll.next; pll; pll = pll->next ) {

	mov	rdi, QWORD PTR ll$[rbp]
	test	rdi, rdi
	je	SHORT $LN63@LstWrite
	npad	9
$LL3@LstWrite:

; 373  :         fwrite( pll->buffer, 1, 32, CurrFile[LST] );

	mov	r9, QWORD PTR ModuleInfo+112
	mov	edx, 1
	lea	rcx, QWORD PTR [rdi+8]
	lea	r8d, QWORD PTR [rdx+31]
	call	fwrite

; 374  :         fwrite( NLSTR, 1, NLSIZ, CurrFile[LST] );

	mov	r9, QWORD PTR ModuleInfo+112
	mov	edx, 1
	lea	r8d, QWORD PTR [rdx+1]
	lea	rcx, OFFSET FLAT:$SG6079
	call	fwrite

; 375  :         list_pos += 32 + NLSIZ;

	add	DWORD PTR list_pos, 34			; 00000022H
	mov	rdi, QWORD PTR [rdi]
	test	rdi, rdi
	jne	SHORT $LL3@LstWrite
$LN63@LstWrite:

; 376  :         DebugMsg1(("LstWrite: additional line >%s<, new pos=%" I32_SPEC "u\n", pll->buffer, list_pos ));
; 377  :     }
; 378  :     return;
; 379  : }

	mov	rbx, QWORD PTR [rbp+112]
	mov	rsi, QWORD PTR [rbp+120]
	mov	rdi, QWORD PTR [rbp+128]
	mov	r12, QWORD PTR [rbp+136]
	mov	r13, QWORD PTR [rbp+88]
	mov	r14, QWORD PTR [rbp+80]
	mov	r15, QWORD PTR [rbp+72]
	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
$LN79@LstWrite:
	DD	$LN50@LstWrite
	DD	$LN49@LstWrite
	DD	$LN30@LstWrite
	DD	$LN25@LstWrite
	DD	$LN18@LstWrite
	DD	$LN15@LstWrite
	DD	$LN19@LstWrite
	DD	$LN20@LstWrite
	DD	$LN21@LstWrite
LstWrite ENDP
_TEXT	ENDS
PUBLIC	LstWriteSrcLine
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
LstWriteSrcLine PROC NEAR

; 384  :     LstWrite( LSTTYPE_MACRO, 0, NULL );

	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+5]

; 385  : }

	jmp	LstWrite
LstWriteSrcLine ENDP
_TEXT	ENDS
PUBLIC	LstPrintf
EXTRN	vfprintf:NEAR
xdata	SEGMENT
$unwind$LstPrintf DD 011801H
	DD	04218H
xdata	ENDS
pdata	SEGMENT
$pdata$LstPrintf DD @imagerel($LN4#)
	DD	@imagerel($LN4#+63)
	DD	@imagerel($unwind$LstPrintf#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
format$ = 48
LstPrintf PROC NEAR

; 389  : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 40					; 00000028H

; 390  :     va_list     args;
; 391  : 
; 392  :     if( CurrFile[LST] ) {

	mov	rax, QWORD PTR ModuleInfo+112
	test	rax, rax
	je	SHORT $LN1@LstPrintf

; 393  :         va_start( args, format );
; 394  :         list_pos += vfprintf( CurrFile[LST], format, args );

	mov	rdx, rcx
	lea	r8, QWORD PTR format$[rsp+8]
	mov	rcx, rax
	call	vfprintf
	add	DWORD PTR list_pos, eax
$LN1@LstPrintf:

; 395  :         va_end( args );
; 396  :     }
; 397  : }

	add	rsp, 40					; 00000028H
	ret	0
LstPrintf ENDP
_TEXT	ENDS
PUBLIC	LstNL
xdata	SEGMENT
$unwind$LstNL DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$LstNL DD	@imagerel($LN4#)
	DD	@imagerel($LN4#+49)
	DD	@imagerel($unwind$LstNL#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
LstNL	PROC NEAR

; 401  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 402  :     if( CurrFile[LST] ) {

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN1@LstNL

; 403  :         fwrite( NLSTR, 1, NLSIZ, CurrFile[LST] );

	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6092
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite

; 404  :         list_pos += NLSIZ;

	add	DWORD PTR list_pos, 2
$LN1@LstNL:

; 405  :     }
; 406  : }

	add	rsp, 40					; 00000028H
	ret	0
LstNL	ENDP
_TEXT	ENDS
PUBLIC	LstSetPosition
xdata	SEGMENT
$unwind$LstSetPosition DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$LstSetPosition DD @imagerel($LN4#)
	DD	@imagerel($LN4#+79)
	DD	@imagerel($unwind$LstSetPosition#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
LstSetPosition PROC NEAR

; 416  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 417  :     if( CurrFile[LST] && ( Parse_Pass > PASS_1 ) && UseSavedState && ModuleInfo.GeneratedCode == 0 ) {

	mov	rcx, QWORD PTR ModuleInfo+112
	test	rcx, rcx
	je	SHORT $LN1@LstSetPosi
	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN1@LstSetPosi
	cmp	BYTE PTR UseSavedState, 0
	je	SHORT $LN1@LstSetPosi
	cmp	DWORD PTR ModuleInfo+456, 0
	jne	SHORT $LN1@LstSetPosi

; 418  :         list_pos = LineStoreCurr->list_pos;

	mov	rax, QWORD PTR LineStoreCurr

; 419  :         fseek( CurrFile[LST], list_pos, SEEK_SET );

	xor	r8d, r8d
	mov	edx, DWORD PTR [rax+12]
	mov	DWORD PTR list_pos, edx
	call	fseek

; 420  :         ModuleInfo.line_flags |= LOF_SKIPPOS;

	or	BYTE PTR ModuleInfo+398, 2
$LN1@LstSetPosi:

; 421  :     }
; 422  : }

	add	rsp, 40					; 00000028H
	ret	0
LstSetPosition ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$get_seg_align DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$get_seg_align DD @imagerel(get_seg_align#)
	DD	@imagerel(get_seg_align#+179)
	DD	@imagerel($unwind$get_seg_align#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
seg$ = 48
buffer$ = 56
get_seg_align PROC NEAR

; 427  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 428  :     switch( seg->alignment ) {

	movzx	ecx, BYTE PTR [rcx+106]
	mov	rbx, rdx
	cmp	ecx, 3
	jg	SHORT $LN13@get_seg_al
	je	SHORT $LN5@get_seg_al
	test	ecx, ecx
	mov	r8d, ecx
	je	SHORT $LN8@get_seg_al
	dec	r8d
	je	SHORT $LN7@get_seg_al
	dec	r8d
	jne	SHORT $LN1@get_seg_al

; 431  :     case 2:    return( strings[LS_DWORD] );

	lea	rax, OFFSET FLAT:$SG5854

; 440  :     }
; 441  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN7@get_seg_al:

; 430  :     case 1:    return( strings[LS_WORD]  );

	lea	rax, OFFSET FLAT:$SG5853

; 440  :     }
; 441  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN8@get_seg_al:

; 429  :     case 0:    return( strings[LS_BYTE]  );

	lea	rax, OFFSET FLAT:$SG5852

; 440  :     }
; 441  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN5@get_seg_al:

; 432  :     case 3:    return( strings[LS_QWORD] );

	lea	rax, OFFSET FLAT:$SG5856

; 440  :     }
; 441  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN13@get_seg_al:

; 428  :     switch( seg->alignment ) {

	cmp	ecx, 4
	je	SHORT $LN4@get_seg_al
	cmp	ecx, 8
	je	SHORT $LN3@get_seg_al
	cmp	ecx, 255				; 000000ffH
	je	SHORT $LN2@get_seg_al
$LN1@get_seg_al:

; 437  :     default:
; 438  :         sprintf( buffer, "%u", 1 << seg->alignment );

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:$SG6114
	shl	r8d, cl
	mov	rcx, rbx
	call	sprintf

; 439  :         return( buffer );

	mov	rax, rbx

; 440  :     }
; 441  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@get_seg_al:

; 435  :     case MAX_SEGALIGNMENT:
; 436  :                return( strings[LS_ABS]   );

	lea	rax, OFFSET FLAT:$SG5893

; 440  :     }
; 441  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@get_seg_al:

; 434  :     case 8:    return( strings[LS_PAGE]  );

	lea	rax, OFFSET FLAT:$SG5862

; 440  :     }
; 441  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@get_seg_al:

; 433  :     case 4:    return( strings[LS_PARA]  );

	lea	rax, OFFSET FLAT:$SG5858

; 440  :     }
; 441  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
get_seg_align ENDP
; Function compile flags: /Ogtpy
seg$ = 8
get_seg_combine PROC NEAR

; 446  :     switch( seg->combine ) {

	mov	dl, BYTE PTR [rcx+108]
	and	edx, 7
	je	SHORT $LN4@get_seg_co
	sub	edx, 2
	je	SHORT $LN2@get_seg_co
	sub	edx, 3
	je	SHORT $LN3@get_seg_co
	dec	edx
	je	SHORT $LN1@get_seg_co

; 452  :     }
; 453  :     return( "?" );

	lea	rax, OFFSET FLAT:$SG6127

; 454  : }

	ret	0
$LN1@get_seg_co:

; 450  :     /* v2.06: added */
; 451  :     case COMB_COMMON:     return( strings[LS_COMMON]  );

	lea	rax, OFFSET FLAT:$SG5886

; 454  : }

	ret	0
$LN3@get_seg_co:

; 448  :     case COMB_STACK:      return( strings[LS_STACK]   );

	lea	rax, OFFSET FLAT:$SG5884

; 454  : }

	ret	0
$LN2@get_seg_co:

; 449  :     case COMB_ADDOFF:     return( strings[LS_PUBLIC]  );

	lea	rax, OFFSET FLAT:$SG5885

; 454  : }

	ret	0
$LN4@get_seg_co:

; 447  :     case COMB_INVALID:    return( strings[LS_PRIVATE] );

	lea	rax, OFFSET FLAT:$SG5883

; 454  : }

	ret	0
get_seg_combine ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$log_macro DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$log_macro DD @imagerel(log_macro#)
	DD	@imagerel(log_macro#+118)
	DD	@imagerel($unwind$log_macro#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
log_macro PROC NEAR

; 458  : {

	sub	rsp, 40					; 00000028H

; 459  :     int i = sym->name_size;
; 460  :     const char *pdots;
; 461  :     const char *type = (sym->isfunc) ? strings[LS_FUNC] : strings[LS_PROC];

	test	BYTE PTR [rcx+52], 2
	movzx	eax, BYTE PTR [rcx+80]
	lea	rdx, OFFSET FLAT:$SG5881
	lea	r9, OFFSET FLAT:$SG5880
	cmovne	r9, rdx

; 462  : 
; 463  :     pdots = ((i >= DOTSMAX) ? "" : dots + i + 1 );

	cmp	eax, 32					; 00000020H
	jl	SHORT $LN3@log_macro
	lea	r8, OFFSET FLAT:$SG6134
	jmp	SHORT $LN4@log_macro
$LN3@log_macro:
	mov	r8, rax
	lea	rax, OFFSET FLAT:dots+1
	add	r8, rax
$LN4@log_macro:

; 464  :     LstPrintf( "%s %s        %s", sym->name, pdots ,type );

	mov	rdx, QWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG6135
	call	LstPrintf

; 465  : #ifdef DEBUG_OUT
; 466  :     LstPrintf( " %5lu", ((struct dsym *)sym)->e.macroinfo->count );
; 467  : #endif
; 468  :     LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN5@log_macro
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6092
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN5@log_macro:

; 469  :     return;
; 470  : }

	add	rsp, 40					; 00000028H
	ret	0
log_macro ENDP
; Function compile flags: /Ogtpy
mem_type$ = 8
SimpleTypeString PROC NEAR

; 475  :     int size = ( mem_type & 0x3f ) + 1;

	and	ecx, 63					; 0000003fH

; 476  :     switch ( size ) {

	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN10@SimpleType
	lea	rdx, OFFSET FLAT:__ImageBase
	movsxd	rax, ecx
	movzx	eax, BYTE PTR $LN14@SimpleType[rdx+rax]
	mov	ecx, DWORD PTR $LN15@SimpleType[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN9@SimpleType:

; 477  :     case 1: return( strings[LS_BYTE] );

	lea	rax, OFFSET FLAT:$SG5852

; 490  : }

	ret	0
$LN8@SimpleType:

; 478  :     case 2: return( strings[LS_WORD] );

	lea	rax, OFFSET FLAT:$SG5853

; 490  : }

	ret	0
$LN7@SimpleType:

; 479  :     case 4: return( strings[LS_DWORD] );

	lea	rax, OFFSET FLAT:$SG5854

; 490  : }

	ret	0
$LN6@SimpleType:

; 480  :     case 6: return( strings[LS_FWORD] );

	lea	rax, OFFSET FLAT:$SG5855

; 490  : }

	ret	0
$LN5@SimpleType:

; 481  :     case 8: return( strings[LS_QWORD] );

	lea	rax, OFFSET FLAT:$SG5856

; 490  : }

	ret	0
$LN4@SimpleType:

; 482  :     case 10:return( strings[LS_TBYTE] );

	lea	rax, OFFSET FLAT:$SG5857

; 490  : }

	ret	0
$LN3@SimpleType:

; 483  :     case 16:return( strings[LS_OWORD] );

	lea	rax, OFFSET FLAT:$SG5859

; 490  : }

	ret	0
$LN2@SimpleType:

; 484  : #if AVXSUPP
; 485  :     case 32:  return( strings[LS_YMMWORD] );

	lea	rax, OFFSET FLAT:$SG5860

; 490  : }

	ret	0
$LN1@SimpleType:

; 486  :     case 64:  return( strings[LS_ZMMWORD] );

	lea	rax, OFFSET FLAT:$SG5861

; 490  : }

	ret	0
$LN10@SimpleType:

; 487  : #endif
; 488  :     }
; 489  :     return( "" );

	lea	rax, OFFSET FLAT:$SG6154

; 490  : }

	ret	0
	npad	2
$LN15@SimpleType:
	DD	$LN9@SimpleType
	DD	$LN8@SimpleType
	DD	$LN7@SimpleType
	DD	$LN6@SimpleType
	DD	$LN5@SimpleType
	DD	$LN4@SimpleType
	DD	$LN3@SimpleType
	DD	$LN2@SimpleType
	DD	$LN1@SimpleType
	DD	$LN10@SimpleType
$LN14@SimpleType:
	DB	0
	DB	1
	DB	9
	DB	2
	DB	9
	DB	3
	DB	9
	DB	4
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	7
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	8
SimpleTypeString ENDP
_TEXT	ENDS
EXTRN	GetSymOfssize:NEAR
xdata	SEGMENT
$unwind$GetMemtypeString DD 051201H
	DD	04c412H
	DD	06340dH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$GetMemtypeString DD @imagerel(GetMemtypeString#)
	DD	@imagerel(GetMemtypeString#+168)
	DD	@imagerel($unwind$GetMemtypeString#)
pdata	ENDS
xdata	SEGMENT
$chain$2$GetMemtypeString DD 020521H
	DD	086405H
	DD	@imagerel(GetMemtypeString#)
	DD	@imagerel(GetMemtypeString#+168)
	DD	@imagerel($unwind$GetMemtypeString#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$GetMemtypeString DD @imagerel(GetMemtypeString#+168)
	DD	@imagerel(GetMemtypeString#+236)
	DD	@imagerel($chain$2$GetMemtypeString#)
pdata	ENDS
xdata	SEGMENT
$chain$4$GetMemtypeString DD 040e21H
	DD	09740eH
	DD	075405H
	DD	@imagerel(GetMemtypeString#+168)
	DD	@imagerel(GetMemtypeString#+236)
	DD	@imagerel($chain$2$GetMemtypeString#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$GetMemtypeString DD @imagerel(GetMemtypeString#+236)
	DD	@imagerel(GetMemtypeString#+303)
	DD	@imagerel($chain$4$GetMemtypeString#)
pdata	ENDS
xdata	SEGMENT
$chain$5$GetMemtypeString DD 020021H
	DD	097400H
	DD	@imagerel(GetMemtypeString#+168)
	DD	@imagerel(GetMemtypeString#+236)
	DD	@imagerel($chain$2$GetMemtypeString#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$GetMemtypeString DD @imagerel(GetMemtypeString#+303)
	DD	@imagerel(GetMemtypeString#+397)
	DD	@imagerel($chain$5$GetMemtypeString#)
pdata	ENDS
xdata	SEGMENT
$chain$6$GetMemtypeString DD 021H
	DD	@imagerel(GetMemtypeString#)
	DD	@imagerel(GetMemtypeString#+168)
	DD	@imagerel($unwind$GetMemtypeString#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$GetMemtypeString DD @imagerel(GetMemtypeString#+397)
	DD	@imagerel(GetMemtypeString#+412)
	DD	@imagerel($chain$6$GetMemtypeString#)
pdata	ENDS
xdata	SEGMENT
$chain$7$GetMemtypeString DD 020021H
	DD	086400H
	DD	@imagerel(GetMemtypeString#)
	DD	@imagerel(GetMemtypeString#+168)
	DD	@imagerel($unwind$GetMemtypeString#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$GetMemtypeString DD @imagerel(GetMemtypeString#+412)
	DD	@imagerel(GetMemtypeString#+435)
	DD	@imagerel($chain$7$GetMemtypeString#)
pdata	ENDS
xdata	SEGMENT
$chain$8$GetMemtypeString DD 021H
	DD	@imagerel(GetMemtypeString#)
	DD	@imagerel(GetMemtypeString#+168)
	DD	@imagerel($unwind$GetMemtypeString#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$GetMemtypeString DD @imagerel(GetMemtypeString#+435)
	DD	@imagerel(GetMemtypeString#+595)
	DD	@imagerel($chain$8$GetMemtypeString#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
buffer$ = 56
GetMemtypeString PROC NEAR

; 499  : {

	sub	rsp, 40					; 00000028H

; 500  :     const char *p;
; 501  :     enum memtype mem_type;
; 502  : 
; 503  :     if ( (sym->mem_type & MT_SPECIAL) == 0 )

	mov	r8d, DWORD PTR [rcx+44]
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+32], r12
	test	r8b, r8b
	mov	r12, rdx
	mov	rbx, rcx
	jns	SHORT $LN34@GetMemtype
	mov	edx, 195				; 000000c3H
$LL29@GetMemtype:

; 505  : 
; 506  :     /* v2.05: improve display of stack vars */
; 507  :     mem_type = sym->mem_type;
; 508  :     if ( sym->state == SYM_STACK && sym->is_ptr )

	cmp	DWORD PTR [rbx+40], 5
	jne	SHORT $LN23@GetMemtype
	cmp	BYTE PTR [rbx+53], 0
	cmovne	r8d, edx
$LN23@GetMemtype:

; 509  :         mem_type = MT_PTR;
; 510  : 
; 511  :     switch ( mem_type ) {

	sub	r8d, 129				; 00000081H
	je	$LN5@GetMemtype
	dec	r8d
	je	$LN7@GetMemtype
	sub	r8d, 62					; 0000003eH
	je	$LN1@GetMemtype
	sub	r8d, 3
	je	SHORT $LN20@GetMemtype
	dec	r8d
	jne	SHORT $LN21@GetMemtype

; 549  :     case MT_TYPE:
; 550  :         if ( *(sym->type->name) )  /* there are a lot of unnamed types */

	mov	rcx, QWORD PTR [rbx+88]
	mov	rax, QWORD PTR [rcx+8]
	cmp	BYTE PTR [rax], r8b
	jne	$LN25@GetMemtype
	mov	r8d, DWORD PTR [rcx+44]

; 551  :             return( sym->type->name );
; 552  :         /* v2.04: changed */
; 553  :         //return( strings[LS_PTR] );
; 554  :         return( GetMemtypeString( sym->type, buffer ) );

	mov	rbx, rcx
	test	r8b, r8b
	js	SHORT $LL29@GetMemtype
$LN34@GetMemtype:

; 504  :         return( SimpleTypeString( sym->mem_type ) );

	mov	ecx, DWORD PTR [rbx+44]
	mov	r12, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+48]

; 565  : }

	add	rsp, 40					; 00000028H
	jmp	SimpleTypeString
$LN21@GetMemtype:

; 558  : #ifdef DEBUG_OUT /* v2.11: obsolete */
; 559  :     case MT_PROC:
; 560  :         printf("GetMemtypeString: found mem_type=MT_PROC for sym=%s\n", sym->name );
; 561  :         break;
; 562  : #endif
; 563  :     }
; 564  :     return("?");

	lea	rax, OFFSET FLAT:$SG6192
	mov	r12, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+48]

; 565  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN20@GetMemtype:

; 512  :     case MT_PTR:
; 513  : #if AMD64_SUPPORT
; 514  :         if ( sym->Ofssize == USE64 )

	movzx	eax, BYTE PTR [rbx+52]
	mov	QWORD PTR [rsp+64], rsi
	cmp	al, 2
	jne	SHORT $LN19@GetMemtype

; 515  :             p = strings[LS_NEAR];

	lea	rsi, OFFSET FLAT:$SG5863

; 516  :         else

	jmp	SHORT $LN16@GetMemtype
$LN19@GetMemtype:

; 517  : #endif
; 518  :             if ( sym->isfar )

	test	BYTE PTR [rbx+55], 16
	je	SHORT $LN17@GetMemtype

; 519  :                 p = strings[LS_FAR16 + sym->Ofssize];

	lea	rcx, OFFSET FLAT:strings
	movzx	eax, al
	mov	rsi, QWORD PTR [rcx+rax*8+128]

; 520  :             else

	jmp	SHORT $LN16@GetMemtype
$LN17@GetMemtype:

; 521  :                 p = strings[LS_NEAR16 + sym->Ofssize];

	lea	rcx, OFFSET FLAT:strings
	movzx	eax, al
	mov	rsi, QWORD PTR [rcx+rax*8+96]
$LN16@GetMemtype:

; 522  : 
; 523  :         if ( buffer ) { /* Currently, 'buffer' is only != NULL for typedefs */

	test	r12, r12
	je	$LN15@GetMemtype
	mov	QWORD PTR [rsp+56], rbp

; 524  :             int i;
; 525  :             char *b2 = buffer;
; 526  :             /* v2.10: improved pointer TYPEDEF display */
; 527  :             for ( i = sym->is_ptr; i; i-- ) {

	movzx	ebp, BYTE PTR [rbx+53]
	mov	QWORD PTR [rsp+72], rdi
	test	ebp, ebp
	mov	rdi, r12
	je	SHORT $LN12@GetMemtype
$LL14@GetMemtype:

; 528  :                 b2 += sprintf( b2, "%s %s ", p, strings[LS_PTR] );

	lea	r9, OFFSET FLAT:$SG5879
	lea	rdx, OFFSET FLAT:$SG6180
	mov	r8, rsi
	mov	rcx, rdi
	call	sprintf
	movsxd	rcx, eax
	add	rdi, rcx
	dec	ebp
	jne	SHORT $LL14@GetMemtype
$LN12@GetMemtype:

; 529  :             }
; 530  :             /* v2.05: added. */
; 531  :             if ( sym->state == SYM_TYPE && sym->typekind == TYPE_TYPEDEF ) {

	cmp	DWORD PTR [rbx+40], 7
	mov	rbp, QWORD PTR [rsp+56]
	jne	SHORT $LN8@GetMemtype
	cmp	BYTE PTR [rbx+74], 3
	jne	SHORT $LN8@GetMemtype

; 532  :                 //strcat( buffer, " ");
; 533  :                 if ( sym->target_type )

	mov	rcx, QWORD PTR [rbx+56]
	test	rcx, rcx
	je	SHORT $LN10@GetMemtype

; 534  :                     strcpy( b2, sym->target_type->name );

	mov	rcx, QWORD PTR [rcx+8]
$LL27@GetMemtype:
	movzx	eax, BYTE PTR [rcx]
	inc	rdi
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi-1], al
	jne	SHORT $LL27@GetMemtype
	jmp	SHORT $LN8@GetMemtype
$LN10@GetMemtype:

; 535  :                 else if ( ( sym->ptr_memtype & MT_SPECIAL ) == 0 )

	movzx	eax, BYTE PTR [rbx+54]
	test	al, al
	js	SHORT $LN8@GetMemtype

; 536  :                     strcpy( b2, SimpleTypeString( sym->ptr_memtype ) );

	movzx	ecx, al
	call	SimpleTypeString
	npad	12
$LL28@GetMemtype:
	movzx	ecx, BYTE PTR [rax]
	inc	rdi
	inc	rax
	test	cl, cl
	mov	BYTE PTR [rdi-1], cl
	jne	SHORT $LL28@GetMemtype
$LN8@GetMemtype:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]

; 537  :             }
; 538  :             return( buffer );

	mov	rax, r12
$LN25@GetMemtype:
	mov	r12, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+48]

; 565  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN15@GetMemtype:

; 539  :         }
; 540  :         return( p );

	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+64]
	mov	r12, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+48]

; 565  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN1@GetMemtype:

; 555  :     //case MT_ABS: /* v2.07: MT_ABS is obsolete */
; 556  :     case MT_EMPTY: /* number, via EQU or = directive */
; 557  :         return( strings[LS_NUMBER] );

	lea	rax, OFFSET FLAT:$SG5882
	mov	r12, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+48]

; 565  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN7@GetMemtype:

; 541  :     case MT_FAR:
; 542  :         if ( sym->segment )

	cmp	QWORD PTR [rbx+32], 0
	je	SHORT $LN6@GetMemtype

; 543  :             return( strings[LS_LFAR] );

	lea	rax, OFFSET FLAT:$SG5875
	mov	r12, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+48]

; 565  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@GetMemtype:

; 544  :         return( strings[LS_LFAR16 + GetSymOfssize( sym )] );

	mov	rcx, rbx
	call	GetSymOfssize
	lea	rcx, OFFSET FLAT:strings
	cdqe
	mov	rax, QWORD PTR [rcx+rax*8+192]
	mov	r12, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+48]

; 565  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN5@GetMemtype:

; 545  :     case MT_NEAR:
; 546  :         if ( sym->segment )

	cmp	QWORD PTR [rbx+32], 0
	je	SHORT $LN4@GetMemtype

; 547  :             return( strings[LS_LNEAR] );

	lea	rax, OFFSET FLAT:$SG5871
	mov	r12, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+48]

; 565  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@GetMemtype:

; 548  :         return( strings[LS_LNEAR16 + GetSymOfssize( sym )] );

	mov	rcx, rbx
	call	GetSymOfssize
	mov	r12, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:strings
	cdqe
	mov	rax, QWORD PTR [rcx+rax*8+160]

; 565  : }

	add	rsp, 40					; 00000028H
	ret	0
GetMemtypeString ENDP
; Function compile flags: /Ogtpy
sym$ = 8
GetLanguage PROC NEAR

; 570  :     if ( sym->langtype <= 7 )

	movsxd	rax, DWORD PTR [rcx+84]
	cmp	eax, 7
	jg	SHORT $LN1@GetLanguag

; 571  :         return( strings[sym->langtype + LS_VOID] );

	lea	rcx, OFFSET FLAT:strings+352
	mov	rax, QWORD PTR [rcx+rax*8]

; 573  : }

	ret	0
$LN1@GetLanguag:

; 572  :     return( "?" );

	lea	rax, OFFSET FLAT:$SG6198

; 573  : }

	ret	0
GetLanguage ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$log_struct DD 093e01H
	DD	06743eH
	DD	0d3439H
	DD	07641fH
	DD	085416H
	DD	0820eH
xdata	ENDS
pdata	SEGMENT
$pdata$log_struct DD @imagerel(log_struct#)
	DD	@imagerel(log_struct#+1172)
	DD	@imagerel($unwind$log_struct#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 80
name$ = 88
ofs$ = 96
log_struct PROC NEAR

; 579  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 580  :     unsigned      i;
; 581  :     struct dsym   *dir;
; 582  :     const char    *pdots;
; 583  :     struct struct_info *si;
; 584  :     struct sfield *f;
; 585  :     static int    prefix = 0;
; 586  : 
; 587  :     dir = (struct dsym *)sym;
; 588  : 
; 589  :     /* filter typedefs and records */
; 590  :     //if ( dir->sym.typekind != TYPE_STRUCT &&
; 591  :     //     dir->sym.typekind != TYPE_UNION )
; 592  :     //    return;
; 593  : 
; 594  :     si = dir->e.structinfo;
; 595  : 
; 596  :     if ( !name )

	test	rdx, rdx
	mov	QWORD PTR [rsp+64], rbp
	mov	rbp, QWORD PTR [rcx+104]
	mov	QWORD PTR [rsp+56], rsi
	mov	r8, rcx
	mov	rsi, rdx
	jne	SHORT $LN19@log_struct

; 597  :         name = sym->name;

	mov	rsi, QWORD PTR [rcx+8]
$LN19@log_struct:

; 598  :     i = strlen ( name );
; 599  :     pdots = (( (i+prefix) >= DOTSMAX) ? "" : dots + i + prefix + 1 );

	movsxd	rdx, DWORD PTR ?prefix@?1??log_struct@@9@9
	xor	eax, eax
	mov	QWORD PTR [rsp+104], rbx
	mov	QWORD PTR [rsp+48], rdi
	mov	rcx, -1
	mov	rdi, rsi
	repne scasb
	lea	rdi, OFFSET FLAT:dots+1
	not	rcx
	dec	rcx
	lea	eax, DWORD PTR [rdx+rcx]
	cmp	eax, 32					; 00000020H
	jb	SHORT $LN22@log_struct
	lea	rbx, OFFSET FLAT:$SG6215
	jmp	SHORT $LN23@log_struct
$LN22@log_struct:
	mov	ebx, ecx
	add	rbx, rdx
	add	rbx, rdi
$LN23@log_struct:

; 600  :     for ( i = 0; i < prefix; i++ )

	xor	edi, edi
	test	edx, edx
	je	SHORT $LN16@log_struct
	npad	10
$LL18@log_struct:

; 601  :         LstPrintf(" ");

	lea	rcx, OFFSET FLAT:$SG6219
	call	LstPrintf
	mov	edx, DWORD PTR ?prefix@?1??log_struct@@9@9
	inc	edi
	cmp	edi, edx
	jb	SHORT $LL18@log_struct
	mov	r8, QWORD PTR sym$[rsp]
$LN16@log_struct:

; 602  :     if ( prefix == 0 )

	test	edx, edx
	jne	SHORT $LN15@log_struct

; 603  :         if ( dir->e.structinfo->alignment > 1)

	mov	rax, QWORD PTR [r8+104]
	cmp	BYTE PTR [rax+28], 1
	jbe	SHORT $LN14@log_struct

; 604  :             LstPrintf( "%s %s        %8" I32_SPEC "X (%u)", name, pdots, sym->total_size, si->alignment );

	movzx	eax, BYTE PTR [rbp+28]
	mov	r9d, DWORD PTR [r8+64]
	lea	rcx, OFFSET FLAT:$SG6222
	mov	r8, rbx
	mov	rdx, rsi
	mov	DWORD PTR [rsp+32], eax
	call	LstPrintf

; 605  :         else

	mov	edi, DWORD PTR ofs$[rsp]
	jmp	SHORT $LN12@log_struct
$LN14@log_struct:

; 606  :             LstPrintf( "%s %s        %8" I32_SPEC "X", name, pdots, sym->total_size );

	mov	r9d, DWORD PTR [r8+64]
	lea	rcx, OFFSET FLAT:$SG6224
	mov	rdx, rsi
	mov	r8, rbx
	call	LstPrintf

; 607  :     else

	mov	edi, DWORD PTR ofs$[rsp]
	jmp	SHORT $LN12@log_struct
$LN15@log_struct:

; 608  :         LstPrintf( "%s %s        %8" I32_SPEC "X", name, pdots, sym->offset + ofs);

	mov	eax, DWORD PTR [r8+16]
	mov	edi, DWORD PTR ofs$[rsp]
	lea	rcx, OFFSET FLAT:$SG6226
	lea	r9d, DWORD PTR [rdi+rax]
	mov	r8, rbx
	mov	rdx, rsi
	call	LstPrintf
$LN12@log_struct:

; 609  :     LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN26@log_struct
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6092
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN26@log_struct:

; 610  :     prefix += 2;

	mov	ecx, DWORD PTR ?prefix@?1??log_struct@@9@9

; 611  :     for( f = si->head; f; f = f->next ) {

	mov	rbx, QWORD PTR [rbp]
	add	ecx, 2
	test	rbx, rbx
	mov	DWORD PTR ?prefix@?1??log_struct@@9@9, ecx
	je	$LN81@log_struct
	mov	rbp, QWORD PTR sym$[rsp]
$LL11@log_struct:

; 612  :         /* recursion if an embedded struct occurs */
; 613  :         /* v2.09: field init_dir removed */
; 614  :         //if ( f->sym->mem_type == MT_TYPE && f->init_dir == NULL ) {
; 615  :         if ( f->sym.mem_type == MT_TYPE && f->ivalue[0] == NULLC ) {

	mov	edx, DWORD PTR [rbx+44]
	cmp	edx, 196				; 000000c4H
	jne	SHORT $LN8@log_struct
	cmp	BYTE PTR [rbx+112], 0
	jne	SHORT $LN8@log_struct

; 616  :             log_struct( f->sym.type, f->sym.name, f->sym.offset + ofs );

	mov	eax, DWORD PTR [rbx+16]
	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rbx+88]
	lea	r8d, DWORD PTR [rdi+rax]
	call	log_struct

; 617  :         } else {

	mov	ecx, DWORD PTR ?prefix@?1??log_struct@@9@9
	jmp	$LN10@log_struct
$LN8@log_struct:

; 618  :             /* don't list unstructured fields without name */
; 619  :             /* but do list them if they are structured */
; 620  :             if (*(f->sym.name) || (f->sym.mem_type == MT_TYPE)) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax], 0
	jne	SHORT $LN5@log_struct
	cmp	edx, 196				; 000000c4H
	jne	$LN10@log_struct
$LN5@log_struct:

; 621  :                 i = f->sym.name_size + prefix;

	movzx	eax, BYTE PTR [rbx+80]
	add	eax, ecx

; 622  :                 pdots = ((i >= DOTSMAX) ? "" : dots + i + 1 );

	cmp	eax, 32					; 00000020H
	jb	SHORT $LN24@log_struct
	lea	rsi, OFFSET FLAT:$SG6234
	jmp	SHORT $LN25@log_struct
$LN24@log_struct:
	mov	esi, eax
	lea	rax, OFFSET FLAT:dots+1
	add	rsi, rax
$LN25@log_struct:

; 623  :                 for ( i = 0; i < prefix; i++ )

	xor	edi, edi
	test	ecx, ecx
	je	SHORT $LN2@log_struct
	npad	3
$LL4@log_struct:

; 624  :                     LstPrintf(" ");

	lea	rcx, OFFSET FLAT:$SG6238
	call	LstPrintf
	inc	edi
	cmp	edi, DWORD PTR ?prefix@?1??log_struct@@9@9
	jb	SHORT $LL4@log_struct
$LN2@log_struct:

; 625  :                 LstPrintf( "%s %s        %8" I32_SPEC "X   ", f->sym.name, pdots, f->sym.offset + sym->offset + ofs);

	mov	r9d, DWORD PTR [rbx+16]
	mov	edi, DWORD PTR ofs$[rsp]
	mov	rdx, QWORD PTR [rbx+8]
	add	r9d, DWORD PTR [rbp+16]
	lea	rcx, OFFSET FLAT:$SG6239
	mov	r8, rsi
	add	r9d, edi
	call	LstPrintf

; 626  :                 LstPrintf( "%s", GetMemtypeString( &f->sym, NULL ) );

	mov	edx, DWORD PTR [rbx+44]
	test	dl, dl
	js	$LN52@log_struct
	and	edx, 63					; 0000003fH
	cmp	edx, 63					; 0000003fH
	ja	$LN66@log_struct
	movsxd	rax, edx
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN79@log_struct[rdx+rax]
	mov	ecx, DWORD PTR $LN80@log_struct[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN65@log_struct:
	lea	rax, OFFSET FLAT:$SG5852
	jmp	$LN53@log_struct
$LN64@log_struct:
	lea	rax, OFFSET FLAT:$SG5853
	jmp	$LN53@log_struct
$LN63@log_struct:
	lea	rax, OFFSET FLAT:$SG5854
	jmp	$LN53@log_struct
$LN62@log_struct:
	lea	rax, OFFSET FLAT:$SG5855
	jmp	$LN53@log_struct
$LN61@log_struct:
	lea	rax, OFFSET FLAT:$SG5856
	jmp	$LN53@log_struct
$LN60@log_struct:
	lea	rax, OFFSET FLAT:$SG5857
	jmp	$LN53@log_struct
$LN59@log_struct:
	lea	rax, OFFSET FLAT:$SG5859
	jmp	$LN53@log_struct
$LN58@log_struct:
	lea	rax, OFFSET FLAT:$SG5860
	jmp	$LN53@log_struct
$LN57@log_struct:
	lea	rax, OFFSET FLAT:$SG5861
	jmp	$LN53@log_struct
$LN66@log_struct:
	lea	rax, OFFSET FLAT:$SG6154
	jmp	$LN53@log_struct
$LN52@log_struct:
	cmp	DWORD PTR [rbx+40], 5
	jne	SHORT $LN51@log_struct
	cmp	BYTE PTR [rbx+53], 0
	mov	eax, 195				; 000000c3H
	cmovne	edx, eax
$LN51@log_struct:
	sub	edx, 129				; 00000081H
	je	$LN33@log_struct
	dec	edx
	je	$LN35@log_struct
	sub	edx, 62					; 0000003eH
	je	SHORT $LN29@log_struct
	sub	edx, 3
	je	SHORT $LN48@log_struct
	dec	edx
	je	SHORT $LN31@log_struct
	lea	rax, OFFSET FLAT:$SG6192
	jmp	$LN53@log_struct
$LN31@log_struct:
	mov	rcx, QWORD PTR [rbx+88]
	mov	rax, QWORD PTR [rcx+8]
	cmp	BYTE PTR [rax], 0
	jne	$LN53@log_struct
	xor	edx, edx
	call	GetMemtypeString
	jmp	$LN53@log_struct
$LN48@log_struct:
	movzx	eax, BYTE PTR [rbx+52]
	cmp	al, 2
	jne	SHORT $LN47@log_struct
	lea	rax, OFFSET FLAT:$SG5863
	jmp	$LN53@log_struct
$LN47@log_struct:
	test	BYTE PTR [rbx+55], 16
	je	SHORT $LN45@log_struct
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, al
	mov	rax, QWORD PTR strings[rcx+rax*8+128]
	jmp	SHORT $LN53@log_struct
$LN45@log_struct:
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, al
	mov	rax, QWORD PTR strings[rcx+rax*8+96]
	jmp	SHORT $LN53@log_struct
$LN29@log_struct:
	lea	rax, OFFSET FLAT:$SG5882
	jmp	SHORT $LN53@log_struct
$LN35@log_struct:
	cmp	QWORD PTR [rbx+32], 0
	je	SHORT $LN34@log_struct
	lea	rax, OFFSET FLAT:$SG5875
	jmp	SHORT $LN53@log_struct
$LN34@log_struct:
	mov	rcx, rbx
	call	GetSymOfssize
	movsxd	rcx, eax
	lea	rax, OFFSET FLAT:__ImageBase
	mov	rax, QWORD PTR strings[rax+rcx*8+192]
	jmp	SHORT $LN53@log_struct
$LN33@log_struct:
	cmp	QWORD PTR [rbx+32], 0
	je	SHORT $LN32@log_struct
	lea	rax, OFFSET FLAT:$SG5871
	jmp	SHORT $LN53@log_struct
$LN32@log_struct:
	mov	rcx, rbx
	call	GetSymOfssize
	movsxd	rcx, eax
	lea	rax, OFFSET FLAT:__ImageBase
	mov	rax, QWORD PTR strings[rax+rcx*8+160]
$LN53@log_struct:
	lea	rcx, OFFSET FLAT:$SG6241
	mov	rdx, rax
	call	LstPrintf

; 627  :                 if ( f->sym.isarray )

	test	BYTE PTR [rbx+49], 2
	je	SHORT $LN1@log_struct

; 628  :                     LstPrintf( "[%u]",f->sym.total_length );

	mov	edx, DWORD PTR [rbx+72]
	lea	rcx, OFFSET FLAT:$SG6243
	call	LstPrintf
$LN1@log_struct:

; 629  :                 LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN82@log_struct
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6092
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
	mov	ecx, DWORD PTR ?prefix@?1??log_struct@@9@9
	jmp	SHORT $LN10@log_struct
$LN82@log_struct:
	mov	ecx, DWORD PTR ?prefix@?1??log_struct@@9@9
$LN10@log_struct:

; 611  :     for( f = si->head; f; f = f->next ) {

	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	$LL11@log_struct
$LN81@log_struct:
	mov	rdi, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+104]

; 630  :             }
; 631  :         }
; 632  :     }
; 633  :     prefix -= 2;

	sub	ecx, 2
	mov	DWORD PTR ?prefix@?1??log_struct@@9@9, ecx

; 634  : }

	add	rsp, 72					; 00000048H
	ret	0
$LN80@log_struct:
	DD	$LN65@log_struct
	DD	$LN64@log_struct
	DD	$LN63@log_struct
	DD	$LN62@log_struct
	DD	$LN61@log_struct
	DD	$LN60@log_struct
	DD	$LN59@log_struct
	DD	$LN58@log_struct
	DD	$LN57@log_struct
	DD	$LN66@log_struct
$LN79@log_struct:
	DB	0
	DB	1
	DB	9
	DB	2
	DB	9
	DB	3
	DB	9
	DB	4
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	7
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	8
log_struct ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$log_record DD 071e01H
	DD	0d741eH
	DD	0c6419H
	DD	0a340dH
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$log_record DD @imagerel(log_record#)
	DD	@imagerel(log_record#+156)
	DD	@imagerel($unwind$log_record#)
pdata	ENDS
xdata	SEGMENT
$chain$3$log_record DD 020521H
	DD	0b5405H
	DD	@imagerel(log_record#)
	DD	@imagerel(log_record#+156)
	DD	@imagerel($unwind$log_record#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$log_record DD @imagerel(log_record#+156)
	DD	@imagerel(log_record#+425)
	DD	@imagerel($chain$3$log_record#)
pdata	ENDS
xdata	SEGMENT
$chain$4$log_record DD 021H
	DD	@imagerel(log_record#)
	DD	@imagerel(log_record#+156)
	DD	@imagerel($unwind$log_record#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$log_record DD @imagerel(log_record#+425)
	DD	@imagerel(log_record#+445)
	DD	@imagerel($chain$4$log_record#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 80
log_record PROC NEAR

; 638  : {

	sub	rsp, 72					; 00000048H

; 639  : #if AMD64_SUPPORT
; 640  :     uint_64         mask;
; 641  : #else
; 642  :     uint_32         mask;
; 643  : #endif
; 644  :     struct dsym     *dir = (struct dsym *)sym;
; 645  :     struct struct_info *si = dir->e.structinfo;
; 646  :     struct sfield   *f;
; 647  :     int i = sym->name_size;

	movzx	eax, BYTE PTR [rcx+80]
	mov	QWORD PTR [rsp+80], rbx
	mov	rbx, QWORD PTR [rcx+104]

; 648  :     const char *pdots;
; 649  : 
; 650  :     pdots = ((i >= DOTSMAX) ? "" : dots + i + 1 );

	cmp	eax, 32					; 00000020H
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+104], rdi
	mov	rdi, rcx
	lea	rsi, OFFSET FLAT:dots+1
	jl	SHORT $LN14@log_record
	lea	r8, OFFSET FLAT:$SG6254
	jmp	SHORT $LN15@log_record
$LN14@log_record:
	lea	r8, QWORD PTR [rsi+rax]
$LN15@log_record:

; 651  :     for( i = 0,f = si->head; f; f = f->next,i++ );

	mov	rax, QWORD PTR [rbx]
	xor	ecx, ecx
	test	rax, rax
	je	SHORT $LN9@log_record
$LL11@log_record:
	mov	rax, QWORD PTR [rax+104]
	inc	ecx
	test	rax, rax
	jne	SHORT $LL11@log_record
$LN9@log_record:

; 652  :     LstPrintf( "%s %s      %6" I32_SPEC "X  %7X", sym->name, pdots, sym->total_size*8, i );

	mov	r9d, DWORD PTR [rdi+64]
	mov	rdx, QWORD PTR [rdi+8]
	mov	DWORD PTR [rsp+32], ecx
	lea	rcx, OFFSET FLAT:$SG6258
	shl	r9d, 3
	call	LstPrintf

; 653  :     LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN22@log_record
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6092
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN22@log_record:

; 654  :     for( f = si->head; f; f = f->next ) {

	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	je	$LN6@log_record
	mov	QWORD PTR [rsp+88], rbp
	lea	rbp, OFFSET FLAT:$SG6262
	npad	8
$LL8@log_record:

; 655  :         i = f->sym.name_size + 2;

	movzx	eax, BYTE PTR [rbx+80]
	add	eax, 2

; 656  :         pdots = ((i >= DOTSMAX) ? "" : dots + i + 1 );

	cmp	eax, 32					; 00000020H
	jl	SHORT $LN16@log_record
	mov	r8, rbp
	jmp	SHORT $LN17@log_record
$LN16@log_record:
	movsxd	r8, eax
	add	r8, rsi
$LN17@log_record:

; 657  :         for ( i = f->sym.offset, mask = 0; i < f->sym.offset + f->sym.total_size; i++ )

	movsxd	r9, DWORD PTR [rbx+16]
	mov	r11d, DWORD PTR [rbx+64]
	xor	r10d, r10d
	lea	eax, DWORD PTR [r11+r9]
	cmp	r9d, eax
	jae	SHORT $LN3@log_record
	sub	eax, r9d
	mov	rcx, r9
	mov	edx, eax
	npad	13
$LL5@log_record:

; 658  : #if AMD64_SUPPORT
; 659  : #if defined(LLONG_MAX) || defined(__GNUC__) || defined(__TINYC__)
; 660  :             mask |= 1ULL << i;
; 661  : #else
; 662  :             mask |= 1i64 << i;

	mov	eax, 1
	shl	rax, cl
	inc	rcx
	or	r10, rax
	dec	rdx
	jne	SHORT $LL5@log_record
$LN3@log_record:

; 663  : #endif
; 664  :         if ( sym->total_size > 4 )

	cmp	DWORD PTR [rdi+64], 4
	jbe	SHORT $LN2@log_record

; 665  :             LstPrintf( "  %s %s      %6" I32_SPEC "X  %7" I32_SPEC "X  %016" I64_SPEC "X %s", f->sym.name, pdots, f->sym.offset, f->sym.total_size, mask, f->ivalue[0] ? f->ivalue : "?" );

	cmp	BYTE PTR [rbx+112], 0
	mov	rdx, QWORD PTR [rbx+8]
	lea	rax, QWORD PTR [rbx+112]
	lea	rcx, OFFSET FLAT:$SG6267
	cmovne	rcx, rax
	mov	QWORD PTR [rsp+48], rcx
	mov	QWORD PTR [rsp+40], r10
	lea	rcx, OFFSET FLAT:$SG6268
	mov	DWORD PTR [rsp+32], r11d
	call	LstPrintf

; 666  :         else

	jmp	SHORT $LN1@log_record
$LN2@log_record:

; 667  :             LstPrintf( "  %s %s      %6" I32_SPEC "X  %7" I32_SPEC "X  %08" I32_SPEC "X %s", f->sym.name, pdots, f->sym.offset, f->sym.total_size, (uint_32)mask, f->ivalue[0] ? f->ivalue : "?" );

	cmp	BYTE PTR [rbx+112], 0
	mov	rdx, QWORD PTR [rbx+8]
	lea	rax, QWORD PTR [rbx+112]
	lea	rcx, OFFSET FLAT:$SG6271
	cmovne	rcx, rax
	mov	QWORD PTR [rsp+48], rcx
	mov	DWORD PTR [rsp+40], r10d
	lea	rcx, OFFSET FLAT:$SG6272
	mov	DWORD PTR [rsp+32], r11d
	call	LstPrintf
$LN1@log_record:

; 668  : #else
; 669  :             mask |= 1 << i;
; 670  :         LstPrintf( "  %s %s      %6" I32_SPEC "X  %7" I32_SPEC "X  %08" I32_SPEC "X %s", f->sym.name, pdots, f->sym.offset, f->sym.total_size, mask, f->ivalue[0] ? f->ivalue : "?" );
; 671  : #endif
; 672  :         LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN7@log_record
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6092
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN7@log_record:
	mov	rbx, QWORD PTR [rbx+104]
	test	rbx, rbx
	jne	$LL8@log_record
	mov	rbp, QWORD PTR [rsp+88]
$LN6@log_record:
	mov	rdi, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [rsp+80]

; 673  :     }
; 674  : }

	add	rsp, 72					; 00000048H
	ret	0
log_record ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$log_typedef DD 010401H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$log_typedef DD @imagerel(log_typedef#)
	DD	@imagerel(log_typedef#+8)
	DD	@imagerel($unwind$log_typedef#)
pdata	ENDS
xdata	SEGMENT
$chain$1$log_typedef DD 040a21H
	DD	0a640aH
	DD	093405H
	DD	@imagerel(log_typedef#)
	DD	@imagerel(log_typedef#+8)
	DD	@imagerel($unwind$log_typedef#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$log_typedef DD @imagerel(log_typedef#+8)
	DD	@imagerel(log_typedef#+83)
	DD	@imagerel($chain$1$log_typedef#)
pdata	ENDS
xdata	SEGMENT
$chain$2$log_typedef DD 020521H
	DD	0b7405H
	DD	@imagerel(log_typedef#+8)
	DD	@imagerel(log_typedef#+83)
	DD	@imagerel($chain$1$log_typedef#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$log_typedef DD @imagerel(log_typedef#+83)
	DD	@imagerel(log_typedef#+470)
	DD	@imagerel($chain$2$log_typedef#)
pdata	ENDS
xdata	SEGMENT
$chain$3$log_typedef DD 021H
	DD	@imagerel(log_typedef#+8)
	DD	@imagerel(log_typedef#+83)
	DD	@imagerel($chain$1$log_typedef#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$log_typedef DD @imagerel(log_typedef#+470)
	DD	@imagerel(log_typedef#+531)
	DD	@imagerel($chain$3$log_typedef#)
pdata	ENDS
xdata	SEGMENT
$chain$4$log_typedef DD 021H
	DD	@imagerel(log_typedef#)
	DD	@imagerel(log_typedef#+8)
	DD	@imagerel($unwind$log_typedef#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$log_typedef DD @imagerel(log_typedef#+531)
	DD	@imagerel(log_typedef#+564)
	DD	@imagerel($chain$4$log_typedef#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 64
log_typedef PROC NEAR

; 680  : {

	sub	rsp, 56					; 00000038H

; 681  :     //struct dsym         *dir = (struct dsym *)sym;
; 682  :     //struct struct_info  *si = dir->e.structinfo;
; 683  :     char *p;
; 684  :     int i = sym->name_size;

	movzx	eax, BYTE PTR [rcx+80]
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+80], rsi

; 685  :     const char *pdots;
; 686  :     //char buffer[256];
; 687  : 
; 688  :     pdots = (( i >= DOTSMAX ) ? "" : dots + i + 1 );

	cmp	eax, 32					; 00000020H
	mov	rbx, rcx
	jl	SHORT $LN6@log_typede
	lea	rsi, OFFSET FLAT:$SG6279
	jmp	SHORT $LN7@log_typede
$LN6@log_typede:
	mov	rsi, rax
	lea	rax, OFFSET FLAT:dots+1
	add	rsi, rax
$LN7@log_typede:

; 689  :     p = StringBufferEnd;

	mov	r8, QWORD PTR ModuleInfo+488

; 690  :     *p = NULLC;

	mov	BYTE PTR [r8], 0

; 691  :     if ( sym->mem_type == MT_PROC && sym->target_type ) { /* typedef proto? */

	cmp	DWORD PTR [rcx+44], 128			; 00000080H
	jne	$LN3@log_typede
	cmp	QWORD PTR [rcx+56], 0
	je	$LN3@log_typede
	mov	QWORD PTR [rsp+88], rdi

; 692  :         strcat( p, strings[LS_PROC] );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, r8
	lea	rdx, OFFSET FLAT:$SG5880
	repne scasb
	xor	ecx, ecx
	npad	1
$LL20@log_typede:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL20@log_typede

; 693  :         strcat( p, " " );

	xor	eax, eax
	mov	rdi, r8
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, OFFSET FLAT:$SG6281
	npad	10
$LL19@log_typede:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL19@log_typede

; 694  :         if ( *sym->target_type->name ) {  /* the name may be "" */

	mov	rax, QWORD PTR [rbx+56]
	mov	rdx, QWORD PTR [rax+8]
	cmp	BYTE PTR [rdx], 0
	je	SHORT $LN2@log_typede

; 695  :             strcat( p, sym->target_type->name );

	xor	eax, eax
	mov	rdi, r8
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	4
$LL18@log_typede:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL18@log_typede

; 696  :             strcat( p," ");

	xor	eax, eax
	mov	rdi, r8
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, OFFSET FLAT:$SG6283
	npad	10
$LL17@log_typede:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL17@log_typede
$LN2@log_typede:

; 697  :         }
; 698  :         /* v2.11: target_type has state SYM_TYPE (since v2.09).
; 699  :          * This state isn't handled properly by GetSymOfsSize(), which is called by GetMemtypeString(),
; 700  :          * so get the strings here.
; 701  :          */
; 702  :         //strcat( p, GetMemtypeString( sym->target_type, NULL ) );
; 703  :         strcat( p, strings[( sym->target_type->mem_type == MT_NEAR ? LS_LNEAR16 : LS_LFAR16 ) + sym->Ofssize ] );

	mov	rax, QWORD PTR [rbx+56]
	mov	ecx, 20
	mov	edx, 24
	cmp	DWORD PTR [rax+44], 129			; 00000081H
	movzx	eax, BYTE PTR [rbx+52]
	lea	r10, OFFSET FLAT:strings
	cmove	rdx, rcx
	mov	rdi, r8
	mov	rcx, -1
	add	rdx, rax
	xor	eax, eax
	mov	r9, QWORD PTR [r10+rdx*8]
	repne scasb
	xor	ecx, ecx
	npad	6
$LL16@log_typede:
	movzx	eax, BYTE PTR [r9+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL16@log_typede

; 704  :         strcat( p," " );

	xor	eax, eax
	mov	rdi, r8
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, OFFSET FLAT:$SG6284
	npad	9
$LL15@log_typede:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL15@log_typede

; 705  :         strcat( p, GetLanguage( sym->target_type ) );

	mov	rax, QWORD PTR [rbx+56]
	movsxd	rcx, DWORD PTR [rax+84]
	cmp	ecx, 7
	jg	SHORT $LN8@log_typede
	mov	rdx, QWORD PTR [r10+rcx*8+352]
	jmp	SHORT $LN9@log_typede
$LN8@log_typede:
	lea	rdx, OFFSET FLAT:$SG6198
$LN9@log_typede:
	xor	eax, eax
	mov	rdi, r8
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	3
$LL14@log_typede:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL14@log_typede
	mov	rdi, QWORD PTR [rsp+88]

; 706  :     } else

	jmp	SHORT $LN1@log_typede
$LN3@log_typede:

; 707  :         p = (char *)GetMemtypeString( sym, p );

	mov	rdx, r8
	call	GetMemtypeString
	mov	r8, rax
$LN1@log_typede:

; 708  :     LstPrintf( "%s %s    %8" I32_SPEC "u  %s", sym->name, pdots, sym->total_size, p );

	mov	r9d, DWORD PTR [rbx+64]
	mov	rdx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rsp+32], r8
	lea	rcx, OFFSET FLAT:$SG6287
	mov	r8, rsi
	call	LstPrintf

; 709  :     LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	mov	rsi, QWORD PTR [rsp+80]
	test	r9, r9
	mov	rbx, QWORD PTR [rsp+72]
	je	SHORT $LN11@log_typede
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6092
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN11@log_typede:

; 710  : }

	add	rsp, 56					; 00000038H
	ret	0
log_typedef ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$log_segment DD 050e01H
	DD	0d740eH
	DD	0c3409H
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$log_segment DD @imagerel(log_segment#)
	DD	@imagerel(log_segment#+452)
	DD	@imagerel($unwind$log_segment#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buffer$ = 32
sym$ = 80
group$ = 88
log_segment PROC NEAR

; 714  : {

	sub	rsp, 72					; 00000048H
	mov	QWORD PTR [rsp+96], rbx
	mov	QWORD PTR [rsp+104], rdi

; 715  :     char buffer[32];
; 716  :     struct seg_info *seg = ((struct dsym *)sym)->e.seginfo;

	mov	rdi, QWORD PTR [rcx+104]

; 717  : 
; 718  :     if( seg->group == group ) {

	cmp	QWORD PTR [rdi], rdx
	mov	rbx, rcx
	jne	$LN33@log_segmen

; 719  :         int i = sym->name_size;

	movzx	eax, BYTE PTR [rcx+80]

; 720  :         const char *pdots;
; 721  :         pdots = (( i >= DOTSMAX ) ? "" : dots + i + 1);

	cmp	eax, 32					; 00000020H
	jl	SHORT $LN8@log_segmen
	lea	r8, OFFSET FLAT:$SG6299
	jmp	SHORT $LN9@log_segmen
$LN8@log_segmen:
	mov	r8, rax
	lea	rax, OFFSET FLAT:dots+1
	add	r8, rax
$LN9@log_segmen:

; 722  :         LstPrintf( "%s %s        ", sym->name, pdots );

	mov	rdx, QWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG6300
	call	LstPrintf

; 723  :         if( seg->Ofssize == USE32 ) {

	movzx	r11d, BYTE PTR [rdi+104]
	cmp	r11b, 1
	jne	SHORT $LN4@log_segmen

; 724  :             //LstPrintf( "32 Bit   %08" I32_SPEC "X ", seg->current_loc );
; 725  :             LstPrintf( "32 Bit   %08" I32_SPEC "X ", sym->max_offset );

	mov	edx, DWORD PTR [rbx+64]
	lea	rcx, OFFSET FLAT:$SG6302
	call	LstPrintf
	jmp	SHORT $LN1@log_segmen
$LN4@log_segmen:

; 726  : #if AMD64_SUPPORT
; 727  :         } else if( seg->Ofssize == USE64 ) {

	cmp	r11b, 2
	jne	SHORT $LN2@log_segmen

; 728  :             LstPrintf( "64 Bit   %08" I32_SPEC "X ", sym->max_offset );

	mov	edx, DWORD PTR [rbx+64]
	lea	rcx, OFFSET FLAT:$SG6305
	call	LstPrintf

; 729  : #endif
; 730  :         } else {

	jmp	SHORT $LN1@log_segmen
$LN2@log_segmen:

; 731  :             //LstPrintf( "16 Bit   %04" I32_SPEC "X     ", seg->current_loc );
; 732  :             LstPrintf( "16 Bit   %04" I32_SPEC "X     ", sym->max_offset );

	mov	edx, DWORD PTR [rbx+64]
	lea	rcx, OFFSET FLAT:$SG6307
	call	LstPrintf
$LN1@log_segmen:

; 733  :         }
; 734  :         LstPrintf( "%-7s %-8s", get_seg_align( seg, buffer ), get_seg_combine( seg ) );

	mov	cl, BYTE PTR [rdi+108]
	and	ecx, 7
	je	SHORT $LN15@log_segmen
	sub	ecx, 2
	je	SHORT $LN13@log_segmen
	sub	ecx, 3
	je	SHORT $LN14@log_segmen
	dec	ecx
	je	SHORT $LN12@log_segmen
	lea	rbx, OFFSET FLAT:$SG6127
	jmp	SHORT $LN18@log_segmen
$LN12@log_segmen:
	lea	rbx, OFFSET FLAT:$SG5886
	jmp	SHORT $LN18@log_segmen
$LN14@log_segmen:
	lea	rbx, OFFSET FLAT:$SG5884
	jmp	SHORT $LN18@log_segmen
$LN13@log_segmen:
	lea	rbx, OFFSET FLAT:$SG5885
	jmp	SHORT $LN18@log_segmen
$LN15@log_segmen:
	lea	rbx, OFFSET FLAT:$SG5883
$LN18@log_segmen:
	movzx	ecx, BYTE PTR [rdi+106]
	cmp	ecx, 3
	jg	SHORT $LN32@log_segmen
	cmp	ecx, 3
	je	SHORT $LN24@log_segmen
	test	ecx, ecx
	mov	edx, ecx
	je	SHORT $LN27@log_segmen
	dec	edx
	je	SHORT $LN26@log_segmen
	dec	edx
	jne	SHORT $LN20@log_segmen
	lea	rdx, OFFSET FLAT:$SG5854
	jmp	SHORT $LN28@log_segmen
$LN26@log_segmen:
	lea	rdx, OFFSET FLAT:$SG5853
	jmp	SHORT $LN28@log_segmen
$LN27@log_segmen:
	lea	rdx, OFFSET FLAT:$SG5852
	jmp	SHORT $LN28@log_segmen
$LN24@log_segmen:
	lea	rdx, OFFSET FLAT:$SG5856
	jmp	SHORT $LN28@log_segmen
$LN32@log_segmen:
	cmp	ecx, 4
	je	SHORT $LN23@log_segmen
	cmp	ecx, 8
	je	SHORT $LN22@log_segmen
	cmp	ecx, 255				; 000000ffH
	je	SHORT $LN21@log_segmen
$LN20@log_segmen:
	mov	r8d, 1
	lea	rdx, OFFSET FLAT:$SG6114
	shl	r8d, cl
	lea	rcx, QWORD PTR buffer$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buffer$[rsp]
	jmp	SHORT $LN28@log_segmen
$LN21@log_segmen:
	lea	rdx, OFFSET FLAT:$SG5893
	jmp	SHORT $LN28@log_segmen
$LN22@log_segmen:
	lea	rdx, OFFSET FLAT:$SG5862
	jmp	SHORT $LN28@log_segmen
$LN23@log_segmen:
	lea	rdx, OFFSET FLAT:$SG5858
$LN28@log_segmen:
	lea	rcx, OFFSET FLAT:$SG6308
	mov	r8, rbx
	call	LstPrintf

; 735  :         LstPrintf( "'%s'", seg->clsym ? seg->clsym->name : "" );

	mov	rdx, QWORD PTR [rdi+80]
	test	rdx, rdx
	je	SHORT $LN10@log_segmen
	mov	rdx, QWORD PTR [rdx+8]
	jmp	SHORT $LN11@log_segmen
$LN10@log_segmen:
	lea	rdx, OFFSET FLAT:$SG6309
$LN11@log_segmen:
	lea	rcx, OFFSET FLAT:$SG6310
	call	LstPrintf

; 736  : #if 0
; 737  :         if ( group != NULL )
; 738  :             LstPrintf( " %s", group->name );
; 739  : #endif
; 740  :         LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN33@log_segmen
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6092
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN33@log_segmen:
	mov	rdi, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+96]

; 741  :     }
; 742  : }

	add	rsp, 72					; 00000048H
	ret	0
log_segment ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$log_group DD 051201H
	DD	097412H
	DD	08340dH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$log_group DD @imagerel(log_group#)
	DD	@imagerel(log_group#+211)
	DD	@imagerel($unwind$log_group#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
grp$ = 48
segs$ = 56
log_group PROC NEAR

; 746  : {

	sub	rsp, 40					; 00000028H

; 747  :     unsigned i;
; 748  :     const char *pdots;
; 749  :     struct seg_item *curr;
; 750  : 
; 751  :     i = grp->name_size;

	movzx	eax, BYTE PTR [rcx+80]
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi

; 752  :     pdots = (( i >= DOTSMAX ) ? "" : dots + i + 1);

	cmp	eax, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	jb	SHORT $LN11@log_group
	lea	r8, OFFSET FLAT:$SG6319
	jmp	SHORT $LN12@log_group
$LN11@log_group:
	mov	r8, rax
	lea	rax, OFFSET FLAT:dots+1
	add	r8, rax
$LN12@log_group:

; 753  :     LstPrintf( "%s %s        %s", grp->name, pdots, strings[LS_GROUP] );

	mov	rdx, QWORD PTR [rcx+8]
	lea	r9, OFFSET FLAT:$SG5889
	lea	rcx, OFFSET FLAT:$SG6320
	call	LstPrintf

; 754  :     LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN13@log_group
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6092
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN13@log_group:

; 755  : 
; 756  :     /* the FLAT groups is always empty */
; 757  :     if ( grp == (struct asym *)ModuleInfo.flat_grp ) {

	cmp	rdi, QWORD PTR ModuleInfo+440
	jne	SHORT $LN8@log_group

; 758  :         for( ; segs; segs = segs->next ) {

	test	rbx, rbx
	je	SHORT $LN1@log_group
$LL7@log_group:

; 759  :             log_segment( (struct asym *)segs, grp );

	mov	rdx, rdi
	mov	rcx, rbx
	call	log_segment
	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL7@log_group
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 764  :         }
; 765  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@log_group:

; 760  :         }
; 761  :     } else
; 762  :         for( curr = ((struct dsym *)grp)->e.grpinfo->seglist; curr; curr = curr->next ) {

	mov	rax, QWORD PTR [rdi+104]
	mov	rbx, QWORD PTR [rax]
	test	rbx, rbx
	je	SHORT $LN1@log_group
	npad	1
$LL3@log_group:

; 763  :             log_segment( (struct asym *)curr->seg, grp );

	mov	rcx, QWORD PTR [rbx+8]
	mov	rdx, rdi
	call	log_segment
	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL3@log_group
$LN1@log_group:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 764  :         }
; 765  : }

	add	rsp, 40					; 00000028H
	ret	0
log_group ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$get_proc_type DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$get_proc_type DD @imagerel(get_proc_type#)
	DD	@imagerel(get_proc_type#+120)
	DD	@imagerel($unwind$get_proc_type#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
get_proc_type PROC NEAR

; 769  : {

	sub	rsp, 40					; 00000028H

; 770  :     /* if there's no segment associated with the symbol,
; 771  :      add the symbol's offset size to the distance */
; 772  :     switch( sym->mem_type ) {

	mov	edx, DWORD PTR [rcx+44]
	sub	edx, 129				; 00000081H
	je	SHORT $LN4@get_proc_t
	dec	edx
	je	SHORT $LN2@get_proc_t

; 783  :     }
; 784  :     return( " " );

	lea	rax, OFFSET FLAT:$SG6347

; 785  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@get_proc_t:

; 778  :     case MT_FAR:
; 779  :         if ( sym->segment == NULL ) {

	cmp	QWORD PTR [rcx+32], 0
	jne	SHORT $LN1@get_proc_t

; 780  :             return( strings[LS_FAR16 + GetSymOfssize( sym )] );

	call	GetSymOfssize
	lea	rcx, OFFSET FLAT:strings
	cdqe
	mov	rax, QWORD PTR [rcx+rax*8+128]

; 785  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN1@get_proc_t:

; 781  :         }
; 782  :         return( strings[LS_FAR] );

	lea	rax, OFFSET FLAT:$SG5867

; 785  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@get_proc_t:

; 773  :     case MT_NEAR:
; 774  :         if ( sym->segment == NULL ) {

	cmp	QWORD PTR [rcx+32], 0
	jne	SHORT $LN3@get_proc_t

; 775  :             return( strings[LS_NEAR16 + GetSymOfssize( sym )] );

	call	GetSymOfssize
	lea	rcx, OFFSET FLAT:strings
	cdqe
	mov	rax, QWORD PTR [rcx+rax*8+96]

; 785  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@get_proc_t:

; 776  :         }
; 777  :         return( strings[LS_NEAR] );

	lea	rax, OFFSET FLAT:$SG5863

; 785  : }

	add	rsp, 40					; 00000028H
	ret	0
get_proc_type ENDP
; Function compile flags: /Ogtpy
sym$ = 8
get_sym_seg_name PROC NEAR

; 790  :     if( sym->segment ) {

	mov	rax, QWORD PTR [rcx+32]
	test	rax, rax
	je	SHORT $LN2@get_sym_se

; 791  :         return( sym->segment->name );

	mov	rax, QWORD PTR [rax+8]

; 794  :     }
; 795  : }

	ret	0
$LN2@get_sym_se:

; 792  :     } else {
; 793  :         return( strings[LS_NOSEG] );

	lea	rax, OFFSET FLAT:$SG5890

; 794  :     }
; 795  : }

	ret	0
get_sym_seg_name ENDP
_TEXT	ENDS
EXTRN	GetResWName:NEAR
xdata	SEGMENT
$unwind$log_proc DD 010fc01H
	DD	012c4fcH
	DD	0ff481H
	DD	0166451H
	DD	010e41eH
	DD	011d41aH
	DD	0177416H
	DD	014340eH
	DD	013010aH
xdata	ENDS
pdata	SEGMENT
$pdata$log_proc DD @imagerel(log_proc#)
	DD	@imagerel(log_proc#+507)
	DD	@imagerel($unwind$log_proc#)
pdata	ENDS
xdata	SEGMENT
$chain$7$log_proc DD 020821H
	DD	0155408H
	DD	@imagerel(log_proc#)
	DD	@imagerel(log_proc#+507)
	DD	@imagerel($unwind$log_proc#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$log_proc DD @imagerel(log_proc#+507)
	DD	@imagerel(log_proc#+3920)
	DD	@imagerel($chain$7$log_proc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
l$2$ = 64
tv66 = 64
buffer$6416 = 72
sym$ = 160
log_proc PROC NEAR

; 801  : {

	mov	rax, rsp
	sub	rsp, 152				; 00000098H
	mov	QWORD PTR [rax+8], rbx

; 802  :     struct dsym *f;
; 803  :     struct dsym *l;
; 804  :     const char *p;
; 805  :     struct dsym *dir = (struct dsym *)sym;
; 806  :     int i = sym->name_size;

	movzx	ebx, BYTE PTR [rcx+80]
	mov	QWORD PTR [rax+32], rdi
	mov	QWORD PTR [rax-16], r13
	mov	QWORD PTR [rax-24], r14
	mov	r13, rcx

; 807  :     char Ofssize = GetSymOfssize( sym );

	call	GetSymOfssize

; 808  :     const char *pdots;
; 809  : 
; 810  :     pdots = (( i >= DOTSMAX ) ? "" : dots + i + 1 );

	cmp	ebx, 32					; 00000020H
	mov	r14d, eax
	mov	DWORD PTR tv66[rsp], eax
	jl	SHORT $LN44@log_proc
	lea	rdi, OFFSET FLAT:$SG6365
	jmp	SHORT $LN45@log_proc
$LN44@log_proc:
	lea	rdi, OFFSET FLAT:dots+1
	add	rdi, rbx
$LN45@log_proc:

; 811  :     if ( Ofssize )
; 812  :         p = "%s %s        P %-6s %08" I32_SPEC "X %-8s ";
; 813  :     else
; 814  :         p = "%s %s        P %-6s %04" I32_SPEC "X     %-8s ";
; 815  :     LstPrintf( p,
; 816  :               sym->name,
; 817  :               pdots,
; 818  :               get_proc_type( sym ),
; 819  :               sym->offset,
; 820  :               get_sym_seg_name( sym ));

	mov	rcx, QWORD PTR [r13+32]
	mov	QWORD PTR [rsp+176], rsi
	test	r14b, r14b
	lea	rsi, OFFSET FLAT:$SG6367
	lea	rax, OFFSET FLAT:$SG6369
	cmove	rsi, rax
	test	rcx, rcx
	je	SHORT $LN62@log_proc
	mov	rbx, QWORD PTR [rcx+8]
	jmp	SHORT $LN61@log_proc
$LN62@log_proc:
	lea	rbx, OFFSET FLAT:$SG5890
$LN61@log_proc:
	mov	edx, DWORD PTR [r13+44]
	mov	QWORD PTR [rsp+120], r15
	lea	r15, OFFSET FLAT:__ImageBase
	sub	edx, 129				; 00000081H
	je	SHORT $LN68@log_proc
	dec	edx
	je	SHORT $LN66@log_proc
	lea	r9, OFFSET FLAT:$SG6347
	jmp	SHORT $LN71@log_proc
$LN66@log_proc:
	test	rcx, rcx
	jne	SHORT $LN65@log_proc
	mov	rcx, r13
	call	GetSymOfssize
	movsxd	rcx, eax
	mov	r9, QWORD PTR strings[r15+rcx*8+128]
	jmp	SHORT $LN71@log_proc
$LN65@log_proc:
	lea	r9, OFFSET FLAT:$SG5867
	jmp	SHORT $LN71@log_proc
$LN68@log_proc:
	test	rcx, rcx
	jne	SHORT $LN67@log_proc
	mov	rcx, r13
	call	GetSymOfssize
	movsxd	rcx, eax
	mov	r9, QWORD PTR strings[r15+rcx*8+96]
	jmp	SHORT $LN71@log_proc
$LN67@log_proc:
	lea	r9, OFFSET FLAT:$SG5863
$LN71@log_proc:
	mov	eax, DWORD PTR [r13+16]
	mov	rdx, QWORD PTR [r13+8]
	mov	r8, rdi
	mov	rcx, rsi
	mov	QWORD PTR [rsp+40], rbx
	mov	QWORD PTR [rsp+144], r12
	mov	DWORD PTR [rsp+32], eax
	call	LstPrintf

; 821  : 
; 822  :     /* externals (PROTO) don't have a size. Masm always prints 0000 or 00000000 */
; 823  :     LstPrintf( "%0*" I32_SPEC "X ", Ofssize > USE16 ? 8 : 4, sym->state == SYM_INTERNAL ? sym->total_size : 0 );

	xor	r12d, r12d
	cmp	DWORD PTR [r13+40], 1
	jne	SHORT $LN46@log_proc
	mov	r8d, DWORD PTR [r13+64]
	jmp	SHORT $LN47@log_proc
$LN46@log_proc:
	mov	r8d, r12d
$LN47@log_proc:
	mov	edx, 4
	mov	eax, 8
	test	r14b, r14b
	lea	rcx, OFFSET FLAT:$SG6370
	cmovg	edx, eax
	call	LstPrintf

; 824  : 
; 825  : #ifdef DEBUG_OUT
; 826  :     if ( sym->fwdref )
; 827  :         LstPrintf( "(F) " );
; 828  : #endif
; 829  :     if( sym->ispublic ) {

	test	BYTE PTR [r13+48], 128			; 00000080H
	je	SHORT $LN39@log_proc

; 830  :         LstPrintf( "%-9s", strings[LS_PUBLIC] );

	lea	rdx, OFFSET FLAT:$SG5885
	lea	rcx, OFFSET FLAT:$SG6372
	call	LstPrintf
	jmp	SHORT $LN35@log_proc
$LN39@log_proc:

; 831  :     } else if ( sym->state == SYM_INTERNAL ) {

	cmp	DWORD PTR [r13+40], 1
	jne	SHORT $LN37@log_proc

; 832  :         LstPrintf( "%-9s", strings[LS_PRIVATE] );

	lea	rdx, OFFSET FLAT:$SG5883
	lea	rcx, OFFSET FLAT:$SG6375
	call	LstPrintf

; 833  :     } else {

	jmp	SHORT $LN35@log_proc
$LN37@log_proc:

; 834  :         LstPrintf( sym->weak ? "*%-8s " : "%-9s ", strings[LS_EXTERNAL] );

	test	BYTE PTR [r13+55], 8
	lea	rax, OFFSET FLAT:$SG6377
	lea	rcx, OFFSET FLAT:$SG6378
	lea	rdx, OFFSET FLAT:$SG5887
	cmovne	rcx, rax
	call	LstPrintf

; 835  : #if DLLIMPORT
; 836  :         if ( sym->dll )

	mov	rdx, QWORD PTR [r13+64]
	test	rdx, rdx
	je	SHORT $LN35@log_proc

; 837  :             LstPrintf( "(%.8s) ", sym->dll->name );

	lea	rcx, OFFSET FLAT:$SG6380
	add	rdx, 12
	call	LstPrintf
$LN35@log_proc:

; 838  : #endif
; 839  :     }
; 840  : 
; 841  :     LstPrintf( "%s", GetLanguage( sym ) );

	movsxd	rax, DWORD PTR [r13+84]
	cmp	eax, 7
	jg	SHORT $LN73@log_proc
	mov	rdx, QWORD PTR strings[r15+rax*8+352]
	jmp	SHORT $LN74@log_proc
$LN73@log_proc:
	lea	rdx, OFFSET FLAT:$SG6198
$LN74@log_proc:
	lea	rcx, OFFSET FLAT:$SG6381
	call	LstPrintf

; 842  :     LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN76@log_proc
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6092
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN76@log_proc:

; 843  :     /* for PROTOs, list optional altname */
; 844  :     if ( sym->state == SYM_EXTERNAL && sym->altname ) {

	cmp	DWORD PTR [r13+40], 2
	mov	QWORD PTR [rsp+168], rbp
	jne	$LN91@log_proc
	mov	rbx, QWORD PTR [r13+72]
	test	rbx, rbx
	je	$LN91@log_proc

; 845  :         struct asym *sym2 = sym->altname;
; 846  :         LstPrintf( "  ");

	lea	rcx, OFFSET FLAT:$SG6384
	call	LstPrintf

; 847  :         LstPrintf( p,
; 848  :                   sym2->name,
; 849  :                   pdots+2,
; 850  :                   get_proc_type( sym2 ),
; 851  :                   sym2->offset,
; 852  :                   get_sym_seg_name( sym2 ));

	mov	r11, QWORD PTR [rbx+32]
	test	r11, r11
	je	SHORT $LN80@log_proc
	mov	rbp, QWORD PTR [r11+8]
	jmp	SHORT $LN79@log_proc
$LN80@log_proc:
	lea	rbp, OFFSET FLAT:$SG5890
$LN79@log_proc:
	mov	ecx, DWORD PTR [rbx+44]
	sub	ecx, 129				; 00000081H
	je	SHORT $LN86@log_proc
	dec	ecx
	je	SHORT $LN84@log_proc
	lea	r9, OFFSET FLAT:$SG6347
	jmp	SHORT $LN89@log_proc
$LN84@log_proc:
	test	r11, r11
	jne	SHORT $LN83@log_proc
	mov	rcx, rbx
	call	GetSymOfssize
	movsxd	rcx, eax
	mov	r9, QWORD PTR strings[r15+rcx*8+128]
	jmp	SHORT $LN89@log_proc
$LN83@log_proc:
	lea	r9, OFFSET FLAT:$SG5867
	jmp	SHORT $LN89@log_proc
$LN86@log_proc:
	test	r11, r11
	jne	SHORT $LN85@log_proc
	mov	rcx, rbx
	call	GetSymOfssize
	movsxd	rcx, eax
	mov	r9, QWORD PTR strings[r15+rcx*8+96]
	jmp	SHORT $LN89@log_proc
$LN85@log_proc:
	lea	r9, OFFSET FLAT:$SG5863
$LN89@log_proc:
	mov	eax, DWORD PTR [rbx+16]
	mov	rdx, QWORD PTR [rbx+8]
	lea	r8, QWORD PTR [rdi+2]
	mov	rcx, rsi
	mov	QWORD PTR [rsp+40], rbp
	mov	DWORD PTR [rsp+32], eax
	call	LstPrintf

; 853  :         LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN91@log_proc
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6092
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN91@log_proc:

; 854  :     }
; 855  :     /* for PROCs, list parameters and locals */
; 856  :     if ( sym->state == SYM_INTERNAL ) {

	cmp	DWORD PTR [r13+40], 1
	jne	$LN8@log_proc

; 857  : 
; 858  :         /* print the procedure's parameters */
; 859  :         if ( sym->langtype == LANG_C ||
; 860  :             sym->langtype == LANG_SYSCALL ||
; 861  :             sym->langtype == LANG_STDCALL ||
; 862  :             sym->langtype == LANG_FASTCALL ) {

	mov	eax, DWORD PTR [r13+84]
	lea	rdx, OFFSET FLAT:dots+3
	lea	r8, OFFSET FLAT:$SG6154
	cmp	eax, 1
	je	$LN31@log_proc
	cmp	eax, 2
	je	$LN31@log_proc
	cmp	eax, 3
	je	$LN31@log_proc
	cmp	eax, 7
	je	$LN31@log_proc

; 885  :             }
; 886  :         } else {
; 887  :             for ( f = dir->e.procinfo->paralist; f; f = f->nextparam ) {

	mov	rax, QWORD PTR [r13+104]
	mov	rdi, QWORD PTR [rax+8]
	test	rdi, rdi
	je	$LN25@log_proc
	lea	rbp, OFFSET FLAT:$SG6410
	lea	r15, OFFSET FLAT:dots+3
	npad	8
$LL18@log_proc:

; 888  :                 i = f->sym.name_size;

	movzx	eax, BYTE PTR [rdi+80]

; 889  :                 pdots = (( i >= DOTSMAX-2 ) ? "" : dots + i + 1 + 2 );

	cmp	eax, 30
	jl	SHORT $LN52@log_proc
	mov	rsi, rbp
	jmp	SHORT $LN53@log_proc
$LN52@log_proc:
	lea	rsi, QWORD PTR [r15+rax]
$LN53@log_proc:

; 890  :                 LstPrintf( szFmtProcStk, f->sym.name, pdots, GetMemtypeString( &f->sym, NULL ),
; 891  : #if STACKBASESUPP
; 892  :                           GetResWName( dir->e.procinfo->basereg, NULL ),
; 893  : #else
; 894  :                           GetResWName( basereg[Ofssize], NULL ),
; 895  : #endif
; 896  :                           '+', f->sym.offset );

	mov	rax, QWORD PTR [r13+104]
	xor	edx, edx
	movzx	ecx, WORD PTR [rax+130]
	call	GetResWName
	xor	edx, edx
	mov	rcx, rdi
	mov	rbx, rax
	call	GetMemtypeString
	mov	ecx, DWORD PTR [rdi+16]
	mov	rdx, QWORD PTR [rdi+8]
	mov	DWORD PTR [rsp+48], ecx
	lea	rcx, OFFSET FLAT:szFmtProcStk
	mov	r9, rax
	mov	r8, rsi
	mov	DWORD PTR [rsp+40], 43			; 0000002bH
	mov	QWORD PTR [rsp+32], rbx
	call	LstPrintf

; 897  :                 LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN17@log_proc
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6092
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN17@log_proc:
	mov	rdi, QWORD PTR [rdi+120]
	test	rdi, rdi
	jne	$LL18@log_proc
	lea	r15, OFFSET FLAT:__ImageBase
	lea	r8, OFFSET FLAT:$SG6154
	lea	rdx, OFFSET FLAT:dots+3
	jmp	$LN25@log_proc
$LN31@log_proc:

; 863  :             int cnt;
; 864  :             /* position f2 to last param */
; 865  :             for ( cnt = 0, f = dir->e.procinfo->paralist; f; f = f->nextparam )

	mov	rax, QWORD PTR [r13+104]
	mov	rcx, QWORD PTR [rax+8]
	test	rcx, rcx
	je	$LN25@log_proc
	npad	5
$LL30@log_proc:
	mov	rcx, QWORD PTR [rcx+120]

; 866  :                 cnt++;

	inc	r12d
	test	rcx, rcx
	jne	SHORT $LL30@log_proc

; 867  :             for ( ; cnt; cnt-- ) {

	test	r12d, r12d
	je	$LN25@log_proc
	lea	rbp, OFFSET FLAT:$SG6399
	mov	r14d, 195				; 000000c3H
$LL27@log_proc:

; 868  :                 int curr;
; 869  :                 for ( curr = 1,f = dir->e.procinfo->paralist; curr < cnt;f = f->nextparam, curr++ );

	cmp	r12d, 1
	mov	rax, QWORD PTR [r13+104]
	mov	rdi, QWORD PTR [rax+8]
	jle	SHORT $LN22@log_proc
	lea	ecx, DWORD PTR [r12-1]
$LL24@log_proc:
	dec	rcx
	mov	rdi, QWORD PTR [rdi+120]
	jne	SHORT $LL24@log_proc
$LN22@log_proc:

; 870  :                 i = f->sym.name_size;

	movzx	eax, BYTE PTR [rdi+80]

; 871  :                 pdots = (( i >= DOTSMAX-2 ) ? "" : dots + i + 1 + 2 );

	cmp	eax, 30
	jl	SHORT $LN48@log_proc
	mov	rsi, rbp
	jmp	SHORT $LN49@log_proc
$LN48@log_proc:
	lea	rsi, QWORD PTR [rdx+rax]
$LN49@log_proc:

; 872  :                 /* FASTCALL: parameter may be a text macro (=register name) */
; 873  :                 if ( f->sym.state == SYM_TMACRO )

	mov	eax, DWORD PTR [rdi+40]
	cmp	eax, 10
	jne	$LN21@log_proc

; 874  :                     LstPrintf( "  %s %s        %-17s %s", f->sym.name, pdots, GetMemtypeString( &f->sym, NULL ), f->sym.string_ptr );

	mov	ecx, DWORD PTR [rdi+44]
	test	cl, cl
	js	$LN117@log_proc
	and	ecx, 63					; 0000003fH
	cmp	ecx, 63					; 0000003fH
	ja	$LN131@log_proc
	movsxd	rax, ecx
	movzx	eax, BYTE PTR $LN303@log_proc[r15+rax]
	mov	ecx, DWORD PTR $LN304@log_proc[r15+rax*4]
	add	rcx, r15
	jmp	rcx
$LN130@log_proc:
	lea	r9, OFFSET FLAT:$SG5852
	jmp	$LN118@log_proc
$LN129@log_proc:
	lea	r9, OFFSET FLAT:$SG5853
	jmp	$LN118@log_proc
$LN128@log_proc:
	lea	r9, OFFSET FLAT:$SG5854
	jmp	$LN118@log_proc
$LN127@log_proc:
	lea	r9, OFFSET FLAT:$SG5855
	jmp	$LN118@log_proc
$LN126@log_proc:
	lea	r9, OFFSET FLAT:$SG5856
	jmp	$LN118@log_proc
$LN125@log_proc:
	lea	r9, OFFSET FLAT:$SG5857
	jmp	$LN118@log_proc
$LN124@log_proc:
	lea	r9, OFFSET FLAT:$SG5859
	jmp	$LN118@log_proc
$LN123@log_proc:
	lea	r9, OFFSET FLAT:$SG5860
	jmp	$LN118@log_proc
$LN122@log_proc:
	lea	r9, OFFSET FLAT:$SG5861
	jmp	$LN118@log_proc
$LN131@log_proc:
	mov	r9, r8
	jmp	$LN118@log_proc
$LN117@log_proc:
	sub	ecx, 129				; 00000081H
	je	$LN98@log_proc
	dec	ecx
	je	SHORT $LN100@log_proc
	sub	ecx, 62					; 0000003eH
	je	SHORT $LN94@log_proc
	sub	ecx, 3
	je	SHORT $LN113@log_proc
	dec	ecx
	je	SHORT $LN96@log_proc
	lea	r9, OFFSET FLAT:$SG6192
	jmp	$LN118@log_proc
$LN96@log_proc:
	mov	rcx, QWORD PTR [rdi+88]
	mov	r9, QWORD PTR [rcx+8]
	cmp	BYTE PTR [r9], 0
	jne	$LN118@log_proc
	xor	edx, edx
	call	GetMemtypeString
	mov	r9, rax
	jmp	$LN118@log_proc
$LN113@log_proc:
	movzx	eax, BYTE PTR [rdi+52]
	cmp	al, 2
	jne	SHORT $LN112@log_proc
	lea	r9, OFFSET FLAT:$SG5863
	jmp	SHORT $LN118@log_proc
$LN112@log_proc:
	test	BYTE PTR [rdi+55], 16
	je	SHORT $LN110@log_proc
	movzx	eax, al
	mov	r9, QWORD PTR strings[r15+rax*8+128]
	jmp	SHORT $LN118@log_proc
$LN110@log_proc:
	movzx	eax, al
	mov	r9, QWORD PTR strings[r15+rax*8+96]
	jmp	SHORT $LN118@log_proc
$LN94@log_proc:
	lea	r9, OFFSET FLAT:$SG5882
	jmp	SHORT $LN118@log_proc
$LN100@log_proc:
	cmp	QWORD PTR [rdi+32], 0
	je	SHORT $LN99@log_proc
	lea	r9, OFFSET FLAT:$SG5875
	jmp	SHORT $LN118@log_proc
$LN99@log_proc:
	mov	rcx, rdi
	call	GetSymOfssize
	movsxd	rcx, eax
	mov	r9, QWORD PTR strings[r15+rcx*8+192]
	jmp	SHORT $LN118@log_proc
$LN98@log_proc:
	cmp	QWORD PTR [rdi+32], 0
	je	SHORT $LN97@log_proc
	lea	r9, OFFSET FLAT:$SG5871
	jmp	SHORT $LN118@log_proc
$LN97@log_proc:
	mov	rcx, rdi
	call	GetSymOfssize
	movsxd	rcx, eax
	mov	r9, QWORD PTR strings[r15+rcx*8+160]
$LN118@log_proc:
	mov	rax, QWORD PTR [rdi+16]
	mov	rdx, QWORD PTR [rdi+8]
	lea	rcx, OFFSET FLAT:$SG6402
	mov	r8, rsi
	mov	QWORD PTR [rsp+32], rax
	call	LstPrintf

; 875  :                 else

	jmp	$LN20@log_proc
$LN21@log_proc:

; 876  :                     LstPrintf( szFmtProcStk, f->sym.name, pdots,
; 877  :                             f->sym.is_vararg ? strings[LS_VARARG] : GetMemtypeString( &f->sym, NULL ),
; 878  : #if STACKBASESUPP
; 879  :                               GetResWName( dir->e.procinfo->basereg, NULL ),
; 880  : #else
; 881  :                               GetResWName( basereg[Ofssize], NULL ),
; 882  : #endif
; 883  :                             '+', f->sym.offset );

	movzx	edx, BYTE PTR [rdi+55]
	test	dl, 32					; 00000020H
	je	SHORT $LN50@log_proc
	lea	rbx, OFFSET FLAT:$SG5895
	jmp	$LN159@log_proc
$LN50@log_proc:
	mov	ecx, DWORD PTR [rdi+44]
	test	cl, cl
	js	$LN158@log_proc
	and	ecx, 63					; 0000003fH
	cmp	ecx, 63					; 0000003fH
	ja	$LN172@log_proc
	movsxd	rax, ecx
	movzx	eax, BYTE PTR $LN301@log_proc[r15+rax]
	mov	ecx, DWORD PTR $LN302@log_proc[r15+rax*4]
	add	rcx, r15
	jmp	rcx
$LN171@log_proc:
	lea	rbx, OFFSET FLAT:$SG5852
	jmp	$LN159@log_proc
$LN170@log_proc:
	lea	rbx, OFFSET FLAT:$SG5853
	jmp	$LN159@log_proc
$LN169@log_proc:
	lea	rbx, OFFSET FLAT:$SG5854
	jmp	$LN159@log_proc
$LN168@log_proc:
	lea	rbx, OFFSET FLAT:$SG5855
	jmp	$LN159@log_proc
$LN167@log_proc:
	lea	rbx, OFFSET FLAT:$SG5856
	jmp	$LN159@log_proc
$LN166@log_proc:
	lea	rbx, OFFSET FLAT:$SG5857
	jmp	$LN159@log_proc
$LN165@log_proc:
	lea	rbx, OFFSET FLAT:$SG5859
	jmp	$LN159@log_proc
$LN164@log_proc:
	lea	rbx, OFFSET FLAT:$SG5860
	jmp	$LN159@log_proc
$LN163@log_proc:
	lea	rbx, OFFSET FLAT:$SG5861
	jmp	$LN159@log_proc
$LN172@log_proc:
	mov	rbx, r8
	jmp	$LN159@log_proc
$LN158@log_proc:
	cmp	eax, 5
	jne	SHORT $LN157@log_proc
	cmp	BYTE PTR [rdi+53], 0
	cmovne	ecx, r14d
$LN157@log_proc:
	sub	ecx, 129				; 00000081H
	je	$LN139@log_proc
	dec	ecx
	je	SHORT $LN141@log_proc
	sub	ecx, 62					; 0000003eH
	je	SHORT $LN135@log_proc
	sub	ecx, 3
	je	SHORT $LN154@log_proc
	dec	ecx
	je	SHORT $LN137@log_proc
	lea	rbx, OFFSET FLAT:$SG6192
	jmp	$LN159@log_proc
$LN137@log_proc:
	mov	rcx, QWORD PTR [rdi+88]
	mov	rbx, QWORD PTR [rcx+8]
	cmp	BYTE PTR [rbx], 0
	jne	$LN159@log_proc
	xor	edx, edx
	call	GetMemtypeString
	mov	rbx, rax
	jmp	$LN159@log_proc
$LN154@log_proc:
	movzx	eax, BYTE PTR [rdi+52]
	cmp	al, 2
	jne	SHORT $LN153@log_proc
	lea	rbx, OFFSET FLAT:$SG5863
	jmp	SHORT $LN159@log_proc
$LN153@log_proc:
	test	dl, 16
	je	SHORT $LN151@log_proc
	movzx	eax, al
	mov	rbx, QWORD PTR strings[r15+rax*8+128]
	jmp	SHORT $LN159@log_proc
$LN151@log_proc:
	movzx	eax, al
	mov	rbx, QWORD PTR strings[r15+rax*8+96]
	jmp	SHORT $LN159@log_proc
$LN135@log_proc:
	lea	rbx, OFFSET FLAT:$SG5882
	jmp	SHORT $LN159@log_proc
$LN141@log_proc:
	cmp	QWORD PTR [rdi+32], 0
	je	SHORT $LN140@log_proc
	lea	rbx, OFFSET FLAT:$SG5875
	jmp	SHORT $LN159@log_proc
$LN140@log_proc:
	mov	rcx, rdi
	call	GetSymOfssize
	movsxd	rcx, eax
	mov	rbx, QWORD PTR strings[r15+rcx*8+192]
	jmp	SHORT $LN159@log_proc
$LN139@log_proc:
	cmp	QWORD PTR [rdi+32], 0
	je	SHORT $LN138@log_proc
	lea	rbx, OFFSET FLAT:$SG5871
	jmp	SHORT $LN159@log_proc
$LN138@log_proc:
	mov	rcx, rdi
	call	GetSymOfssize
	movsxd	rcx, eax
	mov	rbx, QWORD PTR strings[r15+rcx*8+160]
$LN159@log_proc:
	mov	rax, QWORD PTR [r13+104]
	xor	edx, edx
	movzx	ecx, WORD PTR [rax+130]
	call	GetResWName
	mov	ecx, DWORD PTR [rdi+16]
	mov	rdx, QWORD PTR [rdi+8]
	mov	DWORD PTR [rsp+48], ecx
	lea	rcx, OFFSET FLAT:szFmtProcStk
	mov	r9, rbx
	mov	r8, rsi
	mov	DWORD PTR [rsp+40], 43			; 0000002bH
	mov	QWORD PTR [rsp+32], rax
	call	LstPrintf
$LN20@log_proc:

; 884  :                 LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN26@log_proc
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6092
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN26@log_proc:
	dec	r12d
	lea	r8, OFFSET FLAT:$SG6154
	lea	rdx, OFFSET FLAT:dots+3
	jne	$LL27@log_proc
	mov	r14d, DWORD PTR tv66[rsp]
	lea	r8, OFFSET FLAT:$SG6154
	lea	rdx, OFFSET FLAT:dots+3
$LN25@log_proc:

; 898  :             }
; 899  :         }
; 900  : 
; 901  :         /* print the procedure's locals */
; 902  :         for ( l = dir->e.procinfo->locallist; l; l = l->nextlocal ) {

	mov	rax, QWORD PTR [r13+104]
	mov	rdi, QWORD PTR [rax+16]
	test	rdi, rdi
	je	$LN13@log_proc
	lea	r12, OFFSET FLAT:$SG6417
	mov	r14d, 195				; 000000c3H
	npad	5
$LL15@log_proc:

; 903  :             char buffer[32];
; 904  :             i = l->sym.name_size;

	movzx	eax, BYTE PTR [rdi+80]

; 905  :             pdots = (( i >= DOTSMAX-2 ) ? "" : dots + i + 1 + 2);

	cmp	eax, 30
	jl	SHORT $LN54@log_proc
	mov	rbp, r12
	jmp	SHORT $LN55@log_proc
$LN54@log_proc:
	lea	rbp, QWORD PTR [rdx+rax]
$LN55@log_proc:

; 906  :             if ( l->sym.isarray )

	test	BYTE PTR [rdi+49], 2
	je	$LN12@log_proc

; 907  :                 sprintf( buffer, "%s[%" I32_SPEC "u]", GetMemtypeString(&l->sym, NULL), l->sym.total_length );

	mov	ecx, DWORD PTR [rdi+44]
	test	cl, cl
	js	$LN205@log_proc
	and	ecx, 63					; 0000003fH
	cmp	ecx, 63					; 0000003fH
	ja	$LN219@log_proc
	movsxd	rax, ecx
	movzx	eax, BYTE PTR $LN299@log_proc[r15+rax]
	mov	ecx, DWORD PTR $LN300@log_proc[r15+rax*4]
	add	rcx, r15
	jmp	rcx
$LN218@log_proc:
	lea	rax, OFFSET FLAT:$SG5852
	jmp	$LN206@log_proc
$LN217@log_proc:
	lea	rax, OFFSET FLAT:$SG5853
	jmp	$LN206@log_proc
$LN216@log_proc:
	lea	rax, OFFSET FLAT:$SG5854
	jmp	$LN206@log_proc
$LN215@log_proc:
	lea	rax, OFFSET FLAT:$SG5855
	jmp	$LN206@log_proc
$LN214@log_proc:
	lea	rax, OFFSET FLAT:$SG5856
	jmp	$LN206@log_proc
$LN213@log_proc:
	lea	rax, OFFSET FLAT:$SG5857
	jmp	$LN206@log_proc
$LN212@log_proc:
	lea	rax, OFFSET FLAT:$SG5859
	jmp	$LN206@log_proc
$LN211@log_proc:
	lea	rax, OFFSET FLAT:$SG5860
	jmp	$LN206@log_proc
$LN210@log_proc:
	lea	rax, OFFSET FLAT:$SG5861
	jmp	$LN206@log_proc
$LN219@log_proc:
	mov	rax, r8
	jmp	$LN206@log_proc
$LN205@log_proc:
	cmp	DWORD PTR [rdi+40], 5
	jne	SHORT $LN204@log_proc
	cmp	BYTE PTR [rdi+53], 0
	cmovne	ecx, r14d
$LN204@log_proc:
	sub	ecx, 129				; 00000081H
	je	$LN186@log_proc
	dec	ecx
	je	SHORT $LN188@log_proc
	sub	ecx, 62					; 0000003eH
	je	SHORT $LN182@log_proc
	sub	ecx, 3
	je	SHORT $LN201@log_proc
	dec	ecx
	je	SHORT $LN184@log_proc
	lea	rax, OFFSET FLAT:$SG6192
	jmp	$LN206@log_proc
$LN184@log_proc:
	mov	rcx, QWORD PTR [rdi+88]
	mov	rax, QWORD PTR [rcx+8]
	cmp	BYTE PTR [rax], 0
	jne	$LN206@log_proc
	xor	edx, edx
	call	GetMemtypeString
	jmp	$LN206@log_proc
$LN201@log_proc:
	movzx	eax, BYTE PTR [rdi+52]
	cmp	al, 2
	jne	SHORT $LN200@log_proc
	lea	rax, OFFSET FLAT:$SG5863
	jmp	SHORT $LN206@log_proc
$LN200@log_proc:
	test	BYTE PTR [rdi+55], 16
	je	SHORT $LN198@log_proc
	movzx	eax, al
	mov	rax, QWORD PTR strings[r15+rax*8+128]
	jmp	SHORT $LN206@log_proc
$LN198@log_proc:
	movzx	eax, al
	mov	rax, QWORD PTR strings[r15+rax*8+96]
	jmp	SHORT $LN206@log_proc
$LN182@log_proc:
	lea	rax, OFFSET FLAT:$SG5882
	jmp	SHORT $LN206@log_proc
$LN188@log_proc:
	cmp	QWORD PTR [rdi+32], 0
	je	SHORT $LN187@log_proc
	lea	rax, OFFSET FLAT:$SG5875
	jmp	SHORT $LN206@log_proc
$LN187@log_proc:
	mov	rcx, rdi
	call	GetSymOfssize
	movsxd	rcx, eax
	mov	rax, QWORD PTR strings[r15+rcx*8+192]
	jmp	SHORT $LN206@log_proc
$LN186@log_proc:
	cmp	QWORD PTR [rdi+32], 0
	je	SHORT $LN185@log_proc
	lea	rax, OFFSET FLAT:$SG5871
	jmp	SHORT $LN206@log_proc
$LN185@log_proc:
	mov	rcx, rdi
	call	GetSymOfssize
	movsxd	rcx, eax
	mov	rax, QWORD PTR strings[r15+rcx*8+160]
$LN206@log_proc:
	mov	r9d, DWORD PTR [rdi+72]
	lea	rdx, OFFSET FLAT:$SG6420
	lea	rcx, QWORD PTR buffer$6416[rsp]
	mov	r8, rax
	call	sprintf

; 908  :             else

	jmp	$LN11@log_proc
$LN12@log_proc:

; 909  :                 strcpy( buffer, GetMemtypeString( &l->sym, NULL ) );

	mov	ecx, DWORD PTR [rdi+44]
	test	cl, cl
	js	$LN246@log_proc
	and	ecx, 63					; 0000003fH
	cmp	ecx, 63					; 0000003fH
	ja	$LN260@log_proc
	movsxd	rax, ecx
	movzx	eax, BYTE PTR $LN297@log_proc[r15+rax]
	mov	ecx, DWORD PTR $LN298@log_proc[r15+rax*4]
	add	rcx, r15
	jmp	rcx
$LN259@log_proc:
	lea	rcx, OFFSET FLAT:$SG5852
	jmp	$LN247@log_proc
$LN258@log_proc:
	lea	rcx, OFFSET FLAT:$SG5853
	jmp	$LN247@log_proc
$LN257@log_proc:
	lea	rcx, OFFSET FLAT:$SG5854
	jmp	$LN247@log_proc
$LN256@log_proc:
	lea	rcx, OFFSET FLAT:$SG5855
	jmp	$LN247@log_proc
$LN255@log_proc:
	lea	rcx, OFFSET FLAT:$SG5856
	jmp	$LN247@log_proc
$LN254@log_proc:
	lea	rcx, OFFSET FLAT:$SG5857
	jmp	$LN247@log_proc
$LN253@log_proc:
	lea	rcx, OFFSET FLAT:$SG5859
	jmp	$LN247@log_proc
$LN252@log_proc:
	lea	rcx, OFFSET FLAT:$SG5860
	jmp	$LN247@log_proc
$LN251@log_proc:
	lea	rcx, OFFSET FLAT:$SG5861
	jmp	$LN247@log_proc
$LN260@log_proc:
	mov	rcx, r8
	jmp	$LN247@log_proc
$LN246@log_proc:
	cmp	DWORD PTR [rdi+40], 5
	jne	SHORT $LN245@log_proc
	cmp	BYTE PTR [rdi+53], 0
	cmovne	ecx, r14d
$LN245@log_proc:
	sub	ecx, 129				; 00000081H
	je	$LN227@log_proc
	dec	ecx
	je	SHORT $LN229@log_proc
	sub	ecx, 62					; 0000003eH
	je	SHORT $LN223@log_proc
	sub	ecx, 3
	je	SHORT $LN242@log_proc
	dec	ecx
	je	SHORT $LN225@log_proc
	lea	rcx, OFFSET FLAT:$SG6192
	jmp	$LN247@log_proc
$LN225@log_proc:
	mov	rax, QWORD PTR [rdi+88]
	mov	rcx, QWORD PTR [rax+8]
	cmp	BYTE PTR [rcx], 0
	jne	$LN247@log_proc
	xor	edx, edx
	mov	rcx, rax
	call	GetMemtypeString
	mov	rcx, rax
	jmp	$LN247@log_proc
$LN242@log_proc:
	movzx	eax, BYTE PTR [rdi+52]
	cmp	al, 2
	jne	SHORT $LN241@log_proc
	lea	rcx, OFFSET FLAT:$SG5863
	jmp	SHORT $LN247@log_proc
$LN241@log_proc:
	test	BYTE PTR [rdi+55], 16
	je	SHORT $LN239@log_proc
	movzx	eax, al
	mov	rcx, QWORD PTR strings[r15+rax*8+128]
	jmp	SHORT $LN247@log_proc
$LN239@log_proc:
	movzx	eax, al
	mov	rcx, QWORD PTR strings[r15+rax*8+96]
	jmp	SHORT $LN247@log_proc
$LN223@log_proc:
	lea	rcx, OFFSET FLAT:$SG5882
	jmp	SHORT $LN247@log_proc
$LN229@log_proc:
	cmp	QWORD PTR [rdi+32], 0
	je	SHORT $LN228@log_proc
	lea	rcx, OFFSET FLAT:$SG5875
	jmp	SHORT $LN247@log_proc
$LN228@log_proc:
	mov	rcx, rdi
	call	GetSymOfssize
	movsxd	rcx, eax
	mov	rcx, QWORD PTR strings[r15+rcx*8+192]
	jmp	SHORT $LN247@log_proc
$LN227@log_proc:
	cmp	QWORD PTR [rdi+32], 0
	je	SHORT $LN226@log_proc
	lea	rcx, OFFSET FLAT:$SG5871
	jmp	SHORT $LN247@log_proc
$LN226@log_proc:
	mov	rcx, rdi
	call	GetSymOfssize
	movsxd	rcx, eax
	mov	rcx, QWORD PTR strings[r15+rcx*8+160]
$LN247@log_proc:
	lea	rdx, QWORD PTR buffer$6416[rsp]
	npad	6
$LL56@log_proc:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL56@log_proc
$LN11@log_proc:

; 910  :             LstPrintf( szFmtProcStk, l->sym.name, pdots, buffer,
; 911  : #if STACKBASESUPP
; 912  :                       GetResWName( dir->e.procinfo->basereg, NULL ),
; 913  :                       l->sym.offset >= 0 ? '+' : '-', l->sym.offset >= 0 ? l->sym.offset : - l->sym.offset );

	mov	eax, DWORD PTR [rdi+16]
	test	eax, eax
	js	SHORT $LN57@log_proc
	mov	esi, eax
	jmp	SHORT $LN58@log_proc
$LN57@log_proc:
	mov	esi, eax
	neg	esi
$LN58@log_proc:
	test	eax, eax
	mov	eax, 43					; 0000002bH
	mov	ebx, 45					; 0000002dH
	cmovns	ebx, eax
	mov	rax, QWORD PTR [r13+104]
	xor	edx, edx
	movzx	ecx, WORD PTR [rax+130]
	call	GetResWName
	mov	rdx, QWORD PTR [rdi+8]
	mov	DWORD PTR [rsp+48], esi
	lea	r9, QWORD PTR buffer$6416[rsp]
	lea	rcx, OFFSET FLAT:szFmtProcStk
	mov	r8, rbp
	mov	DWORD PTR [rsp+40], ebx
	mov	QWORD PTR [rsp+32], rax
	call	LstPrintf

; 914  : #else
; 915  :                       GetResWName( basereg[Ofssize], NULL ),
; 916  :                       '-', - l->sym.offset );
; 917  : #endif
; 918  :             LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN14@log_proc
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6092
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN14@log_proc:
	mov	rdi, QWORD PTR [rdi+120]
	lea	r8, OFFSET FLAT:$SG6154
	lea	rdx, OFFSET FLAT:dots+3
	test	rdi, rdi
	jne	$LL15@log_proc
	mov	r14d, DWORD PTR tv66[rsp]
$LN13@log_proc:

; 919  :         }
; 920  : 
; 921  :         for ( l = dir->e.procinfo->labellist; l ; l = l->e.nextll ) {

	mov	rax, QWORD PTR [r13+104]
	mov	r12, QWORD PTR [rax+24]
	test	r12, r12
	mov	QWORD PTR l$2$[rsp], r12
	je	$LN8@log_proc
	lea	r13, OFFSET FLAT:$SG6434
	lea	r15, OFFSET FLAT:$SG6438
$LL10@log_proc:

; 922  :             struct dsym *l2;
; 923  :             for ( l2 = l; l2; l2 = (struct dsym *)l2->sym.nextitem ) {

	test	r12, r12
	mov	rbx, r12
	je	$LN9@log_proc
	lea	r12, OFFSET FLAT:__ImageBase
$LL7@log_proc:

; 924  :                 /* filter params and locals! */
; 925  :                 if ( l2->sym.state == SYM_STACK || l2->sym.state == SYM_TMACRO )

	mov	eax, DWORD PTR [rbx+40]
	cmp	eax, 5
	je	$LN6@log_proc
	cmp	eax, 10
	je	$LN6@log_proc

; 926  :                     continue;
; 927  :                 i = l2->sym.name_size;

	movzx	eax, BYTE PTR [rbx+80]

; 928  :                 pdots = (( i >= DOTSMAX-2 ) ? "" : dots + i + 1 + 2);

	cmp	eax, 30
	jl	SHORT $LN59@log_proc
	mov	rdi, r13
	jmp	SHORT $LN60@log_proc
$LN59@log_proc:
	mov	rdi, rax
	lea	rax, OFFSET FLAT:dots+3
	add	rdi, rax
$LN60@log_proc:

; 929  :                 if ( Ofssize )
; 930  :                     p = "  %s %s        L %-6s %08" I32_SPEC "X %s";
; 931  :                 else
; 932  :                     p = "  %s %s        L %-6s %04" I32_SPEC "X     %s";
; 933  :                 LstPrintf( p,
; 934  :                           l2->sym.name,
; 935  :                           pdots,
; 936  :                           get_proc_type( &l2->sym ),
; 937  :                           l2->sym.offset,
; 938  :                           get_sym_seg_name( &l2->sym ));

	mov	rdx, QWORD PTR [rbx+32]
	test	r14b, r14b
	lea	rsi, OFFSET FLAT:$SG6436
	cmove	rsi, r15
	test	rdx, rdx
	je	SHORT $LN268@log_proc
	mov	rbp, QWORD PTR [rdx+8]
	jmp	SHORT $LN267@log_proc
$LN268@log_proc:
	lea	rbp, OFFSET FLAT:$SG5890
$LN267@log_proc:
	mov	ecx, DWORD PTR [rbx+44]
	sub	ecx, 129				; 00000081H
	je	SHORT $LN274@log_proc
	dec	ecx
	je	SHORT $LN272@log_proc
	lea	r9, OFFSET FLAT:$SG6347
	jmp	SHORT $LN277@log_proc
$LN272@log_proc:
	test	rdx, rdx
	jne	SHORT $LN271@log_proc
	mov	rcx, rbx
	call	GetSymOfssize
	movsxd	rcx, eax
	mov	r9, QWORD PTR strings[r12+rcx*8+128]
	jmp	SHORT $LN277@log_proc
$LN271@log_proc:
	lea	r9, OFFSET FLAT:$SG5867
	jmp	SHORT $LN277@log_proc
$LN274@log_proc:
	test	rdx, rdx
	jne	SHORT $LN273@log_proc
	mov	rcx, rbx
	call	GetSymOfssize
	movsxd	rcx, eax
	mov	r9, QWORD PTR strings[r12+rcx*8+96]
	jmp	SHORT $LN277@log_proc
$LN273@log_proc:
	lea	r9, OFFSET FLAT:$SG5863
$LN277@log_proc:
	mov	eax, DWORD PTR [rbx+16]
	mov	rdx, QWORD PTR [rbx+8]
	mov	r8, rdi
	mov	rcx, rsi
	mov	QWORD PTR [rsp+40], rbp
	mov	DWORD PTR [rsp+32], eax
	call	LstPrintf

; 939  : #ifdef DEBUG_OUT
; 940  :                 if ( l2->sym.fwdref )
; 941  :                     LstPrintf( " (F)" );
; 942  : #endif
; 943  :                 LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN6@log_proc
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6092
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN6@log_proc:
	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	$LL7@log_proc
	mov	r12, QWORD PTR l$2$[rsp]
$LN9@log_proc:

; 919  :         }
; 920  : 
; 921  :         for ( l = dir->e.procinfo->labellist; l ; l = l->e.nextll ) {

	mov	r12, QWORD PTR [r12+104]
	test	r12, r12
	mov	QWORD PTR l$2$[rsp], r12
	jne	$LL10@log_proc
$LN8@log_proc:
	mov	r15, QWORD PTR [rsp+120]
	mov	r14, QWORD PTR [rsp+128]
	mov	r13, QWORD PTR [rsp+136]
	mov	r12, QWORD PTR [rsp+144]
	mov	rdi, QWORD PTR [rsp+184]
	mov	rsi, QWORD PTR [rsp+176]
	mov	rbp, QWORD PTR [rsp+168]
	mov	rbx, QWORD PTR [rsp+160]

; 944  :             }
; 945  :         }
; 946  :     }
; 947  : }

	add	rsp, 152				; 00000098H
	ret	0
$LN304@log_proc:
	DD	$LN130@log_proc
	DD	$LN129@log_proc
	DD	$LN128@log_proc
	DD	$LN127@log_proc
	DD	$LN126@log_proc
	DD	$LN125@log_proc
	DD	$LN124@log_proc
	DD	$LN123@log_proc
	DD	$LN122@log_proc
	DD	$LN131@log_proc
$LN303@log_proc:
	DB	0
	DB	1
	DB	9
	DB	2
	DB	9
	DB	3
	DB	9
	DB	4
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	7
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	8
$LN302@log_proc:
	DD	$LN171@log_proc
	DD	$LN170@log_proc
	DD	$LN169@log_proc
	DD	$LN168@log_proc
	DD	$LN167@log_proc
	DD	$LN166@log_proc
	DD	$LN165@log_proc
	DD	$LN164@log_proc
	DD	$LN163@log_proc
	DD	$LN172@log_proc
$LN301@log_proc:
	DB	0
	DB	1
	DB	9
	DB	2
	DB	9
	DB	3
	DB	9
	DB	4
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	7
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	8
$LN300@log_proc:
	DD	$LN218@log_proc
	DD	$LN217@log_proc
	DD	$LN216@log_proc
	DD	$LN215@log_proc
	DD	$LN214@log_proc
	DD	$LN213@log_proc
	DD	$LN212@log_proc
	DD	$LN211@log_proc
	DD	$LN210@log_proc
	DD	$LN219@log_proc
$LN299@log_proc:
	DB	0
	DB	1
	DB	9
	DB	2
	DB	9
	DB	3
	DB	9
	DB	4
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	7
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	8
$LN298@log_proc:
	DD	$LN259@log_proc
	DD	$LN258@log_proc
	DD	$LN257@log_proc
	DD	$LN256@log_proc
	DD	$LN255@log_proc
	DD	$LN254@log_proc
	DD	$LN253@log_proc
	DD	$LN252@log_proc
	DD	$LN251@log_proc
	DD	$LN260@log_proc
$LN297@log_proc:
	DB	0
	DB	1
	DB	9
	DB	2
	DB	9
	DB	3
	DB	9
	DB	4
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	7
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	8
log_proc ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$log_symbol DD 020601H
	DD	030025206H
xdata	ENDS
pdata	SEGMENT
$pdata$log_symbol DD @imagerel(log_symbol#)
	DD	@imagerel(log_symbol#+624)
	DD	@imagerel($unwind$log_symbol#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 64
log_symbol PROC NEAR

; 953  : {

	push	rbx
	sub	rsp, 48					; 00000030H

; 954  :     int i = sym->name_size;

	movzx	eax, BYTE PTR [rcx+80]
	mov	rbx, rcx

; 955  :     const char *pdots;
; 956  :     //char buffer[MAX_LINE_LEN];
; 957  : 
; 958  :     pdots = ((i >= DOTSMAX) ? "" : dots + i + 1 );

	cmp	eax, 32					; 00000020H
	jl	SHORT $LN26@log_symbol
	lea	r8, OFFSET FLAT:$SG6445
	jmp	SHORT $LN27@log_symbol
$LN26@log_symbol:
	mov	r8, rax
	lea	rax, OFFSET FLAT:dots+1
	add	r8, rax
$LN27@log_symbol:

; 959  : 
; 960  :     switch ( sym->state ) {

	mov	eax, DWORD PTR [rcx+40]
	test	eax, eax
	js	$LN35@log_symbol
	cmp	eax, 2
	jle	SHORT $LN21@log_symbol
	cmp	eax, 8
	je	SHORT $LN1@log_symbol
	cmp	eax, 10
	jne	$LN35@log_symbol

; 1014 :         break;
; 1015 :     case SYM_TMACRO:
; 1016 :         //GetLiteralValue( buffer, sym->string_ptr );
; 1017 :         //strcpy( buffer, sym->string_ptr );
; 1018 :         LstPrintf( "%s %s        %s   %s", sym->name, pdots, strings[LS_TEXT], sym->string_ptr );

	mov	rax, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR [rcx+8]
	lea	r9, OFFSET FLAT:$SG5891
	lea	rcx, OFFSET FLAT:$SG6489
	mov	QWORD PTR [rsp+32], rax
	call	LstPrintf

; 1019 :         LstNL();
; 1020 :         break;

	jmp	$LN45@log_symbol
$LN1@log_symbol:

; 1021 :     case SYM_ALIAS:
; 1022 :         LstPrintf( "%s %s        %s  %s", sym->name, pdots, strings[LS_ALIAS], sym->substitute->name );

	mov	rax, QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR [rbx+8]
	lea	r9, OFFSET FLAT:$SG5892
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, OFFSET FLAT:$SG6491
	call	LstPrintf

; 1023 :         LstNL();
; 1024 :         break;

	jmp	$LN45@log_symbol
$LN21@log_symbol:

; 961  :     case SYM_UNDEFINED:
; 962  :     case SYM_INTERNAL:
; 963  :     case SYM_EXTERNAL:
; 964  :         LstPrintf( "%s %s        ", sym->name, pdots );

	mov	rdx, QWORD PTR [rcx+8]
	lea	rcx, OFFSET FLAT:$SG6451
	call	LstPrintf

; 965  : 
; 966  :         if ( sym->isarray ) {

	test	BYTE PTR [rbx+49], 2
	je	SHORT $LN20@log_symbol

; 967  :             i = sprintf( StringBufferEnd, "%s[%u]", GetMemtypeString( sym, NULL ), sym->total_length );

	xor	edx, edx
	mov	rcx, rbx
	call	GetMemtypeString
	mov	r9d, DWORD PTR [rbx+72]
	mov	rcx, QWORD PTR ModuleInfo+488
	lea	rdx, OFFSET FLAT:$SG6454
	mov	r8, rax
	call	sprintf

; 968  :             LstPrintf( "%-10s ", StringBufferEnd );

	mov	rdx, QWORD PTR ModuleInfo+488
	lea	rcx, OFFSET FLAT:$SG6455
	jmp	SHORT $LN46@log_symbol
$LN20@log_symbol:

; 969  :         } else if ( sym->state == SYM_EXTERNAL && sym->iscomm == TRUE ) {

	cmp	DWORD PTR [rbx+40], 2
	jne	SHORT $LN18@log_symbol
	test	BYTE PTR [rbx+55], 4
	je	SHORT $LN18@log_symbol

; 970  :             LstPrintf( "%-10s ", strings[LS_COMM] );

	lea	rdx, OFFSET FLAT:$SG5894
	lea	rcx, OFFSET FLAT:$SG6458

; 971  :         } else

	jmp	SHORT $LN46@log_symbol
$LN18@log_symbol:

; 972  :             LstPrintf( "%-10s ", GetMemtypeString( sym, NULL ) );

	xor	edx, edx
	mov	rcx, rbx
	call	GetMemtypeString
	lea	rcx, OFFSET FLAT:$SG6461
	mov	rdx, rax
$LN46@log_symbol:
	call	LstPrintf

; 973  : 
; 974  :         /* print value */
; 975  :         /* v2.07: MT_ABS is obsolete */
; 976  :         //if ( sym->mem_type == MT_ABS )
; 977  :         if ( sym->state == SYM_EXTERNAL && sym->iscomm == TRUE )

	cmp	DWORD PTR [rbx+40], 2
	jne	SHORT $LN16@log_symbol
	test	BYTE PTR [rbx+55], 4
	je	SHORT $LN16@log_symbol

; 978  :             LstPrintf( " %8" I32_SPEC "Xh ", sym->total_size / sym->total_length );

	mov	eax, DWORD PTR [rbx+64]
	xor	edx, edx
	lea	rcx, OFFSET FLAT:$SG6463
	div	DWORD PTR [rbx+72]
	mov	edx, eax
	jmp	SHORT $LN47@log_symbol
$LN16@log_symbol:

; 979  :         else if ( sym->mem_type == MT_EMPTY ) { /* also check segment? might be != NULL for equates (var = offset x) */

	cmp	DWORD PTR [rbx+44], 192			; 000000c0H
	jne	SHORT $LN14@log_symbol

; 980  :             if ( sym->value3264 != 0 && sym->value3264 != -1 )

	mov	eax, DWORD PTR [rbx+64]
	test	eax, eax
	je	SHORT $LN48@log_symbol
	cmp	eax, -1
	je	SHORT $LN13@log_symbol

; 981  :                 LstPrintf( " %" I64_SPEC "Xh ", sym->uvalue, sym->value3264 );

	mov	edx, DWORD PTR [rbx+16]
	lea	rcx, OFFSET FLAT:$SG6467
	mov	r8d, eax
	call	LstPrintf
	jmp	SHORT $LN9@log_symbol
$LN13@log_symbol:

; 982  :             else if ( sym->value3264 < 0 )

	test	eax, eax
$LN48@log_symbol:

; 983  :                 LstPrintf( "-%08" I32_SPEC "Xh ", 0 - sym->uvalue );

	mov	edx, DWORD PTR [rbx+16]

; 982  :             else if ( sym->value3264 < 0 )

	jns	SHORT $LN11@log_symbol

; 983  :                 LstPrintf( "-%08" I32_SPEC "Xh ", 0 - sym->uvalue );

	neg	edx
	lea	rcx, OFFSET FLAT:$SG6470

; 984  :             else

	jmp	SHORT $LN47@log_symbol
$LN11@log_symbol:

; 985  :                 LstPrintf( " %8" I32_SPEC "Xh ", sym->offset );

	lea	rcx, OFFSET FLAT:$SG6472

; 986  :         } else

	jmp	SHORT $LN47@log_symbol
$LN14@log_symbol:

; 987  :             LstPrintf( " %8" I32_SPEC "Xh ", sym->offset );

	mov	edx, DWORD PTR [rbx+16]
	lea	rcx, OFFSET FLAT:$SG6474
$LN47@log_symbol:
	call	LstPrintf
$LN9@log_symbol:

; 988  : 
; 989  :         /* print segment */
; 990  :         //if ( sym->mem_type == MT_ABS || sym->state == SYM_UNDEFINED )
; 991  :         //    ;
; 992  :         //else
; 993  :         if ( sym->segment )

	mov	rdx, QWORD PTR [rbx+32]
	test	rdx, rdx
	je	SHORT $LN8@log_symbol

; 994  :             LstPrintf( "%s ", get_sym_seg_name( sym ) );

	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, OFFSET FLAT:$SG6476
	call	LstPrintf
$LN8@log_symbol:

; 995  : 
; 996  : #ifdef DEBUG_OUT
; 997  :         if ( sym->fwdref )
; 998  :             LstPrintf( "(F) " );
; 999  : #endif
; 1000 :         if ( sym->state == SYM_EXTERNAL && sym->iscomm == TRUE )

	cmp	DWORD PTR [rbx+40], 2
	jne	SHORT $LN7@log_symbol
	test	BYTE PTR [rbx+55], 4
	je	SHORT $LN7@log_symbol

; 1001 :             LstPrintf( "%s=%u ", szCount, sym->total_length );

	mov	r8d, DWORD PTR [rbx+72]
	lea	rdx, OFFSET FLAT:szCount
	lea	rcx, OFFSET FLAT:$SG6478
	call	LstPrintf
$LN7@log_symbol:

; 1002 : 
; 1003 :         if( sym->ispublic )

	test	BYTE PTR [rbx+48], 128			; 00000080H
	je	SHORT $LN6@log_symbol

; 1004 :             LstPrintf( "%s ", strings[LS_PUBLIC] );

	lea	rdx, OFFSET FLAT:$SG5885
	lea	rcx, OFFSET FLAT:$SG6480
	call	LstPrintf
$LN6@log_symbol:

; 1005 : 
; 1006 :         if ( sym->state == SYM_EXTERNAL ) {

	mov	eax, DWORD PTR [rbx+40]
	cmp	eax, 2
	jne	SHORT $LN5@log_symbol

; 1007 :             LstPrintf( sym->weak ? "*%s " : "%s ", strings[LS_EXTERNAL] );

	test	BYTE PTR [rbx+55], 8
	lea	rax, OFFSET FLAT:$SG6482
	lea	rcx, OFFSET FLAT:$SG6483
	cmovne	rcx, rax
	lea	rdx, OFFSET FLAT:$SG5887
	jmp	SHORT $LN49@log_symbol
$LN5@log_symbol:

; 1008 :         } else if ( sym->state == SYM_UNDEFINED ) {

	test	eax, eax
	jne	SHORT $LN3@log_symbol

; 1009 :             LstPrintf( "%s ", strings[LS_UNDEFINED] );

	lea	rdx, OFFSET FLAT:$SG5888
	lea	rcx, OFFSET FLAT:$SG6486
$LN49@log_symbol:
	call	LstPrintf
$LN3@log_symbol:

; 1010 :         }
; 1011 : 
; 1012 :         LstPrintf( "%s", GetLanguage( sym ) );

	movsxd	rax, DWORD PTR [rbx+84]
	cmp	eax, 7
	jg	SHORT $LN32@log_symbol
	lea	rdx, OFFSET FLAT:strings+352
	mov	rdx, QWORD PTR [rdx+rax*8]
	jmp	SHORT $LN33@log_symbol
$LN32@log_symbol:
	lea	rdx, OFFSET FLAT:$SG6198
$LN33@log_symbol:
	lea	rcx, OFFSET FLAT:$SG6487
	call	LstPrintf
$LN45@log_symbol:

; 1013 :         LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN35@log_symbol
	mov	r8d, 2
	lea	rcx, OFFSET FLAT:$SG6092
	lea	edx, QWORD PTR [r8-1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN35@log_symbol:

; 1025 :     }
; 1026 : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
log_symbol ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$LstCaption DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$LstCaption DD @imagerel(LstCaption#)
	DD	@imagerel(LstCaption#+6)
	DD	@imagerel($unwind$LstCaption#)
pdata	ENDS
xdata	SEGMENT
$chain$1$LstCaption DD 040a21H
	DD	09740aH
	DD	083405H
	DD	@imagerel(LstCaption#)
	DD	@imagerel(LstCaption#+6)
	DD	@imagerel($unwind$LstCaption#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$LstCaption DD @imagerel(LstCaption#+6)
	DD	@imagerel(LstCaption#+106)
	DD	@imagerel($chain$1$LstCaption#)
pdata	ENDS
xdata	SEGMENT
$chain$2$LstCaption DD 021H
	DD	@imagerel(LstCaption#)
	DD	@imagerel(LstCaption#+6)
	DD	@imagerel($unwind$LstCaption#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$LstCaption DD @imagerel(LstCaption#+106)
	DD	@imagerel(LstCaption#+179)
	DD	@imagerel($chain$2$LstCaption#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
caption$ = 48
prefNL$ = 56
LstCaption PROC NEAR

; 1030 : {

	sub	rsp, 40					; 00000028H

; 1031 :     for (; prefNL; prefNL--)

	test	edx, edx
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx
	mov	ebx, edx
	je	SHORT $LN1@LstCaption
	mov	r9, QWORD PTR ModuleInfo+112
	npad	2
$LL3@LstCaption:

; 1032 :         LstNL();

	test	r9, r9
	je	SHORT $LN2@LstCaption
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6092
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
	mov	r9, QWORD PTR ModuleInfo+112
$LN2@LstCaption:

; 1031 :     for (; prefNL; prefNL--)

	dec	ebx
	jne	SHORT $LL3@LstCaption
$LN1@LstCaption:

; 1033 :     LstPrintf( caption );

	mov	rcx, rdi
	call	LstPrintf

; 1034 :     LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	mov	rdi, QWORD PTR [rsp+72]
	test	r9, r9
	mov	rbx, QWORD PTR [rsp+64]
	je	SHORT $LN12@LstCaption
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6092
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite

; 1035 :     LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	add	DWORD PTR list_pos, 2
	test	r9, r9
	je	SHORT $LN12@LstCaption
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6092
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN12@LstCaption:

; 1036 : }

	add	rsp, 40					; 00000028H
	ret	0
LstCaption ENDP
; Function compile flags: /Ogtpy
p1$ = 8
p2$ = 16
compare_syms PROC NEAR

; 1041 :     return( strcmp( (*(struct asym * *)p1)->name, (*(struct asym * *)p2)->name ) );

	mov	r8, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [r8+8]
	sub	rdx, rcx
$LL3@compare_sy:
	movzx	eax, BYTE PTR [rcx]
	cmp	al, BYTE PTR [rcx+rdx]
	jne	SHORT $LN5@compare_sy
	inc	rcx
	test	al, al
	jne	SHORT $LL3@compare_sy
	xor	eax, eax

; 1042 : }

	ret	0
$LN5@compare_sy:

; 1041 :     return( strcmp( (*(struct asym * *)p1)->name, (*(struct asym * *)p2)->name ) );

	sbb	eax, eax
	sbb	eax, -1

; 1042 : }

	ret	0
compare_syms ENDP
_TEXT	ENDS
PUBLIC	LstWriteCRef
EXTRN	MemFree:NEAR
EXTRN	qsort:NEAR
EXTRN	SymGetAll:NEAR
EXTRN	MemAlloc:NEAR
EXTRN	SymGetCount:NEAR
EXTRN	memset:NEAR
xdata	SEGMENT
$unwind$LstWriteCRef DD 020a01H
	DD	019010aH
xdata	ENDS
pdata	SEGMENT
$pdata$LstWriteCRef DD @imagerel($LN103#)
	DD	@imagerel($LN103#+39)
	DD	@imagerel($unwind$LstWriteCRef#)
pdata	ENDS
xdata	SEGMENT
$chain$3$LstWriteCRef DD 081721H
	DD	015f417H
	DD	016e40cH
	DD	01d7408H
	DD	01a3404H
	DD	@imagerel($LN103#)
	DD	@imagerel($LN103#+39)
	DD	@imagerel($unwind$LstWriteCRef#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$LstWriteCRef DD @imagerel($LN103#+39)
	DD	@imagerel($LN103#+358)
	DD	@imagerel($chain$3$LstWriteCRef#)
pdata	ENDS
xdata	SEGMENT
$chain$7$LstWriteCRef DD 082c21H
	DD	01b542cH
	DD	017d418H
	DD	018c410H
	DD	01c6408H
	DD	@imagerel($LN103#+39)
	DD	@imagerel($LN103#+358)
	DD	@imagerel($chain$3$LstWriteCRef#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$LstWriteCRef DD @imagerel($LN103#+358)
	DD	@imagerel($LN103#+768)
	DD	@imagerel($chain$7$LstWriteCRef#)
pdata	ENDS
xdata	SEGMENT
$chain$8$LstWriteCRef DD 021H
	DD	@imagerel($LN103#+39)
	DD	@imagerel($LN103#+358)
	DD	@imagerel($chain$3$LstWriteCRef#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$LstWriteCRef DD @imagerel($LN103#+768)
	DD	@imagerel($LN103#+1065)
	DD	@imagerel($chain$8$LstWriteCRef#)
pdata	ENDS
xdata	SEGMENT
$chain$9$LstWriteCRef DD 040021H
	DD	015f400H
	DD	01d7400H
	DD	@imagerel($LN103#)
	DD	@imagerel($LN103#+39)
	DD	@imagerel($unwind$LstWriteCRef#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$LstWriteCRef DD @imagerel($LN103#+1065)
	DD	@imagerel($LN103#+1115)
	DD	@imagerel($chain$9$LstWriteCRef#)
pdata	ENDS
xdata	SEGMENT
$chain$10$LstWriteCRef DD 021H
	DD	@imagerel($LN103#)
	DD	@imagerel($LN103#+39)
	DD	@imagerel($unwind$LstWriteCRef#)
xdata	ENDS
pdata	SEGMENT
$pdata$10$LstWriteCRef DD @imagerel($LN103#+1115)
	DD	@imagerel($LN103#+1124)
	DD	@imagerel($chain$10$LstWriteCRef#)
pdata	ENDS
xdata	SEGMENT
$chain$11$LstWriteCRef DD 080021H
	DD	015f400H
	DD	016e400H
	DD	01d7400H
	DD	01a3400H
	DD	@imagerel($LN103#)
	DD	@imagerel($LN103#+39)
	DD	@imagerel($unwind$LstWriteCRef#)
xdata	ENDS
pdata	SEGMENT
$pdata$11$LstWriteCRef DD @imagerel($LN103#+1124)
	DD	@imagerel($LN103#+1160)
	DD	@imagerel($chain$11$LstWriteCRef#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
tv816 = 40
queues$ = 48
LstWriteCRef PROC NEAR

; 1048 : {

$LN103:
	mov	rax, rsp
	sub	rsp, 200				; 000000c8H

; 1049 :     struct asym     **syms;
; 1050 :     struct dsym     *dir;
; 1051 :     struct struct_info *si;
; 1052 :     int             idx;
; 1053 :     uint_32         i;
; 1054 :     uint_32         SymCount;
; 1055 :     struct qdesc    queues[LQ_LAST];
; 1056 : 
; 1057 :     /* no point going through the motions if lst file isn't open */
; 1058 :     if( CurrFile[LST] == NULL || Options.no_symbol_listing == TRUE ) {

	mov	rcx, QWORD PTR ModuleInfo+112
	test	rcx, rcx
	je	$LN37@LstWriteCR
	cmp	BYTE PTR Options+148, 1
	je	$LN37@LstWriteCR
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+32], rdi
	mov	QWORD PTR [rax-24], r14

; 1059 :         return;
; 1060 :     }
; 1061 : 
; 1062 :     /* go to EOF */
; 1063 :     fseek( CurrFile[LST], 0, SEEK_END );

	mov	edi, 2
	xor	edx, edx
	mov	QWORD PTR [rax-32], r15
	mov	r8d, edi
	call	fseek

; 1064 : 
; 1065 :     SymCount = SymGetCount();

	call	SymGetCount
	mov	ebx, eax

; 1066 :     syms = MemAlloc( SymCount * sizeof( struct asym * ) );

	mov	QWORD PTR tv816[rsp], rbx
	lea	rcx, QWORD PTR [rbx*8]
	call	MemAlloc

; 1067 :     SymGetAll( syms );

	mov	rcx, rax
	mov	r15, rax
	call	SymGetAll

; 1068 : 
; 1069 :     DebugMsg(("LstWriteCRef: calling qsort\n"));
; 1070 :     /* sort 'em */
; 1071 :     qsort( syms, SymCount, sizeof( struct asym * ), compare_syms );

	lea	r9, OFFSET FLAT:compare_syms
	lea	r8d, QWORD PTR [rdi+6]
	mov	rdx, rbx
	mov	rcx, r15
	call	qsort

; 1072 : 
; 1073 :     memset( queues, 0, sizeof( queues ) );

	lea	r8d, QWORD PTR [rdi+110]
	lea	rcx, QWORD PTR queues$[rsp]
	xor	edx, edx
	call	memset

; 1074 :     for( i = 0; i < SymCount; ++i ) {

	test	ebx, ebx
	lea	r11, OFFSET FLAT:__ImageBase
	je	$LN34@LstWriteCR
	mov	rdx, r15
	mov	r10, rbx
	npad	11
$LL36@LstWriteCR:

; 1075 :         struct qdesc *q;
; 1076 :         if ( syms[i]->list == FALSE )

	mov	r8, QWORD PTR [rdx]
	movzx	r9d, BYTE PTR [r8+49]
	test	r9b, 1
	je	$LN35@LstWriteCR

; 1077 :             continue;
; 1078 :         switch (syms[i]->state) {

	mov	eax, DWORD PTR [r8+40]
	dec	eax
	cmp	eax, 8
	ja	$LN35@LstWriteCR
	cdqe
	mov	ecx, DWORD PTR $LN102@LstWriteCR[r11+rax*4]
	add	rcx, r11
	jmp	rcx
$LN30@LstWriteCR:

; 1079 :         case SYM_TYPE:
; 1080 :             si = ((struct dsym *)syms[i])->e.structinfo;
; 1081 :             switch ( syms[i]->typekind ) {

	mov	cl, BYTE PTR [r8+74]
	test	cl, cl
	je	SHORT $LN35@LstWriteCR
	cmp	cl, dil
	jbe	SHORT $LN25@LstWriteCR
	cmp	cl, 3
	je	SHORT $LN26@LstWriteCR
	cmp	cl, 4
	jne	SHORT $LN35@LstWriteCR

; 1082 :             case TYPE_RECORD:  idx = LQ_RECORDS; break;

	mov	rcx, rdi
	jmp	SHORT $LN31@LstWriteCR
$LN26@LstWriteCR:

; 1083 :             case TYPE_TYPEDEF: idx = LQ_TYPEDEFS;break;

	mov	ecx, 3
	jmp	SHORT $LN31@LstWriteCR
$LN25@LstWriteCR:

; 1084 :             case TYPE_STRUCT:
; 1085 :             case TYPE_UNION:   idx = LQ_STRUCTS ;break;

	mov	ecx, 1

; 1086 : #ifdef DEBUG_OUT
; 1087 :             default:           idx = LQ_UNDEF_TYPES ;break;
; 1088 : #else
; 1089 :             default: continue; /* skip "undefined" types */
; 1090 : #endif
; 1091 :             }
; 1092 :             break;

	jmp	SHORT $LN31@LstWriteCR
$LN23@LstWriteCR:

; 1093 :         case SYM_MACRO:
; 1094 :             idx = LQ_MACROS;

	xor	ecx, ecx

; 1095 :             break;

	jmp	SHORT $LN31@LstWriteCR
$LN22@LstWriteCR:

; 1096 :         case SYM_SEG:
; 1097 :             idx = LQ_SEGS;

	mov	ecx, 4

; 1098 :             break;

	jmp	SHORT $LN31@LstWriteCR
$LN21@LstWriteCR:

; 1099 :         case SYM_GRP:
; 1100 :             idx = LQ_GRPS;

	mov	ecx, 5

; 1101 :             break;

	jmp	SHORT $LN31@LstWriteCR
$LN20@LstWriteCR:

; 1102 :         case SYM_INTERNAL:
; 1103 :         case SYM_EXTERNAL: /* v2.04: added, since PROTOs are now externals */
; 1104 :             if ( syms[i]->isproc ) {

	test	r9b, 8
	je	SHORT $LN35@LstWriteCR

; 1105 :                 idx = LQ_PROCS;

	mov	ecx, 6
$LN31@LstWriteCR:

; 1106 :                 break;
; 1107 :             }
; 1108 :             /* no break */
; 1109 :         default:
; 1110 :             continue;
; 1111 :         }
; 1112 :         q = &queues[idx];

	add	rcx, rcx

; 1113 :         if( q->head == NULL ) {

	cmp	QWORD PTR queues$[rsp+rcx*8], 0
	jne	SHORT $LN17@LstWriteCR

; 1114 :             q->head = syms[i];

	mov	QWORD PTR queues$[rsp+rcx*8], r8

; 1115 :         } else {

	jmp	SHORT $LN16@LstWriteCR
$LN17@LstWriteCR:

; 1116 :             ((struct dsym *)q->tail)->next = (struct dsym *)syms[i];

	mov	rax, QWORD PTR queues$[rsp+rcx*8+8]
	mov	QWORD PTR [rax+112], r8
$LN16@LstWriteCR:

; 1117 :         }
; 1118 :         q->tail = syms[i];

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR queues$[rsp+rcx*8+8], rax

; 1119 :         ((struct dsym *)syms[i])->next = NULL;

	mov	QWORD PTR [rax+112], 0
$LN35@LstWriteCR:
	add	rdx, 8
	dec	r10
	jne	$LL36@LstWriteCR
$LN34@LstWriteCR:

; 1120 :     }
; 1121 :     for ( idx = 0; idx < ( sizeof( cr ) / sizeof(cr[0] ) ); idx++ ) {

	mov	r9, QWORD PTR ModuleInfo+112
	mov	QWORD PTR [rsp+224], rsi
	mov	QWORD PTR [rsp+192], r12
	mov	QWORD PTR [rsp+184], r13
	mov	r13, QWORD PTR queues$[rsp+64]
	lea	rsi, OFFSET FLAT:cr+8
	mov	QWORD PTR [rsp+216], rbp
	mov	r12d, 7
	lea	r14, OFFSET FLAT:__ImageBase
	npad	1
$LL15@LstWriteCR:

; 1122 :         if ( queues[cr[idx].type].head ) {

	movsx	rax, WORD PTR [rsi-8]
	shl	rax, 4
	cmp	QWORD PTR queues$[rsp+rax], 0
	je	$LN14@LstWriteCR

; 1123 :             if ( cr[idx].capitems ) {

	mov	rdi, QWORD PTR [rsi]
	test	rdi, rdi
	je	$LN8@LstWriteCR

; 1124 :                 const short *ps;
; 1125 :                 for ( ps = cr[idx].capitems; *ps; ps++ ) {

	movzx	eax, WORD PTR [rdi]
	test	ax, ax
	je	$LN8@LstWriteCR
	mov	r13d, 2
$LL10@LstWriteCR:

; 1126 :                     //if ( *ps == -1 )
; 1127 :                     //    LstNL();
; 1128 :                     //else
; 1129 :                         LstCaption( strings[ *ps ], ps == cr[idx].capitems ? 2 : 0 );

	xor	ebx, ebx
	cmp	rdi, QWORD PTR [rsi]
	movsx	rax, ax
	mov	rbp, QWORD PTR strings[r14+rax*8]
	cmove	ebx, r13d
	test	ebx, ebx
	je	SHORT $LN41@LstWriteCR
	npad	4
$LL43@LstWriteCR:
	test	r9, r9
	je	SHORT $LN42@LstWriteCR
	lea	rcx, OFFSET FLAT:$SG6092
	mov	r8, r13
	mov	edx, 1
	call	fwrite
	add	DWORD PTR list_pos, r13d
	mov	r9, QWORD PTR ModuleInfo+112
$LN42@LstWriteCR:
	dec	ebx
	jne	SHORT $LL43@LstWriteCR
$LN41@LstWriteCR:
	mov	rcx, rbp
	call	LstPrintf
	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN9@LstWriteCR
	lea	rcx, OFFSET FLAT:$SG6092
	mov	r8, r13
	mov	edx, 1
	call	fwrite
	mov	r9, QWORD PTR ModuleInfo+112
	add	DWORD PTR list_pos, r13d
	test	r9, r9
	je	SHORT $LN9@LstWriteCR
	lea	rcx, OFFSET FLAT:$SG6092
	mov	r8, r13
	mov	edx, 1
	call	fwrite
	add	DWORD PTR list_pos, r13d
	mov	r9, QWORD PTR ModuleInfo+112
$LN9@LstWriteCR:
	add	rdi, r13
	mov	ax, WORD PTR [rdi]
	test	ax, ax
	jne	$LL10@LstWriteCR
	mov	r13, QWORD PTR queues$[rsp+64]
$LN8@LstWriteCR:

; 1130 :                 }
; 1131 :             }
; 1132 :             for( dir = queues[cr[idx].type].head; dir ; dir = dir->next ) {

	movsx	rax, WORD PTR [rsi-8]
	shl	rax, 4
	mov	rbx, QWORD PTR queues$[rsp+rax]
	test	rbx, rbx
	je	SHORT $LN14@LstWriteCR
	npad	1
$LL7@LstWriteCR:

; 1133 :                 cr[idx].function( &dir->sym, ( cr[idx].flags & PRF_ADDSEG ) ? queues[LQ_SEGS].head : NULL, 0 );

	test	BYTE PTR [rsi-6], 1
	mov	edx, 0
	mov	rcx, rbx
	cmovne	rdx, r13
	xor	r8d, r8d
	call	QWORD PTR [rsi+8]
	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL7@LstWriteCR

; 1130 :                 }
; 1131 :             }
; 1132 :             for( dir = queues[cr[idx].type].head; dir ; dir = dir->next ) {

	mov	r9, QWORD PTR ModuleInfo+112
$LN14@LstWriteCR:

; 1120 :     }
; 1121 :     for ( idx = 0; idx < ( sizeof( cr ) / sizeof(cr[0] ) ); idx++ ) {

	add	rsi, 24
	dec	r12
	jne	$LL15@LstWriteCR
	mov	r14, QWORD PTR tv816[rsp]
	mov	r13, QWORD PTR [rsp+184]
	mov	r12, QWORD PTR [rsp+192]
	mov	rsi, QWORD PTR [rsp+224]
	mov	rbp, QWORD PTR [rsp+216]

; 1134 :             }
; 1135 :         }
; 1136 :     }
; 1137 : 
; 1138 :     /* write out symbols */
; 1139 :     LstCaption( strings[ LS_TXT_SYMBOLS ], 2 );

	mov	edi, 2
	mov	ebx, edi
	npad	1
$LL57@LstWriteCR:
	test	r9, r9
	je	SHORT $LN56@LstWriteCR
	lea	rcx, OFFSET FLAT:$SG6092
	mov	r8, rdi
	mov	edx, 1
	call	fwrite
	add	DWORD PTR list_pos, edi
	mov	r9, QWORD PTR ModuleInfo+112
$LN56@LstWriteCR:
	dec	ebx
	jne	SHORT $LL57@LstWriteCR
	lea	rcx, OFFSET FLAT:$SG5916
	call	LstPrintf
	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN66@LstWriteCR
	lea	edx, QWORD PTR [rbx+1]
	lea	rcx, OFFSET FLAT:$SG6092
	mov	r8, rdi
	call	fwrite
	mov	r9, QWORD PTR ModuleInfo+112
	add	DWORD PTR list_pos, edi
	test	r9, r9
	je	SHORT $LN66@LstWriteCR
	lea	edx, QWORD PTR [rbx+1]
	lea	rcx, OFFSET FLAT:$SG6092
	mov	r8, rdi
	call	fwrite
	add	DWORD PTR list_pos, edi
$LN66@LstWriteCR:

; 1140 :     LstCaption( strings[ LS_TXT_SYMCAP ], 0 );

	lea	rcx, OFFSET FLAT:$SG5917
	call	LstPrintf
	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN80@LstWriteCR
	lea	rcx, OFFSET FLAT:$SG6092
	mov	r8, rdi
	mov	edx, 1
	call	fwrite
	mov	r9, QWORD PTR ModuleInfo+112
	add	DWORD PTR list_pos, edi
	test	r9, r9
	je	SHORT $LN80@LstWriteCR
	lea	rcx, OFFSET FLAT:$SG6092
	mov	r8, rdi
	mov	edx, 1
	call	fwrite
	add	DWORD PTR list_pos, edi
	mov	r9, QWORD PTR ModuleInfo+112
$LN80@LstWriteCR:

; 1141 :     for( i = 0; i < SymCount; ++i ) {

	cmp	r14d, 0
	jbe	SHORT $LN2@LstWriteCR
	mov	rbx, r15
	npad	10
$LL4@LstWriteCR:

; 1142 :         if ( syms[i]->list == TRUE && syms[i]->isproc == FALSE ) {

	mov	rcx, QWORD PTR [rbx]
	movzx	eax, BYTE PTR [rcx+49]
	test	al, 1
	je	SHORT $LN3@LstWriteCR
	test	al, 8
	jne	SHORT $LN3@LstWriteCR

; 1143 :             DebugMsg(("LstWriteCRef: log_symbol( %s )\n", syms[i]->name ));
; 1144 :             log_symbol( syms[i] );

	call	log_symbol
$LN3@LstWriteCR:

; 1141 :     for( i = 0; i < SymCount; ++i ) {

	add	rbx, 8
	dec	r14
	jne	SHORT $LL4@LstWriteCR
	mov	r9, QWORD PTR ModuleInfo+112
$LN2@LstWriteCR:

; 1145 :         }
; 1146 : #ifdef DEBUG_OUT
; 1147 :         else
; 1148 :             DebugMsg(("LstWriteCRef: %s suppressed\n", syms[i]->name ));
; 1149 : #endif
; 1150 :     }
; 1151 :     LstNL();

	test	r9, r9
	mov	r14, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [rsp+208]
	je	SHORT $LN83@LstWriteCR
	lea	rcx, OFFSET FLAT:$SG6092
	mov	r8, rdi
	mov	edx, 1
	call	fwrite
	add	DWORD PTR list_pos, edi
$LN83@LstWriteCR:

; 1152 : 
; 1153 :     /* free the sorted symbols */
; 1154 :     DebugMsg(("LstWriteCRef: free sorted symbols\n"));
; 1155 :     MemFree( syms );

	mov	rcx, r15
	call	MemFree
	mov	r15, QWORD PTR [rsp+168]
	mov	rdi, QWORD PTR [rsp+232]
$LN37@LstWriteCR:

; 1156 : }

	add	rsp, 200				; 000000c8H
	ret	0
	npad	1
$LN102@LstWriteCR:
	DD	$LN20@LstWriteCR
	DD	$LN20@LstWriteCR
	DD	$LN22@LstWriteCR
	DD	$LN21@LstWriteCR
	DD	$LN35@LstWriteCR
	DD	$LN35@LstWriteCR
	DD	$LN30@LstWriteCR
	DD	$LN35@LstWriteCR
	DD	$LN23@LstWriteCR
LstWriteCRef ENDP
_TEXT	ENDS
PUBLIC	ListingDirective
EXTRN	EmitWarn:NEAR
EXTRN	EmitError:NEAR
EXTRN	CurrStruct:QWORD
EXTRN	EmitErr:NEAR
EXTRN	SymLookup:NEAR
xdata	SEGMENT
$unwind$ListingDirective DD 071b01H
	DD	09741bH
	DD	086411H
	DD	073409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$ListingDirective DD @imagerel($LN43#)
	DD	@imagerel($LN43#+648)
	DD	@imagerel($unwind$ListingDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
ListingDirective PROC NEAR

; 1164 : {

$LN43:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+56], rbx
	movsxd	rbx, ecx
	mov	QWORD PTR [rsp+64], rsi

; 1165 :     int directive = tokenarray[i].tokval;

	mov	rax, rbx

; 1166 :     i++;

	inc	ebx
	mov	QWORD PTR [rsp+72], rdi
	shl	rax, 5
	mov	rsi, rdx
	movsxd	rdi, ebx
	mov	r8d, DWORD PTR [rax+rdx+16]

; 1167 : 
; 1168 :     switch ( directive ) {

	add	r8d, -295				; fffffffffffffed9H
	cmp	r8d, 11
	ja	$LN7@ListingDir
	lea	rcx, OFFSET FLAT:__ImageBase
	movsxd	rax, r8d
	mov	edx, DWORD PTR $LN40@ListingDir[rcx+rax*4]
	add	rdx, rcx
	jmp	rdx
$LN25@ListingDir:

; 1169 :     case T_DOT_LIST:
; 1170 :         if ( CurrFile[LST] )

	cmp	QWORD PTR ModuleInfo+112, 0
	je	$LN2@ListingDir

; 1171 :             ModuleInfo.list = TRUE;

	bts	DWORD PTR ModuleInfo+408, 12

; 1172 :         break;

	jmp	$LN2@ListingDir
$LN23@ListingDir:

; 1173 :     case T_DOT_CREF:
; 1174 :         ModuleInfo.cref = TRUE;

	bts	DWORD PTR ModuleInfo+408, 13

; 1175 :         break;

	jmp	$LN2@ListingDir
$LN22@ListingDir:

; 1176 :     case T_DOT_NOLIST:
; 1177 :     case T_DOT_XLIST:
; 1178 :         ModuleInfo.list = FALSE;

	btr	DWORD PTR ModuleInfo+408, 12

; 1179 :         break;

	jmp	$LN2@ListingDir
$LN21@ListingDir:

; 1180 :     case T_DOT_NOCREF:
; 1181 :     case T_DOT_XCREF:
; 1182 :         if ( i == Token_Count ) {

	cmp	ebx, DWORD PTR ModuleInfo+496
	jne	SHORT $LN38@ListingDir

; 1183 :             ModuleInfo.cref = FALSE;

	btr	DWORD PTR ModuleInfo+408, 13

; 1184 :             break;

	jmp	$LN2@ListingDir
$LN38@ListingDir:

; 1185 :         }
; 1186 :         do {
; 1187 :             struct asym *sym;
; 1188 :             if ( tokenarray[i].token != T_ID ) {

	shl	rdi, 5
	add	rdi, rsi
$LL19@ListingDir:
	cmp	BYTE PTR [rdi], 8
	jne	SHORT $LN32@ListingDir

; 1190 :             }
; 1191 :             /* the name may be a forward reference. In this case it will
; 1192 :              * be created here.
; 1193 :              * v2.11: function call cannot fail. no need for checks.
; 1194 :              */
; 1195 :             sym = SymLookup( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rdi+8]
	call	SymLookup

; 1196 :             sym->list = FALSE;
; 1197 :             i++;

	inc	ebx
	add	rdi, 32					; 00000020H
	and	BYTE PTR [rax+49], 254			; 000000feH

; 1198 :             if ( i < Token_Count ) {

	mov	ecx, DWORD PTR ModuleInfo+496
	cmp	ebx, ecx
	jge	$LN2@ListingDir

; 1199 :                 if ( tokenarray[i].token != T_COMMA )

	cmp	BYTE PTR [rdi], 44			; 0000002cH
	jne	SHORT $LN34@ListingDir

; 1201 : 
; 1202 :                 /* if there's nothing after the comma, don't increment */
; 1203 :                 if ( i < ( Token_Count - 1 ) )

	lea	eax, DWORD PTR [rcx-1]
	cmp	ebx, eax
	jge	SHORT $LN18@ListingDir

; 1204 :                     i++;

	inc	ebx
	add	rdi, 32					; 00000020H
$LN18@ListingDir:

; 1205 :             }
; 1206 :         } while ( i < Token_Count );

	cmp	ebx, ecx
	jl	SHORT $LL19@ListingDir
	jmp	$LN2@ListingDir
$LN32@ListingDir:

; 1189 :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rdx, ebx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 1246 : }

	add	rsp, 40					; 00000028H
	jmp	EmitErr
$LN34@ListingDir:

; 1200 :                     return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	movsxd	rdx, ebx
	mov	ecx, 39					; 00000027H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 1246 : }

	add	rsp, 40					; 00000028H
	jmp	EmitErr
$LN12@ListingDir:

; 1207 :         break;
; 1208 :     case T_DOT_LISTALL: /* list false conditionals and generated code */
; 1209 :         if ( CurrFile[LST] )

	cmp	QWORD PTR ModuleInfo+112, 0
	je	SHORT $LN41@ListingDir

; 1210 :             ModuleInfo.list = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408
	bts	eax, 12

; 1211 :         ModuleInfo.list_generated_code = TRUE;

	bts	eax, 15

; 1212 :         /* fall through */
; 1213 :     case T_DOT_LISTIF:
; 1214 :     case T_DOT_LFCOND: /* .LFCOND is synonym for .LISTIF */
; 1215 :         ModuleInfo.listif = TRUE;

	bts	eax, 14
	mov	DWORD PTR ModuleInfo+408, eax

; 1216 :         break;

	jmp	$LN2@ListingDir
$LN41@ListingDir:

; 1210 :             ModuleInfo.list = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408

; 1211 :         ModuleInfo.list_generated_code = TRUE;

	bts	eax, 15

; 1212 :         /* fall through */
; 1213 :     case T_DOT_LISTIF:
; 1214 :     case T_DOT_LFCOND: /* .LFCOND is synonym for .LISTIF */
; 1215 :         ModuleInfo.listif = TRUE;

	bts	eax, 14
	mov	DWORD PTR ModuleInfo+408, eax

; 1216 :         break;

	jmp	$LN2@ListingDir
$LN42@ListingDir:

; 1211 :         ModuleInfo.list_generated_code = TRUE;

	mov	eax, DWORD PTR ModuleInfo+408

; 1212 :         /* fall through */
; 1213 :     case T_DOT_LISTIF:
; 1214 :     case T_DOT_LFCOND: /* .LFCOND is synonym for .LISTIF */
; 1215 :         ModuleInfo.listif = TRUE;

	bts	eax, 14
	mov	DWORD PTR ModuleInfo+408, eax

; 1216 :         break;

	jmp	$LN2@ListingDir
$LN9@ListingDir:

; 1217 :     case T_DOT_NOLISTIF:
; 1218 :     case T_DOT_SFCOND: /* .SFCOND is synonym for .NOLISTIF */
; 1219 :         ModuleInfo.listif = FALSE;

	btr	DWORD PTR ModuleInfo+408, 14

; 1220 :         break;

	jmp	SHORT $LN2@ListingDir
$LN8@ListingDir:

; 1221 :     case T_DOT_TFCOND: /* .TFCOND toggles .LFCOND, .SFCOND */
; 1222 :         ModuleInfo.listif = !ModuleInfo.listif;

	mov	ecx, DWORD PTR ModuleInfo+408
	mov	eax, ecx
	not	eax
	xor	eax, ecx
	and	eax, 16384				; 00004000H
	xor	ecx, eax
	mov	DWORD PTR ModuleInfo+408, ecx

; 1223 :         break;

	jmp	SHORT $LN2@ListingDir
$LN7@ListingDir:

; 1224 :     case T_PAGE:
; 1225 :     default: /* TITLE, SUBTITLE, SUBTTL */
; 1226 :         /* tiny checks to ensure that these directives
; 1227 :          aren't used as code labels or struct fields */
; 1228 :         if ( tokenarray[i].token == T_COLON )

	shl	rdi, 5
	cmp	BYTE PTR [rdi+rsi], 58			; 0000003aH
	je	SHORT $LN2@ListingDir

; 1229 :             break;
; 1230 :         /* this isn't really Masm-compatible, but ensures we don't get
; 1231 :          * struct fields with names page, title, subtitle, subttl.
; 1232 :          */
; 1233 :         if( CurrStruct ) {

	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN5@ListingDir

; 1234 :             return( EmitError( STATEMENT_NOT_ALLOWED_INSIDE_STRUCTURE_DEFINITION ) );

	mov	ecx, 141				; 0000008dH
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 1246 : }

	add	rsp, 40					; 00000028H
	jmp	EmitError
$LN5@ListingDir:

; 1235 :         }
; 1236 :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN31@ListingDir

; 1237 :             EmitWarn( 4, DIRECTIVE_IGNORED, tokenarray[i-1].string_ptr );

	mov	r8, QWORD PTR [rdi+rsi-24]
	mov	edx, 128				; 00000080H
	lea	ecx, QWORD PTR [rdx-124]
	call	EmitWarn
$LN31@ListingDir:

; 1238 :         while ( tokenarray[i].token != T_FINAL) i++;

	cmp	BYTE PTR [rdi+rsi], 0
	je	SHORT $LN2@ListingDir
	lea	rax, QWORD PTR [rdi+rsi]
$LL3@ListingDir:
	add	rax, 32					; 00000020H
	inc	ebx
	cmp	BYTE PTR [rax], 0
	jne	SHORT $LL3@ListingDir
$LN2@ListingDir:

; 1239 :     }
; 1240 : 
; 1241 :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, ebx
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rsi], 0
	je	SHORT $LN1@ListingDir

; 1242 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+rsi+8]
	mov	ecx, 209				; 000000d1H
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 1246 : }

	add	rsp, 40					; 00000028H
	jmp	EmitErr
$LN1@ListingDir:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 1243 :     }
; 1244 : 
; 1245 :     return( NOT_ERROR );

	xor	eax, eax

; 1246 : }

	add	rsp, 40					; 00000028H
	ret	0
	npad	3
$LN40@ListingDir:
	DD	$LN23@ListingDir
	DD	$LN42@ListingDir
	DD	$LN25@ListingDir
	DD	$LN12@ListingDir
	DD	$LN42@ListingDir
	DD	$LN21@ListingDir
	DD	$LN22@ListingDir
	DD	$LN9@ListingDir
	DD	$LN9@ListingDir
	DD	$LN8@ListingDir
	DD	$LN21@ListingDir
	DD	$LN22@ListingDir
ListingDirective ENDP
_TEXT	ENDS
PUBLIC	ListMacroDirective
EXTRN	SpecialTable:BYTE
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
i$ = 8
tokenarray$ = 16
ListMacroDirective PROC NEAR

; 1252 : {

	mov	rax, rdx

; 1253 :     if ( tokenarray[i+1].token != T_FINAL ) {

	movsxd	r8, ecx
	lea	rdx, QWORD PTR [r8+1]
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rax], 0
	je	SHORT $LN1@ListMacroD

; 1254 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+rax+8]
	mov	ecx, 209				; 000000d1H

; 1260 : }

	jmp	EmitErr
$LN1@ListMacroD:

; 1255 :     }
; 1256 : 
; 1257 :     ModuleInfo.list_macro = GetSflagsSp( tokenarray[i].tokval );

	shl	r8, 5
	mov	eax, DWORD PTR [r8+rax+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rax, OFFSET FLAT:SpecialTable+4
	mov	eax, DWORD PTR [rax+rcx*4]
	mov	DWORD PTR ModuleInfo+400, eax

; 1258 : 
; 1259 :     return( NOT_ERROR );

	xor	eax, eax

; 1260 : }

	ret	0
ListMacroDirective ENDP
_TEXT	ENDS
PUBLIC	LstInit
EXTRN	GetFName:NEAR
EXTRN	MsgGetEx:NEAR
xdata	SEGMENT
$unwind$LstInit DD 020601H
	DD	070023206H
xdata	ENDS
pdata	SEGMENT
$pdata$LstInit DD @imagerel($LN10#)
	DD	@imagerel($LN10#+239)
	DD	@imagerel($unwind$LstInit#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
LstInit	PROC NEAR

; 1264 : {

$LN10:
	push	rdi
	sub	rsp, 32					; 00000020H

; 1265 :     const struct fname_item *fn;
; 1266 :     const char *buffer;
; 1267 : 
; 1268 :     list_pos = 0;
; 1269 :     if( Options.write_listing ) {

	cmp	BYTE PTR Options+129, 0
	mov	DWORD PTR list_pos, 0
	je	$LN7@LstInit

; 1270 :         int namelen;
; 1271 :         buffer = MsgGetEx( MSG_HJWASM );

	mov	ecx, 2
	call	MsgGetEx

; 1272 :         list_pos = strlen( buffer );
; 1273 :         fwrite( buffer, 1, list_pos, CurrFile[LST] );

	mov	r9, QWORD PTR ModuleInfo+112
	mov	rcx, -1
	mov	r11, rax
	xor	eax, eax
	mov	rdi, r11
	lea	edx, QWORD PTR [rax+1]
	repne scasb
	not	rcx
	dec	rcx
	mov	DWORD PTR list_pos, ecx
	mov	r8d, ecx
	mov	rcx, r11
	call	fwrite

; 1274 :         LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	test	r9, r9
	je	SHORT $LN4@LstInit
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6092
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN4@LstInit:

; 1275 :         fn = GetFName( ModuleInfo.srcfile );

	mov	ecx, DWORD PTR ModuleInfo+428
	call	GetFName

; 1276 :         namelen = strlen( fn->fname );
; 1277 :         fwrite( fn->fname, 1, namelen, CurrFile[LST] );

	mov	r9, QWORD PTR ModuleInfo+112
	mov	rcx, -1
	mov	r10, QWORD PTR [rax]
	xor	eax, eax
	mov	rdi, r10
	lea	edx, QWORD PTR [rax+1]
	repne scasb
	not	rcx
	dec	rcx
	mov	rdi, rcx
	movsxd	r8, ecx
	mov	rcx, r10
	call	fwrite

; 1278 :         list_pos += namelen;
; 1279 :         LstNL();

	mov	r9, QWORD PTR ModuleInfo+112
	add	DWORD PTR list_pos, edi
	test	r9, r9
	je	SHORT $LN7@LstInit
	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6092
	lea	r8d, QWORD PTR [rdx+1]
	call	fwrite
	add	DWORD PTR list_pos, 2
$LN7@LstInit:

; 1280 :     }
; 1281 : 
; 1282 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
LstInit	ENDP
_TEXT	ENDS
END
