; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
EXTRN	FreeFixup:NEAR
EXTRN	EmitWarn:NEAR
EXTRN	OutputByte:NEAR
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
xdata	SEGMENT
$unwind$DoPatch DD 051201H
	DD	0b7412H
	DD	0a6409H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$DoPatch DD @imagerel(DoPatch#)
	DD	@imagerel(DoPatch#+50)
	DD	@imagerel($unwind$DoPatch#)
pdata	ENDS
xdata	SEGMENT
$chain$2$DoPatch DD 020521H
	DD	093405H
	DD	@imagerel(DoPatch#)
	DD	@imagerel(DoPatch#+50)
	DD	@imagerel($unwind$DoPatch#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$DoPatch DD @imagerel(DoPatch#+50)
	DD	@imagerel(DoPatch#+480)
	DD	@imagerel($chain$2$DoPatch#)
pdata	ENDS
xdata	SEGMENT
$chain$3$DoPatch DD 021H
	DD	@imagerel(DoPatch#)
	DD	@imagerel(DoPatch#+50)
	DD	@imagerel($unwind$DoPatch#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$DoPatch DD @imagerel(DoPatch#+480)
	DD	@imagerel(DoPatch#+495)
	DD	@imagerel($chain$3$DoPatch#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\backptch.c
pdata	ENDS
_TEXT	SEGMENT
max_disp$ = 32
disp$ = 32
sym$ = 64
fixup$ = 72
DoPatch	PROC NEAR

; 54   : {

	sub	rsp, 56					; 00000038H
	mov	QWORD PTR [rsp+80], rsi

; 55   :     int_32              disp;
; 56   :     int_32              max_disp;
; 57   :     unsigned            size;
; 58   :     struct dsym         *seg;
; 59   : #if LABELOPT
; 60   :     struct asym         *sym2;
; 61   :     struct fixup        *fixup2;
; 62   : #endif
; 63   : 
; 64   :     /* all relative fixups should occure only at first pass and they signal forward references
; 65   :      * they must be removed after patching or skiped ( next processed as normal fixup )
; 66   :      */
; 67   : 
; 68   :     DebugMsg(("DoPatch(%u, %s): fixup sym=%s type=%u ofs=%" I32_SPEC "Xh loc=%" I32_SPEC "Xh opt=%u def_seg=%s\n",
; 69   :               Parse_Pass + 1, sym->name,
; 70   :               fixup->sym ? fixup->sym->name : "NULL",
; 71   :               fixup->type,
; 72   :               fixup->offset,
; 73   :               fixup->locofs,
; 74   :               fixup->option,
; 75   :               fixup->def_seg ? fixup->def_seg->sym.name : "NULL" ));
; 76   :     seg = GetSegm( sym );

	mov	rsi, QWORD PTR [rcx+32]
	mov	QWORD PTR [rsp+88], rdi

; 77   :     if( seg == NULL || fixup->def_seg != seg ) {

	test	rsi, rsi
	mov	rdi, rdx
	mov	r8, rcx
	je	$LN26@DoPatch
	cmp	QWORD PTR [rdx+48], rsi
	jne	$LN26@DoPatch

; 78   :         /* if fixup location is in another segment, backpatch is possible, but
; 79   :          * complicated and it's a pretty rare case, so nothing's done.
; 80   :          */
; 81   :         DebugMsg(("DoPatch: skipped due to seg incompat: %s - %s\n",
; 82   :                   fixup->def_seg ? fixup->def_seg->sym.name : "NULL",
; 83   :                   seg ? seg->sym.name : "NULL" ));
; 84   :         SkipFixup();
; 85   :         return;
; 86   :     }
; 87   : 
; 88   :     if( Parse_Pass == PASS_1 ) {

	mov	r10d, DWORD PTR Parse_Pass
	mov	QWORD PTR [rsp+72], rbx
	xor	ebx, ebx
	test	r10d, r10d
	jne	SHORT $LN39@DoPatch

; 89   :         if( sym->mem_type == MT_FAR && fixup->option == OPTJ_CALL ) {

	cmp	DWORD PTR [rcx+44], 130			; 00000082H
	jne	SHORT $LN45@DoPatch
	cmp	DWORD PTR [rdx+28], 4
	jne	SHORT $LN45@DoPatch

; 90   :             /* convert near call to push cs + near call,
; 91   :              * (only at first pass) */
; 92   :             DebugMsg(("DoPatch: Phase error! caused by far call optimization\n"));
; 93   :             ModuleInfo.PhaseError = TRUE;

	mov	BYTE PTR ModuleInfo+422, 1

; 94   :             sym->offset++;  /* a PUSH CS will be added */

	inc	DWORD PTR [rcx+16]

; 95   :             /* todo: insert LABELOPT block here */
; 96   :             OutputByte( 0 ); /* it's pass one, nothing is written */

	xor	ecx, ecx
	call	OutputByte

; 97   :             FreeFixup( fixup );
; 98   :             return;

	jmp	$LN3@DoPatch
$LN45@DoPatch:

; 99   :         //} else if( sym->mem_type == MT_NEAR ) {
; 100  :         } else {
; 101  :             /* forward reference, only at first pass */
; 102  :             switch( fixup->type ) {

	mov	eax, DWORD PTR [rdx+24]
	cmp	eax, 2
	jl	SHORT $LN39@DoPatch
	cmp	eax, 3
	jle	SHORT $LN41@DoPatch
	cmp	eax, 4
	jne	SHORT $LN39@DoPatch

; 108  :             case FIX_OFF8:  /* push <forward reference> */
; 109  :                 if ( fixup->option == OPTJ_PUSH ) {

	cmp	DWORD PTR [rdx+28], 5
	jne	SHORT $LN39@DoPatch

; 110  :                     size = 1;    /* size increases from 2 to 3/5 */
; 111  :                     DebugMsg(("DoPatch: FIX_OFF8\n"));
; 112  :                     goto patch;

	mov	r9d, DWORD PTR disp$[rsp]
	mov	r11d, DWORD PTR max_disp$[rsp]
	lea	edx, QWORD PTR [rax-3]
	jmp	SHORT $patch$5317
$LN41@DoPatch:

; 103  :             case FIX_RELOFF32:
; 104  :             case FIX_RELOFF16:
; 105  :                 FreeFixup( fixup );

	mov	rcx, rdx

; 106  :                 DebugMsg(("DoPatch: FIX_RELOFF32/FIX_RELOFF16, return\n"));
; 107  :                 return;

	jmp	$LN66@DoPatch
$LN39@DoPatch:

; 113  :                 }
; 114  :             }
; 115  :         }
; 116  :     }
; 117  :     size = 0;
; 118  :     switch( fixup->type ) {

	mov	ecx, DWORD PTR [rdi+24]
	mov	edx, ebx
	dec	ecx
	je	SHORT $LN34@DoPatch
	dec	ecx
	je	SHORT $LN35@DoPatch
	dec	ecx
	jne	$LN65@DoPatch

; 119  :     case FIX_RELOFF32:
; 120  :         size = 2; /* will be 4 finally */

	mov	edx, 2
$LN35@DoPatch:

; 121  :         /* fall through */
; 122  :     case FIX_RELOFF16:
; 123  :         size++; /* will be 2 finally */

	inc	edx
$LN34@DoPatch:

; 124  :         /* fall through */
; 125  :     case FIX_RELOFF8:
; 126  :         size++;
; 127  :         /* calculate the displacement */
; 128  :         // disp = fixup->offset + GetCurrOffset() - fixup->location - size;
; 129  :         disp = fixup->offset + fixup->sym->offset - fixup->locofs - size - 1;

	mov	rax, QWORD PTR [rdi+56]
	inc	edx

; 130  :         max_disp = (1UL << ((size * 8)-1)) - 1;

	mov	r11d, 1
	mov	r9d, DWORD PTR [rax+16]
	lea	ecx, DWORD PTR [rdx*8-1]
	sub	r9d, DWORD PTR [rdi+20]
	shl	r11d, cl
	add	r9d, DWORD PTR [rdi+16]
	dec	r11d
	sub	r9d, edx
	dec	r9d

; 131  :         if( disp > max_disp || disp < (-max_disp-1) ) {

	cmp	r9d, r11d
	jg	SHORT $patch$5317
	mov	eax, -1
	sub	eax, r11d
	cmp	r9d, eax
	jge	$LN3@DoPatch
$patch$5317:

; 132  :         patch:
; 133  :             DebugMsg(("DoPatch(%u): Phase error, disp=%X, fixup=%s(%X), loc=%X!\n", Parse_Pass + 1, disp, fixup->sym->name, fixup->sym->offset, fixup->locofs ));
; 134  :             ModuleInfo.PhaseError = TRUE;
; 135  :             /* ok, the standard case is: there's a forward jump which
; 136  :              * was assumed to be SHORT, but it must be NEAR instead.
; 137  :              */
; 138  :             switch( size ) {

	dec	edx
	mov	BYTE PTR ModuleInfo+422, 1
	je	SHORT $LN29@DoPatch
	dec	edx
	je	SHORT $LN2@DoPatch
	cmp	edx, 2
	jne	$LN3@DoPatch
$LN2@DoPatch:

; 211  :                     break;
; 212  :                 }
; 213  :                 break;
; 214  :             case 2:
; 215  :             case 4:
; 216  :                 DebugMsg(("DoPatch: jump out of range, disp=%d\n", disp ));
; 217  :                 EmitWarn( 4, JUMP_OUT_OF_RANGE, disp - max_disp );

	mov	edx, 53					; 00000035H
	sub	r9d, r11d
	lea	ecx, QWORD PTR [rdx-49]
	mov	r8d, r9d
	call	EmitWarn

; 218  :                 break;

	jmp	$LN3@DoPatch
$LN29@DoPatch:

; 139  :             case 1:
; 140  :                 size = 0;
; 141  :                 switch( fixup->option ) {

	mov	ecx, DWORD PTR [rdi+28]
	dec	ecx
	je	$LN65@DoPatch
	dec	ecx
	je	SHORT $LN25@DoPatch
	dec	ecx
	je	SHORT $LN24@DoPatch
	jmp	SHORT $LN23@DoPatch
$LN25@DoPatch:

; 142  :                 case OPTJ_EXPLICIT:
; 143  : #if 0 /* don't display the error at the destination line! */
; 144  :                     DebugMsg(("DoPatch: jump out of range, disp=%d\n", disp ));
; 145  :                     EmitErr( JUMP_OUT_OF_RANGE, disp - max_disp );
; 146  : #endif
; 147  :                     return;
; 148  :                 case OPTJ_EXTEND: /* Jxx for 8086 */
; 149  :                     size++;       /* will be 3/5 finally */

	mov	ebx, 1
$LN24@DoPatch:

; 150  :                     /* fall through */
; 151  :                 case OPTJ_JXX: /* Jxx for 386 */
; 152  :                     size++;

	inc	ebx
$LN23@DoPatch:

; 153  :                     /* fall through */
; 154  :                 default: /* normal JMP (and PUSH) */
; 155  :                     // if( CodeInfo->Ofssize ) /* v1.96: don't use CodeInfo here! */
; 156  :                     if( seg->e.seginfo->Ofssize )

	mov	rdx, QWORD PTR [rsi+104]
	cmp	BYTE PTR [rdx+104], 0
	je	SHORT $LN22@DoPatch

; 157  :                         size += 2; /* NEAR32 instead of NEAR16 */

	add	ebx, 2
$LN22@DoPatch:

; 158  :                     size++;

	inc	ebx

; 159  : #if LABELOPT
; 160  :                     /* v2.04: if there's an ORG between src and dst, skip
; 161  :                      * the optimization!
; 162  :                      */
; 163  :                     if ( Parse_Pass == PASS_1 ) {

	test	r10d, r10d
	jne	SHORT $LN56@DoPatch

; 164  :                         for ( fixup2 = seg->e.seginfo->FixupList.head; fixup2; fixup2 = fixup2->nextrlc ) {

	mov	rcx, QWORD PTR [rdx+40]
	test	rcx, rcx
	je	SHORT $LN56@DoPatch
$LL20@DoPatch:

; 165  :                             if ( fixup2->orgoccured ) {

	test	BYTE PTR [rcx+33], 2
	jne	SHORT $LN65@DoPatch

; 166  :                                 DebugMsg(("DoPatch: ORG/ALIGN detected, optimization canceled\n" ));
; 167  :                                 return;
; 168  :                             }
; 169  :                             /* do this check after the check for ORG! */
; 170  :                             if ( fixup2->locofs <= fixup->locofs )

	mov	eax, DWORD PTR [rdi+20]
	cmp	DWORD PTR [rcx+20], eax
	jbe	SHORT $LN56@DoPatch
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	jne	SHORT $LL20@DoPatch
$LN56@DoPatch:

; 171  :                                 break;
; 172  :                         }
; 173  :                     }
; 174  :                     /* scan the segment's label list and adjust all labels
; 175  :                      * which are between the fixup loc and the current sym.
; 176  :                      * ( PROCs are NOT contained in this list because they
; 177  :                      * use the <next>-field of dsym already!)
; 178  :                      */
; 179  :                     for ( sym2 = seg->e.seginfo->label_list; sym2; sym2 = (struct asym *)((struct dsym *)sym2)->next ) {

	mov	rcx, QWORD PTR [rdx+32]
	test	rcx, rcx
	je	SHORT $LN57@DoPatch
$LL15@DoPatch:

; 180  :                         //if ( sym2 == sym )
; 181  :                         //    continue;
; 182  :                         /* v2.0: location is at least 1 byte too low, so
; 183  :                          * use the "<=" operator instead of "<"!
; 184  :                          */
; 185  :                         //if ( sym2->offset < fixup->locofs )
; 186  :                         if ( sym2->offset <= fixup->locofs )

	mov	eax, DWORD PTR [rcx+16]
	cmp	eax, DWORD PTR [rdi+20]
	jbe	SHORT $LN63@DoPatch

; 187  :                             break;
; 188  :                         sym2->offset += size;

	add	eax, ebx
	mov	DWORD PTR [rcx+16], eax
	mov	rcx, QWORD PTR [rcx+112]
	test	rcx, rcx
	jne	SHORT $LL15@DoPatch
$LN63@DoPatch:

; 171  :                                 break;
; 172  :                         }
; 173  :                     }
; 174  :                     /* scan the segment's label list and adjust all labels
; 175  :                      * which are between the fixup loc and the current sym.
; 176  :                      * ( PROCs are NOT contained in this list because they
; 177  :                      * use the <next>-field of dsym already!)
; 178  :                      */
; 179  :                     for ( sym2 = seg->e.seginfo->label_list; sym2; sym2 = (struct asym *)((struct dsym *)sym2)->next ) {

	mov	r10d, DWORD PTR Parse_Pass
$LN57@DoPatch:

; 189  :                         DebugMsg(("DoPatch(loc=%" I32_SPEC "X): sym %s, offset changed %" I32_SPEC "X -> %" I32_SPEC "X\n", fixup->locofs, sym2->name, sym2->offset - size, sym2->offset));
; 190  :                     }
; 191  :                     /* v2.03: also adjust fixup locations located between the
; 192  :                      * label reference and the label. This should reduce the
; 193  :                      * number of passes to 2 for not too complex sources.
; 194  :                      */
; 195  :                     if ( Parse_Pass == PASS_1 ) /* v2.04: added, just to be safe */

	test	r10d, r10d
	jne	SHORT $LN64@DoPatch

; 196  :                     for ( fixup2 = seg->e.seginfo->FixupList.head; fixup2; fixup2 = fixup2->nextrlc ) {

	mov	rax, QWORD PTR [rsi+104]
	mov	rcx, QWORD PTR [rax+40]
	test	rcx, rcx
	je	SHORT $LN64@DoPatch
$LL10@DoPatch:

; 197  :                         if ( fixup2->sym == sym )

	cmp	QWORD PTR [rcx+56], r8
	je	SHORT $LN9@DoPatch

; 198  :                             continue;
; 199  :                         if ( fixup2->locofs <= fixup->locofs )

	mov	eax, DWORD PTR [rcx+20]
	cmp	eax, DWORD PTR [rdi+20]
	jbe	SHORT $LN64@DoPatch

; 200  :                             break;
; 201  :                         fixup2->locofs += size;

	add	eax, ebx
	mov	DWORD PTR [rcx+20], eax
$LN9@DoPatch:
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	jne	SHORT $LL10@DoPatch
$LN64@DoPatch:

; 202  :                         DebugMsg(("for sym=%s fixup loc %" I32_SPEC "X changed to %" I32_SPEC "X\n", fixup2->sym->name, fixup2->locofs - size, fixup2->locofs ));
; 203  :                     }
; 204  : #else
; 205  :                     DebugMsg(("DoPatch: sym %s, offset changed %" I32_SPEC "X -> %" I32_SPEC "X\n", sym->name, sym->offset, sym->offset + size));
; 206  :                     sym->offset += size;
; 207  : #endif
; 208  :                     /*  it doesn't matter what's actually "written" */
; 209  :                     for ( ; size; size-- )

	test	ebx, ebx
	je	SHORT $LN3@DoPatch
$LL5@DoPatch:

; 210  :                         OutputByte( 0xCC );

	mov	cl, 204					; 000000ccH
	call	OutputByte
	add	ebx, -1					; ffffffffH
	jne	SHORT $LL5@DoPatch
$LN3@DoPatch:

; 219  :             }
; 220  :         }
; 221  : #ifdef DEBUG_OUT
; 222  :         else
; 223  :             DebugMsg(("DoPatch, loc=%" I32_SPEC "X: displacement still short: %Xh\n", fixup->locofs, disp ));
; 224  : #endif
; 225  :         /* v2.04: fixme: is it ok to remove the fixup?
; 226  :          * it might still be needed in a later backpatch.
; 227  :          */
; 228  :         FreeFixup( fixup );

	mov	rcx, rdi
$LN66@DoPatch:
	call	FreeFixup
$LN65@DoPatch:
	mov	rbx, QWORD PTR [rsp+72]
$LN26@DoPatch:
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+80]

; 229  :         break;
; 230  :     default:
; 231  :         DebugMsg(("DoPatch: default branch, unhandled fixup type=%u\n", fixup->type ));
; 232  :         SkipFixup();
; 233  :         break;
; 234  :     }
; 235  :     return;
; 236  : }

	add	rsp, 56					; 00000038H
	ret	0
DoPatch	ENDP
_TEXT	ENDS
PUBLIC	BackPatch
xdata	SEGMENT
$unwind$BackPatch DD 030d01H
	DD	09740dH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$BackPatch DD @imagerel($LN10#)
	DD	@imagerel($LN10#+21)
	DD	@imagerel($unwind$BackPatch#)
pdata	ENDS
xdata	SEGMENT
$chain$1$BackPatch DD 020521H
	DD	083405H
	DD	@imagerel($LN10#)
	DD	@imagerel($LN10#+21)
	DD	@imagerel($unwind$BackPatch#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$BackPatch DD @imagerel($LN10#+21)
	DD	@imagerel($LN10#+72)
	DD	@imagerel($chain$1$BackPatch#)
pdata	ENDS
xdata	SEGMENT
$chain$2$BackPatch DD 021H
	DD	@imagerel($LN10#)
	DD	@imagerel($LN10#+21)
	DD	@imagerel($unwind$BackPatch#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$BackPatch DD @imagerel($LN10#+72)
	DD	@imagerel($LN10#+92)
	DD	@imagerel($chain$2$BackPatch#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
BackPatch PROC NEAR

; 249  : {

$LN10:
	sub	rsp, 40					; 00000028H

; 250  :     struct fixup     *fixup;
; 251  :     struct fixup     *next;
; 252  : #ifdef DEBUG_OUT
; 253  :     uint_32 oldofs = sym->offset;
; 254  : #endif
; 255  : 
; 256  :     DebugMsg1(("BackPatch(%s): location=%s:%X, bp_fixup=%p\n", sym->name, sym->segment ? sym->segment->name : "!NULL!", sym->offset, sym->bp_fixup ));
; 257  : 
; 258  :     for( fixup = sym->bp_fixup; fixup; fixup = next ) {

	mov	rdx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx
	test	rdx, rdx
	je	SHORT $LN8@BackPatch
	mov	QWORD PTR [rsp+64], rbx
	npad	6
$LL3@BackPatch:

; 259  :         next = fixup->nextbp;

	mov	rbx, QWORD PTR [rdx]

; 260  :         DoPatch( sym, fixup );

	mov	rcx, rdi
	call	DoPatch
	test	rbx, rbx
	mov	rdx, rbx
	jne	SHORT $LL3@BackPatch

; 261  :     }
; 262  :     /* fixme: to clear field bp_fixup may cause memory leaks, since not all fixups are freed here.
; 263  :      * usually no problem, because FASTMEM is true ( that is, LclFree() is a NOP ).
; 264  :      * the problem is that these fixups are in 2 queues, one starts in sym.bp_fixup,
; 265  :      * the other start in CurrSeg.FixupList.
; 266  :      */
; 267  :     sym->bp_fixup = NULL;

	mov	QWORD PTR [rdi+96], rbx
	mov	rbx, QWORD PTR [rsp+64]

; 268  : #ifdef DEBUG_OUT
; 269  :     if ( oldofs != sym->offset )
; 270  :         DebugMsg1(("BackPatch(%s) exit, new ofs=%X\n", sym->name, sym->offset ));
; 271  : #endif
; 272  :     return( NOT_ERROR );

	xor	eax, eax
	mov	rdi, QWORD PTR [rsp+72]

; 273  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@BackPatch:
	mov	rdi, QWORD PTR [rsp+72]

; 261  :     }
; 262  :     /* fixme: to clear field bp_fixup may cause memory leaks, since not all fixups are freed here.
; 263  :      * usually no problem, because FASTMEM is true ( that is, LclFree() is a NOP ).
; 264  :      * the problem is that these fixups are in 2 queues, one starts in sym.bp_fixup,
; 265  :      * the other start in CurrSeg.FixupList.
; 266  :      */
; 267  :     sym->bp_fixup = NULL;

	mov	QWORD PTR [rcx+96], 0

; 268  : #ifdef DEBUG_OUT
; 269  :     if ( oldofs != sym->offset )
; 270  :         DebugMsg1(("BackPatch(%s) exit, new ofs=%X\n", sym->name, sym->offset ));
; 271  : #endif
; 272  :     return( NOT_ERROR );

	xor	eax, eax

; 273  : }

	add	rsp, 40					; 00000028H
	ret	0
BackPatch ENDP
_TEXT	ENDS
END
