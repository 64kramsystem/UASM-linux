; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
PUBLIC	WriteCodeLabel
EXTRN	WritePreprocessedLine:NEAR
EXTRN	Options:BYTE
EXTRN	ParseLine:NEAR
EXTRN	LstWrite:NEAR
EXTRN	ModuleInfo:BYTE
EXTRN	EmitErr:NEAR
xdata	SEGMENT
$unwind$WriteCodeLabel DD 0b6901H
	DD	04c469H
	DD	08645eH
	DD	075455H
	DD	097411H
	DD	06340cH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$WriteCodeLabel DD @imagerel($LN6#)
	DD	@imagerel($LN6#+204)
	DD	@imagerel($unwind$WriteCodeLabel#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\preproc.c
pdata	ENDS
_TEXT	SEGMENT
line$ = 48
tokenarray$ = 56
WriteCodeLabel PROC NEAR

; 40   : {

$LN6:
	sub	rsp, 40					; 00000028H

; 41   :     int oldcnt;
; 42   :     int oldtoken;
; 43   :     char oldchar;
; 44   : 
; 45   :     if ( tokenarray[0].token != T_ID ) {

	cmp	BYTE PTR [rdx], 8
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx
	mov	rbx, rdx
	je	SHORT $LN3@WriteCodeL

; 46   :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 209				; 000000d1H
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+48]

; 64   : }

	add	rsp, 40					; 00000028H
	jmp	EmitErr
$LN3@WriteCodeL:

; 47   :     }
; 48   :     /* ensure the listing is written with the FULL source line */
; 49   :     if ( CurrFile[LST] ) LstWrite( LSTTYPE_LABEL, 0, NULL );

	cmp	QWORD PTR ModuleInfo+112, 0
	je	SHORT $LN2@WriteCodeL
	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+7]
	call	LstWrite
$LN2@WriteCodeL:

; 50   :     /* v2.04: call ParseLine() to parse the "label" part of the line */
; 51   :     oldcnt = Token_Count;
; 52   :     oldtoken = tokenarray[2].token;
; 53   :     oldchar = *tokenarray[2].tokpos;

	mov	rax, QWORD PTR [rbx+88]
	mov	QWORD PTR [rsp+56], rbp
	movzx	ebp, BYTE PTR [rbx+64]
	mov	QWORD PTR [rsp+64], rsi
	mov	esi, DWORD PTR ModuleInfo+496
	mov	QWORD PTR [rsp+32], r12
	movzx	r12d, BYTE PTR [rax]

; 54   :     Token_Count = 2;

	mov	DWORD PTR ModuleInfo+496, 2

; 55   :     tokenarray[2].token = T_FINAL;
; 56   :     *tokenarray[2].tokpos = NULLC;

	mov	rax, QWORD PTR [rbx+88]
	mov	BYTE PTR [rbx+64], 0

; 57   :     ParseLine( tokenarray );

	mov	rcx, rbx
	mov	BYTE PTR [rax], 0
	call	ParseLine

; 58   :     if ( Options.preprocessor_stdout == TRUE )

	cmp	BYTE PTR Options+134, 1
	jne	SHORT $LN1@WriteCodeL

; 59   :         WritePreprocessedLine( line );

	mov	rcx, rdi
	call	WritePreprocessedLine
$LN1@WriteCodeL:
	mov	rdi, QWORD PTR [rsp+72]

; 60   :     Token_Count = oldcnt;

	mov	DWORD PTR ModuleInfo+496, esi

; 61   :     tokenarray[2].token = oldtoken;
; 62   :     *tokenarray[2].tokpos = oldchar;

	mov	rax, QWORD PTR [rbx+88]
	mov	rsi, QWORD PTR [rsp+64]
	mov	BYTE PTR [rbx+64], bpl
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
	mov	BYTE PTR [rax], r12b
	mov	r12, QWORD PTR [rsp+32]

; 63   :     return( NOT_ERROR );

	xor	eax, eax

; 64   : }

	add	rsp, 40					; 00000028H
	ret	0
WriteCodeLabel ENDP
_TEXT	ENDS
PUBLIC	PreprocessLine
EXTRN	directive_tab:BYTE
EXTRN	StoreLine:NEAR
EXTRN	Parse_Pass:DWORD
EXTRN	StoreState:BYTE
EXTRN	CreateConstant:NEAR
EXTRN	ExpandLine:NEAR
EXTRN	ExpandText:NEAR
EXTRN	LstWriteSrcLine:NEAR
EXTRN	CurrIfState:DWORD
EXTRN	Tokenize:NEAR
xdata	SEGMENT
$unwind$PreprocessLine DD 0bd801H
	DD	0864d8H
	DD	0974bcH
	DD	04c420H
	DD	07540eH
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$PreprocessLine DD @imagerel($LN32#)
	DD	@imagerel($LN32#+481)
	DD	@imagerel($unwind$PreprocessLine#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
line$ = 48
tokenarray$ = 56
PreprocessLine PROC NEAR

; 73   : {

$LN32:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp

; 74   :     int i;
; 75   : 
; 76   :     /* v2.11: GetTextLine() removed - this is now done in ProcessFile() */
; 77   : 
; 78   :     /* v2.08: moved here from GetTextLine() */
; 79   :     ModuleInfo.CurrComment = NULL;
; 80   :     /* v2.06: moved here from Tokenize() */
; 81   :     ModuleInfo.line_flags = 0;
; 82   :     /* Token_Count is the number of tokens scanned */
; 83   :     Token_Count = Tokenize( line, 0, tokenarray, TOK_DEFAULT );

	mov	r8, rdx
	xor	ebp, ebp
	mov	rbx, rdx
	xor	r9d, r9d
	xor	edx, edx
	mov	QWORD PTR [rsp+32], r12
	mov	r12, rcx
	mov	QWORD PTR ModuleInfo+472, rbp
	mov	BYTE PTR ModuleInfo+398, bpl
	call	Tokenize

; 84   : 
; 85   : #ifdef DEBUG_OUT
; 86   :     cntppl0++;
; 87   :     if ( ModuleInfo.GeneratedCode )
; 88   :         DebugMsg1(("PreprocessLine: >%s<\n", line ));
; 89   :     else
; 90   :         DebugMsg1(("PreprocessLine(%s): >%s< cmt=%s\n", GetTopSrcName(), line, ModuleInfo.CurrComment ? ModuleInfo.CurrComment : "" ));
; 91   : #endif
; 92   : 
; 93   : #if REMOVECOMENT == 0
; 94   :     if ( Token_Count == 0 && ( CurrIfState == BLOCK_ACTIVE || ModuleInfo.listif ) )

	test	eax, eax
	mov	DWORD PTR ModuleInfo+496, eax
	jne	SHORT $LN20@Preprocess
	cmp	DWORD PTR CurrIfState, ebp
	je	SHORT $LN21@Preprocess
	bt	DWORD PTR ModuleInfo+408, 14
	jae	SHORT $LN27@Preprocess
$LN21@Preprocess:

; 95   :         LstWriteSrcLine();

	call	LstWriteSrcLine

; 96   : #endif
; 97   : 
; 98   :     if ( Token_Count == 0 )

	mov	eax, DWORD PTR ModuleInfo+496
	test	eax, eax

; 99   :         return( 0 );

	je	SHORT $LN27@Preprocess
$LN20@Preprocess:

; 100  : 
; 101  : #ifdef DEBUG_OUT
; 102  :     /* option -np, skip preprocessor? */
; 103  :     if ( Options.skip_preprocessor )
; 104  :         return( Token_Count );
; 105  : #endif
; 106  : 
; 107  :     /* CurrIfState != BLOCK_ACTIVE && Token_Count == 1 | 3 may happen
; 108  :      * if a conditional assembly directive has been detected by Tokenize().
; 109  :      * However, it's important NOT to expand then */
; 110  :     if ( CurrIfState == BLOCK_ACTIVE ) {

	cmp	DWORD PTR CurrIfState, ebp
	jne	SHORT $LN18@Preprocess

; 111  :         if ( ( tokenarray[Token_Count].bytval & TF3_EXPANSION ? ExpandText( line, tokenarray, TRUE ) : ExpandLine( line, tokenarray ) ) < NOT_ERROR )

	cdqe
	shl	rax, 5
	test	BYTE PTR [rax+rbx+1], 2
	je	SHORT $LN25@Preprocess
	mov	r8d, 1
	mov	rdx, rbx
	mov	rcx, r12
	call	ExpandText
	jmp	SHORT $LN26@Preprocess
$LN25@Preprocess:
	mov	rdx, rbx
	mov	rcx, r12
	call	ExpandLine
$LN26@Preprocess:
	test	eax, eax
	jns	SHORT $LN28@Preprocess
$LN27@Preprocess:

; 112  :             return( 0 );

	xor	eax, eax
	mov	r12, QWORD PTR [rsp+32]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 176  :         }
; 177  :     }
; 178  : 
; 179  :     DebugCmd( cntppl2++ );
; 180  :     return( Token_Count );
; 181  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@Preprocess:

; 112  :             return( 0 );

	mov	eax, DWORD PTR ModuleInfo+496
$LN18@Preprocess:

; 113  :     }
; 114  : 
; 115  :     DebugCmd( cntppl1++ );
; 116  : 
; 117  :     i = 0;
; 118  :     if ( Token_Count > 2 && ( tokenarray[1].token == T_COLON || tokenarray[1].token == T_DBL_COLON ) )

	cmp	eax, 2
	mov	QWORD PTR [rsp+72], rdi
	mov	edi, ebp
	jle	SHORT $LN17@Preprocess
	movzx	ecx, BYTE PTR [rbx+32]
	cmp	cl, 58					; 0000003aH
	je	SHORT $LN16@Preprocess
	cmp	cl, 13
	jne	SHORT $LN17@Preprocess
$LN16@Preprocess:

; 119  :         i = 2;

	mov	edi, 2
$LN17@Preprocess:
	mov	QWORD PTR [rsp+64], rsi

; 120  : 
; 121  :     /* handle "preprocessor" directives:
; 122  :      * IF, ELSE, ENDIF, ...
; 123  :      * FOR, REPEAT, WHILE, ...
; 124  :      * PURGE
; 125  :      * INCLUDE
; 126  :      * since v2.05, error directives are no longer handled here!
; 127  :      */
; 128  :     if ( tokenarray[i].token == T_DIRECTIVE &&
; 129  :         tokenarray[i].dirtype <= DRT_INCLUDE ) {

	movsxd	rsi, edi
	shl	rsi, 5
	cmp	BYTE PTR [rsi+rbx], 3
	jne	SHORT $LN15@Preprocess
	cmp	BYTE PTR [rsi+rbx+1], 3
	ja	SHORT $LN15@Preprocess

; 130  : 
; 131  :         /* if i != 0, then a code label is located before the directive */
; 132  :         if ( i > 1 ) {

	cmp	edi, 1
	jle	SHORT $LN13@Preprocess

; 133  :             if ( ERROR == WriteCodeLabel( line, tokenarray ) )

	mov	rdx, rbx
	mov	rcx, r12
	call	WriteCodeLabel
	cmp	eax, -1

; 134  :                 return( 0 );

	je	$LN2@Preprocess
$LN13@Preprocess:

; 135  :         }
; 136  :         directive_tab[tokenarray[i].dirtype]( i, tokenarray );

	movzx	eax, BYTE PTR [rsi+rbx+1]
	mov	ecx, edi

; 137  :         return( 0 );

	jmp	$LN31@Preprocess
$LN15@Preprocess:

; 138  :     }
; 139  : 
; 140  :     /* handle preprocessor directives which need a label */
; 141  : 
; 142  :     if ( tokenarray[0].token == T_ID && tokenarray[1].token == T_DIRECTIVE ) {

	cmp	BYTE PTR [rbx], 8
	jne	$LN10@Preprocess
	cmp	BYTE PTR [rbx+32], 3
	jne	$LN10@Preprocess

; 143  :         struct asym *sym;
; 144  :         switch ( tokenarray[1].dirtype ) {

	movzx	edx, BYTE PTR [rbx+33]
	cmp	dl, 4
	mov	cl, dl
	jb	$LN10@Preprocess
	cmp	dl, 6
	jbe	SHORT $LN1@Preprocess
	cmp	dl, 47					; 0000002fH
	jne	$LN10@Preprocess

; 145  :         case DRT_EQU:
; 146  :             /*
; 147  :              * EQU is a special case:
; 148  :              * If an EQU directive defines a text equate
; 149  :              * it MUST be handled HERE and 0 must be returned to the caller.
; 150  :              * This will prevent further processing, nothing will be stored
; 151  :              * if FASTPASS is on.
; 152  :              * Since one cannot decide whether EQU defines a text equate or
; 153  :              * a number before it has scanned its argument, we'll have to
; 154  :              * handle it in ANY case and if it defines a number, the line
; 155  :              * must be stored and, if -EP is set, written to stdout.
; 156  :              */
; 157  :             if ( sym = CreateConstant( tokenarray ) ) {

	mov	rcx, rbx
	call	CreateConstant
	test	rax, rax
	mov	rbx, rax
	je	SHORT $LN2@Preprocess

; 158  :                 if ( sym->state != SYM_TMACRO ) {

	cmp	DWORD PTR [rax+40], 10
	je	SHORT $LN3@Preprocess

; 159  : #if FASTPASS
; 160  :                     if ( StoreState ) FStoreLine( 0 );

	cmp	BYTE PTR StoreState, bpl
	je	SHORT $LN5@Preprocess
	cmp	DWORD PTR Parse_Pass, ebp
	jne	SHORT $LN5@Preprocess
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	xor	edx, edx
	call	StoreLine
$LN5@Preprocess:

; 161  : #endif
; 162  :                     if ( Options.preprocessor_stdout == TRUE )

	cmp	BYTE PTR Options+134, 1
	jne	SHORT $LN3@Preprocess

; 163  :                         WritePreprocessedLine( line );

	mov	rcx, r12
	call	WritePreprocessedLine
$LN3@Preprocess:

; 164  :                 }
; 165  :                 /* v2.03: LstWrite() must be called AFTER StoreLine()! */
; 166  :                 if ( ModuleInfo.list == TRUE ) {

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN2@Preprocess

; 167  :                     LstWrite( sym->state == SYM_INTERNAL ? LSTTYPE_EQUATE : LSTTYPE_TMACRO, 0, sym );

	cmp	DWORD PTR [rbx+40], 1
	mov	r8, rbx
	setne	bpl
	xor	edx, edx
	lea	ecx, DWORD PTR [rbp+2]
	call	LstWrite

; 168  :                 }
; 169  :             }
; 170  :             return( 0 );

	jmp	SHORT $LN2@Preprocess
$LN1@Preprocess:

; 171  :         case DRT_MACRO:
; 172  :         case DRT_CATSTR: /* CATSTR + TEXTEQU directives */
; 173  :         case DRT_SUBSTR:
; 174  :             directive_tab[tokenarray[1].dirtype]( 1, tokenarray );

	movzx	eax, dl
	mov	ecx, 1
$LN31@Preprocess:
	lea	r8, OFFSET FLAT:directive_tab
	mov	rdx, rbx
	call	QWORD PTR [r8+rax*8]
$LN2@Preprocess:

; 175  :             return( 0 );

	xor	eax, eax
$LN10@Preprocess:
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	mov	r12, QWORD PTR [rsp+32]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 176  :         }
; 177  :     }
; 178  : 
; 179  :     DebugCmd( cntppl2++ );
; 180  :     return( Token_Count );
; 181  : }

	add	rsp, 40					; 00000028H
	ret	0
PreprocessLine ENDP
_TEXT	ENDS
END
