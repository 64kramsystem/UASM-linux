; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG6009	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	symCurSeg:QWORD
COMM	evex:BYTE
$SG5928	DB	'READONLY', 00H
	ORG $+3
$SG5929	DB	'BYTE', 00H
	ORG $+3
$SG5930	DB	'WORD', 00H
	ORG $+3
$SG5931	DB	'DWORD', 00H
	ORG $+2
$SG5932	DB	'PARA', 00H
	ORG $+3
$SG5933	DB	'PAGE', 00H
	ORG $+3
$SG5934	DB	'ALIGN', 00H
	ORG $+6
$SG5935	DB	'PRIVATE', 00H
$SG5936	DB	'PUBLIC', 00H
	ORG $+1
$SG5937	DB	'STACK', 00H
	ORG $+2
$SG5938	DB	'COMMON', 00H
	ORG $+1
$SG5939	DB	'MEMORY', 00H
	ORG $+1
$SG5940	DB	'AT', 00H
	ORG $+1
$SG5941	DB	'COMDAT', 00H
	ORG $+1
$SG5942	DB	'USE16', 00H
	ORG $+2
$SG5943	DB	'USE32', 00H
	ORG $+2
$SG5944	DB	'USE64', 00H
	ORG $+2
$SG5945	DB	'FLAT', 00H
	ORG $+3
$SG5946	DB	'INFO', 00H
	ORG $+7
$SG5947	DB	'DISCARD', 00H
$SG5948	DB	'NOCACHE', 00H
$SG5949	DB	'NOPAGE', 00H
	ORG $+1
$SG5950	DB	'SHARED', 00H
	ORG $+1
$SG5951	DB	'EXECUTE', 00H
$SG5952	DB	'READ', 00H
	ORG $+3
$SG5953	DB	'WRITE', 00H
	ORG $+2
$SG5954	DB	'ALIAS', 00H
_DATA	ENDS
CONST	SEGMENT
SegAttrToken DQ	FLAT:$SG5928
	DQ	FLAT:$SG5929
	DQ	FLAT:$SG5930
	DQ	FLAT:$SG5931
	DQ	FLAT:$SG5932
	DQ	FLAT:$SG5933
	DQ	FLAT:$SG5934
	DQ	FLAT:$SG5935
	DQ	FLAT:$SG5936
	DQ	FLAT:$SG5937
	DQ	FLAT:$SG5938
	DQ	FLAT:$SG5939
	DQ	FLAT:$SG5940
	DQ	FLAT:$SG5941
	DQ	FLAT:$SG5942
	DQ	FLAT:$SG5943
	DQ	FLAT:$SG5944
	DQ	FLAT:$SG5945
	DQ	FLAT:$SG5946
	DQ	FLAT:$SG5947
	DQ	FLAT:$SG5948
	DQ	FLAT:$SG5949
	DQ	FLAT:$SG5950
	DQ	FLAT:$SG5951
	DQ	FLAT:$SG5952
	DQ	FLAT:$SG5953
	DQ	FLAT:$SG5954
SegAttrValue DB	00H
	DB	01H
	DB	00H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	02H
	DB	08H
	DB	02H
	DB	00H
	DB	082H
	DB	00H
	DB	04H
	DB	02H
	DB	04H
	DB	05H
	DB	04H
	DB	06H
	DB	04H
	DB	02H
	DB	04H
	DB	00H
	DB	084H
	DB	00H
	DB	0c4H
	DB	00H
	DB	08H
	DB	01H
	DB	08H
	DB	02H
	DB	08H
	DB	01H
	DB	088H
	DB	00H
	DB	0a0H
	DB	02H
	DB	020H
	DB	04H
	DB	020H
	DB	08H
	DB	020H
	DB	010H
	DB	020H
	DB	020H
	DB	020H
	DB	040H
	DB	020H
	DB	080H
	DB	020H
	DB	00H
	DB	010H
	ORG $+2
min_cpu	DW	00H
	DW	030H
	DW	070H
CONST	ENDS
_DATA	SEGMENT
	ORG $+2
$SG6153	DB	'FLAT', 00H
	ORG $+3
$SG6202	DB	'CONST', 00H
	ORG $+2
$SG6204	DB	'DBTYP', 00H
	ORG $+2
$SG6206	DB	'DBSYM', 00H
	ORG $+2
$SG6209	DB	'CODE', 00H
	ORG $+3
$SG6211	DB	'DATA', 00H
	ORG $+3
$SG6214	DB	'BSS', 00H
$SG6373	DB	'(', 00H
	ORG $+2
$SG6376	DB	')', 00H
	ORG $+2
$SG6390	DB	'(', 00H
	ORG $+2
$SG6395	DB	'1-6', 00H
$SG6409	DB	')', 00H
	ORG $+2
$SG6422	DB	'(', 00H
	ORG $+2
$SG6426	DB	')', 00H
_DATA	ENDS
EXTRN	_stricmp:NEAR
xdata	SEGMENT
$unwind$FindToken DD 091d01H
	DD	09741dH
	DD	086413H
	DD	07540eH
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$FindToken DD @imagerel(FindToken#)
	DD	@imagerel(FindToken#+107)
	DD	@imagerel($unwind$FindToken#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\segment.c
pdata	ENDS
_TEXT	SEGMENT
token$ = 48
table$ = 56
size$ = 64
FindToken PROC NEAR

; 117  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi

; 118  :     int i;
; 119  :     for( i = 0; i < size; i++, table++ ) {

	xor	ebx, ebx
	test	r8d, r8d
	mov	QWORD PTR [rsp+72], rdi
	mov	esi, r8d
	mov	rbp, rcx
	mov	rdi, rdx
	jle	SHORT $LN2@FindToken
	npad	8
$LL4@FindToken:

; 120  :         if( _stricmp( *table, token ) == 0 ) {

	mov	rcx, QWORD PTR [rdi]
	mov	rdx, rbp
	call	_stricmp
	test	eax, eax
	je	SHORT $LN8@FindToken
	inc	ebx
	add	rdi, 8
	cmp	ebx, esi
	jl	SHORT $LL4@FindToken
$LN2@FindToken:

; 122  :         }
; 123  :     }
; 124  :     return( -1 );  /* Not found */

	mov	eax, -1
$LN5@FindToken:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 125  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@FindToken:

; 121  :             return( i );

	mov	eax, ebx
	jmp	SHORT $LN5@FindToken
FindToken ENDP
_TEXT	ENDS
EXTRN	QAddItem:NEAR
EXTRN	ModuleInfo:BYTE
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
sym$ = 8
AddLnameItem PROC NEAR

; 181  :     QAddItem( &ModuleInfo.g.LnameQueue, sym );

	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:ModuleInfo+32

; 182  :     //return( ++LnamesIdx );
; 183  :     return;
; 184  : 
; 185  : }

	jmp	QAddItem
AddLnameItem ENDP
_TEXT	ENDS
EXTRN	SymFree:NEAR
xdata	SEGMENT
$unwind$FreeLnameQueue DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$FreeLnameQueue DD @imagerel(FreeLnameQueue#)
	DD	@imagerel(FreeLnameQueue#+50)
	DD	@imagerel($unwind$FreeLnameQueue#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
FreeLnameQueue PROC NEAR

; 195  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 196  :     struct qnode *curr;
; 197  :     struct qnode *next;
; 198  : 
; 199  :     DebugMsg(("FreeLnameQueue enter\n" ));
; 200  :     for( curr = ModuleInfo.g.LnameQueue.head; curr; curr = next ) {

	mov	rax, QWORD PTR ModuleInfo+32
	test	rax, rax
	je	SHORT $LN2@FreeLnameQ
$LL4@FreeLnameQ:

; 201  :         next = curr->next;
; 202  :         /* the class name symbols are not part of the
; 203  :          * symbol table and hence must be freed now.
; 204  :          */
; 205  :         if( curr->sym->state == SYM_CLASS_LNAME ) {

	mov	rcx, QWORD PTR [rax+8]
	mov	rbx, QWORD PTR [rax]
	cmp	DWORD PTR [rcx+40], 11
	jne	SHORT $LN3@FreeLnameQ

; 206  :             SymFree( curr->sym );

	call	SymFree
$LN3@FreeLnameQ:

; 196  :     struct qnode *curr;
; 197  :     struct qnode *next;
; 198  : 
; 199  :     DebugMsg(("FreeLnameQueue enter\n" ));
; 200  :     for( curr = ModuleInfo.g.LnameQueue.head; curr; curr = next ) {

	test	rbx, rbx
	mov	rax, rbx
	jne	SHORT $LL4@FreeLnameQ
$LN2@FreeLnameQ:

; 207  :         }
; 208  :         LclFree( curr );
; 209  :     }
; 210  :     DebugMsg(("FreeLnameQueue exit\n" ));
; 211  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
FreeLnameQueue ENDP
_TEXT	ENDS
PUBLIC	UpdateCurrSegVars
EXTRN	SegAssumeTable:BYTE
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
UpdateCurrSegVars PROC NEAR

; 220  :     struct assume_info *info;
; 221  : 
; 222  :     DebugMsg1(("UpdateCurrSegVars(%s)\n", CurrSeg ? CurrSeg->sym.name : "NULL" ));
; 223  :     info = &(SegAssumeTable[ ASSUME_CS ]);
; 224  :     if( CurrSeg == NULL ) {

	mov	rcx, QWORD PTR ModuleInfo+432

; 225  :         info->symbol = NULL;
; 226  :         info->is_flat = FALSE;

	mov	BYTE PTR SegAssumeTable+25, 0
	test	rcx, rcx
	jne	SHORT $LN5@UpdateCurr

; 240  :         }
; 241  :         symCurSeg->string_ptr = CurrSeg->sym.name;

	mov	rax, QWORD PTR symCurSeg
	mov	QWORD PTR SegAssumeTable+16, rcx
	lea	rcx, OFFSET FLAT:$SG6009
	mov	BYTE PTR SegAssumeTable+24, 1
	mov	QWORD PTR [rax+16], rcx

; 242  :         //symPC.segment = &CurrSeg->sym; /* v2.05: removed */
; 243  :     }
; 244  :     return;
; 245  : }

	ret	0
$LN5@UpdateCurr:

; 227  :         info->error = TRUE;
; 228  :         symCurSeg->string_ptr = "";
; 229  :         //symPC.segment = NULL; /* v2.05: removed */
; 230  :     } else {
; 231  :         info->is_flat = FALSE;
; 232  :         info->error = FALSE;

	mov	BYTE PTR SegAssumeTable+24, 0

; 233  :         /* fixme: OPTION OFFSET:SEGMENT? */
; 234  :         if( CurrSeg->e.seginfo->group != NULL ) {

	mov	rax, QWORD PTR [rcx+104]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@UpdateCurr

; 235  :             info->symbol = CurrSeg->e.seginfo->group;

	mov	rax, QWORD PTR [rax]

; 236  :             if ( info->symbol == &ModuleInfo.flat_grp->sym )

	cmp	rax, QWORD PTR ModuleInfo+440
	mov	QWORD PTR SegAssumeTable+16, rax
	jne	SHORT $LN1@UpdateCurr

; 240  :         }
; 241  :         symCurSeg->string_ptr = CurrSeg->sym.name;

	mov	rax, QWORD PTR symCurSeg
	mov	BYTE PTR SegAssumeTable+25, 1
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+16], rcx

; 242  :         //symPC.segment = &CurrSeg->sym; /* v2.05: removed */
; 243  :     }
; 244  :     return;
; 245  : }

	ret	0
$LN3@UpdateCurr:

; 237  :                 info->is_flat = TRUE;
; 238  :         } else {
; 239  :             info->symbol = &CurrSeg->sym;

	mov	QWORD PTR SegAssumeTable+16, rcx
$LN1@UpdateCurr:

; 240  :         }
; 241  :         symCurSeg->string_ptr = CurrSeg->sym.name;

	mov	rax, QWORD PTR symCurSeg
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+16], rcx

; 242  :         //symPC.segment = &CurrSeg->sym; /* v2.05: removed */
; 243  :     }
; 244  :     return;
; 245  : }

	ret	0
UpdateCurrSegVars ENDP
_TEXT	ENDS
EXTRN	EmitError:NEAR
_BSS	SEGMENT
	ALIGN	8

SegStack DQ	014H DUP (?)
stkindex DD	01H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
_TEXT	SEGMENT
seg$ = 8
push_seg PROC NEAR

; 251  :     //pushitem( &CurrSeg, seg ); /* changed in v1.96 */
; 252  :     if ( stkindex >= MAX_SEG_NESTING ) {

	movsxd	r8, DWORD PTR stkindex
	cmp	r8d, 20
	jl	SHORT $LN1@push_seg

; 253  :         EmitError( NESTING_LEVEL_TOO_DEEP );

	mov	ecx, 100				; 00000064H

; 260  :     return;
; 261  : }

	jmp	EmitError
$LN1@push_seg:

; 254  :         return;
; 255  :     }
; 256  :     SegStack[stkindex] = CurrSeg;

	mov	rax, QWORD PTR ModuleInfo+432
	lea	r9, OFFSET FLAT:SegStack

; 257  :     stkindex++;
; 258  :     CurrSeg = seg;
; 259  :     UpdateCurrSegVars();

	mov	BYTE PTR SegAssumeTable+25, 0
	mov	QWORD PTR [r9+r8*8], rax
	inc	r8d
	test	rcx, rcx
	mov	DWORD PTR stkindex, r8d
	mov	QWORD PTR ModuleInfo+432, rcx
	jne	SHORT $LN8@push_seg
	mov	rax, QWORD PTR symCurSeg
	mov	QWORD PTR SegAssumeTable+16, rcx
	lea	rcx, OFFSET FLAT:$SG6009
	mov	BYTE PTR SegAssumeTable+24, 1
	mov	QWORD PTR [rax+16], rcx

; 260  :     return;
; 261  : }

	ret	0

; 257  :     stkindex++;
; 258  :     CurrSeg = seg;
; 259  :     UpdateCurrSegVars();

$LN8@push_seg:
	mov	BYTE PTR SegAssumeTable+24, 0
	mov	rax, QWORD PTR [rcx+104]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN6@push_seg
	mov	rax, QWORD PTR [rax]
	cmp	rax, QWORD PTR ModuleInfo+440
	mov	QWORD PTR SegAssumeTable+16, rax
	jne	SHORT $LN4@push_seg
	mov	rax, QWORD PTR symCurSeg
	mov	BYTE PTR SegAssumeTable+25, 1
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+16], rcx

; 260  :     return;
; 261  : }

	ret	0

; 257  :     stkindex++;
; 258  :     CurrSeg = seg;
; 259  :     UpdateCurrSegVars();

$LN6@push_seg:
	mov	QWORD PTR SegAssumeTable+16, rcx
$LN4@push_seg:
	mov	rax, QWORD PTR symCurSeg
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+16], rcx

; 260  :     return;
; 261  : }

	ret	0
push_seg ENDP
; Function compile flags: /Ogtpy
pop_seg PROC NEAR

; 267  :     //seg = popitem( &CurrSeg ); /* changed in v1.96 */
; 268  :     /* it's already checked that CurrSeg is != NULL, so
; 269  :      * stkindex must be > 0, but anyway ...
; 270  :      */
; 271  :     if ( stkindex ) {

	mov	eax, DWORD PTR stkindex
	test	eax, eax
	je	$LN7@pop_seg

; 272  :         stkindex--;

	dec	eax

; 273  :         CurrSeg = SegStack[stkindex];

	lea	rcx, OFFSET FLAT:SegStack

; 274  :         UpdateCurrSegVars();

	mov	BYTE PTR SegAssumeTable+25, 0
	mov	DWORD PTR stkindex, eax
	cdqe
	mov	rcx, QWORD PTR [rcx+rax*8]
	test	rcx, rcx
	mov	QWORD PTR ModuleInfo+432, rcx
	jne	SHORT $LN8@pop_seg
	mov	rax, QWORD PTR symCurSeg
	mov	QWORD PTR SegAssumeTable+16, rcx
	lea	rcx, OFFSET FLAT:$SG6009
	mov	BYTE PTR SegAssumeTable+24, 1
	mov	QWORD PTR [rax+16], rcx

; 275  :     }
; 276  :     return;
; 277  : }

	ret	0

; 274  :         UpdateCurrSegVars();

$LN8@pop_seg:
	mov	BYTE PTR SegAssumeTable+24, 0
	mov	rax, QWORD PTR [rcx+104]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN6@pop_seg
	mov	rax, QWORD PTR [rax]
	cmp	rax, QWORD PTR ModuleInfo+440
	mov	QWORD PTR SegAssumeTable+16, rax
	jne	SHORT $LN4@pop_seg
	mov	rax, QWORD PTR symCurSeg
	mov	BYTE PTR SegAssumeTable+25, 1
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+16], rcx

; 275  :     }
; 276  :     return;
; 277  : }

	ret	0

; 274  :         UpdateCurrSegVars();

$LN6@pop_seg:
	mov	QWORD PTR SegAssumeTable+16, rcx
$LN4@pop_seg:
	mov	rax, QWORD PTR symCurSeg
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+16], rcx
$LN7@pop_seg:

; 275  :     }
; 276  :     return;
; 277  : }

	ret	0
pop_seg	ENDP
_TEXT	ENDS
PUBLIC	GetCurrOffset
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
GetCurrOffset PROC NEAR

; 282  :     return( CurrSeg ? CurrSeg->e.seginfo->current_loc : 0 );

	mov	rax, QWORD PTR ModuleInfo+432
	test	rax, rax
	je	SHORT $LN3@GetCurrOff
	mov	rax, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rax+12]

; 283  : }

	ret	0
$LN3@GetCurrOff:

; 282  :     return( CurrSeg ? CurrSeg->e.seginfo->current_loc : 0 );

	xor	eax, eax

; 283  : }

	ret	0
GetCurrOffset ENDP
_TEXT	ENDS
PUBLIC	GetCurrSegAlign
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
GetCurrSegAlign PROC NEAR

; 306  :     if( CurrSeg == NULL )

	mov	rax, QWORD PTR ModuleInfo+432
	test	rax, rax
	jne	SHORT $LN2@GetCurrSeg

; 311  : }

	ret	0
$LN2@GetCurrSeg:

; 307  :         return( 0 );
; 308  :     if ( CurrSeg->e.seginfo->alignment == MAX_SEGALIGNMENT ) /* ABS? */

	mov	rax, QWORD PTR [rax+104]
	movzx	ecx, BYTE PTR [rax+106]
	cmp	cl, 255					; 000000ffH
	jne	SHORT $LN1@GetCurrSeg

; 309  :         return( 0x40 ); /* assume PARA alignment for AT segments */

	mov	eax, 64					; 00000040H

; 311  : }

	ret	0
$LN1@GetCurrSeg:

; 310  :     return( 1 << CurrSeg->e.seginfo->alignment );

	mov	eax, 1
	shl	eax, cl

; 311  : }

	ret	0
GetCurrSegAlign ENDP
_TEXT	ENDS
EXTRN	sym_add_table:NEAR
EXTRN	LclAlloc:NEAR
EXTRN	sym_remove_table:NEAR
EXTRN	SymTables:BYTE
EXTRN	SymCreate:NEAR
EXTRN	EmitErr:NEAR
EXTRN	SymFind:NEAR
_BSS	SEGMENT
grpdefidx DD	01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$CreateGroup DD 050e01H
	DD	09740eH
	DD	083409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$CreateGroup DD @imagerel(CreateGroup#)
	DD	@imagerel(CreateGroup#+214)
	DD	@imagerel($unwind$CreateGroup#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
CreateGroup PROC NEAR

; 315  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx

; 316  :     struct dsym    *grp;
; 317  : 
; 318  :     grp = (struct dsym *)SymSearch( name );

	call	SymFind

; 319  : 
; 320  :     if( grp == NULL || grp->sym.state == SYM_UNDEFINED ) {

	test	rax, rax
	mov	rbx, rax
	je	SHORT $LN11@CreateGrou
	mov	eax, DWORD PTR [rax+40]
	test	eax, eax
	je	SHORT $LN4@CreateGrou

; 337  :     } else if( grp->sym.state != SYM_GRP ) {

	cmp	eax, 4
	je	$LN1@CreateGrou

; 338  :         EmitErr( SYMBOL_REDEFINITION, name );

	mov	rdx, rdi
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 339  :         return( NULL );

	xor	eax, eax
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 343  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN11@CreateGrou:

; 321  :         if ( grp == NULL )
; 322  :             grp = (struct dsym *)SymCreate( name );

	mov	rcx, rdi
	call	SymCreate
	mov	rbx, rax

; 323  :         else

	jmp	SHORT $LN3@CreateGrou
$LN4@CreateGrou:

; 324  :             sym_remove_table( &SymTables[TAB_UNDEF], grp );

	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rbx
	call	sym_remove_table
$LN3@CreateGrou:

; 325  : 
; 326  :         grp->sym.state = SYM_GRP;
; 327  :         grp->e.grpinfo = LclAlloc( sizeof( struct grp_info ) );

	mov	ecx, 24
	mov	DWORD PTR [rbx+40], 4
	call	LclAlloc

; 328  :         grp->e.grpinfo->seglist = NULL;

	xor	ecx, ecx

; 329  :         //grp->e.grpinfo->grp_idx = 0;
; 330  :         //grp->e.grpinfo->lname_idx = 0;
; 331  :         grp->e.grpinfo->numseg = 0;
; 332  :         sym_add_table( &SymTables[TAB_GRP], grp );

	mov	rdx, rbx
	mov	QWORD PTR [rbx+104], rax
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR [rbx+104]
	mov	DWORD PTR [rax+16], ecx
	lea	rcx, OFFSET FLAT:SymTables+48
	call	sym_add_table

; 333  : 
; 334  :         grp->sym.list = TRUE;
; 335  :         grp->e.grpinfo->grp_idx = ++grpdefidx;

	mov	ecx, DWORD PTR grpdefidx
	mov	rax, QWORD PTR [rbx+104]
	or	BYTE PTR [rbx+49], 1
	inc	ecx

; 336  :         /* grp->e.grpinfo->lname_idx = */ AddLnameItem( &grp->sym );

	mov	rdx, rbx
	mov	DWORD PTR grpdefidx, ecx
	mov	DWORD PTR [rax+8], ecx
	lea	rcx, OFFSET FLAT:ModuleInfo+32
	call	QAddItem
$LN1@CreateGrou:

; 340  :     }
; 341  :     grp->sym.isdefined = TRUE;

	or	BYTE PTR [rbx+48], 2
	mov	rdi, QWORD PTR [rsp+72]

; 342  :     return( grp );

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+64]

; 343  : }

	add	rsp, 40					; 00000028H
	ret	0
CreateGroup ENDP
_TEXT	ENDS
EXTRN	SymAlloc:NEAR
EXTRN	memset:NEAR
xdata	SEGMENT
$unwind$CreateSegment DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$CreateSegment DD @imagerel(CreateSegment#)
	DD	@imagerel(CreateSegment#+202)
	DD	@imagerel($unwind$CreateSegment#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
seg$ = 48
name$ = 56
add_global$ = 64
CreateSegment PROC NEAR

; 347  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 348  :     if ( seg == NULL )

	test	rcx, rcx
	mov	rbx, rcx
	jne	SHORT $LN6@CreateSegm

; 349  :         seg = ( add_global ? (struct dsym *)SymCreate( name ) : (struct dsym *)SymAlloc( name ) );

	test	r8b, r8b
	mov	rcx, rdx
	je	SHORT $LN9@CreateSegm
	call	SymCreate
	mov	rbx, rax
	jmp	SHORT $LN4@CreateSegm
$LN9@CreateSegm:
	call	SymAlloc
	mov	rbx, rax
	jmp	SHORT $LN4@CreateSegm
$LN6@CreateSegm:

; 350  :     else if ( seg->sym.state == SYM_UNDEFINED )

	cmp	DWORD PTR [rcx+40], 0
	jne	SHORT $LN4@CreateSegm

; 351  :         sym_remove_table( &SymTables[TAB_UNDEF], seg );

	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table
$LN4@CreateSegm:

; 352  : 
; 353  :     if ( seg ) {

	test	rbx, rbx
	je	SHORT $LN11@CreateSegm

; 354  :         seg->sym.state = SYM_SEG;
; 355  :         seg->e.seginfo = LclAlloc( sizeof( struct seg_info ) );

	mov	ecx, 112				; 00000070H
	mov	DWORD PTR [rbx+40], 3
	call	LclAlloc

; 356  :         memset( seg->e.seginfo, 0, sizeof( struct seg_info ) );

	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+112]
	mov	rcx, rax
	mov	QWORD PTR [rbx+104], rax
	call	memset

; 357  :         seg->e.seginfo->Ofssize = ModuleInfo.defOfssize;

	movzx	eax, BYTE PTR ModuleInfo+405
	mov	r11, QWORD PTR [rbx+104]
	mov	BYTE PTR [r11+104], al

; 358  :         seg->e.seginfo->alignment = 4; /* this is PARA (2^4) */

	mov	rax, QWORD PTR [rbx+104]
	mov	BYTE PTR [rax+106], 4

; 359  :         seg->e.seginfo->combine = COMB_INVALID;

	mov	rax, QWORD PTR [rbx+104]
	and	BYTE PTR [rax+108], 248			; 000000f8H

; 360  :         /* null class name, in case none is mentioned */
; 361  :         //seg->e.seginfo->clsym = NULL;
; 362  :         seg->next = NULL;

	mov	QWORD PTR [rbx+112], 0

; 363  :         /* don't use sym_add_table(). Thus the "prev" member
; 364  :          * becomes free for another use.
; 365  :          */
; 366  :         if ( SymTables[TAB_SEG].head == NULL )

	cmp	QWORD PTR SymTables+32, 0
	jne	SHORT $LN2@CreateSegm

; 367  :             SymTables[TAB_SEG].head = SymTables[TAB_SEG].tail = seg;

	mov	QWORD PTR SymTables+32, rbx

; 370  :             SymTables[TAB_SEG].tail = seg;

	mov	QWORD PTR SymTables+40, rbx

; 371  :         }
; 372  :     }
; 373  :     return( seg );

	mov	rax, rbx

; 374  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@CreateSegm:

; 368  :         else {
; 369  :             SymTables[TAB_SEG].tail->next = seg;

	mov	rax, QWORD PTR SymTables+40
	mov	QWORD PTR [rax+112], rbx

; 370  :             SymTables[TAB_SEG].tail = seg;

	mov	QWORD PTR SymTables+40, rbx
$LN11@CreateSegm:

; 371  :         }
; 372  :     }
; 373  :     return( seg );

	mov	rax, rbx

; 374  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
CreateSegment ENDP
_TEXT	ENDS
PUBLIC	DeleteGroup
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
dir$ = 8
DeleteGroup PROC NEAR

; 380  : #if FASTMEM==0 || defined(DEBUG_OUT)
; 381  :     struct seg_item    *curr;
; 382  :     struct seg_item    *next;
; 383  : 
; 384  :     for( curr = dir->e.grpinfo->seglist; curr; curr = next ) {
; 385  :         next = curr->next;
; 386  :         DebugMsg(("DeleteGroup(%s): free seg_item=%p\n", dir->sym.name, curr ));
; 387  :         LclFree( curr );
; 388  :     }
; 389  : #endif
; 390  :     DebugMsg(("DeleteGroup(%s): extension %p will be freed\n", dir->sym.name, dir->e.grpinfo ));
; 391  :     LclFree( dir->e.grpinfo );
; 392  :     return;
; 393  : }

	ret	0
DeleteGroup ENDP
_TEXT	ENDS
PUBLIC	GrpDir
EXTRN	_strupr:NEAR
EXTRN	Parse_Pass:DWORD
EXTRN	Options:BYTE
xdata	SEGMENT
$unwind$GrpDir DD 030c01H
	DD	05f40cH
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$GrpDir DD @imagerel($LN60#)
	DD	@imagerel($LN60#+93)
	DD	@imagerel($unwind$GrpDir#)
pdata	ENDS
xdata	SEGMENT
$chain$1$GrpDir DD 020521H
	DD	0c6405H
	DD	@imagerel($LN60#)
	DD	@imagerel($LN60#+93)
	DD	@imagerel($unwind$GrpDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$GrpDir DD @imagerel($LN60#+93)
	DD	@imagerel($LN60#+129)
	DD	@imagerel($chain$1$GrpDir#)
pdata	ENDS
xdata	SEGMENT
$chain$9$GrpDir DD 0e2421H
	DD	0d7424H
	DD	0b5419H
	DD	0a3414H
	DD	06e40fH
	DD	07d40aH
	DD	08c405H
	DD	0c6400H
	DD	@imagerel($LN60#)
	DD	@imagerel($LN60#+93)
	DD	@imagerel($unwind$GrpDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$GrpDir DD @imagerel($LN60#+129)
	DD	@imagerel($LN60#+336)
	DD	@imagerel($chain$9$GrpDir#)
pdata	ENDS
xdata	SEGMENT
$chain$11$GrpDir DD 0e0021H
	DD	06e400H
	DD	07d400H
	DD	08c400H
	DD	0d7400H
	DD	0c6400H
	DD	0b5400H
	DD	0a3400H
	DD	@imagerel($LN60#)
	DD	@imagerel($LN60#+93)
	DD	@imagerel($unwind$GrpDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$11$GrpDir DD @imagerel($LN60#+336)
	DD	@imagerel($LN60#+843)
	DD	@imagerel($chain$11$GrpDir#)
pdata	ENDS
xdata	SEGMENT
$chain$12$GrpDir DD 021H
	DD	@imagerel($LN60#)
	DD	@imagerel($LN60#+93)
	DD	@imagerel($unwind$GrpDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$12$GrpDir DD @imagerel($LN60#+843)
	DD	@imagerel($LN60#+874)
	DD	@imagerel($chain$12$GrpDir#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 80
tokenarray$ = 88
GrpDir	PROC NEAR

; 399  : {

$LN60:
	sub	rsp, 72					; 00000048H

; 400  :     char        *name;
; 401  :     struct dsym *grp;
; 402  :     struct dsym *seg;
; 403  : 
; 404  :     /* GROUP directive must be at pos 1, needs a name at pos 0 */
; 405  :     if( i != 1 ) {

	cmp	ecx, 1
	mov	QWORD PTR [rsp+40], r15
	mov	r15, rdx
	je	SHORT $LN30@GrpDir

; 406  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r15+8]
	mov	r15, QWORD PTR [rsp+40]

; 504  : }

	add	rsp, 72					; 00000048H
	jmp	EmitErr
$LN30@GrpDir:

; 407  :     }
; 408  :     /* GROUP isn't valid for COFF/ELF/BIN-PE */
; 409  : #if COFF_SUPPORT || ELF_SUPPORT || PE_SUPPORT
; 410  :     if ( Options.output_format == OFORMAT_COFF
; 411  : #if ELF_SUPPORT
; 412  :         || Options.output_format == OFORMAT_ELF
; 413  : #endif
; 414  : #if PE_SUPPORT
; 415  :         || ( Options.output_format == OFORMAT_BIN && ModuleInfo.sub_format == SFORMAT_PE )
; 416  : #endif
; 417  :        ) {

	mov	eax, DWORD PTR Options+156
	cmp	eax, 2
	je	$LN28@GrpDir
	cmp	eax, 3
	je	$LN28@GrpDir
	test	eax, eax
	jne	SHORT $LN29@GrpDir
	cmp	DWORD PTR ModuleInfo+372, 2
	je	$LN28@GrpDir
$LN29@GrpDir:

; 419  :     }
; 420  : #endif
; 421  :     grp = CreateGroup( tokenarray[0].string_ptr );

	mov	rcx, QWORD PTR [rdx+8]
	mov	QWORD PTR [rsp+96], rsi
	call	CreateGroup

; 422  :     if( grp == NULL )

	test	rax, rax
	mov	rsi, rax
	jne	SHORT $LN27@GrpDir

; 423  :         return( ERROR );

	lea	eax, QWORD PTR [rsi-1]
	mov	rsi, QWORD PTR [rsp+96]
	mov	r15, QWORD PTR [rsp+40]

; 504  : }

	add	rsp, 72					; 00000048H
	ret	0
$LN27@GrpDir:
	mov	QWORD PTR [rsp+64], r12
	mov	QWORD PTR [rsp+56], r13
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+88], rbp

; 424  : 
; 425  :     i++; /* go past GROUP */

	mov	r13d, 2
	mov	QWORD PTR [rsp+104], rdi
	lea	r12, QWORD PTR [r15+64]
	lea	r14, QWORD PTR [r15+96]
	npad	3
$LL26@GrpDir:

; 426  : 
; 427  :     do {
; 428  : 
; 429  :         /* get segment name */
; 430  :         if ( tokenarray[i].token != T_ID ) {

	cmp	BYTE PTR [r12], 8
	jne	$LN45@GrpDir

; 432  :         }
; 433  :         name = tokenarray[i].string_ptr;

	mov	rbp, QWORD PTR [r12+8]

; 434  :         i++;

	inc	r13d

; 435  : 
; 436  :         seg = (struct dsym *)SymSearch( name );

	mov	rcx, rbp
	call	SymFind

; 437  :         if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	rbx, rax
	jne	$LN22@GrpDir

; 438  :             if( seg == NULL || seg->sym.state == SYM_UNDEFINED ) {

	test	rax, rax
	je	SHORT $LN20@GrpDir
	mov	eax, DWORD PTR [rax+40]
	test	eax, eax
	je	SHORT $LN20@GrpDir

; 443  :             } else if( seg->sym.state != SYM_SEG ) {

	cmp	eax, 3
	jne	$LN47@GrpDir

; 445  :             } else if( seg->e.seginfo->group != NULL &&
; 446  :                       /* v2.09: allow segments in FLAT magic group be moved to a "real" group */
; 447  :                       seg->e.seginfo->group != &ModuleInfo.flat_grp->sym &&
; 448  :                       seg->e.seginfo->group != &grp->sym ) {

	mov	rcx, QWORD PTR [rbx+104]
	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	je	$LN19@GrpDir
	cmp	rax, QWORD PTR ModuleInfo+440
	je	$LN19@GrpDir
	cmp	rax, rsi
	je	$LN19@GrpDir

; 449  :                 /* segment is in another group */
; 450  :                 DebugMsg(("GrpDir: segment >%s< is in group >%s< already\n", name, seg->e.seginfo->group->name));
; 451  :                 return( EmitErr( SEGMENT_IN_ANOTHER_GROUP, name ) );

	mov	rdx, rbp
	mov	ecx, 135				; 00000087H
	call	EmitErr
$LN59@GrpDir:
	mov	rbx, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+88]
	mov	r12, QWORD PTR [rsp+64]
	mov	r13, QWORD PTR [rsp+56]
	mov	r14, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+96]
	mov	r15, QWORD PTR [rsp+40]

; 504  : }

	add	rsp, 72					; 00000048H
	ret	0
$LN20@GrpDir:

; 439  :                 seg = CreateSegment( seg, name, TRUE );

	test	rbx, rbx
	mov	rdi, rbx
	jne	SHORT $LN38@GrpDir
	mov	rcx, rbp
	call	SymCreate
	mov	rdi, rax
	jmp	SHORT $LN36@GrpDir
$LN38@GrpDir:
	cmp	DWORD PTR [rbx+40], 0
	jne	SHORT $LN36@GrpDir
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rbx
	call	sym_remove_table
$LN36@GrpDir:
	test	rdi, rdi
	je	SHORT $LN33@GrpDir
	mov	ecx, 112				; 00000070H
	mov	DWORD PTR [rdi+40], 3
	call	LclAlloc
	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+112]
	mov	rcx, rax
	mov	QWORD PTR [rdi+104], rax
	call	memset
	movzx	eax, BYTE PTR ModuleInfo+405
	mov	r11, QWORD PTR [rdi+104]
	mov	BYTE PTR [r11+104], al
	mov	rax, QWORD PTR [rdi+104]
	mov	BYTE PTR [rax+106], 4
	mov	rax, QWORD PTR [rdi+104]
	and	BYTE PTR [rax+108], 248			; 000000f8H
	mov	QWORD PTR [rdi+112], 0
	cmp	QWORD PTR SymTables+32, 0
	jne	SHORT $LN34@GrpDir
	mov	QWORD PTR SymTables+40, rdi
	mov	QWORD PTR SymTables+32, rdi
	jmp	SHORT $LN33@GrpDir
$LN34@GrpDir:
	mov	rax, QWORD PTR SymTables+40
	mov	QWORD PTR [rax+112], rdi
	mov	QWORD PTR SymTables+40, rdi
$LN33@GrpDir:

; 440  :                 /* inherit the offset magnitude from the group */
; 441  :                 if ( grp->e.grpinfo->seglist )

	mov	rax, QWORD PTR [rsi+104]
	mov	rbx, rdi
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN19@GrpDir

; 442  :                     seg->e.seginfo->Ofssize = grp->sym.Ofssize;

	mov	rcx, QWORD PTR [rdi+104]
	movzx	eax, BYTE PTR [rsi+52]
	mov	BYTE PTR [rcx+104], al
$LN19@GrpDir:

; 452  :             }
; 453  :             /* the first segment will define the group's word size */
; 454  :             if( grp->e.grpinfo->seglist == NULL ) {

	mov	rax, QWORD PTR [rsi+104]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN14@GrpDir

; 455  :                 grp->sym.Ofssize = seg->e.seginfo->Ofssize;

	mov	rax, QWORD PTR [rbx+104]
	movzx	ecx, BYTE PTR [rax+104]
	mov	BYTE PTR [rsi+52], cl
	jmp	SHORT $LN10@GrpDir
$LN14@GrpDir:

; 456  :             } else if ( grp->sym.Ofssize != seg->e.seginfo->Ofssize ) {

	mov	rax, QWORD PTR [rbx+104]
	movzx	ecx, BYTE PTR [rax+104]
	cmp	BYTE PTR [rsi+52], cl
	je	SHORT $LN10@GrpDir

; 457  :                 return( EmitErr( GROUP_SEGMENT_SIZE_CONFLICT, grp->sym.name, seg->sym.name ) );

	mov	r8, QWORD PTR [rbx+8]
	mov	rdx, QWORD PTR [rsi+8]
	mov	ecx, 239				; 000000efH
	call	EmitErr
	jmp	$LN59@GrpDir
$LN22@GrpDir:

; 458  :             }
; 459  :         } else {
; 460  :             /* v2.04: don't check the "defined" flag in passes > 1. It's for IFDEF only! */
; 461  :             //if( seg == NULL || seg->sym.state != SYM_SEG || seg->sym.defined == FALSE ) {
; 462  :             /* v2.07: check the "segment" field instead of "defined" flag! */
; 463  :             //if( seg == NULL || seg->sym.state != SYM_SEG ) {
; 464  :             if( seg == NULL || seg->sym.state != SYM_SEG || seg->sym.segment == NULL ) {

	test	rax, rax
	je	$LN9@GrpDir
	cmp	DWORD PTR [rax+40], 3
	jne	$LN9@GrpDir
	cmp	QWORD PTR [rax+32], 0
	je	$LN9@GrpDir
$LN10@GrpDir:

; 466  :             }
; 467  :         }
; 468  : 
; 469  :         /* insert segment in group if it's not there already */
; 470  :         if ( seg->e.seginfo->group == NULL ) {

	mov	rax, QWORD PTR [rbx+104]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN6@GrpDir

; 471  :             struct seg_item    *si;
; 472  : 
; 473  :             /* set the segment's grp */
; 474  :             seg->e.seginfo->group = &grp->sym;
; 475  : 
; 476  :             si = LclAlloc( sizeof( struct seg_item ) );

	mov	ecx, 16
	mov	QWORD PTR [rax], rsi
	call	LclAlloc
	mov	r11, rax

; 477  :             si->seg = seg;

	mov	QWORD PTR [rax+8], rbx

; 478  :             si->next = NULL;

	mov	QWORD PTR [rax], 0

; 479  :             grp->e.grpinfo->numseg++;

	mov	rcx, QWORD PTR [rsi+104]
	inc	DWORD PTR [rcx+16]

; 480  : 
; 481  :             /* insert the segment at the end of linked list */
; 482  :             if( grp->e.grpinfo->seglist == NULL ) {

	mov	rax, QWORD PTR [rsi+104]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN7@GrpDir

; 483  :                 grp->e.grpinfo->seglist = si;

	mov	QWORD PTR [rax], r11

; 484  :             } else {

	jmp	SHORT $LN6@GrpDir
$LN7@GrpDir:

; 485  :                 struct seg_item *curr;
; 486  :                 curr = grp->e.grpinfo->seglist;

	mov	rax, QWORD PTR [rax]

; 487  :                 while( curr->next != NULL ) {

	cmp	QWORD PTR [rax], 0
	je	SHORT $LN4@GrpDir
	npad	6
$LL5@GrpDir:

; 488  :                     curr = curr->next;

	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LL5@GrpDir
$LN4@GrpDir:

; 489  :                 }
; 490  :                 curr->next = si;

	mov	QWORD PTR [rax], r11
$LN6@GrpDir:

; 491  :             }
; 492  :         }
; 493  : 
; 494  :         if ( i < Token_Count ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	r13d, eax
	jge	SHORT $LN46@GrpDir

; 495  :             if ( tokenarray[i].token != T_COMMA || tokenarray[i+1].token == T_FINAL ) {

	cmp	BYTE PTR [r12+32], 44			; 0000002cH
	jne	SHORT $LN51@GrpDir
	cmp	BYTE PTR [r14+32], 0
	je	SHORT $LN51@GrpDir

; 497  :             }
; 498  :             i++;

	inc	r13d
	add	r12, 64					; 00000040H
	add	r14, 64					; 00000040H

; 499  :         }
; 500  : 
; 501  :     } while ( i < Token_Count );

	cmp	r13d, eax
	jl	$LL26@GrpDir
$LN46@GrpDir:

; 502  : 
; 503  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN59@GrpDir
$LN45@GrpDir:

; 431  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, r13d
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r15+8]
	call	EmitErr
	jmp	$LN59@GrpDir
$LN47@GrpDir:

; 444  :                 return( EmitErr( SEGMENT_EXPECTED, name ) );

	mov	rdx, rbp
	mov	ecx, 131				; 00000083H
	call	EmitErr
	jmp	$LN59@GrpDir
$LN51@GrpDir:

; 496  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rdx, r13d
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r15+24]
	call	EmitErr
	jmp	$LN59@GrpDir
$LN9@GrpDir:

; 465  :                 return( EmitErr( SEGMENT_NOT_DEFINED, name ) );

	mov	rdx, rbp
	mov	ecx, 83					; 00000053H
	call	EmitErr
	jmp	$LN59@GrpDir
$LN28@GrpDir:

; 418  :         return( EmitErr( NOT_SUPPORTED_WITH_CURR_FORMAT, _strupr( tokenarray[i].string_ptr ) ) );

	mov	rcx, QWORD PTR [rdx+40]
	call	_strupr
	mov	ecx, 224				; 000000e0H
	mov	rdx, rax
	mov	r15, QWORD PTR [rsp+40]

; 504  : }

	add	rsp, 72					; 00000048H
	jmp	EmitErr
GrpDir	ENDP
_TEXT	ENDS
PUBLIC	UpdateWordSize
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
sym$ = 8
p$ = 16
UpdateWordSize PROC NEAR

; 511  :     sym->value = CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	DWORD PTR [rcx+16], eax

; 512  :     return;
; 513  : }

	ret	0
UpdateWordSize ENDP
_TEXT	ENDS
PUBLIC	SetOfssize
EXTRN	Set64Bit:NEAR
xdata	SEGMENT
$unwind$SetOfssize DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetOfssize DD @imagerel($LN6#)
	DD	@imagerel($LN6#+116)
	DD	@imagerel($unwind$SetOfssize#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
SetOfssize PROC NEAR

; 520  : {

$LN6:
	sub	rsp, 40					; 00000028H

; 521  :     if( CurrSeg == NULL ) {

	mov	rax, QWORD PTR ModuleInfo+432
	test	rax, rax
	jne	SHORT $LN3@SetOfssize

; 522  :         ModuleInfo.Ofssize = ModuleInfo.defOfssize;

	movzx	ecx, BYTE PTR ModuleInfo+405
	mov	BYTE PTR ModuleInfo+404, cl
$LN1@SetOfssize:

; 529  :         }
; 530  :     }
; 531  :     DebugMsg1(("SetOfssize: ModuleInfo.Ofssize=%u\n", ModuleInfo.Ofssize ));
; 532  : 
; 533  :     CurrWordSize = (2 << ModuleInfo.Ofssize);

	mov	eax, 2
	shl	al, cl

; 534  : 
; 535  : #if AMD64_SUPPORT
; 536  :     Set64Bit( ModuleInfo.Ofssize == USE64 );

	cmp	cl, 2
	sete	cl
	mov	BYTE PTR ModuleInfo+406, al
	call	Set64Bit

; 537  : #endif
; 538  : 
; 539  :     return( NOT_ERROR );

	xor	eax, eax

; 540  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@SetOfssize:

; 523  :     } else {
; 524  :         ModuleInfo.Ofssize = CurrSeg->e.seginfo->Ofssize;

	mov	rax, QWORD PTR [rax+104]

; 525  :         if( (uint_8)ModuleInfo.curr_cpu < min_cpu[ModuleInfo.Ofssize] ) {

	lea	r8, OFFSET FLAT:min_cpu
	movzx	ecx, BYTE PTR [rax+104]
	movzx	eax, BYTE PTR ModuleInfo+392
	cmp	ax, WORD PTR [r8+rcx*2]
	mov	BYTE PTR ModuleInfo+404, cl
	jae	SHORT $LN1@SetOfssize

; 526  :             DebugMsg(("SetOfssize, error: CurrSeg=%s, ModuleInfo.Ofssize=%u, curr_cpu=%X, defOfssize=%u\n",
; 527  :                       CurrSeg->sym.name, ModuleInfo.Ofssize, ModuleInfo.curr_cpu, ModuleInfo.defOfssize ));
; 528  :             return( EmitErr( INCOMPATIBLE_CPU_MODE_FOR_XXBIT_SEGMENT, 16 << ModuleInfo.Ofssize ) );

	mov	edx, 16
	shl	edx, cl
	mov	ecx, 132				; 00000084H

; 540  : }

	add	rsp, 40					; 00000028H
	jmp	EmitErr
SetOfssize ENDP
_TEXT	ENDS
EXTRN	omf_OutSelect:NEAR
EXTRN	omf_FlushCurrSeg:NEAR
EXTRN	write_to_file:BYTE
EXTRN	SymCmpFunc:QWORD
xdata	SEGMENT
$unwind$CloseSeg DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$CloseSeg DD @imagerel(CloseSeg#)
	DD	@imagerel(CloseSeg#+276)
	DD	@imagerel($unwind$CloseSeg#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
CloseSeg PROC NEAR

; 546  : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 547  :     //struct asym      *sym;
; 548  : 
; 549  :     DebugMsg1(("CloseSeg(%s) enter\n", name));
; 550  : 
; 551  :     if( CurrSeg == NULL || ( SymCmpFunc( CurrSeg->sym.name, name, CurrSeg->sym.name_size ) != 0 ) ) {

	mov	rcx, QWORD PTR ModuleInfo+432
	test	rcx, rcx
	je	$LN3@CloseSeg
	movzx	r8d, BYTE PTR [rcx+80]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rdx, rbx
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	jne	$LN3@CloseSeg

; 554  :     }
; 555  : 
; 556  :     DebugMsg1(("CloseSeg(%s): current ofs=%" I32_SPEC "X\n", name, CurrSeg->e.seginfo->current_loc));
; 557  : 
; 558  :     if ( write_to_file && ( Options.output_format == OFORMAT_OMF ) ) {

	cmp	BYTE PTR write_to_file, al
	je	SHORT $LN1@CloseSeg
	cmp	DWORD PTR Options+156, 1
	jne	SHORT $LN1@CloseSeg

; 559  : 
; 560  :         //if ( !omf_FlushCurrSeg() ) /* v2: error check is obsolete */
; 561  :         //    EmitErr( INTERNAL_ERROR, "CloseSeg", 1 ); /* coding error! */
; 562  :         omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 563  :         if ( Options.no_comment_data_in_code_records == FALSE )

	cmp	BYTE PTR Options+120, 0
	jne	SHORT $LN1@CloseSeg

; 564  :             omf_OutSelect( FALSE );

	xor	ecx, ecx
	call	omf_OutSelect
$LN1@CloseSeg:

; 565  :     }
; 566  : 
; 567  :     pop_seg();

	mov	eax, DWORD PTR stkindex
	test	eax, eax
	je	$LN13@CloseSeg
	dec	eax
	lea	rcx, OFFSET FLAT:SegStack
	mov	BYTE PTR SegAssumeTable+25, 0
	mov	DWORD PTR stkindex, eax
	cdqe
	mov	rcx, QWORD PTR [rcx+rax*8]
	test	rcx, rcx
	mov	QWORD PTR ModuleInfo+432, rcx
	jne	SHORT $LN14@CloseSeg
	mov	rax, QWORD PTR symCurSeg
	mov	QWORD PTR SegAssumeTable+16, rcx
	lea	rcx, OFFSET FLAT:$SG6009
	mov	BYTE PTR SegAssumeTable+24, 1
	mov	QWORD PTR [rax+16], rcx

; 568  : 
; 569  :     return( NOT_ERROR );

	xor	eax, eax

; 570  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0

; 565  :     }
; 566  : 
; 567  :     pop_seg();

$LN14@CloseSeg:
	mov	BYTE PTR SegAssumeTable+24, 0
	mov	rax, QWORD PTR [rcx+104]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN12@CloseSeg
	mov	rax, QWORD PTR [rax]
	cmp	rax, QWORD PTR ModuleInfo+440
	mov	QWORD PTR SegAssumeTable+16, rax
	jne	SHORT $LN10@CloseSeg
	mov	BYTE PTR SegAssumeTable+25, 1
	jmp	SHORT $LN10@CloseSeg
$LN12@CloseSeg:
	mov	QWORD PTR SegAssumeTable+16, rcx
$LN10@CloseSeg:
	mov	rax, QWORD PTR symCurSeg
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+16], rcx
$LN13@CloseSeg:

; 568  : 
; 569  :     return( NOT_ERROR );

	xor	eax, eax

; 570  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@CloseSeg:

; 552  :         DebugMsg(("CloseSeg(%s): nesting error, CurrSeg=%s\n", name, CurrSeg ? CurrSeg->sym.name : "(null)" ));
; 553  :         return( EmitErr( BLOCK_NESTING_ERROR, name ) );

	mov	rdx, rbx
	mov	ecx, 80					; 00000050H

; 570  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	EmitErr
CloseSeg ENDP
_TEXT	ENDS
PUBLIC	DefineFlatGroup
xdata	SEGMENT
$unwind$DefineFlatGroup DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$DefineFlatGroup DD @imagerel($LN16#)
	DD	@imagerel($LN16#+247)
	DD	@imagerel($unwind$DefineFlatGroup#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
DefineFlatGroup PROC NEAR

; 574  : {

$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H

; 575  :     if( ModuleInfo.flat_grp == NULL ) {

	mov	rax, QWORD PTR ModuleInfo+440
	test	rax, rax
	jne	$LN15@DefineFlat

; 576  :         /* can't fail because <FLAT> is a reserved word */
; 577  :         ModuleInfo.flat_grp = CreateGroup( "FLAT" );

	lea	rcx, OFFSET FLAT:$SG6153
	call	SymFind
	test	rax, rax
	mov	rbx, rax
	je	SHORT $LN14@DefineFlat
	mov	eax, DWORD PTR [rax+40]
	test	eax, eax
	je	SHORT $LN7@DefineFlat
	cmp	eax, 4
	je	$LN4@DefineFlat
	lea	rdx, OFFSET FLAT:$SG6153
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	xor	r11d, r11d
	jmp	$LN10@DefineFlat
$LN14@DefineFlat:
	lea	rcx, OFFSET FLAT:$SG6153
	call	SymCreate
	mov	rbx, rax
	jmp	SHORT $LN6@DefineFlat
$LN7@DefineFlat:
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rbx
	call	sym_remove_table
$LN6@DefineFlat:
	mov	ecx, 24
	mov	DWORD PTR [rbx+40], 4
	call	LclAlloc
	xor	r11d, r11d
	lea	rcx, OFFSET FLAT:SymTables+48
	mov	QWORD PTR [rbx+104], rax
	mov	QWORD PTR [rax], r11
	mov	rax, QWORD PTR [rbx+104]
	mov	rdx, rbx
	mov	DWORD PTR [rax+16], r11d
	call	sym_add_table
	mov	ecx, DWORD PTR grpdefidx
	mov	rax, QWORD PTR [rbx+104]
	or	BYTE PTR [rbx+49], 1
	inc	ecx
	mov	rdx, rbx
	mov	DWORD PTR grpdefidx, ecx
	mov	DWORD PTR [rax+8], ecx
	lea	rcx, OFFSET FLAT:ModuleInfo+32
	call	QAddItem
$LN4@DefineFlat:
	or	BYTE PTR [rbx+48], 2
	mov	r11, rbx
$LN10@DefineFlat:

; 578  :         ModuleInfo.flat_grp->sym.Ofssize = ModuleInfo.defOfssize;

	movzx	eax, BYTE PTR ModuleInfo+405
	mov	QWORD PTR ModuleInfo+440, r11
	mov	BYTE PTR [r11+52], al

; 579  :         DebugMsg1(("DefineFlatGroup(): Ofssize=%u\n", ModuleInfo.flat_grp->sym.Ofssize ));
; 580  :     }
; 581  :     ModuleInfo.flat_grp->sym.isdefined = TRUE; /* v2.09 */

	mov	rax, QWORD PTR ModuleInfo+440
$LN15@DefineFlat:
	or	BYTE PTR [rax+48], 2

; 582  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
DefineFlatGroup ENDP
_TEXT	ENDS
PUBLIC	GetSegIdx
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
sym$ = 8
GetSegIdx PROC NEAR

; 588  :     if( sym )

	test	rcx, rcx
	je	SHORT $LN1@GetSegIdx

; 589  :         return( ((struct dsym *)sym)->e.seginfo->seg_idx );

	mov	rax, QWORD PTR [rcx+104]
	mov	eax, DWORD PTR [rax+68]

; 591  : }

	ret	0
$LN1@GetSegIdx:

; 590  :     return( 0 );

	xor	eax, eax

; 591  : }

	ret	0
GetSegIdx ENDP
_TEXT	ENDS
PUBLIC	GetGroup
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
sym$ = 8
GetGroup PROC NEAR

; 597  :     struct dsym  *curr;
; 598  : 
; 599  :     curr = GetSegm( sym );

	mov	rax, QWORD PTR [rcx+32]

; 600  :     if( curr != NULL )

	test	rax, rax
	je	SHORT $LN1@GetGroup

; 601  :         return( curr->e.seginfo->group );

	mov	rax, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rax]

; 603  : }

	ret	0
$LN1@GetGroup:

; 602  :     return( NULL );

	xor	eax, eax

; 603  : }

	ret	0
GetGroup ENDP
_TEXT	ENDS
PUBLIC	GetSymOfssize
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
sym$ = 8
GetSymOfssize PROC NEAR

; 609  :     struct dsym   *curr;
; 610  : 
; 611  :     /* v2.07: MT_ABS has been removed */
; 612  :     //if ( sym->mem_type == MT_ABS )
; 613  :     //    return( USE16 );
; 614  : 
; 615  :     curr = GetSegm( sym );

	mov	rax, QWORD PTR [rcx+32]

; 616  :     if( curr == NULL ) {

	test	rax, rax
	jne	SHORT $LN7@GetSymOfss

; 617  :         /* v2.04: SYM_STACK added */
; 618  :         //if( sym->state == SYM_EXTERNAL || ( sym->state == SYM_INTERNAL && sym->isproc ) || sym->state == SYM_GRP )
; 619  :         if( sym->state == SYM_EXTERNAL )

	mov	eax, DWORD PTR [rcx+40]
	cmp	eax, 2
	jne	SHORT $LN6@GetSymOfss

; 620  :             return( sym->seg_ofssize );

	mov	al, BYTE PTR [rcx+55]
	and	eax, 3

; 632  : }

	ret	0
$LN6@GetSymOfss:

; 621  :         if( sym->state == SYM_STACK || sym->state == SYM_GRP )

	cmp	eax, 5
	je	SHORT $LN4@GetSymOfss
	cmp	eax, 4
	je	SHORT $LN4@GetSymOfss

; 623  :         if( sym->state == SYM_SEG  )

	cmp	eax, 3
	jne	SHORT $LN3@GetSymOfss

; 624  :             return( ((struct dsym *)sym)->e.seginfo->Ofssize );

	mov	rax, QWORD PTR [rcx+104]

; 628  :     } else {
; 629  :         return( curr->e.seginfo->Ofssize );

	movzx	eax, BYTE PTR [rax+104]

; 632  : }

	ret	0
$LN3@GetSymOfss:

; 625  :         /* v2.07: added */
; 626  :         if ( sym->mem_type == MT_EMPTY )

	cmp	DWORD PTR [rcx+44], 192			; 000000c0H
	jne	SHORT $LN2@GetSymOfss

; 627  :             return( USE16 );

	xor	eax, eax

; 632  : }

	ret	0
$LN2@GetSymOfss:

; 630  :     }
; 631  :     return( ModuleInfo.Ofssize );

	movzx	eax, BYTE PTR ModuleInfo+404

; 632  : }

	ret	0
$LN4@GetSymOfss:

; 622  :             return( sym->Ofssize );

	movzx	eax, BYTE PTR [rcx+52]

; 632  : }

	ret	0
$LN7@GetSymOfss:

; 628  :     } else {
; 629  :         return( curr->e.seginfo->Ofssize );

	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+104]

; 632  : }

	ret	0
GetSymOfssize ENDP
_TEXT	ENDS
PUBLIC	SetSymSegOfs
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
sym$ = 8
SetSymSegOfs PROC NEAR

; 637  :     sym->segment = &CurrSeg->sym;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rcx+32], rax

; 638  :     sym->offset = GetCurrOffset();

	mov	rax, QWORD PTR ModuleInfo+432
	test	rax, rax
	je	SHORT $LN5@SetSymSegO
	mov	rax, QWORD PTR [rax+104]
	mov	edx, DWORD PTR [rax+12]
	mov	DWORD PTR [rcx+16], edx

; 639  : }

	ret	0

; 638  :     sym->offset = GetCurrOffset();

$LN5@SetSymSegO:
	mov	DWORD PTR [rcx+16], 0

; 639  : }

	ret	0
SetSymSegOfs ENDP
_TEXT	ENDS
PUBLIC	TypeFromClassName
EXTRN	__ImageBase:BYTE
EXTRN	GetCodeClass:NEAR
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$TypeFromClassName DD 069801H
	DD	0283498H
	DD	0297412H
	DD	025010aH
xdata	ENDS
pdata	SEGMENT
$pdata$TypeFromClassName DD @imagerel($LN29#)
	DD	@imagerel($LN29#+475)
	DD	@imagerel($unwind$TypeFromClassName#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
uname$ = 32
seg$ = 304
clname$ = 312
TypeFromClassName PROC NEAR

; 645  : {

$LN29:
	mov	r11, rsp
	sub	rsp, 296				; 00000128H

; 646  :     int     slen;
; 647  :     char    uname[MAX_ID_LEN+1];
; 648  : 
; 649  :     if ( seg->e.seginfo->alignment == MAX_SEGALIGNMENT )

	mov	rax, QWORD PTR [rcx+104]
	mov	QWORD PTR [r11+32], rdi
	mov	rdi, rdx
	cmp	BYTE PTR [rax+106], 255			; 000000ffH
	jne	SHORT $LN16@TypeFromCl

; 650  :         return( SEGTYPE_ABS );

	mov	eax, 5
	mov	rdi, QWORD PTR [r11+32]

; 691  :     }
; 692  : }

	add	rsp, 296				; 00000128H
	ret	0
$LN16@TypeFromCl:

; 651  : 
; 652  :     /* v2.03: added */
; 653  :     if ( seg->e.seginfo->combine == COMB_STACK )

	movzx	eax, BYTE PTR [rax+108]
	and	al, 7
	cmp	al, 5
	jne	SHORT $LN15@TypeFromCl

; 654  :         return( SEGTYPE_STACK );

	mov	eax, 4
	mov	rdi, QWORD PTR [rsp+328]

; 691  :     }
; 692  : }

	add	rsp, 296				; 00000128H
	ret	0
$LN15@TypeFromCl:

; 655  : 
; 656  :     if( clname == NULL )

	test	rdx, rdx
	jne	SHORT $LN14@TypeFromCl

; 657  :         return( SEGTYPE_UNDEF );

	xor	eax, eax
	mov	rdi, QWORD PTR [rsp+328]

; 691  :     }
; 692  : }

	add	rsp, 296				; 00000128H
	ret	0
$LN14@TypeFromCl:

; 658  : 
; 659  :     if( _stricmp( clname->name, GetCodeClass() ) == 0 )

	call	GetCodeClass
	mov	rcx, QWORD PTR [rdi+8]
	mov	rdx, rax
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN13@TypeFromCl

; 660  :         return( SEGTYPE_CODE );

	mov	eax, 1
	mov	rdi, QWORD PTR [rsp+328]

; 691  :     }
; 692  : }

	add	rsp, 296				; 00000128H
	ret	0
$LN13@TypeFromCl:

; 661  : 
; 662  :     slen = clname->name_size;
; 663  :     memcpy( uname, clname->name, clname->name_size + 1 );

	mov	rdx, QWORD PTR [rdi+8]
	mov	QWORD PTR [rsp+320], rbx
	movzx	ebx, BYTE PTR [rdi+80]
	lea	eax, DWORD PTR [rbx+1]
	lea	rcx, QWORD PTR uname$[rsp]
	movsxd	r8, eax
	call	memcpy

; 664  :     _strupr( uname );

	lea	rcx, QWORD PTR uname$[rsp]
	call	_strupr

; 665  :     switch( slen ) {

	xor	ecx, ecx
	test	ebx, ebx
	lea	r11, OFFSET FLAT:__ImageBase
	js	SHORT $LN10@TypeFromCl
	cmp	ebx, 2
	jle	$LN2@TypeFromCl
	cmp	ebx, 3
	je	$LN4@TypeFromCl
	cmp	ebx, 4
	je	$LN7@TypeFromCl
$LN10@TypeFromCl:

; 666  :     default:
; 667  :     case 5:
; 668  :         if( memcmp( uname, "CONST", 6 ) == 0 )

	lea	rax, QWORD PTR uname$[rsp]
	mov	r8d, DWORD PTR [rax]
	cmp	r8d, DWORD PTR $SG6202[r11]
	jne	SHORT $LN25@TypeFromCl
	mov	r8w, WORD PTR [rax+4]
	cmp	r8w, WORD PTR $SG6202[r11+4]
	jne	SHORT $LN25@TypeFromCl
	mov	eax, ecx
	jmp	SHORT $LN26@TypeFromCl
$LN25@TypeFromCl:
	sbb	eax, eax
	sbb	eax, -1
$LN26@TypeFromCl:
	test	eax, eax
	jne	SHORT $LN9@TypeFromCl
$LN28@TypeFromCl:

; 669  :             return( SEGTYPE_DATA );

	mov	eax, 2
	jmp	$LN27@TypeFromCl
$LN9@TypeFromCl:

; 670  :         //if( memcmp( uname, "STACK", 6 ) == 0 )
; 671  :         //    return( SEGTYPE_DATA );
; 672  :         if( memcmp( uname, "DBTYP", 6 ) == 0 )

	lea	rax, QWORD PTR uname$[rsp]
	mov	r8d, DWORD PTR [rax]
	cmp	r8d, DWORD PTR $SG6204[r11]
	jne	SHORT $LN23@TypeFromCl
	mov	r8w, WORD PTR [rax+4]
	cmp	r8w, WORD PTR $SG6204[r11+4]
	jne	SHORT $LN23@TypeFromCl
	mov	eax, ecx
	jmp	SHORT $LN24@TypeFromCl
$LN23@TypeFromCl:
	sbb	eax, eax
	sbb	eax, -1
$LN24@TypeFromCl:
	test	eax, eax

; 673  :             return( SEGTYPE_DATA );

	je	SHORT $LN28@TypeFromCl

; 674  :         if( memcmp( uname, "DBSYM", 6 ) == 0 )

	lea	rax, QWORD PTR uname$[rsp]
	mov	r8d, DWORD PTR [rax]
	cmp	r8d, DWORD PTR $SG6206[r11]
	jne	SHORT $LN21@TypeFromCl
	mov	r8w, WORD PTR [rax+4]
	cmp	r8w, WORD PTR $SG6206[r11+4]
	jne	SHORT $LN21@TypeFromCl
	mov	eax, ecx
	jmp	SHORT $LN22@TypeFromCl
$LN21@TypeFromCl:
	sbb	eax, eax
	sbb	eax, -1
$LN22@TypeFromCl:
	test	eax, eax

; 675  :             return( SEGTYPE_DATA );

	je	SHORT $LN28@TypeFromCl
$LN7@TypeFromCl:

; 676  :     case 4:
; 677  :         /* v2.03: changed */
; 678  :         //if( memcmp( uname , "CODE", 5 ) == 0 )
; 679  :         //    return( SEGTYPE_CODE );
; 680  :         if( memcmp( uname + slen - 4, "CODE", 4 ) == 0 )

	movsxd	rdx, ebx
	mov	eax, DWORD PTR uname$[rsp+rdx-4]
	cmp	eax, DWORD PTR $SG6209
	jne	SHORT $LN5@TypeFromCl

; 681  :             return( SEGTYPE_CODE );

	mov	eax, 1
	jmp	SHORT $LN27@TypeFromCl
$LN5@TypeFromCl:

; 682  :         if( memcmp( uname + slen - 4, "DATA", 4 ) == 0 )

	cmp	eax, DWORD PTR $SG6211

; 683  :             return( SEGTYPE_DATA );

	je	$LN28@TypeFromCl
$LN4@TypeFromCl:

; 684  :     case 3:
; 685  :         if( memcmp( uname + slen - 3, "BSS", 3 ) == 0 )

	mov	r8w, WORD PTR uname$[rsp+rbx-3]
	lea	rdx, QWORD PTR uname$[rsp+rbx-3]
	cmp	r8w, WORD PTR $SG6214[r11]
	jne	SHORT $LN19@TypeFromCl
	mov	r8b, BYTE PTR [rdx+2]
	cmp	r8b, BYTE PTR $SG6214[r11+2]
	je	SHORT $LN20@TypeFromCl
$LN19@TypeFromCl:
	sbb	ecx, ecx
	sbb	ecx, -1
$LN20@TypeFromCl:
	test	ecx, ecx
	jne	SHORT $LN2@TypeFromCl

; 686  :             return( SEGTYPE_BSS );

	lea	eax, QWORD PTR [rcx+3]
	jmp	SHORT $LN27@TypeFromCl
$LN2@TypeFromCl:

; 687  :     case 2:
; 688  :     case 1:
; 689  :     case 0:
; 690  :         return( SEGTYPE_UNDEF );

	xor	eax, eax
$LN27@TypeFromCl:
	mov	rbx, QWORD PTR [rsp+320]
	mov	rdi, QWORD PTR [rsp+328]

; 691  :     }
; 692  : }

	add	rsp, 296				; 00000128H
	ret	0
TypeFromClassName ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$FindClass DD 092501H
	DD	097425H
	DD	08641dH
	DD	075415H
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$FindClass DD @imagerel(FindClass#)
	DD	@imagerel(FindClass#+118)
	DD	@imagerel($unwind$FindClass#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
len$ = 56
FindClass PROC NEAR

; 742  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx

; 743  :     struct qnode    *node;
; 744  : 
; 745  :     for( node = ModuleInfo.g.LnameQueue.head; node; node = node->next ) {

	mov	rbx, QWORD PTR ModuleInfo+32
	mov	QWORD PTR [rsp+56], rbp
	test	rbx, rbx
	mov	QWORD PTR [rsp+64], rsi
	mov	rbp, rcx
	mov	QWORD PTR [rsp+72], rdi
	movsxd	rsi, edx
	je	SHORT $LN2@FindClass
	npad	6
$LL4@FindClass:

; 746  :         struct asym *sym = node->sym;

	mov	rdi, QWORD PTR [rbx+8]

; 747  :         /* v2.09: use SymCmpFunc (optionally case-sensitive, depending on OPTION CASEMAP) */
; 748  :         //if( sym->state == SYM_CLASS_LNAME && ( _stricmp( sym->name, name ) == 0 ) )
; 749  :         if( sym->state == SYM_CLASS_LNAME && ( SymCmpFunc( sym->name, name, len ) == 0 ) )

	cmp	DWORD PTR [rdi+40], 11
	jne	SHORT $LN3@FindClass
	mov	rcx, QWORD PTR [rdi+8]
	mov	r8, rsi
	mov	rdx, rbp
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	SHORT $LN8@FindClass
$LN3@FindClass:

; 743  :     struct qnode    *node;
; 744  : 
; 745  :     for( node = ModuleInfo.g.LnameQueue.head; node; node = node->next ) {

	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL4@FindClass
$LN2@FindClass:

; 751  :     }
; 752  :     return( NULL );

	xor	eax, eax
$LN5@FindClass:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 753  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@FindClass:

; 750  :             return( sym );

	mov	rax, rdi
	jmp	SHORT $LN5@FindClass
FindClass ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$CreateClassLname DD 095f01H
	DD	06345fH
	DD	097416H
	DD	08640eH
	DD	075409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$CreateClassLname DD @imagerel(CreateClassLname#)
	DD	@imagerel(CreateClassLname#+199)
	DD	@imagerel($unwind$CreateClassLname#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
CreateClassLname PROC NEAR

; 761  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, rcx
	mov	QWORD PTR [rsp+72], rdi

; 762  :     struct asym *sym;
; 763  :     int len = strlen( name );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rsi
	repne scasb
	not	rcx
	dec	rcx

; 764  : 
; 765  :     /* max lname is 255 - this is an OMF restriction */
; 766  :     if( len > MAX_LNAME ) {

	cmp	ecx, 255				; 000000ffH
	mov	rbp, rcx
	jle	SHORT $LN2@CreateClas

; 767  :         EmitError( CLASS_NAME_TOO_LONG );

	lea	ecx, QWORD PTR [rax+79]
	call	EmitError

; 768  :         return( NULL );

	xor	eax, eax
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]

; 780  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@CreateClas:

; 769  :     }
; 770  : 
; 771  :     if ( !( sym = FindClass( name, len ) ) ) {

	mov	rdi, QWORD PTR ModuleInfo+32
	mov	QWORD PTR [rsp+48], rbx
	test	rdi, rdi
	je	SHORT $LN16@CreateClas
$LL8@CreateClas:
	mov	rbx, QWORD PTR [rdi+8]
	cmp	DWORD PTR [rbx+40], 11
	jne	SHORT $LN7@CreateClas
	mov	rcx, QWORD PTR [rbx+8]
	movsxd	r8, ebp
	mov	rdx, rsi
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	SHORT $LN11@CreateClas
$LN7@CreateClas:
	mov	rdi, QWORD PTR [rdi]
	test	rdi, rdi
	jne	SHORT $LL8@CreateClas
$LN16@CreateClas:

; 772  :         /* the classes aren't inserted into the symbol table
; 773  :          but they are in a queue */
; 774  :         sym = SymAlloc( name );

	mov	rcx, rsi
	call	SymAlloc

; 775  :         sym->state = SYM_CLASS_LNAME;
; 776  :         /* sym->class_lname_idx = */ AddLnameItem( sym ); /* index needed by OMF only */

	lea	rcx, OFFSET FLAT:ModuleInfo+32
	mov	rdx, rax
	mov	rbx, rax
	mov	DWORD PTR [rax+40], 11
	call	QAddItem
$LN11@CreateClas:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]

; 777  :     }
; 778  : 
; 779  :     return( sym );

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]

; 780  : }

	add	rsp, 40					; 00000028H
	ret	0
CreateClassLname ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SetSegmentClass DD 0b1f01H
	DD	04c41fH
	DD	097418H
	DD	086413H
	DD	07540eH
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetSegmentClass DD @imagerel(SetSegmentClass#)
	DD	@imagerel(SetSegmentClass#+218)
	DD	@imagerel($unwind$SetSegmentClass#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
seg$ = 48
name$ = 56
SetSegmentClass PROC NEAR

; 787  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi

; 788  :     struct asym *clsym;
; 789  : 
; 790  :     clsym = CreateClassLname( name );

	xor	eax, eax
	mov	QWORD PTR [rsp+32], r12
	mov	r12, rcx
	mov	rdi, rdx
	mov	rcx, -1
	repne scasb
	mov	rsi, rdx
	not	rcx
	dec	rcx
	cmp	ecx, 255				; 000000ffH
	mov	rbp, rcx
	jle	SHORT $LN5@SetSegment
	lea	ecx, QWORD PTR [rax+79]
	call	EmitError

; 792  :         return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN2@SetSegment

; 788  :     struct asym *clsym;
; 789  : 
; 790  :     clsym = CreateClassLname( name );

$LN5@SetSegment:
	mov	rdi, QWORD PTR ModuleInfo+32
	test	rdi, rdi
	je	SHORT $LN20@SetSegment
	npad	3
$LL11@SetSegment:
	mov	rbx, QWORD PTR [rdi+8]
	cmp	DWORD PTR [rbx+40], 11
	jne	SHORT $LN10@SetSegment
	mov	rcx, QWORD PTR [rbx+8]
	movsxd	r8, ebp
	mov	rdx, rsi
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	SHORT $LN14@SetSegment
$LN10@SetSegment:
	mov	rdi, QWORD PTR [rdi]
	test	rdi, rdi
	jne	SHORT $LL11@SetSegment
$LN20@SetSegment:
	mov	rcx, rsi
	call	SymAlloc
	lea	rcx, OFFSET FLAT:ModuleInfo+32
	mov	rdx, rax
	mov	rbx, rax
	mov	DWORD PTR [rax+40], 11
	call	QAddItem
$LN14@SetSegment:

; 791  :     if( clsym == NULL ) {

	test	rbx, rbx
	jne	SHORT $LN1@SetSegment

; 792  :         return( ERROR );

	lea	eax, QWORD PTR [rbx-1]
	jmp	SHORT $LN2@SetSegment
$LN1@SetSegment:

; 793  :     }
; 794  : #if 0 /* v2.09: Masm allows a segment's class name to change */
; 795  :     if ( seg->e.seginfo->clsym == NULL )
; 796  :         seg->e.seginfo->clsym = clsym;
; 797  :     else if ( seg->e.seginfo->clsym != clsym ) {
; 798  :         return( EmitErr( SEGDEF_CHANGED, seg->sym.name, MsgGetEx( TXT_CLASS ) ) );
; 799  :     }
; 800  : #else
; 801  :     seg->e.seginfo->clsym = clsym;

	mov	rax, QWORD PTR [r12+104]
	mov	QWORD PTR [rax+80], rbx

; 802  : #endif
; 803  :     return( NOT_ERROR );

	xor	eax, eax
$LN2@SetSegment:
	mov	r12, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 804  : }

	add	rsp, 40					; 00000028H
	ret	0
SetSegmentClass ENDP
_TEXT	ENDS
PUBLIC	CreateIntSegment
xdata	SEGMENT
$unwind$CreateIntSegment DD 0b2201H
	DD	04d422H
	DD	05c41dH
	DD	067418H
	DD	075413H
	DD	08340eH
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$CreateIntSegment DD @imagerel($LN23#)
	DD	@imagerel($LN23#+382)
	DD	@imagerel($unwind$CreateIntSegment#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 80
classname$ = 88
alignment$ = 96
Ofssize$ = 104
add_global$ = 112
CreateIntSegment PROC NEAR

; 812  : {

$LN23:
	sub	rsp, 72					; 00000048H

; 813  :     struct dsym *seg;
; 814  :     if ( add_global ) {

	cmp	BYTE PTR add_global$[rsp], 0
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+48], rdi
	mov	QWORD PTR [rsp+40], r12
	mov	QWORD PTR [rsp+32], r13
	mov	r13, rdx
	movzx	ebp, r9b
	movzx	r12d, r8b
	mov	rdi, rcx
	je	SHORT $LN8@CreateIntS

; 815  :         seg = (struct dsym *)SymSearch( name );

	call	SymFind

; 816  :         if ( seg == NULL || seg->sym.state == SYM_UNDEFINED )

	test	rax, rax
	mov	rbx, rax
	je	SHORT $LN6@CreateIntS
	mov	eax, DWORD PTR [rax+40]
	test	eax, eax
	je	SHORT $LN6@CreateIntS

; 818  :         else if ( seg->sym.state != SYM_SEG ) {

	cmp	eax, 3
	je	$LN11@CreateIntS

; 819  :             EmitErr( SYMBOL_REDEFINITION, name );

	mov	rdx, rdi
	mov	ecx, 143				; 0000008fH
	call	EmitErr
$LN2@CreateIntS:

; 838  :     }
; 839  :     return( NULL );

	xor	eax, eax
$LN9@CreateIntS:
	mov	r13, QWORD PTR [rsp+32]
	mov	r12, QWORD PTR [rsp+40]
	mov	rdi, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+64]

; 840  : }

	add	rsp, 72					; 00000048H
	ret	0
$LN6@CreateIntS:

; 817  :             seg = CreateSegment( seg, name, add_global );

	movzx	r8d, BYTE PTR add_global$[rsp]
	mov	rdx, rdi
	mov	rcx, rbx
	call	CreateSegment
	mov	rbx, rax

; 820  :             return( NULL );
; 821  :         }
; 822  :     } else

	jmp	$LN11@CreateIntS
$LN8@CreateIntS:

; 823  :         seg = CreateSegment( NULL, name, FALSE );

	call	SymAlloc
	test	rax, rax
	mov	rbx, rax
	je	SHORT $LN11@CreateIntS
	mov	ecx, 112				; 00000070H
	mov	DWORD PTR [rax+40], 3
	call	LclAlloc
	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+112]
	mov	rcx, rax
	mov	QWORD PTR [rbx+104], rax
	call	memset
	movzx	eax, BYTE PTR ModuleInfo+405
	mov	r11, QWORD PTR [rbx+104]
	mov	BYTE PTR [r11+104], al
	mov	rax, QWORD PTR [rbx+104]
	mov	BYTE PTR [rax+106], 4
	mov	rax, QWORD PTR [rbx+104]
	and	BYTE PTR [rax+108], 248			; 000000f8H
	mov	QWORD PTR [rbx+112], 0
	cmp	QWORD PTR SymTables+32, 0
	jne	SHORT $LN12@CreateIntS
	mov	QWORD PTR SymTables+40, rbx
	mov	QWORD PTR SymTables+32, rbx
	jmp	SHORT $LN11@CreateIntS
$LN12@CreateIntS:
	mov	rax, QWORD PTR SymTables+40
	mov	QWORD PTR [rax+112], rbx
	mov	QWORD PTR SymTables+40, rbx
$LN11@CreateIntS:

; 824  :     if ( seg ) {

	test	rbx, rbx
	je	$LN2@CreateIntS

; 825  :         /* v2.12: check 'isdefined' instead of 'lname_idx' */
; 826  :         //if( seg->e.seginfo->lname_idx == 0 ) {
; 827  :         if( seg->sym.isdefined == FALSE ) {

	test	BYTE PTR [rbx+48], 2
	jne	SHORT $LN1@CreateIntS

; 828  :             seg->e.seginfo->seg_idx = ++ModuleInfo.g.num_segs;

	mov	ecx, DWORD PTR ModuleInfo+8

; 829  :             /* seg->e.seginfo->lname_idx = */ AddLnameItem( &seg->sym );

	mov	rdx, rbx
	inc	ecx
	mov	DWORD PTR ModuleInfo+8, ecx
	mov	rax, QWORD PTR [rbx+104]
	mov	DWORD PTR [rax+68], ecx
	lea	rcx, OFFSET FLAT:ModuleInfo+32
	call	QAddItem

; 830  :             seg->sym.isdefined = TRUE; /* v2.12: added */

	or	BYTE PTR [rbx+48], 2
$LN1@CreateIntS:

; 831  :         }
; 832  :         seg->e.seginfo->internal = TRUE; /* segment has private buffer */

	mov	rax, QWORD PTR [rbx+104]

; 833  :         seg->sym.segment = &seg->sym;
; 834  :         seg->e.seginfo->alignment = alignment;
; 835  :         seg->e.seginfo->Ofssize = Ofssize;
; 836  :         SetSegmentClass( seg, classname );

	mov	rdx, r13
	mov	rcx, rbx
	or	BYTE PTR [rax+107], 16
	mov	rax, QWORD PTR [rbx+104]
	mov	QWORD PTR [rbx+32], rbx
	mov	BYTE PTR [rax+106], r12b
	mov	rax, QWORD PTR [rbx+104]
	mov	BYTE PTR [rax+104], bpl
	call	SetSegmentClass

; 837  :         return( &seg->sym );

	mov	rax, rbx
	jmp	$LN9@CreateIntS
CreateIntSegment ENDP
_TEXT	ENDS
PUBLIC	EndsDir
EXTRN	LstWrite:NEAR
EXTRN	EndstructDirective:NEAR
EXTRN	CurrStruct:QWORD
xdata	SEGMENT
$unwind$EndsDir DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$EndsDir DD @imagerel($LN14#)
	DD	@imagerel($LN14#+247)
	DD	@imagerel($unwind$EndsDir#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
EndsDir	PROC NEAR

; 846  : {

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H

; 847  :     if( CurrStruct != NULL ) {

	cmp	QWORD PTR CurrStruct, 0
	mov	rbx, rdx
	je	SHORT $LN6@EndsDir

; 865  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	EndstructDirective
$LN6@EndsDir:

; 848  :         return( EndstructDirective( i, tokenarray ) );
; 849  :     }
; 850  :     /* a label must precede ENDS */
; 851  :     if( i != 1 ) {

	cmp	ecx, 1
	je	SHORT $LN5@EndsDir

; 852  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbx+8]

; 865  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	EmitErr
$LN5@EndsDir:

; 853  :     }
; 854  :     if ( Parse_Pass != PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN3@EndsDir

; 855  :         if ( ModuleInfo.list )

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN3@EndsDir

; 856  :             LstWrite( LSTTYPE_LABEL, 0, NULL );

	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+7]
	call	LstWrite
$LN3@EndsDir:

; 857  :     }
; 858  :     if ( CloseSeg( tokenarray[0].string_ptr ) == ERROR )

	mov	rcx, QWORD PTR [rbx+8]
	call	CloseSeg
	cmp	eax, -1
	jne	SHORT $LN2@EndsDir

; 865  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@EndsDir:

; 859  :         return( ERROR );
; 860  :     i++;
; 861  :     if ( tokenarray[i].token != T_FINAL ) {

	cmp	BYTE PTR [rbx+64], 0
	je	SHORT $LN1@EndsDir

; 862  :         EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	mov	rdx, QWORD PTR [rbx+72]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN1@EndsDir:

; 863  :     }
; 864  :     return( SetOfssize() );

	mov	rax, QWORD PTR ModuleInfo+432
	test	rax, rax
	jne	SHORT $LN11@EndsDir
	movzx	ecx, BYTE PTR ModuleInfo+405
	mov	BYTE PTR ModuleInfo+404, cl
$LN9@EndsDir:
	mov	eax, 2
	shl	al, cl
	cmp	cl, 2
	sete	cl
	mov	BYTE PTR ModuleInfo+406, al
	call	Set64Bit
	xor	eax, eax

; 865  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0

; 863  :     }
; 864  :     return( SetOfssize() );

$LN11@EndsDir:
	mov	rax, QWORD PTR [rax+104]
	lea	r8, OFFSET FLAT:min_cpu
	movzx	ecx, BYTE PTR [rax+104]
	movzx	eax, BYTE PTR ModuleInfo+392
	cmp	ax, WORD PTR [r8+rcx*2]
	mov	BYTE PTR ModuleInfo+404, cl
	jae	SHORT $LN9@EndsDir
	mov	edx, 16
	shl	edx, cl
	mov	ecx, 132				; 00000084H

; 865  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	EmitErr
EndsDir	ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SetCurrSeg DD 051201H
	DD	097412H
	DD	08340dH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetCurrSeg DD @imagerel(SetCurrSeg#)
	DD	@imagerel(SetCurrSeg#+283)
	DD	@imagerel($unwind$SetCurrSeg#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
SetCurrSeg PROC NEAR

; 871  : {

	sub	rsp, 40					; 00000028H

; 872  :     struct asym *sym;
; 873  : 
; 874  :     sym = SymSearch( tokenarray[0].string_ptr );

	mov	rcx, QWORD PTR [rdx+8]
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rdx
	call	SymFind

; 875  :     DebugMsg1(("SetCurrSeg(%s) sym=%p\n", tokenarray[0].string_ptr, sym));
; 876  :     if ( sym == NULL || sym->state != SYM_SEG ) {

	test	rax, rax
	mov	rbx, rax
	je	$LN4@SetCurrSeg
	cmp	DWORD PTR [rax+40], 3
	jne	$LN4@SetCurrSeg

; 878  :     }
; 879  :     /* v2.04: added */
; 880  :     sym->isdefined = TRUE;

	or	BYTE PTR [rax+48], 2

; 881  :     if ( CurrSeg && Options.output_format == OFORMAT_OMF ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	je	SHORT $LN2@SetCurrSeg
	cmp	DWORD PTR Options+156, 1
	jne	SHORT $LN2@SetCurrSeg

; 882  :         omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 883  :         if ( Options.no_comment_data_in_code_records == FALSE )

	cmp	BYTE PTR Options+120, 0
	jne	SHORT $LN2@SetCurrSeg

; 884  :             omf_OutSelect( FALSE );

	xor	ecx, ecx
	call	omf_OutSelect
$LN2@SetCurrSeg:

; 885  :     }
; 886  :     push_seg( (struct dsym *)sym );

	mov	rcx, rbx
	call	push_seg

; 887  : 
; 888  :     if ( ModuleInfo.list )

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN1@SetCurrSeg

; 889  :         LstWrite( LSTTYPE_LABEL, 0, NULL );

	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+7]
	call	LstWrite
$LN1@SetCurrSeg:

; 890  : 
; 891  :     return( SetOfssize() );

	mov	rax, QWORD PTR ModuleInfo+432
	test	rax, rax
	jne	SHORT $LN10@SetCurrSeg
	movzx	ecx, BYTE PTR ModuleInfo+405
	mov	BYTE PTR ModuleInfo+404, cl
$LN8@SetCurrSeg:
	mov	eax, 2
	shl	al, cl
	cmp	cl, 2
	sete	cl
	mov	BYTE PTR ModuleInfo+406, al
	call	Set64Bit
	xor	eax, eax
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 892  : }

	add	rsp, 40					; 00000028H
	ret	0

; 890  : 
; 891  :     return( SetOfssize() );

$LN10@SetCurrSeg:
	mov	rax, QWORD PTR [rax+104]
	lea	r8, OFFSET FLAT:min_cpu
	movzx	ecx, BYTE PTR [rax+104]
	movzx	eax, BYTE PTR ModuleInfo+392
	cmp	ax, WORD PTR [r8+rcx*2]
	mov	BYTE PTR ModuleInfo+404, cl
	jae	SHORT $LN8@SetCurrSeg
	mov	edx, 16
	shl	edx, cl
	mov	ecx, 132				; 00000084H
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 892  : }

	add	rsp, 40					; 00000028H
	jmp	EmitErr
$LN4@SetCurrSeg:

; 877  :         return( EmitErr( SEGMENT_NOT_DEFINED, tokenarray[0].string_ptr ) );

	mov	rdx, QWORD PTR [rdi+8]
	mov	ecx, 83					; 00000053H
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 892  : }

	add	rsp, 40					; 00000028H
	jmp	EmitErr
SetCurrSeg ENDP
; Function compile flags: /Ogtpy
dir$ = 8
UnlinkSeg PROC NEAR

; 897  :     struct dsym *curr;
; 898  :     struct dsym *prev;
; 899  :     for ( curr = SymTables[TAB_SEG].head, prev = NULL; curr; prev = curr, curr = curr->next )

	mov	rdx, QWORD PTR SymTables+32
	xor	r8d, r8d
	test	rdx, rdx
	je	SHORT $LN1@UnlinkSeg
	npad	1
$LL7@UnlinkSeg:

; 900  :         if ( curr == dir ) {

	cmp	rdx, rcx
	je	SHORT $LN11@UnlinkSeg
	mov	r8, rdx
	mov	rdx, QWORD PTR [rdx+112]
	test	rdx, rdx
	jne	SHORT $LL7@UnlinkSeg

; 909  :                 SymTables[TAB_SEG].tail = prev;
; 910  :             break;
; 911  :         }
; 912  :     return;
; 913  : }

	ret	0
$LN11@UnlinkSeg:

; 901  :             /* if segment is first, set a new head */
; 902  :             if ( prev == NULL )

	test	r8, r8

; 903  :                 SymTables[TAB_SEG].head = curr->next;

	mov	rax, QWORD PTR [rdx+112]
	jne	SHORT $LN3@UnlinkSeg
	mov	QWORD PTR SymTables+32, rax

; 904  :             else

	jmp	SHORT $LN2@UnlinkSeg
$LN3@UnlinkSeg:

; 905  :                 prev->next = curr->next;

	mov	QWORD PTR [r8+112], rax
$LN2@UnlinkSeg:

; 906  : 
; 907  :             /* if segment is last, set a new tail */
; 908  :             if ( curr->next == NULL )

	mov	rax, QWORD PTR SymTables+40
	cmp	QWORD PTR [rdx+112], 0
	cmove	rax, r8
	mov	QWORD PTR SymTables+40, rax
$LN1@UnlinkSeg:

; 909  :                 SymTables[TAB_SEG].tail = prev;
; 910  :             break;
; 911  :         }
; 912  :     return;
; 913  : }

	ret	0
UnlinkSeg ENDP
_TEXT	ENDS
PUBLIC	SegmentDir
EXTRN	MsgGetEx:NEAR
EXTRN	EvalOperand:NEAR
EXTRN	memcmp:NEAR
xdata	SEGMENT
$unwind$SegmentDir DD 0a2301H
	DD	017f423H
	DD	018e41aH
	DD	019d416H
	DD	0203412H
	DD	01d010eH
xdata	ENDS
pdata	SEGMENT
$pdata$SegmentDir DD @imagerel($LN149#)
	DD	@imagerel($LN149#+101)
	DD	@imagerel($unwind$SegmentDir#)
pdata	ENDS
xdata	SEGMENT
$chain$6$SegmentDir DD 061f21H
	DD	01ac41fH
	DD	01b7410H
	DD	01c6408H
	DD	@imagerel($LN149#)
	DD	@imagerel($LN149#+101)
	DD	@imagerel($unwind$SegmentDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$SegmentDir DD @imagerel($LN149#+101)
	DD	@imagerel($LN149#+514)
	DD	@imagerel($chain$6$SegmentDir#)
pdata	ENDS
xdata	SEGMENT
$chain$7$SegmentDir DD 020821H
	DD	0215408H
	DD	@imagerel($LN149#+101)
	DD	@imagerel($LN149#+514)
	DD	@imagerel($chain$6$SegmentDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$SegmentDir DD @imagerel($LN149#+514)
	DD	@imagerel($LN149#+2588)
	DD	@imagerel($chain$7$SegmentDir#)
pdata	ENDS
xdata	SEGMENT
$chain$8$SegmentDir DD 021H
	DD	@imagerel($LN149#+101)
	DD	@imagerel($LN149#+514)
	DD	@imagerel($chain$6$SegmentDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$SegmentDir DD @imagerel($LN149#+2588)
	DD	@imagerel($LN149#+3037)
	DD	@imagerel($chain$8$SegmentDir#)
pdata	ENDS
xdata	SEGMENT
$chain$9$SegmentDir DD 021H
	DD	@imagerel($LN149#)
	DD	@imagerel($LN149#+101)
	DD	@imagerel($unwind$SegmentDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$SegmentDir DD @imagerel($LN149#+3037)
	DD	@imagerel($LN149#+3077)
	DD	@imagerel($chain$9$SegmentDir#)
pdata	ENDS
xdata	SEGMENT
$chain$10$SegmentDir DD 060021H
	DD	01ac400H
	DD	01b7400H
	DD	01c6400H
	DD	@imagerel($LN149#)
	DD	@imagerel($LN149#+101)
	DD	@imagerel($unwind$SegmentDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$10$SegmentDir DD @imagerel($LN149#+3077)
	DD	@imagerel($LN149#+3132)
	DD	@imagerel($chain$10$SegmentDir#)
pdata	ENDS
xdata	SEGMENT
$chain$11$SegmentDir DD 080021H
	DD	01ac400H
	DD	01b7400H
	DD	01c6400H
	DD	0215400H
	DD	@imagerel($LN149#)
	DD	@imagerel($LN149#+101)
	DD	@imagerel($unwind$SegmentDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$11$SegmentDir DD @imagerel($LN149#+3132)
	DD	@imagerel($LN149#+3372)
	DD	@imagerel($chain$11$SegmentDir#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
is_old$1$ = 48
oldOfssize$ = 49
oldcombine$ = 50
oldalign$ = 51
initstate$1$ = 52
sym$1$ = 56
opndx$ = 64
i$ = 240
tokenarray$ = 248
SegmentDir PROC NEAR

; 919  : {

$LN149:
	mov	DWORD PTR [rsp+8], ecx
	mov	rax, rsp
	sub	rsp, 232				; 000000e8H
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax-32], r13
	mov	QWORD PTR [rax-40], r14

; 920  :     char                is_old = FALSE;
; 921  :     char                *token;
; 922  :     int                 typeidx;
; 923  :     const struct typeinfo *type;          /* type of option */
; 924  :     int                 temp;
; 925  :     int                 temp2;
; 926  :     unsigned            initstate = 0;  /* flags for attribute initialization */

	xor	r14d, r14d
	xor	bl, bl
	mov	QWORD PTR [rax-48], r15

; 927  :     //unsigned char       oldreadonly;    /* readonly value of a defined segment */
; 928  :     //unsigned char       oldsegtype;
; 929  :     unsigned char       oldOfssize;
; 930  :     char                oldalign;
; 931  :     char                oldcombine;
; 932  :     //struct asym         *oldclsym;
; 933  :     uint_8              newcharacteristics = 0;

	xor	r15b, r15b

; 934  :     struct dsym         *dir;
; 935  :     char                *name;
; 936  :     struct asym         *sym;
; 937  :     struct expr         opndx;
; 938  : 
; 939  :     if ( Parse_Pass != PASS_1 )

	cmp	DWORD PTR Parse_Pass, r14d
	mov	r13, rdx
	mov	BYTE PTR is_old$1$[rsp], bl
	mov	DWORD PTR initstate$1$[rsp], r14d
	je	SHORT $LN88@SegmentDir

; 940  :         return( SetCurrSeg( i, tokenarray ) );

	call	SetCurrSeg
	jmp	$LN89@SegmentDir
$LN88@SegmentDir:

; 941  : 
; 942  :     if( i != 1 ) {

	cmp	ecx, 1
	je	SHORT $LN87@SegmentDir

; 943  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r13+8]
	call	EmitErr
	jmp	$LN89@SegmentDir
$LN87@SegmentDir:
	mov	QWORD PTR [rsp+224], rsi
	mov	QWORD PTR [rsp+216], rdi

; 944  :     }
; 945  : 
; 946  :     name = tokenarray[0].string_ptr;

	mov	rdi, QWORD PTR [rdx+8]

; 947  : 
; 948  :     DebugMsg1(("SegmentDir(%s) enter: ModuleInfo.Ofssize=%u, num_seg=%u\n", name, ModuleInfo.Ofssize, ModuleInfo.g.num_segs ));
; 949  : 
; 950  :     /* See if the segment is already defined */
; 951  :     sym = SymSearch( name );

	mov	rcx, rdi
	mov	QWORD PTR [rsp+208], r12
	call	SymFind

; 952  :     if( sym == NULL || sym->state == SYM_UNDEFINED ) {

	test	rax, rax
	mov	r12, rax
	mov	QWORD PTR sym$1$[rsp], rax
	je	$LN85@SegmentDir
	mov	ecx, DWORD PTR [rax+40]
	test	ecx, ecx
	je	$LN85@SegmentDir

; 957  :         dir = (struct dsym *)sym;
; 958  :         /* v2.12: seg_idx member now set AFTER parsing is done */
; 959  :         //dir->e.seginfo->seg_idx = ++ModuleInfo.g.num_segs;
; 960  : #if 0 //COFF_SUPPORT || ELF_SUPPORT /* v2.09: removed, since not Masm-compatible */
; 961  :         if ( Options.output_format == OFORMAT_COFF
; 962  : #if ELF_SUPPORT
; 963  :             || Options.output_format == OFORMAT_ELF
; 964  : #endif
; 965  :            ) {
; 966  :             char *p;
; 967  :             if ( p = strchr(sym->name, '$') ) {
; 968  :                 char buffer[MAX_ID_LEN+1];
; 969  :                 struct dsym *dir2;
; 970  :                 /* initialize segment with values from the one without suffix */
; 971  :                 memcpy( buffer, sym->name, p - sym->name );
; 972  :                 buffer[p - sym->name] = NULLC;
; 973  :                 if ( ( dir2 = (struct dsym *)SymSearch( buffer ) ) && dir2->sym.state == SYM_SEG ) {
; 974  :                     dir->e.seginfo->segtype  = dir2->e.seginfo->segtype;
; 975  :                     dir->e.seginfo->combine  = dir2->e.seginfo->combine;
; 976  :                     dir->e.seginfo->readonly = dir2->e.seginfo->readonly;
; 977  :                     dir->e.seginfo->Ofssize  = dir2->e.seginfo->Ofssize;
; 978  :                     dir->e.seginfo->alignment= dir2->e.seginfo->alignment;
; 979  :                     dir->e.seginfo->characteristics = dir2->e.seginfo->characteristics;
; 980  :                     dir->e.seginfo->clsym           = dir2->e.seginfo->clsym;
; 981  :                 }
; 982  :             }
; 983  :         }
; 984  : #endif
; 985  :     } else if ( sym->state == SYM_SEG ) { /* segment already defined? */

	cmp	ecx, 3
	jne	SHORT $LN83@SegmentDir

; 986  :         
; 987  :         dir = (struct dsym *)sym;
; 988  :         /* v2.12: check 'isdefined' instead of lname_idx */
; 989  :         //if( dir->e.seginfo->lname_idx == 0 ) {
; 990  :         if( sym->isdefined == FALSE ) {

	test	BYTE PTR [rax+48], 2
	mov	rsi, rax
	jne	SHORT $LN82@SegmentDir

; 991  :             /* segment was forward referenced (in a GROUP directive), but not really set up */
; 992  :             /* the segment list is to be sorted.
; 993  :              * So unlink the segment and add it at the end.
; 994  :              */
; 995  :             UnlinkSeg( dir );

	mov	rcx, rax
	call	UnlinkSeg

; 996  :             /* v2.12: seg_idx member now set AFTER parsing is done */
; 997  :             //dir->e.seginfo->seg_idx = ++ModuleInfo.g.num_segs;
; 998  :             dir->next = NULL;

	mov	QWORD PTR [rcx+112], r14

; 999  :             if ( SymTables[TAB_SEG].head == NULL )

	cmp	QWORD PTR SymTables+32, r14
	jne	SHORT $LN81@SegmentDir

; 1000 :                 SymTables[TAB_SEG].head = SymTables[TAB_SEG].tail = dir;

	mov	QWORD PTR SymTables+40, rcx
	mov	QWORD PTR SymTables+32, rcx

; 1001 :             else {

	jmp	$LN78@SegmentDir
$LN81@SegmentDir:

; 1002 :                 SymTables[TAB_SEG].tail->next = dir;

	mov	rax, QWORD PTR SymTables+40
	mov	QWORD PTR [rax+112], r12

; 1003 :                 SymTables[TAB_SEG].tail = dir;

	mov	QWORD PTR SymTables+40, r12

; 1004 :             }
; 1005 :         } else {

	jmp	$LN78@SegmentDir
$LN82@SegmentDir:

; 1006 :             is_old = TRUE;
; 1007 :             //oldreadonly = dir->e.seginfo->readonly;
; 1008 :             //oldsegtype  = dir->e.seginfo->segtype;
; 1009 :             oldOfssize  = dir->e.seginfo->Ofssize;

	mov	rcx, QWORD PTR [rax+104]
	mov	bl, 1
	movzx	eax, BYTE PTR [rcx+104]
	mov	BYTE PTR is_old$1$[rsp], bl
	mov	BYTE PTR oldOfssize$[rsp], al

; 1010 :             oldalign    = dir->e.seginfo->alignment;

	movzx	eax, BYTE PTR [rcx+106]
	mov	BYTE PTR oldalign$[rsp], al

; 1011 :             oldcombine  = dir->e.seginfo->combine;

	movzx	eax, BYTE PTR [rcx+108]
	and	al, 7
	mov	BYTE PTR oldcombine$[rsp], al

; 1012 :             /* v2.09: class isn't checked anymore, and characteristics is handled differently */
; 1013 :             //oldcharacteristics = dir->e.seginfo->characteristics;
; 1014 :             //oldclsym    = dir->e.seginfo->clsym;
; 1015 :         }
; 1016 : 
; 1017 :     } else {

	jmp	$LN78@SegmentDir
$LN83@SegmentDir:

; 1018 :         /* symbol is different kind, error */
; 1019 :         DebugMsg(("SegmentDir(%s): symbol redefinition\n", name ));
; 1020 :         return( EmitErr( SYMBOL_REDEFINITION, name ) );

	mov	rdx, rdi
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN148@SegmentDir
$LN85@SegmentDir:

; 953  : 
; 954  :         /* segment is not defined (yet) */
; 955  :         sym = (struct asym *)CreateSegment( (struct dsym *)sym, name, TRUE );

	test	rax, rax
	mov	rsi, rax
	jne	SHORT $LN98@SegmentDir
	mov	rcx, rdi
	call	SymCreate
	mov	rsi, rax
	jmp	SHORT $LN96@SegmentDir
$LN98@SegmentDir:
	cmp	DWORD PTR [rax+40], r14d
	jne	SHORT $LN96@SegmentDir
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rax
	call	sym_remove_table
$LN96@SegmentDir:
	test	rsi, rsi
	je	SHORT $LN93@SegmentDir
	mov	ecx, 112				; 00000070H
	mov	DWORD PTR [rsi+40], 3
	call	LclAlloc
	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+112]
	mov	rcx, rax
	mov	QWORD PTR [rsi+104], rax
	call	memset
	movzx	eax, BYTE PTR ModuleInfo+405
	mov	rdx, QWORD PTR [rsi+104]
	mov	BYTE PTR [rdx+104], al
	mov	rax, QWORD PTR [rsi+104]
	mov	BYTE PTR [rax+106], 4
	mov	rax, QWORD PTR [rsi+104]
	and	BYTE PTR [rax+108], 248			; 000000f8H
	mov	QWORD PTR [rsi+112], r14
	cmp	QWORD PTR SymTables+32, r14
	jne	SHORT $LN94@SegmentDir
	mov	QWORD PTR SymTables+40, rsi
	mov	QWORD PTR SymTables+32, rsi
	jmp	SHORT $LN93@SegmentDir
$LN94@SegmentDir:
	mov	rax, QWORD PTR SymTables+40
	mov	QWORD PTR [rax+112], rsi
	mov	QWORD PTR SymTables+40, rsi
$LN93@SegmentDir:

; 956  :         sym->list = TRUE; /* always list segments */

	or	BYTE PTR [rsi+49], 1
	mov	r12, rsi
	mov	QWORD PTR sym$1$[rsp], rsi
$LN78@SegmentDir:

; 1021 :     }
; 1022 : 
; 1023 :     i++; /* go past SEGMENT */

	mov	eax, DWORD PTR i$[rsp]

; 1024 : 
; 1025 :     for( ; i < Token_Count; i++ ) {

	lea	rdi, OFFSET FLAT:__ImageBase
	inc	eax
	cmp	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rsp], eax
	jge	$LN75@SegmentDir
	lea	r12, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [rsp+264], rbp
	npad	6
$LL77@SegmentDir:

; 1026 :         token = tokenarray[i].string_ptr;

	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5

; 1027 :         DebugMsg1(("SegmentDir(%s): i=%u, string=%s token=%X\n", name, i, token, tokenarray[i].token ));
; 1028 :         if( tokenarray[i].token == T_STRING ) {

	cmp	BYTE PTR [rax+r13], 9
	mov	rbp, QWORD PTR [rax+r13+8]
	jne	SHORT $LN74@SegmentDir

; 1029 : 
; 1030 :             /* the class name - the only token which is of type STRING */
; 1031 :             /* string must be delimited by [double]quotes */
; 1032 :             if ( tokenarray[i].string_delim != '"' &&
; 1033 :                 tokenarray[i].string_delim != '\'' ) {

	movzx	ecx, BYTE PTR [rax+r13+1]
	cmp	cl, 34					; 00000022H
	je	SHORT $LN73@SegmentDir
	cmp	cl, 39					; 00000027H
	je	SHORT $LN73@SegmentDir

; 1034 :                 EmitErr( SYNTAX_ERROR_EX, token );

	mov	rdx, rbp
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 1035 :                 continue;

	jmp	$LN76@SegmentDir
$LN73@SegmentDir:

; 1036 :             }
; 1037 :             /* remove the quote delimiters */
; 1038 :             token++;
; 1039 :             *(token+tokenarray[i].stringlen) = NULLC;

	mov	eax, DWORD PTR [rax+r13+16]

; 1040 : 
; 1041 :             SetSegmentClass( dir, token );

	lea	rdx, QWORD PTR [rbp+1]
	mov	rcx, rsi
	mov	BYTE PTR [rax+rbp+1], r14b
	call	SetSegmentClass

; 1042 : 
; 1043 :             DebugMsg1(("SegmentDir(%s): class found: %s\n", name, token ));
; 1044 :             continue;

	jmp	$LN76@SegmentDir
$LN74@SegmentDir:

; 1045 :         }
; 1046 : 
; 1047 :         /* check the rest of segment attributes.
; 1048 :          */
; 1049 :         typeidx = FindToken( token, SegAttrToken, sizeof( SegAttrToken )/sizeof( SegAttrToken[0] ) );

	lea	rbx, OFFSET FLAT:SegAttrToken
	mov	rdi, r14
	npad	1
$LL106@SegmentDir:
	mov	rcx, QWORD PTR [rbx]
	mov	rdx, rbp
	call	_stricmp
	test	eax, eax
	je	SHORT $LN107@SegmentDir
	inc	rdi
	add	rbx, 8
	cmp	rdi, 27
	jl	SHORT $LL106@SegmentDir
	jmp	SHORT $LN133@SegmentDir
$LN107@SegmentDir:

; 1050 :         if( typeidx < 0 ) {

	test	rdi, rdi
	jns	SHORT $LN72@SegmentDir
$LN133@SegmentDir:

; 1051 :             EmitErr( UNKNOWN_SEGMENT_ATTRIBUTE, token );

	mov	rdx, rbp
	mov	ecx, 81					; 00000051H
	call	EmitErr

; 1052 :             continue;

	movzx	ebx, BYTE PTR is_old$1$[rsp]
	jmp	$LN76@SegmentDir
$LN72@SegmentDir:

; 1053 :         }
; 1054 :         type = &SegAttrValue[typeidx];
; 1055 : 
; 1056 :         /* initstate is used to check if any field is already
; 1057 :          * initialized
; 1058 :          */
; 1059 :         if( initstate & INIT_EXCL_MASK & type->init ) {

	movzx	edx, BYTE PTR SegAttrValue[r12+rdi*2+1]
	mov	ebx, DWORD PTR initstate$1$[rsp]
	mov	eax, edx
	and	eax, ebx
	test	al, 31
	je	SHORT $LN71@SegmentDir

; 1060 :             EmitErr( SEGMENT_ATTRIBUTE_DEFINED_ALREADY, token );

	mov	rdx, rbp
	mov	ecx, 77					; 0000004dH
	call	EmitErr

; 1061 :             continue;

	mov	bl, BYTE PTR is_old$1$[rsp]
	jmp	$LN76@SegmentDir
$LN71@SegmentDir:

; 1062 :         } else {
; 1063 :             initstate |= type->init; /* mark it initialized */

	or	ebx, edx

; 1064 :         }
; 1065 : 
; 1066 :         switch ( type->init ) {

	lea	eax, DWORD PTR [rdx-1]
	cmp	eax, 195				; 000000c3H
	mov	DWORD PTR initstate$1$[rsp], ebx
	ja	$LN143@SegmentDir
	cdqe
	movzx	eax, BYTE PTR $LN135@SegmentDir[r12+rax]
	mov	ecx, DWORD PTR $LN136@SegmentDir[r12+rax*4]
	add	rcx, r12
	jmp	rcx
$LN67@SegmentDir:

; 1067 :         case INIT_ATTR:
; 1068 :             dir->e.seginfo->readonly = TRUE;

	mov	rax, QWORD PTR [rsi+104]

; 1069 :             break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	or	BYTE PTR [rax+107], 1
	jmp	$LN76@SegmentDir
$LN66@SegmentDir:

; 1070 :         case INIT_ALIGN:
; 1071 :             DebugMsg1(("SegmentDir(%s): align attribute found\n", name ));
; 1072 :             dir->e.seginfo->alignment = type->value;

	mov	rcx, QWORD PTR [rsi+104]
	movzx	eax, BYTE PTR SegAttrValue[r12+rdi*2]

; 1073 :             break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	mov	BYTE PTR [rcx+106], al
	jmp	$LN76@SegmentDir
$LN65@SegmentDir:

; 1074 :         case INIT_ALIGN_PARAM:
; 1075 :             DebugMsg1(("SegmentDir(%s): ALIGN() found\n", name ));
; 1076 :             if ( Options.output_format == OFORMAT_OMF ) {

	cmp	DWORD PTR Options+156, 1
	jne	SHORT $LN64@SegmentDir

; 1077 :                 EmitErr( NOT_SUPPORTED_WITH_OMF_FORMAT, tokenarray[i].string_ptr );

	movsxd	rdx, DWORD PTR i$[rsp]
	mov	ecx, 223				; 000000dfH
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r13+8]
	call	EmitErr

; 1078 :                 i = Token_Count; /* stop further parsing of this line */

	mov	edx, DWORD PTR ModuleInfo+496

; 1079 :                 break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	mov	DWORD PTR i$[rsp], edx
	jmp	$LN76@SegmentDir
$LN64@SegmentDir:

; 1080 :             }
; 1081 :             i++;

	mov	ecx, DWORD PTR i$[rsp]
	inc	ecx

; 1082 :             if ( tokenarray[i].token != T_OP_BRACKET ) {

	movsxd	rax, ecx
	mov	DWORD PTR i$[rsp], ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+r13], 40			; 00000028H
	je	SHORT $LN63@SegmentDir

; 1083 :                 EmitErr( EXPECTED, "(" );

	lea	rdx, OFFSET FLAT:$SG6373
	mov	ecx, 230				; 000000e6H
	call	EmitErr

; 1084 :                 break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	jmp	$LN76@SegmentDir
$LN63@SegmentDir:

; 1085 :             }
; 1086 :             i++;
; 1087 :             if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	inc	ecx
	lea	r9, QWORD PTR opndx$[rsp]
	mov	DWORD PTR i$[rsp], ecx
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, r13
	mov	BYTE PTR [rsp+32], r14b
	call	EvalOperand
	cmp	eax, -1
	je	$LN142@SegmentDir

; 1088 :                 break;
; 1089 :             if ( tokenarray[i].token != T_CL_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+r13], 41			; 00000029H
	je	SHORT $LN61@SegmentDir

; 1090 :                 EmitErr( EXPECTED, ")" );

	lea	rdx, OFFSET FLAT:$SG6376
	mov	ecx, 230				; 000000e6H
	call	EmitErr

; 1091 :                 break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	jmp	$LN76@SegmentDir
$LN61@SegmentDir:

; 1092 :             }
; 1093 :             if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], r14d
	je	SHORT $LN60@SegmentDir

; 1094 :                 EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 1095 :                 break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	jmp	$LN76@SegmentDir
$LN60@SegmentDir:

; 1096 :             }
; 1097 :             /*
; 1098 :              COFF allows alignment values
; 1099 :              1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192
; 1100 :              */
; 1101 :             for( temp = 1, temp2 = 0; temp < opndx.value && temp < 8192 ; temp <<= 1, temp2++ );

	mov	edx, DWORD PTR opndx$[rsp]
	mov	eax, 1
	mov	edi, r14d
	cmp	edx, eax
	jle	SHORT $LN140@SegmentDir
$LL59@SegmentDir:
	cmp	eax, 8192				; 00002000H
	jge	SHORT $LN140@SegmentDir
	add	eax, eax
	inc	edi
	cmp	eax, edx
	jl	SHORT $LL59@SegmentDir
$LN140@SegmentDir:

; 1102 :             if( temp != opndx.value ) {

	cmp	eax, edx
	je	SHORT $LN56@SegmentDir

; 1103 :                 EmitErr( POWER_OF_2, opndx.value );

	mov	ecx, 129				; 00000081H
	call	EmitErr
$LN56@SegmentDir:

; 1104 :             }
; 1105 :             dir->e.seginfo->alignment = temp2;

	mov	rax, QWORD PTR [rsi+104]

; 1106 :             break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	mov	BYTE PTR [rax+106], dil
	jmp	$LN76@SegmentDir
$LN55@SegmentDir:

; 1107 :         case INIT_COMBINE:
; 1108 :             DebugMsg1(("SegmentDir(%s): combine attribute found\n", name ));
; 1109 :             dir->e.seginfo->combine = type->value;

	mov	rcx, QWORD PTR [rsi+104]

; 1110 :             break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	movzx	eax, BYTE PTR [rcx+108]
	xor	al, BYTE PTR SegAttrValue[r12+rdi*2]
	and	al, 7
	xor	BYTE PTR [rcx+108], al
	jmp	$LN76@SegmentDir
$LN54@SegmentDir:

; 1111 :         case INIT_COMBINE_AT:
; 1112 :             DebugMsg1(("SegmentDir(%s): AT found\n", name ));
; 1113 :             dir->e.seginfo->combine = type->value;

	mov	rcx, QWORD PTR [rsi+104]

; 1114 :             /* v2.05: always use MAX_SEGALIGNMENT */
; 1115 :             //dir->e.seginfo->alignment = -1;
; 1116 :             dir->e.seginfo->alignment = MAX_SEGALIGNMENT;
; 1117 :             i++;
; 1118 :             if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) != ERROR ) {

	lea	r9, QWORD PTR opndx$[rsp]
	mov	rdx, r13
	movzx	eax, BYTE PTR [rcx+108]
	mov	BYTE PTR [rsp+32], r14b
	xor	al, BYTE PTR SegAttrValue[r12+rdi*2]
	and	al, 7
	xor	BYTE PTR [rcx+108], al
	mov	rax, QWORD PTR [rsi+104]
	lea	rcx, QWORD PTR i$[rsp]
	mov	BYTE PTR [rax+106], 255			; 000000ffH
	mov	r8d, DWORD PTR ModuleInfo+496
	inc	DWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	je	$LN145@SegmentDir

; 1119 :                 if ( opndx.kind == EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], r14d
	jne	SHORT $LN52@SegmentDir

; 1120 :                     dir->e.seginfo->abs_frame = opndx.value;

	movzx	eax, WORD PTR opndx$[rsp]
	mov	rcx, QWORD PTR [rsi+104]

; 1121 :                     dir->e.seginfo->abs_offset = 0;
; 1122 :                 } else {

	mov	bl, BYTE PTR is_old$1$[rsp]
	mov	WORD PTR [rcx+88], ax
	mov	rax, QWORD PTR [rsi+104]
	mov	DWORD PTR [rax+96], r14d
	jmp	$LN76@SegmentDir
$LN52@SegmentDir:

; 1123 :                     EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 1124 :                 }
; 1125 :             }
; 1126 :             break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	jmp	$LN76@SegmentDir
$LN50@SegmentDir:

; 1127 : #if COMDATSUPP
; 1128 :         case INIT_COMBINE_COMDAT:
; 1129 :             DebugMsg1(("SegmentDir(%s): COMDAT found\n", name ));
; 1130 :             /* v2.12: COMDAT supported by OMF */
; 1131 :             //if ( Options.output_format != OFORMAT_COFF ) {
; 1132 :             if ( Options.output_format != OFORMAT_COFF && Options.output_format != OFORMAT_OMF ) {

	mov	eax, DWORD PTR Options+156
	cmp	eax, 2
	je	SHORT $LN49@SegmentDir
	cmp	eax, 1
	je	SHORT $LN49@SegmentDir

; 1133 :                 EmitErr( NOT_SUPPORTED_WITH_CURR_FORMAT, tokenarray[i].string_ptr );

	movsxd	rdx, DWORD PTR i$[rsp]
	mov	ecx, 224				; 000000e0H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r13+8]
	call	EmitErr

; 1134 :                 i = Token_Count; /* stop further parsing of this line */

	mov	edx, DWORD PTR ModuleInfo+496

; 1135 :                 break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	mov	DWORD PTR i$[rsp], edx
	jmp	$LN76@SegmentDir
$LN49@SegmentDir:

; 1136 :             }
; 1137 :             i++;

	mov	ecx, DWORD PTR i$[rsp]
	inc	ecx

; 1138 :             if ( tokenarray[i].token != T_OP_BRACKET ) {

	movsxd	rax, ecx
	mov	DWORD PTR i$[rsp], ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+r13], 40			; 00000028H
	je	SHORT $LN48@SegmentDir

; 1139 :                 EmitErr( EXPECTED, "(" );

	lea	rdx, OFFSET FLAT:$SG6390
	mov	ecx, 230				; 000000e6H
	call	EmitErr

; 1140 :                 break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	jmp	$LN76@SegmentDir
$LN48@SegmentDir:

; 1141 :             }
; 1142 :             i++;
; 1143 :             if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	inc	ecx
	lea	r9, QWORD PTR opndx$[rsp]
	mov	DWORD PTR i$[rsp], ecx
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, r13
	mov	BYTE PTR [rsp+32], r14b
	call	EvalOperand
	cmp	eax, -1
	je	$LN141@SegmentDir

; 1144 :                 break;
; 1145 :             if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], r14d
	je	SHORT $LN46@SegmentDir

; 1146 :                 EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 1147 :                 i = Token_Count; /* stop further parsing of this line */

	mov	edx, DWORD PTR ModuleInfo+496

; 1148 :                 break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	mov	DWORD PTR i$[rsp], edx
	jmp	$LN76@SegmentDir
$LN46@SegmentDir:

; 1149 :             }
; 1150 :             if ( opndx.value < 1 || opndx.value > 6 ) {

	mov	ecx, DWORD PTR opndx$[rsp]
	lea	eax, DWORD PTR [rcx-1]
	cmp	eax, 5
	ja	$LN44@SegmentDir

; 1152 :             } else {
; 1153 :                 /* if value is IMAGE_COMDAT_SELECT_ASSOCIATIVE,
; 1154 :                  * get the associated segment name argument.
; 1155 :                  */
; 1156 :                 if ( opndx.value == 5 ) {

	cmp	ecx, 5
	jne	$LN137@SegmentDir

; 1157 :                     struct asym *sym2;
; 1158 :                     if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rdx, rax
	shl	rdx, 5
	cmp	BYTE PTR [rdx+r13], 44			; 0000002cH
	je	SHORT $LN41@SegmentDir

; 1159 :                         EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos );

	mov	rdx, QWORD PTR [rdx+r13+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr

; 1160 :                         i = Token_Count; /* stop further parsing of this line */

	mov	edx, DWORD PTR ModuleInfo+496

; 1161 :                         break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	mov	DWORD PTR i$[rsp], edx
	jmp	$LN76@SegmentDir
$LN41@SegmentDir:

; 1162 :                     }
; 1163 :                     i++;

	inc	eax

; 1164 :                     if ( tokenarray[i].token != T_ID ) {

	movsxd	rcx, eax
	mov	DWORD PTR i$[rsp], eax
	shl	rcx, 5
	cmp	BYTE PTR [rcx+r13], 8
	je	SHORT $LN40@SegmentDir

; 1165 :                         EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	mov	rdx, QWORD PTR [rcx+r13+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 1166 :                         i = Token_Count; /* stop further parsing of this line */

	mov	edx, DWORD PTR ModuleInfo+496

; 1167 :                         break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	mov	DWORD PTR i$[rsp], edx
	jmp	$LN76@SegmentDir
$LN40@SegmentDir:

; 1168 :                     }
; 1169 :                     /* associated segment must be COMDAT, but not associative */
; 1170 :                     sym2 = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rcx+r13+8]
	call	SymFind

; 1171 :                     if ( sym2 == NULL ||
; 1172 :                         sym2->state != SYM_SEG ||
; 1173 :                         ((struct dsym *)sym2)->e.seginfo->comdat_selection == 0 ||
; 1174 :                         ((struct dsym *)sym2)->e.seginfo->comdat_selection == 5 )

	test	rax, rax
	je	SHORT $LN38@SegmentDir
	cmp	DWORD PTR [rax+40], 3
	jne	SHORT $LN38@SegmentDir
	mov	rdx, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rdx+108]
	shr	al, 3
	and	al, 7
	je	SHORT $LN38@SegmentDir
	cmp	al, 5
	je	SHORT $LN38@SegmentDir

; 1176 :                     else
; 1177 :                         dir->e.seginfo->comdat_number = ((struct dsym *)sym2)->e.seginfo->seg_idx;

	mov	rcx, QWORD PTR [rsi+104]
	movzx	eax, WORD PTR [rdx+68]
	mov	WORD PTR [rcx+88], ax

; 1178 :                     i++;

	inc	DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR opndx$[rsp]
	jmp	SHORT $LN137@SegmentDir
$LN38@SegmentDir:

; 1175 :                         EmitErr( INVALID_ASSOCIATED_SEGMENT, tokenarray[i].string_ptr );

	movsxd	rdx, DWORD PTR i$[rsp]
	mov	ecx, 25
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r13+8]
	call	EmitErr

; 1178 :                     i++;

	inc	DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR opndx$[rsp]
	jmp	SHORT $LN137@SegmentDir
$LN44@SegmentDir:

; 1151 :                 EmitErr( VALUE_NOT_WITHIN_ALLOWED_RANGE, "1-6" );

	lea	rdx, OFFSET FLAT:$SG6395
	mov	ecx, 24
	call	EmitErr
	mov	ecx, DWORD PTR opndx$[rsp]
$LN137@SegmentDir:

; 1179 :                 }
; 1180 :             }
; 1181 :             if ( tokenarray[i].token != T_CL_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+r13], 41			; 00000029H
	je	SHORT $LN36@SegmentDir

; 1182 :                 EmitErr( EXPECTED, ")" );

	lea	rdx, OFFSET FLAT:$SG6409
	mov	ecx, 230				; 000000e6H
	call	EmitErr

; 1183 :                 break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	jmp	$LN76@SegmentDir
$LN36@SegmentDir:

; 1184 :             }
; 1185 :             dir->e.seginfo->comdat_selection = opndx.value;

	mov	rax, QWORD PTR [rsi+104]

; 1186 :             dir->e.seginfo->combine = type->value;
; 1187 :             break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	shl	cl, 3
	xor	cl, BYTE PTR [rax+108]
	and	cl, 56					; 00000038H
	xor	BYTE PTR [rax+108], cl
	mov	rcx, QWORD PTR [rsi+104]
	movzx	eax, BYTE PTR [rcx+108]
	xor	al, BYTE PTR SegAttrValue[r12+rdi*2]
	and	al, 7
	xor	BYTE PTR [rcx+108], al
	jmp	$LN76@SegmentDir
$LN35@SegmentDir:

; 1188 : #endif
; 1189 :         case INIT_OFSSIZE:
; 1190 :         case INIT_OFSSIZE_FLAT:
; 1191 :             if ( type->init == INIT_OFSSIZE_FLAT ) {

	cmp	dl, 136					; 00000088H
	jne	SHORT $LN34@SegmentDir

; 1192 :                 DefineFlatGroup();

	call	DefineFlatGroup

; 1193 : #if AMD64_SUPPORT
; 1194 :                 /* v2.09: make sure ofssize is at least USE32 for FLAT */
; 1195 :                 dir->e.seginfo->Ofssize = ( ModuleInfo.defOfssize > USE16 ? ModuleInfo.defOfssize : USE32 );

	movzx	edx, BYTE PTR ModuleInfo+405
	test	dl, dl
	je	SHORT $LN91@SegmentDir
	movzx	ecx, dl
	jmp	SHORT $LN92@SegmentDir
$LN91@SegmentDir:
	mov	ecx, 1
$LN92@SegmentDir:
	mov	rax, QWORD PTR [rsi+104]

; 1196 : #else
; 1197 :                 dir->e.seginfo->Ofssize = USE32;
; 1198 : #endif
; 1199 :                 /* put the segment into the FLAT group.
; 1200 :                  * this is not quite Masm-compatible, because trying to put
; 1201 :                  * the segment into another group will cause an error.
; 1202 :                  */
; 1203 :                 dir->e.seginfo->group = &ModuleInfo.flat_grp->sym;
; 1204 :             } else

	mov	bl, BYTE PTR is_old$1$[rsp]
	mov	BYTE PTR [rax+104], cl
	mov	rcx, QWORD PTR [rsi+104]
	mov	rax, QWORD PTR ModuleInfo+440
	mov	QWORD PTR [rcx], rax
	jmp	$LN76@SegmentDir
$LN34@SegmentDir:

; 1205 :                 dir->e.seginfo->Ofssize = type->value;

	mov	rcx, QWORD PTR [rsi+104]
	movzx	eax, BYTE PTR SegAttrValue[r12+rdi*2]

; 1206 :             break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	mov	BYTE PTR [rcx+104], al
	jmp	$LN76@SegmentDir
$LN32@SegmentDir:

; 1207 : #if COFF_SUPPORT || ELF_SUPPORT || PE_SUPPORT
; 1208 :         case INIT_CHAR_INFO:
; 1209 :             dir->e.seginfo->info = TRUE; /* fixme: check that this flag isn't changed */

	mov	rax, QWORD PTR [rsi+104]

; 1210 :             break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	or	BYTE PTR [rax+107], 2
	jmp	$LN76@SegmentDir
$LN31@SegmentDir:

; 1211 :         case INIT_CHAR:
; 1212 :             DebugMsg1(("SegmentDir(%s): characteristics found\n", name ));
; 1213 :             /* characteristics are restricted to COFF/ELF/BIN-PE */
; 1214 :             if ( Options.output_format == OFORMAT_OMF
; 1215 : #if PE_SUPPORT
; 1216 :                 || ( ModuleInfo.flat == FALSE && Options.output_format == OFORMAT_BIN && ModuleInfo.sub_format != SFORMAT_PE )
; 1217 : #endif
; 1218 :                ) {

	mov	eax, DWORD PTR Options+156
	cmp	eax, 1
	je	SHORT $LN29@SegmentDir
	cmp	BYTE PTR ModuleInfo+772, r14b
	jne	SHORT $LN30@SegmentDir
	test	eax, eax
	jne	SHORT $LN30@SegmentDir
	cmp	DWORD PTR ModuleInfo+372, 2
	jne	SHORT $LN29@SegmentDir
$LN30@SegmentDir:

; 1220 :             } else
; 1221 :                 newcharacteristics |= type->value;

	or	r15b, BYTE PTR SegAttrValue[r12+rdi*2]
	mov	bl, BYTE PTR is_old$1$[rsp]
	jmp	$LN76@SegmentDir
$LN29@SegmentDir:

; 1219 :                 EmitErr( NOT_SUPPORTED_WITH_CURR_FORMAT, tokenarray[i].string_ptr );

	movsxd	rdx, DWORD PTR i$[rsp]
	mov	ecx, 224				; 000000e0H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r13+8]
	call	EmitErr

; 1222 :             break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	jmp	$LN76@SegmentDir
$LN27@SegmentDir:

; 1223 :         case INIT_ALIAS:
; 1224 :             DebugMsg1(("SegmentDir(%s): ALIAS found, curr value=%s\n", name, dir->e.seginfo->aliasname ? dir->e.seginfo->aliasname : "NULL" ));
; 1225 :             /* alias() is restricted to COFF/ELF/BIN-PE */
; 1226 :             if ( Options.output_format == OFORMAT_OMF
; 1227 :                 || ( Options.output_format == OFORMAT_BIN && ModuleInfo.sub_format != SFORMAT_PE )
; 1228 :                ) {

	mov	eax, DWORD PTR Options+156
	cmp	eax, 1
	je	$LN25@SegmentDir
	test	eax, eax
	jne	SHORT $LN26@SegmentDir
	cmp	DWORD PTR ModuleInfo+372, 2
	jne	$LN25@SegmentDir
$LN26@SegmentDir:

; 1231 :                 break;
; 1232 :             }
; 1233 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1234 :             if ( tokenarray[i].token != T_OP_BRACKET ) {

	cdqe
	shl	rax, 5
	cmp	BYTE PTR [rax+r13], 40			; 00000028H
	je	SHORT $LN24@SegmentDir

; 1235 :                 EmitErr( EXPECTED, "(" );

	lea	rdx, OFFSET FLAT:$SG6422
	mov	ecx, 230				; 000000e6H
	call	EmitErr

; 1236 :                 break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	jmp	$LN76@SegmentDir
$LN24@SegmentDir:

; 1237 :             }
; 1238 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax

; 1239 :             if ( tokenarray[i].token != T_STRING ||
; 1240 :                 ( tokenarray[i].string_delim != '"' &&
; 1241 :                 tokenarray[i].string_delim != '\'' ) ) {

	movsxd	rcx, eax
	mov	DWORD PTR i$[rsp], eax
	shl	rcx, 5
	cmp	BYTE PTR [rcx+r13], 9
	jne	$LN22@SegmentDir
	movzx	eax, BYTE PTR [rcx+r13+1]
	cmp	al, 34					; 00000022H
	je	SHORT $LN23@SegmentDir
	cmp	al, 39					; 00000027H
	jne	$LN22@SegmentDir
$LN23@SegmentDir:

; 1245 :             }
; 1246 :             temp = i;
; 1247 :             i++;

	mov	eax, DWORD PTR i$[rsp]
	movsxd	rcx, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1248 :             if ( tokenarray[i].token != T_CL_BRACKET ) {

	cdqe
	shl	rax, 5
	cmp	BYTE PTR [rax+r13], 41			; 00000029H
	je	SHORT $LN21@SegmentDir

; 1249 :                 EmitErr( EXPECTED, ")" );

	lea	rdx, OFFSET FLAT:$SG6426
	mov	ecx, 230				; 000000e6H
	call	EmitErr

; 1250 :                 break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	jmp	$LN76@SegmentDir
$LN21@SegmentDir:

; 1251 :             }
; 1252 :             /* v2.10: if segment already exists, check that old and new aliasname are equal */
; 1253 :             if ( is_old ) {

	mov	bl, BYTE PTR is_old$1$[rsp]
	test	bl, bl
	je	SHORT $LN20@SegmentDir

; 1254 :                 if ( dir->e.seginfo->aliasname == NULL ||
; 1255 :                     ( tokenarray[temp].stringlen != strlen( dir->e.seginfo->aliasname ) ) ||
; 1256 :                     memcmp( dir->e.seginfo->aliasname, tokenarray[temp].string_ptr + 1, tokenarray[temp].stringlen ) ) {

	mov	rax, QWORD PTR [rsi+104]
	mov	r10, QWORD PTR [rax+96]
	test	r10, r10
	je	SHORT $LN18@SegmentDir
	mov	rdx, rcx
	xor	eax, eax
	mov	rdi, r10
	shl	rdx, 5
	mov	rcx, -1
	mov	r8d, DWORD PTR [rdx+r13+16]
	repne scasb
	not	rcx
	dec	rcx
	cmp	r8, rcx
	jne	SHORT $LN18@SegmentDir
	mov	rdx, QWORD PTR [rdx+r13+8]
	lea	r9d, QWORD PTR [rax+1]
	mov	rcx, r10
	inc	rdx
	mov	DWORD PTR [rsp+32], 1
	call	memcmp
	test	eax, eax
	je	$LN76@SegmentDir
$LN18@SegmentDir:

; 1257 :                     EmitErr( SEGDEF_CHANGED, dir->sym.name, MsgGetEx( TXT_ALIASNAME ) );

	mov	ecx, 13
	call	MsgGetEx
	mov	rdx, QWORD PTR [rsi+8]
	mov	ecx, 78					; 0000004eH
	mov	r8, rax
	call	EmitErr

; 1258 :                     break;

	jmp	$LN76@SegmentDir
$LN20@SegmentDir:

; 1259 :                 }
; 1260 :             } else {
; 1261 :                 /* v2.10: " + 1" was missing in next line */
; 1262 :                 dir->e.seginfo->aliasname = LclAlloc( tokenarray[temp].stringlen + 1 );

	mov	rdi, rcx
	shl	rdi, 5
	mov	ecx, DWORD PTR [rdi+r13+16]
	inc	ecx
	call	LclAlloc
	mov	rcx, QWORD PTR [rsi+104]
	mov	QWORD PTR [rcx+96], rax

; 1263 :                 memcpy( dir->e.seginfo->aliasname, tokenarray[temp].string_ptr+1, tokenarray[temp].stringlen );

	mov	rcx, QWORD PTR [rsi+104]
	mov	rdx, QWORD PTR [rdi+r13+8]
	mov	r8d, DWORD PTR [rdi+r13+16]
	mov	rcx, QWORD PTR [rcx+96]
	inc	rdx
	call	memcpy

; 1264 :                 *(dir->e.seginfo->aliasname+tokenarray[temp].stringlen) = NULLC;

	mov	rax, QWORD PTR [rsi+104]
	mov	ecx, DWORD PTR [rdi+r13+16]
	mov	rax, QWORD PTR [rax+96]
	mov	BYTE PTR [rcx+rax], r14b

; 1265 :             }
; 1266 :             DebugMsg1(("SegmentDir(%s): ALIAS argument=>%s<\n", name, dir->e.seginfo->aliasname ));
; 1267 :             break;

	jmp	SHORT $LN76@SegmentDir
$LN22@SegmentDir:

; 1242 :                 EmitErr( SYNTAX_ERROR_EX, token );

	mov	rdx, rbp
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 1243 :                 i = Token_Count; /* stop further parsing of this line */

	mov	edx, DWORD PTR ModuleInfo+496

; 1244 :                 break;

	mov	bl, BYTE PTR is_old$1$[rsp]
	mov	DWORD PTR i$[rsp], edx
	jmp	SHORT $LN76@SegmentDir
$LN25@SegmentDir:

; 1229 :                 EmitErr( NOT_SUPPORTED_WITH_CURR_FORMAT, tokenarray[i].string_ptr );

	movsxd	rdx, DWORD PTR i$[rsp]
	mov	ecx, 224				; 000000e0H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r13+8]
	call	EmitErr

; 1230 :                 i = Token_Count; /* stop further parsing of this line */

	mov	edx, DWORD PTR ModuleInfo+496
	mov	bl, BYTE PTR is_old$1$[rsp]
	mov	DWORD PTR i$[rsp], edx
	jmp	SHORT $LN76@SegmentDir
$LN141@SegmentDir:

; 1052 :             continue;

	mov	bl, BYTE PTR is_old$1$[rsp]
	jmp	SHORT $LN76@SegmentDir
$LN142@SegmentDir:
	mov	bl, BYTE PTR is_old$1$[rsp]
	jmp	SHORT $LN76@SegmentDir
$LN143@SegmentDir:
	mov	bl, BYTE PTR is_old$1$[rsp]
	jmp	SHORT $LN76@SegmentDir
$LN144@SegmentDir:
	mov	bl, BYTE PTR is_old$1$[rsp]
	jmp	SHORT $LN76@SegmentDir
$LN145@SegmentDir:
	mov	bl, BYTE PTR is_old$1$[rsp]
$LN76@SegmentDir:

; 1024 : 
; 1025 :     for( ; i < Token_Count; i++ ) {

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cmp	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rsp], eax
	jl	$LL77@SegmentDir
	mov	r12, QWORD PTR sym$1$[rsp]
	mov	rbp, QWORD PTR [rsp+264]
	lea	rdi, OFFSET FLAT:__ImageBase
$LN75@SegmentDir:

; 1268 : #endif
; 1269 : #ifdef DEBUG_OUT
; 1270 :         default: /* shouldn't happen */
; 1271 :             /**/myassert( 0 );
; 1272 :             break;
; 1273 : #endif
; 1274 :         }
; 1275 :     } /* end for */
; 1276 : 
; 1277 :     /* make a guess about the segment's type */
; 1278 :     if( dir->e.seginfo->segtype != SEGTYPE_CODE ) {

	mov	rdx, QWORD PTR [rsi+104]
	cmp	DWORD PTR [rdx+72], 1
	je	SHORT $LN15@SegmentDir

; 1279 :         enum seg_type res;
; 1280 : 
; 1281 :         //token = GetLname( dir->e.seginfo->class_name_idx );
; 1282 :         res = TypeFromClassName( dir, dir->e.seginfo->clsym );

	mov	rdx, QWORD PTR [rdx+80]
	mov	rcx, rsi
	call	TypeFromClassName

; 1283 :         if( res != SEGTYPE_UNDEF ) {

	test	eax, eax
	je	SHORT $LN15@SegmentDir

; 1284 :             dir->e.seginfo->segtype = res;

	mov	rcx, QWORD PTR [rsi+104]
	mov	DWORD PTR [rcx+72], eax
$LN15@SegmentDir:

; 1285 :         }
; 1286 : #if 0 /* v2.03: removed */
; 1287 :         else {
; 1288 :             res = TypeFromSegmentName( name );
; 1289 :             dir->e.seginfo->segtype = res;
; 1290 :         }
; 1291 : #endif
; 1292 :     }
; 1293 : 
; 1294 :     if( is_old ) {

	test	bl, bl
	je	SHORT $LN14@SegmentDir

; 1295 :         int txt = 0;
; 1296 : 
; 1297 :         /* Check if new definition is different from previous one */
; 1298 : 
; 1299 :         // oldobj = dir->e.seginfo->segrec;
; 1300 :         if ( oldalign    != dir->e.seginfo->alignment )

	mov	rdx, QWORD PTR [rsi+104]
	movsx	eax, BYTE PTR oldalign$[rsp]
	movzx	ecx, BYTE PTR [rdx+106]
	cmp	eax, ecx
	je	SHORT $LN13@SegmentDir

; 1301 :             txt = TXT_ALIGNMENT;

	mov	ecx, 8
	jmp	SHORT $LN134@SegmentDir
$LN13@SegmentDir:

; 1302 :         else if ( oldcombine  != dir->e.seginfo->combine )

	mov	cl, BYTE PTR [rdx+108]
	mov	al, BYTE PTR oldcombine$[rsp]
	and	ecx, 7
	cmp	al, cl
	je	SHORT $LN11@SegmentDir

; 1303 :             txt = TXT_COMBINE;

	mov	ecx, 9
	jmp	SHORT $LN134@SegmentDir
$LN11@SegmentDir:

; 1304 :         else if ( oldOfssize  != dir->e.seginfo->Ofssize )

	movzx	eax, BYTE PTR [rdx+104]
	cmp	BYTE PTR oldOfssize$[rsp], al
	je	SHORT $LN9@SegmentDir

; 1305 :             txt = TXT_SEG_WORD_SIZE;

	mov	ecx, 10
	jmp	SHORT $LN134@SegmentDir
$LN9@SegmentDir:

; 1306 : #if 0 /* v2.09: removed */
; 1307 :         else if(  oldreadonly != dir->e.seginfo->readonly )
; 1308 :             /* readonly is not a true segment attribute */
; 1309 :             txt = TXT_READONLY;
; 1310 :         else if ( oldclsym != dir->e.seginfo->clsym )
; 1311 :             /* segment class check is done in SetSegmentClass() */
; 1312 :             txt = TXT_CLASS;
; 1313 : #endif
; 1314 :         else if ( newcharacteristics && ( newcharacteristics != dir->e.seginfo->characteristics ) )

	test	r15b, r15b
	je	SHORT $LN2@SegmentDir
	cmp	r15b, BYTE PTR [rdx+105]
	je	SHORT $LN109@SegmentDir

; 1315 :             txt = TXT_CHARACTERISTICS;

	mov	ecx, 12
$LN134@SegmentDir:

; 1316 : 
; 1317 :         if ( txt ) {
; 1318 :             EmitErr( SEGDEF_CHANGED, dir->sym.name, MsgGetEx( txt ) );

	call	MsgGetEx
	mov	rdx, QWORD PTR [rsi+8]
	mov	ecx, 78					; 0000004eH
	mov	r8, rax
	call	EmitErr

; 1319 :             //return( ERROR ); /* v2: display error, but continue */
; 1320 :         }
; 1321 : 
; 1322 :     } else {

	jmp	SHORT $LN109@SegmentDir
$LN14@SegmentDir:

; 1323 :         /* A new definition */
; 1324 : 
; 1325 :         //sym = &dir->sym;
; 1326 :         sym->isdefined = TRUE;

	or	BYTE PTR [r12+48], 2

; 1327 :         sym->segment = sym;

	mov	QWORD PTR [r12+32], r12

; 1328 :         sym->offset = 0; /* remains 0 ( =segment's local start offset ) */

	mov	DWORD PTR [r12+16], r14d

; 1329 : #if COMDATSUPP
; 1330 :         /* no segment index for COMDAT segments in OMF! */
; 1331 :         if ( dir->e.seginfo->comdat_selection && Options.output_format == OFORMAT_OMF )

	mov	rax, QWORD PTR [rsi+104]
	test	BYTE PTR [rax+108], 56			; 00000038H
	je	SHORT $LN4@SegmentDir
	cmp	DWORD PTR Options+156, 1
	je	SHORT $LN109@SegmentDir
$LN4@SegmentDir:

; 1332 :             ;
; 1333 :         else {
; 1334 : #endif
; 1335 :             dir->e.seginfo->seg_idx = ++ModuleInfo.g.num_segs;

	mov	ecx, DWORD PTR ModuleInfo+8

; 1336 :             /* dir->e.seginfo->lname_idx = */ AddLnameItem( sym );

	mov	rdx, r12
	inc	ecx
	mov	DWORD PTR ModuleInfo+8, ecx
	mov	rax, QWORD PTR [rsi+104]
	mov	DWORD PTR [rax+68], ecx
	lea	rcx, OFFSET FLAT:ModuleInfo+32
	call	QAddItem
$LN109@SegmentDir:

; 1337 : #if COMDATSUPP
; 1338 :         }
; 1339 : #endif
; 1340 : 
; 1341 :     }
; 1342 :     if ( newcharacteristics )

	test	r15b, r15b
	je	SHORT $LN2@SegmentDir

; 1343 :         dir->e.seginfo->characteristics = newcharacteristics;

	mov	rax, QWORD PTR [rsi+104]
	mov	BYTE PTR [rax+105], r15b
$LN2@SegmentDir:

; 1344 : 
; 1345 :     push_seg( dir ); /* set CurrSeg */

	movsxd	rdx, DWORD PTR stkindex
	cmp	edx, 20
	jl	SHORT $LN111@SegmentDir
	mov	ecx, 100				; 00000064H
	call	EmitError
	jmp	SHORT $LN117@SegmentDir
$LN111@SegmentDir:
	mov	rax, QWORD PTR ModuleInfo+432
	mov	BYTE PTR SegAssumeTable+25, r14b
	mov	BYTE PTR SegAssumeTable+24, r14b
	mov	QWORD PTR SegStack[rdi+rdx*8], rax
	mov	QWORD PTR ModuleInfo+432, rsi
	mov	rax, QWORD PTR [rsi+104]
	inc	edx
	cmp	QWORD PTR [rax], r14
	mov	DWORD PTR stkindex, edx
	je	SHORT $LN116@SegmentDir
	mov	rax, QWORD PTR [rax]
	cmp	rax, QWORD PTR ModuleInfo+440
	mov	QWORD PTR SegAssumeTable+16, rax
	jne	SHORT $LN114@SegmentDir
	mov	BYTE PTR SegAssumeTable+25, 1
	jmp	SHORT $LN114@SegmentDir
$LN116@SegmentDir:
	mov	QWORD PTR SegAssumeTable+16, rsi
$LN114@SegmentDir:
	mov	rax, QWORD PTR symCurSeg
	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rax+16], rcx
$LN117@SegmentDir:

; 1346 : 
; 1347 :     if ( ModuleInfo.list )

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN1@SegmentDir

; 1348 :         LstWrite( LSTTYPE_LABEL, 0, NULL );

	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+7]
	call	LstWrite
$LN1@SegmentDir:

; 1349 : 
; 1350 :     return( SetOfssize() );

	mov	rax, QWORD PTR ModuleInfo+432
	test	rax, rax
	jne	SHORT $LN123@SegmentDir
	movzx	ecx, BYTE PTR ModuleInfo+405
	mov	BYTE PTR ModuleInfo+404, cl
$LN121@SegmentDir:
	mov	eax, 2
	shl	al, cl
	cmp	cl, 2
	sete	cl
	mov	BYTE PTR ModuleInfo+406, al
	call	Set64Bit
$LN124@SegmentDir:
	mov	eax, r14d
$LN148@SegmentDir:
	mov	rdi, QWORD PTR [rsp+216]
	mov	rsi, QWORD PTR [rsp+224]
	mov	r12, QWORD PTR [rsp+208]
$LN89@SegmentDir:
	mov	r15, QWORD PTR [rsp+184]
	mov	r14, QWORD PTR [rsp+192]
	mov	r13, QWORD PTR [rsp+200]
	mov	rbx, QWORD PTR [rsp+256]

; 1351 : }

	add	rsp, 232				; 000000e8H
	ret	0

; 1349 : 
; 1350 :     return( SetOfssize() );

$LN123@SegmentDir:
	mov	rax, QWORD PTR [rax+104]
	movzx	ecx, BYTE PTR [rax+104]
	movzx	eax, BYTE PTR ModuleInfo+392
	cmp	ax, WORD PTR min_cpu[rdi+rcx*2]
	mov	BYTE PTR ModuleInfo+404, cl
	jae	SHORT $LN121@SegmentDir
	mov	edx, 16
	shl	edx, cl
	mov	ecx, 132				; 00000084H
	call	EmitErr
	mov	r14d, eax
	jmp	SHORT $LN124@SegmentDir
	npad	2
$LN136@SegmentDir:

; 1351 : }

	DD	$LN67@SegmentDir
	DD	$LN66@SegmentDir
	DD	$LN55@SegmentDir
	DD	$LN35@SegmentDir
	DD	$LN27@SegmentDir
	DD	$LN31@SegmentDir
	DD	$LN65@SegmentDir
	DD	$LN54@SegmentDir
	DD	$LN32@SegmentDir
	DD	$LN50@SegmentDir
	DD	$LN144@SegmentDir
$LN135@SegmentDir:
	DB	0
	DB	1
	DB	10
	DB	2
	DB	10
	DB	10
	DB	10
	DB	3
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	4
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	5
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	6
	DB	10
	DB	7
	DB	10
	DB	10
	DB	10
	DB	3
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	8
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	9
SegmentDir ENDP
_TEXT	ENDS
PUBLIC	SortSegments
xdata	SEGMENT
$unwind$SortSegments DD 0b2001H
	DD	097420H
	DD	086418H
	DD	075413H
	DD	06340eH
	DD	04c409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SortSegments DD @imagerel($LN28#)
	DD	@imagerel($LN28#+294)
	DD	@imagerel($unwind$SortSegments#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
type$ = 48
SortSegments PROC NEAR

; 1361 : {

$LN28:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+32], r12
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	r12d, ecx
	mov	QWORD PTR [rsp+72], rdi
$LL17@SortSegmen:

; 1368 :         struct dsym *prev = NULL;
; 1369 :         changed = FALSE;
; 1370 :         for( curr = SymTables[TAB_SEG].head; curr && curr->next ; prev = curr, curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+32
	xor	esi, esi
	xor	bpl, bpl
	test	rbx, rbx
	je	$LN23@SortSegmen
	npad	11
$LL15@SortSegmen:
	mov	rdx, QWORD PTR [rbx+112]
	test	rdx, rdx
	je	$LN13@SortSegmen

; 1371 :             swap = FALSE;
; 1372 :             switch (type ) {

	test	r12d, r12d
	mov	ecx, r12d
	je	SHORT $LN10@SortSegmen
	dec	ecx
	je	SHORT $LN8@SortSegmen
	dec	ecx
	jne	$LN14@SortSegmen

; 1381 :             case 2:
; 1382 :                 if ( curr->e.seginfo->lname_idx > curr->next->e.seginfo->lname_idx ||
; 1383 :                     ( curr->e.seginfo->lname_idx == curr->next->e.seginfo->lname_idx &&
; 1384 :                     ( _stricmp( curr->sym.name, curr->next->sym.name ) > 0 ) ) )

	mov	rax, QWORD PTR [rbx+104]
	mov	ecx, DWORD PTR [rax+76]
	mov	rax, QWORD PTR [rdx+104]
	mov	r8d, DWORD PTR [rax+76]
	cmp	ecx, r8d
	jg	SHORT $LN24@SortSegmen
	cmp	ecx, r8d
	jne	SHORT $LN14@SortSegmen
	mov	rdx, QWORD PTR [rdx+8]
	mov	rcx, QWORD PTR [rbx+8]
	call	_stricmp
	test	eax, eax
	jle	SHORT $LN14@SortSegmen

; 1385 :                     swap = TRUE;
; 1386 :                 break;

	jmp	SHORT $LN24@SortSegmen
$LN8@SortSegmen:

; 1375 :                     swap = TRUE;
; 1376 :                 break;
; 1377 :             case 1:
; 1378 :                 if ( strcmp( curr->sym.name, curr->next->sym.name ) > 0 )

	mov	rax, QWORD PTR [rbx+8]
	mov	r8, QWORD PTR [rdx+8]
	sub	r8, rax
	npad	8
$LL25@SortSegmen:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN26@SortSegmen
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL25@SortSegmen
$LN26@SortSegmen:
	test	edx, edx
	jle	SHORT $LN14@SortSegmen

; 1379 :                     swap = TRUE;
; 1380 :                 break;

	jmp	SHORT $LN24@SortSegmen
$LN10@SortSegmen:

; 1373 :             case 0:
; 1374 :                 if ( curr->e.seginfo->fileoffset > curr->next->e.seginfo->fileoffset )

	mov	rax, QWORD PTR [rdx+104]
	mov	rcx, QWORD PTR [rbx+104]
	mov	eax, DWORD PTR [rax+56]
	cmp	DWORD PTR [rcx+56], eax
	jbe	SHORT $LN14@SortSegmen
$LN24@SortSegmen:

; 1387 : #ifdef DEBUG_OUT
; 1388 :             default: /**/myassert( 0 );
; 1389 : #endif
; 1390 :             }
; 1391 :             if ( swap ) {
; 1392 :                 struct dsym *tmp = curr->next;
; 1393 :                 changed = TRUE;
; 1394 :                 if ( prev == NULL ) {

	test	rsi, rsi
	mov	rcx, QWORD PTR [rbx+112]
	mov	bpl, 1
	jne	SHORT $LN2@SortSegmen

; 1395 :                     SymTables[TAB_SEG].head = tmp;

	mov	QWORD PTR SymTables+32, rcx

; 1396 :                 } else {

	jmp	SHORT $LN1@SortSegmen
$LN2@SortSegmen:

; 1397 :                     prev->next = tmp;

	mov	QWORD PTR [rsi+112], rcx
$LN1@SortSegmen:

; 1398 :                 }
; 1399 :                 curr->next = tmp->next;

	mov	rax, QWORD PTR [rcx+112]
	mov	QWORD PTR [rbx+112], rax

; 1400 :                 tmp->next = curr;

	mov	QWORD PTR [rcx+112], rbx
$LN14@SortSegmen:
	mov	rsi, rbx
	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	$LL15@SortSegmen
$LN13@SortSegmen:

; 1362 :     bool changed = TRUE;
; 1363 :     bool swap;
; 1364 :     struct dsym *curr;
; 1365 :     //int index = 1;
; 1366 : 
; 1367 :     while ( changed == TRUE ) {

	cmp	bpl, 1
	je	$LL17@SortSegmen
$LN23@SortSegmen:
	mov	r12, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 1401 :             }
; 1402 :         }
; 1403 :     }
; 1404 : 
; 1405 :     /* v2.7: don't change segment indices! They're stored in fixup.frame_datum */
; 1406 :     //for ( curr = SymTables[TAB_SEG].head; curr ; curr = curr->next ) {
; 1407 :     //    curr->e.seginfo->seg_idx = index++;
; 1408 :     //}
; 1409 : }

	add	rsp, 40					; 00000028H
	ret	0
SortSegments ENDP
_TEXT	ENDS
PUBLIC	SegmentModuleExit
EXTRN	ModelSimSegmExit:NEAR
xdata	SEGMENT
$unwind$SegmentModuleExit DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SegmentModuleExit DD @imagerel($LN30#)
	DD	@imagerel($LN30#+38)
	DD	@imagerel($unwind$SegmentModuleExit#)
pdata	ENDS
xdata	SEGMENT
$chain$3$SegmentModuleExit DD 082e21H
	DD	06342eH
	DD	097414H
	DD	08640fH
	DD	075405H
	DD	@imagerel($LN30#)
	DD	@imagerel($LN30#+38)
	DD	@imagerel($unwind$SegmentModuleExit#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$SegmentModuleExit DD @imagerel($LN30#+38)
	DD	@imagerel($LN30#+398)
	DD	@imagerel($chain$3$SegmentModuleExit#)
pdata	ENDS
xdata	SEGMENT
$chain$4$SegmentModuleExit DD 021H
	DD	@imagerel($LN30#)
	DD	@imagerel($LN30#+38)
	DD	@imagerel($unwind$SegmentModuleExit#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$SegmentModuleExit DD @imagerel($LN30#+398)
	DD	@imagerel($LN30#+405)
	DD	@imagerel($chain$4$SegmentModuleExit#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
SegmentModuleExit PROC NEAR

; 1415 : {

$LN30:
	sub	rsp, 40					; 00000028H

; 1416 :     if ( ModuleInfo.model != MODEL_NONE )

	cmp	DWORD PTR ModuleInfo+360, 0
	je	SHORT $LN4@SegmentMod

; 1417 :         ModelSimSegmExit();

	call	ModelSimSegmExit
$LN4@SegmentMod:

; 1418 :     /* if there's still an open segment, it's an error */
; 1419 :     if ( CurrSeg ) {

	mov	rdx, QWORD PTR ModuleInfo+432
	test	rdx, rdx
	je	$LN25@SegmentMod

; 1420 :         EmitErr( BLOCK_NESTING_ERROR, CurrSeg->sym.name );

	mov	rdx, QWORD PTR [rdx+8]
	mov	QWORD PTR [rsp+56], rbp
	mov	ecx, 80					; 00000050H
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	call	EmitErr
	lea	rbp, OFFSET FLAT:SegStack
	xor	edi, edi
	lea	rsi, OFFSET FLAT:$SG6009
	mov	QWORD PTR [rsp+48], rbx
	npad	12
$LL2@SegmentMod:

; 1421 :         /* but close the still open segments anyway */
; 1422 :         while( CurrSeg && ( CloseSeg( CurrSeg->sym.name ) == NOT_ERROR ) );

	mov	rax, QWORD PTR ModuleInfo+432
	test	rax, rax
	je	$LN24@SegmentMod
	mov	rbx, QWORD PTR [rax+8]
	movzx	r8d, BYTE PTR [rax+80]
	mov	rdx, rbx
	mov	rcx, rbx
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	jne	$LN9@SegmentMod
	cmp	BYTE PTR write_to_file, dil
	je	SHORT $LN7@SegmentMod
	cmp	DWORD PTR Options+156, 1
	jne	SHORT $LN7@SegmentMod
	call	omf_FlushCurrSeg
	cmp	BYTE PTR Options+120, dil
	jne	SHORT $LN7@SegmentMod
	xor	ecx, ecx
	call	omf_OutSelect
$LN7@SegmentMod:
	mov	eax, DWORD PTR stkindex
	test	eax, eax
	je	SHORT $LL2@SegmentMod
	dec	eax
	mov	DWORD PTR stkindex, eax
	cdqe
	mov	rcx, QWORD PTR [rbp+rax*8]
	test	rcx, rcx
	mov	QWORD PTR ModuleInfo+432, rcx
	jne	SHORT $LN20@SegmentMod
	mov	rax, QWORD PTR symCurSeg
	mov	QWORD PTR SegAssumeTable+16, rdi
	mov	BYTE PTR SegAssumeTable+25, dil
	mov	BYTE PTR SegAssumeTable+24, 1
	mov	QWORD PTR [rax+16], rsi
	jmp	$LL2@SegmentMod
$LN20@SegmentMod:
	mov	BYTE PTR SegAssumeTable+25, dil
	mov	BYTE PTR SegAssumeTable+24, dil
	mov	rax, QWORD PTR [rcx+104]
	cmp	QWORD PTR [rax], rdi
	je	SHORT $LN18@SegmentMod
	mov	rax, QWORD PTR [rax]
	cmp	rax, QWORD PTR ModuleInfo+440
	mov	QWORD PTR SegAssumeTable+16, rax
	jne	SHORT $LN16@SegmentMod
	mov	rax, QWORD PTR symCurSeg
	mov	BYTE PTR SegAssumeTable+25, 1
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+16], rcx
	jmp	$LL2@SegmentMod
$LN18@SegmentMod:
	mov	QWORD PTR SegAssumeTable+16, rcx
$LN16@SegmentMod:
	mov	rax, QWORD PTR symCurSeg
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+16], rcx
	jmp	$LL2@SegmentMod
$LN9@SegmentMod:
	mov	rdx, rbx
	mov	ecx, 80					; 00000050H
	call	EmitErr
	test	eax, eax
	je	$LL2@SegmentMod
$LN24@SegmentMod:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]

; 1423 :     }
; 1424 : 
; 1425 :     return( NOT_ERROR );

	xor	eax, eax

; 1426 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN25@SegmentMod:

; 1423 :     }
; 1424 : 
; 1425 :     return( NOT_ERROR );

	xor	eax, eax

; 1426 : }

	add	rsp, 40					; 00000028H
	ret	0
SegmentModuleExit ENDP
_TEXT	ENDS
PUBLIC	SegmentFini
xdata	SEGMENT
$unwind$SegmentFini DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$SegmentFini DD @imagerel($LN12#)
	DD	@imagerel($LN12#+50)
	DD	@imagerel($unwind$SegmentFini#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
SegmentFini PROC NEAR

; 1432 : {

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1433 : #if FASTMEM==0
; 1434 :     struct dsym    *curr;
; 1435 : #endif
; 1436 : 
; 1437 :     DebugMsg(("SegmentFini() enter\n"));
; 1438 : #if FASTMEM==0
; 1439 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {
; 1440 :         struct fixup *fix;
; 1441 :         DebugMsg(("SegmentFini: segment %s\n", curr->sym.name ));
; 1442 :         for ( fix = curr->e.seginfo->FixupList.head; fix ; ) {
; 1443 :             struct fixup *next = fix->nextrlc;
; 1444 :             DebugMsg(("SegmentFini: free fixup [sym=%s, loc=%" I32_SPEC "X]\n", fix->sym ? fix->sym->name : "NULL", fix->location ));
; 1445 :             LclFree( fix );
; 1446 :             fix = next;
; 1447 :         }
; 1448 :     }
; 1449 : #endif
; 1450 : 
; 1451 : #if FASTPASS
; 1452 :     if ( saved_SegStack ) {
; 1453 :         LclFree( saved_SegStack );
; 1454 :     }
; 1455 : #endif
; 1456 :     FreeLnameQueue();

	mov	rax, QWORD PTR ModuleInfo+32
	test	rax, rax
	je	SHORT $LN5@SegmentFin
$LL7@SegmentFin:
	mov	rcx, QWORD PTR [rax+8]
	mov	rbx, QWORD PTR [rax]
	cmp	DWORD PTR [rcx+40], 11
	jne	SHORT $LN6@SegmentFin
	call	SymFree
$LN6@SegmentFin:
	test	rbx, rbx
	mov	rax, rbx
	jne	SHORT $LL7@SegmentFin
$LN5@SegmentFin:

; 1457 :     DebugMsg(("SegmentFini() exit\n"));
; 1458 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
SegmentFini ENDP
_TEXT	ENDS
PUBLIC	SegmentInit
EXTRN	UseSavedState:BYTE
_BSS	SEGMENT
saved_SegStack DQ 01H DUP (?)
saved_CurrSeg DQ 01H DUP (?)
saved_stkindex DD 01H DUP (?)
codebuf	DB	0400H DUP (?)
buffer_size DD	01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$SegmentInit DD 050e01H
	DD	09740eH
	DD	083409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SegmentInit DD @imagerel($LN36#)
	DD	@imagerel($LN36#+541)
	DD	@imagerel($unwind$SegmentInit#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pass$ = 48
SegmentInit PROC NEAR

; 1464 : {

$LN36:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi

; 1465 :     struct dsym *curr;
; 1466 :     uint_32     i;
; 1467 : #ifdef __I86__
; 1468 :     char __huge *p;
; 1469 : #else
; 1470 :     char        *p;
; 1471 : #endif
; 1472 :     //struct fixup *fix;
; 1473 : 
; 1474 :     DebugMsg(("SegmentInit(%u) enter\n", pass ));
; 1475 :     CurrSeg      = NULL;

	xor	edi, edi

; 1476 :     stkindex     = 0;
; 1477 : 
; 1478 :     if ( pass == PASS_1 ) {

	test	ecx, ecx
	mov	ebx, ecx
	mov	QWORD PTR ModuleInfo+432, rdi
	mov	DWORD PTR stkindex, edi
	jne	SHORT $LN20@SegmentIni

; 1479 :         grpdefidx   = 0;

	mov	DWORD PTR grpdefidx, edi

; 1480 :         //LnamesIdx   = 1; /* the first Lname is a null-string */
; 1481 :         //pCodeBuff = NULL;
; 1482 :         buffer_size = 0;

	mov	DWORD PTR buffer_size, edi
$LN20@SegmentIni:

; 1483 :         //flat_grp    = NULL;
; 1484 : #if FASTPASS
; 1485 : #if FASTMEM==0
; 1486 :         saved_SegStack = NULL;
; 1487 : #endif
; 1488 : #endif
; 1489 : 
; 1490 : #if 0 /* v2.03: obsolete, also belongs to simplified segment handling */
; 1491 :         /* set ModuleInfo.code_class */
; 1492 :         if( Options.code_class  )
; 1493 :             size = strlen( Options.code_class ) + 1;
; 1494 :         else
; 1495 :             size = 4 + 1;
; 1496 :         ModuleInfo.code_class = LclAlloc( size );
; 1497 :         if ( Options.code_class )
; 1498 :             strcpy( ModuleInfo.code_class, Options.code_class );
; 1499 :         else
; 1500 :             strcpy( ModuleInfo.code_class, "CODE" );
; 1501 : #endif
; 1502 :     }
; 1503 : 
; 1504 :     /*
; 1505 :      * alloc a buffer for the contents
; 1506 :      */
; 1507 : 
; 1508 :     if ( ModuleInfo.pCodeBuff == NULL && Options.output_format != OFORMAT_OMF ) {

	mov	r9, QWORD PTR ModuleInfo+448
	test	r9, r9
	jne	SHORT $LN34@SegmentIni
	cmp	DWORD PTR Options+156, 1
	je	SHORT $LN34@SegmentIni

; 1509 :         for( curr = SymTables[TAB_SEG].head, buffer_size = 0; curr; curr = curr->next ) {

	mov	rcx, QWORD PTR SymTables+32
	mov	r8d, edi
	mov	DWORD PTR buffer_size, edi
	test	rcx, rcx
	je	SHORT $LN34@SegmentIni
	npad	7
$LL18@SegmentIni:

; 1510 :             if ( curr->e.seginfo->internal )

	mov	rax, QWORD PTR [rcx+104]
	test	BYTE PTR [rax+107], 16
	jne	SHORT $LN17@SegmentIni

; 1511 :                 continue;
; 1512 :             if ( curr->e.seginfo->bytes_written ) {

	cmp	DWORD PTR [rax+24], edi
	je	SHORT $LN17@SegmentIni

; 1513 :                 i = curr->sym.max_offset - curr->e.seginfo->start_loc;

	mov	edx, DWORD PTR [rcx+64]
	sub	edx, DWORD PTR [rax+8]

; 1514 :                 /* the segment can grow in step 2-n due to forward references.
; 1515 :                  * for a quick solution just add 25% to the size if segment
; 1516 :                  * is a code segment. (v2.02: previously if was added only if
; 1517 :                  * code segment contained labels, but this isn't sufficient.)
; 1518 :                  */
; 1519 :                 //if ( curr->e.seginfo->labels ) /* v2.02: changed */
; 1520 :                 if ( curr->e.seginfo->segtype == SEGTYPE_CODE )

	cmp	DWORD PTR [rax+72], 1
	jne	SHORT $LN13@SegmentIni

; 1521 :                     i = i + (i >> 2);

	mov	eax, edx
	shr	eax, 2
	add	edx, eax
$LN13@SegmentIni:

; 1522 :                 DebugMsg(("SegmentInit(%u), %s: max_ofs=%" I32_SPEC "X, alloc_size=%" I32_SPEC "Xh\n", pass, curr->sym.name, curr->sym.max_offset, i ));
; 1523 :                 buffer_size += i;

	add	r8d, edx
$LN17@SegmentIni:

; 1509 :         for( curr = SymTables[TAB_SEG].head, buffer_size = 0; curr; curr = curr->next ) {

	mov	rcx, QWORD PTR [rcx+112]
	test	rcx, rcx
	jne	SHORT $LL18@SegmentIni

; 1524 :             }
; 1525 :         }
; 1526 :         if ( buffer_size ) {

	test	r8d, r8d
	mov	DWORD PTR buffer_size, r8d
	je	SHORT $LN34@SegmentIni

; 1527 :             ModuleInfo.pCodeBuff = LclAlloc( buffer_size );

	mov	ecx, r8d
	call	LclAlloc
	mov	r9, rax
	mov	QWORD PTR ModuleInfo+448, rax
$LN34@SegmentIni:

; 1528 :             DebugMsg(("SegmentInit(%u): total buffer size=%" I32_SPEC "X, start=%p\n", pass, buffer_size, ModuleInfo.pCodeBuff ));
; 1529 :         }
; 1530 :     }
; 1531 :     /* Reset length of all segments to zero.
; 1532 :      * set start of segment buffers.
; 1533 :      */
; 1534 : #if FASTMEM==0
; 1535 :     /* fastmem clears the memory blocks, but malloc() won't */
; 1536 :     if ( ModuleInfo.pCodeBuff )
; 1537 :         memset( ModuleInfo.pCodeBuff, 0, buffer_size );
; 1538 : #endif
; 1539 :     for( curr = SymTables[TAB_SEG].head, p = ModuleInfo.pCodeBuff; curr; curr = curr->next ) {

	mov	rdx, QWORD PTR SymTables+32
	test	rdx, rdx
	je	$LN9@SegmentIni
	lea	r8, OFFSET FLAT:codebuf
	npad	13
$LL11@SegmentIni:

; 1540 :         curr->e.seginfo->current_loc = 0;

	mov	rcx, QWORD PTR [rdx+104]
	mov	DWORD PTR [rcx+12], edi

; 1541 :         if ( curr->e.seginfo->internal )

	mov	rax, QWORD PTR [rdx+104]
	test	BYTE PTR [rax+107], 16
	jne	SHORT $LN10@SegmentIni

; 1542 :             continue;
; 1543 :         if ( curr->e.seginfo->bytes_written ) {

	cmp	DWORD PTR [rax+24], edi
	je	SHORT $LN5@SegmentIni

; 1544 :             if ( Options.output_format == OFORMAT_OMF ) {

	cmp	DWORD PTR Options+156, 1
	jne	SHORT $LN6@SegmentIni

; 1545 :                 curr->e.seginfo->CodeBuffer = codebuf;

	mov	QWORD PTR [rax+16], r8

; 1546 :                 DebugMsg(("SegmentInit(%u), %s: buffer=%p\n", pass, curr->sym.name, codebuf ));
; 1547 :             } else {

	jmp	SHORT $LN5@SegmentIni
$LN6@SegmentIni:

; 1548 :                 curr->e.seginfo->CodeBuffer = p;

	mov	QWORD PTR [rax+16], r9

; 1549 :                 i = curr->sym.max_offset - curr->e.seginfo->start_loc;

	mov	rax, QWORD PTR [rdx+104]
	mov	ecx, DWORD PTR [rdx+64]
	sub	ecx, DWORD PTR [rax+8]

; 1550 :                 DebugMsg(("SegmentInit(%u), %s: size=%" I32_SPEC "X buffer=%p\n", pass, curr->sym.name, i, p ));
; 1551 :                 p += i;

	mov	eax, ecx
	add	r9, rax
$LN5@SegmentIni:

; 1552 :             }
; 1553 :         }
; 1554 :         if( curr->e.seginfo->combine != COMB_STACK ) {

	mov	rcx, QWORD PTR [rdx+104]
	movzx	eax, BYTE PTR [rcx+108]
	and	al, 7
	cmp	al, 5
	je	SHORT $LN4@SegmentIni

; 1555 :             curr->sym.max_offset = 0;

	mov	DWORD PTR [rdx+64], edi
$LN4@SegmentIni:

; 1556 :         }
; 1557 :         if ( Options.output_format == OFORMAT_OMF ) { /* v2.03: do this selectively */

	cmp	DWORD PTR Options+156, 1
	jne	SHORT $LN3@SegmentIni

; 1558 :             curr->e.seginfo->start_loc = 0;

	mov	DWORD PTR [rcx+8], edi

; 1559 :             curr->e.seginfo->data_in_code = FALSE;

	mov	rax, QWORD PTR [rdx+104]
	and	BYTE PTR [rax+107], 247			; 000000f7H
$LN3@SegmentIni:

; 1560 :         }
; 1561 :         curr->e.seginfo->bytes_written = 0;

	mov	rax, QWORD PTR [rdx+104]
	mov	DWORD PTR [rax+24], edi

; 1562 : 
; 1563 :         //if ( Options.output_format != OFORMAT_OMF ) {
; 1564 :         curr->e.seginfo->FixupList.head = NULL;

	mov	rax, QWORD PTR [rdx+104]
	mov	QWORD PTR [rax+40], rdi

; 1565 :         curr->e.seginfo->FixupList.tail = NULL;

	mov	rax, QWORD PTR [rdx+104]
	mov	QWORD PTR [rax+48], rdi
$LN10@SegmentIni:
	mov	rdx, QWORD PTR [rdx+112]
	test	rdx, rdx
	jne	SHORT $LL11@SegmentIni
$LN9@SegmentIni:

; 1566 :         //}
; 1567 :     }
; 1568 : 
; 1569 :     ModuleInfo.Ofssize = USE16;
; 1570 : 
; 1571 : #if FASTPASS
; 1572 :     if ( pass != PASS_1 && UseSavedState == TRUE ) {

	test	ebx, ebx
	mov	BYTE PTR ModuleInfo+404, dil
	je	$LN26@SegmentIni
	cmp	BYTE PTR UseSavedState, 1
	jne	$LN26@SegmentIni

; 1573 :         CurrSeg = saved_CurrSeg;
; 1574 :         stkindex = saved_stkindex;

	movsxd	rax, DWORD PTR saved_stkindex
	mov	rbx, QWORD PTR saved_CurrSeg

; 1575 :         if ( stkindex )

	test	eax, eax
	mov	QWORD PTR ModuleInfo+432, rbx
	mov	DWORD PTR stkindex, eax
	je	SHORT $LN1@SegmentIni

; 1576 :             memcpy( &SegStack, saved_SegStack, stkindex * sizeof(struct dsym *) );

	mov	rdx, QWORD PTR saved_SegStack
	mov	r8, rax
	lea	rcx, OFFSET FLAT:SegStack
	shl	r8, 3
	call	memcpy
$LN1@SegmentIni:

; 1577 : 
; 1578 :         //symCurSeg->string_ptr = saved_CurSeg_name;
; 1579 : 
; 1580 :         UpdateCurrSegVars();

	test	rbx, rbx
	jne	SHORT $LN27@SegmentIni
	mov	QWORD PTR SegAssumeTable+16, rdi
	mov	BYTE PTR SegAssumeTable+25, dil
	mov	BYTE PTR SegAssumeTable+24, 1
	lea	rcx, OFFSET FLAT:$SG6009
	jmp	SHORT $LN35@SegmentIni
$LN27@SegmentIni:
	mov	BYTE PTR SegAssumeTable+25, dil
	mov	BYTE PTR SegAssumeTable+24, dil
	mov	rax, QWORD PTR [rbx+104]
	cmp	QWORD PTR [rax], rdi
	je	SHORT $LN25@SegmentIni
	mov	rax, QWORD PTR [rax]
	cmp	rax, QWORD PTR ModuleInfo+440
	mov	QWORD PTR SegAssumeTable+16, rax
	jne	SHORT $LN23@SegmentIni
	mov	BYTE PTR SegAssumeTable+25, 1
	jmp	SHORT $LN23@SegmentIni
$LN25@SegmentIni:
	mov	QWORD PTR SegAssumeTable+16, rbx
$LN23@SegmentIni:
	mov	rcx, QWORD PTR [rbx+8]
$LN35@SegmentIni:
	mov	rax, QWORD PTR symCurSeg
	mov	QWORD PTR [rax+16], rcx
$LN26@SegmentIni:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 1581 :     }
; 1582 : #endif
; 1583 : }

	add	rsp, 40					; 00000028H
	ret	0
SegmentInit ENDP
_TEXT	ENDS
PUBLIC	SegmentSaveState
xdata	SEGMENT
$unwind$SegmentSaveState DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SegmentSaveState DD @imagerel($LN4#)
	DD	@imagerel($LN4#+85)
	DD	@imagerel($unwind$SegmentSaveState#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
SegmentSaveState PROC NEAR

; 1587 : {

$LN4:
	sub	rsp, 40					; 00000028H

; 1588 :     //int i;
; 1589 : 
; 1590 :     //i = stkindex;
; 1591 : 
; 1592 :     saved_CurrSeg = CurrSeg;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR saved_CurrSeg, rax

; 1593 :     saved_stkindex = stkindex;

	movsxd	rax, DWORD PTR stkindex

; 1594 :     if ( stkindex ) {

	test	eax, eax
	mov	DWORD PTR saved_stkindex, eax
	je	SHORT $LN1@SegmentSav

; 1595 :         saved_SegStack = LclAlloc( stkindex * sizeof(struct dsym *) );

	mov	rcx, rax
	shl	rcx, 3
	call	LclAlloc

; 1596 :         memcpy( saved_SegStack, &SegStack, stkindex * sizeof(struct dsym *) );

	movsxd	r8, DWORD PTR stkindex
	lea	rdx, OFFSET FLAT:SegStack
	shl	r8, 3
	mov	rcx, rax
	mov	QWORD PTR saved_SegStack, rax
	call	memcpy
$LN1@SegmentSav:

; 1597 :         DebugMsg(("SegmentSaveState: saved_segStack=%X\n", saved_SegStack ));
; 1598 :     }
; 1599 : 
; 1600 :     //saved_CurSeg_name  = symCurSeg->string_ptr;
; 1601 : }

	add	rsp, 40					; 00000028H
	ret	0
SegmentSaveState ENDP
_TEXT	ENDS
PUBLIC	UpdateCurPC
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
sym$ = 8
p$ = 16
UpdateCurPC PROC NEAR

; 132  :     if( CurrStruct ) {

	cmp	QWORD PTR CurrStruct, 0
	mov	rdx, rcx
	je	SHORT $LN4@UpdateCurP

; 133  :         //symPC.segment = NULL;
; 134  :         //symPC.mem_type = MT_ABS;
; 135  :         sym->mem_type = MT_EMPTY;

	mov	DWORD PTR [rcx+44], 192			; 000000c0H

; 136  :         sym->segment = NULL; /* v2.07: needed again */

	xor	ecx, ecx
	mov	QWORD PTR [rdx+32], rcx

; 137  :         sym->offset = CurrStruct->sym.offset + (CurrStruct->next ? CurrStruct->next->sym.offset : 0);

	mov	r8, QWORD PTR CurrStruct
	mov	rax, QWORD PTR [r8+112]
	test	rax, rax
	je	SHORT $LN8@UpdateCurP
	mov	ecx, DWORD PTR [rax+16]
$LN8@UpdateCurP:
	add	ecx, DWORD PTR [r8+16]
	mov	DWORD PTR [rdx+16], ecx

; 144  : 
; 145  :     DebugMsg1(("UpdateCurPC: curr value=%" I32_SPEC "Xh\n", sym->offset ));
; 146  : }

	ret	0
$LN4@UpdateCurP:

; 138  :     } else if ( CurrSeg ) { /* v2.10: check for CurrSeg != NULL */

	cmp	QWORD PTR ModuleInfo+432, 0
	je	SHORT $LN2@UpdateCurP

; 139  :         sym->mem_type = MT_NEAR;

	mov	DWORD PTR [rcx+44], 129			; 00000081H

; 140  :         sym->segment = (struct asym *)CurrSeg;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rcx+32], rax

; 141  :         sym->offset = GetCurrOffset();

	mov	rax, QWORD PTR ModuleInfo+432
	test	rax, rax
	je	SHORT $LN11@UpdateCurP
	mov	rax, QWORD PTR [rax+104]
	mov	ecx, DWORD PTR [rax+12]
	mov	DWORD PTR [rdx+16], ecx

; 144  : 
; 145  :     DebugMsg1(("UpdateCurPC: curr value=%" I32_SPEC "Xh\n", sym->offset ));
; 146  : }

	ret	0

; 141  :         sym->offset = GetCurrOffset();

$LN11@UpdateCurP:
	xor	ecx, ecx
	mov	DWORD PTR [rdx+16], ecx

; 144  : 
; 145  :     DebugMsg1(("UpdateCurPC: curr value=%" I32_SPEC "Xh\n", sym->offset ));
; 146  : }

	ret	0
$LN2@UpdateCurP:

; 142  :     } else
; 143  :         EmitErr( MUST_BE_IN_SEGMENT_BLOCK ); /* v2.10: added */

	mov	ecx, 82					; 00000052H

; 144  : 
; 145  :     DebugMsg1(("UpdateCurPC: curr value=%" I32_SPEC "Xh\n", sym->offset ));
; 146  : }

	jmp	EmitErr
UpdateCurPC ENDP
_TEXT	ENDS
END
