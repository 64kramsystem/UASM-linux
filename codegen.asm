; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	szNull
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
szNull	DB	'<NULL>', 00H
	ORG $+1
sr_prefix DB	026H
	DB	02eH
	DB	036H
	DB	03eH
	DB	064H
	DB	065H
CONST	ENDS
PUBLIC	GetByteDisp
EXTRN	__ImageBase:BYTE
xdata	SEGMENT
$unwind$GetByteDisp DD 020901H
	DD	030021209H
xdata	ENDS
pdata	SEGMENT
$pdata$GetByteDisp DD @imagerel($LN19#)
	DD	@imagerel($LN19#+508)
	DD	@imagerel($unwind$GetByteDisp#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\codegen.c
pdata	ENDS
_TEXT	SEGMENT
fvarr$ = 0
duparr$ = 32
CodeInfo$ = 32
hvarr$ = 40
GetByteDisp PROC NEAR

; 67   : {

$LN19:
	push	rbx
	mov	rax, rsp
	sub	rsp, 16

; 68   :     const uint_8 fvarr[2][2][3] = {{{16, 32, 64}, {4, 4, 4}},    // Full Vector (FV)
; 69   :                                   {{16, 32, 64}, {8, 8, 8}}};
; 70   :     const uint_8 hvarr[2][3]    =  {{8, 16, 32}, {4, 4, 4}};     // Half Vector (HV) 
; 71   :     const uint_8 duparr[3]      =   {8, 32, 64};                 // VMOVDDUP    (DUP)
; 72   :                                                   //RXBR00MM
; 73   :     uint_8 n = 0;
; 74   :     bool evexW            = (CodeInfo->evex_p1 & EVEX_P1WMASK) >> 7;
; 75   :     enum ttypes   tuple   = CodeInfo->pinstr->prefix & 0x1F;
; 76   :     bool evexB            = (CodeInfo->evex_p2 & EVEX_P2BMASK) >> 4;

	movzx	r9d, BYTE PTR [rcx+139]
	movzx	r10d, BYTE PTR [rcx+138]
	mov	BYTE PTR fvarr$[rsp], 16
	movzx	r11d, r9b
	mov	BYTE PTR [rax-15], 32			; 00000020H
	mov	BYTE PTR [rax-14], 64			; 00000040H
	mov	BYTE PTR [rax-13], 4
	mov	BYTE PTR [rax-12], 4
	mov	BYTE PTR [rax-11], 4
	mov	BYTE PTR [rax-10], 16
	mov	BYTE PTR [rax-9], 32			; 00000020H
	mov	BYTE PTR [rax-8], 64			; 00000040H
	mov	BYTE PTR [rax-7], 8
	mov	BYTE PTR [rax-6], 8
	mov	BYTE PTR [rax-5], 8
	mov	BYTE PTR [rax+24], 8
	mov	BYTE PTR [rax+25], 16
	mov	BYTE PTR [rax+26], 32			; 00000020H
	mov	BYTE PTR [rax+27], 4
	mov	BYTE PTR [rax+28], 4
	mov	BYTE PTR [rax+29], 4
	mov	BYTE PTR [rax+16], 8
	mov	BYTE PTR [rax+17], 32			; 00000020H
	mov	BYTE PTR [rax+18], 64			; 00000040H
	mov	rax, QWORD PTR [rcx+16]
	shr	r11b, 4

; 77   :     uint_8  vctln         = (CodeInfo->evex_p2 & EVEX_P2LLMASK) >> 5;

	shr	r9b, 5
	mov	r8b, BYTE PTR [rax+8]
	xor	dl, dl
	shr	r10b, 7
	and	r8d, 31
	and	r11b, 1
	and	r9b, 3

; 78   :     
; 79   : 
; 80   :     switch(tuple) {

	lea	eax, DWORD PTR [r8-1]
	cmp	eax, 19
	ja	$LN1@GetByteDis
	lea	rbx, OFFSET FLAT:__ImageBase
	cdqe
	mov	ecx, DWORD PTR $LN18@GetByteDis[rbx+rax*4]
	add	rcx, rbx
	jmp	rcx
$LN13@GetByteDis:

; 81   :     case FV:         // Full Vector 
; 82   :         n = fvarr[evexW][evexB][vctln];

	movzx	eax, r11b
	movzx	ecx, r10b
	lea	rcx, QWORD PTR [rax+rcx*2]
	movzx	eax, r9b
	lea	rdx, QWORD PTR [rcx+rcx*2]
	lea	rcx, QWORD PTR fvarr$[rsp+rax]
	mov	dl, BYTE PTR [rcx+rdx]

; 119  :         break;
; 120  : 
; 121  :     default:
; 122  :         break;
; 123  :     }
; 124  :     return n;

	mov	al, dl

; 125  : }

	add	rsp, 16
	pop	rbx
	ret	0
$LN12@GetByteDis:

; 83   :         break;
; 84   :     case HV:        // Half Vector 
; 85   :         n = hvarr[evexB][vctln];

	movzx	eax, r11b
	lea	rdx, QWORD PTR [rax+rax*2]
	movzx	eax, r9b
	lea	rcx, QWORD PTR hvarr$[rsp+rax]
	mov	dl, BYTE PTR [rcx+rdx]

; 119  :         break;
; 120  : 
; 121  :     default:
; 122  :         break;
; 123  :     }
; 124  :     return n;

	mov	al, dl

; 125  : }

	add	rsp, 16
	pop	rbx
	ret	0
$LN11@GetByteDis:

; 86   :         break;
; 87   :     case FVM:       // Full Vector Mem
; 88   :         n = 1 << (vctln + 4);

	mov	al, r9b
	mov	edx, 1
	lea	ecx, DWORD PTR [rax+4]
	shl	dl, cl

; 119  :         break;
; 120  : 
; 121  :     default:
; 122  :         break;
; 123  :     }
; 124  :     return n;

	mov	al, dl

; 125  : }

	add	rsp, 16
	pop	rbx
	ret	0
$LN10@GetByteDis:

; 89   :         break;
; 90   :     case T1S8:      // Tuple1 Scalar
; 91   :     case T1S16: 
; 92   :         n = tuple - T1S8 + 1;

	lea	edx, DWORD PTR [r8-3]

; 119  :         break;
; 120  : 
; 121  :     default:
; 122  :         break;
; 123  :     }
; 124  :     return n;

	mov	al, dl

; 125  : }

	add	rsp, 16
	pop	rbx
	ret	0
$LN9@GetByteDis:

; 93   :         break;
; 94   :     case T1S:
; 95   :         n = evexW ? 8 : 4;

	mov	edx, 8
	mov	eax, 4
	test	r10b, r10b
	cmovne	eax, edx
	mov	dl, al

; 125  : }

	add	rsp, 16
	pop	rbx
	ret	0
$LN8@GetByteDis:

; 96   :         break;
; 97   :     case T1F32:    // Tuple1 Fixed
; 98   :     case T1F64:
; 99   :         n = (tuple == T1F32 ? 4 : 8);

	mov	eax, 4
	mov	edx, 8
	cmp	r8d, 7
	cmove	edx, eax

; 119  :         break;
; 120  : 
; 121  :     default:
; 122  :         break;
; 123  :     }
; 124  :     return n;

	mov	al, dl

; 125  : }

	add	rsp, 16
	pop	rbx
	ret	0
$LN7@GetByteDis:

; 100  :         break;
; 101  :     case T2:       // Tuple2
; 102  :     case T4:       // Tuple4
; 103  :     case T8:       // Tuple8
; 104  :         if (vctln + 7 <= (evexW + 5) + (tuple - T2 + 1))

	movzx	edx, r10b
	movzx	ecx, r9b
	add	edx, r8d
	add	ecx, 7
	lea	eax, DWORD PTR [rdx-5]
	cmp	ecx, eax
	jg	SHORT $LN6@GetByteDis

; 105  :             n = 0;

	xor	dl, dl

; 119  :         break;
; 120  : 
; 121  :     default:
; 122  :         break;
; 123  :     }
; 124  :     return n;

	mov	al, dl

; 125  : }

	add	rsp, 16
	pop	rbx
	ret	0
$LN6@GetByteDis:

; 106  :         else
; 107  :             n = 1 << (tuple - T2 + evexW + 3);

	lea	ecx, DWORD PTR [rdx-8]
	mov	edx, 1
	shl	dl, cl

; 119  :         break;
; 120  : 
; 121  :     default:
; 122  :         break;
; 123  :     }
; 124  :     return n;

	mov	al, dl

; 125  : }

	add	rsp, 16
	pop	rbx
	ret	0
$LN4@GetByteDis:

; 108  :         break;
; 109  :     case HVM:      // Half Mem
; 110  :     case QVM:      // QuarterMem
; 111  :     case OVM:      // OctMem
; 112  :         n = 1 << (OVM - tuple + vctln + 1);

	mov	al, r9b
	mov	edx, 1
	sub	eax, r8d
	lea	ecx, DWORD PTR [rax+17]
	shl	dl, cl

; 119  :         break;
; 120  : 
; 121  :     default:
; 122  :         break;
; 123  :     }
; 124  :     return n;

	mov	al, dl

; 125  : }

	add	rsp, 16
	pop	rbx
	ret	0
$LN3@GetByteDis:

; 113  :         break;
; 114  :     case T128:     // Mem128
; 115  :         n = 16;

	mov	dl, 16

; 119  :         break;
; 120  : 
; 121  :     default:
; 122  :         break;
; 123  :     }
; 124  :     return n;

	mov	al, dl

; 125  : }

	add	rsp, 16
	pop	rbx
	ret	0
$LN2@GetByteDis:

; 116  :         break;
; 117  :     case DUP:      // MOVDDUP
; 118  :         n = duparr[vctln];

	movzx	eax, r9b
	mov	dl, BYTE PTR duparr$[rsp+rax]
$LN1@GetByteDis:

; 119  :         break;
; 120  : 
; 121  :     default:
; 122  :         break;
; 123  :     }
; 124  :     return n;

	mov	al, dl

; 125  : }

	add	rsp, 16
	pop	rbx
	ret	0
	npad	3
$LN18@GetByteDis:
	DD	$LN13@GetByteDis
	DD	$LN12@GetByteDis
	DD	$LN11@GetByteDis
	DD	$LN10@GetByteDis
	DD	$LN10@GetByteDis
	DD	$LN9@GetByteDis
	DD	$LN8@GetByteDis
	DD	$LN1@GetByteDis
	DD	$LN1@GetByteDis
	DD	$LN8@GetByteDis
	DD	$LN7@GetByteDis
	DD	$LN7@GetByteDis
	DD	$LN7@GetByteDis
	DD	$LN4@GetByteDis
	DD	$LN4@GetByteDis
	DD	$LN4@GetByteDis
	DD	$LN3@GetByteDis
	DD	$LN1@GetByteDis
	DD	$LN1@GetByteDis
	DD	$LN2@GetByteDis
GetByteDisp ENDP
_TEXT	ENDS
PUBLIC	Check4CompDisp8
xdata	SEGMENT
$unwind$Check4CompDisp8 DD 071a01H
	DD	09741aH
	DD	086415H
	DD	073410H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$Check4CompDisp8 DD @imagerel($LN6#)
	DD	@imagerel($LN6#+126)
	DD	@imagerel($unwind$Check4CompDisp8#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
CodeInfo$ = 48
comprdsp$ = 56
d$ = 64
disp$ = 72
Check4CompDisp8 PROC NEAR

; 129  : {

$LN6:
	sub	rsp, 40					; 00000028H

; 130  :     int_32 disp32           = disp;
; 131  :     uint_8 n;
; 132  :     int_32 disp8;
; 133  :     if (CodeInfo->evex_flag){  //Do it only for EVEX instructions

	cmp	BYTE PTR [rcx+136], 0
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	mov	rsi, r8
	mov	rbx, rdx
	mov	edi, r9d
	je	SHORT $LN1@Check4Comp

; 134  :       n = GetByteDisp(CodeInfo);

	call	GetByteDisp

; 135  :       *d = n;
; 136  :       if (n && !(disp32 & (n - 1))) {

	test	al, al
	movzx	ecx, al
	mov	DWORD PTR [rsi], ecx
	je	SHORT $LN1@Check4Comp
	lea	eax, DWORD PTR [rcx-1]
	test	eax, edi
	jne	SHORT $LN1@Check4Comp

; 137  :         disp8 = disp32 / n;

	mov	eax, edi
	cdq
	idiv	ecx

; 138  :         /* if it fits in Disp8 */
; 139  :         if (disp8 >= -128 && disp8 <= 127) {

	lea	ecx, DWORD PTR [rax+128]
	cmp	ecx, 255				; 000000ffH
	ja	SHORT $LN1@Check4Comp

; 140  :           *comprdsp = disp8;

	mov	BYTE PTR [rbx], al

; 141  :           return TRUE;

	mov	al, 1
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 147  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN1@Check4Comp:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]

; 142  :           }
; 143  :         }
; 144  :       }
; 145  :     *comprdsp = 0;

	mov	BYTE PTR [rbx], 0
	mov	rbx, QWORD PTR [rsp+56]

; 146  :     return FALSE;

	xor	al, al

; 147  : }

	add	rsp, 40					; 00000028H
	ret	0
Check4CompDisp8 ENDP
_TEXT	ENDS
EXTRN	opnd_clstab:BYTE
EXTRN	vex_flags:BYTE
EXTRN	ResWordTable:BYTE
EXTRN	OutputByte:NEAR
EXTRN	AddFloatingPointEmulationFixup:NEAR
EXTRN	EmitError:NEAR
EXTRN	InstrTable:BYTE
EXTRN	optable_idx:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	AddLinnumDataRef:NEAR
EXTRN	get_curr_srcfile:NEAR
EXTRN	GetLineNumber:NEAR
EXTRN	Options:BYTE
xdata	SEGMENT
$unwind$output_opc DD 0da101H
	DD	05f4a1H
	DD	06e424H
	DD	08c418H
	DD	0d7413H
	DD	0c640eH
	DD	0a3409H
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$output_opc DD @imagerel(output_opc#)
	DD	@imagerel(output_opc#+338)
	DD	@imagerel($unwind$output_opc#)
pdata	ENDS
xdata	SEGMENT
$chain$6$output_opc DD 020521H
	DD	0b5405H
	DD	@imagerel(output_opc#)
	DD	@imagerel(output_opc#+338)
	DD	@imagerel($unwind$output_opc#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$output_opc DD @imagerel(output_opc#+338)
	DD	@imagerel(output_opc#+1089)
	DD	@imagerel($chain$6$output_opc#)
pdata	ENDS
xdata	SEGMENT
$chain$7$output_opc DD 020521H
	DD	07d405H
	DD	@imagerel(output_opc#+338)
	DD	@imagerel(output_opc#+1089)
	DD	@imagerel($chain$6$output_opc#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$output_opc DD @imagerel(output_opc#+1089)
	DD	@imagerel(output_opc#+11128)
	DD	@imagerel($chain$7$output_opc#)
pdata	ENDS
xdata	SEGMENT
$chain$8$output_opc DD 021H
	DD	@imagerel(output_opc#+338)
	DD	@imagerel(output_opc#+1089)
	DD	@imagerel($chain$6$output_opc#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$output_opc DD @imagerel(output_opc#+11128)
	DD	@imagerel(output_opc#+11220)
	DD	@imagerel($chain$8$output_opc#)
pdata	ENDS
xdata	SEGMENT
$chain$9$output_opc DD 020021H
	DD	07d400H
	DD	@imagerel(output_opc#+338)
	DD	@imagerel(output_opc#+1089)
	DD	@imagerel($chain$6$output_opc#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$output_opc DD @imagerel(output_opc#+11220)
	DD	@imagerel(output_opc#+11540)
	DD	@imagerel($chain$9$output_opc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
CodeInfo$ = 80
output_opc PROC NEAR

; 169  : {

	sub	rsp, 72					; 00000048H
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+104], rdi
	mov	QWORD PTR [rsp+64], r12

; 170  :   const struct instr_item *ins = CodeInfo->pinstr;

	mov	r12, QWORD PTR [rcx+16]

; 171  :   uint_8           tmp;
; 172  :   uint_8           fpfix = FALSE;

	xor	sil, sil
	mov	QWORD PTR [rsp+48], r14

; 173  :   int              rn;
; 174  :   unsigned char    c;
; 175  :   int_8            comprdsp = 0;

	xor	r14b, r14b

; 176  : 
; 177  :   DebugMsg1(("output_opc enter, ins.opc/rm=%X/%X, byte1_info=%X CodeInfo->rm=%X opsiz=%u\n", ins->opcode, ins->rm_byte, ins->byte1_info, CodeInfo->rm_byte, CodeInfo->prefix.opsiz));
; 178  :   /*
; 179  :    * Output debug info - line numbers
; 180  :    */
; 181  :   if (Options.line_numbers)

	cmp	BYTE PTR Options+1, sil
	mov	rdi, rcx
	je	SHORT $LN809@output_opc

; 182  :     AddLinnumDataRef(get_curr_srcfile(), GetLineNumber());

	call	GetLineNumber
	mov	ebx, eax
	call	get_curr_srcfile
	mov	edx, ebx
	mov	ecx, eax
	call	AddLinnumDataRef
$LN809@output_opc:

; 183  :   /* if it's a FPU instr, reset opsiz */
; 184  :   //if( ins->cpu & P_FPU_MASK ) {
; 185  :   /* v2.02: if it's a FPU or MMX/SSE instr, reset opsiz!
; 186  :    * [this code has been moved here from codegen()]
; 187  :    */
; 188  :   if (ins->cpu & (P_FPU_MASK | P_MMX | P_SSEALL)) {

	test	WORD PTR [r12+10], 64775		; 0000fd07H
	je	SHORT $LN807@output_opc

; 189  : #if SSE4SUPP
; 190  :     /* there are 2 exceptions. how to avoid this ugly hack? */
; 191  :     if (CodeInfo->token != T_CRC32 &&
; 192  :       CodeInfo->token != T_POPCNT)

	mov	eax, DWORD PTR [rdi+24]
	cmp	eax, 1275				; 000004fbH
	je	SHORT $LN807@output_opc
	cmp	eax, 1281				; 00000501H
	je	SHORT $LN807@output_opc

; 193  : #endif
; 194  :       CodeInfo->prefix.opsiz = FALSE;

	and	BYTE PTR [rdi+9], 253			; 000000fdH
$LN807@output_opc:

; 195  :   }
; 196  :   if ((CodeInfo->token == T_RDRAND) || (CodeInfo->token == T_RDSEED)){

	movsxd	r9, DWORD PTR [rdi+24]
	cmp	r9d, 1282				; 00000502H
	je	SHORT $LN805@output_opc
	cmp	r9d, 1283				; 00000503H
	jne	SHORT $LN804@output_opc
$LN805@output_opc:

; 197  :     if ((CodeInfo->opnd[OPND1].type == OP_R16) || (CodeInfo->opnd[OPND1].type == OP_AX))

	mov	eax, DWORD PTR [rdi+32]
	cmp	eax, 2
	je	SHORT $LN803@output_opc
	cmp	eax, 514				; 00000202H
	jne	SHORT $LN804@output_opc
$LN803@output_opc:

; 198  :       CodeInfo->prefix.opsiz = TRUE;

	or	BYTE PTR [rdi+9], 2
$LN804@output_opc:

; 199  :   } 
; 200  :   /*
; 201  :    * Check if CPU, FPU and extensions are within the limits
; 202  :    */
; 203  :   if ((ins->cpu & P_CPU_MASK) > (ModuleInfo.curr_cpu & P_CPU_MASK)
; 204  :     || (ins->cpu & P_FPU_MASK) > (ModuleInfo.curr_cpu & P_FPU_MASK)
; 205  :     || (ins->cpu & P_EXT_MASK) > (ModuleInfo.curr_cpu & P_EXT_MASK)) {

	movzx	r8d, WORD PTR [r12+10]
	mov	edx, DWORD PTR ModuleInfo+392
	mov	QWORD PTR [rsp+40], r15
	mov	ecx, r8d
	mov	eax, edx
	lea	r15, OFFSET FLAT:__ImageBase
	and	ecx, 240				; 000000f0H
	and	eax, 240				; 000000f0H
	cmp	ecx, eax
	jg	SHORT $LN801@output_opc
	mov	ecx, r8d
	mov	eax, edx
	and	ecx, 7
	and	eax, 7
	cmp	cl, al
	jg	SHORT $LN801@output_opc
	mov	eax, r8d
	and	edx, 65280				; 0000ff00H
	and	eax, 65280				; 0000ff00H
	cmp	eax, edx
	jle	SHORT $LN799@output_opc
$LN801@output_opc:

; 206  :     DebugMsg(("output_opc: wrong cpu setting: instr.cpu=%X, ModuleInfo.cpu=%X\n",
; 207  :       ins->cpu, ModuleInfo.curr_cpu));
; 208  :     /* if instruction is valid for 16bit cpu, but operands aren't,
; 209  :      then display a more specific error message! */
; 210  :     if (ins->cpu == P_386 &&
; 211  :       ((InstrTable[IndexFromToken(CodeInfo->token)].cpu & P_CPU_MASK) <= P_386))

	cmp	r8d, 48					; 00000030H
	jne	SHORT $LN800@output_opc
	movzx	ecx, WORD PTR optable_idx[r15+r9*2-910]
	mov	rax, r9
	imul	rcx, 14
	mov	al, BYTE PTR InstrTable[rcx+r15+10]
	and	ax, 240					; 000000f0H
	cmp	ax, r8w
	ja	SHORT $LN800@output_opc

; 212  :       EmitError(INSTRUCTION_FORM_REQUIRES_80386);

	mov	ecx, 238				; 000000eeH
	call	EmitError

; 213  :     else

	jmp	SHORT $LN799@output_opc
$LN800@output_opc:

; 214  :       EmitError(INSTRUCTION_OR_REGISTER_NOT_ACCEPTED_IN_CURRENT_CPU_MODE);

	mov	ecx, 30
	call	EmitError
$LN799@output_opc:

; 215  :     //return( ERROR );
; 216  :   }
; 217  : 
; 218  :   /*
; 219  :    * Output FP fixup if required
; 220  :    * the OPs with NOWAIT are the instructions beginning with
; 221  :    * FN, except FNOP.
; 222  :    * the OPs with WAIT are the instructions:
; 223  :    * FCLEX, FDISI, FENI, FINIT, FSAVEx, FSTCW, FSTENVx, FSTSW
; 224  :    */
; 225  :   if ((ModuleInfo.emulator == TRUE) &&
; 226  :     (CodeInfo->Ofssize == USE16) &&
; 227  :     (ins->cpu & P_FPU_MASK) &&
; 228  :     (ins->allowed_prefix != AP_NO_FWAIT)) {

	mov	edx, DWORD PTR ModuleInfo+408
	bt	edx, 10
	jae	SHORT $LN798@output_opc
	cmp	BYTE PTR [rdi+106], 0
	jne	SHORT $LN798@output_opc
	test	BYTE PTR [r12+10], 7
	je	SHORT $LN798@output_opc
	cmp	WORD PTR [r12+2], 5
	je	SHORT $LN798@output_opc

; 229  :     fpfix = TRUE;
; 230  :     /* v2.04: no error is returned */
; 231  :     AddFloatingPointEmulationFixup(CodeInfo);

	mov	rcx, rdi
	mov	sil, 1
	call	AddFloatingPointEmulationFixup
	mov	edx, DWORD PTR ModuleInfo+408
$LN798@output_opc:

; 232  :   }
; 233  :   /*
; 234  :    * Output instruction prefix LOCK, REP or REP[N]E|Z
; 235  :    */
; 236  :   if (CodeInfo->prefix.ins != EMPTY && (CodeInfo->token < T_VPGATHERDD || CodeInfo->token > T_VGATHERQPS)) {

	movsxd	rcx, DWORD PTR [rdi]
	mov	QWORD PTR [rsp+88], rbp
	mov	ebp, 3
	cmp	ecx, -2
	je	SHORT $LN793@output_opc
	mov	eax, DWORD PTR [rdi+24]
	cmp	eax, 1365				; 00000555H
	jl	SHORT $LN796@output_opc
	cmp	eax, 1372				; 0000055cH
	jle	SHORT $LN793@output_opc
$LN796@output_opc:

; 237  :     tmp = InstrTable[IndexFromToken(CodeInfo->prefix.ins)].allowed_prefix;

	mov	rax, rcx
	movzx	ecx, WORD PTR optable_idx[r15+rcx*2-910]
	imul	rcx, 14

; 238  :     /* instruction prefix must be ok. However, with -Zm, the plain REP
; 239  :      * is also ok for instructions which expect REPxx.
; 240  :      */
; 241  :     if (ModuleInfo.m510 == TRUE &&
; 242  :       tmp == AP_REP &&
; 243  :       ins->allowed_prefix == AP_REPxx)

	test	dl, dl
	mov	al, BYTE PTR InstrTable[rcx+r15+2]
	jns	SHORT $LN795@output_opc
	cmp	al, 2
	jne	SHORT $LN795@output_opc
	cmp	WORD PTR [r12+2], bp
	movzx	eax, al
	cmove	eax, ebp
$LN795@output_opc:

; 244  :       tmp = AP_REPxx;
; 245  : 
; 246  :     if (ins->allowed_prefix != tmp) {

	movzx	eax, al
	cmp	WORD PTR [r12+2], ax
	je	SHORT $LN794@output_opc

; 247  :       EmitError(INSTRUCTION_PREFIX_NOT_ALLOWED);

	mov	ecx, 28
	call	EmitError

; 248  :     }
; 249  :     else

	jmp	SHORT $LN793@output_opc
$LN794@output_opc:

; 250  :       OutputCodeByte(InstrTable[IndexFromToken(CodeInfo->prefix.ins)].opcode);

	movzx	ecx, BYTE PTR InstrTable[rcx+r15+12]
	call	OutputByte
$LN793@output_opc:

; 251  :   }
; 252  :   /*
; 253  :    * Output FP FWAIT if required
; 254  :    */
; 255  :   if (ins->cpu & P_FPU_MASK) {

	test	BYTE PTR [r12+10], 7
	je	SHORT $LN784@output_opc

; 256  :     if (CodeInfo->token == T_FWAIT) {

	cmp	DWORD PTR [rdi+24], 833			; 00000341H
	jne	SHORT $LN791@output_opc

; 257  :       /* v2.04: Masm will always insert a NOP if emulation is active,
; 258  :        * no matter what the current cpu is. The reason is simple: the
; 259  :        * nop is needed because of the fixup which was inserted.
; 260  :        */
; 261  :       //if(( ModuleInfo.curr_cpu & P_CPU_MASK ) < P_386 ) {
; 262  :       //    if(( ModuleInfo.emulator == TRUE ) && ( CodeInfo->Ofssize == USE16 )) {
; 263  :       if (fpfix) {

	test	sil, sil
	je	SHORT $LN784@output_opc

; 264  :         OutputCodeByte(OP_NOP);

	mov	cl, 144					; 00000090H
	call	OutputByte

; 265  :       }

	jmp	SHORT $LN784@output_opc
$LN791@output_opc:

; 266  :     }
; 267  :     else if (fpfix || ins->allowed_prefix == AP_FWAIT) {

	test	sil, sil
	jne	SHORT $LN787@output_opc
	movzx	eax, WORD PTR [r12+2]
	cmp	ax, 4
	je	SHORT $LN787@output_opc

; 269  :     }
; 270  :     else if (ins->allowed_prefix != AP_NO_FWAIT) {

	cmp	ax, 5
	je	SHORT $LN784@output_opc

; 271  :       /* implicit FWAIT synchronization for 8087 (CPU 8086/80186) */
; 272  :       if ((ModuleInfo.curr_cpu & P_CPU_MASK) < P_286)

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 32					; 00000020H
	jge	SHORT $LN784@output_opc

; 273  :         OutputCodeByte(OP_WAIT);

	mov	cl, 155					; 0000009bH
	call	OutputByte
	jmp	SHORT $LN784@output_opc
$LN787@output_opc:

; 268  :       OutputCodeByte(OP_WAIT);

	mov	cl, 155					; 0000009bH
	call	OutputByte
$LN784@output_opc:

; 274  :     }
; 275  :   }
; 276  :   /*
; 277  :    * check if address/operand size prefix is to be set
; 278  :    */
; 279  :   switch (ins->byte1_info) {

	movzx	eax, BYTE PTR [r12+1]
	dec	eax
	cmp	eax, 21
	ja	SHORT $LN782@output_opc
	cdqe
	movzx	eax, BYTE PTR $LN842@output_opc[r15+rax]
	mov	ecx, DWORD PTR $LN843@output_opc[r15+rax*4]
	add	rcx, r15
	jmp	rcx
$LN781@output_opc:

; 280  :   case F_16:
; 281  :     if (CodeInfo->Ofssize >= USE32) CodeInfo->prefix.opsiz = TRUE;

	cmp	BYTE PTR [rdi+106], 1
	jb	SHORT $LN782@output_opc
	or	BYTE PTR [rdi+9], 2

; 282  :     break;

	jmp	SHORT $LN782@output_opc
$LN779@output_opc:

; 283  :   case F_32:
; 284  :     if (CodeInfo->Ofssize == USE16) CodeInfo->prefix.opsiz = TRUE;

	cmp	BYTE PTR [rdi+106], 0
	jne	SHORT $LN782@output_opc
	or	BYTE PTR [rdi+9], 2

; 285  :     break;

	jmp	SHORT $LN782@output_opc
$LN777@output_opc:

; 286  :   case F_16A: /* 16-bit JCXZ and LOOPcc */
; 287  :     /* doesnt exist for IA32+ */
; 288  :     if (CodeInfo->Ofssize == USE32) CodeInfo->prefix.adrsiz = TRUE;

	cmp	BYTE PTR [rdi+106], 1
	jne	SHORT $LN782@output_opc
	or	BYTE PTR [rdi+9], 1

; 289  :     break;

	jmp	SHORT $LN782@output_opc
$LN775@output_opc:

; 290  :   case F_32A: /* 32-bit JECXZ and LOOPcc */
; 291  : #if AMD64_SUPPORT
; 292  :     /* in IA32+, the 32bit version gets an 0x67 prefix */
; 293  :     if (CodeInfo->Ofssize != USE32)  CodeInfo->prefix.adrsiz = TRUE;

	cmp	BYTE PTR [rdi+106], 1
	je	SHORT $LN782@output_opc
	or	BYTE PTR [rdi+9], 1

; 294  : #else
; 295  :     if( CodeInfo->Ofssize == USE16 ) CodeInfo->prefix.adrsiz = TRUE;
; 296  : #endif
; 297  :     break;

	jmp	SHORT $LN782@output_opc
$LN773@output_opc:

; 298  :   case F_0FNO66:
; 299  :     CodeInfo->prefix.opsiz = FALSE;

	and	BYTE PTR [rdi+9], 253			; 000000fdH

; 300  :     break;

	jmp	SHORT $LN782@output_opc
$LN772@output_opc:

; 301  : #if AMD64_SUPPORT
; 302  :   case F_48:
; 303  :   case F_480F:
; 304  :     CodeInfo->prefix.rex |= REX_W;

	or	BYTE PTR [rdi+8], 8
$LN782@output_opc:

; 305  :     break;
; 306  : #endif
; 307  :   }
; 308  : 
; 309  : 
; 310  : #if AVXSUPP  
; 311  :       if ((CodeInfo->token >= T_VSHUFF32X4) && (CodeInfo->token <= T_VSHUFI64X2) &&
; 312  :       ((CodeInfo->opnd[OPND1].type & OP_XMM) || (CodeInfo->opnd[OPND2].type & OP_XMM)))

	mov	eax, DWORD PTR [rdi+24]
	cmp	eax, 1635				; 00000663H
	jl	SHORT $LN771@output_opc
	cmp	eax, 1638				; 00000666H
	jg	SHORT $LN771@output_opc
	test	BYTE PTR [rdi+32], 32			; 00000020H
	jne	SHORT $LN770@output_opc
	test	BYTE PTR [rdi+56], 32			; 00000020H
	je	SHORT $LN771@output_opc
$LN770@output_opc:

; 313  :       EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS); //Only YMM and ZMM alowed    

	mov	ecx, 14
	call	EmitError
$LN771@output_opc:

; 314  : 	  
; 315  : 	/* John: removed once kn and decorator flag masks were determined not to be required as k0 is implicit */
; 316  : 	  /*if ((CodeInfo->token >= T_VBROADCASTF128) && (CodeInfo->token <= T_VPBROADCASTQ)) {
; 317  : 		if (decoflags == 0 && CodeInfo->r1type != OP_K)
; 318  :         CodeInfo->evex_flag = 0;
; 319  : 	}
; 320  :   	if (CodeInfo->token >= T_VPORD && CodeInfo->token <= T_PSRLDQ){
; 321  : 		if (decoflags == 0 && CodeInfo->r1type != OP_K)
; 322  :         CodeInfo->evex_flag = 0;
; 323  : 	}
; 324  :   	if (CodeInfo->token == T_VCVTPH2PS || CodeInfo->token == T_VCVTPS2PD ||
; 325  :         CodeInfo->token == T_VRANGEPD ||CodeInfo->token == T_VRANGEPS ||
; 326  :         CodeInfo->token == T_VPTESTNMD ||CodeInfo->token == T_VPTESTNMQ ||
; 327  :         CodeInfo->token == T_VPERM2I128) {
; 328  : 
; 329  : 		if (decoflags == 0 && CodeInfo->r1type != OP_K)
; 330  : 	        CodeInfo->evex_flag = 0;
; 331  : 
; 332  : 	}*/
; 333  : 
; 334  :   if ((CodeInfo->pinstr->prefix & 0xF00) == IZSZ)

	mov	rax, QWORD PTR [rdi+16]
	movzx	ecx, WORD PTR [rax+8]
	and	cx, 3840				; 00000f00H
	cmp	cx, 512					; 00000200H
	jne	SHORT $LN769@output_opc

; 335  : 	  CodeInfo->evex_flag = TRUE;

	mov	BYTE PTR [rdi+136], 1
$LN769@output_opc:

; 336  :   if (!evex){

	cmp	BYTE PTR evex, 0
	jne	SHORT $LN844@output_opc

; 337  : 	  CodeInfo->evex_flag = FALSE;
; 338  :     if (ResWordTable[CodeInfo->token].flags & RWF_VEX) {

	movsxd	rax, DWORD PTR [rdi+24]
	mov	BYTE PTR [rdi+136], 0
	shl	rax, 4
	test	BYTE PTR ResWordTable[rax+r15+3], 8
	je	SHORT $LN844@output_opc

; 339  :       if ((CodeInfo->reg1 > 15 && CodeInfo->reg1 < 32) || 
; 340  :           (CodeInfo->reg2 > 15 && CodeInfo->reg2 < 32) ||
; 341  :           (CodeInfo->reg3 > 15 && CodeInfo->reg3 < 32) ||
; 342  :           CodeInfo->r1type == OP_ZMM || CodeInfo->r2type == OP_ZMM)

	movzx	eax, BYTE PTR [rdi+109]
	cmp	al, 15
	jbe	SHORT $LN764@output_opc
	cmp	al, 32					; 00000020H
	jb	SHORT $LN765@output_opc
$LN764@output_opc:
	movzx	eax, BYTE PTR [rdi+110]
	cmp	al, 15
	jbe	SHORT $LN763@output_opc
	cmp	al, 32					; 00000020H
	jb	SHORT $LN765@output_opc
$LN763@output_opc:
	movzx	eax, BYTE PTR [rdi+111]
	cmp	al, 15
	jbe	SHORT $LN762@output_opc
	cmp	al, 32					; 00000020H
	jb	SHORT $LN765@output_opc
$LN762@output_opc:
	cmp	DWORD PTR [rdi+116], 256		; 00000100H
	je	SHORT $LN765@output_opc
	cmp	DWORD PTR [rdi+120], 256		; 00000100H
	jne	SHORT $LN844@output_opc
$LN765@output_opc:

; 343  :           EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN844@output_opc:

; 344  :       }
; 345  :     }
; 346  : 
; 347  :   if (CodeInfo->evex_flag == TRUE) {

	cmp	BYTE PTR [rdi+136], 1
	jne	SHORT $LN760@output_opc

; 348  : 	  if (!(vex_flags[CodeInfo->token - VEX_START] & VX_LL))

	movsxd	rax, DWORD PTR [rdi+24]
	test	BYTE PTR vex_flags[rax+r15-1304], 64	; 00000040H
	jne	SHORT $LN760@output_opc

; 349  : 		  EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN760@output_opc:

; 350  :   }
; 351  :   //if (!(ResWordTable[CodeInfo->token].flags & RWF_EVEX) && (CodeInfo->evex_flag == TRUE) ) 
; 352  :   //  EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);
; 353  :   //if (decoflags == 0){
; 354  :   //    if ((CodeInfo->reg1 > 15 && CodeInfo->reg1 < 32)  || (CodeInfo->reg2 > 15 && CodeInfo->reg2 < 32) ||
; 355  :   //        (CodeInfo->reg3 > 15 && CodeInfo->reg3 < 32)) 
; 356  :   //     // __debugbreak();
; 357  :   //      EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);
; 358  :   //  }
; 359  : 
; 360  :   if (!(ResWordTable[CodeInfo->token].flags & RWF_VEX)) {

	movsxd	rax, DWORD PTR [rdi+24]
	add	rax, rax
	test	BYTE PTR ResWordTable[r15+rax*8+3], 8
	jne	SHORT $LN757@output_opc

; 361  : #endif
; 362  : 
; 363  : 	switch (ins->byte1_info) {

	movzx	eax, BYTE PTR [r12+1]
	add	eax, -5
	cmp	eax, 22
	ja	SHORT $LN757@output_opc
	cdqe
	movzx	eax, BYTE PTR $LN840@output_opc[r15+rax]
	mov	ecx, DWORD PTR $LN841@output_opc[r15+rax*4]
	add	rcx, r15
	jmp	rcx
$LN756@output_opc:

; 364  :     case F_660F:
; 365  :     case F_660F38:
; 366  :     case F_660F3A:
; 367  :       CodeInfo->prefix.opsiz = TRUE;

	or	BYTE PTR [rdi+9], 2

; 368  :       break;

	jmp	SHORT $LN757@output_opc
$LN755@output_opc:

; 369  :     case F_F20F:
; 370  :     case F_F20F38: OutputCodeByte(0xF2); break;

	mov	cl, 242					; 000000f2H
	call	OutputByte
	jmp	SHORT $LN757@output_opc
$LN754@output_opc:

; 371  :     case F_F3: /* PAUSE instruction */
; 372  :     case F_F30F:   OutputCodeByte(0xF3); break;

	mov	cl, 243					; 000000f3H
	call	OutputByte
$LN757@output_opc:

; 373  :     }
; 374  : #if AVXSUPP
; 375  :   }
; 376  : #endif
; 377  :   /*
; 378  :    * Output address and operand size prefixes.
; 379  :    * These bytes are NOT compatible with FP emulation fixups,
; 380  :    * which expect that the FWAIT/NOP first "prefix" byte is followed
; 381  :    * by either a segment prefix or the opcode byte.
; 382  :    * Neither Masm nor HJWasm emit a warning, though.
; 383  :    */
; 384  :   if (CodeInfo->prefix.adrsiz == TRUE && (CodeInfo->token < T_VPGATHERDD || CodeInfo->token > T_VSCATTERQPD)&&
; 385  :       CodeInfo->token != T_VCVTPH2PS && CodeInfo->token != T_VCVTPS2PD) {

	test	BYTE PTR [rdi+9], 1
	je	SHORT $LN753@output_opc
	mov	eax, DWORD PTR [rdi+24]
	cmp	eax, 1365				; 00000555H
	jl	SHORT $LN752@output_opc
	cmp	eax, 1396				; 00000574H
	jle	SHORT $LN753@output_opc
$LN752@output_opc:
	cmp	eax, 1468				; 000005bcH
	je	SHORT $LN753@output_opc
	cmp	eax, 1951				; 0000079fH
	je	SHORT $LN753@output_opc

; 386  :     OutputCodeByte(ADRSIZ);

	mov	cl, 103					; 00000067H
	call	OutputByte
$LN753@output_opc:

; 387  : #ifdef DEBUG_OUT
; 388  :     if (fpfix)
; 389  :       DebugMsg(("output_opc: ERROR: FP emulation byte sequence destroyed by 32-bit address prefix!\n"));
; 390  : #endif
; 391  :   }
; 392  :   if (CodeInfo->prefix.opsiz == TRUE) {

	test	BYTE PTR [rdi+9], 2
	je	SHORT $LN751@output_opc

; 393  : #if 1
; 394  :     if ((ModuleInfo.curr_cpu & P_CPU_MASK) < P_386) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jge	SHORT $LN750@output_opc

; 395  :       DebugMsg(("output_opc: instruction form requires 386\n"));
; 396  :       EmitError(INSTRUCTION_FORM_REQUIRES_80386);

	mov	ecx, 238				; 000000eeH
	call	EmitError
$LN750@output_opc:

; 397  :       //return( ERROR ); /* v2.06: don't skip instruction */
; 398  :     }
; 399  : #endif
; 400  :     OutputCodeByte(OPSIZ);

	mov	cl, 102					; 00000066H
	call	OutputByte
$LN751@output_opc:

; 401  :   }
; 402  :   //if(CodeInfo->token == T_VCVTPD2PS)
; 403  :   //  __debugbreak();
; 404  :   /*
; 405  :    * Output segment prefix
; 406  :    */
; 407  :   if (CodeInfo->prefix.RegOverride != EMPTY) {

	movsxd	rax, DWORD PTR [rdi+4]
	cmp	eax, -2
	je	SHORT $LN749@output_opc

; 408  :     OutputCodeByte(sr_prefix[CodeInfo->prefix.RegOverride]);

	movzx	ecx, BYTE PTR sr_prefix[rax+r15]
	call	OutputByte
$LN749@output_opc:

; 409  :   }
; 410  :   if (ins->opnd_dir) {

	cmp	BYTE PTR [r12+6], 0
	je	SHORT $LN748@output_opc

; 411  :     /* The reg and r/m fields are backwards */
; 412  :     tmp = CodeInfo->rm_byte;

	movzx	ecx, BYTE PTR [rdi+104]

; 413  :     CodeInfo->rm_byte = (tmp & 0xc0) | ((tmp >> 3) & 0x7) | ((tmp << 3) & 0x38);

	movzx	edx, cl
	movzx	eax, cl
	and	cl, 192					; 000000c0H
	shr	dl, 3
	and	al, 7
	and	dl, 7
	shl	al, 3
	or	dl, al
	or	dl, cl

; 414  : #if AMD64_SUPPORT
; 415  :     tmp = CodeInfo->prefix.rex;

	movzx	ecx, BYTE PTR [rdi+8]
	mov	BYTE PTR [rdi+104], dl

; 416  :     CodeInfo->prefix.rex = (tmp & 0xFA) | ((tmp & REX_R) >> 2) | ((tmp & REX_B) << 2);

	movzx	edx, cl
	movzx	eax, cl
	shr	dl, 2
	and	al, 1
	and	cl, 250					; 000000faH
	and	dl, 1
	shl	al, 2
	or	dl, al
	or	dl, cl
	mov	BYTE PTR [rdi+8], dl
$LN748@output_opc:

; 417  : #endif
; 418  :   }
; 419  : #if AVXSUPP
; 420  :   if (ResWordTable[CodeInfo->token].flags & RWF_VEX) {

	movsxd	rdx, DWORD PTR [rdi+24]
	mov	QWORD PTR [rsp+56], r13
	xor	r13d, r13d
	mov	rax, rdx
	shl	rax, 4
	test	BYTE PTR ResWordTable[rax+r15+3], 8
	je	$LN747@output_opc

; 421  :     uint_8 lbyte = 0;

	xor	al, al

; 422  :     if (CodeInfo->evex_flag){

	cmp	BYTE PTR [rdi+136], r13b
	movzx	esi, al
	mov	eax, 4
	cmovne	esi, eax

; 423  :       lbyte |= 0x4;              //bite 3 must be set in P2 WVVVV1PP 
; 424  :     }
; 425  :     switch (ins->byte1_info) {

	movzx	eax, BYTE PTR [r12+1]
	add	eax, -18
	cmp	eax, 10
	ja	SHORT $LN744@output_opc
	cdqe
	mov	ecx, DWORD PTR $LN839@output_opc[r15+rax*4]
	add	rcx, r15
	jmp	rcx
$LN743@output_opc:

; 426  :     case F_660F:
; 427  :     case F_660F38:
; 428  :     case F_660F3A:
; 429  :       lbyte |= 0x01;

	or	sil, 1

; 430  :       break;

	jmp	SHORT $LN744@output_opc
$LN742@output_opc:

; 431  :     case F_F30F:
; 432  :     case F_F30F38:
; 433  :       lbyte |= 0x02;

	or	sil, 2

; 434  :       break;

	jmp	SHORT $LN744@output_opc
$LN741@output_opc:

; 435  :     case F_F20F:
; 436  :     case F_F20F38:
; 437  :       lbyte |= 0x03;

	or	sil, bpl
$LN744@output_opc:

; 438  :       break;
; 439  :     }
; 440  :     if (CodeInfo->vexregop)

	movzx	ecx, BYTE PTR [rdi+128]
	test	cl, cl
	je	SHORT $LN740@output_opc

; 441  :       lbyte |= ((16 - CodeInfo->vexregop) << 3);

	shl	cl, 3
	mov	eax, 128				; 00000080H
	sub	al, cl
	or	sil, al

; 442  :     else {

	jmp	SHORT $LN739@output_opc
$LN740@output_opc:

; 443  :       lbyte |= EVEX_P1VVVV;

	or	sil, 120				; 00000078H

; 444  :       CodeInfo->evex_p2 |= EVEX_P2VMASK;

	or	BYTE PTR [rdi+139], 8
$LN739@output_opc:

; 445  :     }
; 446  : 
; 447  : 
; 448  : 
; 449  :   /* If there is no decoflags then it is AVX2 instruction with 3 parameters, HJWasm 2.15 */
; 450  :   if (CodeInfo->token >= T_VBROADCASTSS && CodeInfo->token <= T_VPBROADCASTMW2D)

	cmp	edx, 1304				; 00000518H
	jl	SHORT $LN845@output_opc
	cmp	edx, 1323				; 0000052bH
	jg	SHORT $LN845@output_opc

; 451  :       {
; 452  :     if (decoflags == 0 && CodeInfo->r1type != OP_K){

	cmp	BYTE PTR decoflags, r13b
	jne	SHORT $LN845@output_opc
	mov	eax, DWORD PTR [rdi+116]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN845@output_opc

; 453  :       if (CodeInfo->reg1 <= 15 && CodeInfo->r1type != OP_ZMM)

	cmp	BYTE PTR [rdi+109], 15
	ja	SHORT $LN736@output_opc
	cmp	eax, 256				; 00000100H
	je	SHORT $LN736@output_opc

; 454  :         CodeInfo->evex_flag = 0;

	mov	BYTE PTR [rdi+136], r13b

; 455  :       else{

	jmp	SHORT $LN845@output_opc
$LN736@output_opc:

; 456  :         CodeInfo->evex_flag = 1;

	mov	BYTE PTR [rdi+136], 1

; 457  :         lbyte |= 4;

	or	sil, 4
$LN845@output_opc:

; 458  :         }
; 459  :       }
; 460  :     }
; 461  :     if (CodeInfo->token >= T_VPGATHERDD && CodeInfo->token <= T_VGATHERQPS)

	cmp	edx, 1365				; 00000555H
	jl	SHORT $LN730@output_opc
	cmp	edx, 1372				; 0000055cH
	jg	SHORT $LN730@output_opc

; 462  :     {
; 463  :     if (decoflags == 0 && CodeInfo->r1type != OP_K){

	cmp	BYTE PTR decoflags, r13b
	jne	SHORT $LN730@output_opc
	cmp	DWORD PTR [rdi+116], 64			; 00000040H
	je	SHORT $LN730@output_opc

; 464  :       if (CodeInfo->reg1 > 15 || CodeInfo->reg3 > 15)

	cmp	BYTE PTR [rdi+109], 15
	ja	SHORT $LN731@output_opc
	cmp	BYTE PTR [rdi+111], 15
	ja	SHORT $LN731@output_opc

; 466  :       else CodeInfo->evex_flag = 0;

	mov	BYTE PTR [rdi+136], r13b
	jmp	SHORT $LN730@output_opc
$LN731@output_opc:

; 465  :         EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN730@output_opc:

; 467  :       }
; 468  :     }
; 469  :     /* VCVTTSS2SI can only be used with XMM registers, HJWasm 2.16 */
; 470  :     if (CodeInfo->token == T_VCVTTSS2SI){

	cmp	DWORD PTR [rdi+24], 1958		; 000007a6H
	jne	SHORT $LN728@output_opc

; 471  :       if (CodeInfo->r2type == OP_YMM || CodeInfo->r2type == OP_ZMM )

	mov	eax, DWORD PTR [rdi+120]
	cmp	eax, 128				; 00000080H
	je	SHORT $LN727@output_opc
	cmp	eax, 256				; 00000100H
	jne	SHORT $LN728@output_opc
$LN727@output_opc:

; 472  :         EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN728@output_opc:

; 473  :       }
; 474  :     /* Check size of added missing instructions VRCP28SD, VRCP28SS, VRCP28PD, VRCP28PS 
; 475  :      VRSQRT28PD, VRSQRT28PS, VRSQRT28SD, VRSQRT28SS, VEXP2PD, VEXP2PS HJWasm 2.16  */
; 476  :     switch (CodeInfo->token){

	mov	edx, DWORD PTR [rdi+24]
	cmp	edx, 2044				; 000007fcH
	mov	eax, edx
	jg	$LN812@output_opc
	cmp	eax, 2041				; 000007f9H
	jge	$LN716@output_opc
	sub	eax, 1605				; 00000645H
	cmp	eax, 9
	ja	$LN704@output_opc
	cdqe
	mov	ecx, DWORD PTR $LN838@output_opc[r15+rax*4]
	add	rcx, r15
	jmp	rcx
$LN724@output_opc:

; 477  :       case   T_VRCP28SD:
; 478  :       case T_VRSQRT28SD:
; 479  :         if (CodeInfo->mem_type != MT_EMPTY && CodeInfo->mem_type != MT_QWORD )

	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, 192				; 000000c0H
	je	SHORT $LN723@output_opc
	cmp	eax, 7
	jne	$error$5618
$LN723@output_opc:

; 480  :           goto error;
; 481  :         if ((CodeInfo->r1type == OP_XMM && CodeInfo->r2type == OP_XMM) && 
; 482  :             CodeInfo->opnd[OPND1].type == OP_XMM || CodeInfo->opnd[OPND1].type == OP_M)

	cmp	DWORD PTR [rdi+116], 32			; 00000020H
	jne	SHORT $LN720@output_opc
	cmp	DWORD PTR [rdi+120], 32			; 00000020H
	jne	SHORT $LN720@output_opc
	cmp	DWORD PTR [rdi+32], 32			; 00000020H
	je	$LN704@output_opc
$LN720@output_opc:
	cmp	DWORD PTR [rdi+32], -1887436800		; ffffffff8f800000H
	jne	$error$5618

; 483  :             break;

	jmp	$LN704@output_opc
$LN719@output_opc:

; 484  :         else goto error;
; 485  :       case   T_VRCP28SS:
; 486  :       case T_VRSQRT28SS:
; 487  :         if (CodeInfo->mem_type != MT_EMPTY && CodeInfo->mem_type != MT_DWORD )

	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, 192				; 000000c0H
	je	SHORT $LN717@output_opc
	cmp	eax, ebp
	jne	$error$5618
$LN717@output_opc:

; 488  :           goto error;
; 489  :         if ((CodeInfo->r1type == OP_XMM && CodeInfo->r2type == OP_XMM) && 
; 490  :             CodeInfo->opnd[OPND1].type == OP_XMM || CodeInfo->opnd[OPND1].type == OP_M)

	cmp	DWORD PTR [rdi+116], 32			; 00000020H
	jne	SHORT $LN714@output_opc
	cmp	DWORD PTR [rdi+120], 32			; 00000020H
	jne	SHORT $LN714@output_opc
	cmp	DWORD PTR [rdi+32], 32			; 00000020H
	je	$LN704@output_opc
$LN714@output_opc:
	cmp	DWORD PTR [rdi+32], -1887436800		; ffffffff8f800000H
	je	$LN704@output_opc
$LN716@output_opc:

; 491  :             break;
; 492  :       case T_VPCLMULQDQ:
; 493  :       case T_VAESDECLAST:
; 494  :       case T_VAESENCLAST:
; 495  :       case T_VAESENC:
; 496  :         if (CodeInfo->mem_type != MT_EMPTY && CodeInfo->mem_type != MT_OWORD )

	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, 192				; 000000c0H
	je	SHORT $LN712@output_opc
	cmp	eax, 15
	jne	$error$5618
$LN712@output_opc:

; 497  :           goto error;
; 498  :         if ((CodeInfo->r1type == OP_XMM && CodeInfo->r2type == OP_XMM) && 
; 499  :             CodeInfo->opnd[OPND1].type == OP_XMM || CodeInfo->opnd[OPND1].type == OP_M)

	cmp	DWORD PTR [rdi+116], 32			; 00000020H
	jne	SHORT $LN709@output_opc
	cmp	DWORD PTR [rdi+120], 32			; 00000020H
	jne	SHORT $LN709@output_opc
	cmp	DWORD PTR [rdi+32], 32			; 00000020H
	je	SHORT $LN704@output_opc
$LN709@output_opc:
	cmp	DWORD PTR [rdi+32], -1887436800		; ffffffff8f800000H
	jne	$error$5618

; 500  :             break;

	jmp	SHORT $LN704@output_opc
$LN702@output_opc:

; 508  :             break;
; 509  :         else goto error;
; 510  :       case   T_VRCP28PD:
; 511  :       case   T_VRCP28PS:
; 512  :       case   T_VRSQRT28PD:
; 513  :       case   T_VRSQRT28PS:
; 514  :       case   T_VEXP2PD:
; 515  :       case   T_VEXP2PS:
; 516  :         if ((CodeInfo->r1type == OP_ZMM) && (CodeInfo->opnd[OPND2].type == OP_ZMM || 
; 517  :           CodeInfo->opnd[OPND2].type == OP_M512 || CodeInfo->opnd[OPND2].type == OP_M))

	cmp	DWORD PTR [rdi+116], 256		; 00000100H
	jne	$error$5618
	mov	eax, DWORD PTR [rdi+56]
	cmp	eax, 256				; 00000100H
	je	SHORT $LN704@output_opc
	cmp	eax, 536870912				; 20000000H
	je	SHORT $LN704@output_opc
	cmp	eax, -1887436800			; ffffffff8f800000H
	jne	$error$5618

; 518  :           break;

	jmp	SHORT $LN704@output_opc
$LN812@output_opc:

; 473  :       }
; 474  :     /* Check size of added missing instructions VRCP28SD, VRCP28SS, VRCP28PD, VRCP28PS 
; 475  :      VRSQRT28PD, VRSQRT28PS, VRSQRT28SD, VRSQRT28SS, VEXP2PD, VEXP2PS HJWasm 2.16  */
; 476  :     switch (CodeInfo->token){

	cmp	eax, 2046				; 000007feH
	jne	SHORT $LN704@output_opc

; 501  :         else goto error;
; 502  :       case T_VAESKEYGENASSIST:
; 503  :         if (CodeInfo->mem_type != MT_EMPTY && CodeInfo->mem_type != MT_OWORD )

	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, 192				; 000000c0H
	je	SHORT $LN706@output_opc
	cmp	eax, 15
	jne	$error$5618
$LN706@output_opc:

; 504  :           goto error;
; 505  :         if ((CodeInfo->r1type == OP_XMM) && 
; 506  :             CodeInfo->opnd[OPND2].type == OP_XMM || CodeInfo->opnd[OPND2].type == OP_M128 ||
; 507  :             CodeInfo->opnd[OPND2].type == OP_M)

	cmp	DWORD PTR [rdi+116], 32			; 00000020H
	jne	SHORT $LN703@output_opc
	cmp	DWORD PTR [rdi+56], 32			; 00000020H
	je	SHORT $LN704@output_opc
$LN703@output_opc:
	mov	eax, DWORD PTR [rdi+56]
	cmp	eax, 134217728				; 08000000H
	je	SHORT $LN704@output_opc
	cmp	eax, -1887436800			; ffffffff8f800000H
	jne	$error$5618
$LN704@output_opc:

; 519  :         else goto error;
; 520  :       }
; 521  :   /* Validate use of proper GPR size for VPINSRB, VPINSRW, VPINSRD, VPINSRQ, VPEXTRB, VPEXTRW, VPEXTRD, VPEXTRQ, HJWasm 2.16 
; 522  :    * MT_EMPTY is OK because instructions mnemonics are teling the size
; 523  :    */
; 524  :   switch (CodeInfo->token){

	lea	eax, DWORD PTR [rdx-2033]
	cmp	eax, 7
	ja	$LN696@output_opc
	cdqe
	mov	ecx, DWORD PTR $LN837@output_opc[r15+rax*4]
	add	rcx, r15
	jmp	rcx
$LN695@output_opc:

; 525  :     case T_VPINSRB:
; 526  :       if ((CodeInfo->opnd[OPND2].type == OP_R32 || CodeInfo->mem_type == MT_BYTE || CodeInfo->mem_type == MT_EMPTY) &&
; 527  :         (CodeInfo->r1type == OP_XMM && CodeInfo->r2type == OP_XMM))

	cmp	DWORD PTR [rdi+56], 4
	je	SHORT $LN693@output_opc
	mov	eax, DWORD PTR [rdi+28]
	test	eax, eax
	je	SHORT $LN693@output_opc
	cmp	eax, 192				; 000000c0H
	jne	$error$5618
$LN693@output_opc:
	cmp	DWORD PTR [rdi+116], 32			; 00000020H
	jne	$error$5618
	cmp	DWORD PTR [rdi+120], 32			; 00000020H
	je	$LN696@output_opc

; 528  :         ;// That is correct 
; 529  :       else goto error;

	jmp	$error$5618
$LN691@output_opc:

; 530  :         break;
; 531  :     case T_VPINSRW:
; 532  :       if ((CodeInfo->opnd[OPND2].type == OP_R32 || CodeInfo->mem_type == MT_WORD || CodeInfo->mem_type == MT_EMPTY) &&
; 533  :         (CodeInfo->r1type == OP_XMM && CodeInfo->r2type == OP_XMM))

	cmp	DWORD PTR [rdi+56], 4
	je	SHORT $LN689@output_opc
	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, 1
	je	SHORT $LN689@output_opc
	cmp	eax, 192				; 000000c0H
	jne	$error$5618
$LN689@output_opc:
	cmp	DWORD PTR [rdi+116], 32			; 00000020H
	jne	$error$5618
	cmp	DWORD PTR [rdi+120], 32			; 00000020H
	je	$LN696@output_opc

; 534  :         ;// That is correct
; 535  :       else goto error;

	jmp	$error$5618
$LN687@output_opc:

; 536  :         break;
; 537  :     case T_VPINSRD:
; 538  :       if ((CodeInfo->opnd[OPND2].type == OP_R32 || CodeInfo->mem_type == MT_DWORD || CodeInfo->mem_type == MT_EMPTY) &&
; 539  :         (CodeInfo->r1type == OP_XMM && CodeInfo->r2type == OP_XMM))

	cmp	DWORD PTR [rdi+56], 4
	je	SHORT $LN685@output_opc
	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, ebp
	je	SHORT $LN685@output_opc
	cmp	eax, 192				; 000000c0H
	jne	$error$5618
$LN685@output_opc:
	cmp	DWORD PTR [rdi+116], 32			; 00000020H
	jne	$error$5618
	cmp	DWORD PTR [rdi+120], 32			; 00000020H
	je	$LN696@output_opc

; 540  :         ;// That is correct
; 541  :       else goto error;

	jmp	$error$5618
$LN683@output_opc:

; 542  :         break;
; 543  :     case T_VPINSRQ:   // only VPINSRQ can have OP_R64 or MT_QWORD
; 544  :       if ((CodeInfo->opnd[OPND2].type == OP_R64 || CodeInfo->mem_type == MT_QWORD || CodeInfo->mem_type == MT_EMPTY) &&
; 545  :         (CodeInfo->r1type == OP_XMM && CodeInfo->r2type == OP_XMM))

	cmp	DWORD PTR [rdi+56], 8
	je	SHORT $LN681@output_opc
	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, 7
	je	SHORT $LN681@output_opc
	cmp	eax, 192				; 000000c0H
	jne	SHORT $error$5618
$LN681@output_opc:
	cmp	DWORD PTR [rdi+116], 32			; 00000020H
	jne	SHORT $error$5618
	cmp	DWORD PTR [rdi+120], 32			; 00000020H
	je	SHORT $LN696@output_opc

; 546  :         ;// That is correct
; 547  :       else goto error;

	jmp	SHORT $error$5618
$LN679@output_opc:

; 548  :        break;
; 549  :     case T_VPEXTRB:
; 550  :      if ((CodeInfo->opnd[OPND1].type == OP_R32 || CodeInfo->mem_type == MT_BYTE || CodeInfo->mem_type == MT_EMPTY) &&
; 551  :         (CodeInfo->r2type == OP_XMM ))

	cmp	DWORD PTR [rdi+32], 4
	je	SHORT $LN677@output_opc
	mov	eax, DWORD PTR [rdi+28]
	test	eax, eax
	je	SHORT $LN677@output_opc
	cmp	eax, 192				; 000000c0H
	jne	SHORT $error$5618
$LN677@output_opc:
	cmp	DWORD PTR [rdi+120], 32			; 00000020H
	je	SHORT $LN696@output_opc

; 552  :         ;//That is correct
; 553  :      else goto error;

	jmp	SHORT $error$5618
$LN675@output_opc:

; 554  :        break;
; 555  :     case T_VPEXTRW:
; 556  :      if ((CodeInfo->opnd[OPND1].type == OP_R32 || CodeInfo->mem_type == MT_WORD || CodeInfo->mem_type == MT_EMPTY) &&
; 557  :         (CodeInfo->r2type == OP_XMM ))

	cmp	DWORD PTR [rdi+32], 4
	je	SHORT $LN673@output_opc
	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, 1
	je	SHORT $LN673@output_opc
	cmp	eax, 192				; 000000c0H
	jne	SHORT $error$5618
$LN673@output_opc:
	cmp	DWORD PTR [rdi+120], 32			; 00000020H
	je	SHORT $LN696@output_opc

; 558  :         ;//That is correct
; 559  :      else goto error;

	jmp	SHORT $error$5618
$LN671@output_opc:

; 560  :        break;
; 561  :     case T_VPEXTRD:      
; 562  :      if ((CodeInfo->opnd[OPND1].type == OP_R32 || CodeInfo->mem_type == MT_DWORD || CodeInfo->mem_type == MT_EMPTY) &&
; 563  :         (CodeInfo->r2type == OP_XMM ))

	cmp	DWORD PTR [rdi+32], 4
	je	SHORT $LN669@output_opc
	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, ebp
	je	SHORT $LN669@output_opc
	cmp	eax, 192				; 000000c0H
	jne	SHORT $error$5618
$LN669@output_opc:
	cmp	DWORD PTR [rdi+120], 32			; 00000020H
	je	SHORT $LN696@output_opc

; 564  :          ;//That is correct
; 565  :      else goto error;

	jmp	SHORT $error$5618
$LN667@output_opc:

; 566  :       break;
; 567  :     case T_VPEXTRQ:
; 568  :      if ((CodeInfo->opnd[OPND1].type == OP_R64 || CodeInfo->mem_type == MT_QWORD || CodeInfo->mem_type == MT_EMPTY) &&
; 569  :         (CodeInfo->r2type == OP_XMM ))        

	cmp	DWORD PTR [rdi+32], 8
	je	SHORT $LN665@output_opc
	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, 7
	je	SHORT $LN665@output_opc
	cmp	eax, 192				; 000000c0H
	jne	SHORT $error$5618
$LN665@output_opc:
	cmp	DWORD PTR [rdi+120], 32			; 00000020H
	je	SHORT $LN696@output_opc
$error$5618:

; 570  :        ;//That is correct 
; 571  :        else goto error;
; 572  :      break;
; 573  :    error:
; 574  :      EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN696@output_opc:

; 575  :     }
; 576  :     /* emit 4 byte (0x62), 3 (0xC4) or 2 (0xC5) byte VEX prefix */
; 577  :         if ((CodeInfo->token ==  T_VMOVMSKPD )||(CodeInfo->token ==  T_VMOVMSKPS )) 

	movsxd	rcx, DWORD PTR [rdi+24]
	cmp	ecx, 1989				; 000007c5H
	je	SHORT $LN662@output_opc
	cmp	ecx, 1990				; 000007c6H
	jne	SHORT $LN663@output_opc
$LN662@output_opc:

; 578  :           CodeInfo->prefix.rex &= ~REX_W;

	and	BYTE PTR [rdi+8], 247			; 000000f7H
$LN663@output_opc:

; 579  :         if (( ins->byte1_info >= F_0F38) || ( CodeInfo->prefix.rex & ( REX_B | REX_X | REX_W ) )|| 
; 580  :           (( ins->byte1_info == F_0F) && (CodeInfo->token ==  T_KMOVQ )) || (ins->byte1_info == F_660F) && 
; 581  :            (CodeInfo->token ==  T_KMOVD )){

	mov	dl, BYTE PTR [r12+1]
	cmp	dl, 23
	jae	$LN660@output_opc
	movzx	eax, BYTE PTR [rdi+8]
	test	al, 11
	jne	$LN660@output_opc
	cmp	dl, 16
	jne	SHORT $LN659@output_opc
	cmp	ecx, 1775				; 000006efH
	je	$LN660@output_opc
$LN659@output_opc:
	cmp	dl, 18
	jne	SHORT $LN661@output_opc
	cmp	ecx, 1774				; 000006eeH
	je	$LN660@output_opc
$LN661@output_opc:

; 1226 :               }
; 1227 :            }
; 1228 : 		}
; 1229 : 		else {
; 1230 : 			lbyte |= ((CodeInfo->prefix.rex & REX_R) ? 0 : EVEX_P1WMASK);

	shl	al, 5
	not	al
	and	al, 128					; 00000080H
	or	sil, al

; 1231 : 			/* first byte is 0xC5  in 2 byte version  */
; 1232 :       if (CodeInfo->token == T_VCVTPD2PS || CodeInfo->token == T_VCVTPS2PD){

	cmp	ecx, 1363				; 00000553H
	je	SHORT $LN333@output_opc
	cmp	ecx, 1951				; 0000079fH
	jne	SHORT $LN334@output_opc
$LN333@output_opc:

; 1233 :           if (CodeInfo->opnd[OPND2].type == OP_M512)CodeInfo->evex_flag = 1;

	cmp	DWORD PTR [rdi+56], 536870912		; 20000000H
	jne	SHORT $LN332@output_opc
	mov	BYTE PTR [rdi+136], 1
$LN332@output_opc:

; 1234 :           lbyte |= 4;

	or	sil, 4

; 1235 :           CodeInfo->evex_p2 |= EVEX_P2L1MASK;

	or	BYTE PTR [rdi+139], 64			; 00000040H
$LN334@output_opc:

; 1236 :         }
; 1237 : 			if (CodeInfo->evex_flag) {

	cmp	BYTE PTR [rdi+136], r13b
	je	$outC5$5690

; 1238 : 				OutputCodeByte(0x62);

	mov	cl, 98					; 00000062H
	call	OutputByte

; 1239 : 				if ((CodeInfo->opnd[OPND1].type & OP_M_ANY) || (CodeInfo->opnd[OPND2].type & OP_M_ANY) ||
; 1240 : 					(CodeInfo->opnd[OPND3].type & OP_M_ANY)) CodeInfo->tuple = TRUE;

	mov	r10d, DWORD PTR [rdi+32]
	mov	r8d, r10d
	and	r8d, -8388608				; ffffffffff800000H
	jne	SHORT $LN329@output_opc
	test	DWORD PTR [rdi+56], -8388608		; ffffffffff800000H
	jne	SHORT $LN329@output_opc
	test	DWORD PTR [rdi+80], -8388608		; ffffffffff800000H
	je	SHORT $LN330@output_opc
$LN329@output_opc:
	mov	BYTE PTR [rdi+140], 1
$LN330@output_opc:

; 1241 : 				lbyte &= ~EVEX_P1WMASK;
; 1242 : 				lbyte |= ((CodeInfo->pinstr->prefix) >> 8 & EVEX_P1WMASK);

	mov	rax, QWORD PTR [rdi+16]

; 1243 : 				if ((CodeInfo->opnd[OPND2].type == OP_M64) || (CodeInfo->opnd[OPND1].type == OP_M64))

	mov	r9d, DWORD PTR [rdi+56]
	xor	sil, BYTE PTR [rax+9]
	and	sil, 127				; 0000007fH
	xor	sil, BYTE PTR [rax+9]
	cmp	r9d, 67108864				; 04000000H
	je	SHORT $LN327@output_opc
	cmp	r10d, 67108864				; 04000000H
	jne	SHORT $LN328@output_opc
$LN327@output_opc:

; 1244 : 					lbyte |= EVEX_P1WMASK;

	or	sil, 128				; 00000080H
$LN328@output_opc:

; 1245 : 				if ((CodeInfo->opnd[OPND2].type == OP_R32) || (CodeInfo->opnd[OPND2].type == OP_EAX) ||
; 1246 : 					(CodeInfo->opnd[OPND1].type == OP_R32) || (CodeInfo->opnd[OPND1].type == OP_EAX) ||
; 1247 : 					(CodeInfo->token == T_VMOVD)) {

	cmp	r9d, 4
	je	SHORT $LN325@output_opc
	cmp	r9d, 516				; 00000204H
	je	SHORT $LN325@output_opc
	cmp	r10d, 4
	je	SHORT $LN325@output_opc
	cmp	r10d, 516				; 00000204H
	je	SHORT $LN325@output_opc
	cmp	DWORD PTR [rdi+24], 1977		; 000007b9H
	jne	SHORT $LN326@output_opc
$LN325@output_opc:

; 1248 : 					lbyte &= ~EVEX_P1WMASK;

	and	sil, 127				; 0000007fH
$LN326@output_opc:

; 1249 : 				}
; 1250 : 				switch (ins->byte1_info) {

	movzx	edx, BYTE PTR [r12+1]
	mov	ecx, edx
	sub	ecx, 23
	je	SHORT $LN322@output_opc
	dec	ecx
	je	SHORT $LN321@output_opc
	dec	ecx
	je	SHORT $LN322@output_opc
	dec	ecx
	je	SHORT $LN321@output_opc
	dec	ecx
	je	SHORT $LN322@output_opc

; 1260 : 				default:
; 1261 : 					if (ins->byte1_info >= F_0F) {

	cmp	dl, 16
	jb	SHORT $LN319@output_opc

; 1262 : 						CodeInfo->evex_p0 |= 0x01;

	or	BYTE PTR [rdi+137], 1
	jmp	SHORT $LN319@output_opc
$LN321@output_opc:

; 1255 : 					break;
; 1256 : 				case F_0F3A:
; 1257 : 				case F_660F3A:
; 1258 : 					CodeInfo->evex_p0 |= 0x03;

	or	BYTE PTR [rdi+137], bpl

; 1259 : 					break;

	jmp	SHORT $LN319@output_opc
$LN322@output_opc:

; 1251 : 				case F_0F38:
; 1252 : 				case F_660F38:
; 1253 : 				case F_F20F38:
; 1254 : 					CodeInfo->evex_p0 |= 0x02;

	or	BYTE PTR [rdi+137], 2
$LN319@output_opc:

; 1263 : 					}
; 1264 : 				}
; 1265 :         if (CodeInfo->opnd[OPND1].type & OP_M_ANY) {

	test	r8d, r8d
	je	SHORT $LN318@output_opc

; 1266 :           if (CodeInfo->indexreg != 0xff){

	movzx	eax, BYTE PTR [rdi+112]
	cmp	al, 255					; 000000ffH
	je	SHORT $LN315@output_opc

; 1267 :             if (CodeInfo->indexreg <= 7) 

	cmp	al, 7
	ja	SHORT $LN316@output_opc

; 1268 :             CodeInfo->evex_p0 |= EVEX_P0XMASK;

	or	BYTE PTR [rdi+137], 64			; 00000040H

; 1269 :             else

	jmp	SHORT $LN315@output_opc
$LN316@output_opc:

; 1270 :               CodeInfo->evex_p0 &= ~EVEX_P0XMASK;

	and	BYTE PTR [rdi+137], 191			; 000000bfH
$LN315@output_opc:

; 1271 :             }
; 1272 :           if (CodeInfo->basereg != 0xFF){

	movzx	eax, BYTE PTR [rdi+113]
	cmp	al, 255					; 000000ffH
	je	$LN308@output_opc

; 1273 :             if (CodeInfo->basereg <= 7)   

	cmp	al, 7
	ja	SHORT $LN313@output_opc

; 1274 :               CodeInfo->evex_p0 |= EVEX_P0BMASK;

	or	BYTE PTR [rdi+137], 32			; 00000020H

; 1275 :             else

	jmp	SHORT $LN308@output_opc
$LN313@output_opc:

; 1276 :               CodeInfo->evex_p0 &= ~EVEX_P0BMASK;

	and	BYTE PTR [rdi+137], 223			; 000000dfH

; 1277 :           }

	jmp	SHORT $LN308@output_opc
$LN318@output_opc:

; 1278 :         }
; 1279 :         /* if it is EVEX and VX_NND not present then it must 3 registers */
; 1280 : 				else if ((vex_flags[CodeInfo->token - VEX_START] & VX_NND) == 0){

	movsxd	rax, DWORD PTR [rdi+24]
	test	BYTE PTR vex_flags[rax+r15-1304], 2
	jne	SHORT $LN310@output_opc

; 1281 :           CodeInfo->evex_p0 &= ~0x20;    // clear REX_B

	and	BYTE PTR [rdi+137], 223			; 000000dfH

; 1282 :           if (CodeInfo->reg3 <= 7) CodeInfo->evex_p0 |= EVEX_P0XMASK;

	cmp	BYTE PTR [rdi+111], 7
	movzx	eax, BYTE PTR [rdi+137]
	ja	SHORT $LN309@output_opc
	or	al, 64					; 00000040H
	mov	BYTE PTR [rdi+137], al
$LN309@output_opc:

; 1283 :           CodeInfo->evex_p0 |= ((CodeInfo->prefix.rex & REX_B) ? 0 : 0x20);/*  REX_B regno 0-7 <-> 8-15 of ModR/M or SIB base */

	movzx	eax, BYTE PTR [rdi+8]
	shl	al, 5
	not	al
	and	al, 32					; 00000020H
	or	BYTE PTR [rdi+137], al

; 1284 : 				}
; 1285 : 				else { 

	jmp	SHORT $LN308@output_opc
$LN310@output_opc:

; 1286 :           /* only 2 registers */
; 1287 :           CodeInfo->evex_p0 &= ~0x20;  // clear REX_B

	and	BYTE PTR [rdi+137], 223			; 000000dfH

; 1288 : 					if (CodeInfo->reg2 <= 7) CodeInfo->evex_p0 |= EVEX_P0XMASK;

	cmp	BYTE PTR [rdi+110], 7
	movzx	eax, BYTE PTR [rdi+137]
	ja	SHORT $LN307@output_opc
	or	al, 64					; 00000040H
	mov	BYTE PTR [rdi+137], al
$LN307@output_opc:

; 1289 :           CodeInfo->evex_p0 |= ((CodeInfo->prefix.rex & REX_B) ? 0 : 0x20);/*  REX_B regno 0-7 <-> 8-15 of ModR/M or SIB base */

	movzx	eax, BYTE PTR [rdi+8]
	shl	al, 5
	not	al
	and	al, 32					; 00000020H
	or	BYTE PTR [rdi+137], al
$LN308@output_opc:

; 1290 : 				}
; 1291 :           if (CodeInfo->basereg != 0xFF){

	movzx	eax, BYTE PTR [rdi+113]
	cmp	al, 255					; 000000ffH
	je	SHORT $LN304@output_opc

; 1292 :             if (CodeInfo->basereg <= 7)   

	cmp	al, 7
	ja	SHORT $LN305@output_opc

; 1293 :               CodeInfo->evex_p0 |= EVEX_P0BMASK;

	or	BYTE PTR [rdi+137], 32			; 00000020H

; 1294 :             else

	jmp	SHORT $LN304@output_opc
$LN305@output_opc:

; 1295 :               CodeInfo->evex_p0 &= ~EVEX_P0BMASK;

	and	BYTE PTR [rdi+137], 223			; 000000dfH
$LN304@output_opc:

; 1296 :             }
; 1297 : 				if ((CodeInfo->token >= T_VMOVLHPS) && (CodeInfo->token <= T_VMOVLPS) ||
; 1298 : 					(CodeInfo->token == T_VMOVNTDQ) ||
; 1299 : 					(CodeInfo->token == T_VMOVUPD) || (CodeInfo->token == T_VMOVAPD) ||
; 1300 : 					(CodeInfo->token >= T_VMOVDQA32) && (CodeInfo->token <= T_VMOVDQU64) ||
; 1301 : 					(CodeInfo->token == T_VMOVAPS) || (CodeInfo->token == T_VMOVUPS)) {

	mov	ecx, DWORD PTR [rdi+24]
	cmp	ecx, 1982				; 000007beH
	jl	SHORT $LN301@output_opc
	cmp	ecx, 1986				; 000007c2H
	jle	$LN302@output_opc
$LN301@output_opc:
	cmp	ecx, 1991				; 000007c7H
	je	$LN302@output_opc
	cmp	ecx, 1997				; 000007cdH
	je	$LN302@output_opc
	cmp	ecx, 1975				; 000007b7H
	je	$LN302@output_opc
	cmp	ecx, 1685				; 00000695H
	jl	SHORT $LN300@output_opc
	cmp	ecx, 1688				; 00000698H
	jle	$LN302@output_opc
$LN300@output_opc:
	cmp	ecx, 1976				; 000007b8H
	je	$LN302@output_opc
	cmp	ecx, 1998				; 000007ceH
	je	$LN302@output_opc

; 1323 : 					}
; 1324 : 				}
; 1325 : 				else {  // this is a fix for VMOVSS when first operand is RIP memory, HJWasm 2.16
; 1326 : 					if (CodeInfo->opnd[OPND1].type & OP_M_ANY) {

	test	r8d, r8d
	je	SHORT $LN279@output_opc

; 1327 : 						if (CodeInfo->reg2 <= 15) CodeInfo->evex_p0 |= EVEX_P0R1MASK;

	movzx	eax, BYTE PTR [rdi+110]
	cmp	al, 15
	ja	SHORT $LN278@output_opc
	or	BYTE PTR [rdi+137], 16
	jmp	SHORT $LN277@output_opc
$LN278@output_opc:

; 1328 : 						else CodeInfo->evex_p0 &= ~EVEX_P0R1MASK;

	and	BYTE PTR [rdi+137], 239			; 000000efH
$LN277@output_opc:

; 1329 : 						if ((CodeInfo->reg2 <= 7) || (CodeInfo->reg2 >= 16 && CodeInfo->reg2 <= 23))

	cmp	al, 7
	jbe	SHORT $LN275@output_opc
	cmp	al, 16
	jb	SHORT $LN276@output_opc
	cmp	al, 23
	jbe	SHORT $LN275@output_opc
$LN276@output_opc:

; 1331 : 						else CodeInfo->evex_p0 &= ~EVEX_P0RMASK;

	and	BYTE PTR [rdi+137], 127			; 0000007fH
	jmp	$LN291@output_opc
$LN275@output_opc:

; 1330 : 							CodeInfo->evex_p0 |= EVEX_P0RMASK;

	or	BYTE PTR [rdi+137], 128			; 00000080H

; 1332 : 					}
; 1333 : 					else if (CodeInfo->opnd[OPND2].type & OP_M_ANY) {

	jmp	$LN291@output_opc
$LN279@output_opc:
	test	r9d, -8388608				; ffffffffff800000H
	je	SHORT $LN272@output_opc

; 1334 : 						if (CodeInfo->reg1 <= 15) CodeInfo->evex_p0 |= EVEX_P0R1MASK;

	movzx	eax, BYTE PTR [rdi+109]
	cmp	al, 15
	ja	SHORT $LN271@output_opc
	or	BYTE PTR [rdi+137], 16
	jmp	SHORT $LN270@output_opc
$LN271@output_opc:

; 1335 : 						else CodeInfo->evex_p0 &= ~EVEX_P0R1MASK;

	and	BYTE PTR [rdi+137], 239			; 000000efH
$LN270@output_opc:

; 1336 : 						if ((CodeInfo->reg1 <= 7) || (CodeInfo->reg1 >= 16 && CodeInfo->reg1 <= 23))

	cmp	al, 7
	jbe	SHORT $LN268@output_opc
	cmp	al, 16
	jb	SHORT $LN269@output_opc
	cmp	al, 23
	jbe	SHORT $LN268@output_opc
$LN269@output_opc:

; 1338 : 						else CodeInfo->evex_p0 &= ~EVEX_P0RMASK;

	and	BYTE PTR [rdi+137], 127			; 0000007fH
	jmp	$LN291@output_opc
$LN268@output_opc:

; 1337 : 							CodeInfo->evex_p0 |= EVEX_P0RMASK;

	or	BYTE PTR [rdi+137], 128			; 00000080H

; 1339 : 					}
; 1340 : 					else {

	jmp	$LN291@output_opc
$LN272@output_opc:

; 1341 : 						if (CodeInfo->reg1 <= 15) CodeInfo->evex_p0 |= EVEX_P0R1MASK;

	movzx	eax, BYTE PTR [rdi+109]
	cmp	al, 15
	ja	SHORT $LN265@output_opc
	or	BYTE PTR [rdi+137], 16
	jmp	SHORT $LN264@output_opc
$LN265@output_opc:

; 1342 : 						else CodeInfo->evex_p0 &= ~EVEX_P0R1MASK;

	and	BYTE PTR [rdi+137], 239			; 000000efH
$LN264@output_opc:

; 1343 : 						if ((CodeInfo->reg1 <= 7) || (CodeInfo->reg1 >= 16 && CodeInfo->reg1 <= 23))

	cmp	al, 7
	jbe	SHORT $LN262@output_opc
	cmp	al, 16
	jb	SHORT $LN263@output_opc
	cmp	al, 23
	jbe	SHORT $LN262@output_opc
$LN263@output_opc:

; 1345 : 						else CodeInfo->evex_p0 &= ~EVEX_P0RMASK;

	and	BYTE PTR [rdi+137], 127			; 0000007fH
	jmp	SHORT $LN261@output_opc
$LN262@output_opc:

; 1344 : 							CodeInfo->evex_p0 |= EVEX_P0RMASK;

	or	BYTE PTR [rdi+137], 128			; 00000080H
$LN261@output_opc:

; 1346 :           CodeInfo->evex_p0 &= ~0x20;  // clear REX_B
; 1347 :           CodeInfo->evex_p0 |= ((CodeInfo->prefix.rex & REX_B) ? 0 : 0x20);/*  REX_B regno 0-7 <-> 8-15 of ModR/M or SIB base */

	movzx	eax, BYTE PTR [rdi+8]
	and	BYTE PTR [rdi+137], 223			; 000000dfH
	shl	al, 5
	not	al
	and	al, 32					; 00000020H
	or	BYTE PTR [rdi+137], al
	jmp	$LN291@output_opc
$LN302@output_opc:

; 1302 : 					if ((CodeInfo->opnd[OPND1].type & OP_XMM) || (CodeInfo->opnd[OPND1].type & OP_YMM) ||
; 1303 : 						(CodeInfo->opnd[OPND1].type & OP_ZMM)) {

	test	r10b, 32				; 00000020H
	jne	SHORT $LN298@output_opc
	test	r10b, r10b
	js	SHORT $LN298@output_opc
	bt	r10d, 8
	jb	SHORT $LN298@output_opc

; 1312 : 					}
; 1313 : 					else if ((CodeInfo->opnd[OPND2].type & OP_XMM) || (CodeInfo->opnd[OPND2].type & OP_YMM) ||
; 1314 : 						(CodeInfo->opnd[OPND2].type & OP_ZMM)) {

	test	r9b, 32					; 00000020H
	jne	SHORT $LN288@output_opc
	test	r9b, r9b
	js	SHORT $LN288@output_opc
	bt	r9d, 8
	jae	$LN291@output_opc
$LN288@output_opc:

; 1315 : 						if ((CodeInfo->reg2 <= 7) || (CodeInfo->reg2 >= 16 && CodeInfo->reg2 <= 23))

	movzx	eax, BYTE PTR [rdi+110]
	cmp	al, 7
	jbe	SHORT $LN286@output_opc
	cmp	al, 16
	jb	SHORT $LN287@output_opc
	cmp	al, 23
	jbe	SHORT $LN286@output_opc
$LN287@output_opc:

; 1317 : 						else CodeInfo->evex_p0 &= ~EVEX_P0RMASK;

	and	BYTE PTR [rdi+137], 127			; 0000007fH
	jmp	SHORT $LN285@output_opc
$LN286@output_opc:

; 1316 : 							CodeInfo->evex_p0 |= EVEX_P0RMASK;

	or	BYTE PTR [rdi+137], 128			; 00000080H
$LN285@output_opc:

; 1318 : 						if (CodeInfo->reg2 <= 15)

	cmp	al, 15
	ja	SHORT $LN284@output_opc

; 1319 : 							CodeInfo->evex_p0 |= EVEX_P0R1MASK;

	or	BYTE PTR [rdi+137], 16
	jmp	SHORT $LN283@output_opc
$LN284@output_opc:

; 1320 : 						else CodeInfo->evex_p0 &= ~EVEX_P0R1MASK;

	and	BYTE PTR [rdi+137], 239			; 000000efH
$LN283@output_opc:

; 1321 : 						if (CodeInfo->opnd[OPND2].type & OP_YMM) CodeInfo->evex_p2 |= EVEX_P2LMASK;

	test	r9b, r9b
	jns	SHORT $LN282@output_opc
	or	BYTE PTR [rdi+139], 32			; 00000020H
$LN282@output_opc:

; 1322 : 						if (CodeInfo->opnd[OPND2].type & OP_ZMM) CodeInfo->evex_p2 |= EVEX_P2L1MASK;

	bt	r9d, 8
	jae	SHORT $LN291@output_opc
	or	BYTE PTR [rdi+139], 64			; 00000040H
	jmp	SHORT $LN291@output_opc
$LN298@output_opc:

; 1304 : 						if ((CodeInfo->reg1 <= 7) || (CodeInfo->reg1 >= 16 && CodeInfo->reg1 <= 23))

	movzx	eax, BYTE PTR [rdi+109]
	cmp	al, 7
	jbe	SHORT $LN296@output_opc
	cmp	al, 16
	jb	SHORT $LN297@output_opc
	cmp	al, 23
	jbe	SHORT $LN296@output_opc
$LN297@output_opc:

; 1306 : 						else CodeInfo->evex_p0 &= ~EVEX_P0RMASK;

	and	BYTE PTR [rdi+137], 127			; 0000007fH
	jmp	SHORT $LN295@output_opc
$LN296@output_opc:

; 1305 : 							CodeInfo->evex_p0 |= EVEX_P0RMASK;

	or	BYTE PTR [rdi+137], 128			; 00000080H
$LN295@output_opc:

; 1307 : 						if (CodeInfo->reg1 <= 15) 

	cmp	al, 15
	ja	SHORT $LN294@output_opc

; 1308 :               CodeInfo->evex_p0 |= EVEX_P0R1MASK;

	or	BYTE PTR [rdi+137], 16
	jmp	SHORT $LN293@output_opc
$LN294@output_opc:

; 1309 : 						else CodeInfo->evex_p0 &= ~EVEX_P0R1MASK;

	and	BYTE PTR [rdi+137], 239			; 000000efH
$LN293@output_opc:

; 1310 : 						if (CodeInfo->opnd[OPND1].type & OP_YMM) CodeInfo->evex_p2 |= EVEX_P2LMASK;

	test	r10b, r10b
	jns	SHORT $LN292@output_opc
	or	BYTE PTR [rdi+139], 32			; 00000020H
$LN292@output_opc:

; 1311 : 						if (CodeInfo->opnd[OPND1].type & OP_ZMM) CodeInfo->evex_p2 |= EVEX_P2L1MASK;

	bt	r10d, 8
	jae	SHORT $LN291@output_opc
	or	BYTE PTR [rdi+139], 64			; 00000040H
$LN291@output_opc:

; 1348 :             }
; 1349 : 				}
; 1350 : 				if ((CodeInfo->token == T_VMOVNTPD) || (CodeInfo->token == T_VMOVNTPS)) {

	cmp	ecx, 1993				; 000007c9H
	je	SHORT $LN259@output_opc
	cmp	ecx, 1994				; 000007caH
	jne	SHORT $LN254@output_opc
$LN259@output_opc:

; 1351 : 					if (CodeInfo->reg2 <= 15) CodeInfo->evex_p0 |= EVEX_P0R1MASK;

	movzx	eax, BYTE PTR [rdi+110]
	cmp	al, 15
	ja	SHORT $LN258@output_opc
	or	BYTE PTR [rdi+137], 16
	jmp	SHORT $LN257@output_opc
$LN258@output_opc:

; 1352 : 					else CodeInfo->evex_p0 &= ~EVEX_P0R1MASK;

	and	BYTE PTR [rdi+137], 239			; 000000efH
$LN257@output_opc:

; 1353 : 					if ((CodeInfo->reg2 <= 7) || (CodeInfo->reg2 >= 16 && CodeInfo->reg2 <= 23))

	cmp	al, 7
	jbe	SHORT $LN255@output_opc
	cmp	al, 16
	jb	SHORT $LN256@output_opc
	cmp	al, 23
	jbe	SHORT $LN255@output_opc
$LN256@output_opc:

; 1355 : 					else CodeInfo->evex_p0 &= ~EVEX_P0RMASK;

	and	BYTE PTR [rdi+137], 127			; 0000007fH
	jmp	SHORT $LN254@output_opc
$LN255@output_opc:

; 1354 : 						CodeInfo->evex_p0 |= EVEX_P0RMASK;

	or	BYTE PTR [rdi+137], 128			; 00000080H
$LN254@output_opc:

; 1356 : 				}
; 1357 : 				if ((CodeInfo->token >= T_VMOVLHPS) && (CodeInfo->token <= T_VMOVLPS)) {

	cmp	ecx, 1982				; 000007beH
	jl	SHORT $LN252@output_opc
	cmp	ecx, 1986				; 000007c2H
	jg	SHORT $LN252@output_opc

; 1358 : 					if ((CodeInfo->opnd[OPND1].type == OP_YMM) || (CodeInfo->opnd[OPND2].type == OP_YMM) ||
; 1359 : 						(CodeInfo->opnd[OPND1].type == OP_ZMM) || (CodeInfo->opnd[OPND2].type == OP_ZMM))

	cmp	r10d, 128				; 00000080H
	je	SHORT $LN251@output_opc
	cmp	r9d, 128				; 00000080H
	je	SHORT $LN251@output_opc
	cmp	r10d, 256				; 00000100H
	je	SHORT $LN251@output_opc
	cmp	r9d, 256				; 00000100H
	jne	SHORT $LN252@output_opc
$LN251@output_opc:

; 1360 : 						EmitError(INVALID_INSTRUCTION_OPERANDS);

	mov	ecx, 49					; 00000031H
	call	EmitError
$LN252@output_opc:

; 1361 : 				}
; 1362 : 				OutputCodeByte(CodeInfo->evex_p0);

	movzx	ecx, BYTE PTR [rdi+137]
	call	OutputByte

; 1363 : 			}
; 1364 : 			else {

	jmp	$LN250@output_opc
$LN660@output_opc:

; 582  :             uint_8 byte1 = 0;      //RXBR00MM

	xor	bl, bl

; 583  :             /* first byte is 0xC4  in 3 byte VEX prefix */  
; 584  :             if (CodeInfo->evex_flag) 

	cmp	BYTE PTR [rdi+136], bl
	je	SHORT $LN658@output_opc

; 585  :               OutputCodeByte( 0x62 ); //AVX512 EVEX first byte

	mov	cl, 98					; 00000062H
	call	OutputByte

; 586  :             else{

	jmp	$LN642@output_opc
$LN658@output_opc:

; 587  :               /* These instructions if, not 0x62, can be only 0xC5, HJWasm 2.16 */
; 588  :                 if (CodeInfo->token == T_VPMOVMSKB){

	cmp	ecx, 2068				; 00000814H
	jne	SHORT $LN654@output_opc

; 589  :                   if(ins->byte1_info == F_0F && (CodeInfo->prefix.rex & REX_B == 0)&& 
; 590  :                      (CodeInfo->prefix.rex & REX_X == 0) && (CodeInfo->prefix.rex & REX_W == 8))
; 591  :                         goto outC5;    // go handle 0xC5 instruction
; 592  :                   CodeInfo->prefix.rex &= ~REX_W; // clear the W bit.

	and	BYTE PTR [rdi+8], 247			; 000000f7H

; 593  :                   if(CodeInfo->reg3 > 7) lbyte |= 1;

	cmp	BYTE PTR [rdi+111], 7
	jbe	SHORT $LN654@output_opc
	or	sil, 1
$LN654@output_opc:

; 594  :                 }              
; 595  :                 if (CodeInfo->token >= T_VPSLLDQ && CodeInfo->token <= T_VPSRLQ){

	cmp	ecx, 2097				; 00000831H
	jl	$LN653@output_opc
	cmp	ecx, 2107				; 0000083bH
	jg	$LN653@output_opc

; 596  :                   if ((CodeInfo->reg2 <= 7) && ((CodeInfo->opnd[OPND2].type & OP_M_ANY ) == 0))

	cmp	BYTE PTR [rdi+110], 7
	ja	$LN652@output_opc
	test	DWORD PTR [rdi+56], -8388608		; ffffffffff800000H
	jne	$LN652@output_opc
$outC5$5690:

; 1365 : 			outC5:
; 1366 : 				
; 1367 : 				/* John: Validate 3 operand vex form */
; 1368 : 				if (CodeInfo->opnd[OPND3].type == OP_NONE && CodeInfo->vexregop == 0 &&
; 1369 : 					(vex_flags[CodeInfo->token - VEX_START] & VX_NND) == 0 &&
; 1370 : 					(vex_flags[CodeInfo->token - VEX_START] & VX_NMEM) == 0)

	cmp	DWORD PTR [rdi+80], r13d
	jne	SHORT $LN249@output_opc
	cmp	BYTE PTR [rdi+128], r13b
	jne	SHORT $LN249@output_opc
	mov	rax, rcx
	movzx	ecx, BYTE PTR vex_flags[rcx+r15-1304]
	test	cl, 2
	jne	SHORT $LN249@output_opc
	test	cl, 16
	jne	SHORT $LN249@output_opc

; 1371 : 				{
; 1372 : 					EmitError(INVALID_INSTRUCTION_OPERANDS);

	mov	ecx, 49					; 00000031H
	call	EmitError
$LN249@output_opc:

; 1373 : 				}
; 1374 : 
; 1375 : 				OutputCodeByte(0xC5);

	mov	cl, 197					; 000000c5H
	call	OutputByte

; 1376 : 				if (CodeInfo->opnd[OPND1].type == OP_YMM || CodeInfo->opnd[OPND2].type == OP_YMM || CodeInfo->token == T_VZEROALL) /* VZEROALL is 256 bits VZEROUPPER is 128 bits */

	cmp	DWORD PTR [rdi+32], 128			; 00000080H
	je	SHORT $LN247@output_opc
	cmp	DWORD PTR [rdi+56], 128			; 00000080H
	je	SHORT $LN247@output_opc
	cmp	DWORD PTR [rdi+24], 1347		; 00000543H
	je	SHORT $LN247@output_opc

; 1378 : 				else
; 1379 : 					lbyte &= ~0x04;

	and	sil, 251				; 000000fbH
	jmp	SHORT $LN246@output_opc
$LN247@output_opc:

; 1377 : 					lbyte |= 0x04;  /* set L: Vector Length */

	or	sil, 4
$LN246@output_opc:

; 1380 : 				CodeInfo->tuple = 0;

	mov	BYTE PTR [rdi+140], r13b
$LN250@output_opc:

; 1381 : 			}
; 1382 : 			/* second byte R vvvv Lpp   */
; 1383 : 			if ((CodeInfo->token == T_LZCNT) || (CodeInfo->token == T_TZCNT))

	movsxd	rcx, DWORD PTR [rdi+24]
	cmp	ecx, 1284				; 00000504H
	je	SHORT $LN244@output_opc
	cmp	ecx, 1285				; 00000505H
	jne	SHORT $LN245@output_opc
$LN244@output_opc:

; 1384 : 				lbyte |= 0x80;

	or	sil, 128				; 00000080H
$LN245@output_opc:

; 1385 : 			if (CodeInfo->token == T_VMASKMOVDQU) {

	cmp	ecx, 1974				; 000007b6H
	jne	SHORT $LN240@output_opc

; 1386 : 				/*  1 1111 0pp */
; 1387 : 				/*  R vvvv Lpp */
; 1388 : 				lbyte |= 0xF8;
; 1389 : 				if (ins->byte1_info == F_660F) lbyte |= 0x01;

	mov	al, BYTE PTR [r12+1]
	or	sil, 248				; 000000f8H
	cmp	al, 18
	jne	SHORT $LN242@output_opc
	or	sil, 1
	jmp	SHORT $LN240@output_opc
$LN242@output_opc:

; 1390 : 				else if (ins->byte1_info == F_0F) lbyte |= 0x3;

	cmp	al, 16
	jne	SHORT $LN240@output_opc
	or	sil, bpl
$LN240@output_opc:

; 1391 : 			}  //WVVVV1PP
; 1392 : 			/* if broadflags are prezent W = 0  in WVVVV1PP */
; 1393 : 			if (CodeInfo->token == T_VPGATHERDQ || CodeInfo->token == T_VPGATHERQQ ||
; 1394 : 				CodeInfo->token == T_VGATHERDPD || CodeInfo->token == T_VGATHERQPD) {

	cmp	ecx, 1367				; 00000557H
	je	SHORT $LN238@output_opc
	cmp	ecx, 1368				; 00000558H
	je	SHORT $LN238@output_opc
	cmp	ecx, 1369				; 00000559H
	je	SHORT $LN238@output_opc
	cmp	ecx, 1370				; 0000055aH
	jne	SHORT $LN239@output_opc
$LN238@output_opc:

; 1395 : 				lbyte |= 0x80;

	or	sil, 128				; 00000080H
$LN239@output_opc:

; 1396 : 			}
; 1397 : 			if (CodeInfo->token == T_VGATHERDPS)lbyte &= ~0x80;

	cmp	ecx, 1371				; 0000055bH
	jne	SHORT $LN237@output_opc
	and	sil, 127				; 0000007fH
$LN237@output_opc:

; 1398 : 			if (CodeInfo->evex_flag) {

	movzx	r9d, BYTE PTR [rdi+136]
	test	r9b, r9b
	je	SHORT $LN235@output_opc

; 1399 : 				if ((CodeInfo->opnd[OPND2].type == OP_R32) || (CodeInfo->opnd[OPND2].type == OP_EAX))

	mov	eax, DWORD PTR [rdi+56]
	cmp	eax, 4
	je	SHORT $LN234@output_opc
	cmp	eax, 516				; 00000204H
	jne	SHORT $LN235@output_opc
$LN234@output_opc:

; 1400 : 					lbyte &= ~EVEX_P1WMASK;

	and	sil, 127				; 0000007fH
$LN235@output_opc:

; 1401 : 			}
; 1402 : 			if ((CodeInfo->token >= T_KADDB) && (CodeInfo->token <= T_KUNPCKDQ)) {       //here pay atention

	cmp	ecx, 1730				; 000006c2H
	jl	SHORT $LN233@output_opc
	cmp	ecx, 1756				; 000006dcH
	jg	SHORT $LN233@output_opc

; 1403 : 				c = CodeInfo->reg2;
; 1404 : 				lbyte &= 0x83;
; 1405 : 				c = (c << 3);

	movzx	edx, BYTE PTR [rdi+110]
	and	sil, 131				; 00000083H

; 1406 : 				c = ~c;
; 1407 : 				c &= EVEX_P1VVVV;
; 1408 : 				lbyte |= c;
; 1409 : 				if (vex_flags[CodeInfo->token - VEX_START] & VX_L) lbyte |= c;

	mov	rax, rcx
	shl	dl, 3
	not	dl
	and	dl, 120					; 00000078H
	or	sil, dl
	test	BYTE PTR vex_flags[rcx+r15-1304], 1
	je	SHORT $LN224@output_opc
	or	sil, dl

; 1410 : 			}
; 1411 : 			else if ((CodeInfo->token >= T_KNOTB) && (CodeInfo->token <= T_KORTESTQ)) {

	jmp	SHORT $LN224@output_opc
$LN233@output_opc:
	cmp	ecx, 1757				; 000006ddH
	jl	SHORT $LN230@output_opc
	cmp	ecx, 1764				; 000006e4H
	jg	SHORT $LN230@output_opc

; 1412 : 				/*  1 1111 0pp */
; 1413 : 				/*  R vvvv Lpp */
; 1414 : 				lbyte = 0xF8;
; 1415 : 				if (ins->byte1_info == F_660F) lbyte |= 0x01;

	cmp	BYTE PTR [r12+1], 18
	mov	sil, 248				; 000000f8H
	jne	SHORT $LN224@output_opc
	mov	sil, 249				; 000000f9H

; 1416 : 			}
; 1417 : 			else if ((CodeInfo->token >= T_KMOVB) && (CodeInfo->token <= T_KMOVW)) {

	jmp	SHORT $LN224@output_opc
$LN230@output_opc:
	cmp	ecx, 1773				; 000006edH
	jl	SHORT $LN224@output_opc
	cmp	ecx, 1776				; 000006f0H
	jg	SHORT $LN224@output_opc

; 1418 : 				/*  1 1111 0pp */
; 1419 : 				/*  R vvvv Lpp */
; 1420 : 				lbyte = 0xF8;
; 1421 : 				if (ins->byte1_info == F_660F) lbyte |= 0x01;

	mov	dl, BYTE PTR [r12+1]
	mov	al, 248					; 000000f8H
	cmp	dl, 18
	jne	SHORT $LN226@output_opc
	mov	sil, 249				; 000000f9H
	jmp	SHORT $LN224@output_opc
$LN226@output_opc:

; 1422 : 				else if (ins->byte1_info == F_F20F) lbyte |= 0x3;

	movzx	eax, al
	mov	r8d, 251				; 000000fbH
	cmp	dl, 19
	cmove	eax, r8d
	mov	sil, al
$LN224@output_opc:

; 1423 : 			}  //WVVVV1PP
; 1424 : 			if ((CodeInfo->token == T_VMOVHPD) || (CodeInfo->token == T_VMOVNTDQ) ||
; 1425 : 				(CodeInfo->token >= T_VFPCLASSPD) && (CodeInfo->token <= T_VFPCLASSSS)) {

	cmp	ecx, 1983				; 000007bfH
	je	SHORT $LN222@output_opc
	cmp	ecx, 1991				; 000007c7H
	je	SHORT $LN222@output_opc
	cmp	ecx, 1690				; 0000069aH
	jl	SHORT $LN220@output_opc
	cmp	ecx, 1693				; 0000069dH
	jg	SHORT $LN220@output_opc
$LN222@output_opc:

; 1426 : 				if (CodeInfo->vexregop) {

	movzx	edx, BYTE PTR [rdi+128]
	test	dl, dl
	je	SHORT $LN221@output_opc

; 1427 : 					lbyte &= ~0x78;
; 1428 : 					lbyte |= ((16 - CodeInfo->vexregop) << 3);

	shl	dl, 3
	and	sil, 135				; 00000087H
	mov	eax, 128				; 00000080H
	sub	al, dl
	or	al, sil
	mov	sil, al
	jmp	SHORT $LN220@output_opc
$LN221@output_opc:

; 1429 : 				}
; 1430 : 				else lbyte |= 0x78;

	or	sil, 120				; 00000078H
$LN220@output_opc:

; 1431 : 			}
; 1432 : 			if (CodeInfo->evex_flag) {

	test	r9b, r9b
	je	SHORT $LN218@output_opc

; 1433 : 				if ((CodeInfo->token == T_VMOVHPS) || (CodeInfo->token == T_VMOVLPS))

	cmp	ecx, 1984				; 000007c0H
	je	SHORT $LN217@output_opc
	cmp	ecx, 1986				; 000007c2H
	jne	SHORT $LN218@output_opc
$LN217@output_opc:

; 1434 : 					lbyte &= ~EVEX_P1WMASK;

	and	sil, 127				; 0000007fH
$LN218@output_opc:

; 1435 : 			}
; 1436 : 			if(CodeInfo->token == T_VPSLLDQ || CodeInfo->token == T_VPSRLDQ)

	cmp	ecx, 2097				; 00000831H
	je	SHORT $LN215@output_opc
	cmp	ecx, 2098				; 00000832H
	jne	SHORT $LN216@output_opc
$LN215@output_opc:

; 1437 :         lbyte &= ~EVEX_P1WMASK;

	and	sil, 127				; 0000007fH
$LN216@output_opc:

; 1438 : 			if ((CodeInfo->token == T_VPSRAQ) || (CodeInfo->token == T_VPROLQ) ||
; 1439 : 				(CodeInfo->token == T_VPRORQ))

	cmp	ecx, 2104				; 00000838H
	je	SHORT $LN213@output_opc
	cmp	ecx, 1571				; 00000623H
	je	SHORT $LN213@output_opc
	cmp	ecx, 1575				; 00000627H
	jne	SHORT $LN214@output_opc
$LN213@output_opc:

; 1440 : 				lbyte |= EVEX_P1WMASK;

	or	sil, 128				; 00000080H
$LN214@output_opc:

; 1441 : 			//if (CodeInfo->token == T_VPROLD){
; 1442 : 			//  //__debugbreak();
; 1443 : 			//  lbyte &= ~EVEX_P1WMASK;
; 1444 : 			//   if (CodeInfo->vexregop){
; 1445 : 			//     lbyte &= ~EVEX_P1VVVV;
; 1446 : 			//     lbyte |= ((16 - CodeInfo->reg1-1) << 3);
; 1447 : 			//   }
; 1448 : 			//  }
; 1449 : 		   //if first byte is VEX 0xC5 then there is two byte folowing 
; 1450 : 		   /* set L: Vector Length for all instructions between KADDB and  KUNPCKDQ  HJWasm 2.16 */
; 1451 : 			if ((CodeInfo->token >= T_KADDB) && (CodeInfo->token <= T_KUNPCKDQ)) lbyte |= 0x04;

	cmp	ecx, 1730				; 000006c2H
	jl	SHORT $LN212@output_opc
	cmp	ecx, 1756				; 000006dcH
	jg	SHORT $LN212@output_opc
	or	sil, 4
$LN212@output_opc:

; 1452 : 			/* That is where is fixed problem with the VEX registers size, HJWasm 2.16 */
; 1453 : 			if (CodeInfo->token == T_VPMOVMSKB) {

	cmp	ecx, 2068				; 00000814H
	jne	SHORT $LN211@output_opc

; 1454 : 				lbyte |= EVEX_P1WMASK;    // 2 byte vex_p1 R must be set
; 1455 : 				if (CodeInfo->opnd[OPND1].type == OP_YMM)

	mov	eax, DWORD PTR [rdi+32]
	or	sil, 128				; 00000080H
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN210@output_opc

; 1456 : 					lbyte |= 0x04;         // for YMM register bit 2 byte VEX L bit is set

	or	sil, 4
	jmp	SHORT $LN208@output_opc
$LN210@output_opc:

; 1457 : 				else if (CodeInfo->opnd[OPND1].type == OP_XMM)

	cmp	eax, 32					; 00000020H
	jne	SHORT $LN208@output_opc

; 1458 : 					lbyte &= ~0x04;                     // for XMM register bit 2 byte VEX L bit is cleared

	and	sil, 251				; 000000fbH
$LN208@output_opc:

; 1459 : 				lbyte &= ~0x03;                     // clear vex_p1 PP 

	and	sil, 253				; 000000fdH

; 1460 : 				lbyte |= 0x01;                     // set vex_p1 01: 66

	or	sil, 1
$LN211@output_opc:

; 1461 : 			}
; 1462 : 			if (CodeInfo->token == T_VCVTPS2PD)

	cmp	ecx, 1951				; 0000079fH
	jne	SHORT $LN203@output_opc

; 1463 : 			{				
; 1464 :         if (CodeInfo->evex_flag){

	test	r9b, r9b
	je	SHORT $LN206@output_opc

; 1465 :           /* EVEX VCVTPS2PD must be W0*/
; 1466 :           CodeInfo->evex_p1 &= ~EVEX_P1WMASK;
; 1467 : 					CodeInfo->evex_p1 |= 0xf0;    // EVEX.vvvv is reserved and must be 1111b

	or	BYTE PTR [rdi+138], 240			; 000000f0H

; 1468 :           }
; 1469 :         else{

	jmp	SHORT $LN203@output_opc
$LN206@output_opc:

; 1470 :           /* AVX are both WIG */
; 1471 :           lbyte &= ~EVEX_P1WMASK;
; 1472 :           lbyte |= 0xf0;               // VEX.vvvv is reserved and must be 1111b
; 1473 :           if ((CodeInfo->opnd[OPND2].type == OP_XMM)|| (CodeInfo->opnd[OPND2].type == OP_M64) );

	mov	eax, DWORD PTR [rdi+56]
	or	sil, 240				; 000000f0H
	cmp	eax, 32					; 00000020H
	je	SHORT $LN203@output_opc
	cmp	eax, 67108864				; 04000000H
	je	SHORT $LN203@output_opc

; 1474 :             else EmitError(INVALID_INSTRUCTION_OPERANDS);

	mov	ecx, 49					; 00000031H
	call	EmitError
$LN203@output_opc:

; 1475 :           }
; 1476 : 			  }
; 1477 : 			if (CodeInfo->token == T_VCVTPD2PS)

	cmp	DWORD PTR [rdi+24], 1363		; 00000553H
	jne	SHORT $LN197@output_opc

; 1478 : 			{				
; 1479 :         if (CodeInfo->evex_flag){

	cmp	BYTE PTR [rdi+136], r13b
	je	SHORT $LN200@output_opc

; 1480 :           /* EVEX VCVTPD2PS must be W1 */
; 1481 :           CodeInfo->evex_p1 |= EVEX_P1WMASK;
; 1482 : 					CodeInfo->evex_p1 |= 0xf0;    // EVEX.vvvv is reserved and must be 1111b

	or	BYTE PTR [rdi+138], 240			; 000000f0H

; 1483 :           }
; 1484 :         else{

	jmp	SHORT $LN197@output_opc
$LN200@output_opc:

; 1485 :           /* AVX are both WIG */
; 1486 :           lbyte &= ~EVEX_P1WMASK;
; 1487 :           lbyte |= 0xf0;               // VEX.vvvv is reserved and must be 1111b

	or	sil, 240				; 000000f0H

; 1488 :           if (CodeInfo->opnd[OPND1].type != OP_XMM) 

	cmp	DWORD PTR [rdi+32], 32			; 00000020H
	je	SHORT $LN198@output_opc

; 1489 :             EmitError(INVALID_INSTRUCTION_OPERANDS);

	mov	ecx, 49					; 00000031H
	call	EmitError
$LN198@output_opc:

; 1490 :           if (CodeInfo->opnd[OPND2].type == OP_M256)

	cmp	DWORD PTR [rdi+56], 268435456		; 10000000H
	jne	SHORT $LN197@output_opc

; 1491 :             lbyte |= 0x4;              // L bit

	or	sil, 4
$LN197@output_opc:

; 1492 :           }
; 1493 : 			  }	
; 1494 : 
; 1495 :           CodeInfo->evex_p1 = lbyte;
; 1496 :           OutputCodeByte( lbyte );

	movzx	ecx, sil
	mov	BYTE PTR [rdi+138], sil
	call	OutputByte

; 1497 :           if (CodeInfo->evex_flag) {

	cmp	BYTE PTR [rdi+136], r13b
	je	$LN98@output_opc

; 1498 :             if (broadflags >= 0x10 && broadflags <= 0x47){ 

	movzx	eax, BYTE PTR broadflags
	sub	al, 16
	cmp	al, 55					; 00000037H
	ja	$LN195@output_opc

; 1499 :               // __debugbreak();
; 1500 :               CodeInfo->evex_p2 |= 0x10;

	or	BYTE PTR [rdi+139], 16

; 1501 :               if (CodeInfo->vexregop){                 

	cmp	BYTE PTR [rdi+128], r13b
	movzx	eax, BYTE PTR [rdi+139]
	je	SHORT $LN194@output_opc

; 1502 :                 if (CodeInfo->reg2 <= 15) CodeInfo->evex_p2 |= EVEX_P2VMASK;

	cmp	BYTE PTR [rdi+110], 15
	ja	SHORT $LN193@output_opc
	or	al, 8
	mov	BYTE PTR [rdi+139], al
	jmp	SHORT $LN191@output_opc
$LN193@output_opc:

; 1503 :                 else CodeInfo->evex_p2 &= ~EVEX_P2VMASK;

	and	al, 247					; 000000f7H
	mov	BYTE PTR [rdi+139], al

; 1504 :               }
; 1505 :               else CodeInfo->evex_p2 |= EVEX_P2VMASK;

	jmp	SHORT $LN191@output_opc
$LN194@output_opc:
	or	al, 8
	mov	BYTE PTR [rdi+139], al
$LN191@output_opc:

; 1506 :               if (CodeInfo->r2type == OP_XMM && (broadflags & ~EVEX_P2AAAMASK) == 0x10){   //{1to2}

	mov	edx, DWORD PTR [rdi+120]
	movzx	ecx, BYTE PTR broadflags
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN190@output_opc
	movzx	eax, cl
	and	al, -8
	cmp	al, 16
	jne	SHORT $LN190@output_opc

; 1507 :                   if ((CodeInfo->mem_type != MT_QWORD) && (CodeInfo->mem_type != MT_EMPTY))

	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, 7
	je	SHORT $LN189@output_opc
	cmp	eax, 192				; 000000c0H
	je	SHORT $LN189@output_opc

; 1508 :                     EmitError( INVALID_OPERAND_SIZE );

	lea	ecx, QWORD PTR [rdx+39]
	call	EmitError
$LN189@output_opc:

; 1509 :                   if ((CodeInfo->pinstr->prefix & 0xE0) == QSIZE)

	mov	rax, QWORD PTR [rdi+16]
	movzx	ecx, BYTE PTR [rax+8]
	and	cl, 224					; 000000e0H
	cmp	cl, 96					; 00000060H
	jne	SHORT $LN188@output_opc

; 1510 :                     CodeInfo->mem_type = MT_QWORD;

	mov	DWORD PTR [rdi+28], 7

; 1511 :                   else

	jmp	$LN129@output_opc
$LN188@output_opc:

; 1512 :                     EmitError( MISMATCH_IN_THE_NUMBER_OF_BROADCASTING_ELEMENTS );

	mov	ecx, 18
	call	EmitError

; 1513 :               }
; 1514 :               else if (CodeInfo->r2type == OP_XMM && (broadflags & ~EVEX_P2AAAMASK) == 0x20){ //{1to4} 

	jmp	$LN129@output_opc
$LN190@output_opc:
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN185@output_opc
	movzx	eax, cl
	and	al, -8
	cmp	al, dl
	jne	SHORT $LN185@output_opc

; 1515 :                   if ((CodeInfo->mem_type != MT_DWORD) && (CodeInfo->mem_type != MT_EMPTY))

	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, ebp
	je	SHORT $LN184@output_opc
	cmp	eax, 192				; 000000c0H
	je	SHORT $LN184@output_opc

; 1516 :                     EmitError( INVALID_OPERAND_SIZE );

	lea	ecx, QWORD PTR [rdx+39]
	call	EmitError
$LN184@output_opc:

; 1517 :                   if ((CodeInfo->pinstr->prefix & 0xE0) == DSIZE)

	mov	rax, QWORD PTR [rdi+16]
	movzx	ecx, BYTE PTR [rax+8]
	and	cl, 224					; 000000e0H
	cmp	cl, 64					; 00000040H
	jne	SHORT $LN183@output_opc

; 1518 :                     CodeInfo->mem_type = MT_DWORD;

	mov	DWORD PTR [rdi+28], ebp

; 1519 :                   else

	jmp	$LN129@output_opc
$LN183@output_opc:

; 1520 :                     EmitError( MISMATCH_IN_THE_NUMBER_OF_BROADCASTING_ELEMENTS );

	mov	ecx, 18
	call	EmitError

; 1521 :               }
; 1522 :               else if (CodeInfo->r2type == OP_YMM && (broadflags & ~EVEX_P2AAAMASK) == 0x20){ //{1to4}

	jmp	$LN129@output_opc
$LN185@output_opc:
	cmp	edx, 128				; 00000080H
	jne	SHORT $LN180@output_opc
	movzx	eax, cl
	and	al, -8
	cmp	al, 32					; 00000020H
	jne	SHORT $LN180@output_opc

; 1523 :                   if ((CodeInfo->mem_type != MT_QWORD) && (CodeInfo->mem_type != MT_EMPTY))

	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, 7
	je	SHORT $LN179@output_opc
	cmp	eax, 192				; 000000c0H
	je	SHORT $LN179@output_opc

; 1524 :                     EmitError( INVALID_OPERAND_SIZE );

	lea	ecx, QWORD PTR [rdx-57]
	call	EmitError
$LN179@output_opc:

; 1525 :                   if ((CodeInfo->pinstr->prefix & 0xE0) == QSIZE){

	mov	rax, QWORD PTR [rdi+16]
	movzx	ecx, BYTE PTR [rax+8]
	and	cl, 224					; 000000e0H
	cmp	cl, 96					; 00000060H
	jne	SHORT $LN178@output_opc

; 1526 :                     CodeInfo->mem_type = MT_QWORD;
; 1527 :                     CodeInfo->evex_p2 |= 0x20;

	or	BYTE PTR [rdi+139], 32			; 00000020H
	mov	DWORD PTR [rdi+28], 7

; 1528 :                   }
; 1529 :                   else 

	jmp	$LN129@output_opc
$LN178@output_opc:

; 1530 :                     EmitError( MISMATCH_IN_THE_NUMBER_OF_BROADCASTING_ELEMENTS );

	mov	ecx, 18
	call	EmitError

; 1531 :               }
; 1532 :               else if (CodeInfo->r2type == OP_YMM && (broadflags & ~EVEX_P2AAAMASK) == 0x30){ //{1to8}

	jmp	$LN129@output_opc
$LN180@output_opc:
	cmp	edx, 128				; 00000080H
	jne	SHORT $LN175@output_opc
	mov	al, cl
	and	eax, -8
	cmp	al, 48					; 00000030H
	jne	SHORT $LN175@output_opc

; 1533 :                 if ((CodeInfo->mem_type != MT_DWORD) && (CodeInfo->mem_type != MT_EMPTY) &&
; 1534 :                     (CodeInfo->mem_type != MT_OWORD)){

	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, ebp
	je	SHORT $LN174@output_opc
	cmp	eax, 192				; 000000c0H
	je	SHORT $LN174@output_opc
	cmp	eax, 15
	je	SHORT $LN174@output_opc

; 1535 :                   EmitError(INVALID_OPERAND_SIZE);

	lea	ecx, QWORD PTR [rdx-57]
	call	EmitError
$LN174@output_opc:

; 1536 :                   }
; 1537 :                   if ((CodeInfo->pinstr->prefix & 0xE0) == DSIZE){

	mov	rax, QWORD PTR [rdi+16]
	movzx	ecx, BYTE PTR [rax+8]
	and	cl, 224					; 000000e0H
	cmp	cl, 64					; 00000040H
	jne	SHORT $LN173@output_opc

; 1538 :                     CodeInfo->mem_type = MT_DWORD;
; 1539 :                     CodeInfo->evex_p2 |= 0x20;

	or	BYTE PTR [rdi+139], 32			; 00000020H
	mov	DWORD PTR [rdi+28], ebp

; 1540 :                   }
; 1541 :                   else 

	jmp	$LN129@output_opc
$LN173@output_opc:

; 1542 :                     EmitError( MISMATCH_IN_THE_NUMBER_OF_BROADCASTING_ELEMENTS );

	mov	ecx, 18
	call	EmitError

; 1543 :               }
; 1544 :               else if ( CodeInfo->r2type == OP_ZMM && (broadflags & ~EVEX_P2AAAMASK) == 0x30){ //{1to8}

	jmp	$LN129@output_opc
$LN175@output_opc:
	cmp	edx, 256				; 00000100H
	jne	SHORT $LN170@output_opc
	mov	al, cl
	and	eax, -8
	cmp	al, 48					; 00000030H
	jne	SHORT $LN170@output_opc

; 1545 :                   if ((CodeInfo->pinstr->prefix & 0xE0) == QSIZE){

	mov	rax, QWORD PTR [rdi+16]
	movzx	ecx, BYTE PTR [rax+8]
	and	cl, 224					; 000000e0H
	cmp	cl, 96					; 00000060H
	jne	SHORT $LN169@output_opc

; 1546 :                     CodeInfo->mem_type = MT_QWORD;
; 1547 :                     CodeInfo->evex_p2 |= 0x40;

	or	BYTE PTR [rdi+139], 64			; 00000040H
	mov	DWORD PTR [rdi+28], 7

; 1548 :                   }
; 1549 :                   else 

	jmp	$LN129@output_opc
$LN169@output_opc:

; 1550 :                     EmitError( MISMATCH_IN_THE_NUMBER_OF_BROADCASTING_ELEMENTS );

	mov	ecx, 18
	call	EmitError

; 1551 :               }
; 1552 :               else if (CodeInfo->r2type == OP_ZMM && (broadflags & ~EVEX_P2AAAMASK) == 0x40){ //{1to16}

	jmp	$LN129@output_opc
$LN170@output_opc:
	cmp	edx, 256				; 00000100H
	jne	$LN129@output_opc
	and	cl, -8
	cmp	cl, 64					; 00000040H
	jne	$LN129@output_opc

; 1553 :                   if ((CodeInfo->pinstr->prefix & 0xE0) == DSIZE){

	mov	rax, QWORD PTR [rdi+16]
	movzx	ecx, BYTE PTR [rax+8]
	and	cl, 224					; 000000e0H
	cmp	cl, 64					; 00000040H
	jne	SHORT $LN165@output_opc

; 1554 :                     CodeInfo->mem_type = MT_DWORD;
; 1555 :                     CodeInfo->evex_p2 |= 0x40;

	or	BYTE PTR [rdi+139], cl
	mov	DWORD PTR [rdi+28], ebp

; 1556 :                   }
; 1557 :                   else 

	jmp	$LN129@output_opc
$LN165@output_opc:

; 1558 :                     EmitError(MISMATCH_IN_THE_NUMBER_OF_BROADCASTING_ELEMENTS);

	mov	ecx, 18
	call	EmitError

; 1559 :               }
; 1560 :             }
; 1561 :               else{   //check all for size

	jmp	$LN129@output_opc
$LN195@output_opc:

; 1562 :                 if (CodeInfo->r2type == OP_YMM){              

	mov	eax, DWORD PTR [rdi+120]
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN162@output_opc

; 1563 :                   if (CodeInfo->mem_type == MT_YMMWORD || (CodeInfo->mem_type == MT_EMPTY)){

	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, 31
	je	SHORT $LN160@output_opc
	cmp	eax, 192				; 000000c0H
	je	SHORT $LN160@output_opc

; 1567 :                   }
; 1568 :                   
; 1569 :                   else{
; 1570 :                     if (CodeInfo->token < T_VPSLLD && CodeInfo->token > T_VPRORVQ)

	mov	eax, DWORD PTR [rdi+24]
	cmp	eax, 2100				; 00000834H
	jge	$LN134@output_opc
	cmp	eax, 1576				; 00000628H
	jle	$LN134@output_opc

; 1571 :                     EmitError(INVALID_OPERAND_SIZE);

	mov	ecx, 71					; 00000047H
	call	EmitError
	jmp	$LN134@output_opc
$LN160@output_opc:

; 1564 :                     CodeInfo->evex_p2 |= 0x20;
; 1565 :                     if ((CodeInfo->opnd[OPND3].data32h > 0x20)||(CodeInfo->opnd[OPND3].data32h > ~0x20)) 

	mov	eax, DWORD PTR [rdi+92]
	or	BYTE PTR [rdi+139], 32			; 00000020H
	cmp	eax, 32					; 00000020H
	jg	SHORT $LN158@output_opc
	cmp	eax, -33				; ffffffffffffffdfH
	jle	$LN134@output_opc
$LN158@output_opc:

; 1566 :                       CodeInfo->tuple = TRUE;  

	mov	BYTE PTR [rdi+140], 1

; 1572 :                     }

	jmp	$LN134@output_opc
$LN162@output_opc:

; 1573 :                 }
; 1574 :                 else if (CodeInfo->r2type == OP_XMM){

	cmp	eax, 32					; 00000020H
	jne	$LN154@output_opc

; 1575 :                   if ((CodeInfo->mem_type == MT_OWORD || CodeInfo->mem_type == MT_EMPTY)){

	mov	ecx, DWORD PTR [rdi+28]
	cmp	ecx, 15
	je	SHORT $LN152@output_opc
	cmp	ecx, 192				; 000000c0H
	je	SHORT $LN152@output_opc

; 1578 :                   }
; 1579 :                   else if ((CodeInfo->token >= T_VCMPEQSD || CodeInfo->token <= T_VCMPTRUE_USSD) &&
; 1580 :                     (CodeInfo->mem_type == MT_QWORD)){

	mov	eax, DWORD PTR [rdi+24]
	cmp	eax, 1873				; 00000751H
	jge	SHORT $LN147@output_opc
	cmp	eax, 1904				; 00000770H
	jg	SHORT $LN148@output_opc
$LN147@output_opc:
	cmp	ecx, 7
	jne	SHORT $LN148@output_opc

; 1581 :                       if ((CodeInfo->opnd[OPND3].data32h > 8)||(CodeInfo->opnd[OPND3].data32h > ~8))

	mov	eax, DWORD PTR [rdi+92]
	cmp	eax, 8
	jg	SHORT $LN145@output_opc
	cmp	eax, -9
	jle	$LN134@output_opc
$LN145@output_opc:

; 1582 :                       CodeInfo->tuple = TRUE;

	mov	BYTE PTR [rdi+140], 1

; 1583 :                   }
; 1584 :                   else if ((CodeInfo->token >= T_VCMPEQSS || CodeInfo->token <= T_VCMPTRUE_USSS) &&

	jmp	SHORT $LN134@output_opc
$LN148@output_opc:

; 1585 :                     (CodeInfo->mem_type == MT_DWORD)){

	cmp	eax, 1905				; 00000771H
	jge	SHORT $LN142@output_opc
	cmp	eax, 1936				; 00000790H
	jg	SHORT $LN143@output_opc
$LN142@output_opc:
	cmp	ecx, ebp
	jne	SHORT $LN143@output_opc

; 1586 :                       if ((CodeInfo->opnd[OPND3].data32h > 4)||(CodeInfo->opnd[OPND3].data32h > ~4))

	mov	eax, DWORD PTR [rdi+92]
	cmp	eax, 4
	jg	SHORT $LN140@output_opc
	cmp	eax, -5
	jle	SHORT $LN134@output_opc
$LN140@output_opc:

; 1587 :                       CodeInfo->tuple = TRUE;

	mov	BYTE PTR [rdi+140], 1

; 1588 :                   }
; 1589 :                   else EmitError(INVALID_OPERAND_SIZE);

	jmp	SHORT $LN134@output_opc
$LN143@output_opc:
	mov	ecx, 71					; 00000047H
	call	EmitError
	jmp	SHORT $LN134@output_opc
$LN152@output_opc:

; 1576 :                     if ((CodeInfo->opnd[OPND3].data32h > 0x10)||(CodeInfo->opnd[OPND3].data32h > ~0x10))

	mov	eax, DWORD PTR [rdi+92]
	cmp	eax, 16
	jg	SHORT $LN150@output_opc
	cmp	eax, -17
	jle	SHORT $LN134@output_opc
$LN150@output_opc:

; 1577 :                       CodeInfo->tuple = TRUE;

	mov	BYTE PTR [rdi+140], 1

; 1590 :                 }
; 1591 :                 else if (CodeInfo->r2type == OP_ZMM){

	jmp	SHORT $LN134@output_opc
$LN154@output_opc:
	cmp	eax, 256				; 00000100H
	jne	SHORT $LN134@output_opc

; 1592 :                   if (CodeInfo->mem_type == MT_ZMMWORD || (CodeInfo->mem_type == MT_EMPTY)){

	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN135@output_opc
	cmp	eax, 192				; 000000c0H
	jne	SHORT $LN134@output_opc
$LN135@output_opc:

; 1593 :                     CodeInfo->evex_p2 |= 0x40;
; 1594 :                     if ((CodeInfo->opnd[OPND3].data32h > 0x40)||(CodeInfo->opnd[OPND3].data32h > ~0x40))

	mov	eax, DWORD PTR [rdi+92]
	or	BYTE PTR [rdi+139], 64			; 00000040H
	cmp	eax, 64					; 00000040H
	jg	SHORT $LN133@output_opc
	cmp	eax, -65				; ffffffffffffffbfH
	jle	SHORT $LN134@output_opc
$LN133@output_opc:

; 1595 :                       CodeInfo->tuple = TRUE;

	mov	BYTE PTR [rdi+140], 1
$LN134@output_opc:

; 1596 :                   }
; 1597 :                 }
; 1598 :                 if (CodeInfo->opnd[OPND3].data32l != -1){

	mov	ecx, DWORD PTR [rdi+88]
	cmp	ecx, -1
	je	SHORT $LN129@output_opc

; 1599 :                   if ((CodeInfo->r2type == OP_YMM) && (CodeInfo->opnd[OPND3].type != OP_ZMM)){

	cmp	DWORD PTR [rdi+120], 128		; 00000080H
	jne	SHORT $LN129@output_opc
	cmp	DWORD PTR [rdi+80], 256			; 00000100H
	je	SHORT $LN129@output_opc

; 1600 :                     if ((CodeInfo->token >= T_VCMPEQPD) && (CodeInfo->token <= T_VCMPTRUE_USSS))

	mov	eax, DWORD PTR [rdi+24]
	cmp	eax, 1809				; 00000711H
	jl	SHORT $LN130@output_opc
	cmp	eax, 1936				; 00000790H
	jg	SHORT $LN130@output_opc

; 1601 :                       CodeInfo->evex_p2 |= 0x40;

	or	BYTE PTR [rdi+139], 64			; 00000040H
$LN130@output_opc:

; 1602 :                     if (CodeInfo->opnd[OPND3].data32l >= 0x20)

	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN129@output_opc

; 1603 :                       CodeInfo->tuple = TRUE;

	mov	BYTE PTR [rdi+140], 1
$LN129@output_opc:

; 1604 :                   }
; 1605 :                 }
; 1606 :               }
; 1607 :               if (CodeInfo->evex_sae){

	movzx	eax, BYTE PTR [rdi+141]
	test	al, al
	je	SHORT $LN128@output_opc

; 1608 :                 CodeInfo->evex_p2 &= ~0x70;     //clear bites 6,5,4

	and	BYTE PTR [rdi+139], 143			; 0000008fH
	movzx	ecx, BYTE PTR [rdi+139]

; 1609 :                 c = CodeInfo->evex_sae - 0x10;  //subtract SAE to get a proper decorator

	sub	al, 16

; 1610 :                 /* here we need to test for corect use of decorators  
; 1611 :                  * if it is {sae} c will be zero, in that case we need to add 0x10 to c
; 1612 :                  * if we need {sae}
; 1613 :                 */  
; 1614 :                 if (c == 0) c = 0x10;

	movzx	eax, al
	mov	r8d, 16
	cmove	eax, r8d

; 1615 :                 CodeInfo->evex_p2 |= c;

	or	cl, al
	mov	BYTE PTR [rdi+139], cl
$LN128@output_opc:

; 1616 :               }
; 1617 :                 if (CodeInfo->r2type == OP_YMM) CodeInfo->evex_p2 |= EVEX_P2LMASK;

	mov	r8d, DWORD PTR [rdi+120]
	cmp	r8d, 128				; 00000080H
	jne	SHORT $LN126@output_opc
	or	BYTE PTR [rdi+139], 32			; 00000020H
	jmp	SHORT $LN124@output_opc
$LN126@output_opc:

; 1618 :                 else if (CodeInfo->opnd[OPND3].type == OP_ZMM)CodeInfo->evex_p2 |= EVEX_P2L1MASK; 

	cmp	DWORD PTR [rdi+80], 256			; 00000100H
	jne	SHORT $LN124@output_opc
	or	BYTE PTR [rdi+139], 64			; 00000040H
$LN124@output_opc:

; 1619 :                 if ((CodeInfo->token >= T_VPGATHERDD && CodeInfo->token <= T_VGATHERQPS) ||
; 1620 :                     CodeInfo->token == T_VCVTPD2DQ){

	mov	ecx, DWORD PTR [rdi+24]
	cmp	ecx, 1365				; 00000555H
	jl	SHORT $LN121@output_opc
	cmp	ecx, 1372				; 0000055cH
	jle	SHORT $LN122@output_opc
$LN121@output_opc:
	cmp	ecx, 1349				; 00000545H
	jne	SHORT $LN118@output_opc
$LN122@output_opc:

; 1621 :                   CodeInfo->evex_p2 &= ~EVEX_P2L1MASK;
; 1622 :                   CodeInfo->evex_p2 &= ~EVEX_P2LMASK;

	and	BYTE PTR [rdi+139], 159			; 0000009fH

; 1623 :                   if (CodeInfo->r1type == OP_YMM) CodeInfo->evex_p2 |= EVEX_P2LMASK;

	mov	edx, DWORD PTR [rdi+116]
	movzx	eax, BYTE PTR [rdi+139]
	cmp	edx, 128				; 00000080H
	jne	SHORT $LN120@output_opc
	or	al, 32					; 00000020H
	mov	BYTE PTR [rdi+139], al
	jmp	SHORT $LN118@output_opc
$LN120@output_opc:

; 1624 :                   else if (CodeInfo->r1type == OP_ZMM) CodeInfo->evex_p2 |= EVEX_P2L1MASK;

	cmp	edx, 256				; 00000100H
	jne	SHORT $LN118@output_opc
	or	al, 64					; 00000040H
	mov	BYTE PTR [rdi+139], al
$LN118@output_opc:

; 1625 :                   }
; 1626 :                   if ((CodeInfo->token == T_VEXTRACTPS)||      // 1914    1932
; 1627 :                     //(CodeInfo->token == T_VMOVHPS)||(CodeInfo->token == T_VMOVLPS)||           // 1933    1935  
; 1628 :                     (CodeInfo->token == T_VCVTSD2USI)||(CodeInfo->token == T_VCVTSS2USI)||     // 1598    1599
; 1629 :                     (CodeInfo->token >= T_VMOVHPD)&&(CodeInfo->token <= T_VMOVSS))              // 1936    1937

	cmp	ecx, 1965				; 000007adH
	je	SHORT $LN116@output_opc
	cmp	ecx, 1644				; 0000066cH
	je	SHORT $LN116@output_opc
	cmp	ecx, 1645				; 0000066dH
	je	SHORT $LN116@output_opc
	cmp	ecx, 1983				; 000007bfH
	jl	SHORT $LN117@output_opc
	cmp	ecx, 1988				; 000007c4H
	jg	SHORT $LN117@output_opc
$LN116@output_opc:

; 1630 :                     CodeInfo->evex_p2 &= ~EVEX_P2L1MASK;

	and	BYTE PTR [rdi+139], 191			; 000000bfH
$LN117@output_opc:

; 1631 :                 if (CodeInfo->evex_flag){

	cmp	BYTE PTR [rdi+136], r13b
	je	$LN98@output_opc

; 1632 :                   if (CodeInfo->vexregop){

	movzx	eax, BYTE PTR [rdi+128]
	test	al, al
	je	SHORT $LN114@output_opc

; 1633 :                     if (CodeInfo->vexregop <= 16) CodeInfo->evex_p2 |= EVEX_P2VMASK;

	cmp	al, 16
	ja	SHORT $LN113@output_opc
	or	BYTE PTR [rdi+139], 8
	jmp	SHORT $LN111@output_opc
$LN113@output_opc:

; 1634 :                     else CodeInfo->evex_p2 &= ~EVEX_P2VMASK;

	and	BYTE PTR [rdi+139], 247			; 000000f7H

; 1635 :                   }
; 1636 :                   else CodeInfo->evex_p2 |= EVEX_P2VMASK;

	jmp	SHORT $LN111@output_opc
$LN114@output_opc:
	or	BYTE PTR [rdi+139], 8
$LN111@output_opc:

; 1637 :                   CodeInfo->tuple = TRUE;

	mov	BYTE PTR [rdi+140], 1

; 1638 :                   CodeInfo->evex_p2 |= decoflags;

	movzx	eax, BYTE PTR decoflags
	or	BYTE PTR [rdi+139], al

; 1639 :                   if (CodeInfo->token == T_VCVTDQ2PD || CodeInfo->token == T_VCVTPS2PD ||
; 1640 :                     CodeInfo->token == T_VMOVDQA || CodeInfo->token == T_VMOVDQU ||
; 1641 :                     CodeInfo->token == T_VCVTUDQ2PD){ 

	cmp	ecx, 1947				; 0000079bH
	movzx	eax, BYTE PTR [rdi+139]
	je	SHORT $LN109@output_opc
	cmp	ecx, 1951				; 0000079fH
	je	SHORT $LN109@output_opc
	cmp	ecx, 1979				; 000007bbH
	je	SHORT $LN109@output_opc
	cmp	ecx, 1980				; 000007bcH
	je	SHORT $LN109@output_opc
	cmp	ecx, 1483				; 000005cbH
	jne	SHORT $LN105@output_opc
$LN109@output_opc:

; 1642 :                   //__debugbreak();
; 1643 :                      CodeInfo->evex_p2 &= ~EVEX_P2LMASK;
; 1644 :                      CodeInfo->evex_p2 &= ~EVEX_P2L1MASK;
; 1645 :                     if (CodeInfo->r1type == OP_YMM || CodeInfo->r2type == OP_YMM) 

	mov	ecx, DWORD PTR [rdi+116]
	and	al, 159					; 0000009fH
	cmp	ecx, 128				; 00000080H
	mov	BYTE PTR [rdi+139], al
	je	SHORT $LN107@output_opc
	cmp	r8d, 128				; 00000080H
	je	SHORT $LN107@output_opc

; 1647 :                     else if (CodeInfo->r1type == OP_ZMM || CodeInfo->r2type == OP_ZMM)

	cmp	ecx, 256				; 00000100H
	je	SHORT $LN104@output_opc
	cmp	r8d, 256				; 00000100H
	jne	SHORT $LN105@output_opc
$LN104@output_opc:

; 1648 :                       CodeInfo->evex_p2 |= EVEX_P2L1MASK;

	or	al, 64					; 00000040H

; 1649 :                     //__debugbreak();
; 1650 :                     //if (CodeInfo->r1type == OP_YMM)CodeInfo->evex_p2 |= EVEX_P2LMASK;
; 1651 :                     //else if (CodeInfo->r1type == OP_ZMM)CodeInfo->evex_p2 |= EVEX_P2L1MASK;
; 1652 :                   }
; 1653 :                   OutputCodeByte(CodeInfo->evex_p2);

	movzx	ecx, al
	mov	BYTE PTR [rdi+139], al
	call	OutputByte
	jmp	$LN98@output_opc
$LN107@output_opc:

; 1646 :                       CodeInfo->evex_p2 |= EVEX_P2LMASK;

	or	al, 32					; 00000020H
	mov	BYTE PTR [rdi+139], al
$LN105@output_opc:

; 1649 :                     //__debugbreak();
; 1650 :                     //if (CodeInfo->r1type == OP_YMM)CodeInfo->evex_p2 |= EVEX_P2LMASK;
; 1651 :                     //else if (CodeInfo->r1type == OP_ZMM)CodeInfo->evex_p2 |= EVEX_P2L1MASK;
; 1652 :                   }
; 1653 :                   OutputCodeByte(CodeInfo->evex_p2);

	mov	cl, BYTE PTR [rdi+139]
	call	OutputByte
	jmp	$LN98@output_opc
$LN652@output_opc:

; 597  :                   goto outC5;    // go handle 0xC5 instruction
; 598  : 
; 599  : 					/* John: Validate 3 operand vex form */
; 600  : 				  if (CodeInfo->opnd[OPND3].type == OP_NONE && CodeInfo->vexregop == 0 &&
; 601  : 					  (vex_flags[CodeInfo->token - VEX_START] & VX_NND) == 0 &&
; 602  : 					  (vex_flags[CodeInfo->token - VEX_START] & VX_NMEM) == 0)

	cmp	DWORD PTR [rdi+80], r13d
	jne	SHORT $LN651@output_opc
	cmp	BYTE PTR [rdi+128], r13b
	jne	SHORT $LN651@output_opc
	movzx	ecx, BYTE PTR vex_flags[rcx+r15-1304]
	test	cl, 2
	jne	SHORT $LN651@output_opc
	test	cl, 16
	jne	SHORT $LN651@output_opc

; 603  : 				  {
; 604  : 					  EmitError(INVALID_INSTRUCTION_OPERANDS);

	mov	ecx, 49					; 00000031H
	call	EmitError
$LN651@output_opc:

; 605  : 				  }
; 606  :                   OutputCodeByte(0xC4);

	mov	cl, 196					; 000000c4H
	call	OutputByte

; 607  :                 }
; 608  : 				else

	jmp	SHORT $LN650@output_opc
$LN653@output_opc:

; 609  : 				{
; 610  : 					/* John: Validate 3 operand vex form */
; 611  : 					if (CodeInfo->opnd[OPND3].type == OP_NONE && CodeInfo->vexregop == 0 && 
; 612  : 						(vex_flags[CodeInfo->token - VEX_START] & VX_NND)==0 && 
; 613  : 						(vex_flags[CodeInfo->token - VEX_START] & VX_NMEM)==0)

	cmp	DWORD PTR [rdi+80], r13d
	jne	SHORT $LN649@output_opc
	cmp	BYTE PTR [rdi+128], r13b
	jne	SHORT $LN649@output_opc
	movzx	ecx, BYTE PTR vex_flags[rcx+r15-1304]
	test	cl, 2
	jne	SHORT $LN649@output_opc
	test	cl, 16
	jne	SHORT $LN649@output_opc

; 614  : 					{
; 615  : 						EmitError(INVALID_INSTRUCTION_OPERANDS);

	mov	ecx, 49					; 00000031H
	call	EmitError
$LN649@output_opc:

; 616  : 					}
; 617  : 					OutputCodeByte(0xC4);

	mov	cl, 196					; 000000c4H
	call	OutputByte
$LN650@output_opc:

; 618  : 				}
; 619  :               if (CodeInfo->opnd[OPND1].type == OP_YMM || CodeInfo->opnd[OPND2].type == OP_YMM)

	cmp	DWORD PTR [rdi+32], 128			; 00000080H
	je	SHORT $LN647@output_opc
	cmp	DWORD PTR [rdi+56], 128			; 00000080H
	je	SHORT $LN647@output_opc

; 621  :               else
; 622  :                 lbyte &= ~0x04;

	and	sil, 251				; 000000fbH
	jmp	SHORT $LN646@output_opc
$LN647@output_opc:

; 620  :                  lbyte |= 0x04;

	or	sil, 4
$LN646@output_opc:

; 623  :               CodeInfo->tuple = 0;
; 624  :               /* This fixes AVX  REX_W wide 32 <-> 64 instructions third byte bit W*/
; 625  :               if ((CodeInfo->token >= T_VADDPD && CodeInfo->token <= T_VMOVAPS) ||
; 626  : 				  (CodeInfo->token == T_VMOVD)||(CodeInfo->token == T_VPANDN)||
; 627  :           (CodeInfo->token == T_VPAND))

	mov	eax, DWORD PTR [rdi+24]
	mov	BYTE PTR [rdi+140], r13b
	cmp	eax, 1777				; 000006f1H
	jl	SHORT $LN643@output_opc
	cmp	eax, 1976				; 000007b8H
	jle	SHORT $LN644@output_opc
$LN643@output_opc:
	cmp	eax, 1977				; 000007b9H
	je	SHORT $LN644@output_opc
	cmp	eax, 2017				; 000007e1H
	je	SHORT $LN644@output_opc
	cmp	eax, 2016				; 000007e0H
	je	SHORT $LN644@output_opc

; 629  :               else
; 630  :                 lbyte |= ((CodeInfo->pinstr->prefix) >> 8 & 0x80); // set only W bit if 64 bit

	mov	rax, QWORD PTR [rdi+16]
	movzx	ecx, BYTE PTR [rax+9]
	and	cl, 128					; 00000080H
	or	sil, cl
	jmp	SHORT $LN642@output_opc
$LN644@output_opc:

; 628  :                 lbyte &= ~EVEX_P1WMASK;        //make sure it is not set if WIG

	and	sil, 127				; 0000007fH
$LN642@output_opc:

; 631  :             }
; 632  :             switch ( ins->byte1_info ) {                     

	movzx	edx, BYTE PTR [r12+1]
	lea	eax, DWORD PTR [rdx-23]
	cmp	eax, 6
	ja	SHORT $LN637@output_opc
	cdqe
	mov	ecx, DWORD PTR $LN836@output_opc[r15+rax*4]
	add	rcx, r15
	jmp	rcx
$LN639@output_opc:

; 633  :             case F_0F38:                                     
; 634  :             case F_660F38:                                   
; 635  :             case F_F20F38:
; 636  :             case F_F30F38:
; 637  :                 byte1 |= 0x02;

	mov	bl, 2

; 638  :                 break;

	jmp	SHORT $LN636@output_opc
$LN638@output_opc:

; 639  :             case F_0F3A:
; 640  :             case F_660F3A:
; 641  :             case F_F20F3A:
; 642  :                 byte1 |= 0x03;

	mov	bl, bpl

; 643  :                 break;

	jmp	SHORT $LN636@output_opc
$LN637@output_opc:

; 644  :             default:
; 645  :                 if ( ins->byte1_info >= F_0F )

	movzx	ebx, bl
	cmp	dl, 16
	mov	eax, 1
	cmovae	ebx, eax
$LN636@output_opc:

; 646  :                     byte1 |= 0x01;
; 647  :             }
; 648  :               byte1 |= ((CodeInfo->prefix.rex & REX_B) ? 0 : 0x20);/*  REX_B regno 0-7 <-> 8-15 of ModR/M or SIB base */
; 649  :               byte1 |= ((CodeInfo->prefix.rex & REX_X) ? 0 : 0x40);/*  REX_X regno 0-7 <-> 8-15 of SIB index */
; 650  :               byte1 |= ((CodeInfo->prefix.rex & REX_R) ? 0 : 0x80);/*  REX_R regno 0-7 <-> 8-15 of ModR/M REG */

	movzx	eax, BYTE PTR [rdi+8]

; 651  :               //this still needs to be checked
; 652  :               if ((CodeInfo->evex_flag)&& (CodeInfo->reg2 <= 15))byte1 |= EVEX_P0R1MASK;

	movzx	r10d, BYTE PTR [rdi+136]
	shl	al, 5
	not	al
	and	al, 224					; 000000e0H
	or	bl, al
	test	r10b, r10b
	je	SHORT $LN635@output_opc
	cmp	BYTE PTR [rdi+110], 15
	ja	SHORT $LN635@output_opc
	or	bl, 16
$LN635@output_opc:

; 653  :             /* second byte is RXBm mmmm of 3 byte  VEX prefix */    /*  REX_W wide 32 <-> 64 */
; 654  :                if ((CodeInfo->evex_flag) && (CodeInfo->token != T_VEXTRACTPS)){ 

	test	r10b, r10b
	je	$LN613@output_opc
	mov	r9d, DWORD PTR [rdi+24]
	cmp	r9d, 1965				; 000007adH
	je	$LN613@output_opc

; 655  :                  if ((CodeInfo->opnd[OPND1].type & OP_M_ANY) || (CodeInfo->opnd[OPND2].type & OP_M_ANY) ||
; 656  :                    (CodeInfo->opnd[OPND3].type & OP_M_ANY)) CodeInfo->tuple = TRUE;

	mov	edx, DWORD PTR [rdi+32]
	mov	r8d, edx
	and	r8d, -8388608				; ffffffffff800000H
	jne	SHORT $LN632@output_opc
	test	DWORD PTR [rdi+56], -8388608		; ffffffffff800000H
	jne	SHORT $LN632@output_opc
	test	DWORD PTR [rdi+80], -8388608		; ffffffffff800000H
	je	SHORT $LN633@output_opc
$LN632@output_opc:
	mov	BYTE PTR [rdi+140], 1
$LN633@output_opc:

; 657  :                  lbyte &= ~EVEX_P1WMASK;
; 658  :                  lbyte |= ((CodeInfo->pinstr->prefix) >> 8 & 0x80);

	mov	rax, QWORD PTR [rdi+16]
	xor	sil, BYTE PTR [rax+9]
	and	sil, 127				; 0000007fH
	xor	sil, BYTE PTR [rax+9]

; 659  :                  if ((CodeInfo->opnd[OPND2].type == OP_M64)||(CodeInfo->opnd[OPND1].type == OP_M64)) 

	mov	eax, DWORD PTR [rdi+56]
	cmp	eax, 67108864				; 04000000H
	je	SHORT $LN630@output_opc
	cmp	edx, 67108864				; 04000000H
	jne	SHORT $LN631@output_opc
$LN630@output_opc:

; 660  :                    lbyte |= EVEX_P1WMASK;

	or	sil, 128				; 00000080H
$LN631@output_opc:

; 661  :                  if ((CodeInfo->opnd[OPND2].type == OP_R32) || (CodeInfo->opnd[OPND2].type == OP_EAX)||
; 662  :                     (CodeInfo->opnd[OPND1].type == OP_R32) || (CodeInfo->opnd[OPND1].type == OP_EAX)){

	cmp	eax, 4
	je	SHORT $LN628@output_opc
	cmp	eax, 516				; 00000204H
	je	SHORT $LN628@output_opc
	cmp	edx, 4
	je	SHORT $LN628@output_opc
	cmp	edx, 516				; 00000204H
	jne	SHORT $LN629@output_opc
$LN628@output_opc:

; 663  :                    lbyte &= ~EVEX_P1WMASK;

	and	sil, 127				; 0000007fH
$LN629@output_opc:

; 664  :                  }
; 665  :                  if (((CodeInfo->opnd[OPND1].type & OP_M_ANY) == 0)&& (CodeInfo->token != T_VCVTPS2PD)&&
; 666  :                    (CodeInfo->token != T_VCVTPS2PH) && CodeInfo->token != T_VPMOVQB && CodeInfo->token != T_VPEXTRQ) {

	test	r8d, r8d
	jne	$LN613@output_opc
	cmp	r9d, 1951				; 0000079fH
	je	$LN613@output_opc
	cmp	r9d, 1469				; 000005bdH
	je	SHORT $LN613@output_opc
	cmp	r9d, 1617				; 00000651H
	je	SHORT $LN613@output_opc
	cmp	r9d, 2039				; 000007f7H
	je	SHORT $LN613@output_opc

; 667  :                    if (CodeInfo->reg1 <= 15)

	movzx	eax, BYTE PTR [rdi+109]
	cmp	al, 15
	ja	SHORT $LN626@output_opc

; 668  :                      byte1 |= EVEX_P0R1MASK;     

	or	bl, 16

; 669  :                    else

	jmp	SHORT $LN625@output_opc
$LN626@output_opc:

; 670  :                      byte1 &= ~EVEX_P0R1MASK;

	and	bl, 239					; 000000efH
$LN625@output_opc:

; 671  :                    if ((CodeInfo->reg1 <= 7) || (CodeInfo->reg1 >= 16 && CodeInfo->reg1 <= 23))

	cmp	al, 7
	jbe	SHORT $LN623@output_opc
	cmp	al, 16
	jb	SHORT $LN624@output_opc
	cmp	al, 23
	jbe	SHORT $LN623@output_opc
$LN624@output_opc:

; 673  :                    else
; 674  :                      byte1 &= ~EVEX_P0RMASK;

	and	bl, 127					; 0000007fH
	jmp	SHORT $LN622@output_opc
$LN623@output_opc:

; 672  :                      byte1 |= EVEX_P0RMASK;

	or	bl, 128					; 00000080H
$LN622@output_opc:

; 675  :                    if (CodeInfo->reg3 != 0xff)     

	movzx	eax, BYTE PTR [rdi+111]
	cmp	al, 255					; 000000ffH
	je	SHORT $LN621@output_opc

; 676  :                      rn = CodeInfo->reg3;

	movzx	eax, al
	jmp	SHORT $LN618@output_opc
$LN621@output_opc:

; 677  :                    else if (CodeInfo->basereg != 0xff)

	movzx	eax, BYTE PTR [rdi+113]
	cmp	al, 255					; 000000ffH
	je	SHORT $LN619@output_opc

; 678  :                      rn = CodeInfo->basereg;

	movzx	eax, al
	jmp	SHORT $LN618@output_opc
$LN619@output_opc:

; 679  :                    else rn = CodeInfo->reg2;

	movzx	eax, BYTE PTR [rdi+110]
$LN618@output_opc:

; 680  :                    if (rn > 15){

	cmp	eax, 15
	jle	SHORT $LN617@output_opc

; 681  :                      rn -= 15;

	sub	eax, 15

; 682  :                      byte1 &= ~EVEX_P0XMASK;

	and	bl, 191					; 000000bfH
$LN617@output_opc:

; 683  :                    }
; 684  :                    if (CodeInfo->token >= T_VFMADD132PD && CodeInfo->token <= T_VFNMSUB231SS);

	cmp	r9d, 1404				; 0000057cH
	jl	SHORT $LN616@output_opc
	cmp	r9d, 1463				; 000005b7H
	jle	SHORT $LN613@output_opc
$LN616@output_opc:

; 685  :                    else if (rn <= 7)byte1 |= EVEX_P0BMASK;

	cmp	eax, 7
	jg	SHORT $LN614@output_opc
	or	bl, 32					; 00000020H
	jmp	SHORT $LN613@output_opc
$LN614@output_opc:

; 686  :                    else byte1 &= ~EVEX_P0BMASK;

	and	bl, 223					; 000000dfH
$LN613@output_opc:

; 687  :                    
; 688  :                  }
; 689  :                }
; 690  :             if (CodeInfo->token >= T_VPSCATTERDD && CodeInfo->token <= T_VSCATTERQPD){

	mov	ecx, DWORD PTR [rdi+24]
	cmp	ecx, 1389				; 0000056dH
	jl	SHORT $LN606@output_opc
	cmp	ecx, 1396				; 00000574H
	jg	SHORT $LN606@output_opc

; 691  :               if (CodeInfo->reg2 <= 15) byte1 |= EVEX_P0R1MASK;

	movzx	eax, BYTE PTR [rdi+110]
	cmp	al, 15
	ja	SHORT $LN611@output_opc
	or	bl, 16
	jmp	SHORT $LN610@output_opc
$LN611@output_opc:

; 692  :               else byte1 &= ~EVEX_P0R1MASK;

	and	bl, 239					; 000000efH
$LN610@output_opc:

; 693  :               if (CodeInfo->reg2 <= 7 )  byte1 |= EVEX_P0RMASK;

	cmp	al, 7
	ja	SHORT $LN609@output_opc
	or	bl, 128					; 00000080H
	jmp	SHORT $LN606@output_opc
$LN609@output_opc:

; 694  :               else if (CodeInfo->reg2 >= 16 && CodeInfo->reg2 <= 23) byte1 |= EVEX_P0RMASK;

	cmp	al, 16
	jb	SHORT $LN607@output_opc
	cmp	al, 23
	ja	SHORT $LN607@output_opc
	or	bl, 128					; 00000080H
	jmp	SHORT $LN606@output_opc
$LN607@output_opc:

; 695  :               else byte1 &= ~EVEX_P0RMASK;

	and	bl, 127					; 0000007fH
$LN606@output_opc:

; 696  :             }
; 697  :               if (((CodeInfo->token == T_VMOVHPS)||(CodeInfo->token == T_VMOVLPS)) && (CodeInfo->opnd[OPND2].type & OP_XMM)){

	cmp	ecx, 1984				; 000007c0H
	je	SHORT $LN604@output_opc
	cmp	ecx, 1986				; 000007c2H
	jne	SHORT $LN605@output_opc
$LN604@output_opc:
	test	BYTE PTR [rdi+56], 32			; 00000020H
	je	SHORT $LN605@output_opc

; 698  :                 if ((CodeInfo->reg2 > 7))

	cmp	BYTE PTR [rdi+110], 7
	jbe	SHORT $LN603@output_opc

; 699  :                     byte1 &= ~EVEX_P0RMASK;

	and	bl, 127					; 0000007fH
$LN603@output_opc:

; 700  :                     lbyte &= ~EVEX_P1WMASK;

	and	sil, 127				; 0000007fH
$LN605@output_opc:

; 701  :               }
; 702  :               if ((CodeInfo->token == T_VMOVNTPD)||(CodeInfo->token == T_VMOVNTPS)||                                
; 703  :                 (CodeInfo->token >= T_VPMOVQB)&&(CodeInfo->token <= T_VPMOVUSDW)){

	cmp	ecx, 1993				; 000007c9H
	je	SHORT $LN601@output_opc
	cmp	ecx, 1994				; 000007caH
	je	SHORT $LN601@output_opc
	cmp	ecx, 1617				; 00000651H
	jl	SHORT $LN591@output_opc
	cmp	ecx, 1631				; 0000065fH
	jg	SHORT $LN591@output_opc
$LN601@output_opc:

; 704  :                 if (CodeInfo->reg2 <= 15) byte1 |= EVEX_P0R1MASK;

	movzx	eax, BYTE PTR [rdi+110]
	cmp	al, 15
	ja	SHORT $LN600@output_opc
	or	bl, 16
	jmp	SHORT $LN599@output_opc
$LN600@output_opc:

; 705  :                 else byte1 &= ~EVEX_P0R1MASK;

	and	bl, 239					; 000000efH
$LN599@output_opc:

; 706  :                 if ((CodeInfo->reg2 <= 7) || (CodeInfo->reg2 >= 16 && CodeInfo->reg2 <= 23))

	cmp	al, 7
	jbe	SHORT $LN597@output_opc
	cmp	al, 16
	jb	SHORT $LN598@output_opc
	cmp	al, 23
	jbe	SHORT $LN597@output_opc
$LN598@output_opc:

; 708  :                 else byte1 &= ~EVEX_P0RMASK;

	and	bl, 127					; 0000007fH
	jmp	SHORT $LN596@output_opc
$LN597@output_opc:

; 707  :                   byte1 |= EVEX_P0RMASK;

	or	bl, 128					; 00000080H
$LN596@output_opc:

; 709  :                 if (CodeInfo->reg1 <= 15) byte1 |= EVEX_P0XMASK;

	movzx	eax, BYTE PTR [rdi+109]
	cmp	al, 15
	ja	SHORT $LN595@output_opc
	or	bl, 64					; 00000040H
	jmp	SHORT $LN594@output_opc
$LN595@output_opc:

; 710  :                 else byte1 &= ~EVEX_P0XMASK;

	and	bl, 191					; 000000bfH
$LN594@output_opc:

; 711  :                 if ((CodeInfo->reg1 <= 7) || (CodeInfo->reg1 >= 16 && CodeInfo->reg1 <= 23))

	cmp	al, 7
	jbe	SHORT $LN592@output_opc
	cmp	al, 16
	jb	SHORT $LN593@output_opc
	cmp	al, 23
	jbe	SHORT $LN592@output_opc
$LN593@output_opc:

; 713  :                 else byte1 &= ~EVEX_P0BMASK;

	and	bl, 223					; 000000dfH
	jmp	SHORT $LN591@output_opc
$LN592@output_opc:

; 712  :                   byte1 |= EVEX_P0BMASK;

	or	bl, 32					; 00000020H
$LN591@output_opc:

; 714  :               }
; 715  :               if (CodeInfo->opnd[OPND2].type == OP_I8){

	cmp	DWORD PTR [rdi+56], 131072		; 00020000H
	jne	SHORT $LN579@output_opc

; 716  :                 if ((CodeInfo->token >= T_VPSLLW) && (CodeInfo->token <= T_VPSRLQ) ||
; 717  :                   (CodeInfo->token >= T_VPSLLVD) && (CodeInfo->token <= T_VPSRLVW)){

	cmp	ecx, 2099				; 00000833H
	jl	SHORT $LN587@output_opc
	cmp	ecx, 2107				; 0000083bH
	jle	SHORT $LN588@output_opc
$LN587@output_opc:
	cmp	ecx, 1566				; 0000061eH
	jl	SHORT $LN579@output_opc
	cmp	ecx, 1582				; 0000062eH
	jg	SHORT $LN579@output_opc
$LN588@output_opc:

; 718  :                   byte1 |= EVEX_P0R1MASK;
; 719  :                   byte1 |= EVEX_P0RMASK;
; 720  :                   if ((CodeInfo->opnd[OPND1].type == OP_R64) || (CodeInfo->opnd[OPND1].type == OP_RAX) ||
; 721  :                     (CodeInfo->opnd[OPND1].type == OP_R32) || (CodeInfo->opnd[OPND1].type == OP_EAX)){

	mov	eax, DWORD PTR [rdi+32]
	or	bl, 144					; 00000090H
	cmp	eax, 8
	je	SHORT $LN585@output_opc
	cmp	eax, 520				; 00000208H
	je	SHORT $LN585@output_opc
	cmp	eax, 4
	je	SHORT $LN585@output_opc
	cmp	eax, 516				; 00000204H
	je	SHORT $LN585@output_opc

; 733  :                     }
; 734  :                   }
; 735  :                   else if (!CodeInfo->evex_flag)

	test	r10b, r10b
	jne	SHORT $LN579@output_opc

; 736  :                     byte1 &= ~EVEX_P0R1MASK;

	and	bl, 239					; 000000efH
	jmp	SHORT $LN579@output_opc
$LN585@output_opc:

; 722  :                       if (CodeInfo->basereg != 0xFF){

	movzx	eax, BYTE PTR [rdi+113]
	cmp	al, 255					; 000000ffH
	je	SHORT $LN582@output_opc

; 723  :                         if (CodeInfo->basereg <= 7)   

	cmp	al, 7
	ja	SHORT $LN583@output_opc

; 724  :                           byte1 |= EVEX_P0BMASK;

	or	bl, 32					; 00000020H

; 725  :                         else

	jmp	SHORT $LN582@output_opc
$LN583@output_opc:

; 726  :                           byte1 &= ~EVEX_P0BMASK;

	and	bl, 223					; 000000dfH
$LN582@output_opc:

; 727  :                       }
; 728  :                     if (CodeInfo->indexreg != 0xFF){

	movzx	eax, BYTE PTR [rdi+112]
	cmp	al, 255					; 000000ffH
	je	SHORT $LN579@output_opc

; 729  :                       if (CodeInfo->indexreg <= 7)   

	cmp	al, 7
	ja	SHORT $LN580@output_opc

; 730  :                         byte1 |= EVEX_P0XMASK;

	or	bl, 64					; 00000040H

; 731  :                       else

	jmp	SHORT $LN579@output_opc
$LN580@output_opc:

; 732  :                         byte1 &= ~EVEX_P0XMASK;

	and	bl, 191					; 000000bfH
$LN579@output_opc:

; 737  :                 }
; 738  :               }
; 739  :               if ((CodeInfo->token == T_VRNDSCALEPD) || (CodeInfo->token == T_VRNDSCALEPS)){

	cmp	ecx, 1656				; 00000678H
	je	SHORT $LN575@output_opc
	cmp	ecx, 1657				; 00000679H
	jne	SHORT $LN570@output_opc
$LN575@output_opc:

; 740  :                 if (((CodeInfo->r2type &= OP_R64)||(CodeInfo->r2type &= OP_R32))&&
; 741  :                   (CodeInfo->vexconst)) { 

	and	DWORD PTR [rdi+120], 8
	jne	SHORT $LN573@output_opc
	test	r13b, r13b
	mov	DWORD PTR [rdi+120], r13d
	je	SHORT $LN570@output_opc
$LN573@output_opc:
	cmp	DWORD PTR [rdi+124], r13d
	je	SHORT $LN570@output_opc

; 742  :                   if (CodeInfo->indexreg != 0xff){

	cmp	BYTE PTR [rdi+112], 255			; 000000ffH
	je	SHORT $LN570@output_opc

; 743  :                     if (CodeInfo->reg1 <= 7)

	cmp	BYTE PTR [rdi+109], 7
	ja	SHORT $LN571@output_opc

; 744  :                       byte1 |= EVEX_P0XMASK;

	or	bl, 64					; 00000040H

; 745  :                     else

	jmp	SHORT $LN570@output_opc
$LN571@output_opc:

; 746  :                       byte1 &= ~EVEX_P0XMASK;

	and	bl, 191					; 000000bfH
$LN570@output_opc:

; 747  :                   }
; 748  :                 }
; 749  :               }
; 750  :               if (((CodeInfo->token == T_VEXTRACTF32x8)||(CodeInfo->token == T_VEXTRACTF64x4))
; 751  :                 && !(CodeInfo->opnd[OPND1].type & OP_M_ANY)) {

	cmp	ecx, 1329				; 00000531H
	je	SHORT $LN568@output_opc
	cmp	ecx, 1330				; 00000532H
	jne	SHORT $LN561@output_opc
$LN568@output_opc:
	test	DWORD PTR [rdi+32], -8388608		; ffffffffff800000H
	jne	SHORT $LN561@output_opc

; 752  :                 if (CodeInfo->reg2 <= 15) byte1 |= EVEX_P0R1MASK;

	movzx	eax, BYTE PTR [rdi+110]
	cmp	al, 15
	ja	SHORT $LN567@output_opc
	or	bl, 16
	jmp	SHORT $LN566@output_opc
$LN567@output_opc:

; 753  :                 else byte1 &= ~EVEX_P0R1MASK;

	and	bl, 239					; 000000efH
$LN566@output_opc:

; 754  :                 if ((CodeInfo->reg2 <= 7) || (CodeInfo->reg2 >= 16 && CodeInfo->reg2 <= 23))

	cmp	al, 7
	jbe	SHORT $LN564@output_opc
	cmp	al, 16
	jb	SHORT $LN565@output_opc
	cmp	al, 23
	jbe	SHORT $LN564@output_opc
$LN565@output_opc:

; 756  :                 else
; 757  :                   byte1 &= ~EVEX_P0RMASK;

	and	bl, 127					; 0000007fH
	jmp	SHORT $LN563@output_opc
$LN564@output_opc:

; 755  :                   byte1 |= EVEX_P0RMASK;

	or	bl, 128					; 00000080H
$LN563@output_opc:

; 758  :                 if (CodeInfo->reg1 <= 15) byte1 |= EVEX_P0XMASK;

	cmp	BYTE PTR [rdi+109], 15
	ja	SHORT $LN562@output_opc
	or	bl, 64					; 00000040H
	jmp	SHORT $LN561@output_opc
$LN562@output_opc:

; 759  :                 else byte1 &= ~EVEX_P0XMASK;

	and	bl, 191					; 000000bfH
$LN561@output_opc:

; 760  :               }
; 761  :               if (((CodeInfo->token >= T_BEXTR)&&(CodeInfo->token <= T_SHRX)||(CodeInfo->token == T_BZHI)&&
; 762  :                 (CodeInfo->indexreg != 0xFF))){

	cmp	ecx, 1719				; 000006b7H
	jl	SHORT $LN558@output_opc
	cmp	ecx, 1722				; 000006baH
	jle	SHORT $LN559@output_opc
$LN558@output_opc:
	cmp	ecx, 1726				; 000006beH
	jne	SHORT $LN557@output_opc
	cmp	BYTE PTR [rdi+112], 255			; 000000ffH
	je	SHORT $LN557@output_opc
$LN559@output_opc:

; 763  :                 byte1 &= 0xE3;

	and	bl, 227					; 000000e3H

; 764  :                 if (CodeInfo->indexreg > 0x07)byte1 &= ~0x10;

	cmp	BYTE PTR [rdi+112], 7
	jbe	SHORT $LN557@output_opc
	and	bl, 239					; 000000efH
$LN557@output_opc:

; 765  :               }
; 766  :               if (CodeInfo->token == T_VCVTPH2PS || CodeInfo->token == T_VCVTPD2UDQ||
; 767  :                 CodeInfo->token == T_VCVTPD2DQ || CodeInfo->token == T_VCVTDQ2PD){

	cmp	ecx, 1468				; 000005bcH
	je	SHORT $LN555@output_opc
	cmp	ecx, 1350				; 00000546H
	je	SHORT $LN555@output_opc
	cmp	ecx, 1349				; 00000545H
	je	SHORT $LN555@output_opc
	cmp	ecx, 1947				; 0000079bH
	jne	SHORT $LN549@output_opc
$LN555@output_opc:

; 768  :                 if ((CodeInfo->reg1 <= 7) || (CodeInfo->reg1 >= 16 && CodeInfo->reg1 <= 23))

	movzx	eax, BYTE PTR [rdi+109]
	cmp	al, 7
	jbe	SHORT $LN553@output_opc
	cmp	al, 16
	jb	SHORT $LN554@output_opc
	cmp	al, 23
	jbe	SHORT $LN553@output_opc
$LN554@output_opc:

; 770  :                 else
; 771  :                   byte1 &= ~EVEX_P0RMASK;

	and	bl, 127					; 0000007fH
	jmp	SHORT $LN552@output_opc
$LN553@output_opc:

; 769  :                   byte1 |= EVEX_P0RMASK;

	or	bl, 128					; 00000080H
$LN552@output_opc:

; 772  :                 if (CodeInfo->reg2 <= 15) byte1 |= EVEX_P0XMASK;

	cmp	BYTE PTR [rdi+110], 15
	ja	SHORT $LN551@output_opc
	or	bl, 64					; 00000040H
	jmp	SHORT $LN550@output_opc
$LN551@output_opc:

; 773  :                 else byte1 &= ~EVEX_P0XMASK;

	and	bl, 191					; 000000bfH
$LN550@output_opc:

; 774  :                 if (CodeInfo->token == T_VCVTDQ2PD || CodeInfo->token == T_VCVTPS2PD)

	cmp	ecx, 1947				; 0000079bH
	je	SHORT $LN548@output_opc
	cmp	ecx, 1951				; 0000079fH
	jne	SHORT $LN549@output_opc
$LN548@output_opc:

; 775  :                 CodeInfo->evex_p2 &= ~EVEX_P2L1MASK;

	and	BYTE PTR [rdi+139], 191			; 000000bfH
$LN549@output_opc:

; 776  :               }
; 777  :               if (CodeInfo->token == T_VPCMPEQQ || CodeInfo->token == T_VPCMPEQD ||
; 778  :                   CodeInfo->token == T_VPCMPEQW || CodeInfo->token == T_VPCMPEQB){

	cmp	ecx, 2028				; 000007ecH
	je	SHORT $LN546@output_opc
	cmp	ecx, 2027				; 000007ebH
	je	SHORT $LN546@output_opc
	cmp	ecx, 2026				; 000007eaH
	je	SHORT $LN546@output_opc
	cmp	ecx, 2025				; 000007e9H
	jne	SHORT $LN545@output_opc
$LN546@output_opc:

; 779  :                   if (CodeInfo->r1type == OP_ZMM)

	cmp	DWORD PTR [rdi+116], 256		; 00000100H
	jne	SHORT $LN545@output_opc

; 780  :                     EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN545@output_opc:

; 781  :                 } 
; 782  :               OutputCodeByte( byte1 );

	movzx	ecx, bl
	call	OutputByte

; 783  :               //ovde treba proveriti sada je 91 a treba biti D1
; 784  :               if (CodeInfo->opnd[OPND2].type == OP_I8){

	cmp	DWORD PTR [rdi+56], 131072		; 00020000H
	jne	SHORT $LN544@output_opc

; 785  :                 if ((CodeInfo->token >= T_VPSLLW) && (CodeInfo->token <= T_VPSRLQ) ||
; 786  :                   (CodeInfo->token >= T_VPSLLVD) && (CodeInfo->token <= T_VPSRLVW)) {

	mov	eax, DWORD PTR [rdi+24]
	cmp	eax, 2099				; 00000833H
	jl	SHORT $LN541@output_opc
	cmp	eax, 2107				; 0000083bH
	jle	SHORT $LN542@output_opc
$LN541@output_opc:
	cmp	eax, 1566				; 0000061eH
	jl	SHORT $LN539@output_opc
	cmp	eax, 1582				; 0000062eH
	jg	SHORT $LN539@output_opc
$LN542@output_opc:

; 787  :                   c = CodeInfo->reg1;
; 788  :                   lbyte &= 0x0f;
; 789  :                   c = (c << 3);

	movzx	eax, BYTE PTR [rdi+109]
	and	sil, 11
	shl	al, 3

; 790  :                   c = ~c;

	not	al

; 791  :                   c &= EVEX_P1VVVV;

	and	al, 120					; 00000078H
	or	sil, al

; 792  :                   lbyte |= c;
; 793  :                   lbyte |= 4;

	or	sil, 4

; 794  :                   if (ins->byte1_info == F_660F) lbyte |= 0x1;

	cmp	BYTE PTR [r12+1], 18
	jne	SHORT $LN540@output_opc
	or	sil, 1
$LN540@output_opc:

; 795  :                   CodeInfo->tuple = TRUE;

	mov	BYTE PTR [rdi+140], 1

; 796  :                 }
; 797  :               }
; 798  :             else

	jmp	SHORT $LN539@output_opc
$LN544@output_opc:

; 799  :             lbyte |= ( ( CodeInfo->prefix.rex & REX_W ) ? 0x80 : 0 );

	movzx	eax, BYTE PTR [rdi+8]
	and	al, 248					; 000000f8H
	shl	al, 4
	or	sil, al
$LN539@output_opc:

; 800  :             /* KSHIFTLW KSHIFTLQ KSHIFTRW KSHIFTRQ */
; 801  :             if ((CodeInfo->token == T_KSHIFTLW) || (CodeInfo->token == T_KSHIFTLQ)||
; 802  :               (CodeInfo->token == T_KSHIFTRW) || (CodeInfo->token == T_KSHIFTRQ)){

	mov	eax, DWORD PTR [rdi+24]
	cmp	eax, 1766				; 000006e6H
	je	SHORT $LN537@output_opc
	cmp	eax, 1768				; 000006e8H
	je	SHORT $LN537@output_opc
	cmp	eax, 1770				; 000006eaH
	je	SHORT $LN537@output_opc
	cmp	eax, 1772				; 000006ecH
	jne	SHORT $LN538@output_opc
$LN537@output_opc:

; 803  :               lbyte |= 0x80;

	or	sil, 128				; 00000080H
$LN538@output_opc:

; 804  :             }
; 805  :             //HJWasm13.1 VPGATHERDD, VPGATHERQD, VPGATHERDQ, VPGATHERQQ
; 806  :             if (CodeInfo->token >= T_VPGATHERDD && CodeInfo->token <= T_VGATHERQPS){

	cmp	eax, 1365				; 00000555H
	jl	SHORT $LN531@output_opc
	cmp	eax, 1372				; 0000055cH
	jg	SHORT $LN531@output_opc

; 807  :               if ((CodeInfo->opnd[OPND3].type != CodeInfo->opnd[OPND1].type)&& 
; 808  :                 (CodeInfo->evex_flag == 0))

	mov	eax, DWORD PTR [rdi+32]
	cmp	DWORD PTR [rdi+80], eax
	je	SHORT $LN535@output_opc
	cmp	BYTE PTR [rdi+136], r13b
	jne	SHORT $LN535@output_opc

; 809  :                 EmitError( INVALID_USE_OF_REGISTER );

	mov	ecx, 170				; 000000aaH
	call	EmitError
$LN535@output_opc:

; 810  :               CodeInfo->tuple = TRUE;       
; 811  :               lbyte &= ~EVEX_P1VVVV;      // clear EVEX_P1VVVV

	and	sil, 135				; 00000087H

; 812  :               if (CodeInfo->evex_flag){

	cmp	BYTE PTR [rdi+136], r13b
	mov	BYTE PTR [rdi+140], 1
	je	SHORT $LN534@output_opc

; 813  :                 c = EVEX_P1VVVV;          // set all to ones : VVVV = 1111, we are not using it

	mov	al, 120					; 00000078H

; 814  :               }
; 815  :               else {

	jmp	SHORT $LN533@output_opc
$LN534@output_opc:

; 816  :                 c = CodeInfo->reg3 + 1;
; 817  :                 c = ((16 - c) << 3);

	mov	eax, 15
	sub	al, BYTE PTR [rdi+111]
	shl	al, 3
$LN533@output_opc:

; 818  :                 //c = ~c;
; 819  :               }
; 820  :               c &= EVEX_P1VVVV;

	and	al, 120					; 00000078H

; 821  :               lbyte |= c;  

	or	sil, al

; 822  :               if (CodeInfo->indextype == OP_YMM)    lbyte |= 4;

	cmp	DWORD PTR [rdi+132], 128		; 00000080H
	jne	SHORT $LN532@output_opc
	or	sil, 4
$LN532@output_opc:

; 823  :               if (( CodeInfo->prefix.rex & REX_W )) lbyte |= 0x80;

	test	BYTE PTR [rdi+8], 8
	je	SHORT $LN531@output_opc
	or	sil, 128				; 00000080H
$LN531@output_opc:

; 824  : 
; 825  :             }
; 826  :             if ((CodeInfo->token >= T_KADDB) && (CodeInfo->token <= T_KUNPCKDQ)) {       //here pay atention

	mov	ecx, DWORD PTR [rdi+24]
	cmp	ecx, 1730				; 000006c2H
	jl	SHORT $LN530@output_opc
	cmp	ecx, 1756				; 000006dcH
	jg	SHORT $LN530@output_opc

; 827  :               /* third byte W vvvv Lpp   */
; 828  :               c = CodeInfo->reg2;
; 829  :               lbyte &= 0xc0;
; 830  :               c = (c << 3);

	movzx	eax, BYTE PTR [rdi+110]
	and	sil, 196				; 000000c4H
	shl	al, 3

; 831  :               c = ~c;

	not	al

; 832  :               c &= EVEX_P1VVVV;

	and	al, 120					; 00000078H
	or	al, sil

; 833  :               lbyte |= c;
; 834  :               lbyte |= 4;    

	or	al, 4

; 835  :                if (ins->byte1_info == F_660F) lbyte |= 0x1;

	cmp	BYTE PTR [r12+1], 18
	mov	sil, al
	jne	SHORT $LN523@output_opc
	or	sil, 1

; 836  :             }
; 837  :             else if ((CodeInfo->token >= T_KNOTB) && (CodeInfo->token <= T_KORTESTQ)) {

	jmp	SHORT $LN523@output_opc
$LN530@output_opc:
	cmp	ecx, 1757				; 000006ddH
	jl	SHORT $LN527@output_opc
	cmp	ecx, 1764				; 000006e4H
	jg	SHORT $LN527@output_opc

; 838  :               /*  1 1111 0pp */
; 839  :               /*  R vvvv Lpp */
; 840  :               lbyte = 0xF8;
; 841  :               if (ins->byte1_info == F_660F) lbyte |= 0x01;

	cmp	BYTE PTR [r12+1], 18
	mov	sil, 248				; 000000f8H
	jne	SHORT $LN523@output_opc
	mov	sil, 249				; 000000f9H

; 842  :             }
; 843  :             else if ((CodeInfo->token >= T_KMOVB) && (CodeInfo->token <= T_KMOVW)) {

	jmp	SHORT $LN523@output_opc
$LN527@output_opc:
	cmp	ecx, 1773				; 000006edH
	jl	SHORT $LN523@output_opc
	cmp	ecx, 1776				; 000006f0H
	jg	SHORT $LN523@output_opc

; 844  :               /*  1 1111 0pp */
; 845  :               /*  R vvvv Lpp */
; 846  :               lbyte = 0xF8;
; 847  :               if (ins->byte1_info == F_660F) lbyte |= 0x01;

	cmp	BYTE PTR [r12+1], 18
	mov	esi, 251				; 000000fbH
	mov	eax, 249				; 000000f9H
	cmove	esi, eax
$LN523@output_opc:

; 848  :               else  lbyte |= 0x3;
; 849  :             }
; 850  :             if (CodeInfo->token < T_VCVTDQ2PD && CodeInfo->token > T_VCVTTSS2SI){

	cmp	ecx, 1947				; 0000079bH
	jge	SHORT $LN520@output_opc
	cmp	ecx, 1958				; 000007a6H
	jle	SHORT $LN520@output_opc

; 851  :               if (CodeInfo->reg2 > 15)lbyte |= EVEX_P1WMASK;

	cmp	BYTE PTR [rdi+110], 15
	jbe	SHORT $LN520@output_opc
	or	sil, 128				; 00000080H
$LN520@output_opc:

; 852  :             }
; 853  :             if ( CodeInfo->token == T_VPSCATTERQQ ||      //CodeInfo->token == T_VPSCATTERDQ ||
; 854  :               CodeInfo->token == T_VSCATTERDPD || CodeInfo->token == T_VSCATTERQPD){

	cmp	ecx, 1392				; 00000570H
	je	SHORT $LN518@output_opc
	cmp	ecx, 1394				; 00000572H
	je	SHORT $LN518@output_opc
	cmp	ecx, 1396				; 00000574H
	jne	SHORT $LN519@output_opc
$LN518@output_opc:

; 855  :               lbyte |= 0x80;

	or	sil, 128				; 00000080H
$LN519@output_opc:

; 856  :             }
; 857  :             /* if broadflags are prezent W = 0  in WVVVV1PP */
; 858  :               if (CodeInfo->token == T_VPGATHERDQ || CodeInfo->token == T_VPGATHERQQ ||
; 859  :                 CodeInfo->token == T_VGATHERDPD || CodeInfo->token == T_VGATHERQPD){

	cmp	ecx, 1367				; 00000557H
	je	SHORT $LN516@output_opc
	cmp	ecx, 1368				; 00000558H
	je	SHORT $LN516@output_opc
	cmp	ecx, 1369				; 00000559H
	je	SHORT $LN516@output_opc
	cmp	ecx, 1370				; 0000055aH
	jne	SHORT $LN517@output_opc
$LN516@output_opc:

; 860  :                   lbyte |= EVEX_P1WMASK;

	or	sil, 128				; 00000080H
$LN517@output_opc:

; 861  :                 }
; 862  :             if (((CodeInfo->token <= T_VCOMPRESSPS))||((CodeInfo->token >= T_VCVTDQ2PD) &&
; 863  :               (CodeInfo->token <= T_VCVTTSS2SI))|| (CodeInfo->token == T_VCVTPD2DQ)) 

	cmp	ecx, 1479				; 000005c7H
	jle	SHORT $LN514@output_opc
	cmp	ecx, 1947				; 0000079bH
	jl	SHORT $LN513@output_opc
	cmp	ecx, 1958				; 000007a6H
	jle	SHORT $LN514@output_opc
$LN513@output_opc:
	cmp	ecx, 1349				; 00000545H
	jne	SHORT $LN515@output_opc
$LN514@output_opc:

; 864  :               CodeInfo->evex_p2 &= ~EVEX_P1PPMASK;

	and	BYTE PTR [rdi+139], 252			; 000000fcH
$LN515@output_opc:

; 865  :             if ((CodeInfo->token == T_VPCMPB) || (CodeInfo->token == T_VPCMPUB ))lbyte &= ~EVEX_P1WMASK;

	cmp	ecx, 1493				; 000005d5H
	je	SHORT $LN511@output_opc
	cmp	ecx, 1494				; 000005d6H
	jne	SHORT $LN512@output_opc
$LN511@output_opc:
	and	sil, 127				; 0000007fH
$LN512@output_opc:

; 866  :             if (CodeInfo->evex_flag){

	cmp	BYTE PTR [rdi+136], r13b
	je	SHORT $LN507@output_opc

; 867  :               if ((CodeInfo->opnd[OPND2].type == OP_M64) || (CodeInfo->opnd[OPND1].type == OP_M64))

	mov	eax, DWORD PTR [rdi+56]
	cmp	eax, 67108864				; 04000000H
	je	SHORT $LN508@output_opc
	cmp	DWORD PTR [rdi+32], 67108864		; 04000000H
	jne	SHORT $LN509@output_opc
$LN508@output_opc:

; 868  :                 lbyte |= EVEX_P1WMASK;

	or	sil, 128				; 00000080H
$LN509@output_opc:

; 869  :                if ((CodeInfo->opnd[OPND2].type == OP_R32) || (CodeInfo->opnd[OPND2].type == OP_EAX) ||
; 870  :                  (CodeInfo->opnd[OPND1].type == OP_R32) || (CodeInfo->opnd[OPND1].type == OP_EAX)){

	cmp	eax, 4
	je	SHORT $LN506@output_opc
	cmp	eax, 516				; 00000204H
	je	SHORT $LN506@output_opc
	mov	eax, DWORD PTR [rdi+32]
	cmp	eax, 4
	je	SHORT $LN506@output_opc
	cmp	eax, 516				; 00000204H
	jne	SHORT $LN507@output_opc
$LN506@output_opc:

; 871  :                  lbyte &= ~EVEX_P1WMASK;

	and	sil, 127				; 0000007fH
$LN507@output_opc:

; 872  :                }
; 873  :              }
; 874  :             if (CodeInfo->token == T_VMOVHPS || CodeInfo->token == T_VMOVLPS || CodeInfo->token == T_VCVTPS2PD ||
; 875  :                 CodeInfo->token == T_VCVTPH2PS || CodeInfo->token == T_VCVTPS2PD ||
; 876  :               CodeInfo->token == T_VPMOVQB || CodeInfo->token == T_VPMOVSQB ||
; 877  :               CodeInfo->token == T_VPMOVUSQB || CodeInfo->token == T_VGATHERQPS ||
; 878  :               CodeInfo->token == T_VPGATHERQD || CodeInfo->token == T_VGATHERDPS){  

	cmp	ecx, 1984				; 000007c0H
	je	SHORT $LN504@output_opc
	cmp	ecx, 1986				; 000007c2H
	je	SHORT $LN504@output_opc
	cmp	ecx, 1951				; 0000079fH
	je	SHORT $LN504@output_opc
	cmp	ecx, 1468				; 000005bcH
	je	SHORT $LN504@output_opc
	cmp	ecx, 1617				; 00000651H
	je	SHORT $LN504@output_opc
	cmp	ecx, 1618				; 00000652H
	je	SHORT $LN504@output_opc
	cmp	ecx, 1619				; 00000653H
	je	SHORT $LN504@output_opc
	cmp	ecx, 1372				; 0000055cH
	je	SHORT $LN504@output_opc
	cmp	ecx, 1366				; 00000556H
	je	SHORT $LN504@output_opc
	cmp	ecx, 1371				; 0000055bH
	jne	SHORT $LN505@output_opc
$LN504@output_opc:

; 879  :                   lbyte &= ~EVEX_P1WMASK;

	and	sil, 127				; 0000007fH
$LN505@output_opc:

; 880  :             }
; 881  :              if ((CodeInfo->token == T_VPSLLQ)||(CodeInfo->token == T_VPSRLQ)||
; 882  :                (CodeInfo->token == T_VPSRAQ)|| (CodeInfo->token == T_VPROLQ)||
; 883  :                (CodeInfo->token == T_VPRORQ))

	cmp	ecx, 2101				; 00000835H
	je	SHORT $LN502@output_opc
	cmp	ecx, 2107				; 0000083bH
	je	SHORT $LN502@output_opc
	cmp	ecx, 2104				; 00000838H
	je	SHORT $LN502@output_opc
	cmp	ecx, 1571				; 00000623H
	je	SHORT $LN502@output_opc
	cmp	ecx, 1575				; 00000627H
	jne	SHORT $LN503@output_opc
$LN502@output_opc:

; 884  :                lbyte |= EVEX_P1WMASK;

	or	sil, 128				; 00000080H
$LN503@output_opc:

; 885  :              if ((CodeInfo->token >= T_BEXTR)&&(CodeInfo->token <= T_SHRX)||(CodeInfo->token == T_BZHI)){

	cmp	ecx, 1719				; 000006b7H
	jl	SHORT $LN499@output_opc
	cmp	ecx, 1722				; 000006baH
	jle	SHORT $LN500@output_opc
$LN499@output_opc:
	cmp	ecx, 1726				; 000006beH
	jne	SHORT $LN492@output_opc
$LN500@output_opc:

; 886  :               c = CodeInfo->reg3;
; 887  :               lbyte &= 0x80;
; 888  :               c = (c << 3);

	movzx	esi, BYTE PTR [rdi+111]

; 889  :               c = ~c;
; 890  :               c &= EVEX_P1VVVV;
; 891  :               lbyte |= c;
; 892  : #if AMD64_SUPPORT
; 893  :               lbyte |=0x80;
; 894  : #endif
; 895  :                if (ins->byte1_info == F_660F) lbyte |= 0x1;

	mov	al, BYTE PTR [r12+1]
	shl	sil, 3
	not	sil
	and	sil, 248				; 000000f8H
	or	sil, 128				; 00000080H
	cmp	al, 18
	jne	SHORT $LN498@output_opc
	or	sil, 1
	jmp	SHORT $LN492@output_opc
$LN498@output_opc:

; 896  :                else if (ins->byte1_info == F_F30F38) lbyte |= 0x02;//SARX

	cmp	al, 28
	jne	SHORT $LN496@output_opc
	or	sil, 2
	jmp	SHORT $LN492@output_opc
$LN496@output_opc:

; 897  :                else if (ins->byte1_info == F_660F38) lbyte |= 0x01;//SHLX

	cmp	al, 25
	jne	SHORT $LN494@output_opc
	or	sil, 1
	jmp	SHORT $LN492@output_opc
$LN494@output_opc:

; 898  :                else if (ins->byte1_info == F_F20F38) lbyte |= 0x03;//SHRX

	cmp	al, 27
	jne	SHORT $LN492@output_opc
	or	sil, bpl
$LN492@output_opc:

; 899  :              }
; 900  :              if ((CodeInfo->token == T_BLSMSK)||(CodeInfo->token == T_BLSI)||
; 901  :                (CodeInfo->token == T_BLSR)){

	cmp	ecx, 1724				; 000006bcH
	je	SHORT $LN490@output_opc
	cmp	ecx, 1723				; 000006bbH
	je	SHORT $LN490@output_opc
	cmp	ecx, 1725				; 000006bdH
	jne	SHORT $LN487@output_opc
$LN490@output_opc:

; 902  :               c = CodeInfo->reg1;
; 903  :               lbyte &= 0x80;
; 904  :               c = (c << 3);

	movzx	eax, BYTE PTR [rdi+109]
	and	sil, 128				; 00000080H
	shl	al, 3

; 905  :               c = ~c;

	not	al

; 906  :               c &= EVEX_P1VVVV;

	and	al, 120					; 00000078H

; 907  :               lbyte |= c;

	or	sil, al

; 908  :                if (ins->byte1_info == F_660F) lbyte |= 0x1;

	mov	al, BYTE PTR [r12+1]
	cmp	al, 18
	jne	SHORT $LN489@output_opc
	or	sil, 1
	jmp	SHORT $LN487@output_opc
$LN489@output_opc:

; 909  :                else if (ins->byte1_info == F_F20F38) lbyte |= 0x3;

	cmp	al, 27
	jne	SHORT $LN487@output_opc
	or	sil, bpl
$LN487@output_opc:

; 910  :              }
; 911  :              if ((CodeInfo->token == T_PDEP)||(CodeInfo->token == T_PEXT)){ 

	cmp	ecx, 1727				; 000006bfH
	je	SHORT $LN485@output_opc
	cmp	ecx, 1728				; 000006c0H
	jne	SHORT $LN482@output_opc
$LN485@output_opc:

; 912  :               c = CodeInfo->reg2;
; 913  :               lbyte &= 0x80;
; 914  :               c = (c << 3);

	movzx	eax, BYTE PTR [rdi+110]
	and	sil, 128				; 00000080H
	shl	al, 3

; 915  :               c = ~c;

	not	al

; 916  :               c &= EVEX_P1VVVV;

	and	al, 120					; 00000078H

; 917  :               lbyte |= c;

	or	sil, al

; 918  :                if (ins->byte1_info == F_F20F38) lbyte |= 0x3;

	mov	al, BYTE PTR [r12+1]
	cmp	al, 27
	jne	SHORT $LN484@output_opc
	or	sil, bpl
	jmp	SHORT $LN482@output_opc
$LN484@output_opc:

; 919  :                else if (ins->byte1_info == F_F30F38)

	cmp	al, 28
	jne	SHORT $LN482@output_opc

; 920  :                  lbyte |= 0x2;

	or	sil, 2
$LN482@output_opc:

; 921  :              }
; 922  :             if (CodeInfo->token == T_RORX)lbyte |= 0x3;

	cmp	ecx, 1729				; 000006c1H
	jne	SHORT $LN481@output_opc
	or	sil, bpl
$LN481@output_opc:

; 923  :             if (CodeInfo->token == T_VEXTRACTF128){

	cmp	ecx, 1326				; 0000052eH
	jne	SHORT $LN479@output_opc

; 924  :               if (CodeInfo->r2type == OP_YMM)

	cmp	DWORD PTR [rdi+120], 128		; 00000080H
	jne	SHORT $LN479@output_opc

; 925  :                 lbyte |= 0x04;

	or	sil, 4
$LN479@output_opc:

; 926  :             }
; 927  :           /* This prevents misuse of data size,   HJWasm 2.16  */
; 928  :           switch (CodeInfo->token){

	add	ecx, -2069				; fffffffffffff7ebH
	cmp	ecx, 11
	ja	$LN456@output_opc
	movsxd	rax, ecx
	mov	ecx, DWORD PTR $LN835@output_opc[r15+rax*4]
	add	rcx, r15
	jmp	rcx
$LN476@output_opc:

; 929  :             case T_VPMOVSXBW:
; 930  :             case T_VPMOVSXWD:
; 931  :             case T_VPMOVSXDQ:
; 932  :             case T_VPMOVZXBW:
; 933  :             case T_VPMOVZXWD:
; 934  :             case T_VPMOVZXDQ:
; 935  :               if((CodeInfo->r1type == OP_XMM && (CodeInfo->r2type == OP_XMM || CodeInfo->mem_type == MT_QWORD || CodeInfo->mem_type == MT_EMPTY))||
; 936  :                  (CodeInfo->r1type == OP_YMM && (CodeInfo->r2type == OP_XMM || CodeInfo->mem_type == MT_OWORD || CodeInfo->mem_type == MT_EMPTY ))||
; 937  :                  (CodeInfo->r1type == OP_ZMM && decoflags && (CodeInfo->r2type == OP_YMM || CodeInfo->mem_type == MT_YMMWORD || CodeInfo->mem_type == MT_EMPTY)))

	mov	ecx, DWORD PTR [rdi+116]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN473@output_opc
	cmp	DWORD PTR [rdi+120], ecx
	je	SHORT $LN471@output_opc
	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, 7
	je	SHORT $LN471@output_opc
	cmp	eax, 192				; 000000c0H
	je	SHORT $LN471@output_opc
$LN473@output_opc:
	cmp	ecx, 128				; 00000080H
	jne	SHORT $LN472@output_opc
	cmp	DWORD PTR [rdi+120], 32			; 00000020H
	je	SHORT $LN471@output_opc
	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, 15
	je	SHORT $LN471@output_opc
	cmp	eax, 192				; 000000c0H
	je	SHORT $LN471@output_opc
$LN472@output_opc:
	cmp	ecx, 256				; 00000100H
	jne	SHORT $LN475@output_opc
	cmp	BYTE PTR decoflags, r13b
	je	SHORT $LN475@output_opc
	cmp	DWORD PTR [rdi+120], 128		; 00000080H
	je	SHORT $LN471@output_opc
	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, 31
	je	SHORT $LN471@output_opc
	cmp	eax, 192				; 000000c0H
	jne	SHORT $LN475@output_opc
$LN471@output_opc:

; 938  :                  lbyte &= ~EVEX_P1WMASK;  // make sure CodeInfo->evex_p1 W is not set

	and	sil, 127				; 0000007fH

; 939  :               else

	jmp	$LN456@output_opc
$LN475@output_opc:

; 940  :                 EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError

; 941  :               break;

	jmp	$LN456@output_opc
$LN469@output_opc:

; 942  :             case T_VPMOVSXBD:
; 943  :             case T_VPMOVSXWQ:
; 944  :             case T_VPMOVZXBD:
; 945  :             case T_VPMOVZXWQ:
; 946  :               if((CodeInfo->r1type == OP_XMM && (CodeInfo->r2type == OP_XMM || CodeInfo->mem_type == MT_DWORD || CodeInfo->mem_type == MT_EMPTY))||
; 947  :                  (CodeInfo->r1type == OP_YMM && (CodeInfo->r2type == OP_XMM || CodeInfo->mem_type == MT_QWORD || CodeInfo->mem_type == MT_EMPTY ))||
; 948  :                  (CodeInfo->r1type == OP_ZMM && decoflags && (CodeInfo->r2type == OP_XMM || CodeInfo->mem_type == MT_OWORD || CodeInfo->mem_type == MT_EMPTY)))

	mov	ecx, DWORD PTR [rdi+116]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN466@output_opc
	cmp	DWORD PTR [rdi+120], ecx
	je	SHORT $LN464@output_opc
	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, ebp
	je	SHORT $LN464@output_opc
	cmp	eax, 192				; 000000c0H
	je	SHORT $LN464@output_opc
$LN466@output_opc:
	cmp	ecx, 128				; 00000080H
	jne	SHORT $LN465@output_opc
	cmp	DWORD PTR [rdi+120], 32			; 00000020H
	je	SHORT $LN464@output_opc
	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, 7
	je	SHORT $LN464@output_opc
	cmp	eax, 192				; 000000c0H
	je	SHORT $LN464@output_opc
$LN465@output_opc:
	cmp	ecx, 256				; 00000100H
	jne	SHORT $LN468@output_opc
	cmp	BYTE PTR decoflags, r13b
	je	SHORT $LN468@output_opc
	cmp	DWORD PTR [rdi+120], 32			; 00000020H
	je	SHORT $LN464@output_opc
	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, 15
	je	SHORT $LN464@output_opc
	cmp	eax, 192				; 000000c0H
	jne	SHORT $LN468@output_opc
$LN464@output_opc:

; 949  :                  lbyte &= ~EVEX_P1WMASK;  // make sure CodeInfo->evex_p1 W is not set

	and	sil, 127				; 0000007fH

; 950  :               else

	jmp	SHORT $LN456@output_opc
$LN468@output_opc:

; 951  :                 EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError

; 952  :               break;

	jmp	SHORT $LN456@output_opc
$LN462@output_opc:

; 953  :             case T_VPMOVSXBQ:
; 954  :             case T_VPMOVZXBQ:
; 955  :               if((CodeInfo->r1type == OP_XMM && (CodeInfo->r2type == OP_XMM || CodeInfo->mem_type == MT_WORD || CodeInfo->mem_type == MT_EMPTY))||
; 956  :                  (CodeInfo->r1type == OP_YMM && (CodeInfo->r2type == OP_XMM || CodeInfo->mem_type == MT_DWORD || CodeInfo->mem_type == MT_EMPTY ))||
; 957  :                  (CodeInfo->r1type == OP_ZMM && decoflags && (CodeInfo->r2type == OP_XMM || CodeInfo->mem_type == MT_QWORD || CodeInfo->mem_type == MT_EMPTY)))

	mov	ecx, DWORD PTR [rdi+116]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN459@output_opc
	cmp	DWORD PTR [rdi+120], ecx
	je	SHORT $LN457@output_opc
	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, 1
	je	SHORT $LN457@output_opc
	cmp	eax, 192				; 000000c0H
	je	SHORT $LN457@output_opc
$LN459@output_opc:
	cmp	ecx, 128				; 00000080H
	jne	SHORT $LN458@output_opc
	cmp	DWORD PTR [rdi+120], 32			; 00000020H
	je	SHORT $LN457@output_opc
	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, ebp
	je	SHORT $LN457@output_opc
	cmp	eax, 192				; 000000c0H
	je	SHORT $LN457@output_opc
$LN458@output_opc:
	cmp	ecx, 256				; 00000100H
	jne	SHORT $LN461@output_opc
	cmp	BYTE PTR decoflags, r13b
	je	SHORT $LN461@output_opc
	cmp	DWORD PTR [rdi+120], 32			; 00000020H
	je	SHORT $LN457@output_opc
	mov	eax, DWORD PTR [rdi+28]
	cmp	eax, 7
	je	SHORT $LN457@output_opc
	cmp	eax, 192				; 000000c0H
	jne	SHORT $LN461@output_opc
$LN457@output_opc:

; 958  :                  lbyte &= ~EVEX_P1WMASK;  // make sure CodeInfo->evex_p1 W is not set

	and	sil, 127				; 0000007fH

; 959  :               else

	jmp	SHORT $LN456@output_opc
$LN461@output_opc:

; 960  :                 EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN456@output_opc:

; 961  :               break;
; 962  :             }
; 963  :                 //if (CodeInfo->token >= T_VPGATHERDD && CodeInfo->token <= T_VGATHERQPS){
; 964  :                 //  if (CodeInfo->r1type == OP_YMM) CodeInfo->evex_p2 |= EVEX_P2LMASK;
; 965  :                 //  else if (CodeInfo->r1type == OP_ZMM) {
; 966  :                 //    CodeInfo->evex_p2 &= ~EVEX_P2LMASK;    /* Clear first EVEX_P2LMASK because it was set before */
; 967  :                 //    CodeInfo->evex_p2 |= EVEX_P2L1MASK;
; 968  :                 //    }
; 969  :                 //  CodeInfo->tuple = TRUE;
; 970  :                 //}if (CodeInfo->token == T_VCVTPS2PH) lbyte &= ~EVEX_P1WMASK;
; 971  : 
; 972  :             if(CodeInfo->token == T_VSCATTERQPS || CodeInfo->token == T_VPSCATTERQD ||
; 973  :                CodeInfo->token == T_VCVTPS2PH || CodeInfo->token == T_VCVTPH2PS ||
; 974  :               (CodeInfo->token >= T_VPMOVQW && CodeInfo->token <= T_VPMOVUSDW))

	mov	ecx, DWORD PTR [rdi+24]
	cmp	ecx, 1395				; 00000573H
	je	SHORT $LN454@output_opc
	cmp	ecx, 1391				; 0000056fH
	je	SHORT $LN454@output_opc
	cmp	ecx, 1469				; 000005bdH
	je	SHORT $LN454@output_opc
	cmp	ecx, 1468				; 000005bcH
	je	SHORT $LN454@output_opc
	cmp	ecx, 1620				; 00000654H
	jl	SHORT $LN455@output_opc
	cmp	ecx, 1631				; 0000065fH
	jg	SHORT $LN455@output_opc
$LN454@output_opc:

; 975  :               lbyte &= ~EVEX_P1WMASK;

	and	sil, 127				; 0000007fH
$LN455@output_opc:

; 976  : 
; 977  : 			switch (CodeInfo->token) {

	cmp	ecx, 2086				; 00000826H
	jg	SHORT $LN813@output_opc
	cmp	ecx, 2086				; 00000826H
	je	SHORT $LN451@output_opc
	sub	ecx, 1339				; 0000053bH
	je	SHORT $LN451@output_opc
	sub	ecx, 671				; 0000029fH
	je	SHORT $LN451@output_opc
	cmp	ecx, 18
	je	SHORT $LN451@output_opc
	jmp	SHORT $LN450@output_opc
$LN813@output_opc:
	cmp	ecx, 2097				; 00000831H
	jl	SHORT $LN450@output_opc
	cmp	ecx, 2098				; 00000832H
	jle	SHORT $LN451@output_opc
	cmp	ecx, 2101				; 00000835H
	je	SHORT $LN451@output_opc
	cmp	ecx, 2107				; 0000083bH
	jne	SHORT $LN450@output_opc
$LN451@output_opc:

; 978  : 			case T_VPCMPEQQ:
; 979  : 			case T_VPSRLQ:
; 980  : 			case T_VPSLLQ:
; 981  : 			case T_VPSRLDQ:
; 982  : 			case T_VPSLLDQ:
; 983  : 			case T_VPMULUDQ:
; 984  : 			case T_VPERMILPD:
; 985  : 			case T_VPADDQ:
; 986  : 				if (CodeInfo->evex_flag == 0) lbyte &= ~EVEX_P1WMASK;

	cmp	BYTE PTR [rdi+136], r13b
	jne	SHORT $LN450@output_opc
	and	sil, 127				; 0000007fH
$LN450@output_opc:

; 987  : 			}
; 988  :             CodeInfo->evex_p1 = lbyte;
; 989  :             OutputCodeByte( lbyte );

	movzx	ecx, sil
	mov	BYTE PTR [rdi+138], sil
	call	OutputByte

; 990  :             //VGATHERPF0DPS
; 991  :             //VGATHERPF0QPS
; 992  :             //VGATHERPF0DPD
; 993  :             //VGATHERPF0QPD
; 994  :             if (CodeInfo->evex_flag  ){

	cmp	BYTE PTR [rdi+136], r13b
	je	$LN98@output_opc

; 995  :               CodeInfo->evex_p2 |= decoflags;

	movzx	eax, BYTE PTR decoflags

; 996  :               /*HJWasm 2.16 fixed error, replaed '&' with '==' */
; 997  :             if ((CodeInfo->r1type  == OP_ZMM)|| (CodeInfo->r2type == OP_ZMM))

	mov	edx, DWORD PTR [rdi+116]
	or	BYTE PTR [rdi+139], al
	cmp	edx, 256				; 00000100H
	movzx	eax, BYTE PTR [rdi+139]
	je	SHORT $LN447@output_opc
	mov	ecx, DWORD PTR [rdi+120]
	cmp	ecx, 256				; 00000100H
	je	SHORT $LN447@output_opc

; 999  :             else if ((CodeInfo->r1type == OP_YMM) || (CodeInfo->r2type == OP_YMM)) 

	cmp	edx, 128				; 00000080H
	je	SHORT $LN444@output_opc
	cmp	ecx, 128				; 00000080H
	jne	SHORT $LN445@output_opc
$LN444@output_opc:

; 1000 :               CodeInfo->evex_p2 |= EVEX_P2LMASK;

	or	al, 32					; 00000020H
	mov	BYTE PTR [rdi+139], al
	jmp	SHORT $LN445@output_opc
$LN447@output_opc:

; 998  :               CodeInfo->evex_p2 |= EVEX_P2L1MASK;

	or	al, 64					; 00000040H
	mov	BYTE PTR [rdi+139], al
$LN445@output_opc:

; 1001 :             //__debugbreak();
; 1002 :               /* here is Static Rounding Mode inserted */
; 1003 :             if (CodeInfo->evex_sae){

	movzx	r9d, BYTE PTR [rdi+141]
	test	r9b, r9b
	je	SHORT $LN443@output_opc

; 1004 :                 CodeInfo->evex_p2 &= ~0x70;     //clear bites 6,5,4

	and	BYTE PTR [rdi+139], 143			; 0000008fH
	movzx	edx, BYTE PTR [rdi+139]

; 1005 :                 c = CodeInfo->evex_sae - 0x10;  //subtract SAE to get a proper decorator

	movzx	eax, r9b
	sub	al, 16

; 1006 :                 /* here we need to test for corect use of decorators  
; 1007 :                  * if it is {sae} c will be zero, in that case we need to add 0x10 to c
; 1008 :                  * if we need {sae}
; 1009 :                 */   
; 1010 :                 if (c == 0) c += 0x10;

	mov	r8d, 16
	movzx	ecx, al
	cmove	ecx, r8d

; 1011 :                 CodeInfo->evex_p2 |= c;

	or	dl, cl
	mov	BYTE PTR [rdi+139], dl
$LN443@output_opc:

; 1012 :               }
; 1013 :               if (broadflags >= 0x10 && broadflags <= 0x47) CodeInfo->evex_p2 |= 0x10;

	movzx	eax, BYTE PTR broadflags
	sub	al, 16
	cmp	al, 55					; 00000037H
	ja	SHORT $LN441@output_opc
	or	BYTE PTR [rdi+139], 16
$LN441@output_opc:

; 1014 :                 if ((CodeInfo->token >= T_VCVTDQ2PD && CodeInfo->token <= T_VCVTTSS2SI)||
; 1015 :                 (CodeInfo->token == T_VCVTSD2SS)){

	mov	eax, DWORD PTR [rdi+24]
	cmp	eax, 1947				; 0000079bH
	jl	SHORT $LN438@output_opc
	cmp	eax, 1958				; 000007a6H
	jle	SHORT $LN439@output_opc
$LN438@output_opc:
	cmp	eax, 1954				; 000007a2H
	jne	SHORT $LN426@output_opc
$LN439@output_opc:

; 1016 :                   if (!CodeInfo->evex_sae)

	test	r9b, r9b
	jne	SHORT $LN437@output_opc

; 1017 :                   CodeInfo->evex_p2 &= ~0x60;   //clear bits 6 and 5

	and	BYTE PTR [rdi+139], 159			; 0000009fH
$LN437@output_opc:

; 1018 :                   if (CodeInfo->opnd[OPND1].type & OP_XMM){

	mov	eax, DWORD PTR [rdi+32]
	test	al, 32					; 00000020H
	je	SHORT $LN436@output_opc

; 1019 :                     if (CodeInfo->r2type & (OP_XMM | OP_M64 | OP_M))

	test	DWORD PTR [rdi+120], -1887436768	; 8f800020H
	jne	SHORT $LN426@output_opc

; 1020 :                       ;
; 1021 :                     else EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError

; 1022 :                   }
; 1023 :                   else if (CodeInfo->opnd[OPND1].type & OP_YMM){

	jmp	SHORT $LN426@output_opc
$LN436@output_opc:
	test	al, al
	jns	SHORT $LN432@output_opc

; 1024 :                     if (CodeInfo->r2type & (OP_XMM | OP_M128 | OP_M))

	test	DWORD PTR [rdi+120], -1887436768	; 8f800020H
	je	SHORT $LN431@output_opc

; 1025 :                       CodeInfo->evex_p2 |= EVEX_P2LMASK;

	or	BYTE PTR [rdi+139], 32			; 00000020H
	jmp	SHORT $LN426@output_opc
$LN431@output_opc:

; 1026 :                     else EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError

; 1027 :                   }
; 1028 :                   else if (CodeInfo->opnd[OPND1].type & OP_ZMM){

	jmp	SHORT $LN426@output_opc
$LN432@output_opc:
	bt	eax, 8
	jae	SHORT $LN426@output_opc

; 1029 :                     if (CodeInfo->r2type & OP_YMM | OP_M256 | OP_M)

	mov	eax, DWORD PTR [rdi+120]
	and	eax, 128				; 00000080H
	or	eax, -1619001344			; 9f800000H
	je	SHORT $LN427@output_opc

; 1030 :                       CodeInfo->evex_p2 |= EVEX_P2L1MASK;

	or	BYTE PTR [rdi+139], 64			; 00000040H
	jmp	SHORT $LN426@output_opc
$LN427@output_opc:

; 1031 :                     else EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN426@output_opc:

; 1032 :                   }
; 1033 :                 }
; 1034 :                 /* Check for proper data and index size, HJWasm 2.16 */
; 1035 :                 switch (CodeInfo->token){

	mov	eax, DWORD PTR [rdi+24]
	add	eax, -1365				; fffffffffffffaabH
	cmp	eax, 31
	ja	$LN375@output_opc
	cdqe
	movzx	eax, BYTE PTR $LN833@output_opc[r15+rax]
	mov	ecx, DWORD PTR $LN834@output_opc[r15+rax*4]
	add	rcx, r15
	jmp	rcx
$LN423@output_opc:

; 1036 :                   /*  xmmword,ymmword,zmmword  xmm1 {k1}, vm32x ; ymm1 {k1}, vm32x ; zmm1 {k1}, vm32y   */
; 1037 :                   case T_VPGATHERDQ:
; 1038 :                   case T_VGATHERDPD:
; 1039 :                     //if (CodeInfo->mem_type == MT_EMPTY || CodeInfo->mem_type == MT_DWORD);//that is good
; 1040 :                     //else if (CodeInfo->mem_type == MT_XMMWORD && CodeInfo->r1type == OP_XMM);//that is good
; 1041 :                     //else if (CodeInfo->mem_type == MT_YMMWORD && CodeInfo->r1type == OP_YMM);//that is good
; 1042 :                     //else if (CodeInfo->mem_type == MT_ZMMWORD && CodeInfo->r1type == OP_ZMM);//that is good
; 1043 :                     //else  goto error1;
; 1044 :                     if ((!CodeInfo->evex_flag)&& (CodeInfo->indextype == OP_ZMM || CodeInfo->r1type == OP_ZMM))

	movzx	eax, BYTE PTR [rdi+136]
	test	al, al
	jne	SHORT $LN422@output_opc
	cmp	DWORD PTR [rdi+132], 256		; 00000100H
	je	$error1$5933
	cmp	DWORD PTR [rdi+116], 256		; 00000100H

; 1045 :                        goto error1;

	je	$error1$5933
$LN422@output_opc:

; 1046 :                     if (!CodeInfo->evex_flag && CodeInfo->indextype == OP_XMM);

	test	al, al
	jne	SHORT $LN420@output_opc
	cmp	DWORD PTR [rdi+132], 32			; 00000020H
	je	SHORT $LN414@output_opc
$LN420@output_opc:

; 1047 :                     else if ((CodeInfo->r1type == OP_XMM || CodeInfo->r1type == OP_YMM) && 
; 1048 :                           (CodeInfo->indextype == OP_XMM)); 

	mov	eax, DWORD PTR [rdi+116]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN417@output_opc
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN418@output_opc
$LN417@output_opc:
	cmp	DWORD PTR [rdi+132], 32			; 00000020H
	je	SHORT $LN414@output_opc
$LN418@output_opc:

; 1049 :                     else if (CodeInfo->r1type == OP_ZMM && CodeInfo->indextype == OP_YMM)

	cmp	eax, 256				; 00000100H
	jne	$error1$5933
	cmp	DWORD PTR [rdi+132], 128		; 00000080H
	jne	$error1$5933
$LN414@output_opc:

; 1050 :                         ;//CodeInfo->evex_p2 |= EVEX_P2LMASK;
; 1051 :                     else  goto error1;
; 1052 :                         CodeInfo->tuple = TRUE;

	mov	BYTE PTR [rdi+140], 1

; 1053 :                     break;

	jmp	$LN375@output_opc
$LN413@output_opc:

; 1054 :                   case T_VPGATHERDD:
; 1055 :                   case T_VGATHERDPS:
; 1056 :                   case T_VPGATHERQQ:
; 1057 :                   case T_VGATHERQPD:
; 1058 :                     //if (CodeInfo->mem_type == MT_EMPTY || CodeInfo->mem_type == MT_QWORD);//that is good
; 1059 :                     //else if (CodeInfo->mem_type == MT_XMMWORD && CodeInfo->r1type == OP_XMM);//that is good
; 1060 :                     //else if (CodeInfo->mem_type == MT_YMMWORD && CodeInfo->r1type == OP_YMM);//that is good
; 1061 :                     //else if (CodeInfo->mem_type == MT_ZMMWORD && CodeInfo->r1type == OP_ZMM);//that is good
; 1062 :                     //else  goto error1;
; 1063 :                     if ((!CodeInfo->evex_flag)&& (CodeInfo->indextype == OP_ZMM || CodeInfo->r1type == OP_ZMM))

	cmp	BYTE PTR [rdi+136], r13b
	jne	SHORT $LN412@output_opc
	cmp	DWORD PTR [rdi+132], 256		; 00000100H
	je	$error1$5933
	cmp	DWORD PTR [rdi+116], 256		; 00000100H

; 1064 :                        goto error1;

	je	$error1$5933
$LN412@output_opc:

; 1065 :                       if (CodeInfo->r1type == OP_XMM && CodeInfo->indextype == OP_XMM );//that is good

	mov	eax, DWORD PTR [rdi+116]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN410@output_opc
	cmp	DWORD PTR [rdi+132], eax
	je	SHORT $LN405@output_opc
$LN410@output_opc:

; 1066 :                       else if (CodeInfo->r1type == OP_YMM && CodeInfo->indextype == OP_YMM)

	cmp	eax, 128				; 00000080H
	jne	SHORT $LN408@output_opc
	cmp	DWORD PTR [rdi+132], eax
	jne	SHORT $LN408@output_opc

; 1067 :                            CodeInfo->evex_p2 |= EVEX_P2LMASK;

	or	BYTE PTR [rdi+139], 32			; 00000020H

; 1071 :                         }
; 1072 :                       else goto error1;
; 1073 :                       CodeInfo->tuple = TRUE;

	mov	BYTE PTR [rdi+140], 1

; 1074 :                     break;

	jmp	$LN375@output_opc
$LN408@output_opc:

; 1068 :                       else if (CodeInfo->r1type == OP_ZMM && CodeInfo->indextype == OP_ZMM){

	cmp	eax, 256				; 00000100H
	jne	$error1$5933
	cmp	DWORD PTR [rdi+132], eax
	jne	$error1$5933

; 1069 :                          CodeInfo->evex_p2 &= ~EVEX_P2LMASK;

	and	BYTE PTR [rdi+139], 223			; 000000dfH

; 1070 :                          CodeInfo->evex_p2 |= EVEX_P2L1MASK;

	or	BYTE PTR [rdi+139], 64			; 00000040H
$LN405@output_opc:

; 1071 :                         }
; 1072 :                       else goto error1;
; 1073 :                       CodeInfo->tuple = TRUE;

	mov	BYTE PTR [rdi+140], 1

; 1074 :                     break;

	jmp	$LN375@output_opc
$LN404@output_opc:

; 1075 :                     /*    VGATHERQPS xmm1 {k1}, vm64x; VGATHERQPS xmm1 {k1}, vm64y; VGATHERQPS ymm1 {k1}, vm64z */
; 1076 :                     /*    VPGATHERQD xmm1 {k1}, vm64x; VPGATHERQD xmm1 {k1}, vm64y; VPGATHERQD ymm1 {k1}, vm64z*/
; 1077 :                   case T_VGATHERQPS:
; 1078 :                   case T_VPGATHERQD:
; 1079 :                     //if (CodeInfo->mem_type == MT_QWORD || CodeInfo->mem_type == MT_EMPTY);//that is good
; 1080 :                     //else if (CodeInfo->mem_type == MT_XMMWORD && CodeInfo->r1type == OP_XMM);//that is good
; 1081 :                     //else if (CodeInfo->mem_type == MT_YMMWORD && CodeInfo->r1type == OP_YMM);//that is good
; 1082 :                     //else if (CodeInfo->mem_type == MT_ZMMWORD && CodeInfo->r1type == OP_ZMM);//that is good
; 1083 :                     //else  goto error1;
; 1084 :                     if ((!CodeInfo->evex_flag)&& (CodeInfo->indextype == OP_ZMM || CodeInfo->r1type == OP_ZMM))

	cmp	BYTE PTR [rdi+136], r13b
	jne	SHORT $LN403@output_opc
	cmp	DWORD PTR [rdi+132], 256		; 00000100H
	je	$error1$5933
	cmp	DWORD PTR [rdi+116], 256		; 00000100H

; 1085 :                        goto error1;

	je	$error1$5933
$LN403@output_opc:

; 1086 :                       if (CodeInfo->indextype == OP_XMM && CodeInfo->r1type == OP_XMM);

	mov	eax, DWORD PTR [rdi+132]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN401@output_opc
	cmp	DWORD PTR [rdi+116], eax
	je	SHORT $LN396@output_opc
$LN401@output_opc:

; 1087 :                       else if (CodeInfo->indextype == OP_YMM && CodeInfo->r1type == OP_XMM)

	cmp	eax, 128				; 00000080H
	jne	SHORT $LN399@output_opc
	cmp	DWORD PTR [rdi+116], 32			; 00000020H
	jne	SHORT $LN399@output_opc

; 1088 :                         CodeInfo->evex_p2 |= EVEX_P2LMASK;

	or	BYTE PTR [rdi+139], 32			; 00000020H

; 1092 :                         }
; 1093 :                       else goto error1;
; 1094 :                       CodeInfo->tuple = TRUE;

	mov	BYTE PTR [rdi+140], 1

; 1095 :                     break; 

	jmp	$LN375@output_opc
$LN399@output_opc:

; 1089 :                       else if (CodeInfo->indextype == OP_ZMM && CodeInfo->r1type == OP_YMM){

	cmp	eax, 256				; 00000100H
	jne	$error1$5933
	cmp	DWORD PTR [rdi+116], 128		; 00000080H
	jne	$error1$5933

; 1090 :                         CodeInfo->evex_p2 &= ~EVEX_P2LMASK;

	and	BYTE PTR [rdi+139], 223			; 000000dfH

; 1091 :                         CodeInfo->evex_p2 |= EVEX_P2L1MASK;

	or	BYTE PTR [rdi+139], 64			; 00000040H
$LN396@output_opc:

; 1092 :                         }
; 1093 :                       else goto error1;
; 1094 :                       CodeInfo->tuple = TRUE;

	mov	BYTE PTR [rdi+140], 1

; 1095 :                     break; 

	jmp	$LN375@output_opc
$LN395@output_opc:

; 1096 :                     /*  VPSCATTERDD vm32x {k1}, xmm1; VPSCATTERDD vm32y {k1}, ymm1; VPSCATTERDD vm32z {k1}, zmm1
; 1097 :                     *   VPSCATTERQQ vm64x {k1}, xmm1; VPSCATTERQQ vm64y {k1}, ymm1; VPSCATTERQQ vm64z {k1}, zmm1
; 1098 :                     *   VSCATTERDPS vm32x {k1}, xmm1; VSCATTERDPS vm32y {k1}, ymm1; VSCATTERDPS vm32z {k1}, zmm1
; 1099 :                     *   VSCATTERQPD vm64x {k1}, xmm1; VSCATTERQPD vm64y {k1}, ymm1; VSCATTERQPD vm64z {k1}, zmm1 */
; 1100 :                   case T_VPSCATTERDD:
; 1101 :                   case T_VPSCATTERQQ:
; 1102 :                   case T_VSCATTERDPS:
; 1103 :                   case T_VSCATTERQPD:
; 1104 :                     //if (CodeInfo->mem_type == MT_EMPTY);//that is good
; 1105 :                     //else if (CodeInfo->mem_type == MT_XMMWORD && CodeInfo->r2type == OP_XMM);//that is good
; 1106 :                     //else if (CodeInfo->mem_type == MT_YMMWORD && CodeInfo->r2type == OP_YMM);//that is good
; 1107 :                     //else if (CodeInfo->mem_type == MT_ZMMWORD && CodeInfo->r2type == OP_ZMM);//that is good
; 1108 :                     //else  goto error1;
; 1109 :                       if (CodeInfo->indextype != CodeInfo->r2type) goto error1;

	mov	eax, DWORD PTR [rdi+132]
	cmp	eax, DWORD PTR [rdi+120]
	jne	$error1$5933

; 1110 :                       if (CodeInfo->indextype == OP_YMM) CodeInfo->evex_p2 |= EVEX_P2LMASK;

	cmp	eax, 128				; 00000080H
	jne	SHORT $LN393@output_opc
	or	BYTE PTR [rdi+139], 32			; 00000020H
	jmp	$LN375@output_opc
$LN393@output_opc:

; 1111 :                       else if (CodeInfo->indextype == OP_ZMM){

	cmp	eax, 256				; 00000100H
	jne	$LN375@output_opc

; 1112 :                         CodeInfo->evex_p2 &= ~EVEX_P2LMASK;    /* Clear first EVEX_P2LMASK because it was set before */

	and	BYTE PTR [rdi+139], 223			; 000000dfH

; 1113 :                          CodeInfo->evex_p2 |= EVEX_P2L1MASK;   /* set L1 byte for ZMM index */

	or	BYTE PTR [rdi+139], 64			; 00000040H

; 1114 :                         }
; 1115 :                     break;

	jmp	$LN375@output_opc
$LN390@output_opc:

; 1116 :                   //VSCATTERDPD vm32x {k1}, xmm1; VSCATTERDPD vm32x {k1}, ymm1; VSCATTERDPD vm32y {k1}, zmm
; 1117 :                   //VPSCATTERDQ vm32x {k1}, xmm1; VPSCATTERDQ vm32x {k1}, ymm1; VPSCATTERDQ vm32y {k1}, zmm
; 1118 :                   case T_VSCATTERDPD:
; 1119 :                   case T_VPSCATTERDQ:
; 1120 :                       if ((CodeInfo->indextype == OP_XMM) && (CodeInfo->r2type == OP_ZMM)) goto error1;

	mov	ecx, DWORD PTR [rdi+132]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN389@output_opc
	cmp	DWORD PTR [rdi+120], 256		; 00000100H
	je	SHORT $error1$5933
$LN389@output_opc:

; 1121 :                       else if (CodeInfo->r2type == OP_ZMM && CodeInfo->indextype != OP_YMM) goto error1;

	mov	eax, DWORD PTR [rdi+120]
	cmp	eax, 256				; 00000100H
	jne	SHORT $LN387@output_opc
	cmp	ecx, 128				; 00000080H
	jne	SHORT $error1$5933
$LN387@output_opc:

; 1122 :                       if (CodeInfo->r2type == OP_YMM) CodeInfo->evex_p2 |= EVEX_P2LMASK;

	cmp	eax, 128				; 00000080H
	jne	SHORT $LN386@output_opc
	or	BYTE PTR [rdi+139], 32			; 00000020H
	jmp	SHORT $LN375@output_opc
$LN386@output_opc:

; 1123 :                       else if (CodeInfo->r2type == OP_ZMM){

	cmp	eax, 256				; 00000100H
	jne	SHORT $LN375@output_opc

; 1124 :                         CodeInfo->evex_p2 &= ~EVEX_P2LMASK;    /* Clear first EVEX_P2LMASK because it was set before */

	and	BYTE PTR [rdi+139], 223			; 000000dfH

; 1125 :                          CodeInfo->evex_p2 |= EVEX_P2L1MASK;   /* set L1 byte for ZMM index */

	or	BYTE PTR [rdi+139], 64			; 00000040H

; 1126 :                         }
; 1127 :                     break;

	jmp	SHORT $LN375@output_opc
$LN383@output_opc:

; 1128 :                   //VPSCATTERQD vm64x {k1}, xmm1; VPSCATTERQD vm64y {k1}, xmm1; VPSCATTERQD vm64z {k1}, ymm1 
; 1129 :                   //VSCATTERQPS vm64x {k1}, xmm1; VSCATTERQPS vm64y {k1}, xmm1; VSCATTERQPS vm64z {k1}, ymm1
; 1130 :                   case T_VPSCATTERQD:
; 1131 :                   case T_VSCATTERQPS:
; 1132 :                     /* vm64x {k1}, xmm1 ;  vm64y {k1}, xmm1 ;  vm64z {k1}, ymm1 */
; 1133 :                     //if (CodeInfo->mem_type == MT_EMPTY || CodeInfo->mem_type == MT_QWORD);//that is good
; 1134 :                     //else if (CodeInfo->mem_type == MT_XMMWORD && CodeInfo->r1type == OP_XMM);//that is good
; 1135 :                     //else if (CodeInfo->mem_type == MT_YMMWORD && CodeInfo->r1type == OP_YMM);//that is good
; 1136 :                     //else if (CodeInfo->mem_type == MT_ZMMWORD && CodeInfo->r1type == OP_ZMM);//that is good
; 1137 :                     //else  goto error1;
; 1138 :                       if (CodeInfo->indextype == OP_XMM || CodeInfo->indextype == OP_YMM) 

	mov	eax, DWORD PTR [rdi+132]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN381@output_opc
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN378@output_opc
$LN381@output_opc:

; 1139 :                          if (CodeInfo->r2type != OP_XMM) goto error1;

	cmp	DWORD PTR [rdi+120], 32			; 00000020H

; 1140 :                       else if (CodeInfo->r2type == OP_YMM && CodeInfo->indextype != OP_ZMM) goto error1;

	je	SHORT $LN378@output_opc
$error1$5933:

; 1145 :                         }
; 1146 : 
; 1147 :                     break;
; 1148 :                  error1:
; 1149 :                    EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
	jmp	SHORT $LN375@output_opc
$LN378@output_opc:

; 1141 :                       if (CodeInfo->indextype == OP_YMM) CodeInfo->evex_p2 |= EVEX_P2LMASK;

	cmp	eax, 128				; 00000080H
	jne	SHORT $LN377@output_opc
	or	BYTE PTR [rdi+139], 32			; 00000020H
	jmp	SHORT $LN375@output_opc
$LN377@output_opc:

; 1142 :                       else if (CodeInfo->indextype == OP_ZMM){

	cmp	eax, 256				; 00000100H
	jne	SHORT $LN375@output_opc

; 1143 :                         CodeInfo->evex_p2 &= ~EVEX_P2LMASK;    /* Clear first EVEX_P2LMASK because it was set before */

	and	BYTE PTR [rdi+139], 223			; 000000dfH

; 1144 :                          CodeInfo->evex_p2 |= EVEX_P2L1MASK;   /* set L1 byte for ZMM index */

	or	BYTE PTR [rdi+139], 64			; 00000040H
$LN375@output_opc:

; 1150 :                   }
; 1151 :                 /* This is a fix in HJWasm 2.16 */
; 1152 :                 if (CodeInfo->token >= T_VPSCATTERDD && CodeInfo->token <= T_VSCATTERQPD){

	mov	ecx, DWORD PTR [rdi+24]
	cmp	ecx, 1389				; 0000056dH
	jl	SHORT $LN374@output_opc
	cmp	ecx, 1396				; 00000574H
	jg	SHORT $LN374@output_opc

; 1153 :                     CodeInfo->tuple = TRUE;

	mov	BYTE PTR [rdi+140], 1
$LN374@output_opc:

; 1154 :                 }
; 1155 :                 if ((CodeInfo->token == T_VEXTRACTPS)||(CodeInfo->token == T_VCVTSD2USI)||
; 1156 :                   (CodeInfo->token == T_VCVTSS2USI)||(CodeInfo->token == T_VCVTTSD2USI))

	cmp	ecx, 1965				; 000007adH
	je	SHORT $LN372@output_opc
	cmp	ecx, 1644				; 0000066cH
	je	SHORT $LN372@output_opc
	cmp	ecx, 1645				; 0000066dH
	je	SHORT $LN372@output_opc
	cmp	ecx, 1664				; 00000680H
	jne	SHORT $LN373@output_opc
$LN372@output_opc:

; 1157 :                   CodeInfo->evex_p2 &= ~EVEX_P2L1MASK;

	and	BYTE PTR [rdi+139], 191			; 000000bfH
$LN373@output_opc:

; 1158 :                   if ((CodeInfo->token == T_VEXTRACTF32x4) || (CodeInfo->token == T_VEXTRACTF64x2)||
; 1159 :                     (CodeInfo->token == T_VEXTRACTF64x4)|| (CodeInfo->token == T_VEXTRACTF32x8)||
; 1160 :                     (CodeInfo->token == T_VEXTRACTI32x4)||(CodeInfo->token == T_VEXTRACTI64x4)||
; 1161 :                     (CodeInfo->token == T_VEXTRACTI64x2)|| (CodeInfo->token == T_VEXTRACTI32x8)||
; 1162 :                   (CodeInfo->token == T_VEXTRACTPS)|| (CodeInfo->token == T_VEXTRACTPS)){

	cmp	ecx, 1327				; 0000052fH
	je	SHORT $LN370@output_opc
	cmp	ecx, 1328				; 00000530H
	je	SHORT $LN370@output_opc
	cmp	ecx, 1330				; 00000532H
	je	SHORT $LN370@output_opc
	cmp	ecx, 1329				; 00000531H
	je	SHORT $LN370@output_opc
	cmp	ecx, 1332				; 00000534H
	je	SHORT $LN370@output_opc
	cmp	ecx, 1335				; 00000537H
	je	SHORT $LN370@output_opc
	cmp	ecx, 1333				; 00000535H
	je	SHORT $LN370@output_opc
	cmp	ecx, 1334				; 00000536H
	je	SHORT $LN370@output_opc
	cmp	ecx, 1965				; 000007adH
	jne	SHORT $LN367@output_opc
$LN370@output_opc:

; 1163 :                     CodeInfo->evex_p2 &= ~EVEX_P2BMASK;

	and	BYTE PTR [rdi+139], 239			; 000000efH

; 1164 :                     if (CodeInfo->r2type == OP_YMM)

	mov	edx, DWORD PTR [rdi+120]
	movzx	eax, BYTE PTR [rdi+139]
	cmp	edx, 128				; 00000080H
	jne	SHORT $LN369@output_opc

; 1165 :                       CodeInfo->evex_p2 |= EVEX_P2LMASK;

	or	al, 32					; 00000020H
	mov	BYTE PTR [rdi+139], al
	jmp	SHORT $LN367@output_opc
$LN369@output_opc:

; 1166 :                     else if (CodeInfo->r2type == OP_ZMM){

	cmp	edx, 256				; 00000100H
	jne	SHORT $LN367@output_opc

; 1167 :                       CodeInfo->evex_p2 &= ~EVEX_P2LMASK;

	and	al, 223					; 000000dfH

; 1168 :                       CodeInfo->evex_p2 |= EVEX_P2L1MASK;

	or	al, 64					; 00000040H
	mov	BYTE PTR [rdi+139], al
$LN367@output_opc:

; 1169 :                       }
; 1170 :                   }
; 1171 :                 if (CodeInfo->evex_flag){

	cmp	BYTE PTR [rdi+136], r13b
	je	$LN98@output_opc

; 1172 :                   //__debugbreak();
; 1173 :                   if (CodeInfo->token >= T_VPSLLVD && CodeInfo->token <= T_VPSRLVW);

	cmp	ecx, 1566				; 0000061eH
	jl	SHORT $LN365@output_opc
	cmp	ecx, 1582				; 0000062eH
	jle	SHORT $LN354@output_opc
$LN365@output_opc:

; 1174 :                   else if (CodeInfo->token >= T_VPSLLW && CodeInfo->token <= T_VPSRLDQ);

	cmp	ecx, 2099				; 00000833H
	jl	SHORT $LN363@output_opc
	cmp	ecx, 2098				; 00000832H
	jle	SHORT $LN354@output_opc
$LN363@output_opc:

; 1175 :                   else if (CodeInfo->token >= T_VPSLLDQ && CodeInfo->token <= T_VPSRLQ);

	cmp	ecx, 2097				; 00000831H
	jl	SHORT $LN361@output_opc
	cmp	ecx, 2107				; 0000083bH
	jle	SHORT $LN354@output_opc
$LN361@output_opc:

; 1176 :                   else if (CodeInfo->vexregop){

	cmp	BYTE PTR [rdi+128], r13b
	je	SHORT $LN359@output_opc

; 1177 :                     if (CodeInfo->reg2 <= 15) CodeInfo->evex_p2 |= EVEX_P2VMASK;

	cmp	BYTE PTR [rdi+110], 15
	ja	SHORT $LN358@output_opc
	or	BYTE PTR [rdi+139], 8
	jmp	SHORT $LN354@output_opc
$LN358@output_opc:

; 1178 :                     else CodeInfo->evex_p2 &= ~EVEX_P2VMASK;

	and	BYTE PTR [rdi+139], 247			; 000000f7H

; 1179 :                   }
; 1180 :                   //__debugbreak();
; 1181 :                   /* Fixed index size in CodeInfo->evex_p2 ~EVEX_P2VMASK, HJWasm 2.16 */
; 1182 :                   else if (CodeInfo->opnd[OPND2].type == OP_M && CodeInfo->indexreg > 15) 

	jmp	SHORT $LN354@output_opc
$LN359@output_opc:
	cmp	DWORD PTR [rdi+56], -1887436800		; ffffffff8f800000H
	jne	SHORT $LN355@output_opc
	cmp	BYTE PTR [rdi+112], 15
	jbe	SHORT $LN355@output_opc

; 1183 :                     CodeInfo->evex_p2 &= ~EVEX_P2VMASK;

	and	BYTE PTR [rdi+139], 247			; 000000f7H
	jmp	SHORT $LN354@output_opc
$LN355@output_opc:

; 1184 :                   else CodeInfo->evex_p2 |= EVEX_P2VMASK;

	or	BYTE PTR [rdi+139], 8
$LN354@output_opc:

; 1185 :               if ((CodeInfo->token == T_VRNDSCALEPD) || (CodeInfo->token == T_VRNDSCALEPS)||
; 1186 :                    (CodeInfo->token ==  T_VCVTPS2PH))

	cmp	ecx, 1656				; 00000678H
	je	SHORT $LN352@output_opc
	cmp	ecx, 1657				; 00000679H
	je	SHORT $LN352@output_opc
	cmp	ecx, 1469				; 000005bdH
	jne	SHORT $LN353@output_opc
$LN352@output_opc:

; 1187 :                     CodeInfo->evex_p2 |= EVEX_P2VMASK;

	or	BYTE PTR [rdi+139], 8
$LN353@output_opc:

; 1188 :                 CodeInfo->evex_p2 |= decoflags;

	movzx	eax, BYTE PTR decoflags
	or	BYTE PTR [rdi+139], al

; 1189 :               if (CodeInfo->token == T_VCVTDQ2PD)

	cmp	ecx, 1947				; 0000079bH
	movzx	eax, BYTE PTR [rdi+139]
	jne	SHORT $LN351@output_opc

; 1190 :                 CodeInfo->evex_p2 &= ~EVEX_P2L1MASK;

	and	al, 191					; 000000bfH
	mov	BYTE PTR [rdi+139], al
$LN351@output_opc:

; 1191 :               if ((CodeInfo->token >= T_VPSLLW) && (CodeInfo->token <= T_VPSRLQ) ||
; 1192 :                   (CodeInfo->token >= T_VPSLLVD) && (CodeInfo->token <= T_VPSRLVW)||
; 1193 :                   (CodeInfo->token >= T_VPSLLVD && CodeInfo->token <= T_VPSRLVW)){ 

	cmp	ecx, 2099				; 00000833H
	jl	SHORT $LN348@output_opc
	cmp	ecx, 2107				; 0000083bH
	jle	SHORT $LN349@output_opc
$LN348@output_opc:
	cmp	ecx, 1566				; 0000061eH
	jl	SHORT $LN347@output_opc
	cmp	ecx, 1582				; 0000062eH
	jle	SHORT $LN349@output_opc
$LN347@output_opc:
	cmp	ecx, 1566				; 0000061eH
	jl	SHORT $LN346@output_opc
	cmp	ecx, 1582				; 0000062eH
	jg	SHORT $LN346@output_opc
$LN349@output_opc:

; 1194 :                 if (CodeInfo->reg1 <= 15)           //HJWasm 2.16 fixed EVEX_P2VMASK

	cmp	BYTE PTR [rdi+109], 15
	ja	SHORT $LN346@output_opc

; 1195 :                   CodeInfo->evex_p2 |= EVEX_P2VMASK;

	or	BYTE PTR [rdi+139], 8
$LN346@output_opc:

; 1196 :                 }
; 1197 :             switch (CodeInfo->token){ 

	sub	ecx, 1375				; 0000055fH
	je	SHORT $LN343@output_opc
	sub	ecx, 4
	je	SHORT $LN343@output_opc
	sub	ecx, 4
	je	SHORT $LN343@output_opc
	cmp	ecx, 4
	jne	SHORT $LN341@output_opc
$LN343@output_opc:

; 1198 :               case T_VGATHERPF0DPD: 
; 1199 :               case T_VGATHERPF1DPD:
; 1200 :               case T_VSCATTERPF0DPD:
; 1201 :               case T_VSCATTERPF1DPD:
; 1202 :               CodeInfo->evex_p2 |= EVEX_P2L1MASK;

	or	BYTE PTR [rdi+139], 64			; 00000040H

; 1203 :               if (CodeInfo->indexreg > 15) CodeInfo->evex_p2 &= ~EVEX_P2VMASK;

	cmp	BYTE PTR [rdi+112], 15
	movzx	eax, BYTE PTR [rdi+139]
	jbe	SHORT $LN342@output_opc
	and	al, 247					; 000000f7H
	mov	BYTE PTR [rdi+139], al
$LN342@output_opc:

; 1204 :               if (CodeInfo->indextype != OP_YMM)

	cmp	DWORD PTR [rdi+132], 128		; 00000080H
	je	SHORT $LN341@output_opc

; 1205 :                 EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN341@output_opc:

; 1206 :               }
; 1207 :             switch (CodeInfo->token){

	mov	eax, DWORD PTR [rdi+24]
	add	eax, -1373				; fffffffffffffaa3H
	cmp	eax, 15
	ja	SHORT $LN336@output_opc
	cdqe
	movzx	eax, BYTE PTR $LN831@output_opc[r15+rax]
	mov	ecx, DWORD PTR $LN832@output_opc[r15+rax*4]
	add	rcx, r15
	jmp	rcx
$LN338@output_opc:

; 1208 :               case T_VGATHERPF0DPS: 
; 1209 :               case T_VGATHERPF0QPS:
; 1210 :               case T_VGATHERPF0QPD:
; 1211 :               case T_VGATHERPF1DPS: 
; 1212 :               case T_VGATHERPF1QPS:
; 1213 :               case T_VGATHERPF1QPD:
; 1214 :               case T_VSCATTERPF0DPS: 
; 1215 :               case T_VSCATTERPF0QPS:
; 1216 :               case T_VSCATTERPF0QPD:
; 1217 :               case T_VSCATTERPF1DPS: 
; 1218 :               case T_VSCATTERPF1QPS:
; 1219 :               case T_VSCATTERPF1QPD:
; 1220 :               if (CodeInfo->indexreg > 15) CodeInfo->evex_p2 &= ~EVEX_P2VMASK;

	cmp	BYTE PTR [rdi+112], 15
	jbe	SHORT $LN337@output_opc
	and	BYTE PTR [rdi+139], 247			; 000000f7H
$LN337@output_opc:

; 1221 :               CodeInfo->evex_p2 |= EVEX_P2L1MASK;

	or	BYTE PTR [rdi+139], 64			; 00000040H

; 1222 :               if (CodeInfo->indextype != OP_ZMM)

	cmp	DWORD PTR [rdi+132], 256		; 00000100H
	je	SHORT $LN336@output_opc

; 1223 :                 EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN336@output_opc:

; 1224 :               }
; 1225 :                OutputCodeByte(CodeInfo->evex_p2);

	movzx	ecx, BYTE PTR [rdi+139]
	call	OutputByte

; 1654 :                 }
; 1655 :             }
; 1656 :         }
; 1657 :     } else {

	jmp	SHORT $LN98@output_opc
$LN747@output_opc:

; 1658 : #endif
; 1659 : 
; 1660 : #if AMD64_SUPPORT
; 1661 :     /* the REX prefix must be located after the other prefixes */
; 1662 :     if( CodeInfo->prefix.rex != 0 ) {

	cmp	BYTE PTR [rdi+8], r13b
	je	SHORT $LN102@output_opc

; 1663 :         if ( CodeInfo->Ofssize != USE64 ) {

	cmp	BYTE PTR [rdi+106], 2
	je	SHORT $LN101@output_opc

; 1664 :             EmitError( INVALID_OPERAND_SIZE );

	mov	ecx, 71					; 00000047H
	call	EmitError
$LN101@output_opc:

; 1665 :         }
; 1666 :         OutputCodeByte( CodeInfo->prefix.rex | 0x40 );

	movzx	ecx, BYTE PTR [rdi+8]
	or	cl, 64					; 00000040H
	call	OutputByte
$LN102@output_opc:

; 1667 :     }
; 1668 : #endif
; 1669 : 
; 1670 :     /*
; 1671 :      * Output extended opcode
; 1672 :      * special case for some 286 and 386 instructions
; 1673 :      * or 3DNow!, MMX and SSEx instructions
; 1674 :      */
; 1675 :     if ( ins->byte1_info >= F_0F ) {

	cmp	BYTE PTR [r12+1], 16
	jb	SHORT $LN98@output_opc

; 1676 :         OutputCodeByte( EXTENDED_OPCODE );

	mov	cl, 15
	call	OutputByte

; 1677 :         switch ( ins->byte1_info ) {

	movzx	r11d, BYTE PTR [r12+1]
	add	r11d, -17
	cmp	r11d, 10
	ja	SHORT $LN98@output_opc
	movsxd	rax, r11d
	mov	ecx, DWORD PTR $LN830@output_opc[r15+rax*4]
	add	rcx, r15
	jmp	rcx
$LN97@output_opc:

; 1678 :         case F_0F0F:   OutputCodeByte( EXTENDED_OPCODE ); break;

	mov	cl, 15
	call	OutputByte
	jmp	SHORT $LN98@output_opc
$LN96@output_opc:

; 1679 :         case F_0F38:
; 1680 :         case F_F20F38:
; 1681 :         case F_660F38: OutputCodeByte( 0x38 );            break;

	mov	cl, 56					; 00000038H
	call	OutputByte
	jmp	SHORT $LN98@output_opc
$LN95@output_opc:

; 1682 :         case F_0F3A:
; 1683 :         case F_660F3A: OutputCodeByte( 0x3A );            break;

	mov	cl, 58					; 0000003aH
	call	OutputByte
$LN98@output_opc:

; 1684 :         }
; 1685 :     }
; 1686 : 
; 1687 : #if AVXSUPP
; 1688 :     }
; 1689 : #endif
; 1690 : 
; 1691 :     switch( ins->rm_info) {

	movzx	ecx, BYTE PTR [r12+5]
	dec	ecx
	je	$LN91@output_opc
	dec	ecx
	je	SHORT $LN90@output_opc
	dec	ecx
	jne	SHORT $LN89@output_opc

; 1692 :     case R_in_OP:
; 1693 :         OutputCodeByte( ins->opcode | ( CodeInfo->rm_byte & NOT_BIT_67 ) );

	movzx	ecx, BYTE PTR [rdi+104]
	and	cl, 63					; 0000003fH

; 1694 :         break;

	jmp	$LN847@output_opc
$LN90@output_opc:

; 1697 :         break;
; 1698 :     case no_WDS:
; 1699 :         CodeInfo->iswide = 0;

	and	BYTE PTR [rdi+142], 254			; 000000feH
$LN89@output_opc:

; 1700 :         /* no break */
; 1701 :     default: /* opcode (with w d s bits), rm-byte */
; 1702 :            if( ins->byte1_info != F_0F0F ) {

	cmp	BYTE PTR [r12+1], 17
	je	$LN75@output_opc

; 1703 :              if ((CodeInfo->token >= T_KADDB) && (CodeInfo->token <= T_KMOVW)){

	mov	eax, DWORD PTR [rdi+24]
	cmp	eax, 1730				; 000006c2H
	jl	$LN87@output_opc
	cmp	eax, 1776				; 000006f0H
	jg	$LN87@output_opc

; 1704 :                if ((CodeInfo->token >= T_KMOVB) && (CodeInfo->token <= T_KMOVW)){

	cmp	eax, 1773				; 000006edH
	jl	SHORT $LN86@output_opc

; 1705 :                 const  struct instr_item *p = CodeInfo->pinstr;
; 1706 :                  int cnt;
; 1707 :                  int type1 = CodeInfo->opnd[OPND1].type;

	mov	ebp, DWORD PTR [rdi+32]
	mov	rbx, QWORD PTR [rdi+16]

; 1708 :                  int type2 = CodeInfo->opnd[OPND2].type;

	mov	esi, DWORD PTR [rdi+56]

; 1709 :                  CodeInfo->tuple = 0;
; 1710 :                  /* at least one operand must be K register */
; 1711 :                  if (type1 == OP_K || type2 == OP_K)

	cmp	ebp, 64					; 00000040H
	mov	BYTE PTR [rdi+140], r13b
	je	SHORT $LN84@output_opc
	cmp	esi, 64					; 00000040H
	je	SHORT $LN84@output_opc

; 1712 :                    ;    //OK
; 1713 :                  else
; 1714 :                  EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN84@output_opc:

; 1715 :                  /* find the proper opcode for the command movw KREG,GP_REG */
; 1716 :                  for (cnt = 0; cnt < 5; cnt++,p++){

	mov	ecx, r13d
	npad	4
$LL82@output_opc:

; 1717 :                    if ((opnd_clstab[p->opclsidx].opnd_type[OPND1] == type1) && 
; 1718 :                      (opnd_clstab[p->opclsidx].opnd_type[OPND2] == type2))

	movzx	eax, BYTE PTR [rbx]
	lea	rdx, QWORD PTR [rax+rax*2]
	cmp	DWORD PTR opnd_clstab[r15+rdx*4], ebp
	jne	SHORT $LN81@output_opc
	cmp	DWORD PTR opnd_clstab[r15+rdx*4+4], esi
	je	SHORT $LN825@output_opc
$LN81@output_opc:

; 1715 :                  /* find the proper opcode for the command movw KREG,GP_REG */
; 1716 :                  for (cnt = 0; cnt < 5; cnt++,p++){

	inc	ecx
	add	rbx, 14
	cmp	ecx, 5
	jl	SHORT $LL82@output_opc
$LN78@output_opc:

; 1725 :                    OutputCodeByte(ins->opcode);

	movzx	ecx, BYTE PTR [r12+12]
	call	OutputByte

; 1726 :               }else

	jmp	$LN75@output_opc
$LN825@output_opc:

; 1719 :                      break;
; 1720 :                  }
; 1721 :                  if (cnt < 5) {   //there are 5 combinations

	cmp	ecx, 5
	jge	SHORT $LN78@output_opc

; 1722 :                    OutputCodeByte(p->opcode);

	movzx	ecx, BYTE PTR [rbx+12]
	call	OutputByte

; 1723 :                  }
; 1724 :                  else

	jmp	$LN75@output_opc
$LN86@output_opc:

; 1727 :                 OutputCodeByte(ins->opcode);

	movzx	ecx, BYTE PTR [r12+12]
	call	OutputByte

; 1728 :              }
; 1729 :              else{

	jmp	$LN75@output_opc
$LN87@output_opc:

; 1730 :                if (CodeInfo->token == T_VMOVDQA || CodeInfo->token == T_VMOVDQU ||
; 1731 :                    CodeInfo->token == T_VMOVDQA32 || CodeInfo->token == T_VMOVDQU32 ||
; 1732 :                    CodeInfo->token == T_VMOVDQA64 || CodeInfo->token == T_VMOVDQU64){

	cmp	eax, 1979				; 000007bbH
	je	SHORT $LN73@output_opc
	cmp	eax, 1980				; 000007bcH
	je	SHORT $LN73@output_opc
	cmp	eax, 1685				; 00000695H
	je	SHORT $LN73@output_opc
	cmp	eax, 1686				; 00000696H
	je	SHORT $LN73@output_opc
	cmp	eax, 1687				; 00000697H
	je	SHORT $LN73@output_opc
	cmp	eax, 1688				; 00000698H
	jne	SHORT $LN64@output_opc
$LN73@output_opc:

; 1733 :                  if (CodeInfo->opnd[OPND1].type & OP_M_ANY){

	mov	eax, DWORD PTR [rdi+32]
	test	eax, -8388608				; ffffffffff800000H
	je	SHORT $LN64@output_opc

; 1734 :                  if (CodeInfo->mem_type == MT_EMPTY);

	cmp	DWORD PTR [rdi+28], 192			; 000000c0H
	je	SHORT $LN64@output_opc

; 1735 :                  else if (CodeInfo->opnd[OPND1].type == OP_M128 &&  CodeInfo->opnd[OPND2].type & OP_XMM);

	cmp	eax, 134217728				; 08000000H
	jne	SHORT $LN69@output_opc
	test	BYTE PTR [rdi+56], 32			; 00000020H
	jne	SHORT $LN64@output_opc
$LN69@output_opc:

; 1736 :                  else if (CodeInfo->opnd[OPND1].type == OP_M256 &&  CodeInfo->opnd[OPND2].type == OP_YMM);

	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN67@output_opc
	cmp	DWORD PTR [rdi+56], 128			; 00000080H
	je	SHORT $LN64@output_opc
$LN67@output_opc:

; 1737 :                  else if (CodeInfo->opnd[OPND1].type == OP_M512 &&  CodeInfo->opnd[OPND2].type == OP_ZMM);

	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN65@output_opc
	cmp	DWORD PTR [rdi+56], 256			; 00000100H
	je	SHORT $LN64@output_opc
$LN65@output_opc:

; 1738 :                  else 
; 1739 :                    EmitError(INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS);

	mov	ecx, 14
	call	EmitError
$LN64@output_opc:

; 1740 :                    }
; 1741 :                 }
; 1742 :                OutputCodeByte(ins->opcode | CodeInfo->iswide | CodeInfo->opc_or);

	movzx	ecx, BYTE PTR [rdi+142]
	and	cl, 1
	or	cl, BYTE PTR [rdi+107]
	or	cl, BYTE PTR [r12+12]
	call	OutputByte
$LN75@output_opc:

; 1743 :              }
; 1744 :         }
; 1745 : 
; 1746 :         /* emit ModRM byte; bits 7-6 = Mod, bits 5-3 = Reg, bits 2-0 = R/M */
; 1747 :            if ((CodeInfo->token == T_VRNDSCALEPD) || (CodeInfo->token == T_VRNDSCALEPS))CodeInfo->tuple = TRUE;

	mov	esi, DWORD PTR [rdi+24]
	cmp	esi, 1656				; 00000678H
	je	SHORT $LN62@output_opc
	cmp	esi, 1657				; 00000679H
	jne	SHORT $LN63@output_opc
$LN62@output_opc:
	mov	BYTE PTR [rdi+140], 1
$LN63@output_opc:

; 1748 :             if ((CodeInfo->token >= T_KADDB) && (CodeInfo->token <= T_KUNPCKDQ)) {       //here pay atention

	cmp	esi, 1730				; 000006c2H
	jl	SHORT $LN61@output_opc
	cmp	esi, 1756				; 000006dcH
	jg	SHORT $LN61@output_opc

; 1749 :               c = CodeInfo->reg1;
; 1750 :               tmp = MOD_11;           //bits 7-6 = Mod
; 1751 :               c = (c << 3);           //bits 5-3 = Reg,
; 1752 :               tmp |= c;            
; 1753 :               tmp |= CodeInfo->reg3;  //bits 2-0 = R/M

	movzx	ebx, BYTE PTR [rdi+109]
	or	bl, 248					; 000000f8H
	shl	bl, 3
	or	bl, BYTE PTR [rdi+111]
	jmp	SHORT $LN58@output_opc
$LN61@output_opc:

; 1754 :             }
; 1755 :             else if ((CodeInfo->token >= T_KNOTB) && (CodeInfo->token <= T_KORTESTQ)) {

	cmp	esi, 1757				; 000006ddH
	jl	SHORT $LN59@output_opc
	cmp	esi, 1764				; 000006e4H
	jg	SHORT $LN59@output_opc

; 1756 :                 tmp = MOD_11;                 //bits 7-6 = Mod
; 1757 :                 tmp |= (CodeInfo->reg1 << 3); //bits 5-3 = Reg,
; 1758 :                 tmp |= CodeInfo->reg2;        //bits 2-0 = R/M

	mov	bl, BYTE PTR [rdi+109]
	or	bl, 248					; 000000f8H
	shl	bl, 3
	or	bl, BYTE PTR [rdi+110]

; 1759 :             }
; 1760 :         else

	jmp	SHORT $LN58@output_opc
$LN59@output_opc:

; 1761 :         tmp = ins->rm_byte | CodeInfo->rm_byte;

	mov	bl, BYTE PTR [rdi+104]
	or	bl, BYTE PTR [r12+13]
$LN58@output_opc:

; 1762 :             if (CodeInfo->token == T_VCVTPS2PH){//(!CodeInfo->evex_flag) && 

	cmp	esi, 1469				; 000005bdH
	jne	SHORT $LN57@output_opc

; 1763 :               //tmp &= 0xC0;
; 1764 :               c = CodeInfo->reg2;

	movzx	eax, BYTE PTR [rdi+110]

; 1765 :               if (c > 15)c -= 16 ;

	cmp	al, 15
	jbe	SHORT $LN56@output_opc
	add	al, 240					; 000000f0H
$LN56@output_opc:

; 1766 :               if (c > 7)c -= 8;

	cmp	al, 7
	jbe	SHORT $LN55@output_opc
	add	al, 248					; 000000f8H
$LN55@output_opc:

; 1767 :               c = (c << 3);

	shl	al, 3

; 1768 :               tmp |= c;

	or	bl, al
$LN57@output_opc:

; 1769 :             }
; 1770 :         if (CodeInfo->basetype == T_RIP) tmp &= ~MOD_10;

	cmp	BYTE PTR [rdi+108], 131			; 00000083H
	jne	SHORT $LN54@output_opc
	and	bl, 127					; 0000007fH
$LN54@output_opc:

; 1771 :         /* use only if TypleType is present  */
; 1772 :         if (CodeInfo->tuple){

	cmp	BYTE PTR [rdi+140], r13b
	je	$LN15@output_opc

; 1773 :           int index = -1;
; 1774 :           int d;
; 1775 :           if ((CodeInfo->opnd[OPND1].type & OP_M_ANY) &&
; 1776 :             (CodeInfo->opnd[OPND1].data32l != -1))  index = OPND1;

	mov	r12d, DWORD PTR [rdi+32]
	test	r12d, -8388608				; ffffffffff800000H
	je	SHORT $LN52@output_opc
	cmp	DWORD PTR [rdi+40], -1
	jne	SHORT $LN827@output_opc
$LN52@output_opc:

; 1777 :           else if ((CodeInfo->opnd[OPND2].type & OP_M_ANY) &&
; 1778 :             (CodeInfo->opnd[OPND1].data32l != -1))

	test	DWORD PTR [rdi+56], -8388608		; ffffffffff800000H
	je	SHORT $LN49@output_opc
	cmp	DWORD PTR [rdi+40], -1
	je	SHORT $LN49@output_opc

; 1779 :             index = OPND2;

	mov	r13d, 1
$LN827@output_opc:

; 1780 :           if ((index != -1) && ((Check4CompDisp8(CodeInfo, &comprdsp, &d, CodeInfo->opnd[index].data32l)) && comprdsp)){

	cmp	BYTE PTR [rdi+136], 0
	movsxd	rax, r13d
	lea	rbp, QWORD PTR [rax+rax*2]
	mov	r13d, DWORD PTR [rdi+rbp*8+40]
	je	SHORT $LN814@output_opc
	mov	rcx, rdi
	call	GetByteDisp
	test	al, al
	je	SHORT $LN814@output_opc
	movzx	r8d, al
	lea	ecx, DWORD PTR [r8-1]
	test	ecx, r13d
	jne	SHORT $LN814@output_opc
	mov	eax, r13d
	cdq
	idiv	r8d
	mov	r14d, eax
	lea	ecx, DWORD PTR [rax+128]
	cmp	ecx, 255				; 000000ffH
	jbe	$LN828@output_opc
$LN814@output_opc:
	xor	r14b, r14b
$LN49@output_opc:

; 1784 :           }
; 1785 :           else if (CodeInfo->opnd[OPND2].type == OP_I8 ){

	cmp	DWORD PTR [rdi+56], 131072		; 00020000H
	jne	$LN47@output_opc

; 1786 :             if ((CodeInfo->token >= T_VPSLLW) && (CodeInfo->token <= T_VPSRLQ) ||
; 1787 :               (CodeInfo->token == T_VRNDSCALEPD) || (CodeInfo->token == T_VRNDSCALEPS)||
; 1788 :               (CodeInfo->token >= T_VPSLLVD) && (CodeInfo->token <= T_VPSRLVW)){

	cmp	esi, 2099				; 00000833H
	jl	SHORT $LN44@output_opc
	cmp	esi, 2107				; 0000083bH
	jle	SHORT $LN45@output_opc
$LN44@output_opc:
	cmp	esi, 1656				; 00000678H
	je	SHORT $LN45@output_opc
	cmp	esi, 1657				; 00000679H
	je	SHORT $LN45@output_opc
	cmp	esi, 1566				; 0000061eH
	jl	$LN15@output_opc
	cmp	esi, 1582				; 0000062eH
	jg	$LN15@output_opc
$LN45@output_opc:

; 1789 :               if ((CodeInfo->vexconst) && ((Check4CompDisp8(CodeInfo, &comprdsp, &d, CodeInfo->vexconst)) && comprdsp)){

	mov	ebp, DWORD PTR [rdi+124]
	test	ebp, ebp
	je	$LN43@output_opc
	cmp	BYTE PTR [rdi+136], 0
	je	$LN819@output_opc
	mov	rcx, rdi
	call	GetByteDisp
	test	al, al
	je	SHORT $LN819@output_opc
	movzx	ecx, al
	lea	eax, DWORD PTR [rcx-1]
	test	eax, ebp
	jne	SHORT $LN819@output_opc
	mov	eax, ebp
	cdq
	idiv	ecx
	lea	ecx, DWORD PTR [rax+128]
	cmp	ecx, 255				; 000000ffH
	ja	SHORT $LN819@output_opc
	test	al, al
	mov	r14b, al
	je	SHORT $LN43@output_opc

; 1790 :                 CodeInfo->opnd[OPND1].data32l = comprdsp;                
; 1791 :                 tmp &= ~MOD_10;     /* if        mod = 10, r/m = 100, s-i-b is present */

	and	bl, 63					; 0000003fH
	movsx	eax, al

; 1792 :                 tmp |= MOD_01;      /* change to mod = 01, r/m = 100, s-i-b is present */

	or	bl, 64					; 00000040H

; 1793 :                 if ((CodeInfo->token == T_VRNDSCALEPD) || (CodeInfo->token == T_VRNDSCALEPS)){                   

	cmp	esi, 1656				; 00000678H
	mov	DWORD PTR [rdi+40], eax
	je	SHORT $LN41@output_opc
	cmp	esi, 1657				; 00000679H
	jne	$LN15@output_opc
$LN41@output_opc:

; 1794 :                      c = CodeInfo->reg2;

	movzx	eax, BYTE PTR [rdi+110]

; 1795 :                      if (c > 15) c -= 16;

	cmp	al, 15
	jbe	SHORT $LN40@output_opc
	add	al, 240					; 000000f0H
$LN40@output_opc:

; 1796 :                      if (c > 7) c -= 8;

	cmp	al, 7
	jbe	SHORT $LN39@output_opc
	add	al, 248					; 000000f8H
$LN39@output_opc:

; 1797 :                      tmp |= c;

	or	bl, al

; 1798 :                  }
; 1799 :               }
; 1800 :               else{

	jmp	$LN15@output_opc
$LN828@output_opc:

; 1780 :           if ((index != -1) && ((Check4CompDisp8(CodeInfo, &comprdsp, &d, CodeInfo->opnd[index].data32l)) && comprdsp)){

	test	al, al
	je	$LN49@output_opc

; 1781 :             CodeInfo->opnd[index].data32l = comprdsp;

	movsx	eax, al

; 1782 :             tmp &= ~MOD_10;     /* if        mod = 10, r/m = 100, s-i-b is present */

	and	bl, 63					; 0000003fH
	mov	DWORD PTR [rdi+rbp*8+40], eax

; 1783 :             tmp |= MOD_01;      /* change to mod = 01, r/m = 100, s-i-b is present */

	or	bl, 64					; 00000040H
	jmp	$LN15@output_opc

; 1789 :               if ((CodeInfo->vexconst) && ((Check4CompDisp8(CodeInfo, &comprdsp, &d, CodeInfo->vexconst)) && comprdsp)){

$LN819@output_opc:
	xor	r14b, r14b
$LN43@output_opc:

; 1801 :                 CodeInfo->tuple = 0;
; 1802 :                 if (CodeInfo->indexreg != 0xff){

	movzx	ecx, BYTE PTR [rdi+112]
	mov	BYTE PTR [rdi+140], 0
	cmp	cl, 255					; 000000ffH
	je	SHORT $LN37@output_opc

; 1803 :                   tmp &= ~NOT_BIT_345;
; 1804 :                   tmp &= ~BIT_012;
; 1805 :                   tmp |= MOD_10;
; 1806 :                   tmp |= RM_SIB;
; 1807 :                   c = CodeInfo->indexreg;
; 1808 :                   c = (c &= 0x7) << 3;
; 1809 :                   CodeInfo->sib |= c;
; 1810 :                   c = CodeInfo->basereg;
; 1811 :                   c &= 0x7;

	movzx	eax, BYTE PTR [rdi+113]

; 1812 :                   CodeInfo->sib |= c;
; 1813 :                   CodeInfo->rm_byte = tmp;
; 1814 :                   CodeInfo->sib |= MOD_11;

	or	cl, 248					; 000000f8H
	and	bl, 56					; 00000038H
	and	al, 7
	shl	cl, 3
	or	bl, 132					; 00000084H
	or	cl, al
	mov	BYTE PTR [rdi+104], bl

; 1815 :                   CodeInfo->opnd[OPND1].data32l = CodeInfo->vexconst;

	mov	DWORD PTR [rdi+40], ebp
	or	BYTE PTR [rdi+105], cl

; 1816 :                 }
; 1817 :                 else {

	jmp	$LN15@output_opc
$LN37@output_opc:

; 1818 :                   if ((CodeInfo->opnd[OPND1].type == OP_R64) || (CodeInfo->opnd[OPND1].type == OP_RAX) ||
; 1819 :                     (CodeInfo->opnd[OPND1].type == OP_R32) || (CodeInfo->opnd[OPND1].type == OP_EAX)){

	cmp	r12d, 8
	je	$LN34@output_opc
	cmp	r12d, 520				; 00000208H
	je	$LN34@output_opc
	cmp	r12d, 4
	je	$LN34@output_opc
	cmp	r12d, 516				; 00000204H
	je	$LN34@output_opc

; 1825 :                     }
; 1826 :                   }
; 1827 :                   else if ((CodeInfo->opnd[OPND1].type == OP_XMM) || (CodeInfo->opnd[OPND1].type == OP_YMM) ||
; 1828 :                     (CodeInfo->opnd[OPND1].type == OP_ZMM)){

	cmp	r12d, 32				; 00000020H
	je	SHORT $LN30@output_opc
	cmp	r12d, 128				; 00000080H
	je	SHORT $LN30@output_opc
	cmp	r12d, 256				; 00000100H
	jne	$LN15@output_opc
$LN30@output_opc:

; 1829 :                 CodeInfo->tuple = 0;
; 1830 :                 if (CodeInfo->vexconst){

	test	ebp, ebp
	mov	BYTE PTR [rdi+140], 0
	je	SHORT $LN29@output_opc

; 1831 :                   tmp &= ~NOT_BIT_345;
; 1832 :                   tmp &= ~BIT_012;
; 1833 :                   tmp |= MOD_10;
; 1834 :                   tmp |= RM_SIB;
; 1835 :                   if (CodeInfo->indexreg != 0xFF){
; 1836 :                     c = CodeInfo->indexreg;
; 1837 :                     c = (c &= 0x07) << 3;
; 1838 :                     CodeInfo->sib |= c;
; 1839 :                     c = CodeInfo->basereg;
; 1840 :                     c &= 0x7;
; 1841 :                     CodeInfo->sib |= c;
; 1842 :                     CodeInfo->sib &= 0xf0;
; 1843 :                   }
; 1844 :                   else{
; 1845 :                     tmp &= ~0x07;
; 1846 :                     tmp |= (CodeInfo->reg2 & 0x07);

	movzx	eax, BYTE PTR [rdi+110]
	and	bl, 56					; 00000038H

; 1847 :                   }
; 1848 :                   CodeInfo->rm_byte = tmp;
; 1849 :                   CodeInfo->opnd[OPND1].data32l = CodeInfo->vexconst;

	mov	DWORD PTR [rdi+40], ebp
	or	bl, 132					; 00000084H
	xor	al, bl
	and	al, 7
	xor	bl, al
	mov	BYTE PTR [rdi+104], bl

; 1850 :                 }
; 1851 :                    else {

	jmp	$LN15@output_opc
$LN29@output_opc:

; 1852 :                      if ((CodeInfo->r2type)&&((CodeInfo->token == T_VRNDSCALEPD) || (CodeInfo->token == T_VRNDSCALEPS)))

	mov	eax, DWORD PTR [rdi+120]
	test	eax, eax
	je	SHORT $LN25@output_opc
	cmp	esi, 1656				; 00000678H
	je	SHORT $LN24@output_opc
	cmp	esi, 1657				; 00000679H
	jne	SHORT $LN25@output_opc
$LN24@output_opc:

; 1853 :                        tmp &= ~0xc0;

	and	bl, 63					; 0000003fH
$LN25@output_opc:

; 1854 :                      if ((CodeInfo->token >= T_VPSLLW) && (CodeInfo->token <= T_VPSRLQ) ||
; 1855 :                        (CodeInfo->token >= T_VPSLLVD) && (CodeInfo->token <= T_VPSRLVW)) {

	cmp	esi, 2099				; 00000833H
	jl	SHORT $LN21@output_opc
	cmp	esi, 2107				; 0000083bH
	jle	SHORT $LN22@output_opc
$LN21@output_opc:
	cmp	esi, 1566				; 0000061eH
	jl	SHORT $LN20@output_opc
	cmp	esi, 1582				; 0000062eH
	jg	SHORT $LN20@output_opc
$LN22@output_opc:

; 1856 :                        tmp &= ~7;

	and	bl, 248					; 000000f8H

; 1857 : 					   if ((CodeInfo->r2type == OP_R64) || (CodeInfo->r2type == OP_R32)) tmp &= ~0xc0;

	cmp	eax, 8
	je	SHORT $LN19@output_opc
	cmp	eax, 4
	jne	SHORT $LN20@output_opc
$LN19@output_opc:
	and	bl, 63					; 0000003fH
$LN20@output_opc:

; 1858 :                      }
; 1859 :                        c = CodeInfo->reg2;

	movzx	eax, BYTE PTR [rdi+110]

; 1860 :                        if (c > 15) c -= 16;

	cmp	al, 15
	jbe	SHORT $LN18@output_opc
	add	al, 240					; 000000f0H
$LN18@output_opc:

; 1861 :                        if (c > 7) c -= 8;

	cmp	al, 7
	jbe	SHORT $LN17@output_opc
	add	al, 248					; 000000f8H
$LN17@output_opc:

; 1862 :                        tmp |= c;

	or	bl, al
	jmp	SHORT $LN15@output_opc
$LN34@output_opc:

; 1820 :                     tmp &= ~MOD_11;

	and	bl, 63					; 0000003fH

; 1821 :                     if (CodeInfo->vexconst){

	test	ebp, ebp
	je	SHORT $LN15@output_opc

; 1822 :                       tmp |= MOD_10;

	or	bl, 128					; 00000080H

; 1823 :                       CodeInfo->rm_byte = tmp;
; 1824 :                       CodeInfo->opnd[OPND1].data32l = CodeInfo->vexconst;

	mov	DWORD PTR [rdi+40], ebp
	mov	BYTE PTR [rdi+104], bl

; 1863 :                     }
; 1864 :                   }
; 1865 :                 }
; 1866 :               }
; 1867 :             }
; 1868 :           }
; 1869 :           else{

	jmp	SHORT $LN15@output_opc
$LN47@output_opc:

; 1870 :             CodeInfo->tuple = 0;
; 1871 :            if (CodeInfo->token >= T_VPGATHERDD && CodeInfo->token <= T_VSCATTERQPD){

	cmp	esi, 1365				; 00000555H
	mov	BYTE PTR [rdi+140], 0
	jl	SHORT $LN15@output_opc
	cmp	esi, 1396				; 00000574H
	jg	SHORT $LN15@output_opc

; 1872 :               tmp &= ~0xc0;

	and	bl, 63					; 0000003fH

; 1873 :               tmp |= MOD_10;

	or	bl, 128					; 00000080H

; 1874 :               CodeInfo->rm_byte = tmp;

	mov	BYTE PTR [rdi+104], bl
$LN15@output_opc:

; 1875 :             }
; 1876 :           }
; 1877 :         }
; 1878 :         if (CodeInfo->token == T_VCVTPS2PH){

	mov	eax, DWORD PTR [rdi+24]
	cmp	eax, 1469				; 000005bdH
	jne	SHORT $LN14@output_opc

; 1879 :           if (!comprdsp) CodeInfo->tuple = 0;

	test	r14b, r14b
	jne	SHORT $LN13@output_opc
	mov	BYTE PTR [rdi+140], r14b
$LN13@output_opc:

; 1880 :           if (CodeInfo->indexreg != 0xFF){

	cmp	BYTE PTR [rdi+112], 255			; 000000ffH
	je	SHORT $LN12@output_opc

; 1881 :             c = CodeInfo->indexreg;
; 1882 :             c = (c &= 0x07) << 3;
; 1883 :             CodeInfo->sib |= c;
; 1884 :             c = CodeInfo->basereg;
; 1885 :             c &= 0x7;
; 1886 :             CodeInfo->sib |= c;
; 1887 :             CodeInfo->sib = 0xf0;

	mov	BYTE PTR [rdi+105], 240			; 000000f0H

; 1888 :             tmp |= RM_SIB;

	or	bl, 4
$LN12@output_opc:

; 1889 :           }
; 1890 :           CodeInfo->rm_byte = tmp;

	mov	BYTE PTR [rdi+104], bl
$LN14@output_opc:

; 1891 :         }
; 1892 :         if (CodeInfo->token == T_BLSMSK){

	cmp	eax, 1724				; 000006bcH
	jne	SHORT $LN11@output_opc

; 1893 :               tmp &= ~0x38;

	and	bl, 215					; 000000d7H

; 1894 :               tmp |= 0x10;

	or	bl, 16
$LN11@output_opc:

; 1895 :             }
; 1896 :         if (CodeInfo->token == T_BLSR){

	cmp	eax, 1725				; 000006bdH
	jne	SHORT $LN10@output_opc

; 1897 :               tmp &= ~0x38;

	and	bl, 207					; 000000cfH

; 1898 :               tmp |= 0x08;

	or	bl, 8
$LN10@output_opc:

; 1899 :             }
; 1900 :         /* ModR/M.mod (bit 7:6) = 0 specifies the scale factor [Scaled Vector Register] + Disp32, HJWasm 2.16 */
; 1901 :         if ((CodeInfo->basetype == 0xfe) && ((CodeInfo->indextype == OP_XMM) ||
; 1902 :           (CodeInfo->indextype == OP_YMM) || (CodeInfo->indextype == OP_ZMM))){ 

	cmp	BYTE PTR [rdi+108], 254			; 000000feH
	jne	SHORT $LN7@output_opc
	mov	eax, DWORD PTR [rdi+132]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN8@output_opc
	cmp	eax, 128				; 00000080H
	je	SHORT $LN8@output_opc
	cmp	eax, 256				; 00000100H
	jne	SHORT $LN7@output_opc
$LN8@output_opc:

; 1903 :           if (CodeInfo->basereg != 0xff)

	cmp	BYTE PTR [rdi+113], 255			; 000000ffH
	je	SHORT $LN7@output_opc

; 1904 :           tmp &= ~0xC0; // we need the scale field to be 00 for VSIB without base register EG: [XMM4+1*8]

	and	bl, 63					; 0000003fH
$LN7@output_opc:

; 1905 :         }
; 1906 :           OutputCodeByte( tmp );

	movzx	ecx, bl
	call	OutputByte

; 1907 :         if( ( CodeInfo->Ofssize == USE16 && CodeInfo->prefix.adrsiz == 0 ) ||
; 1908 :            ( CodeInfo->Ofssize == USE32 && CodeInfo->prefix.adrsiz == 1 ) )

	movzx	r11d, BYTE PTR [rdi+106]
	test	r11b, r11b
	jne	SHORT $LN4@output_opc
	test	BYTE PTR [rdi+9], 1
	je	SHORT $LN2@output_opc
$LN4@output_opc:
	cmp	r11b, 1
	jne	SHORT $LN6@output_opc
	test	BYTE PTR [rdi+9], r11b

; 1909 :             return; /* no SIB for 16bit */

	jne	SHORT $LN2@output_opc
$LN6@output_opc:

; 1910 : 
; 1911 :         switch ( tmp & NOT_BIT_345 ) {

	mov	cl, bl
	and	ecx, 199				; 000000c7H
	sub	ecx, 4
	je	SHORT $LN1@output_opc
	sub	ecx, 64					; 00000040H
	je	SHORT $LN1@output_opc
	cmp	ecx, 64					; 00000040H
	jne	SHORT $LN2@output_opc
$LN1@output_opc:

; 1912 :         case 0x04: /* mod = 00, r/m = 100, s-i-b is present */
; 1913 :         case 0x44: /* mod = 01, r/m = 100, s-i-b is present */
; 1914 :         case 0x84: /* mod = 10, r/m = 100, s-i-b is present */
; 1915 :             /* emit SIB byte; bits 7-6 = Scale, bits 5-3 = Index, bits 2-0 = Base */
; 1916 :           OutputCodeByte( CodeInfo->sib );

	movzx	ecx, BYTE PTR [rdi+105]
	jmp	SHORT $LN846@output_opc
$LN91@output_opc:

; 1695 :     case no_RM:
; 1696 :         OutputCodeByte( ins->opcode | CodeInfo->iswide );

	movzx	ecx, BYTE PTR [rdi+142]
	and	cl, 1
$LN847@output_opc:
	or	cl, BYTE PTR [r12+12]
$LN846@output_opc:
	call	OutputByte
$LN2@output_opc:
	mov	r15, QWORD PTR [rsp+40]
	mov	r14, QWORD PTR [rsp+48]
	mov	r13, QWORD PTR [rsp+56]
	mov	r12, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]

; 1917 :         }
; 1918 :     }
; 1919 :     return;
; 1920 : }

	add	rsp, 72					; 00000048H
	ret	0
$LN843@output_opc:
	DD	$LN781@output_opc
	DD	$LN779@output_opc
	DD	$LN777@output_opc
	DD	$LN775@output_opc
	DD	$LN772@output_opc
	DD	$LN773@output_opc
	DD	$LN782@output_opc
$LN842@output_opc:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	6
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
	DB	4
	npad	2
$LN841@output_opc:
	DD	$LN754@output_opc
	DD	$LN756@output_opc
	DD	$LN755@output_opc
	DD	$LN757@output_opc
$LN840@output_opc:
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	2
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	1
	DB	2
	npad	1
$LN839@output_opc:
	DD	$LN743@output_opc
	DD	$LN741@output_opc
	DD	$LN742@output_opc
	DD	$LN744@output_opc
	DD	$LN744@output_opc
	DD	$LN744@output_opc
	DD	$LN744@output_opc
	DD	$LN743@output_opc
	DD	$LN743@output_opc
	DD	$LN741@output_opc
	DD	$LN742@output_opc
$LN838@output_opc:
	DD	$LN702@output_opc
	DD	$LN702@output_opc
	DD	$LN724@output_opc
	DD	$LN719@output_opc
	DD	$LN702@output_opc
	DD	$LN702@output_opc
	DD	$LN724@output_opc
	DD	$LN719@output_opc
	DD	$LN702@output_opc
	DD	$LN702@output_opc
$LN837@output_opc:
	DD	$LN679@output_opc
	DD	$LN675@output_opc
	DD	$LN671@output_opc
	DD	$LN695@output_opc
	DD	$LN691@output_opc
	DD	$LN687@output_opc
	DD	$LN667@output_opc
	DD	$LN683@output_opc
$LN836@output_opc:
	DD	$LN639@output_opc
	DD	$LN638@output_opc
	DD	$LN639@output_opc
	DD	$LN638@output_opc
	DD	$LN639@output_opc
	DD	$LN639@output_opc
	DD	$LN638@output_opc
$LN835@output_opc:
	DD	$LN476@output_opc
	DD	$LN469@output_opc
	DD	$LN462@output_opc
	DD	$LN476@output_opc
	DD	$LN469@output_opc
	DD	$LN476@output_opc
	DD	$LN476@output_opc
	DD	$LN469@output_opc
	DD	$LN462@output_opc
	DD	$LN476@output_opc
	DD	$LN469@output_opc
	DD	$LN476@output_opc
$LN834@output_opc:
	DD	$LN413@output_opc
	DD	$LN404@output_opc
	DD	$LN423@output_opc
	DD	$LN395@output_opc
	DD	$LN390@output_opc
	DD	$LN383@output_opc
	DD	$LN375@output_opc
$LN833@output_opc:
	DB	0
	DB	1
	DB	2
	DB	0
	DB	2
	DB	0
	DB	0
	DB	1
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	4
	DB	5
	DB	3
	DB	3
	DB	4
	DB	5
	DB	3
$LN832@output_opc:
	DD	$LN338@output_opc
	DD	$LN336@output_opc
$LN831@output_opc:
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
$LN830@output_opc:
	DD	$LN97@output_opc
	DD	$LN98@output_opc
	DD	$LN98@output_opc
	DD	$LN98@output_opc
	DD	$LN98@output_opc
	DD	$LN98@output_opc
	DD	$LN96@output_opc
	DD	$LN95@output_opc
	DD	$LN96@output_opc
	DD	$LN95@output_opc
	DD	$LN96@output_opc
output_opc ENDP
_TEXT	ENDS
EXTRN	OutputBytes:NEAR
EXTRN	GetCurrOffset:NEAR
EXTRN	write_to_file:BYTE
EXTRN	EmitErr:NEAR
EXTRN	Parse_Pass:DWORD
xdata	SEGMENT
$unwind$output_data DD 071d01H
	DD	04c41dH
	DD	097411H
	DD	06340cH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$output_data DD @imagerel(output_data#)
	DD	@imagerel(output_data#+261)
	DD	@imagerel($unwind$output_data#)
pdata	ENDS
xdata	SEGMENT
$chain$4$output_data DD 040a21H
	DD	08640aH
	DD	075405H
	DD	@imagerel(output_data#)
	DD	@imagerel(output_data#+261)
	DD	@imagerel($unwind$output_data#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$output_data DD @imagerel(output_data#+261)
	DD	@imagerel(output_data#+753)
	DD	@imagerel($chain$4$output_data#)
pdata	ENDS
xdata	SEGMENT
$chain$5$output_data DD 021H
	DD	@imagerel(output_data#)
	DD	@imagerel(output_data#+261)
	DD	@imagerel($unwind$output_data#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$output_data DD @imagerel(output_data#+753)
	DD	@imagerel(output_data#+773)
	DD	@imagerel($chain$5$output_data#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
CodeInfo$ = 48
determinant$ = 56
index$ = 64
output_data PROC NEAR

; 1927 : {

	sub	rsp, 40					; 00000028H

; 1928 :   int       size = 0;
; 1929 : 
; 1930 :   /* John: Fixed specially typed INS/OUTS instructions where the operands MUST be ignored, they're purely for documentation purposes */
; 1931 :   if ( (CodeInfo->token == T_INS && CodeInfo->opnd[OPND1].type != OP_NONE) ||
; 1932 : 	  (CodeInfo->token == T_OUTS && CodeInfo->opnd[OPND2].type != OP_NONE) )

	mov	eax, DWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+72], rdi
	xor	ebx, ebx
	cmp	eax, 525				; 0000020dH
	mov	QWORD PTR [rsp+32], r12
	movsxd	r12, r8d
	mov	rdi, rcx
	jne	SHORT $LN63@output_dat
	cmp	DWORD PTR [rcx+32], ebx
	jne	$LN1@output_dat
$LN63@output_dat:
	cmp	eax, 537				; 00000219H
	jne	SHORT $LN65@output_dat
	cmp	DWORD PTR [rcx+56], ebx

; 1933 : 	  return;

	jne	$LN1@output_dat
$LN65@output_dat:

; 1934 : 
; 1935 : #if AVXSUPP
; 1936 :     if (CodeInfo->token >= VEX_START){

	cmp	eax, 1304				; 00000518H
	mov	r8d, 2
	jl	$LN62@output_dat

; 1937 :       if ((CodeInfo->token == T_ANDN) || (CodeInfo->token == T_MULX) ||
; 1938 :         (CodeInfo->token == T_PDEP) || (CodeInfo->token == T_PEXT)){

	cmp	eax, 1717				; 000006b5H
	je	SHORT $LN60@output_dat
	cmp	eax, 1718				; 000006b6H
	je	SHORT $LN60@output_dat
	cmp	eax, 1727				; 000006bfH
	je	SHORT $LN60@output_dat
	cmp	eax, 1728				; 000006c0H
	jne	SHORT $LN59@output_dat
$LN60@output_dat:

; 1939 :         if ((CodeInfo->opnd[OPND2].data32l == 0) || (index == 2))

	cmp	DWORD PTR [rcx+64], ebx
	je	$LN1@output_dat
	cmp	r12d, r8d
	je	$LN1@output_dat
$LN59@output_dat:

; 1940 :           return;
; 1941 :       }
; 1942 :       if ((CodeInfo->token >= T_BEXTR) && (CodeInfo->token <= T_SHRX) || (CodeInfo->token == T_BZHI)) {

	cmp	eax, 1719				; 000006b7H
	jl	SHORT $LN55@output_dat
	cmp	eax, 1722				; 000006baH
	jle	SHORT $LN56@output_dat
$LN55@output_dat:
	cmp	eax, 1726				; 000006beH
	jne	SHORT $LN53@output_dat
$LN56@output_dat:

; 1943 :         if (CodeInfo->opnd[OPND2].data32l == 0) return;

	cmp	DWORD PTR [rcx+64], ebx
	je	$LN1@output_dat

; 1944 :         if ((index == 0) || (index == 2))

	test	r12d, r12d
	je	$LN1@output_dat
	cmp	r12d, r8d

; 1945 :           return;

	je	$LN1@output_dat
$LN53@output_dat:

; 1946 :       }
; 1947 :       if (CodeInfo->opnd[OPND2].type == OP_I8 && CodeInfo->evex_flag){

	cmp	DWORD PTR [rcx+56], 131072		; 00020000H
	jne	SHORT $LN62@output_dat
	cmp	BYTE PTR [rcx+136], bl
	je	SHORT $LN62@output_dat

; 1948 :         if ((CodeInfo->token >= T_VPSLLW) && (CodeInfo->token <= T_VPSRLQ) ||
; 1949 :           (CodeInfo->token >= T_VPSLLVD) && (CodeInfo->token <= T_VPSRLVW) ||
; 1950 :           (CodeInfo->token == T_VRNDSCALEPD) || (CodeInfo->token == T_VRNDSCALEPS))

	cmp	eax, 2099				; 00000833H
	jl	SHORT $LN48@output_dat
	cmp	eax, 2107				; 0000083bH
	jle	SHORT $LN49@output_dat
$LN48@output_dat:
	cmp	eax, 1566				; 0000061eH
	jl	SHORT $LN47@output_dat
	cmp	eax, 1582				; 0000062eH
	jle	SHORT $LN49@output_dat
$LN47@output_dat:
	cmp	eax, 1656				; 00000678H
	je	SHORT $LN49@output_dat
	cmp	eax, 1657				; 00000679H
	jne	SHORT $LN62@output_dat
$LN49@output_dat:

; 1951 :         {
; 1952 :           if (((CodeInfo->rm_byte) >> 6) == 2)size = 4;

	movzx	eax, BYTE PTR [rcx+104]
	shr	al, 6
	cmp	al, r8b
	jne	SHORT $LN46@output_dat
	mov	ebx, 4
	jmp	SHORT $LN62@output_dat
$LN46@output_dat:

; 1953 :           else if (((CodeInfo->rm_byte) >> 6) == 1)size = 2;

	cmp	al, 1
	cmove	ebx, r8d
$LN62@output_dat:

; 1954 :         }
; 1955 :       }
; 1956 :     } 
; 1957 :     else
; 1958 : #endif
; 1959 :     /* skip the memory operand for XLAT/XLATB and string instructions! */
; 1960 :     if ( CodeInfo->token == T_XLAT || CodeInfo->token == T_XLATB ||
; 1961 :         CodeInfo->pinstr->allowed_prefix == AP_REP ||
; 1962 :         CodeInfo->pinstr->allowed_prefix == AP_REPxx ) {
; 1963 :         /* v2.06: no need anymore to modify the fixup field, it's
; 1964 :          * used inside OutputBytes() only.
; 1965 :          */
; 1966 :         //CodeInfo->InsFixup[index] = NULL;
; 1967 : 
; 1968 :         ;//return;
; 1969 :     }
; 1970 : #ifdef DEBUG_OUT
; 1971 :     if ( CodeInfo->opnd[index].InsFixup )
; 1972 :         DebugMsg1(("output_data(idx=%u, op=%" I32_SPEC "X [data=%" I32_SPEC "X fixup=%p typ=%u] ) enter [rm=%X]\n", index, determinant, CodeInfo->opnd[index].data32l, CodeInfo->opnd[index].InsFixup, CodeInfo->opnd[index].InsFixup->type ,CodeInfo->rm_byte ));
; 1973 :     else
; 1974 :         DebugMsg1(("output_data(idx=%u, op=%" I32_SPEC "X [data=%" I32_SPEC "X fixup=NULL] ) enter [rm=%X]\n", index, determinant, CodeInfo->opnd[index].data32l, CodeInfo->rm_byte ));
; 1975 : #endif
; 1976 : 
; 1977 :     /* determine size */
; 1978 : 
; 1979 :     if( determinant & OP_I8 ) {

	bt	edx, 17
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	jae	SHORT $LN40@output_dat

; 1980 :         size = 1;

	mov	ebx, 1
	jmp	$LN70@output_dat
$LN40@output_dat:

; 1981 :     } else if( determinant & OP_I16 ) {

	bt	edx, 18
	jae	SHORT $LN38@output_dat

; 1982 :         size = 2;

	mov	ebx, r8d
	jmp	$LN70@output_dat
$LN38@output_dat:

; 1983 :     } else if( determinant & OP_I32 ) {

	bt	edx, 19
	jae	SHORT $LN36@output_dat

; 1984 :         size = 4;

	mov	ebx, 4
	jmp	$LN70@output_dat
$LN36@output_dat:

; 1985 :     } else if( determinant & OP_I48 ) {

	bt	edx, 21
	jae	SHORT $LN34@output_dat

; 1986 :         size = 6;

	mov	ebx, 6
	jmp	$LN70@output_dat
$LN34@output_dat:

; 1987 : #if AMD64_SUPPORT
; 1988 :     } else if( determinant & OP_I64 ) {

	bt	edx, 20
	jae	SHORT $LN32@output_dat

; 1989 :         size = 8;

	mov	ebx, 8
	jmp	$LN70@output_dat
$LN32@output_dat:

; 1990 : #endif
; 1991 :     } else if( determinant & OP_M_ANY ) {

	test	edx, -8388608				; ffffffffff800000H
	je	$LN13@output_dat

; 1992 :         /* switch on the mode ( the leftmost 2 bits ) */
; 1993 :         switch( CodeInfo->rm_byte & BIT_67 ) {

	movzx	ecx, BYTE PTR [rcx+104]
	mov	edx, ecx
	and	edx, 192				; 000000c0H
	je	SHORT $LN26@output_dat
	sub	edx, 64					; 00000040H
	je	SHORT $LN27@output_dat
	cmp	edx, 64					; 00000040H
	jne	SHORT $LN13@output_dat

; 2022 : 
; 2023 : #endif
; 2024 :                 }
; 2025 :             }
; 2026 :             break;
; 2027 :         case MOD_10:  /* 16- or 32-bit displacement */
; 2028 :             if( ( CodeInfo->Ofssize == USE16 && CodeInfo->prefix.adrsiz == 0 ) ||
; 2029 :                ( CodeInfo->Ofssize == USE32 && CodeInfo->prefix.adrsiz == 1 ) ) {

	movzx	eax, BYTE PTR [rdi+106]
	test	al, al
	jne	SHORT $LN9@output_dat
	test	BYTE PTR [rdi+9], 1
	je	SHORT $LN10@output_dat
$LN9@output_dat:
	cmp	al, 1
	jne	SHORT $LN11@output_dat
	test	BYTE PTR [rdi+9], al
	je	SHORT $LN11@output_dat
$LN10@output_dat:

; 2030 :                 size = 2;

	mov	ebx, r8d

; 2031 :             } else {

	jmp	SHORT $LN70@output_dat
$LN11@output_dat:

; 2032 :                 size = 4;

	mov	ebx, 4
	jmp	SHORT $LN70@output_dat
$LN27@output_dat:

; 1994 :         case MOD_01:  /* 8-bit displacement */
; 1995 :             size = 1;

	mov	ebx, 1

; 1996 :             break;

	jmp	SHORT $LN70@output_dat
$LN26@output_dat:

; 1997 :         case MOD_00: /* direct; base and/or index with no disp */
; 1998 :             if( ( CodeInfo->Ofssize == USE16 && CodeInfo->prefix.adrsiz == 0 ) ||
; 1999 :                ( CodeInfo->Ofssize == USE32 && CodeInfo->prefix.adrsiz == 1 ) ) {

	movzx	edx, BYTE PTR [rdi+106]
	test	dl, dl
	jne	SHORT $LN23@output_dat
	test	BYTE PTR [rdi+9], 1
	je	SHORT $LN24@output_dat
$LN23@output_dat:
	cmp	dl, 1
	jne	SHORT $LN25@output_dat
	test	BYTE PTR [rdi+9], dl
	je	SHORT $LN25@output_dat
$LN24@output_dat:

; 2000 :                 if( ( CodeInfo->rm_byte & BIT_012 ) == RM_D16 ) {

	and	cl, 7
	cmp	cl, 6
	jne	SHORT $LN13@output_dat

; 2001 :                      size = 2; /* = size of displacement */

	mov	ebx, r8d

; 2002 :                 }
; 2003 :             } else {

	jmp	SHORT $LN70@output_dat
$LN25@output_dat:

; 2004 : #if AMD64_SUPPORT
; 2005 :                 /* v2.11: special case, 64-bit direct memory addressing, opcodes 0xA0 - 0xA3 */
; 2006 :                 if( CodeInfo->Ofssize == USE64 && ( CodeInfo->pinstr->opcode & 0xFC ) == 0xA0 && CodeInfo->pinstr->byte1_info == 0 )

	cmp	dl, r8b
	jne	SHORT $LN20@output_dat
	mov	r8, QWORD PTR [rdi+16]
	movzx	eax, BYTE PTR [r8+12]
	and	al, 252					; 000000fcH
	cmp	al, 160					; 000000a0H
	jne	SHORT $LN20@output_dat
	cmp	BYTE PTR [r8+1], 0
	jne	SHORT $LN20@output_dat

; 2007 :                     size = 8;

	mov	ebx, 8

; 2008 :                 else

	jmp	SHORT $LN70@output_dat
$LN20@output_dat:

; 2009 : #endif
; 2010 :                 switch( CodeInfo->rm_byte & BIT_012 ) {

	and	ecx, 7
	sub	ecx, 4
	je	SHORT $LN16@output_dat
	dec	ecx
	je	SHORT $LN15@output_dat
$LN13@output_dat:

; 2033 :             }
; 2034 :         }
; 2035 :     }
; 2036 : #ifdef DEBUG_OUT
; 2037 :     if ( size > 4 )
; 2038 :         DebugMsg1(( "output_data: size=%u cont=%" I64_SPEC "X\n", size, CodeInfo->opnd[index].data64 ));
; 2039 :     else if ( size )
; 2040 :         DebugMsg1(( "output_data: size=%u cont=%" I32_SPEC "X\n", size, CodeInfo->opnd[index].data32l ));
; 2041 :     else
; 2042 :         DebugMsg1(( "output_data: size=0\n" ));
; 2043 : #endif
; 2044 :     if (size) {

	test	ebx, ebx
	je	$LN3@output_dat
$LN70@output_dat:

; 2045 :       if (CodeInfo->opnd[index].InsFixup) {

	lea	rbp, QWORD PTR [r12+r12*2+6]
	mov	rdx, QWORD PTR [rdi+rbp*8]
	test	rdx, rdx
	je	$LN3@output_dat

; 2046 :         /* v2.07: fixup type check moved here */
; 2047 :         if (Parse_Pass > PASS_1)

	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN4@output_dat

; 2048 :           if ((1 << CodeInfo->opnd[index].InsFixup->type) & ModuleInfo.fmtopt->invalid_fixup_type) {

	mov	r9, QWORD PTR ModuleInfo+344
	mov	ecx, DWORD PTR [rdx+24]
	movsx	eax, WORD PTR [r9+8]
	bt	eax, ecx
	jae	SHORT $LN4@output_dat

; 2049 :             EmitErr(UNSUPPORTED_FIXUP_TYPE,
; 2050 :               ModuleInfo.fmtopt->formatname,
; 2051 :               CodeInfo->opnd[index].InsFixup->sym ? CodeInfo->opnd[index].InsFixup->sym->name : szNull);

	mov	rax, QWORD PTR [rdx+56]
	test	rax, rax
	je	SHORT $LN68@output_dat
	mov	r8, QWORD PTR [rax+8]
	jmp	SHORT $LN69@output_dat
$LN16@output_dat:

; 2011 :                 case RM_SIB: /* 0x04 (equals register # for ESP) */
; 2012 :                     if( ( CodeInfo->sib & BIT_012 ) != RM_D32 ) {

	movzx	eax, BYTE PTR [rdi+105]
	and	al, 7
	cmp	al, 5
	jne	SHORT $LN13@output_dat
$LN15@output_dat:

; 2013 :                         break;  /* size = 0 */
; 2014 :                     }
; 2015 :                     /* no break */
; 2016 :                 case RM_D32: /* 0x05 (equals register # for EBP) */
; 2017 :                     size = 4; /* = size of displacement */
; 2018 : #if AMD64_SUPPORT
; 2019 :                     /* v2.11: overflow check for 64-bit added */
; 2020 :                       if ( CodeInfo->Ofssize == USE64 && CodeInfo->opnd[index].data64 >= 0x80000000 && CodeInfo->opnd[index].data64 < 0xffffffff80000000 )

	cmp	dl, 2
	mov	ebx, 4
	jne	SHORT $LN70@output_dat
	lea	rcx, QWORD PTR [r12+r12*2]
	mov	rax, QWORD PTR [rdi+rcx*8+40]
	mov	ecx, -2147483648			; 80000000H
	cmp	rax, rcx
	jb	SHORT $LN70@output_dat
	cmp	rax, -2147483648			; ffffffff80000000H
	jae	SHORT $LN70@output_dat

; 2021 :                         EmitErr( INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS );  // proveri

	lea	ecx, QWORD PTR [rbx+10]
	call	EmitErr

; 2033 :             }
; 2034 :         }
; 2035 :     }
; 2036 : #ifdef DEBUG_OUT
; 2037 :     if ( size > 4 )
; 2038 :         DebugMsg1(( "output_data: size=%u cont=%" I64_SPEC "X\n", size, CodeInfo->opnd[index].data64 ));
; 2039 :     else if ( size )
; 2040 :         DebugMsg1(( "output_data: size=%u cont=%" I32_SPEC "X\n", size, CodeInfo->opnd[index].data32l ));
; 2041 :     else
; 2042 :         DebugMsg1(( "output_data: size=0\n" ));
; 2043 : #endif
; 2044 :     if (size) {

	jmp	SHORT $LN70@output_dat
$LN68@output_dat:

; 2049 :             EmitErr(UNSUPPORTED_FIXUP_TYPE,
; 2050 :               ModuleInfo.fmtopt->formatname,
; 2051 :               CodeInfo->opnd[index].InsFixup->sym ? CodeInfo->opnd[index].InsFixup->sym->name : szNull);

	lea	r8, OFFSET FLAT:szNull
$LN69@output_dat:
	lea	rdx, QWORD PTR [r9+10]
	mov	ecx, 197				; 000000c5H
	call	EmitErr
$LN4@output_dat:

; 2052 :             /* don't exit! */
; 2053 :           }
; 2054 :         if (write_to_file) {

	cmp	BYTE PTR write_to_file, 0
	je	SHORT $LN3@output_dat

; 2055 :           CodeInfo->opnd[index].InsFixup->locofs = GetCurrOffset();

	call	GetCurrOffset
	mov	rcx, QWORD PTR [rdi+rbp*8]
	mov	DWORD PTR [rcx+20], eax

; 2056 :           OutputBytes((unsigned char *)&CodeInfo->opnd[index].data32l,
; 2057 :             size, CodeInfo->opnd[index].InsFixup);

	mov	r8, QWORD PTR [rdi+rbp*8]
	lea	rax, QWORD PTR [r12+r12*2]
	lea	rcx, QWORD PTR [rdi+rax*8+40]

; 2058 :           return;

	jmp	SHORT $LN73@output_dat
$LN3@output_dat:

; 2059 :         }
; 2060 :       }
; 2061 :     }
; 2062 :         /* if the TypleType is present output only 1 byte for the multiplier */
; 2063 :         if ((CodeInfo->tuple)&&(CodeInfo->opnd[OPND2].type != OP_I8)) {

	cmp	BYTE PTR [rdi+140], 0
	je	SHORT $LN2@output_dat
	cmp	DWORD PTR [rdi+56], 131072		; 00020000H
	je	SHORT $LN2@output_dat

; 2064 :           OutputByte(CodeInfo->opnd[index].data32l);

	lea	rcx, QWORD PTR [r12+r12*2]
	movzx	ecx, BYTE PTR [rdi+rcx*8+40]
	call	OutputByte

; 2065 :         }
; 2066 :         else

	jmp	SHORT $LN72@output_dat
$LN2@output_dat:

; 2067 :           OutputBytes( (unsigned char *)&CodeInfo->opnd[index].data32l, size, NULL );

	lea	rcx, QWORD PTR [r12+r12*2]
	xor	r8d, r8d
	lea	rcx, QWORD PTR [rdi+rcx*8+40]
$LN73@output_dat:
	mov	edx, ebx
	call	OutputBytes
$LN72@output_dat:
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
$LN1@output_dat:
	mov	r12, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+48]

; 2068 :        
; 2069 :     return;
; 2070 : }

	add	rsp, 40					; 00000028H
	ret	0
output_data ENDP
; Function compile flags: /Ogtpy
CodeInfo$ = 8
check_3rd_operand PROC NEAR

; 2075 :     if( ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type_3rd == OP3_NONE ) ||
; 2076 :        ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type_3rd == OP3_HID ) )

	mov	rax, QWORD PTR [rcx+16]
	movzx	edx, BYTE PTR [rax]
	lea	rax, QWORD PTR [rdx+rdx*2]
	lea	rdx, OFFSET FLAT:opnd_clstab+8
	movzx	edx, BYTE PTR [rdx+rax*4]
	test	dl, dl
	je	$LN16@check_3rd_
	cmp	dl, 5
	je	SHORT $LN16@check_3rd_

; 2078 :     
; 2079 :     /* current variant needs a 3rd operand */
; 2080 :     DebugMsg1(("check_3rd_operand: tab=%X <-> codeinfo=%X\n", opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type_3rd, CodeInfo->opnd[OPND3].type ));
; 2081 : 
; 2082 :     switch ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type_3rd ) {

	movzx	edx, dl
	dec	edx
	je	SHORT $LN13@check_3rd_
	dec	edx
	je	SHORT $LN11@check_3rd_
	dec	edx
	je	SHORT $LN4@check_3rd_
	dec	edx
	jne	SHORT $LN12@check_3rd_

; 2094 :             }
; 2095 :         }
; 2096 :         break;
; 2097 :     case OP3_I: /* IMUL */
; 2098 :         if ( CodeInfo->opnd[OPND3].type & OP_I )

	test	DWORD PTR [rcx+80], 917504		; 000e0000H
	je	SHORT $LN12@check_3rd_
$LN23@check_3rd_:

; 2099 :             return( NOT_ERROR );

	xor	eax, eax

; 2114 : }

	ret	0
$LN4@check_3rd_:

; 2100 :         break;
; 2101 :     case OP3_XMM0:
; 2102 : #if AVXSUPP
; 2103 :         /* for VEX encoding, XMM0 has the meaning: any K/XMM/YMM/ZMM register */
; 2104 :         if ( CodeInfo->token >= VEX_START ) {

	cmp	DWORD PTR [rcx+24], 1304		; 00000518H

; 2105 :                return( NOT_ERROR );

	jge	SHORT $LN22@check_3rd_

; 2106 :         } else
; 2107 : #endif
; 2108 :         if ( CodeInfo->opnd[OPND3].type == OP_XMM &&
; 2109 :             CodeInfo->opnd[OPND3].data32l == 0 )

	cmp	DWORD PTR [rcx+80], 32			; 00000020H
	jne	SHORT $LN12@check_3rd_
	cmp	DWORD PTR [rcx+88], 0
	jne	SHORT $LN12@check_3rd_
$LN22@check_3rd_:

; 2110 :             return( NOT_ERROR );

	xor	eax, eax

; 2114 : }

	ret	0
$LN11@check_3rd_:

; 2086 :         break;
; 2087 :     case OP3_I8_U: /* IMUL, SHxD, a few MMX/SSE */
; 2088 :         /* for IMUL, the operand is signed! */
; 2089 :         if ( ( CodeInfo->opnd[OPND3].type & OP_I ) && CodeInfo->opnd[OPND3].data32l >= -128 ) {

	test	DWORD PTR [rcx+80], 917504		; 000e0000H
	je	SHORT $LN12@check_3rd_
	mov	eax, DWORD PTR [rcx+88]
	cmp	eax, -128				; ffffffffffffff80H
	jl	SHORT $LN12@check_3rd_

; 2090 :             if ( ( CodeInfo->token == T_IMUL && CodeInfo->opnd[OPND3].data32l < 128 ) ||
; 2091 :                 ( CodeInfo->token != T_IMUL && CodeInfo->opnd[OPND3].data32l < 256 ) ) {

	mov	edx, DWORD PTR [rcx+24]
	cmp	edx, 621				; 0000026dH
	jne	SHORT $LN21@check_3rd_
	cmp	eax, 128				; 00000080H
	jl	SHORT $LN8@check_3rd_
	cmp	edx, edx
	je	SHORT $LN12@check_3rd_
$LN21@check_3rd_:
	cmp	eax, 256				; 00000100H
	jge	SHORT $LN12@check_3rd_
$LN8@check_3rd_:

; 2092 :                 CodeInfo->opnd[OPND3].type = OP_I8;

	mov	DWORD PTR [rcx+80], 131072		; 00020000H

; 2093 :                 return( NOT_ERROR );

	xor	eax, eax

; 2114 : }

	ret	0
$LN13@check_3rd_:

; 2083 :     case OP3_CL:
; 2084 :         if ( CodeInfo->opnd[OPND3].type == OP_CL )

	cmp	DWORD PTR [rcx+80], 1025		; 00000401H

; 2085 :             return( NOT_ERROR );

	je	SHORT $LN23@check_3rd_
$LN12@check_3rd_:

; 2111 :         break;
; 2112 :     }
; 2113 :     return( ERROR );

	mov	eax, -1

; 2114 : }

	ret	0
$LN16@check_3rd_:

; 2077 :         return( ( CodeInfo->opnd[OPND3].type == OP_NONE ) ? NOT_ERROR : ERROR );

	mov	eax, DWORD PTR [rcx+80]
	neg	eax
	sbb	eax, eax

; 2114 : }

	ret	0
check_3rd_operand ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$output_3rd_operand DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$output_3rd_operand DD @imagerel(output_3rd_operand#)
	DD	@imagerel(output_3rd_operand#+458)
	DD	@imagerel($unwind$output_3rd_operand#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
CodeInfo$ = 48
output_3rd_operand PROC NEAR

; 2118 : {

	sub	rsp, 40					; 00000028H

; 2119 :     if( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type_3rd == OP3_I8_U ) {

	mov	rax, QWORD PTR [rcx+16]
	movzx	edx, BYTE PTR [rax]
	lea	rax, QWORD PTR [rdx+rdx*2]
	lea	rdx, OFFSET FLAT:opnd_clstab+8
	movzx	edx, BYTE PTR [rdx+rax*4]
	cmp	dl, 2

; 2120 :         DebugMsg1(("output_3rd_operand, expected I8, op3=%" I32_SPEC "X\n", CodeInfo->opnd[OPND3].type ));
; 2121 :         /* v2.06: the type has been checked already! */
; 2122 :         //if( CodeInfo->opnd_type[OPND3] & OP_I ) {
; 2123 :         output_data( CodeInfo, OP_I8, OPND3 );

	je	$LN32@output_3rd

; 2124 :         //} else {
; 2125 :         //    EmitError( INVALID_INSTRUCTION_OPERANDS );
; 2126 :         //    return;
; 2127 :         //}
; 2128 :     } else if( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type_3rd == OP3_I ) {

	cmp	dl, 4
	jne	SHORT $LN27@output_3rd

; 2129 :         output_data( CodeInfo, CodeInfo->opnd[OPND3].type, OPND3 );

	mov	edx, DWORD PTR [rcx+80]

; 2200 :         output_data( CodeInfo, OP_I8, OPND3 );

	mov	r8d, 2

; 2201 :     }
; 2202 : #endif
; 2203 :     return;
; 2204 : }

	add	rsp, 40					; 00000028H
	jmp	output_data
$LN27@output_3rd:

; 2130 :     }
; 2131 :     else if (opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type_3rd == OP3_HID) {

	cmp	dl, 5

; 2132 :       DebugMsg1(("output_3rd_operand, expected OP3_HID, op3=%" I32_SPEC "X\n", CodeInfo->opnd[OPND3].type));
; 2133 :       /* v2.06: to avoid having to add 3*8 operand categories there's a
; 2134 :        * hard-wired peculiarity for the "hidden" 3rd operand: it's calculated
; 2135 :        * directly from the instruction token. in instruct.h, CMPEQPD must
; 2136 :        * be first and the order of the following CMP entries must not be
; 2137 :        * changed.
; 2138 :        */
; 2139 :       //CodeInfo->data[OPND3] = opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type_3rd & ~OP3_HID;
; 2140 : #if AVXSUPP
; 2141 :       if (CodeInfo->token >= VEX_START){

	mov	eax, DWORD PTR [rcx+24]
	jne	$LN25@output_3rd
	cmp	eax, 1304				; 00000518H
	jl	$LN24@output_3rd

; 2142 :         if (CodeInfo->token >= T_VCMPEQPD && CodeInfo->token <= T_VCMPTRUE_USSS){

	cmp	eax, 1809				; 00000711H
	jl	SHORT $LN23@output_3rd
	cmp	eax, 1936				; 00000790H
	jg	SHORT $LN23@output_3rd

; 2143 :           CodeInfo->opnd[OPND3].InsFixup = NULL;

	mov	QWORD PTR [rcx+96], 0

; 2144 :           OutputCodeByte((CodeInfo->token - T_VCMPEQPD) & 0x1F);

	lea	ecx, DWORD PTR [rax+15]
	and	cl, 31

; 2201 :     }
; 2202 : #endif
; 2203 :     return;
; 2204 : }

	add	rsp, 40					; 00000028H
	jmp	OutputByte
$LN23@output_3rd:

; 2145 :           return;
; 2146 :         }
; 2147 :         else if (CodeInfo->token >= T_VPCMPEQD && CodeInfo->token <= T_VPCMPTRUED){

	cmp	eax, 2027				; 000007ebH
	jl	SHORT $LN21@output_3rd
	cmp	eax, 1501				; 000005ddH

; 2148 :           CodeInfo->opnd[OPND3].InsFixup = NULL;
; 2149 :           OutputCodeByte((CodeInfo->token - T_VPCMPEQD) & 0x07);

	jle	$LN34@output_3rd
$LN21@output_3rd:

; 2150 :           return;
; 2151 :         }
; 2152 :         else if (CodeInfo->token >= T_VPCMPEQUD && CodeInfo->token <= T_VPCMPTRUEUD){

	cmp	eax, 1502				; 000005deH
	jl	SHORT $LN19@output_3rd
	cmp	eax, 1509				; 000005e5H
	jg	SHORT $LN19@output_3rd

; 2153 :           CodeInfo->opnd[OPND3].InsFixup = NULL;

	mov	QWORD PTR [rcx+96], 0

; 2154 :           OutputCodeByte((CodeInfo->token - T_VPCMPEQUD) & 0x07);

	lea	ecx, DWORD PTR [rax+2]
	and	cl, 7

; 2201 :     }
; 2202 : #endif
; 2203 :     return;
; 2204 : }

	add	rsp, 40					; 00000028H
	jmp	OutputByte
$LN19@output_3rd:

; 2155 :           return;
; 2156 :         }
; 2157 :         else if (CodeInfo->token >= T_VPCMPEQQ && CodeInfo->token <= T_VPCMPTRUEQ){

	cmp	eax, 2028				; 000007ecH
	jl	SHORT $LN17@output_3rd
	cmp	eax, 1516				; 000005ecH
	jg	SHORT $LN17@output_3rd
$LN35@output_3rd:

; 2158 :           CodeInfo->opnd[OPND3].InsFixup = NULL;

	mov	QWORD PTR [rcx+96], 0

; 2159 :           OutputCodeByte((CodeInfo->token - T_VPCMPEQQ) & 0x07);

	lea	ecx, DWORD PTR [rax-4]
	and	cl, 7

; 2201 :     }
; 2202 : #endif
; 2203 :     return;
; 2204 : }

	add	rsp, 40					; 00000028H
	jmp	OutputByte
$LN17@output_3rd:

; 2160 :           return;
; 2161 :         }
; 2162 :         else if (CodeInfo->token >= T_VPCMPEQUQ && CodeInfo->token <= T_VPCMPTRUEUQ){

	cmp	eax, 1517				; 000005edH
	jl	SHORT $LN15@output_3rd
	cmp	eax, 1524				; 000005f4H
	jg	SHORT $LN15@output_3rd

; 2163 :           CodeInfo->opnd[OPND3].InsFixup = NULL;

	mov	QWORD PTR [rcx+96], 0

; 2164 :           OutputCodeByte((CodeInfo->token - T_VPCMPEQUQ) & 0x07);

	lea	ecx, DWORD PTR [rax+3]
	and	cl, 7

; 2201 :     }
; 2202 : #endif
; 2203 :     return;
; 2204 : }

	add	rsp, 40					; 00000028H
	jmp	OutputByte
$LN15@output_3rd:

; 2165 :           return;
; 2166 :         }
; 2167 :         else if (CodeInfo->token >= T_VPCMPEQW && CodeInfo->token <= T_VPCMPTRUEW){

	cmp	eax, 2026				; 000007eaH
	jl	SHORT $LN13@output_3rd
	cmp	eax, 1531				; 000005fbH
	jg	SHORT $LN13@output_3rd

; 2168 :           CodeInfo->opnd[OPND3].InsFixup = NULL;

	mov	QWORD PTR [rcx+96], 0

; 2169 :           OutputCodeByte((CodeInfo->token - T_VPCMPEQW) & 0x07);

	lea	ecx, DWORD PTR [rax-2]
	and	cl, 7

; 2201 :     }
; 2202 : #endif
; 2203 :     return;
; 2204 : }

	add	rsp, 40					; 00000028H
	jmp	OutputByte
$LN13@output_3rd:

; 2170 :           return;
; 2171 :         }
; 2172 :         else if (CodeInfo->token >= T_VPCMPEQUW && CodeInfo->token <= T_VPCMPTRUEUW){

	cmp	eax, 1532				; 000005fcH
	jl	SHORT $LN11@output_3rd
	cmp	eax, 1539				; 00000603H

; 2173 :           CodeInfo->opnd[OPND3].InsFixup = NULL;
; 2174 :           OutputCodeByte((CodeInfo->token - T_VPCMPEQUW) & 0x07);

	jle	SHORT $LN35@output_3rd
$LN11@output_3rd:

; 2175 :           return;
; 2176 :         }
; 2177 :         else if (CodeInfo->token >= T_VPCMPEQB && CodeInfo->token <= T_VPCMPTRUEB){

	cmp	eax, 2025				; 000007e9H
	jl	SHORT $LN9@output_3rd
	cmp	eax, 1546				; 0000060aH
	jg	SHORT $LN9@output_3rd

; 2178 :           CodeInfo->opnd[OPND3].InsFixup = NULL;

	mov	QWORD PTR [rcx+96], 0

; 2179 :           OutputCodeByte((CodeInfo->token - T_VPCMPEQB) & 0x07);

	lea	ecx, DWORD PTR [rax-1]
	and	cl, 7

; 2201 :     }
; 2202 : #endif
; 2203 :     return;
; 2204 : }

	add	rsp, 40					; 00000028H
	jmp	OutputByte
$LN9@output_3rd:

; 2180 :           return;
; 2181 :         }
; 2182 :         else if (CodeInfo->token >= T_VPCMPEQUB && CodeInfo->token <= T_VPCMPTRUEUB){

	cmp	eax, 1547				; 0000060bH
	jl	SHORT $LN6@output_3rd
	cmp	eax, 1554				; 00000612H
	jg	SHORT $LN6@output_3rd
$LN34@output_3rd:

; 2183 :           CodeInfo->opnd[OPND3].InsFixup = NULL;

	mov	QWORD PTR [rcx+96], 0

; 2184 :           OutputCodeByte((CodeInfo->token - T_VPCMPEQUB) & 0x07);

	lea	ecx, DWORD PTR [rax-3]
	and	cl, 7

; 2201 :     }
; 2202 : #endif
; 2203 :     return;
; 2204 : }

	add	rsp, 40					; 00000028H
	jmp	OutputByte
$LN24@output_3rd:

; 2185 :           return;
; 2186 :       }
; 2187 :     }
; 2188 :     else
; 2189 : #endif
; 2190 :           CodeInfo->opnd[OPND3].data32l = ( CodeInfo->token - T_CMPEQPD ) % 8;

	add	eax, -884				; fffffffffffffc8cH
	cdq
	and	edx, 7
	add	eax, edx
	and	eax, 7
	sub	eax, edx
	mov	DWORD PTR [rcx+88], eax
$LN6@output_3rd:

; 2191 :           CodeInfo->opnd[OPND3].InsFixup = NULL;

	mov	QWORD PTR [rcx+96], 0

; 2192 :           output_data( CodeInfo, OP_I8, OPND3 );
; 2193 :     }
; 2194 : #if AVXSUPP
; 2195 :     else if( ((CodeInfo->token >= VEX_START) && (CodeInfo->token < T_VPGATHERDD)|| 

	jmp	SHORT $LN32@output_3rd
$LN25@output_3rd:

; 2196 :       (CodeInfo->token > T_VGATHERQPS))&&
; 2197 :        opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type_3rd == OP3_XMM0 ) {

	cmp	eax, 1304				; 00000518H
	jl	SHORT $LN2@output_3rd
	cmp	eax, 1365				; 00000555H
	jl	SHORT $LN3@output_3rd
$LN2@output_3rd:
	cmp	eax, 1372				; 0000055cH
	jle	SHORT $LN1@output_3rd
$LN3@output_3rd:
	cmp	dl, 3
	jne	SHORT $LN1@output_3rd

; 2198 :         CodeInfo->opnd[OPND3].data32l = ( CodeInfo->opnd[OPND3].data32l << 4 );

	shl	DWORD PTR [rcx+88], 4

; 2199 :         if (CodeInfo->opnd[OPND3].type != OP_K)

	cmp	DWORD PTR [rcx+80], 64			; 00000040H
	je	SHORT $LN1@output_3rd
$LN32@output_3rd:

; 2200 :         output_data( CodeInfo, OP_I8, OPND3 );

	mov	edx, 131072				; 00020000H
	mov	r8d, 2
	call	output_data
$LN1@output_3rd:

; 2201 :     }
; 2202 : #endif
; 2203 :     return;
; 2204 : }

	add	rsp, 40					; 00000028H
	ret	0
output_3rd_operand ENDP
_TEXT	ENDS
EXTRN	OperandSize:NEAR
xdata	SEGMENT
$unwind$match_phase_3 DD 092f01H
	DD	09742fH
	DD	08641bH
	DD	075412H
	DD	06340dH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$match_phase_3 DD @imagerel(match_phase_3#)
	DD	@imagerel(match_phase_3#+1280)
	DD	@imagerel($unwind$match_phase_3#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
CodeInfo$ = 48
opnd1$ = 56
match_phase_3 PROC NEAR

; 2214 : {

	sub	rsp, 40					; 00000028H

; 2215 :     enum operand_type    determinant = opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[OPND1]; /* remember first op type */

	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	movzx	r8d, BYTE PTR [rax]
	mov	QWORD PTR [rsp+64], rsi
	lea	rbp, OFFSET FLAT:__ImageBase
	lea	rax, QWORD PTR [r8+r8*2]

; 2216 :     enum operand_type    opnd2 = CodeInfo->opnd[OPND2].type;
; 2217 :     enum operand_type    tbl_op2;
; 2218 : 
; 2219 :     DebugMsg1(("match_phase_3 enter, opnd1=%" I32_SPEC "X, searching op2=%" I32_SPEC "X\n", opnd1, opnd2 ));
; 2220 :     
; 2221 : #if AVXSUPP 
; 2222 :                                
; 2223 :     if ( CodeInfo->token >= VEX_START && ( vex_flags[ CodeInfo->token - VEX_START ] & VX_L ) ) {

	movsxd	r8, DWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+72], rdi
	cmp	r8d, 1304				; 00000518H
	mov	edi, DWORD PTR [rcx+56]
	mov	r10d, DWORD PTR opnd_clstab[rbp+rax*4]
	mov	esi, edx
	mov	rbx, rcx
	jl	SHORT $LN102@match_phas
	movzx	ecx, BYTE PTR vex_flags[r8+rbp-1304]
	test	cl, 1
	je	SHORT $LN102@match_phas

; 2224 :         if ( CodeInfo->opnd[OPND1].type & (OP_K | OP_YMM | OP_ZMM | OP_M256) ) {

	mov	eax, DWORD PTR [rbx+32]
	test	eax, 268435904				; 100001c0H
	je	SHORT $LN66@match_phas

; 2225 :             if ( opnd2 & OP_ZMM || opnd2 & OP_YMM || opnd2 & OP_K)

	bt	edi, 8
	jb	SHORT $LN64@match_phas
	test	dil, dil
	js	SHORT $LN64@match_phas
	test	dil, 64					; 00000040H
	jne	SHORT $LN64@match_phas

; 2227 :             else if ( opnd2 & OP_M256 )

	bt	edi, 28
	jae	SHORT $LN62@match_phas

; 2228 :                 opnd2 |= OP_M128;

	bts	edi, 27
	jmp	SHORT $LN102@match_phas
$LN62@match_phas:

; 2229 :             else if ( opnd2 & OP_M128 )

	bt	edi, 27
	jae	SHORT $LN60@match_phas

; 2230 :                 opnd2 |= OP_M64;               //should be: ins->prefix & VX_HALF)

	bts	edi, 26
	jmp	SHORT $LN102@match_phas
$LN60@match_phas:

; 2231 :             else if ( ( opnd2 & OP_XMM ) && !( vex_flags[ CodeInfo->token - VEX_START ] & VX_HALF ) ) {

	test	dil, 32					; 00000020H
	je	SHORT $LN102@match_phas
	test	cl, 32					; 00000020H
	jne	SHORT $LN102@match_phas

; 2232 :                 EmitError( INSTRUCTION_OR_REGISTER_NOT_ACCEPTED_IN_CURRENT_CPU_MODE );

	mov	ecx, 30
	call	EmitError

; 2233 :                 return( ERROR );

	jmp	$LN103@match_phas
$LN64@match_phas:

; 2226 :                 opnd2 |= OP_XMM;

	or	edi, 32					; 00000020H

; 2234 :             }

	jmp	SHORT $LN102@match_phas
$LN66@match_phas:

; 2235 :         }
; 2236 : #if 1
; 2237 :         /* may be necessary to cover the cases where the first operand is a memory operand
; 2238 :          * "without size" and the second operand is a ymm register
; 2239 :          */
; 2240 :         else if ( CodeInfo->opnd[OPND1].type == OP_M ) {

	cmp	eax, -1887436800			; ffffffff8f800000H
	jne	SHORT $LN102@match_phas

; 2241 :             if ( opnd2 & OP_YMM || opnd2 & OP_ZMM)

	test	dil, dil
	js	SHORT $LN54@match_phas
	bt	edi, 8
	jae	SHORT $LN102@match_phas
$LN54@match_phas:

; 2242 :                 opnd2 |= OP_XMM;

	or	edi, 32					; 00000020H
$LN102@match_phas:
	mov	r11d, 655360				; 000a0000H
$LL53@match_phas:

; 2243 :         }
; 2244 : #endif
; 2245 :     }
; 2246 : #endif
; 2247 :     do  {
; 2248 :         tbl_op2 = opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[OPND2];

	mov	r9, QWORD PTR [rbx+16]
	movzx	eax, BYTE PTR [r9]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	edx, DWORD PTR opnd_clstab[rbp+rcx*4+4]

; 2249 :         DebugMsg1(("match_phase_3: instr table op2=%" I32_SPEC "X\n", tbl_op2 ));
; 2250 :         switch( tbl_op2 ) {

	cmp	edx, 131072				; 00020000H
	je	$LN24@match_phas
	cmp	edx, 917504				; 000e0000H
	je	$LN48@match_phas
	cmp	edx, 4325376				; 00420000H
	je	$LN15@match_phas
	cmp	edx, 5111808				; 004e0000H
	je	$LN31@match_phas

; 2382 :                }
; 2383 :             }
; 2384 :             break;
; 2385 :         default:
; 2386 :             /* v2.06: condition made more restrictive */
; 2387 :             if (CodeInfo->token < T_VBROADCASTSS)(CodeInfo->evex_flag = 0);

	cmp	r8d, 1304				; 00000518H
	jge	SHORT $LN11@match_phas
	mov	BYTE PTR [rbx+136], 0
$LN11@match_phas:

; 2388 :             //if( ( opnd2 & tbl_op2 ) || (CodeInfo->mem_type == MT_EMPTY && (opnd2 & OP_M_ANY) && (tbl_op2 & OP_M_ANY) )) {
; 2389 :               if ((opnd2 & tbl_op2) || ((CodeInfo->evex_flag)&&(CodeInfo->token < T_VPBROADCASTB) || (CodeInfo->token > T_VPBROADCASTQ))) {     // 

	test	edx, edi
	jne	SHORT $LN8@match_phas
	cmp	BYTE PTR [rbx+136], 0
	je	SHORT $LN7@match_phas
	cmp	r8d, 1308				; 0000051cH
	jl	SHORT $LN8@match_phas
$LN7@match_phas:
	cmp	r8d, 1311				; 0000051fH
	jle	$LN16@match_phas
$LN8@match_phas:

; 2390 :                 if( check_3rd_operand( CodeInfo ) == ERROR )

	movzx	eax, BYTE PTR [r9]
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR opnd_clstab[rbp+rcx*4+8]
	test	al, al
	je	$LN85@match_phas
	cmp	al, 5
	je	$LN85@match_phas
	movzx	ecx, al
	dec	ecx
	je	$LN82@match_phas
	dec	ecx
	je	SHORT $LN80@match_phas
	dec	ecx
	je	SHORT $LN73@match_phas
	dec	ecx
	jne	$LN16@match_phas
	test	DWORD PTR [rbx+80], 917504		; 000e0000H
	jne	SHORT $LN99@match_phas
	jmp	$LN16@match_phas
$LN73@match_phas:
	cmp	r8d, 1304				; 00000518H
	jge	SHORT $LN99@match_phas
	cmp	DWORD PTR [rbx+80], 32			; 00000020H
	jne	$LN16@match_phas
	cmp	DWORD PTR [rbx+88], 0
	je	SHORT $LN99@match_phas
	jmp	$LN16@match_phas
$LN80@match_phas:
	test	DWORD PTR [rbx+80], 917504		; 000e0000H
	je	$LN16@match_phas
	mov	eax, DWORD PTR [rbx+88]
	cmp	eax, -128				; ffffffffffffff80H
	jl	$LN16@match_phas
	cmp	r8d, 621				; 0000026dH
	jne	$LN100@match_phas
	cmp	eax, 128				; 00000080H
	jge	$LN16@match_phas
$LN77@match_phas:
	mov	DWORD PTR [rbx+80], 131072		; 00020000H
$LN99@match_phas:

; 2392 :                 DebugMsg1(("match_phase_3: matched opnd2\n" ));
; 2393 :                 output_opc( CodeInfo );

	mov	rcx, rbx
	call	output_opc

; 2394 :                 if ( opnd1 & (OP_I_ANY | OP_M_ANY ) )

	test	esi, -4325376				; ffffffffffbe0000H
	je	SHORT $LN5@match_phas

; 2395 :                     output_data( CodeInfo, opnd1, OPND1 );

	xor	r8d, r8d
	mov	edx, esi
	mov	rcx, rbx
	call	output_data
$LN5@match_phas:

; 2396 :                 if ( opnd2 & (OP_I_ANY | OP_M_ANY ) )

	test	edi, -4325376				; ffffffffffbe0000H
	je	SHORT $LN4@match_phas

; 2397 :                     output_data( CodeInfo, opnd2, OPND2 );

	mov	r8d, 1
	mov	edx, edi
	mov	rcx, rbx
	call	output_data
$LN4@match_phas:

; 2398 :                 //if( CodeInfo->pinstr->opnd_type_3rd != OP3_NONE )
; 2399 :                 if( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type_3rd != OP3_NONE )

	mov	rax, QWORD PTR [rbx+16]
	movzx	ecx, BYTE PTR [rax]
	lea	rax, QWORD PTR [rcx+rcx*2]
	cmp	BYTE PTR opnd_clstab[rbp+rax*4+8], 0
	je	SHORT $LN3@match_phas

; 2400 :                     output_3rd_operand( CodeInfo );

	mov	rcx, rbx
	call	output_3rd_operand
$LN3@match_phas:

; 2401 :                 if( CodeInfo->pinstr->byte1_info == F_0F0F ) /* output 3dNow opcode? */

	mov	rax, QWORD PTR [rbx+16]
	cmp	BYTE PTR [rax+1], 17
	jne	SHORT $LN2@match_phas

; 2402 :                     OutputCodeByte( CodeInfo->pinstr->opcode | CodeInfo->iswide );

	movzx	ecx, BYTE PTR [rbx+142]
	and	cl, 1
	or	cl, BYTE PTR [rax+12]
	call	OutputByte
$LN2@match_phas:

; 2403 :                 return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN68@match_phas
$LN100@match_phas:

; 2390 :                 if( check_3rd_operand( CodeInfo ) == ERROR )

	cmp	eax, 256				; 00000100H
	jl	$LN77@match_phas
	jmp	$LN16@match_phas
$LN82@match_phas:
	cmp	DWORD PTR [rbx+80], 1025		; 00000401H
	je	$LN99@match_phas
	jmp	$LN16@match_phas
$LN85@match_phas:
	mov	eax, DWORD PTR [rbx+80]
	neg	eax
	sbb	ecx, ecx
	cmp	ecx, -1
	jne	$LN99@match_phas

; 2391 :                     break;

	jmp	$LN16@match_phas
$LN31@match_phas:

; 2317 :             }
; 2318 :             break;
; 2319 :         case OP_I8_U: /* shift+rotate, ENTER, BTx, IN, PSxx[D|Q|W] */
; 2320 :             if( opnd2 & tbl_op2 ) {

	test	edi, 5111808				; 004e0000H
	je	$LN16@match_phas

; 2321 :                 DebugMsg1(("match_phase_3: matched OP_I8_U\n"));
; 2322 :                 if ( CodeInfo->const_size_fixed && opnd2 != OP_I8 )

	test	BYTE PTR [rbx+142], 8
	je	SHORT $LN29@match_phas
	cmp	edi, 131072				; 00020000H
	jne	$LN16@match_phas
$LN29@match_phas:

; 2323 :                     break;
; 2324 :                 /* v2.03: lower bound wasn't checked */
; 2325 :                 /* range of unsigned 8-bit is -128 - +255 */
; 2326 :                 if( CodeInfo->opnd[OPND2].data32l <= UCHAR_MAX && CodeInfo->opnd[OPND2].data32l >= SCHAR_MIN ) {

	mov	eax, DWORD PTR [rbx+64]
	cmp	eax, 255				; 000000ffH
	jg	$LN16@match_phas
	cmp	eax, -128				; ffffffffffffff80H
	jl	$LN16@match_phas

; 2327 :                     /* v2.06: if there's an external, adjust the fixup if it is > 8-bit */
; 2328 :                     if ( CodeInfo->opnd[OPND2].InsFixup != NULL ) {

	mov	rax, QWORD PTR [rbx+72]
	test	rax, rax
	je	SHORT $LN26@match_phas

; 2329 :                         if ( CodeInfo->opnd[OPND2].InsFixup->type == FIX_OFF16 ||
; 2330 :                             CodeInfo->opnd[OPND2].InsFixup->type == FIX_OFF32 )

	mov	ecx, DWORD PTR [rax+24]
	cmp	ecx, 5
	je	SHORT $LN25@match_phas
	cmp	ecx, 6
	jne	SHORT $LN26@match_phas
$LN25@match_phas:

; 2331 :                             CodeInfo->opnd[OPND2].InsFixup->type = FIX_OFF8;

	mov	DWORD PTR [rax+24], 4
$LN26@match_phas:

; 2332 :                     }
; 2333 :                     /* the SSE4A EXTRQ instruction will need this! */
; 2334 :                     //if( check_3rd_operand( CodeInfo ) == ERROR )
; 2335 :                     //  break;
; 2336 :                     output_opc( CodeInfo );

	mov	rcx, rbx
	call	output_opc

; 2337 :                     output_data( CodeInfo, opnd1, OPND1 );

	xor	r8d, r8d
	mov	edx, esi
	mov	rcx, rbx
	call	output_data

; 2338 :                     output_data( CodeInfo, OP_I8, OPND2 );

	mov	edx, 131072				; 00020000H
	mov	r8d, 1
	mov	rcx, rbx
	call	output_data

; 2339 :                     //if( CodeInfo->pinstr->opnd_type_3rd != OP3_NONE )
; 2340 :                     //output_3rd_operand( CodeInfo );
; 2341 :                     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN68@match_phas
$LN15@match_phas:

; 2367 :                 DebugMsg1(("match_phase_3: matched OP_I8\n"));
; 2368 :                 output_opc( CodeInfo );
; 2369 :                 output_data( CodeInfo, opnd1, OPND1 );
; 2370 :                 output_data( CodeInfo, OP_I8, OPND2 );
; 2371 :                 return( NOT_ERROR );
; 2372 :             }
; 2373 :             break;
; 2374 :         case OP_I_1: /* shift ops */
; 2375 :             if( opnd2 & tbl_op2 ) {

	test	edi, 4325376				; 00420000H
	je	$LN16@match_phas

; 2376 :                if ( CodeInfo->opnd[OPND2].data32l == 1 ) {

	cmp	DWORD PTR [rbx+64], 1
	jne	$LN16@match_phas

; 2377 :                    DebugMsg1(("match_phase_3: matched OP_I_1\n"));
; 2378 :                    output_opc( CodeInfo );

	mov	rcx, rbx
	call	output_opc

; 2379 :                    output_data( CodeInfo, opnd1, OPND1 );

	xor	r8d, r8d
	mov	edx, esi
	mov	rcx, rbx
	call	output_data

; 2380 :                    /* the immediate is "implicite" */
; 2381 :                    return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN68@match_phas
$LN48@match_phas:

; 2251 :         case OP_I: /* arith, MOV, IMUL, TEST */
; 2252 :             if( opnd2 & tbl_op2 ) {

	test	edi, 917504				; 000e0000H
	je	$LN16@match_phas

; 2253 :                 DebugMsg1(("match_phase_3: matched OP_I\n"));
; 2254 :                 /* This branch exits with either ERROR or NOT_ERROR.
; 2255 :                  * So it can modify the CodeInfo fields without harm.
; 2256 :                  */
; 2257 :                 if( opnd1 & OP_R8 ) {

	test	sil, 1
	je	$LN46@match_phas

; 2258 :                     /* 8-bit register, so output 8-bit data */
; 2259 :                     /* v2.04: the check has already happened in check_size() or idata_xxx() */
; 2260 :                     //if( Parse_Pass == PASS_1 && !InRange( operand, 1 ) ) {
; 2261 :                     //    DebugMsg(("imm const too large (08): %X\n", operand));
; 2262 :                     //    EmitWarn( 1, IMMEDIATE_CONSTANT_TOO_LARGE );
; 2263 :                     //}
; 2264 :                     CodeInfo->prefix.opsiz = FALSE;
; 2265 :                     opnd2 = OP_I8;
; 2266 :                     if( CodeInfo->opnd[OPND2].InsFixup != NULL ) {

	mov	rax, QWORD PTR [rbx+72]
	and	BYTE PTR [rbx+9], 253			; 000000fdH
	mov	edi, 131072				; 00020000H
	test	rax, rax
	je	$LN36@match_phas

; 2267 :                     /* v1.96: make sure FIX_HIBYTE isn't overwritten! */
; 2268 :                         if ( CodeInfo->opnd[OPND2].InsFixup->type != FIX_HIBYTE )

	cmp	DWORD PTR [rax+24], 11
	je	$LN36@match_phas

; 2269 :                             CodeInfo->opnd[OPND2].InsFixup->type = FIX_OFF8;

	mov	DWORD PTR [rax+24], 4

; 2270 :                     }

	jmp	$LN36@match_phas
$LN24@match_phas:

; 2342 :                 }
; 2343 :             }
; 2344 :             break;
; 2345 :         case OP_I8: /* arith, IMUL */
; 2346 :             /* v2.06: this case has been rewritten */
; 2347 : 
; 2348 :             /* v2.04: added */
; 2349 :             if( ModuleInfo.NoSignExtend &&
; 2350 :                ( CodeInfo->token == T_AND ||
; 2351 :                 CodeInfo->token == T_OR ||
; 2352 :                 CodeInfo->token == T_XOR ) )

	bt	DWORD PTR ModuleInfo+408, 19
	jae	SHORT $LN23@match_phas
	cmp	r8d, 509				; 000001fdH
	je	SHORT $LN16@match_phas
	cmp	r8d, 506				; 000001faH
	je	SHORT $LN16@match_phas
	cmp	r8d, 511				; 000001ffH

; 2353 :                 break;

	je	SHORT $LN16@match_phas
$LN23@match_phas:

; 2354 : 
; 2355 :             /* v2.11: skip externals - but don't skip undefines; forward8.asm */
; 2356 :             //if ( CodeInfo->opnd[OPND2].InsFixup != NULL ) /* external? then skip */
; 2357 :             if ( CodeInfo->opnd[OPND2].InsFixup != NULL && CodeInfo->opnd[OPND2].InsFixup->sym->state != SYM_UNDEFINED ) /* external? then skip */

	mov	rax, QWORD PTR [rbx+72]
	test	rax, rax
	je	SHORT $LN21@match_phas
	mov	rax, QWORD PTR [rax+56]
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN16@match_phas
$LN21@match_phas:

; 2358 :                 break;
; 2359 : 
; 2360 :             if ( CodeInfo->const_size_fixed == FALSE )

	test	BYTE PTR [rbx+142], 8
	jne	SHORT $LN17@match_phas

; 2361 :                 if ( ( opnd1 & ( OP_R16 | OP_M16 ) ) && (int_8)CodeInfo->opnd[OPND2].data32l == (int_16)CodeInfo->opnd[OPND2].data32l )

	test	esi, 16777218				; 01000002H
	je	SHORT $LN19@match_phas
	movsx	eax, BYTE PTR [rbx+64]
	cmp	ax, WORD PTR [rbx+64]
	jne	SHORT $LN19@match_phas

; 2362 :                     tbl_op2 |= OP_I16;

	mov	edx, 393216				; 00060000H
	jmp	SHORT $LN17@match_phas
$LN19@match_phas:

; 2363 :                 else if ( ( opnd1 & ( OP_RGT16 | OP_MGT16 ) ) && (int_8)CodeInfo->opnd[OPND2].data32l == (int_32)CodeInfo->opnd[OPND2].data32l )

	test	esi, 100663308				; 0600000cH
	je	SHORT $LN17@match_phas
	movsx	eax, BYTE PTR [rbx+64]
	cmp	eax, DWORD PTR [rbx+64]
	cmove	edx, r11d
$LN17@match_phas:

; 2364 :                     tbl_op2 |= OP_I32;
; 2365 : 
; 2366 :             if( opnd2 & tbl_op2 ) {

	test	edx, edi
	jne	$LN26@match_phas
$LN16@match_phas:

; 2404 :             }
; 2405 :             break;
; 2406 :         }
; 2407 :         CodeInfo->pinstr++;

	lea	rdx, QWORD PTR [r9+14]
	mov	QWORD PTR [rbx+16], rdx

; 2408 :     } while ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[OPND1] == determinant && CodeInfo->pinstr->first == FALSE );

	movzx	eax, BYTE PTR [rdx]
	lea	rcx, QWORD PTR [rax+rax*2]
	cmp	DWORD PTR opnd_clstab[rbp+rcx*4], r10d
	jne	SHORT $LN1@match_phas
	cmp	BYTE PTR [rdx+4], 0
	je	$LL53@match_phas
$LN1@match_phas:

; 2409 :     CodeInfo->pinstr--; /* pointer will be increased in codegen() */

	lea	rax, QWORD PTR [rdx-14]
	mov	QWORD PTR [rbx+16], rax
$LN103@match_phas:

; 2410 :     DebugMsg(("match_phase_3: returns EMPTY\n"));
; 2411 :     return( ERROR );

	mov	eax, -1
$LN68@match_phas:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 2412 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN46@match_phas:

; 2271 :                 } else if( opnd1 & OP_R16 ) {

	test	sil, 2
	je	SHORT $LN42@match_phas

; 2272 :                     /* v2.04: the check has already happened in check_size() or idata_xxx() */
; 2273 :                     //if( Parse_Pass == PASS_1 && !InRange( operand, 2 ) ) {
; 2274 :                     //    DebugMsg(("imm const too large (16): %X\n", operand));
; 2275 :                     //    EmitWarn( 1, IMMEDIATE_CONSTANT_TOO_LARGE );
; 2276 :                     //}
; 2277 :                     /* 16-bit register, so output 16-bit data */
; 2278 :                     opnd2 = OP_I16;

	mov	edi, 262144				; 00040000H
	jmp	$LN36@match_phas
$LN42@match_phas:

; 2279 : #if AMD64_SUPPORT
; 2280 :                 } else if( opnd1 & (OP_R32 | OP_R64 ) ) {

	test	sil, 12
	je	SHORT $LN40@match_phas

; 2281 : #else
; 2282 :                 } else if( opnd1 & OP_R32 ) {
; 2283 : #endif
; 2284 :                     /* 32- or 64-bit register, so output 32-bit data */
; 2285 :                     CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? 0 : 1;/* 12-feb-92 */

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], 0

; 2286 :                     opnd2 = OP_I32;

	mov	edi, 524288				; 00080000H
	sete	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al
	jmp	SHORT $LN36@match_phas
$LN40@match_phas:

; 2287 :                 } else if( opnd1 & OP_M ) {

	test	esi, -1887436800			; ffffffff8f800000H
	je	SHORT $LN36@match_phas

; 2288 :                     /* there is no reason this should be only for T_MOV */
; 2289 :                     switch( OperandSize( opnd1, CodeInfo ) ) {

	mov	rdx, rbx
	mov	ecx, esi
	call	OperandSize
	dec	eax
	je	SHORT $LN35@match_phas
	dec	eax
	je	SHORT $LN34@match_phas
	sub	eax, 2
	je	SHORT $LN33@match_phas
	cmp	eax, 4
	je	SHORT $LN33@match_phas

; 2308 :                     default:
; 2309 :                         EmitError( INVALID_COMBINATION_OF_OPCODE_AND_OPERANDS );

	mov	ecx, 14
	call	EmitError
	jmp	SHORT $LN36@match_phas
$LN33@match_phas:

; 2298 : #if AMD64_SUPPORT
; 2299 :                         /* mov [mem], imm64 doesn't exist. It's ensured that
; 2300 :                          * immediate data is 32bit only
; 2301 :                          */
; 2302 :                     case 8:
; 2303 : #endif
; 2304 :                     case 4:
; 2305 :                         opnd2 = OP_I32;
; 2306 :                         CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? 0 : 1;

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], 0
	mov	edi, 524288				; 00080000H
	sete	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al

; 2307 :                         break;

	jmp	SHORT $LN36@match_phas
$LN34@match_phas:

; 2293 :                         break;
; 2294 :                     case 2:
; 2295 :                         opnd2 = OP_I16;
; 2296 :                         CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? 1 : 0;

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], 0
	mov	edi, 262144				; 00040000H
	setne	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al

; 2297 :                         break;

	jmp	SHORT $LN36@match_phas
$LN35@match_phas:

; 2290 :                     case 1:
; 2291 :                         opnd2 = OP_I8;
; 2292 :                         CodeInfo->prefix.opsiz = FALSE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	mov	edi, 131072				; 00020000H
$LN36@match_phas:

; 2310 :                         //return( ERROR ); /* v2.06: don't exit */
; 2311 :                     }
; 2312 :                 }
; 2313 :                 output_opc( CodeInfo );

	mov	rcx, rbx
	call	output_opc

; 2314 :                 output_data( CodeInfo, opnd1, OPND1 );

	xor	r8d, r8d
	mov	edx, esi
	mov	rcx, rbx
	call	output_data

; 2315 :                 output_data( CodeInfo, opnd2, OPND2 );

	mov	r8d, 1
	mov	edx, edi
	mov	rcx, rbx
	call	output_data

; 2316 :                 return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN68@match_phas
match_phase_3 ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$check_operand_2 DD 051201H
	DD	097412H
	DD	08340dH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$check_operand_2 DD @imagerel(check_operand_2#)
	DD	@imagerel(check_operand_2#+290)
	DD	@imagerel($unwind$check_operand_2#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
CodeInfo$ = 48
opnd1$ = 56
check_operand_2 PROC NEAR

; 2421 : {

	sub	rsp, 40					; 00000028H

; 2422 :     if( CodeInfo->opnd[OPND2].type == OP_NONE ) {

	cmp	DWORD PTR [rcx+56], 0
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx
	mov	ebx, edx
	jne	$LN14@check_oper

; 2423 :       if (opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[OPND2] != OP_NONE){

	mov	rdx, QWORD PTR [rcx+16]
	lea	r9, OFFSET FLAT:opnd_clstab
	movzx	eax, BYTE PTR [rdx]
	lea	r8, QWORD PTR [rax+rax*2]
	cmp	DWORD PTR [r9+r8*4+4], 0
	je	SHORT $LN11@check_oper

; 2424 :         if (CodeInfo->token == T_VGETEXPPD || CodeInfo->token == T_VGETEXPPS)

	mov	eax, DWORD PTR [rcx+24]
	cmp	eax, 1464				; 000005b8H
	je	SHORT $LN11@check_oper
	cmp	eax, 1465				; 000005b9H

; 2425 :           ;
; 2426 :         else
; 2427 :         return(ERROR); /* doesn't match */

	jne	$LN4@check_oper
$LN11@check_oper:

; 2428 :       }
; 2429 :         /* 1 opnd instruction found */
; 2430 : 
; 2431 :         /* v2.06: added check for unspecified size of mem op */
; 2432 :         if ( opnd1 == OP_M ) {

	cmp	ebx, -1887436800			; ffffffff8f800000H
	jne	SHORT $LN7@check_oper

; 2433 :             const struct instr_item *next = CodeInfo->pinstr+1;
; 2434 :             if ( ( opnd_clstab[next->opclsidx].opnd_type[OPND1] & OP_M ) &&
; 2435 :                 next->first == FALSE )

	movzx	eax, BYTE PTR [rdx+14]
	lea	rcx, QWORD PTR [rax+rax*2]
	test	DWORD PTR [r9+rcx*4], ebx
	je	SHORT $LN7@check_oper
	cmp	BYTE PTR [rdx+18], 0
	jne	SHORT $LN7@check_oper

; 2436 :                 /* skip error if mem op is a forward reference */
; 2437 :                 /* v2.06b: added "undefined" check */
; 2438 :                 if ( CodeInfo->undef_sym == FALSE &&
; 2439 :                     ( CodeInfo->opnd[OPND1].InsFixup == NULL ||
; 2440 :                      CodeInfo->opnd[OPND1].InsFixup->sym == NULL ||
; 2441 :                      CodeInfo->opnd[OPND1].InsFixup->sym->state != SYM_UNDEFINED ) ) {

	test	BYTE PTR [rdi+142], 64			; 00000040H
	jne	SHORT $LN7@check_oper
	mov	rax, QWORD PTR [rdi+48]
	test	rax, rax
	je	SHORT $LN6@check_oper
	mov	rcx, QWORD PTR [rax+56]
	test	rcx, rcx
	je	SHORT $LN6@check_oper
	cmp	DWORD PTR [rcx+40], 0
	je	SHORT $LN7@check_oper
$LN6@check_oper:

; 2442 :                     DebugMsg(("check_operand_2: error: undef_sym=%u Fixup[0]=%X [%s]\n",
; 2443 :                               CodeInfo->undef_sym, CodeInfo->opnd[OPND1].InsFixup,
; 2444 :                               CodeInfo->opnd[OPND1].InsFixup ? CodeInfo->opnd[OPND1].InsFixup->sym ? CodeInfo->opnd[OPND1].InsFixup->sym->name : "NULL" : "NULL" ));
; 2445 :                     EmitErr( INSTRUCTION_OPERAND_MUST_HAVE_SIZE );

	mov	ecx, 182				; 000000b6H
	call	EmitErr
$LN7@check_oper:

; 2446 :                 }
; 2447 :         }
; 2448 : 
; 2449 :         output_opc( CodeInfo );

	mov	rcx, rdi
	call	output_opc

; 2450 :         output_data( CodeInfo, opnd1, OPND1 );

	xor	r8d, r8d
	mov	edx, ebx
	mov	rcx, rdi
	call	output_data

; 2451 : #if AMD64_SUPPORT
; 2452 :         if ( CodeInfo->Ofssize == USE64 && CodeInfo->opnd[OPND1].InsFixup && CodeInfo->opnd[OPND1].InsFixup->type == FIX_RELOFF32 )

	cmp	BYTE PTR [rdi+106], 2
	jne	SHORT $LN1@check_oper
	mov	rax, QWORD PTR [rdi+48]

; 2453 :             CodeInfo->opnd[OPND1].InsFixup->addbytes = GetCurrOffset() - CodeInfo->opnd[OPND1].InsFixup->locofs;
; 2454 : #endif
; 2455 :         return( NOT_ERROR );

	jmp	SHORT $LN17@check_oper
$LN14@check_oper:

; 2456 :     }
; 2457 : 
; 2458 :     /* check second operand */
; 2459 :     if ( match_phase_3( CodeInfo, opnd1 ) == NOT_ERROR ) {

	call	match_phase_3
	test	eax, eax
	jne	SHORT $LN4@check_oper

; 2460 : #if AMD64_SUPPORT
; 2461 :         /* for rip-relative fixups, the instruction end is needed */
; 2462 :         if ( CodeInfo->Ofssize == USE64 ) {

	cmp	BYTE PTR [rdi+106], 2
	jne	SHORT $LN1@check_oper

; 2463 :             if ( CodeInfo->opnd[OPND1].InsFixup && CodeInfo->opnd[OPND1].InsFixup->type == FIX_RELOFF32 )

	mov	rax, QWORD PTR [rdi+48]
	test	rax, rax
	je	SHORT $LN2@check_oper
	cmp	DWORD PTR [rax+24], 3
	jne	SHORT $LN2@check_oper

; 2464 :                 CodeInfo->opnd[OPND1].InsFixup->addbytes = GetCurrOffset() - CodeInfo->opnd[OPND1].InsFixup->locofs;

	mov	rbx, rax
	call	GetCurrOffset
	sub	al, BYTE PTR [rbx+20]
	mov	BYTE PTR [rbx+32], al
$LN2@check_oper:

; 2465 :             if ( CodeInfo->opnd[OPND2].InsFixup && CodeInfo->opnd[OPND2].InsFixup->type == FIX_RELOFF32 )

	mov	rax, QWORD PTR [rdi+72]
$LN17@check_oper:
	test	rax, rax
	je	SHORT $LN1@check_oper
	cmp	DWORD PTR [rax+24], 3
	jne	SHORT $LN1@check_oper

; 2466 :                 CodeInfo->opnd[OPND2].InsFixup->addbytes = GetCurrOffset() - CodeInfo->opnd[OPND2].InsFixup->locofs;

	mov	rbx, rax
	call	GetCurrOffset
	sub	al, BYTE PTR [rbx+20]
	mov	BYTE PTR [rbx+32], al
$LN1@check_oper:

; 2467 :         }
; 2468 : #endif
; 2469 :         return( NOT_ERROR );

	xor	eax, eax
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 2472 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@check_oper:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 2470 :     }
; 2471 :     return( ERROR );

	mov	eax, -1

; 2472 : }

	add	rsp, 40					; 00000028H
	ret	0
check_operand_2 ENDP
_TEXT	ENDS
PUBLIC	codegen
EXTRN	LstWrite:NEAR
xdata	SEGMENT
$unwind$codegen DD 051201H
	DD	086412H
	DD	06340dH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$codegen DD @imagerel($LN50#)
	DD	@imagerel($LN50#+82)
	DD	@imagerel($unwind$codegen#)
pdata	ENDS
xdata	SEGMENT
$chain$3$codegen DD 043621H
	DD	075436H
	DD	097405H
	DD	@imagerel($LN50#)
	DD	@imagerel($LN50#+82)
	DD	@imagerel($unwind$codegen#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$codegen DD @imagerel($LN50#+82)
	DD	@imagerel($LN50#+579)
	DD	@imagerel($chain$3$codegen#)
pdata	ENDS
xdata	SEGMENT
$chain$5$codegen DD 040021H
	DD	097400H
	DD	075400H
	DD	@imagerel($LN50#)
	DD	@imagerel($LN50#+82)
	DD	@imagerel($unwind$codegen#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$codegen DD @imagerel($LN50#+579)
	DD	@imagerel($LN50#+615)
	DD	@imagerel($chain$5$codegen#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
CodeInfo$ = 48
oldofs$ = 56
codegen	PROC NEAR

; 2481 : {

$LN50:
	sub	rsp, 40					; 00000028H

; 2482 :     ret_code           retcode = ERROR;
; 2483 :     enum operand_type  opnd1;
; 2484 :     enum operand_type  tbl_op1;
; 2485 :     /* privileged instructions ok? */
; 2486 :     if( ( CodeInfo->pinstr->cpu & P_PM ) > ( ModuleInfo.curr_cpu & P_PM ) ) {

	mov	r8, QWORD PTR [rcx+16]
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+64], rsi
	mov	r9b, BYTE PTR [r8+10]
	mov	r8d, DWORD PTR ModuleInfo+392
	mov	esi, edx
	and	r8d, 8
	and	r9d, 8
	mov	rbx, rcx
	cmp	r9b, r8b
	mov	r10d, -1
	jle	SHORT $LN37@codegen

; 2487 :         EmitError( INSTRUCTION_OR_REGISTER_NOT_ACCEPTED_IN_CURRENT_CPU_MODE );

	lea	ecx, QWORD PTR [r10+31]
	call	EmitError

; 2488 :         return( ERROR );

	mov	eax, -1
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]

; 2584 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN37@codegen:
	mov	QWORD PTR [rsp+72], rdi

; 2489 :     }
; 2490 :     opnd1 = CodeInfo->opnd[OPND1].type;

	mov	edi, DWORD PTR [rcx+32]

; 2491 :     /* if first operand is immediate data, set compatible flags */
; 2492 :     if( opnd1 & OP_I ) {

	test	edi, 917504				; 000e0000H
	je	SHORT $LN33@codegen

; 2493 :         if( opnd1 == OP_I8 ) {

	cmp	edi, 131072				; 00020000H
	jne	SHORT $LN35@codegen

; 2494 :             opnd1 = OP_IGE8;

	mov	edi, 917504				; 000e0000H
	jmp	SHORT $LN33@codegen
$LN35@codegen:

; 2495 :         } else if( opnd1 == OP_I16 ) {

	mov	eax, 786432				; 000c0000H
	cmp	edi, 262144				; 00040000H
	cmove	edi, eax
$LN33@codegen:

; 2496 :             opnd1 = OP_IGE16;
; 2497 :         }
; 2498 :     }
; 2499 : 
; 2500 : #if AVXSUPP 
; 2501 :     //if (CodeInfo->token == T_VPTESTMD)
; 2502 :     //  __debugbreak();
; 2503 : 	if (CodeInfo->token >= VEX_START) {

	movsxd	rcx, DWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+56], rbp
	lea	rbp, OFFSET FLAT:__ImageBase
	cmp	ecx, 1304				; 00000518H
	jl	$LL17@codegen

; 2504 : 		if (vex_flags[CodeInfo->token - VEX_START] & VX_L) {

	movzx	edx, BYTE PTR vex_flags[rcx+rbp-1304]
	test	dl, 1
	je	SHORT $LN26@codegen

; 2505 : 			if (opnd1 & (OP_K | OP_ZMM | OP_YMM | OP_M256 | OP_M512)) {

	test	edi, 805306816				; 300001c0H
	je	SHORT $LN26@codegen

; 2506 : 				if (CodeInfo->opnd[OPND2].type & OP_XMM && !(vex_flags[CodeInfo->token - VEX_START] & VX_HALF)) {

	test	BYTE PTR [rbx+56], 32			; 00000020H
	je	SHORT $LN29@codegen
	test	dl, 32					; 00000020H
	jne	SHORT $LN29@codegen

; 2507 : 					EmitErr(INVALID_INSTRUCTION_OPERANDS);

	mov	ecx, 49					; 00000031H
	call	EmitErr

; 2508 : 					return(ERROR);

	jmp	$LN49@codegen
$LN29@codegen:

; 2509 : 				}
; 2510 : 				if (opnd1 & OP_YMM || opnd1 & OP_K || opnd1 & OP_ZMM)

	test	dil, dil
	js	SHORT $LN27@codegen
	test	dil, 64					; 00000040H
	jne	SHORT $LN27@codegen
	bt	edi, 8
	jb	SHORT $LN27@codegen

; 2512 : 				else
; 2513 : 					opnd1 |= OP_M128;

	bts	edi, 27
	jmp	SHORT $LN26@codegen
$LN27@codegen:

; 2511 : 					opnd1 |= OP_XMM;

	or	edi, 32					; 00000020H
$LN26@codegen:

; 2514 : 			}
; 2515 : 		}
; 2516 : 		/* Here is probably possible to find better solution     */
; 2517 :      if ((CodeInfo->token >= T_VCMPPD && CodeInfo->token <= T_VCMPTRUE_USSS) ||          //1754        1885                  
; 2518 :         (CodeInfo->token >= T_VPCMPD) && (CodeInfo->token <= T_VINSERTI64x4) ||          //1446        1635         
; 2519 :         (CodeInfo->token >= T_VPMOVSXBD) && (CodeInfo->token <= T_VUNPCKLPS) ||          //2007        2077            
; 2520 :         (CodeInfo->token >= T_VPBROADCASTB && CodeInfo->token <= T_VBROADCASTF64x4) ||   //1294        1306
; 2521 :         (CodeInfo->token == T_VCVTPS2PH) || (CodeInfo->token == T_VCVTPH2PS) ||          //1428        1427
; 2522 :         (CodeInfo->token == T_VMOVDDUP) ||                                               //1339        
; 2523 :         (CodeInfo->token >= T_VDBPSADBW) && (CodeInfo->token <= T_VFPCLASSSS) ||         //1642        1646
; 2524 :         (CodeInfo->token >= T_VCVTPD2DQ) && (CodeInfo->token <= T_VMOVDDUP) ||           //1334        1339 
; 2525 :         (CodeInfo->token >= T_VPGATHERDD) && (CodeInfo->token <= T_VSCATTERQPD))

	cmp	ecx, 1805				; 0000070dH
	jl	SHORT $LN23@codegen
	cmp	ecx, 1936				; 00000790H
	jle	SHORT $LN24@codegen
$LN23@codegen:
	cmp	ecx, 1487				; 000005cfH
	jl	SHORT $LN22@codegen
	cmp	ecx, 1682				; 00000692H
	jle	SHORT $LN24@codegen
$LN22@codegen:
	cmp	ecx, 2070				; 00000816H
	jl	SHORT $LN21@codegen
	cmp	ecx, 2141				; 0000085dH
	jle	SHORT $LN24@codegen
$LN21@codegen:
	cmp	ecx, 1308				; 0000051cH
	jl	SHORT $LN20@codegen
	cmp	ecx, 1321				; 00000529H
	jle	SHORT $LN24@codegen
$LN20@codegen:
	cmp	ecx, 1469				; 000005bdH
	je	SHORT $LN24@codegen
	cmp	ecx, 1468				; 000005bcH
	je	SHORT $LN24@codegen
	cmp	ecx, 1364				; 00000554H
	je	SHORT $LN24@codegen
	cmp	ecx, 1689				; 00000699H
	jl	SHORT $LN19@codegen
	cmp	ecx, 1693				; 0000069dH
	jle	SHORT $LN24@codegen
$LN19@codegen:
	cmp	ecx, 1349				; 00000545H
	jl	SHORT $LN18@codegen
	cmp	ecx, 1364				; 00000554H
	jle	SHORT $LN24@codegen
$LN18@codegen:
	cmp	ecx, 1365				; 00000555H
	jl	SHORT $LL17@codegen
	cmp	ecx, 1396				; 00000574H
	jg	SHORT $LL17@codegen
$LN24@codegen:

; 2526 :         opnd1 |= OP_XMM;

	or	edi, 32					; 00000020H
	npad	1
$LL17@codegen:

; 2527 :     }
; 2528 : 
; 2529 : #endif
; 2530 : 
; 2531 : #if AMD64_SUPPORT
; 2532 :     DebugMsg1(("codegen(ofs=%X): %s opnd1=%X codeinfo: ofssize=%u wide=%u rm=%Xh sib=%Xh rex=%Xh opsiz=%u\n",
; 2533 :                CurrSeg->sym.offset, GetResWName( CodeInfo->token, NULL ),
; 2534 :                opnd1, CodeInfo->Ofssize, CodeInfo->iswide,
; 2535 :                CodeInfo->rm_byte, CodeInfo->sib,
; 2536 :                CodeInfo->prefix.rex, CodeInfo->prefix.opsiz ));
; 2537 : #endif
; 2538 :     /* scan the instruction table for a matching first operand */
; 2539 :     do  {
; 2540 :         tbl_op1 = opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[OPND1];

	mov	rax, QWORD PTR [rbx+16]
	movzx	ecx, BYTE PTR [rax]
	lea	rax, QWORD PTR [rcx+rcx*2]
	mov	edx, DWORD PTR opnd_clstab[rbp+rax*4]

; 2541 : 
; 2542 :         //DebugMsg1(("codegen: table.op1=%X\n", tbl_op1 ));
; 2543 :         /* v2.06: simplified */
; 2544 :         if ( tbl_op1 == OP_NONE && opnd1 == OP_NONE ) {

	test	edx, edx
	jne	SHORT $LN14@codegen
	test	edi, edi
	je	$LN41@codegen
$LN14@codegen:

; 2549 :         } else if ( opnd1 & tbl_op1 ) {

	test	edx, edi
	je	SHORT $LN2@codegen

; 2550 :             /* for immediate operands, the idata type has sometimes
; 2551 :              * to be modified in opnd_type[OPND1], to make output_data()
; 2552 :              * emit the correct number of bytes. */
; 2553 :             switch( tbl_op1 ) {

	cmp	edx, 262144				; 00040000H
	je	SHORT $LN8@codegen
	cmp	edx, 524288				; 00080000H
	je	SHORT $LN8@codegen
	cmp	edx, 4325377				; 00420001H
	je	SHORT $LN5@codegen
	cmp	edx, 5111808				; 004e0000H
	je	SHORT $LN7@codegen

; 2568 :             default:
; 2569 :                 retcode = check_operand_2( CodeInfo, CodeInfo->opnd[OPND1].type );

	mov	edx, DWORD PTR [rbx+32]
	mov	rcx, rbx
	call	check_operand_2
	mov	r10d, eax

; 2570 :                 break;

	jmp	SHORT $LN9@codegen
$LN7@codegen:

; 2557 :                 break;
; 2558 :             case OP_I8_U: /* INT xx; OUT xx, AL */
; 2559 :                 if( CodeInfo->opnd[OPND1].data32l <= UCHAR_MAX && CodeInfo->opnd[OPND1].data32l >= SCHAR_MIN ) {

	mov	eax, DWORD PTR [rbx+40]
	cmp	eax, 255				; 000000ffH
	jg	SHORT $LN9@codegen
	cmp	eax, -128				; ffffffffffffff80H
	jl	SHORT $LN9@codegen

; 2560 :                     retcode = check_operand_2( CodeInfo, OP_I8 );

	mov	edx, 131072				; 00020000H
	mov	rcx, rbx
	call	check_operand_2
	mov	r10d, eax

; 2561 :                 }
; 2562 :                 break;

	jmp	SHORT $LN9@codegen
$LN5@codegen:

; 2563 :             case OP_I_3: /* INT 3 */
; 2564 :                 if ( CodeInfo->opnd[OPND1].data32l == 3 ) {

	cmp	DWORD PTR [rbx+40], 3
	jne	SHORT $LN9@codegen

; 2565 :                     retcode = check_operand_2( CodeInfo, OP_NONE );

	xor	edx, edx
	mov	rcx, rbx
	call	check_operand_2
	mov	r10d, eax

; 2566 :                 }
; 2567 :                 break;

	jmp	SHORT $LN9@codegen
$LN8@codegen:

; 2554 :             case OP_I32: /* CALL, JMP, PUSHD */
; 2555 :             case OP_I16: /* CALL, JMP, RETx, ENTER, PUSHW */
; 2556 :                 retcode = check_operand_2( CodeInfo, tbl_op1 );

	mov	rcx, rbx
	call	check_operand_2
	mov	r10d, eax
$LN9@codegen:

; 2571 :             }
; 2572 :             if( retcode == NOT_ERROR) {

	test	r10d, r10d
	je	SHORT $LN43@codegen
$LN2@codegen:

; 2573 :                 if ( CurrFile[LST] )
; 2574 :                     LstWrite( LSTTYPE_CODE, oldofs, NULL );
; 2575 :                 return( NOT_ERROR );
; 2576 :             }
; 2577 :         }
; 2578 :         CodeInfo->pinstr++;

	add	QWORD PTR [rbx+16], 14
	mov	rax, QWORD PTR [rbx+16]

; 2579 :     } while ( CodeInfo->pinstr->first == FALSE );

	cmp	BYTE PTR [rax+4], 0
	je	$LL17@codegen

; 2580 : 
; 2581 :     DebugMsg(("codegen: no matching format found\n"));
; 2582 :     EmitError( INVALID_INSTRUCTION_OPERANDS );

	mov	ecx, 49					; 00000031H
	call	EmitError
$LN49@codegen:

; 2583 :     return( ERROR );

	mov	eax, -1
$LN48@codegen:
	mov	rbp, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]

; 2584 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN41@codegen:

; 2545 :             output_opc( CodeInfo );

	mov	rcx, rbx
	call	output_opc
$LN43@codegen:

; 2546 :             if ( CurrFile[LST] )

	cmp	QWORD PTR ModuleInfo+112, 0
	je	SHORT $LN13@codegen

; 2547 :                 LstWrite( LSTTYPE_CODE, oldofs, NULL );

	xor	r8d, r8d
	mov	edx, esi
	lea	ecx, QWORD PTR [r8+1]
	call	LstWrite
$LN13@codegen:

; 2548 :             return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN48@codegen
codegen	ENDP
_TEXT	ENDS
END
