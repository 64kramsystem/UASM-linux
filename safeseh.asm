; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
$SG5262	DB	'coff', 00H
	ORG $+3
$SG5265	DB	'safeseh', 00H
_DATA	ENDS
PUBLIC	SafeSEHDirective
EXTRN	QAddItem:NEAR
EXTRN	SymCreate:NEAR
EXTRN	ModuleInfo:BYTE
EXTRN	SymFind:NEAR
EXTRN	EmitErr:NEAR
EXTRN	EmitWarn:NEAR
EXTRN	Parse_Pass:DWORD
EXTRN	Options:BYTE
xdata	SEGMENT
$unwind$SafeSEHDirective DD 051501H
	DD	097415H
	DD	086410H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SafeSEHDirective DD @imagerel($LN29#)
	DD	@imagerel($LN29#+105)
	DD	@imagerel($unwind$SafeSEHDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$2$SafeSEHDirective DD 020521H
	DD	073405H
	DD	@imagerel($LN29#)
	DD	@imagerel($LN29#+105)
	DD	@imagerel($unwind$SafeSEHDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$SafeSEHDirective DD @imagerel($LN29#+105)
	DD	@imagerel($LN29#+158)
	DD	@imagerel($chain$2$SafeSEHDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$4$SafeSEHDirective DD 020021H
	DD	073400H
	DD	@imagerel($LN29#)
	DD	@imagerel($LN29#+105)
	DD	@imagerel($unwind$SafeSEHDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$SafeSEHDirective DD @imagerel($LN29#+158)
	DD	@imagerel($LN29#+223)
	DD	@imagerel($chain$4$SafeSEHDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$6$SafeSEHDirective DD 020021H
	DD	073400H
	DD	@imagerel($LN29#)
	DD	@imagerel($LN29#+105)
	DD	@imagerel($unwind$SafeSEHDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$SafeSEHDirective DD @imagerel($LN29#+223)
	DD	@imagerel($LN29#+267)
	DD	@imagerel($chain$6$SafeSEHDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$8$SafeSEHDirective DD 020021H
	DD	073400H
	DD	@imagerel($LN29#)
	DD	@imagerel($LN29#+105)
	DD	@imagerel($unwind$SafeSEHDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$SafeSEHDirective DD @imagerel($LN29#+267)
	DD	@imagerel($LN29#+388)
	DD	@imagerel($chain$8$SafeSEHDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$10$SafeSEHDirective DD 020021H
	DD	073400H
	DD	@imagerel($LN29#)
	DD	@imagerel($LN29#+105)
	DD	@imagerel($unwind$SafeSEHDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$10$SafeSEHDirective DD @imagerel($LN29#+388)
	DD	@imagerel($LN29#+410)
	DD	@imagerel($chain$10$SafeSEHDirective#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\safeseh.c
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
SafeSEHDirective PROC NEAR

; 28   : {

$LN29:
	sub	rsp, 40					; 00000028H

; 29   :     struct asym    *sym;
; 30   :     struct qnode   *node;
; 31   : 
; 32   :     if ( Options.output_format != OFORMAT_COFF ) {

	cmp	DWORD PTR Options+156, 2
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	mov	edi, ecx
	mov	rsi, rdx
	je	SHORT $LN19@SafeSEHDir

; 33   :         if ( Parse_Pass == PASS_1)

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN16@SafeSEHDir

; 34   :             EmitWarn( 2, DIRECTIVE_IGNORED_WITHOUT_X, "coff" );

	lea	r8, OFFSET FLAT:$SG5262

; 35   :         return( NOT_ERROR );

	jmp	SHORT $LN28@SafeSEHDir
$LN19@SafeSEHDir:

; 36   :     }
; 37   :     if ( Options.safeseh == FALSE ) {

	cmp	BYTE PTR Options+151, 0
	jne	SHORT $LN17@SafeSEHDir

; 38   :         if ( Parse_Pass == PASS_1)

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN16@SafeSEHDir

; 39   :             EmitWarn( 2, DIRECTIVE_IGNORED_WITHOUT_X, "safeseh" );

	lea	r8, OFFSET FLAT:$SG5265
$LN28@SafeSEHDir:
	mov	edx, 262				; 00000106H
	mov	ecx, 2
	call	EmitWarn
$LN16@SafeSEHDir:

; 40   :         return( NOT_ERROR );

	xor	eax, eax
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]

; 89   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN17@SafeSEHDir:

; 41   :     }
; 42   :     i++;

	inc	edi
	mov	QWORD PTR [rsp+56], rbx

; 43   :     if ( tokenarray[i].token != T_ID ) {

	movsxd	rbx, edi
	shl	rbx, 5
	cmp	BYTE PTR [rbx+rdx], 8
	je	SHORT $LN15@SafeSEHDir

; 44   :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rbx+rdx+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	mov	rbx, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]

; 89   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN15@SafeSEHDir:

; 45   :     }
; 46   :     sym = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rbx+rdx+8]
	call	SymFind

; 47   : 
; 48   :     /* make sure the argument is a true PROC */
; 49   :     if ( sym == NULL || sym->state == SYM_UNDEFINED ) {

	test	rax, rax
	mov	rdx, rax
	je	SHORT $LN13@SafeSEHDir
	cmp	DWORD PTR [rax+40], 0
	je	SHORT $LN13@SafeSEHDir

; 52   :         }
; 53   :     } else if ( sym->isproc == FALSE ) {

	test	BYTE PTR [rax+49], 8
	jne	SHORT $LN12@SafeSEHDir

; 54   :         return( EmitErr( SAFESEH_ARGUMENT_MUST_BE_A_PROC, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rbx+rsi+8]
	mov	ecx, 261				; 00000105H
	call	EmitErr
	mov	rbx, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]

; 89   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN13@SafeSEHDir:

; 50   :         if ( Parse_Pass != PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN26@SafeSEHDir

; 51   :             return( EmitErr( SYMBOL_NOT_DEFINED, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rbx+rsi+8]
	mov	ecx, 102				; 00000066H
	call	EmitErr
	mov	rbx, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]

; 89   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN12@SafeSEHDir:

; 55   :     }
; 56   : 
; 57   :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN2@SafeSEHDir
$LN26@SafeSEHDir:

; 58   :         if ( sym ) {

	test	rax, rax
	je	SHORT $LN8@SafeSEHDir

; 59   :             for ( node = ModuleInfo.g.SafeSEHQueue.head; node; node = node->next )

	mov	rax, QWORD PTR ModuleInfo+48
	test	rax, rax
	je	SHORT $LN25@SafeSEHDir
$LL7@SafeSEHDir:

; 60   :                 if ( node->elmt == sym )

	cmp	QWORD PTR [rax+8], rdx
	je	SHORT $LN2@SafeSEHDir
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL7@SafeSEHDir

; 61   :                     break;
; 62   :         } else {

	jmp	SHORT $LN25@SafeSEHDir
$LN8@SafeSEHDir:

; 63   :             sym = SymCreate( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rbx+rsi+8]
	call	SymCreate
	mov	rdx, rax
$LN25@SafeSEHDir:

; 64   :             node = NULL;
; 65   :         }
; 66   :         if ( node == NULL ) {
; 67   :             sym->used = TRUE; /* make sure an external reference will become strong */

	or	BYTE PTR [rdx+48], 1

; 68   : #if 0 /* v2.11: use QAddItem() */
; 69   :             node = LclAlloc( sizeof( struct qnode ) );
; 70   :             node->elmt = sym;
; 71   :             node->next = NULL;
; 72   :             if ( ModuleInfo.g.SafeSEHQueue.head == 0 )
; 73   :                 ModuleInfo.g.SafeSEHQueue.head = ModuleInfo.g.SafeSEHQueue.tail = node;
; 74   :             else {
; 75   :                 ((struct qnode *)ModuleInfo.g.SafeSEHQueue.tail)->next = node;
; 76   :                 ModuleInfo.g.SafeSEHQueue.tail = node;
; 77   :             }
; 78   : #else
; 79   :             QAddItem( &ModuleInfo.g.SafeSEHQueue, sym );

	lea	rcx, OFFSET FLAT:ModuleInfo+48
	call	QAddItem
$LN2@SafeSEHDir:

; 80   : #endif
; 81   :         }
; 82   :     }
; 83   :     i++;

	inc	edi

; 84   :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, edi
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rsi], 0
	je	SHORT $LN1@SafeSEHDir

; 85   :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+rsi+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	mov	rbx, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]

; 89   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN1@SafeSEHDir:
	mov	rbx, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]

; 86   :     }
; 87   : 
; 88   :     return( NOT_ERROR );

	xor	eax, eax

; 89   : }

	add	rsp, 40					; 00000028H
	ret	0
SafeSEHDirective ENDP
_TEXT	ENDS
END
