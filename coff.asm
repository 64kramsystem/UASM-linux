; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG6392	DB	01H DUP (?)
	ALIGN	4

$SG6371	DB	01H DUP (?)
	ALIGN	4

$SG6305	DB	01H DUP (?)
	ALIGN	4

?init@?1??CRC32Comdat@@9@9 DB 01H DUP (?)		; `CRC32Comdat'::`2'::init
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
$SG5824	DB	'.debug$S', 00H
	ORG $+7
$SG5825	DB	'.debug$T', 00H
_DATA	ENDS
CONST	SEGMENT
SymDebName DQ	FLAT:$SG5824
	DQ	FLAT:$SG5825
szdrectve DB	'.drectve', 00H
	ORG $+7
isFeat00 DB	'@feat.00'
	DD	01H
	DW	0ffffH
	DW	00H
	DB	03H
	DB	00H
CONST	ENDS
_DATA	SEGMENT
	ORG $+3
$SG5887	DB	'/%u', 00H
$SG5900	DB	'CONST', 00H
	ORG $+2
$SG6008	DB	'.file', 00H
	ORG $+2
$SG6051	DB	'.file', 00H
	ORG $+2
$SG6071	DB	'.bf', 00H
$SG6076	DB	'.lf', 00H
$SG6078	DB	'.ef', 00H
	ORG $+4
$SG6330	DB	'-export:%s ', 00H
	ORG $+4
$SG6333	DB	'-export:%s=%s ', 00H
	ORG $+1
$SG6340	DB	'-defaultlib:"%s" ', 00H
	ORG $+6
$SG6344	DB	'-defaultlib:%s ', 00H
$SG6347	DB	'-entry:%s ', 00H
	ORG $+5
$SG6353	DB	'-import:', 00H
	ORG $+7
$SG6393	DB	'.sxdata', 00H
_DATA	ENDS
EXTRN	LclAlloc:NEAR
xdata	SEGMENT
$unwind$Coff_AllocString DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$Coff_AllocString DD @imagerel(Coff_AllocString#)
	DD	@imagerel(Coff_AllocString#+4)
	DD	@imagerel($unwind$Coff_AllocString#)
pdata	ENDS
xdata	SEGMENT
$chain$2$Coff_AllocString DD 061721H
	DD	097417H
	DD	08640aH
	DD	073405H
	DD	@imagerel(Coff_AllocString#)
	DD	@imagerel(Coff_AllocString#+4)
	DD	@imagerel($unwind$Coff_AllocString#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$Coff_AllocString DD @imagerel(Coff_AllocString#+4)
	DD	@imagerel(Coff_AllocString#+90)
	DD	@imagerel($chain$2$Coff_AllocString#)
pdata	ENDS
xdata	SEGMENT
$chain$3$Coff_AllocString DD 040021H
	DD	097400H
	DD	086400H
	DD	@imagerel(Coff_AllocString#)
	DD	@imagerel(Coff_AllocString#+4)
	DD	@imagerel($unwind$Coff_AllocString#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$Coff_AllocString DD @imagerel(Coff_AllocString#+90)
	DD	@imagerel(Coff_AllocString#+124)
	DD	@imagerel($chain$3$Coff_AllocString#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\coff.c
pdata	ENDS
_TEXT	SEGMENT
cm$ = 48
string$ = 56
len$ = 64
Coff_AllocString PROC NEAR

; 115  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi

; 116  :     struct stringitem *name;
; 117  :     uint_32 oldsize = cm->LongNames.size;

	mov	esi, DWORD PTR [rcx+112]

; 118  : 
; 119  :     cm->LongNames.size += len + 1;

	lea	eax, DWORD PTR [rsi+r8+1]
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx
	mov	DWORD PTR [rcx+112], eax

; 120  :     name = LclAlloc( len + sizeof( struct stringitem ) );

	movsxd	rcx, r8d
	mov	rbx, rdx
	add	rcx, 16
	call	LclAlloc

; 121  :     name->next = NULL;
; 122  :     strcpy( name->string, string );

	lea	rdx, QWORD PTR [rax+8]
	mov	QWORD PTR [rax], 0
	sub	rdx, rbx
	npad	2
$LL5@Coff_Alloc:
	movzx	ecx, BYTE PTR [rbx]
	inc	rbx
	test	cl, cl
	mov	BYTE PTR [rdx+rbx-1], cl
	jne	SHORT $LL5@Coff_Alloc

; 123  :     if ( cm->LongNames.head ) {

	cmp	QWORD PTR [rdi+96], 0
	mov	rbx, QWORD PTR [rsp+56]
	je	SHORT $LN2@Coff_Alloc

; 124  :         cm->LongNames.tail->next = name;

	mov	rcx, QWORD PTR [rdi+104]
	mov	QWORD PTR [rcx], rax

; 125  :         cm->LongNames.tail = name;
; 126  :     } else {

	jmp	SHORT $LN7@Coff_Alloc
$LN2@Coff_Alloc:

; 127  :         cm->LongNames.head = cm->LongNames.tail = name;

	mov	QWORD PTR [rdi+96], rax
$LN7@Coff_Alloc:
	mov	QWORD PTR [rdi+104], rax
	mov	rdi, QWORD PTR [rsp+72]

; 128  :     }
; 129  :     return( oldsize );

	mov	eax, esi
	mov	rsi, QWORD PTR [rsp+64]

; 130  : }

	add	rsp, 40					; 00000028H
	ret	0
Coff_AllocString ENDP
; Function compile flags: /Ogtpy
q$ = 8
GetLinnumItems PROC NEAR

; 137  :     unsigned i;
; 138  :     struct line_num_info *curr;
; 139  : 
; 140  :     for ( i = 0, curr = q->head; curr; i++, curr = curr->next );

	mov	rdx, QWORD PTR [rcx]
	xor	eax, eax
	test	rdx, rdx
	je	SHORT $LN8@GetLinnumI
	npad	6
$LL3@GetLinnumI:
	mov	rdx, QWORD PTR [rdx]
	inc	eax
	test	rdx, rdx
	jne	SHORT $LL3@GetLinnumI
$LN8@GetLinnumI:

; 141  :     return( i );
; 142  : }

	ret	0
GetLinnumItems ENDP
_TEXT	ENDS
EXTRN	WriteError:NEAR
EXTRN	fwrite:NEAR
EXTRN	ModuleInfo:BYTE
EXTRN	sprintf:NEAR
EXTRN	strncpy:NEAR
EXTRN	ConvertSectionName:NEAR
EXTRN	SymTables:BYTE
xdata	SEGMENT
$unwind$coff_write_section_table DD 081c01H
	DD	02dd41cH
	DD	02ec415H
	DD	0326411H
	DD	02f010aH
xdata	ENDS
pdata	SEGMENT
$pdata$coff_write_section_table DD @imagerel(coff_write_section_table#)
	DD	@imagerel(coff_write_section_table#+59)
	DD	@imagerel($unwind$coff_write_section_table#)
pdata	ENDS
xdata	SEGMENT
$chain$7$coff_write_section_table DD 0a1d21H
	DD	033741dH
	DD	0315410H
	DD	030340cH
	DD	02bf408H
	DD	02ce404H
	DD	@imagerel(coff_write_section_table#)
	DD	@imagerel(coff_write_section_table#+59)
	DD	@imagerel($unwind$coff_write_section_table#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$coff_write_section_table DD @imagerel(coff_write_section_table#+59)
	DD	@imagerel(coff_write_section_table#+980)
	DD	@imagerel($chain$7$coff_write_section_table#)
pdata	ENDS
xdata	SEGMENT
$chain$8$coff_write_section_table DD 021H
	DD	@imagerel(coff_write_section_table#)
	DD	@imagerel(coff_write_section_table#+59)
	DD	@imagerel($unwind$coff_write_section_table#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$coff_write_section_table DD @imagerel(coff_write_section_table#+980)
	DD	@imagerel(coff_write_section_table#+1014)
	DD	@imagerel($chain$8$coff_write_section_table#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
ish$ = 32
segtype$ = 72
buffer$ = 80
modinfo$ = 384
cm$ = 392
coff_write_section_table PROC NEAR

; 148  : {

	mov	r11, rsp
	sub	rsp, 376				; 00000178H

; 149  :     struct dsym  *curr;
; 150  :     struct fixup *fix;
; 151  :     uint_32      fileoffset; /* calculated file offset for section data, relocs and linenumber info */
; 152  :     unsigned     len;
; 153  :     char         *secname;
; 154  :     //struct omf_rec  *objr;
; 155  :     //char        *p;
; 156  :     //uint        size_relocs = 0;
; 157  :     enum seg_type segtype;
; 158  :     struct IMAGE_SECTION_HEADER ish;
; 159  :     char buffer[MAX_ID_LEN+1];
; 160  : 
; 161  :     DebugMsg(("coff_write_section_table: enter, sections=%u\n", modinfo->g.num_segs ));
; 162  : 
; 163  :     fileoffset = sizeof( struct IMAGE_FILE_HEADER ) + modinfo->g.num_segs * sizeof( struct IMAGE_SECTION_HEADER );

	mov	eax, DWORD PTR [rcx+8]
	mov	QWORD PTR [r11+24], rsi
	mov	QWORD PTR [r11-8], r12
	lea	ecx, DWORD PTR [rax+rax*4]
	mov	QWORD PTR [r11-16], r13
	mov	r13, rdx
	lea	r12d, DWORD PTR [rcx*8+20]

; 164  :     cm->start_data = fileoffset;

	mov	DWORD PTR [rdx+32], r12d

; 165  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rsi, QWORD PTR SymTables+32
	test	rsi, rsi
	je	$LN58@coff_write
	mov	QWORD PTR [r11-24], r14
	mov	QWORD PTR [r11-32], r15
	mov	QWORD PTR [r11+8], rbx
	mov	QWORD PTR [r11+16], rbp
	xor	r14d, r14d
	mov	r15d, 2560				; 00000a00H
	mov	QWORD PTR [r11+32], rdi
	npad	8
$LL34@coff_write:

; 166  : 
; 167  :         /* v2.04: can't happen */
; 168  :         //if( curr->sym.state != SYM_SEG ) {
; 169  :         //    EmitErr( SEGMENT_NOT_DEFINED, curr->sym.name );
; 170  :         //    continue;
; 171  :         //}
; 172  :         segtype = SEGTYPE_UNDEF;

	mov	DWORD PTR segtype$[rsp], r14d

; 173  :         /* v2.07: prefer ALIAS name if defined. */
; 174  :         secname = ( curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ConvertSectionName( &curr->sym, &segtype, buffer ) );

	mov	rax, QWORD PTR [rsi+104]
	mov	rbx, QWORD PTR [rax+96]
	test	rbx, rbx
	jne	SHORT $LN38@coff_write
	lea	r8, QWORD PTR buffer$[rsp]
	lea	rdx, QWORD PTR segtype$[rsp]
	mov	rcx, rsi
	call	ConvertSectionName
	mov	rbx, rax
$LN38@coff_write:

; 175  :         len = strlen( secname );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	dec	rcx

; 176  :         /* if section name is longer than 8 chars, a '/' is stored,
; 177  :          followed by a number in ascii which is the offset for the string table
; 178  :          */
; 179  :         if ( len <= IMAGE_SIZEOF_SHORT_NAME )

	cmp	ecx, 8
	ja	SHORT $LN31@coff_write

; 180  :             strncpy( ish.Name, secname, IMAGE_SIZEOF_SHORT_NAME );

	lea	r8d, QWORD PTR [rax+8]
	lea	rcx, QWORD PTR ish$[rsp]
	mov	rdx, rbx
	call	strncpy

; 181  :         else

	jmp	SHORT $LN30@coff_write
$LN31@coff_write:

; 182  :             sprintf( ish.Name, "/%u", Coff_AllocString( cm, secname, len ) );

	mov	ebp, DWORD PTR [r13+112]
	lea	eax, DWORD PTR [rbp+rcx+1]
	movsxd	rcx, ecx
	add	rcx, 16
	mov	DWORD PTR [r13+112], eax
	call	LclAlloc
	mov	rdx, rax
	mov	rdi, rax
	sub	rdx, rbx
	mov	QWORD PTR [rax], r14
	npad	9
$LL43@coff_write:
	movzx	ecx, BYTE PTR [rbx]
	inc	rbx
	test	cl, cl
	mov	BYTE PTR [rdx+rbx+7], cl
	jne	SHORT $LL43@coff_write
	cmp	QWORD PTR [r13+96], r14
	je	SHORT $LN40@coff_write
	mov	rax, QWORD PTR [r13+104]
	mov	QWORD PTR [rax], rdi
	mov	QWORD PTR [r13+104], rdi
	jmp	SHORT $LN39@coff_write
$LN40@coff_write:
	mov	QWORD PTR [r13+104], rax
	mov	QWORD PTR [r13+96], rax
$LN39@coff_write:
	lea	rdx, OFFSET FLAT:$SG5887
	lea	rcx, QWORD PTR ish$[rsp]
	mov	r8d, ebp
	call	sprintf
$LN30@coff_write:

; 183  : 
; 184  :         /* v2.04: what is the old line supposed to do? */
; 185  :         //ish.Misc.PhysicalAddress = fileoffset - (size_relocs + sizeof(struct IMAGE_FILE_HEADER) + ModuleInfo->g.num_segs * sizeof(struct IMAGE_SECTION_HEADER));
; 186  :         ish.Misc.PhysicalAddress = 0;

	mov	DWORD PTR ish$[rsp+8], r14d

; 187  :         ish.VirtualAddress = 0;

	mov	DWORD PTR ish$[rsp+12], r14d

; 188  :         ish.SizeOfRawData = curr->sym.max_offset;

	mov	ebx, DWORD PTR [rsi+64]

; 189  :         ish.PointerToRawData = ( ish.SizeOfRawData ? fileoffset : 0 );

	test	ebx, ebx

; 190  :         ish.PointerToRelocations = 0;

	mov	DWORD PTR ish$[rsp+24], r14d

; 191  :         ish.PointerToLinenumbers = 0;

	mov	DWORD PTR ish$[rsp+28], r14d
	mov	DWORD PTR ish$[rsp+16], ebx

; 192  :         ish.NumberOfRelocations = 0;

	mov	WORD PTR ish$[rsp+32], r14w

; 193  :         ish.NumberOfLinenumbers = 0;

	mov	WORD PTR ish$[rsp+34], r14w

; 194  :         ish.Characteristics = 0;

	mov	DWORD PTR ish$[rsp+36], r14d
	mov	r10d, r14d
	mov	edx, r14d
	cmovne	r10d, r12d
	mov	DWORD PTR ish$[rsp+20], r10d

; 195  : 
; 196  :         /* set field Characteristics; optionally reset PointerToRawData/SizeOfRawData */
; 197  :         if ( curr->e.seginfo->info ) {

	mov	rax, QWORD PTR [rsi+104]
	test	BYTE PTR [rax+107], 2
	je	SHORT $LN29@coff_write

; 198  :             /* v2.09: set "remove" flag for .drectve section, as it was done in v2.06 and earlier */
; 199  :             if ( curr == cm->directives )

	cmp	rsi, QWORD PTR [r13]
	mov	edx, 576				; 00000240H
	cmove	edx, r15d
	mov	DWORD PTR ish$[rsp+36], edx

; 200  :                 ish.Characteristics = ( IMAGE_SCN_LNK_INFO | IMAGE_SCN_LNK_REMOVE );
; 201  :             else
; 202  :                 ish.Characteristics = ( IMAGE_SCN_LNK_INFO | IMAGE_SCN_CNT_INITIALIZED_DATA );
; 203  :         } else {

	jmp	$LN13@coff_write
$LN29@coff_write:

; 204  :             if ( curr->e.seginfo->alignment != MAX_SEGALIGNMENT ) /* ABS not possible */

	movzx	eax, BYTE PTR [rax+106]
	cmp	al, 255					; 000000ffH
	je	SHORT $LN25@coff_write

; 205  :                 ish.Characteristics |= (uint_32)(curr->e.seginfo->alignment + 1) << 20;

	movzx	edx, al
	inc	edx
	shl	edx, 20
	mov	DWORD PTR ish$[rsp+36], edx
$LN25@coff_write:

; 206  : #if COMDATSUPP
; 207  :             if ( curr->e.seginfo->comdat_selection )

	mov	rax, QWORD PTR [rsi+104]
	test	BYTE PTR [rax+108], 56			; 00000038H
	je	SHORT $LN24@coff_write

; 208  :                 ish.Characteristics |= IMAGE_SCN_LNK_COMDAT;

	bts	edx, 12
	mov	DWORD PTR ish$[rsp+36], edx
$LN24@coff_write:

; 209  : #endif
; 210  :             if ( curr->e.seginfo->segtype == SEGTYPE_CODE ) {

	mov	r8, QWORD PTR [rsi+104]
	mov	r11d, DWORD PTR [r8+72]
	cmp	r11d, 1
	jne	SHORT $LN23@coff_write

; 211  :                 ish.Characteristics |= IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ;

	or	edx, 1610612768				; 60000020H
	mov	DWORD PTR ish$[rsp+36], edx
	jmp	$LN13@coff_write
$LN23@coff_write:

; 212  :             } else if ( curr->e.seginfo->readonly ) {

	test	BYTE PTR [r8+107], 1
	je	SHORT $LN21@coff_write

; 213  :                 ish.Characteristics |= IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ;

	or	edx, 1073741888				; 40000040H
	mov	DWORD PTR ish$[rsp+36], edx
	jmp	$LN13@coff_write
$LN21@coff_write:

; 214  :             } else if ( curr->e.seginfo->clsym && strcmp( curr->e.seginfo->clsym->name, "CONST" ) == 0 ) {

	mov	rax, QWORD PTR [r8+80]
	test	rax, rax
	je	SHORT $LN19@coff_write
	mov	rax, QWORD PTR [rax+8]
	lea	r9, OFFSET FLAT:$SG5900
	sub	r9, rax
	npad	6
$LL56@coff_write:
	movzx	edi, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r9]
	sub	edi, ecx
	jne	SHORT $LN57@coff_write
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL56@coff_write
$LN57@coff_write:
	test	edi, edi
	jne	SHORT $LN19@coff_write

; 215  :                 ish.Characteristics |= IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ;

	or	edx, 1073741888				; 40000040H
	mov	DWORD PTR ish$[rsp+36], edx
	jmp	SHORT $LN13@coff_write
$LN19@coff_write:

; 216  :             } else if ( curr->e.seginfo->segtype == SEGTYPE_BSS || segtype == SEGTYPE_BSS ) {

	cmp	r11d, 3
	je	SHORT $LN16@coff_write
	cmp	DWORD PTR segtype$[rsp], 3
	je	SHORT $LN16@coff_write

; 224  :             } else if ( curr->e.seginfo->combine == COMB_STACK && curr->e.seginfo->bytes_written == 0 ) {

	movzx	eax, BYTE PTR [r8+108]
	and	al, 7
	cmp	al, 5
	jne	SHORT $LN14@coff_write
	cmp	DWORD PTR [r8+24], r14d
	jne	SHORT $LN14@coff_write

; 225  :                 ish.Characteristics |= IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

	or	edx, -1073741696			; c0000080H

; 226  :                 ish.SizeOfRawData = 0;

	mov	ebx, r14d
	mov	DWORD PTR ish$[rsp+16], r14d

; 227  :                 ish.PointerToRawData = 0;

	mov	r10d, r14d
	mov	DWORD PTR ish$[rsp+20], r14d
	mov	DWORD PTR ish$[rsp+36], edx

; 228  :             } else

	jmp	SHORT $LN13@coff_write
$LN14@coff_write:

; 229  :                 ish.Characteristics |= IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

	or	edx, -1073741760			; c0000040H
	mov	DWORD PTR ish$[rsp+36], edx
	jmp	SHORT $LN13@coff_write
$LN16@coff_write:

; 217  :                 /* v2.12: if segtype is bss, ensure that seginfo->segtype is also bss; else
; 218  :                  * the segment might be written in coff_write_data().
; 219  :                  */
; 220  :                 curr->e.seginfo->segtype = SEGTYPE_BSS;

	mov	DWORD PTR [r8+72], 3

; 221  :                 ish.Characteristics |= IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

	mov	edx, DWORD PTR ish$[rsp+36]

; 222  :                 /* ish.SizeOfRawData = 0; */
; 223  :                 ish.PointerToRawData = 0;

	mov	ebx, DWORD PTR ish$[rsp+16]
	or	edx, -1073741696			; c0000080H
	mov	r10d, r14d
	mov	DWORD PTR ish$[rsp+20], r14d
	mov	DWORD PTR ish$[rsp+36], edx
$LN13@coff_write:

; 230  :         }
; 231  : 
; 232  :         /* manual characteristics set? */
; 233  :         if ( curr->e.seginfo->characteristics ) {

	mov	rax, QWORD PTR [rsi+104]
	cmp	BYTE PTR [rax+105], r14b
	je	SHORT $LN12@coff_write

; 234  :             ish.Characteristics &= 0x1FFFFFF; /* clear the IMAGE_SCN_MEM flags */

	and	edx, 33554431				; 01ffffffH
	mov	DWORD PTR ish$[rsp+36], edx

; 235  :             ish.Characteristics |= (uint_32)(curr->e.seginfo->characteristics & 0xFE) << 24;

	mov	rax, QWORD PTR [rsi+104]
	movzx	ecx, BYTE PTR [rax+105]
	and	ecx, -2					; fffffffeH
	shl	ecx, 24
	or	edx, ecx
	mov	DWORD PTR ish$[rsp+36], edx
$LN12@coff_write:

; 236  :             /* the INFO bit (bit 0) needs special handling! */
; 237  :             //if ( curr->e.seginfo->characteristics & 1 )
; 238  :             //    ish.Characteristics |= IMAGE_SCN_LNK_INFO;
; 239  :         }
; 240  : 
; 241  :         if ( ish.PointerToRawData )

	test	r10d, r10d
	je	SHORT $LN11@coff_write

; 242  :             fileoffset += ish.SizeOfRawData;

	add	r12d, ebx
$LN11@coff_write:

; 243  : 
; 244  :         /* set fields PointerToRelocations/NumberOfRelocations; update 'fileoffset'.
; 245  :          * v2.10: don't use the 16-bit NumberOfRelocations member to count relocs!
; 246  :          * if the true number of relocs doesn't fit in 16-bits, set the appropriate
; 247  :          * flag in the section header!
; 248  :          */
; 249  :         if ( curr->e.seginfo->FixupList.head ) {

	mov	rax, QWORD PTR [rsi+104]
	mov	r8, QWORD PTR [rax+40]
	test	r8, r8
	je	$LN3@coff_write
	npad	4
$LL9@coff_write:

; 250  :             for ( fix = curr->e.seginfo->FixupList.head; fix ; fix = fix->nextrlc ) {
; 251  :                 //printf("segment %s, reloc.sym=%s\n", curr->sym.name, fix->sym ? fix->sym : "NULL" );
; 252  :                 if ( fix->sym == NULL ) {

	cmp	QWORD PTR [r8+56], r14
	jne	SHORT $LN6@coff_write

; 253  : #if AMD64_SUPPORT
; 254  :                     if ( fix->type == FIX_RELOFF32 ) {

	cmp	DWORD PTR [r8+24], 3
	jne	SHORT $LN5@coff_write

; 255  :                         uint_32 *cp = (uint_32 *)( curr->e.seginfo->CodeBuffer + (fix->locofs - curr->e.seginfo->start_loc ));

	mov	edi, DWORD PTR [r8+20]
	mov	rcx, QWORD PTR [rsi+104]

; 256  :                         uint_32 src = fix->locofs + fix->addbytes;
; 257  :                         (*cp) -= src;

	movzx	eax, BYTE PTR [r8+32]
	mov	edx, edi
	add	eax, edi
	sub	edx, DWORD PTR [rcx+8]
	add	rdx, QWORD PTR [rcx+16]
	sub	DWORD PTR [rdx], eax
$LN5@coff_write:

; 258  :                     }
; 259  : #endif
; 260  :                     fix->type = FIX_VOID;

	mov	DWORD PTR [r8+24], r14d

; 261  :                     continue;

	jmp	SHORT $LN8@coff_write
$LN6@coff_write:

; 262  :                 }
; 263  :                 curr->e.seginfo->num_relocs++;

	mov	rax, QWORD PTR [rsi+104]
	inc	DWORD PTR [rax+64]
$LN8@coff_write:
	mov	r8, QWORD PTR [r8+8]
	test	r8, r8
	jne	SHORT $LL9@coff_write

; 264  :             }
; 265  :             fileoffset = (fileoffset + 1) & ~1;

	lea	edx, DWORD PTR [r12+1]
	and	edx, -2					; fffffffeH

; 266  :             ish.PointerToRelocations = fileoffset;

	mov	DWORD PTR ish$[rsp+24], edx

; 267  :             /* v2.10: handle the "relocs overflow"-case */
; 268  :             fileoffset += curr->e.seginfo->num_relocs * sizeof( IMAGE_RELOCATION );

	mov	rax, QWORD PTR [rsi+104]
	mov	ecx, DWORD PTR [rax+64]

; 269  :             if ( curr->e.seginfo->num_relocs <= 0xffff ) {

	cmp	ecx, 65535				; 0000ffffH
	lea	eax, DWORD PTR [rcx+rcx*4]
	lea	r12d, DWORD PTR [rdx+rax*2]
	ja	SHORT $LN4@coff_write

; 270  :                 ish.NumberOfRelocations =  (uint_16)curr->e.seginfo->num_relocs;

	mov	rax, QWORD PTR [rsi+104]
	movzx	ecx, WORD PTR [rax+64]
	mov	WORD PTR ish$[rsp+32], cx

; 271  :             } else {

	jmp	SHORT $LN3@coff_write
$LN4@coff_write:

; 272  :                 DebugMsg(( "coff_write_section_table(%s): %" I32_SPEC "u fixups (more than 0xffff!)!\n", curr->sym.name, curr->e.seginfo->num_relocs ));
; 273  :                 ish.NumberOfRelocations =  0xffff;
; 274  :                 ish.Characteristics |= IMAGE_SCN_LNK_NRELOC_OVFL;

	bts	DWORD PTR ish$[rsp+36], 24

; 275  :                 /* add 1 relocation - the true number of relocations is stored in the first relocation item */
; 276  :                 fileoffset += sizeof( IMAGE_RELOCATION );

	add	r12d, 10
	mov	WORD PTR ish$[rsp+32], 65535		; 0000ffffH
$LN3@coff_write:

; 277  :             }
; 278  :             //printf( "segment %s has %u relocs\n", curr->sym.name, curr->e.seginfo->num_relocs );
; 279  :         }
; 280  : 
; 281  :         /* set fields PointerToLinenumbers/NumberOfLinenumbers; update 'fileoffset' */
; 282  : 
; 283  :         if ( curr->e.seginfo->LinnumQueue ) {

	mov	rax, QWORD PTR [rsi+104]
	cmp	QWORD PTR [rax+56], r14
	je	SHORT $LN2@coff_write

; 284  :             ish.PointerToLinenumbers = fileoffset;

	mov	DWORD PTR ish$[rsp+28], r12d

; 285  :             ish.NumberOfLinenumbers = GetLinnumItems( curr->e.seginfo->LinnumQueue );

	mov	rax, QWORD PTR [rsi+104]
	mov	edx, r14d
	mov	rcx, QWORD PTR [rax+56]
	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	je	SHORT $LN44@coff_write
$LL46@coff_write:
	mov	rax, QWORD PTR [rax]
	inc	edx
	test	rax, rax
	jne	SHORT $LL46@coff_write
$LN44@coff_write:

; 286  :             fileoffset += ish.NumberOfLinenumbers * sizeof( IMAGE_LINENUMBER );

	movzx	eax, dx
	mov	WORD PTR ish$[rsp+34], dx
	lea	ecx, DWORD PTR [rax+rax*2]
	lea	r12d, DWORD PTR [r12+rcx*2]
$LN2@coff_write:

; 287  :         }
; 288  : 
; 289  :         DebugMsg(( "coff_write_section_table(%s): name=%.8s Fixups=%u, Linnums=%u\n", curr->sym.name, ish.Name, ish.NumberOfRelocations, ish.NumberOfLinenumbers ));
; 290  :         if ( fwrite( &ish, 1, sizeof( ish ), CurrFile[OBJ] ) != sizeof( ish ) )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	edx, 1
	lea	rcx, QWORD PTR ish$[rsp]
	lea	r8d, QWORD PTR [rdx+39]
	call	fwrite
	cmp	rax, 40					; 00000028H
	je	SHORT $LN33@coff_write

; 291  :             WriteError();

	call	WriteError
$LN33@coff_write:

; 165  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rsi, QWORD PTR [rsi+112]
	test	rsi, rsi
	jne	$LL34@coff_write
	mov	r15, QWORD PTR [rsp+344]
	mov	r14, QWORD PTR [rsp+352]
	mov	rdi, QWORD PTR [rsp+408]
	mov	rbp, QWORD PTR [rsp+392]
	mov	rbx, QWORD PTR [rsp+384]
$LN58@coff_write:
	mov	r13, QWORD PTR [rsp+360]
	mov	r12, QWORD PTR [rsp+368]
	mov	rsi, QWORD PTR [rsp+400]

; 292  :     }
; 293  : #ifdef DEBUG_OUT
; 294  :     cm->start_symtab = fileoffset;
; 295  : #endif
; 296  :     DebugMsg(("coff_write_section_table: exit\n"));
; 297  :     return( NOT_ERROR );

	xor	eax, eax

; 298  : }

	add	rsp, 376				; 00000178H
	ret	0
coff_write_section_table ENDP
; Function compile flags: /Ogtpy
sym$ = 8
CoffGetType PROC NEAR

; 308  :     if ( sym->isproc )

	movzx	eax, BYTE PTR [rcx+49]
	and	al, 8
	movzx	eax, al
	shl	ax, 2

; 309  :         return( 0x20 );
; 310  : 
; 311  : #if 0
; 312  :     switch (sym->mem_type) {
; 313  :     case MT_BYTE:
; 314  :     case MT_SBYTE:
; 315  :         return( IMAGE_SYM_TYPE_BYTE );
; 316  :     case MT_WORD:
; 317  :     case MT_SWORD:
; 318  :         return( IMAGE_SYM_TYPE_WORD );
; 319  :     case MT_DWORD:
; 320  :     case MT_SDWORD:
; 321  :         return( IMAGE_SYM_TYPE_DWORD );
; 322  :     }
; 323  : #endif
; 324  :     return( IMAGE_SYM_TYPE_NULL );
; 325  : }

	ret	0
CoffGetType ENDP
; Function compile flags: /Ogtpy
sym$ = 8
CoffGetClass PROC NEAR

; 333  :     if ( sym->state == SYM_EXTERNAL )

	cmp	DWORD PTR [rcx+40], 2
	jne	SHORT $LN7@CoffGetCla

; 334  :         if ( sym->iscomm == FALSE && sym->altname )

	test	BYTE PTR [rcx+55], 4
	jne	SHORT $LN6@CoffGetCla
	cmp	QWORD PTR [rcx+72], 0
	je	SHORT $LN6@CoffGetCla

; 335  :             return( IMAGE_SYM_CLASS_WEAK_EXTERNAL );

	mov	ax, 105					; 00000069H

; 350  : }

	ret	0
$LN7@CoffGetCla:

; 336  :         else
; 337  :             return( IMAGE_SYM_CLASS_EXTERNAL );
; 338  :     else if ( sym->ispublic == TRUE )

	test	BYTE PTR [rcx+48], 128			; 00000080H
	je	SHORT $LN3@CoffGetCla
$LN6@CoffGetCla:

; 339  :         return( IMAGE_SYM_CLASS_EXTERNAL );

	mov	ax, 2

; 350  : }

	ret	0
$LN3@CoffGetCla:

; 340  : #if HELPSYMS
; 341  :     else if ( sym->variable == TRUE ) /* assembly time variable in fixup */
; 342  :         return( IMAGE_SYM_CLASS_LABEL );
; 343  : #endif
; 344  :     /* v2.09: don't declare private procs as label */
; 345  :     //else if ( sym->mem_type == MT_NEAR )/* added v2.0 */
; 346  :     else if ( sym->mem_type == MT_NEAR && sym->isproc == FALSE )

	cmp	DWORD PTR [rcx+44], 129			; 00000081H
	jne	SHORT $LN1@CoffGetCla
	test	BYTE PTR [rcx+49], 8

; 347  :         return( IMAGE_SYM_CLASS_LABEL );

	mov	ax, 6
	je	SHORT $LN8@CoffGetCla
$LN1@CoffGetCla:

; 348  : 
; 349  :     return( IMAGE_SYM_CLASS_STATIC );

	mov	ax, 3
$LN8@CoffGetCla:

; 350  : }

	ret	0
CoffGetClass ENDP
_TEXT	ENDS
EXTRN	GetFName:NEAR
xdata	SEGMENT
$unwind$GetFileAuxEntries DD 020601H
	DD	070023206H
xdata	ENDS
pdata	SEGMENT
$pdata$GetFileAuxEntries DD @imagerel(GetFileAuxEntries#)
	DD	@imagerel(GetFileAuxEntries#+97)
	DD	@imagerel($unwind$GetFileAuxEntries#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
file$ = 48
tv74 = 56
fname$ = 56
GetFileAuxEntries PROC NEAR

; 356  : {

	push	rdi
	sub	rsp, 32					; 00000020H

; 357  :     const struct fname_item *curr;
; 358  :     unsigned len;
; 359  :     curr = GetFName( file );

	movzx	ecx, cx
	mov	rdi, rdx
	call	GetFName

; 360  :     if ( fname )

	test	rdi, rdi
	mov	r11, rax
	je	SHORT $LN1@GetFileAux

; 361  :         *fname = curr->fname;

	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR [rdi], rcx
$LN1@GetFileAux:

; 362  :     len = strlen( curr->fname );

	mov	rdi, QWORD PTR [r11]
	xor	eax, eax
	mov	rcx, -1
	repne scasb

; 363  :     /**/myassert( len ); /* name length must be > 0 */
; 364  :     return ( len / sizeof( IMAGE_AUX_SYMBOL ) + ( len % sizeof( IMAGE_AUX_SYMBOL ) ? 1 : 0 ) );

	mov	rax, -2049638230412172401		; e38e38e38e38e38fH
	not	rcx
	dec	rcx
	mov	ecx, ecx
	mul	rcx
	shr	rdx, 4
	lea	rax, QWORD PTR [rdx+rdx*8]
	add	rax, rax
	sub	rcx, rax
	mov	eax, 0
	setne	al
	add	rax, rdx

; 365  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
GetFileAuxEntries ENDP
_TEXT	ENDS
_BSS	SEGMENT
	ALIGN	4

CRC32Table DD	0100H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
_TEXT	SEGMENT
InitCRC32 PROC NEAR

; 376  :     int i,j;
; 377  :     uint_32 crc;
; 378  :     for ( i = 0; i < 256; i++ ) {

	xor	edx, edx
	lea	r8, OFFSET FLAT:CRC32Table
	npad	7
$LL6@InitCRC32:

; 379  :         for ( j = 0, crc = i; j < 8; j++ ) {
; 380  :             crc = ( crc >> 1 ) ^ (0xEDB88320 * ( crc & 1 ) );

	mov	ecx, edx
	mov	eax, edx
	inc	edx
	shr	eax, 1
	and	ecx, 1
	add	r8, 4
	imul	ecx, -306674912				; edb88320H
	xor	ecx, eax
	mov	eax, ecx
	shr	ecx, 1
	and	eax, 1
	imul	eax, -306674912				; edb88320H
	xor	eax, ecx
	mov	ecx, eax
	shr	eax, 1
	and	ecx, 1
	imul	ecx, -306674912				; edb88320H
	xor	ecx, eax
	mov	eax, ecx
	shr	ecx, 1
	and	eax, 1
	imul	eax, -306674912				; edb88320H
	xor	eax, ecx
	mov	ecx, eax
	shr	eax, 1
	and	ecx, 1
	imul	ecx, -306674912				; edb88320H
	xor	ecx, eax
	mov	eax, ecx
	shr	ecx, 1
	and	eax, 1
	imul	eax, -306674912				; edb88320H
	xor	eax, ecx
	mov	ecx, eax
	shr	eax, 1
	and	ecx, 1
	imul	ecx, -306674912				; edb88320H
	xor	ecx, eax
	mov	eax, ecx
	shr	ecx, 1
	and	eax, 1
	imul	eax, -306674912				; edb88320H
	xor	eax, ecx
	cmp	edx, 256				; 00000100H

; 381  :         }
; 382  :         CRC32Table[i] = crc;

	mov	DWORD PTR [r8-4], eax
	jl	$LL6@InitCRC32

; 383  :     }
; 384  : }

	ret	0
InitCRC32 ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$CRC32Comdat DD 020c01H
	DD	04740cH
xdata	ENDS
pdata	SEGMENT
$pdata$CRC32Comdat DD @imagerel(CRC32Comdat#)
	DD	@imagerel(CRC32Comdat#+31)
	DD	@imagerel($unwind$CRC32Comdat#)
pdata	ENDS
xdata	SEGMENT
$chain$1$CRC32Comdat DD 020521H
	DD	033405H
	DD	@imagerel(CRC32Comdat#)
	DD	@imagerel(CRC32Comdat#+31)
	DD	@imagerel($unwind$CRC32Comdat#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$CRC32Comdat DD @imagerel(CRC32Comdat#+31)
	DD	@imagerel(CRC32Comdat#+207)
	DD	@imagerel($chain$1$CRC32Comdat#)
pdata	ENDS
xdata	SEGMENT
$chain$2$CRC32Comdat DD 021H
	DD	@imagerel(CRC32Comdat#)
	DD	@imagerel(CRC32Comdat#+31)
	DD	@imagerel($unwind$CRC32Comdat#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$CRC32Comdat DD @imagerel(CRC32Comdat#+207)
	DD	@imagerel(CRC32Comdat#+265)
	DD	@imagerel($chain$2$CRC32Comdat#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
lpBuffer$ = 8
dwBufLen$ = 16
dwCRC$ = 24
CRC32Comdat PROC NEAR

; 389  :     static bool init = FALSE;
; 390  :     uint_8 byt;
; 391  : 
; 392  :     if ( !init ) {

	cmp	BYTE PTR ?init@?1??CRC32Comdat@@9@9, 0
	mov	QWORD PTR [rsp+32], rdi
	mov	r9d, r8d
	lea	rdi, OFFSET FLAT:CRC32Table
	mov	r10, rcx
	jne	$LN11@CRC32Comda
	mov	QWORD PTR [rsp+24], rbx

; 393  :         init = TRUE;

	mov	BYTE PTR ?init@?1??CRC32Comdat@@9@9, 1

; 394  :         InitCRC32();

	xor	r11d, r11d
	mov	rbx, rdi
$LL13@CRC32Comda:
	mov	r8d, r11d
	mov	eax, r11d
	inc	r11d
	shr	eax, 1
	and	r8d, 1
	add	rbx, 4
	imul	r8d, -306674912				; edb88320H
	xor	r8d, eax
	mov	eax, r8d
	shr	r8d, 1
	and	eax, 1
	imul	eax, -306674912				; edb88320H
	xor	eax, r8d
	mov	ecx, eax
	shr	eax, 1
	and	ecx, 1
	imul	ecx, -306674912				; edb88320H
	xor	ecx, eax
	mov	eax, ecx
	shr	ecx, 1
	and	eax, 1
	imul	eax, -306674912				; edb88320H
	xor	eax, ecx
	mov	ecx, eax
	shr	eax, 1
	and	ecx, 1
	imul	ecx, -306674912				; edb88320H
	xor	ecx, eax
	mov	eax, ecx
	shr	ecx, 1
	and	eax, 1
	imul	eax, -306674912				; edb88320H
	xor	eax, ecx
	mov	ecx, eax
	shr	eax, 1
	and	ecx, 1
	imul	ecx, -306674912				; edb88320H
	xor	ecx, eax
	mov	eax, ecx
	shr	ecx, 1
	and	eax, 1
	imul	eax, -306674912				; edb88320H
	xor	eax, ecx
	cmp	r11d, 256				; 00000100H
	mov	DWORD PTR [rbx-4], eax
	jl	$LL13@CRC32Comda
	mov	rbx, QWORD PTR [rsp+24]
$LN11@CRC32Comda:

; 395  :     }
; 396  :     if ( lpBuffer ) /* v2.11: lpBuffer may be NULL ( uninitialized data segs ) */

	test	r10, r10
	je	SHORT $LN31@CRC32Comda

; 397  :         for ( ; dwBufLen; dwBufLen-- ) {

	test	edx, edx
	je	SHORT $LN31@CRC32Comda
	npad	8
$LL3@CRC32Comda:

; 398  :             byt = *lpBuffer++;

	movzx	eax, BYTE PTR [r10]

; 399  :             byt = byt ^ (uint_8)dwCRC;
; 400  :             dwCRC = dwCRC >> 8;
; 401  :             dwCRC = dwCRC ^ CRC32Table[byt];

	movzx	ecx, r9b
	inc	r10
	xor	rcx, rax
	mov	eax, r9d
	mov	r9d, DWORD PTR [rdi+rcx*4]
	shr	eax, 8
	xor	r9d, eax
	add	edx, -1					; ffffffffH
	jne	SHORT $LL3@CRC32Comda
$LN31@CRC32Comda:
	mov	rdi, QWORD PTR [rsp+32]

; 402  :         }
; 403  :     return( dwCRC );

	mov	eax, r9d

; 404  : }

	ret	0
CRC32Comdat ENDP
_TEXT	ENDS
EXTRN	GetSegIdx:NEAR
EXTRN	Mangle:NEAR
EXTRN	Options:BYTE
xdata	SEGMENT
$unwind$coff_write_symbols DD 0a2701H
	DD	02fd427H
	DD	0326423H
	DD	0375417H
	DD	0363413H
	DD	033010fH
xdata	ENDS
pdata	SEGMENT
$pdata$coff_write_symbols DD @imagerel(coff_write_symbols#)
	DD	@imagerel(coff_write_symbols#+39)
	DD	@imagerel($unwind$coff_write_symbols#)
pdata	ENDS
xdata	SEGMENT
$chain$6$coff_write_symbols DD 065021H
	DD	030c450H
	DD	0317448H
	DD	02df404H
	DD	@imagerel(coff_write_symbols#)
	DD	@imagerel(coff_write_symbols#+39)
	DD	@imagerel($unwind$coff_write_symbols#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$coff_write_symbols DD @imagerel(coff_write_symbols#+39)
	DD	@imagerel(coff_write_symbols#+390)
	DD	@imagerel($chain$6$coff_write_symbols#)
pdata	ENDS
xdata	SEGMENT
$chain$7$coff_write_symbols DD 020821H
	DD	02ee408H
	DD	@imagerel(coff_write_symbols#+39)
	DD	@imagerel(coff_write_symbols#+390)
	DD	@imagerel($chain$6$coff_write_symbols#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$coff_write_symbols DD @imagerel(coff_write_symbols#+390)
	DD	@imagerel(coff_write_symbols#+2850)
	DD	@imagerel($chain$7$coff_write_symbols#)
pdata	ENDS
xdata	SEGMENT
$chain$8$coff_write_symbols DD 060021H
	DD	02ee400H
	DD	030c400H
	DD	0317400H
	DD	@imagerel(coff_write_symbols#)
	DD	@imagerel(coff_write_symbols#+39)
	DD	@imagerel($unwind$coff_write_symbols#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$coff_write_symbols DD @imagerel(coff_write_symbols#+2850)
	DD	@imagerel(coff_write_symbols#+3230)
	DD	@imagerel($chain$8$coff_write_symbols#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
is$ = 32
ias$ = 56
tv1634 = 80
tv835 = 80
buffer$ = 96
modinfo$ = 416
cm$ = 424
coff_write_symbols PROC NEAR

; 418  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	rax, rsp
	sub	rsp, 408				; 00000198H
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax+32], rbp

; 419  :     uint_32     cntSymbols = 0;

	xor	ebx, ebx

; 420  :     struct dsym *curr;
; 421  :     struct asym *sym;
; 422  :     struct qnode *q;
; 423  :     char        *p;
; 424  :     unsigned    len;
; 425  :     unsigned    i;
; 426  :     IMAGE_SYMBOL is;
; 427  :     IMAGE_AUX_SYMBOL ias;
; 428  :     unsigned    lastfile = 0;
; 429  :     char        buffer[MAX_ID_LEN + MANGLE_BYTES + 1];
; 430  : 
; 431  :     DebugMsg(("coff_write_symbols: enter\n"));
; 432  : 
; 433  : #if COMPID
; 434  :     /* write "@comp.id" entry */
; 435  :     if ( fwrite( &isCompId, 1, sizeof(IMAGE_SYMBOL), CurrFile[OBJ] ) != sizeof(IMAGE_SYMBOL) )
; 436  :         WriteError();
; 437  :     cntSymbols++;
; 438  : #endif
; 439  :     /* "@feat.00" entry (for SafeSEH) */
; 440  :     if ( Options.safeseh ) {

	cmp	BYTE PTR Options+151, bl
	mov	QWORD PTR [rax-8], rsi
	mov	QWORD PTR [rax-32], r13
	mov	QWORD PTR [rax-48], r15
	lea	r13d, QWORD PTR [rbx+1]
	mov	rsi, rdx
	mov	r15d, ebx
	mov	ebp, ebx
	je	SHORT $LN67@coff_write@2

; 441  :         if ( fwrite( &isFeat00, 1, sizeof(IMAGE_SYMBOL), CurrFile[OBJ] ) != sizeof(IMAGE_SYMBOL) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	r8d, QWORD PTR [rbx+18]
	lea	rcx, OFFSET FLAT:isFeat00
	mov	rdx, r13
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN66@coff_write@2

; 442  :             WriteError();

	call	WriteError
$LN66@coff_write@2:

; 443  :         cntSymbols++;

	mov	ebp, r13d
$LN67@coff_write@2:

; 444  :     }
; 445  : 
; 446  :     /* .file item (optionally disabled by -zlf) */
; 447  : 
; 448  :     if ( Options.no_file_entry == FALSE ) {

	cmp	BYTE PTR Options+122, bl
	mov	QWORD PTR [rsp+392], rdi
	mov	QWORD PTR [rsp+384], r12
	mov	r12, -2049638230412172401		; e38e38e38e38e38fH
	jne	$LN65@coff_write@2

; 449  :         strncpy( is.N.ShortName, ".file", IMAGE_SIZEOF_SHORT_NAME );

	lea	rdx, OFFSET FLAT:$SG6008
	lea	rcx, QWORD PTR is$[rsp]
	mov	r8d, 8
	call	strncpy

; 450  :         is.Value = ( Options.line_numbers ? cm->start_files : 0 );  /* index of next .file entry */

	cmp	BYTE PTR Options+1, bl
	je	SHORT $LN70@coff_write@2
	mov	eax, DWORD PTR [rsi+40]
	mov	DWORD PTR is$[rsp+8], eax
	jmp	SHORT $LN71@coff_write@2
$LN70@coff_write@2:
	mov	DWORD PTR is$[rsp+8], ebx
$LN71@coff_write@2:

; 451  :         is.SectionNumber = (uint_16)IMAGE_SYM_DEBUG;
; 452  :         is.Type = IMAGE_SYM_TYPE_NULL;
; 453  :         is.StorageClass = IMAGE_SYM_CLASS_FILE;
; 454  : 
; 455  :         p = cm->dot_file_value;
; 456  :         i = strlen( p );
; 457  :         is.NumberOfAuxSymbols = i / sizeof(IMAGE_AUX_SYMBOL) + (i % sizeof(IMAGE_AUX_SYMBOL) ? 1 : 0);
; 458  :         if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	r9, QWORD PTR ModuleInfo+104
	xor	eax, eax
	mov	WORD PTR is$[rsp+14], bx
	mov	rbx, QWORD PTR [rsi+24]
	mov	WORD PTR is$[rsp+12], 65534		; 0000fffeH
	mov	BYTE PTR is$[rsp+16], 103		; 00000067H
	mov	rcx, -1
	mov	rdi, rbx
	mov	r8d, 18
	repne scasb
	mov	rax, r12
	not	rcx
	dec	rcx
	mov	ecx, ecx
	mul	rcx
	shr	rdx, 4
	lea	rax, QWORD PTR [rdx+rdx*8]
	add	rax, rax
	sub	rcx, rax
	lea	rcx, QWORD PTR is$[rsp]
	setne	al
	add	al, dl
	mov	rdx, r13
	mov	BYTE PTR is$[rsp+17], al
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN64@coff_write@2

; 459  :             WriteError();

	call	WriteError
$LN64@coff_write@2:

; 460  : 
; 461  :         for ( i = is.NumberOfAuxSymbols;i;i--, p += sizeof(IMAGE_AUX_SYMBOL) ) {

	movzx	eax, BYTE PTR is$[rsp+17]
	test	al, al
	mov	edi, eax
	je	SHORT $LN61@coff_write@2
	npad	5
$LL63@coff_write@2:

; 462  :             strncpy( ias.File.Name, p, sizeof(IMAGE_AUX_SYMBOL) );

	lea	rcx, QWORD PTR ias$[rsp]
	mov	r8d, 18
	mov	rdx, rbx
	call	strncpy

; 463  :             if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR ias$[rsp]
	mov	r8d, 18
	mov	rdx, r13
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN62@coff_write@2

; 464  :                 WriteError();

	call	WriteError
$LN62@coff_write@2:

; 460  : 
; 461  :         for ( i = is.NumberOfAuxSymbols;i;i--, p += sizeof(IMAGE_AUX_SYMBOL) ) {

	add	rbx, 18
	add	edi, -1					; ffffffffH
	jne	SHORT $LL63@coff_write@2
	movzx	eax, BYTE PTR is$[rsp+17]
$LN61@coff_write@2:

; 465  :         }
; 466  :         cntSymbols += is.NumberOfAuxSymbols + 1;

	movzx	eax, al
	xor	ebx, ebx
	lea	ebp, DWORD PTR [rbp+rax+1]
$LN65@coff_write@2:

; 467  :     }
; 468  : 
; 469  :     /* next are section entries */
; 470  : 
; 471  :     for( i = 1, curr = SymTables[TAB_SEG].head; curr; curr = curr->next, i++ ) {

	mov	r12, QWORD PTR SymTables+32
	mov	QWORD PTR [rsp+368], r14
	mov	r14d, r13d
	test	r12, r12
	je	$LN57@coff_write@2
	npad	6
$LL59@coff_write@2:

; 472  :         /* v2.07: prefer ALIAS name if defined */
; 473  :         p = ( curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ConvertSectionName( &curr->sym, NULL, buffer ) );

	mov	rax, QWORD PTR [r12+104]
	mov	rbx, QWORD PTR [rax+96]
	test	rbx, rbx
	jne	SHORT $LN73@coff_write@2
	lea	r8, QWORD PTR buffer$[rsp]
	xor	edx, edx
	mov	rcx, r12
	call	ConvertSectionName
	mov	rbx, rax
$LN73@coff_write@2:

; 474  :         len = strlen( p );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	dec	rcx

; 475  :         if ( len <= IMAGE_SIZEOF_SHORT_NAME )

	cmp	ecx, 8
	ja	SHORT $LN56@coff_write@2

; 476  :             strncpy( is.N.ShortName, p, IMAGE_SIZEOF_SHORT_NAME );

	lea	r8d, QWORD PTR [rax+8]
	lea	rcx, QWORD PTR is$[rsp]
	mov	rdx, rbx
	call	strncpy

; 477  :         else {

	jmp	SHORT $LN55@coff_write@2
$LN56@coff_write@2:

; 478  :             is.N.Name.Short = 0;
; 479  :             is.N.Name.Long = Coff_AllocString( cm, p, len );

	mov	r13d, DWORD PTR [rsi+112]
	mov	DWORD PTR is$[rsp], eax
	lea	eax, DWORD PTR [r13+rcx+1]
	movsxd	rcx, ecx
	add	rcx, 16
	mov	DWORD PTR [rsi+112], eax
	call	LclAlloc
	mov	rdx, rax
	mov	rdi, rax
	sub	rdx, rbx
	mov	QWORD PTR [rax], r15
	npad	12
$LL82@coff_write@2:
	movzx	ecx, BYTE PTR [rbx]
	inc	rbx
	test	cl, cl
	mov	BYTE PTR [rbx+rdx+7], cl
	jne	SHORT $LL82@coff_write@2
	cmp	QWORD PTR [rsi+96], r15
	je	SHORT $LN79@coff_write@2
	mov	rax, QWORD PTR [rsi+104]
	mov	QWORD PTR [rax], rdi
	mov	QWORD PTR [rsi+104], rdi
	jmp	SHORT $LN78@coff_write@2
$LN79@coff_write@2:
	mov	QWORD PTR [rsi+104], rax
	mov	QWORD PTR [rsi+96], rax
$LN78@coff_write@2:
	mov	DWORD PTR is$[rsp+4], r13d
	mov	r13d, 1
$LN55@coff_write@2:

; 480  :         }
; 481  :         is.Value = 0;
; 482  :         is.SectionNumber = i;
; 483  :         is.Type = IMAGE_SYM_TYPE_NULL;
; 484  :         is.StorageClass = IMAGE_SYM_CLASS_STATIC;
; 485  :         is.NumberOfAuxSymbols = 0;
; 486  :         if ( Options.no_section_aux_entry == FALSE )
; 487  :             is.NumberOfAuxSymbols = 1;
; 488  : 
; 489  :         DebugMsg(("coff_write_symbols(%u, SECT): %s, type=%x, stgcls=%x\n", cntSymbols, curr->sym.name, is.Type, is.StorageClass ));
; 490  : 
; 491  :         if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	r9, QWORD PTR ModuleInfo+104
	xor	ebx, ebx
	xor	al, al
	cmp	BYTE PTR Options+124, bl
	movzx	eax, al
	lea	rcx, QWORD PTR is$[rsp]
	cmove	eax, r13d
	lea	r8d, QWORD PTR [rbx+18]
	mov	rdx, r13
	mov	DWORD PTR is$[rsp+8], ebx
	mov	WORD PTR is$[rsp+12], r14w
	mov	WORD PTR is$[rsp+14], bx
	mov	BYTE PTR is$[rsp+17], al
	mov	BYTE PTR is$[rsp+16], 3
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN53@coff_write@2

; 492  :             WriteError();

	call	WriteError
$LN53@coff_write@2:

; 493  :         cntSymbols++;

	inc	ebp

; 494  : 
; 495  :         /* write the auxiliary symbol record for sections.
; 496  :          * may be suppressed with option -zls.
; 497  :          */
; 498  :         if ( Options.no_section_aux_entry == FALSE 
; 499  : #if COMDATSUPP
; 500  :             || curr->e.seginfo->comdat_selection
; 501  : #endif
; 502  :             ) {

	cmp	BYTE PTR Options+124, bl
	je	SHORT $LN51@coff_write@2
	mov	rax, QWORD PTR [r12+104]
	test	BYTE PTR [rax+108], 56			; 00000038H
	je	$LN58@coff_write@2
$LN51@coff_write@2:

; 503  :             ias.Section.Length = curr->sym.max_offset;

	mov	eax, DWORD PTR [r12+64]
	mov	DWORD PTR ias$[rsp], eax

; 504  :             /* v2.10: check for overflow */
; 505  :             //ias.Section.NumberOfRelocations = curr->e.seginfo->num_relocs;
; 506  :             ias.Section.NumberOfRelocations = ( curr->e.seginfo->num_relocs > 0xffff ? 0xffff : (uint_16)curr->e.seginfo->num_relocs );

	mov	rax, QWORD PTR [r12+104]
	cmp	DWORD PTR [rax+64], 65535		; 0000ffffH
	jbe	SHORT $LN74@coff_write@2
	mov	WORD PTR ias$[rsp+4], 65535		; 0000ffffH
	jmp	SHORT $LN75@coff_write@2
$LN74@coff_write@2:
	movzx	eax, WORD PTR [rax+64]
	mov	WORD PTR ias$[rsp+4], ax
$LN75@coff_write@2:

; 507  :             if ( Options.line_numbers )

	cmp	BYTE PTR Options+1, bl
	je	SHORT $LN50@coff_write@2

; 508  :                 ias.Section.NumberOfLinenumbers = curr->e.seginfo->num_linnums;

	mov	rax, QWORD PTR [r12+104]
	movzx	ecx, WORD PTR [rax+56]
	mov	WORD PTR ias$[rsp+6], cx

; 509  :             else

	jmp	SHORT $LN49@coff_write@2
$LN50@coff_write@2:

; 510  :                 ias.Section.NumberOfLinenumbers = 0;

	mov	WORD PTR ias$[rsp+6], bx
$LN49@coff_write@2:

; 511  :             /* CheckSum, Number and Selection are for COMDAT sections only */
; 512  : #if COMDATSUPP
; 513  :             if ( curr->e.seginfo->comdat_selection ) {

	mov	rdi, QWORD PTR [r12+104]
	test	BYTE PTR [rdi+108], 56			; 00000038H
	je	$LN48@coff_write@2

; 514  :                 ias.Section.CheckSum = CRC32Comdat( curr->e.seginfo->CodeBuffer, curr->sym.max_offset, 0 );

	mov	rdi, QWORD PTR [rdi+16]
	mov	r8d, DWORD PTR [r12+64]
	mov	edx, ebx
	cmp	BYTE PTR ?init@?1??CRC32Comdat@@9@9, dl
	jne	$LN171@coff_write@2
	lea	r11, OFFSET FLAT:CRC32Table
	mov	BYTE PTR ?init@?1??CRC32Comdat@@9@9, 1
	mov	r9d, ebx
	mov	r10, r11
	npad	7
$LL95@coff_write@2:
	mov	ecx, r9d
	mov	eax, r9d
	inc	r9d
	shr	eax, 1
	and	ecx, 1
	add	r10, 4
	imul	ecx, -306674912				; edb88320H
	xor	ecx, eax
	mov	eax, ecx
	shr	ecx, 1
	and	eax, 1
	imul	eax, -306674912				; edb88320H
	xor	eax, ecx
	mov	ecx, eax
	shr	eax, 1
	and	ecx, 1
	imul	ecx, -306674912				; edb88320H
	xor	ecx, eax
	mov	eax, ecx
	shr	ecx, 1
	and	eax, 1
	imul	eax, -306674912				; edb88320H
	xor	eax, ecx
	mov	ecx, eax
	shr	eax, 1
	and	ecx, 1
	imul	ecx, -306674912				; edb88320H
	xor	ecx, eax
	mov	eax, ecx
	shr	ecx, 1
	and	eax, 1
	imul	eax, -306674912				; edb88320H
	xor	eax, ecx
	mov	ecx, eax
	shr	eax, 1
	and	ecx, 1
	imul	ecx, -306674912				; edb88320H
	xor	ecx, eax
	mov	eax, ecx
	shr	ecx, 1
	and	eax, 1
	imul	eax, -306674912				; edb88320H
	xor	eax, ecx
	cmp	r9d, 256				; 00000100H
	mov	DWORD PTR [r10-4], eax
	jl	$LL95@coff_write@2

; 460  : 
; 461  :         for ( i = is.NumberOfAuxSymbols;i;i--, p += sizeof(IMAGE_AUX_SYMBOL) ) {

	jmp	SHORT $LN93@coff_write@2
$LN171@coff_write@2:
	lea	r11, OFFSET FLAT:CRC32Table

; 514  :                 ias.Section.CheckSum = CRC32Comdat( curr->e.seginfo->CodeBuffer, curr->sym.max_offset, 0 );

$LN93@coff_write@2:
	test	rdi, rdi
	je	SHORT $LN83@coff_write@2
	test	r8d, r8d
	je	SHORT $LN83@coff_write@2
	npad	9
$LL85@coff_write@2:
	movzx	eax, BYTE PTR [rdi]
	movzx	ecx, dl
	inc	rdi
	xor	rcx, rax
	mov	eax, edx
	mov	edx, DWORD PTR [r11+rcx*4]
	shr	eax, 8
	xor	edx, eax
	add	r8d, -1					; ffffffffH
	jne	SHORT $LL85@coff_write@2
$LN83@coff_write@2:
	mov	DWORD PTR ias$[rsp+8], edx

; 515  :                 ias.Section.Number = curr->e.seginfo->comdat_number;

	mov	rax, QWORD PTR [r12+104]
	movzx	ecx, WORD PTR [rax+88]
	mov	WORD PTR ias$[rsp+12], cx

; 516  :                 ias.Section.Selection = curr->e.seginfo->comdat_selection;

	mov	rax, QWORD PTR [r12+104]
	movzx	ecx, BYTE PTR [rax+108]
	shr	cl, 3
	and	cl, 7
	mov	BYTE PTR ias$[rsp+14], cl

; 517  :             } else {

	jmp	SHORT $LN47@coff_write@2
$LN48@coff_write@2:

; 518  : #endif
; 519  :                 ias.Section.CheckSum = 0;

	mov	DWORD PTR ias$[rsp+8], ebx

; 520  :                 ias.Section.Number = 0;

	mov	WORD PTR ias$[rsp+12], bx

; 521  :                 ias.Section.Selection = 0;

	mov	BYTE PTR ias$[rsp+14], bl
$LN47@coff_write@2:

; 522  : #if COMDATSUPP
; 523  :             };
; 524  : #endif
; 525  :             if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR ias$[rsp]
	mov	r8d, 18
	mov	rdx, r13
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN46@coff_write@2

; 526  :                 WriteError();

	call	WriteError
$LN46@coff_write@2:

; 527  :             DebugMsg(("coff_write_symbols(%u, SECT): %s, AUX, relocs=%u, linnums=%u\n", cntSymbols, curr->sym.name, ias.Section.NumberOfRelocations, ias.Section.NumberOfLinenumbers ));
; 528  :             cntSymbols++;

	inc	ebp
$LN58@coff_write@2:

; 467  :     }
; 468  : 
; 469  :     /* next are section entries */
; 470  : 
; 471  :     for( i = 1, curr = SymTables[TAB_SEG].head; curr; curr = curr->next, i++ ) {

	mov	r12, QWORD PTR [r12+112]
	inc	r14d
	test	r12, r12
	jne	$LL59@coff_write@2
$LN57@coff_write@2:

; 529  :         }
; 530  :     }
; 531  : 
; 532  :     /* third are externals + communals ( + protos [since v2.01] ) */
; 533  : 
; 534  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	rdi, QWORD PTR SymTables+16
	test	rdi, rdi
	je	$LN43@coff_write@2
	npad	7
$LL45@coff_write@2:

; 535  :         /* skip "weak" (=unused) externdefs */
; 536  :         if ( curr->sym.iscomm == FALSE && curr->sym.weak == TRUE ) {

	movzx	eax, BYTE PTR [rdi+55]
	test	al, 4
	jne	SHORT $LN42@coff_write@2
	test	al, 8
	jne	$LN44@coff_write@2
$LN42@coff_write@2:

; 537  :             DebugMsg(("coff_write_symbols(EXT+COMM): %s skipped, used=%u, comm=%u, weak=%u\n", curr->sym.name, curr->sym.used, curr->sym.iscomm, curr->sym.weak ));
; 538  :             continue;
; 539  :         }
; 540  :         len = Mangle( &curr->sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rdi
	call	Mangle

; 541  : 
; 542  :         is.Type = CoffGetType(&curr->sym);

	movzx	ecx, BYTE PTR [rdi+49]
	and	cl, 8
	movsxd	r11, eax
	movzx	edx, cl
	shl	dx, 2
	mov	WORD PTR is$[rsp+14], dx

; 543  :         is.StorageClass = CoffGetClass(&curr->sym);

	cmp	DWORD PTR [rdi+40], 2
	jne	SHORT $LN107@coff_write@2
	test	BYTE PTR [rdi+55], 4
	jne	SHORT $LN106@coff_write@2
	cmp	QWORD PTR [rdi+72], r15
	je	SHORT $LN106@coff_write@2
	mov	ax, 105					; 00000069H
	jmp	SHORT $LN108@coff_write@2
$LN106@coff_write@2:
	mov	ax, 2
	jmp	SHORT $LN108@coff_write@2
$LN107@coff_write@2:
	test	BYTE PTR [rdi+48], 128			; 00000080H
	je	SHORT $LN103@coff_write@2
	mov	ax, 2
	jmp	SHORT $LN108@coff_write@2
$LN103@coff_write@2:
	cmp	DWORD PTR [rdi+44], 129			; 00000081H
	jne	SHORT $LN101@coff_write@2
	test	BYTE PTR [rdi+49], 8
	jne	SHORT $LN101@coff_write@2
	mov	ax, 6
	jmp	SHORT $LN108@coff_write@2
$LN101@coff_write@2:
	mov	ax, 3
$LN108@coff_write@2:
	mov	BYTE PTR is$[rsp+16], al

; 544  : 
; 545  :         DebugMsg(("coff_write_symbols(%u, EXT+COMM): %s, type=%x, stgcls=%x\n", cntSymbols, curr->sym.name, is.Type, is.StorageClass ));
; 546  : 
; 547  :         /* for COMMUNALs, store their size in the Value field */
; 548  :         if (curr->sym.iscomm == TRUE)

	test	BYTE PTR [rdi+55], 4
	je	SHORT $LN41@coff_write@2

; 549  :             is.Value = curr->sym.total_size;

	mov	eax, DWORD PTR [rdi+64]
	mov	DWORD PTR is$[rsp+8], eax

; 550  :         else

	jmp	SHORT $LN40@coff_write@2
$LN41@coff_write@2:

; 551  :             is.Value = curr->sym.offset; /* is always 0 */

	mov	eax, DWORD PTR [rdi+16]
	mov	DWORD PTR is$[rsp+8], eax
$LN40@coff_write@2:

; 552  :         is.SectionNumber = IMAGE_SYM_UNDEFINED;

	mov	WORD PTR is$[rsp+12], r15w

; 553  :         is.NumberOfAuxSymbols = (( curr->sym.iscomm == FALSE && curr->sym.altname ) ? 1 : 0 );

	test	BYTE PTR [rdi+55], 4
	jne	SHORT $LN76@coff_write@2
	cmp	QWORD PTR [rdi+72], r15
	je	SHORT $LN76@coff_write@2
	mov	BYTE PTR is$[rsp+17], 1
	jmp	SHORT $LN77@coff_write@2
$LN76@coff_write@2:
	mov	BYTE PTR is$[rsp+17], r15b
$LN77@coff_write@2:

; 554  : 
; 555  :         if ( len <= IMAGE_SIZEOF_SHORT_NAME )

	cmp	r11d, 8
	ja	SHORT $LN39@coff_write@2

; 556  :             strncpy( is.N.ShortName, buffer, IMAGE_SIZEOF_SHORT_NAME );

	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR is$[rsp]
	mov	r8d, 8
	call	strncpy

; 557  :         else {

	jmp	SHORT $LN38@coff_write@2
$LN39@coff_write@2:

; 558  :             is.N.Name.Short = 0;

	mov	DWORD PTR is$[rsp], ebx

; 559  :             is.N.Name.Long = Coff_AllocString( cm, buffer, len );

	mov	ebx, DWORD PTR [rsi+112]
	lea	rcx, QWORD PTR [r11+16]
	lea	eax, DWORD PTR [rbx+r11+1]
	mov	DWORD PTR [rsi+112], eax
	call	LclAlloc
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	r11, rax
	mov	QWORD PTR [rax], r15
	lea	rax, QWORD PTR buffer$[rsp]
	mov	r8, r11
	sub	r8, rax
	npad	7
$LL114@coff_write@2:
	movzx	ecx, BYTE PTR [rdx]
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rdx+r8+7], cl
	jne	SHORT $LL114@coff_write@2
	cmp	QWORD PTR [rsi+96], r15
	je	SHORT $LN111@coff_write@2
	mov	rax, QWORD PTR [rsi+104]
	mov	QWORD PTR [rax], r11
	mov	QWORD PTR [rsi+104], r11
	jmp	SHORT $LN110@coff_write@2
$LN111@coff_write@2:
	mov	QWORD PTR [rsi+104], r11
	mov	QWORD PTR [rsi+96], r11
$LN110@coff_write@2:
	mov	DWORD PTR is$[rsp+4], ebx
	xor	ebx, ebx
$LN38@coff_write@2:

; 560  :         }
; 561  :         if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR is$[rsp]
	mov	r8d, 18
	mov	rdx, r13
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN37@coff_write@2

; 562  :             WriteError();

	call	WriteError
$LN37@coff_write@2:

; 563  :         cntSymbols++;

	inc	ebp

; 564  : 
; 565  :         /* for weak externals, write the auxiliary record */
; 566  :         if ( curr->sym.iscomm == FALSE && curr->sym.altname ) {

	test	BYTE PTR [rdi+55], 4
	jne	SHORT $LN44@coff_write@2
	cmp	QWORD PTR [rdi+72], r15
	je	SHORT $LN44@coff_write@2

; 567  :             memset( &ias, 0, sizeof(ias) );
; 568  :             ias.Sym.TagIndex = curr->sym.altname->ext_idx;
; 569  :             /* v2.10: weak externals defined via "extern sym (altsym) ..."
; 570  :              * are to have characteristics IMAGE_WEAK_EXTERN_SEARCH_LIBRARY.
; 571  :              */
; 572  :             //ias.Sym.Misc.TotalSize = IMAGE_WEAK_EXTERN_SEARCH_ALIAS;
; 573  :             ias.Sym.Misc.TotalSize = IMAGE_WEAK_EXTERN_SEARCH_LIBRARY;
; 574  :             if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	r9, QWORD PTR ModuleInfo+104
	xor	eax, eax
	mov	r8d, 18
	mov	QWORD PTR ias$[rsp], rax
	mov	QWORD PTR ias$[rsp+8], rax
	mov	WORD PTR ias$[rsp+16], ax
	mov	rax, QWORD PTR [rdi+72]
	mov	rdx, r13
	mov	ecx, DWORD PTR [rax+96]
	mov	DWORD PTR ias$[rsp+4], 2
	mov	DWORD PTR ias$[rsp], ecx
	lea	rcx, QWORD PTR ias$[rsp]
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN35@coff_write@2

; 575  :                 WriteError();

	call	WriteError
$LN35@coff_write@2:

; 576  :             cntSymbols++;

	inc	ebp
$LN44@coff_write@2:

; 529  :         }
; 530  :     }
; 531  : 
; 532  :     /* third are externals + communals ( + protos [since v2.01] ) */
; 533  : 
; 534  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	rdi, QWORD PTR [rdi+112]
	test	rdi, rdi
	jne	$LL45@coff_write@2
$LN43@coff_write@2:

; 577  :         }
; 578  :     }
; 579  : 
; 580  :     /* publics and internal symbols. The internal symbols have
; 581  :      * been written to the "public" queue inside coff_write_data().
; 582  :      */
; 583  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	r14, QWORD PTR ModuleInfo+16
	test	r14, r14
	je	$LN32@coff_write@2
	npad	5
$LL34@coff_write@2:

; 584  :         sym = q->sym;

	mov	rbx, QWORD PTR [r14+8]

; 585  :         len = Mangle( sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rbx
	call	Mangle

; 586  : #ifdef DEBUG_OUT
; 587  :         if ( sym->state == SYM_INTERNAL && sym->isproc == TRUE && Options.line_numbers )
; 588  :             DebugMsg(("coff_write_symbols(%u): %s, file=%u\n", cntSymbols, sym->name, sym->debuginfo->file ));
; 589  : #endif
; 590  :         if ( Options.line_numbers &&
; 591  :             sym->isproc &&
; 592  :             sym->debuginfo->file != lastfile ) {

	cmp	BYTE PTR Options+1, 0
	movsxd	r13, eax
	je	$LN31@coff_write@2
	test	BYTE PTR [rbx+49], 8
	je	$LN31@coff_write@2
	mov	rcx, QWORD PTR [rbx+72]
	movzx	edx, WORD PTR [rcx+14]
	cmp	edx, r15d
	je	$LN31@coff_write@2

; 593  :             lastfile = sym->debuginfo->file;

	mov	r15d, edx

; 594  :             strncpy( is.N.ShortName, ".file", IMAGE_SIZEOF_SHORT_NAME );

	lea	rcx, QWORD PTR is$[rsp]
	lea	rdx, OFFSET FLAT:$SG6051
	mov	r8d, 8
	call	strncpy

; 595  :             is.SectionNumber = (uint_16)IMAGE_SYM_DEBUG;

	mov	WORD PTR is$[rsp+12], 65534		; 0000fffeH

; 596  :             is.Type = IMAGE_SYM_TYPE_NULL;

	mov	WORD PTR is$[rsp+14], 0

; 597  :             is.StorageClass = IMAGE_SYM_CLASS_FILE;

	mov	BYTE PTR is$[rsp+16], 103		; 00000067H

; 598  :             is.NumberOfAuxSymbols = GetFileAuxEntries( sym->debuginfo->file, &p );

	mov	rax, QWORD PTR [rbx+72]
	movzx	ecx, WORD PTR [rax+14]
	call	GetFName

; 599  :             is.Value = sym->debuginfo->next_file;
; 600  :             if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	rcx, -1
	mov	r12, QWORD PTR [rax]
	xor	eax, eax
	mov	rdi, r12
	repne scasb
	mov	rax, -2049638230412172401		; e38e38e38e38e38fH
	not	rcx
	dec	rcx
	mov	ecx, ecx
	mul	rcx
	shr	rdx, 4
	lea	rax, QWORD PTR [rdx+rdx*8]
	add	rax, rax
	sub	rcx, rax
	setne	al
	add	al, dl
	mov	edx, 1
	mov	BYTE PTR is$[rsp+17], al
	mov	rax, QWORD PTR [rbx+72]
	lea	r8d, QWORD PTR [rdx+17]
	mov	ecx, DWORD PTR [rax+20]
	mov	DWORD PTR is$[rsp+8], ecx
	lea	rcx, QWORD PTR is$[rsp]
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN30@coff_write@2

; 601  :                 WriteError();

	call	WriteError
$LN30@coff_write@2:

; 602  : 
; 603  :             for ( i = is.NumberOfAuxSymbols; i; i--, p += sizeof(IMAGE_AUX_SYMBOL) ) {

	movzx	eax, BYTE PTR is$[rsp+17]
	test	al, al
	mov	edi, eax
	je	SHORT $LN27@coff_write@2
	mov	esi, 1
	npad	13
$LL29@coff_write@2:

; 604  :                 strncpy( ias.File.Name, p, sizeof(IMAGE_AUX_SYMBOL) );

	lea	rcx, QWORD PTR ias$[rsp]
	mov	r8d, 18
	mov	rdx, r12
	call	strncpy

; 605  :                 if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR ias$[rsp]
	mov	r8d, 18
	mov	rdx, rsi
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN28@coff_write@2

; 606  :                     WriteError();

	call	WriteError
$LN28@coff_write@2:

; 602  : 
; 603  :             for ( i = is.NumberOfAuxSymbols; i; i--, p += sizeof(IMAGE_AUX_SYMBOL) ) {

	add	r12, 18
	add	edi, -1					; ffffffffH
	jne	SHORT $LL29@coff_write@2
	movzx	eax, BYTE PTR is$[rsp+17]
	mov	rsi, QWORD PTR cm$[rsp]
$LN27@coff_write@2:

; 607  :             }
; 608  :             cntSymbols += is.NumberOfAuxSymbols + 1;

	movzx	eax, al
	lea	ebp, DWORD PTR [rbp+rax+1]
$LN31@coff_write@2:

; 609  :         }
; 610  :         is.Type = CoffGetType( sym );

	movzx	eax, BYTE PTR [rbx+49]
	and	al, 8
	movzx	ecx, al
	shl	cx, 2
	mov	WORD PTR is$[rsp+14], cx

; 611  :         is.StorageClass = CoffGetClass( sym );

	cmp	DWORD PTR [rbx+40], 2
	jne	SHORT $LN127@coff_write@2
	test	BYTE PTR [rbx+55], 4
	jne	SHORT $LN126@coff_write@2
	cmp	QWORD PTR [rbx+72], 0
	je	SHORT $LN126@coff_write@2
	mov	ax, 105					; 00000069H
	jmp	SHORT $LN128@coff_write@2
$LN126@coff_write@2:
	mov	ax, 2
	jmp	SHORT $LN128@coff_write@2
$LN127@coff_write@2:
	test	BYTE PTR [rbx+48], 128			; 00000080H
	je	SHORT $LN123@coff_write@2
	mov	ax, 2
	jmp	SHORT $LN128@coff_write@2
$LN123@coff_write@2:
	cmp	DWORD PTR [rbx+44], 129			; 00000081H
	jne	SHORT $LN121@coff_write@2
	test	BYTE PTR [rbx+49], 8
	jne	SHORT $LN121@coff_write@2
	mov	ax, 6
	jmp	SHORT $LN128@coff_write@2
$LN121@coff_write@2:
	mov	ax, 3
$LN128@coff_write@2:
	mov	BYTE PTR is$[rsp+16], al

; 612  :         is.Value = sym->offset;

	mov	eax, DWORD PTR [rbx+16]
	mov	DWORD PTR is$[rsp+8], eax

; 613  : #if 1 /* v2.07: changed - to make MT_ABS obsolete */
; 614  :         if ( sym->state == SYM_INTERNAL ) {

	cmp	DWORD PTR [rbx+40], 1
	jne	SHORT $LN25@coff_write@2

; 615  :             if ( sym->segment )

	mov	rcx, QWORD PTR [rbx+32]
	test	rcx, rcx
	je	SHORT $LN24@coff_write@2

; 616  :                 is.SectionNumber = GetSegIdx( sym->segment );

	call	GetSegIdx
	mov	WORD PTR is$[rsp+12], ax

; 617  :             else

	jmp	SHORT $LN22@coff_write@2
$LN24@coff_write@2:

; 618  :                 is.SectionNumber = (uint_16)IMAGE_SYM_ABSOLUTE;

	mov	WORD PTR is$[rsp+12], 65535		; 0000ffffH

; 619  :         } else

	jmp	SHORT $LN22@coff_write@2
$LN25@coff_write@2:

; 620  :             is.SectionNumber = IMAGE_SYM_UNDEFINED;

	mov	WORD PTR is$[rsp+12], 0
$LN22@coff_write@2:

; 621  : #else
; 622  :         if ( sym->state == SYM_EXTERNAL )
; 623  :             is.SectionNumber = IMAGE_SYM_UNDEFINED;
; 624  :         else if ( sym->mem_type == MT_ABS )
; 625  :             is.SectionNumber = IMAGE_SYM_ABSOLUTE;
; 626  :         else if ( sym->segment )
; 627  :             is.SectionNumber = GetSegIdx( sym->segment );
; 628  :         else
; 629  :             is.SectionNumber = IMAGE_SYM_UNDEFINED;
; 630  : #endif
; 631  :         is.NumberOfAuxSymbols = 0;

	xor	al, al

; 632  :         if ( Options.line_numbers && sym->isproc )

	cmp	BYTE PTR Options+1, al
	mov	BYTE PTR is$[rsp+17], al
	je	SHORT $LN21@coff_write@2
	test	BYTE PTR [rbx+49], 8
	movzx	eax, al
	mov	ecx, 1
	cmovne	eax, ecx
	mov	BYTE PTR is$[rsp+17], al
$LN21@coff_write@2:

; 633  :             is.NumberOfAuxSymbols++;
; 634  : 
; 635  :         if ( len <= IMAGE_SIZEOF_SHORT_NAME )

	cmp	r13d, 8
	ja	SHORT $LN20@coff_write@2

; 636  :             strncpy( is.N.ShortName, buffer, IMAGE_SIZEOF_SHORT_NAME );

	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR is$[rsp]
	mov	r8d, 8
	call	strncpy

; 637  :         else {

	jmp	SHORT $LN19@coff_write@2
$LN20@coff_write@2:

; 638  :             is.N.Name.Short = 0;
; 639  :             is.N.Name.Long = Coff_AllocString( cm, buffer, len );

	mov	r12d, DWORD PTR [rsi+112]
	lea	rcx, QWORD PTR [r13+16]
	mov	DWORD PTR is$[rsp], 0
	lea	eax, DWORD PTR [r12+r13+1]
	mov	DWORD PTR [rsi+112], eax
	call	LclAlloc
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rdi, rax
	sub	rax, rcx
	lea	rdx, QWORD PTR buffer$[rsp]
	npad	13
$LL134@coff_write@2:
	movzx	ecx, BYTE PTR [rdx]
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rdx+rax+7], cl
	jne	SHORT $LL134@coff_write@2
	cmp	QWORD PTR [rsi+96], 0
	je	SHORT $LN131@coff_write@2
	mov	rax, QWORD PTR [rsi+104]
	mov	QWORD PTR [rax], rdi
	mov	QWORD PTR [rsi+104], rdi
	jmp	SHORT $LN130@coff_write@2
$LN131@coff_write@2:
	mov	QWORD PTR [rsi+104], rdi
	mov	QWORD PTR [rsi+96], rdi
$LN130@coff_write@2:
	mov	DWORD PTR is$[rsp+4], r12d
$LN19@coff_write@2:

; 640  :         }
; 641  : 
; 642  :         DebugMsg(("coff_write_symbols(%u, PUB+INT): %s, ofs=%X, type=%X, stgcls=%X\n", cntSymbols, buffer, is.Value, is.Type, is.StorageClass ));
; 643  : 
; 644  :         if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	r13d, 1
	lea	rcx, QWORD PTR is$[rsp]
	mov	rdx, r13
	mov	r8d, 18
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN18@coff_write@2

; 645  :             WriteError();

	call	WriteError
$LN18@coff_write@2:

; 646  :         cntSymbols++;

	inc	ebp

; 647  :         if ( Options.line_numbers && sym->isproc ) {

	cmp	BYTE PTR Options+1, 0
	je	$LN33@coff_write@2
	test	BYTE PTR [rbx+49], 8
	je	$LN33@coff_write@2

; 648  :             /* write:
; 649  :              * 1.   the aux for the proc
; 650  :              * 2+3. a .bf record with 1 aux
; 651  :              * 4.   a .lf record with 0 aux
; 652  :              * 5+6. a .ef record with 1 aux
; 653  :              */
; 654  :             ias.Sym.TagIndex = cntSymbols+1;
; 655  :             ias.Sym.Misc.TotalSize = sym->total_size;
; 656  :             ias.Sym.FcnAry.Function.PointerToLinenumber = sym->debuginfo->ln_fileofs;
; 657  :             ias.Sym.FcnAry.Function.PointerToNextFunction = sym->debuginfo->next_proc;
; 658  :             if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	eax, DWORD PTR [rbp+1]
	mov	r8d, 18
	mov	DWORD PTR ias$[rsp], eax
	mov	eax, DWORD PTR [rbx+64]
	mov	rdx, r13
	mov	DWORD PTR ias$[rsp+4], eax
	mov	rax, QWORD PTR [rbx+72]
	mov	ecx, DWORD PTR [rax+8]
	mov	DWORD PTR ias$[rsp+8], ecx
	mov	rax, QWORD PTR [rbx+72]
	mov	ecx, DWORD PTR [rax+16]
	mov	DWORD PTR ias$[rsp+12], ecx
	lea	rcx, QWORD PTR ias$[rsp]
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN16@coff_write@2

; 659  :                 WriteError();

	call	WriteError
$LN16@coff_write@2:

; 660  : 
; 661  :             strncpy( is.N.ShortName, ".bf", IMAGE_SIZEOF_SHORT_NAME );

	lea	rdx, OFFSET FLAT:$SG6071
	lea	rcx, QWORD PTR is$[rsp]
	mov	r8d, 8
	call	strncpy

; 662  :             is.Type = IMAGE_SYM_TYPE_NULL;
; 663  :             is.NumberOfAuxSymbols = 1;
; 664  :             is.StorageClass = IMAGE_SYM_CLASS_FUNCTION;
; 665  :             if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR is$[rsp]
	mov	r8d, 18
	mov	rdx, r13
	mov	WORD PTR is$[rsp+14], 0
	mov	BYTE PTR is$[rsp+17], r13b
	mov	BYTE PTR is$[rsp+16], 101		; 00000065H
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN15@coff_write@2

; 666  :                 WriteError();

	call	WriteError
$LN15@coff_write@2:

; 667  :             ias.Sym.TagIndex = 0;

	xor	edi, edi
	mov	DWORD PTR ias$[rsp], edi

; 668  :             ias.Sym.Misc.LnSz.Linenumber = sym->debuginfo->start_line;

	mov	rax, QWORD PTR [rbx+72]
	movzx	ecx, WORD PTR [rax]
	mov	WORD PTR ias$[rsp+4], cx

; 669  :             if ( sym->debuginfo->next_proc )

	mov	rax, QWORD PTR [rbx+72]
	cmp	DWORD PTR [rax+16], edi
	je	SHORT $LN14@coff_write@2

; 670  :                 ias.Sym.FcnAry.Function.PointerToNextFunction = sym->debuginfo->next_proc + 2;

	mov	ecx, DWORD PTR [rax+16]
	add	ecx, 2
	mov	DWORD PTR ias$[rsp+12], ecx

; 671  :             else

	jmp	SHORT $LN13@coff_write@2
$LN14@coff_write@2:

; 672  :                 ias.Sym.FcnAry.Function.PointerToNextFunction = 0;

	mov	DWORD PTR ias$[rsp+12], edi
$LN13@coff_write@2:

; 673  :             if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR ias$[rsp]
	mov	r8d, 18
	mov	rdx, r13
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN12@coff_write@2

; 674  :                 WriteError();

	call	WriteError
$LN12@coff_write@2:

; 675  : 
; 676  :             strncpy( is.N.ShortName, ".lf", IMAGE_SIZEOF_SHORT_NAME );

	lea	rdx, OFFSET FLAT:$SG6076
	lea	rcx, QWORD PTR is$[rsp]
	mov	r8d, 8
	call	strncpy

; 677  :             is.Type = IMAGE_SYM_TYPE_NULL;
; 678  :             is.NumberOfAuxSymbols = 0;
; 679  :             is.StorageClass = IMAGE_SYM_CLASS_FUNCTION;
; 680  :             is.Value = sym->debuginfo->line_numbers;
; 681  :             if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	WORD PTR is$[rsp+14], di
	mov	BYTE PTR is$[rsp+17], dil
	mov	BYTE PTR is$[rsp+16], 101		; 00000065H
	mov	rax, QWORD PTR [rbx+72]
	movzx	ecx, WORD PTR [rax+12]
	mov	r8d, 18
	mov	rdx, r13
	mov	DWORD PTR is$[rsp+8], ecx
	lea	rcx, QWORD PTR is$[rsp]
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN11@coff_write@2

; 682  :                 WriteError();

	call	WriteError
$LN11@coff_write@2:

; 683  : 
; 684  :             strncpy( is.N.ShortName, ".ef", IMAGE_SIZEOF_SHORT_NAME );

	lea	rdx, OFFSET FLAT:$SG6078
	lea	rcx, QWORD PTR is$[rsp]
	mov	r8d, 8
	call	strncpy

; 685  :             is.Type = IMAGE_SYM_TYPE_NULL;
; 686  :             is.NumberOfAuxSymbols = 1;
; 687  :             is.StorageClass = IMAGE_SYM_CLASS_FUNCTION;
; 688  :             is.Value = sym->offset + sym->total_size;
; 689  :             if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	WORD PTR is$[rsp+14], di
	mov	BYTE PTR is$[rsp+17], r13b
	mov	BYTE PTR is$[rsp+16], 101		; 00000065H
	mov	eax, DWORD PTR [rbx+64]
	add	eax, DWORD PTR [rbx+16]
	lea	rcx, QWORD PTR is$[rsp]
	mov	r8d, 18
	mov	rdx, r13
	mov	DWORD PTR is$[rsp+8], eax
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN10@coff_write@2

; 690  :                 WriteError();

	call	WriteError
$LN10@coff_write@2:

; 691  :             ias.Sym.TagIndex = 0;
; 692  :             ias.Sym.Misc.LnSz.Linenumber = sym->debuginfo->end_line;
; 693  :             if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	DWORD PTR ias$[rsp], edi
	mov	rax, QWORD PTR [rbx+72]
	movzx	ecx, WORD PTR [rax+4]
	mov	r8d, 18
	mov	rdx, r13
	mov	WORD PTR ias$[rsp+4], cx
	lea	rcx, QWORD PTR ias$[rsp]
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN9@coff_write@2

; 694  :                 WriteError();

	call	WriteError
$LN9@coff_write@2:

; 695  : 
; 696  :             cntSymbols += 6;

	add	ebp, 6
$LN33@coff_write@2:

; 577  :         }
; 578  :     }
; 579  : 
; 580  :     /* publics and internal symbols. The internal symbols have
; 581  :      * been written to the "public" queue inside coff_write_data().
; 582  :      */
; 583  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	r14, QWORD PTR [r14]
	test	r14, r14
	jne	$LL34@coff_write@2
$LN32@coff_write@2:

; 697  :         }
; 698  :     }
; 699  : 
; 700  :     /* aliases. A weak external entry with 1 aux entry is created.
; 701  :      */
; 702  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+80
	mov	r15, QWORD PTR [rsp+360]
	test	rbx, rbx
	je	$LN170@coff_write@2
	xor	r14d, r14d
	npad	11
$LL8@coff_write@2:

; 703  :         struct asym * sym;
; 704  : 
; 705  :         len = Mangle( &curr->sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rbx
	call	Mangle
	movsxd	rdx, eax

; 706  : 
; 707  :         if ( len <= IMAGE_SIZEOF_SHORT_NAME )

	cmp	edx, 8
	ja	SHORT $LN5@coff_write@2

; 708  :             strncpy( is.N.ShortName, buffer, IMAGE_SIZEOF_SHORT_NAME );

	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR is$[rsp]
	mov	r8d, 8
	call	strncpy

; 709  :         else {

	jmp	SHORT $LN4@coff_write@2
$LN5@coff_write@2:

; 710  :             is.N.Name.Short = 0;
; 711  :             is.N.Name.Long = Coff_AllocString( cm, buffer, len );

	mov	r12d, DWORD PTR [rsi+112]
	lea	rcx, QWORD PTR [rdx+16]
	mov	DWORD PTR is$[rsp], r14d
	lea	eax, DWORD PTR [r12+rdx+1]
	mov	DWORD PTR [rsi+112], eax
	call	LclAlloc
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rax], r14
	mov	rdi, rax
	sub	rax, rcx
	lea	rdx, QWORD PTR buffer$[rsp]
	npad	7
$LL139@coff_write@2:
	movzx	ecx, BYTE PTR [rdx]
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rdx+rax+7], cl
	jne	SHORT $LL139@coff_write@2
	cmp	QWORD PTR [rsi+96], r14
	je	SHORT $LN136@coff_write@2
	mov	rax, QWORD PTR [rsi+104]
	mov	QWORD PTR [rax], rdi
	mov	QWORD PTR [rsi+104], rdi
	jmp	SHORT $LN135@coff_write@2
$LN136@coff_write@2:
	mov	QWORD PTR [rsi+104], rdi
	mov	QWORD PTR [rsi+96], rdi
$LN135@coff_write@2:
	mov	DWORD PTR is$[rsp+4], r12d
$LN4@coff_write@2:

; 712  :         }
; 713  : 
; 714  :         is.Value = 0;
; 715  :         is.SectionNumber = IMAGE_SYM_UNDEFINED;
; 716  :         is.Type = IMAGE_SYM_TYPE_NULL;
; 717  :         is.StorageClass = IMAGE_SYM_CLASS_WEAK_EXTERNAL;
; 718  :         is.NumberOfAuxSymbols = 1;
; 719  : 
; 720  :         DebugMsg(("coff_write_symbols(%u, ALIAS): symbol %s, ofs=%X\n", cntSymbols, buffer, is.Value ));
; 721  : 
; 722  :         if ( fwrite( &is, 1, sizeof(is), CurrFile[OBJ] ) != sizeof(is) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR is$[rsp]
	mov	r8d, 18
	mov	rdx, r13
	mov	DWORD PTR is$[rsp+8], r14d
	mov	WORD PTR is$[rsp+12], r14w
	mov	WORD PTR is$[rsp+14], r14w
	mov	BYTE PTR is$[rsp+16], 105		; 00000069H
	mov	BYTE PTR is$[rsp+17], 1
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN3@coff_write@2

; 723  :             WriteError();

	call	WriteError
$LN3@coff_write@2:

; 724  :         cntSymbols++;
; 725  : 
; 726  :         memset( &ias, 0, sizeof(ias) );

	xor	eax, eax
	mov	QWORD PTR ias$[rsp], rax
	mov	QWORD PTR ias$[rsp+8], rax
	mov	WORD PTR ias$[rsp+16], ax

; 727  : 
; 728  :         /* v2.04b: adjusted to new field <substitute> */
; 729  :         //sym = SymSearch( curr->sym.string_ptr );
; 730  :         sym = curr->sym.substitute;

	mov	rax, QWORD PTR [rbx+16]

; 731  :         if (sym)

	test	rax, rax
	je	SHORT $LN2@coff_write@2

; 732  :             ias.Sym.TagIndex = sym->ext_idx;

	mov	eax, DWORD PTR [rax+96]
	mov	DWORD PTR ias$[rsp], eax
$LN2@coff_write@2:

; 733  : 
; 734  :         ias.Sym.Misc.TotalSize = IMAGE_WEAK_EXTERN_SEARCH_ALIAS;
; 735  :         if ( fwrite( &ias, 1, sizeof(ias), CurrFile[OBJ] ) != sizeof(ias) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR ias$[rsp]
	mov	r8d, 18
	mov	rdx, r13
	mov	DWORD PTR ias$[rsp+4], 3
	call	fwrite
	cmp	rax, 18
	je	SHORT $LN1@coff_write@2

; 736  :             WriteError();

	call	WriteError
$LN1@coff_write@2:

; 697  :         }
; 698  :     }
; 699  : 
; 700  :     /* aliases. A weak external entry with 1 aux entry is created.
; 701  :      */
; 702  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {

	mov	rbx, QWORD PTR [rbx+112]

; 737  :         cntSymbols++;

	add	ebp, 2
	test	rbx, rbx
	jne	$LL8@coff_write@2
$LN170@coff_write@2:
	mov	r14, QWORD PTR [rsp+368]
	mov	r13, QWORD PTR [rsp+376]
	mov	r12, QWORD PTR [rsp+384]
	mov	rdi, QWORD PTR [rsp+392]
	mov	rsi, QWORD PTR [rsp+400]
	mov	rbx, QWORD PTR [rsp+432]

; 738  : 
; 739  :     }
; 740  : 
; 741  :     DebugMsg(("coff_write_symbols: exit cntSymbols=%u\n", cntSymbols ));
; 742  :     return( cntSymbols );

	mov	eax, ebp
	mov	rbp, QWORD PTR [rsp+440]

; 743  : }

	add	rsp, 408				; 00000198H
	ret	0
coff_write_symbols ENDP
_TEXT	ENDS
EXTRN	EmitWarn:NEAR
xdata	SEGMENT
$unwind$GetStartLabel DD 061f01H
	DD	029741fH
	DD	028340eH
	DD	025010aH
xdata	ENDS
pdata	SEGMENT
$pdata$GetStartLabel DD @imagerel(GetStartLabel#)
	DD	@imagerel(GetStartLabel#+318)
	DD	@imagerel($unwind$GetStartLabel#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
temp$ = 32
buffer$ = 304
msg$ = 312
GetStartLabel PROC NEAR

; 747  : {

	mov	rax, rsp
	sub	rsp, 296				; 00000128H
	mov	QWORD PTR [rax+24], rbx
	mov	rbx, rcx

; 748  :     int size = 0;
; 749  :     char temp[ MAX_ID_LEN + MANGLE_BYTES + 1 ];
; 750  : 
; 751  :     if ( ModuleInfo.g.start_label ) {

	mov	rcx, QWORD PTR ModuleInfo+208
	test	rcx, rcx
	mov	QWORD PTR [rax+32], rdi
	movzx	edi, dl
	je	$LN19@GetStartLa

; 752  :         Mangle( ModuleInfo.g.start_label, temp );

	lea	rdx, QWORD PTR temp$[rsp]
	call	Mangle

; 753  :         if ( Options.entry_decorated )

	cmp	BYTE PTR Options+128, 0
	je	SHORT $LN7@GetStartLa

; 754  :             strcpy( buffer, temp );

	lea	rax, QWORD PTR temp$[rsp]
	mov	rcx, rbx
	lea	rdx, QWORD PTR temp$[rsp]
	sub	rcx, rax
	npad	5
$LL11@GetStartLa:
	movzx	eax, BYTE PTR [rdx]
	inc	rdx
	test	al, al
	mov	BYTE PTR [rcx+rdx-1], al
	jne	SHORT $LL11@GetStartLa

; 755  :         else {

	jmp	$LN1@GetStartLa
$LN7@GetStartLa:

; 756  :             if ( ModuleInfo.g.start_label->langtype != LANG_C &&
; 757  :                 ModuleInfo.g.start_label->langtype != LANG_STDCALL &&
; 758  :                 ModuleInfo.g.start_label->langtype != LANG_SYSCALL ) {

	mov	rcx, QWORD PTR ModuleInfo+208
	mov	eax, DWORD PTR [rcx+84]
	cmp	eax, 1
	je	SHORT $LN5@GetStartLa
	cmp	eax, 3
	je	SHORT $LN5@GetStartLa
	cmp	eax, 2
	je	SHORT $LN5@GetStartLa

; 759  :                 if ( *ModuleInfo.g.start_label->name != '_' ) {

	mov	r8, QWORD PTR [rcx+8]
	cmp	BYTE PTR [r8], 95			; 0000005fH
	je	SHORT $LN4@GetStartLa

; 760  :                     if ( msg && ( ModuleInfo.fctype != FCT_WIN64 ) )

	test	dil, dil
	je	SHORT $LN3@GetStartLa
	cmp	DWORD PTR ModuleInfo+376, 2
	je	SHORT $LN3@GetStartLa

; 761  :                         EmitWarn( 2, LEADING_UNDERSCORE_REQUIRED_FOR_START_LABEL, ModuleInfo.g.start_label->name );

	mov	edx, 194				; 000000c2H
	mov	ecx, 2
	call	EmitWarn
$LN3@GetStartLa:

; 762  :                     strcpy( buffer, temp );

	lea	rax, QWORD PTR temp$[rsp]
	mov	rdx, rbx
	lea	rcx, QWORD PTR temp$[rsp]
	sub	rdx, rax
	npad	13
$LL12@GetStartLa:
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx+rcx-1], al
	jne	SHORT $LL12@GetStartLa

; 763  :                 } else {

	jmp	SHORT $LN1@GetStartLa
$LN4@GetStartLa:

; 764  :                     strcpy( buffer, temp+1 );

	lea	rax, QWORD PTR temp$[rsp+1]
	mov	rdx, rbx
	lea	rcx, QWORD PTR temp$[rsp+1]
	sub	rdx, rax
$LL13@GetStartLa:
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx+rcx-1], al
	jne	SHORT $LL13@GetStartLa

; 765  :                 }
; 766  :             } else

	jmp	SHORT $LN1@GetStartLa
$LN5@GetStartLa:

; 767  :                 strcpy( buffer, temp+1 );

	lea	rax, QWORD PTR temp$[rsp+1]
	mov	rdx, rbx
	lea	rcx, QWORD PTR temp$[rsp+1]
	sub	rdx, rax
$LL14@GetStartLa:
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx+rcx-1], al
	jne	SHORT $LL14@GetStartLa
$LN1@GetStartLa:

; 768  :         }
; 769  :         size = strlen( buffer ) + 8; // 8 == size of " -entry:"

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx

; 770  :     }
; 771  :     return( size );

	lea	eax, DWORD PTR [rcx+7]
	jmp	SHORT $LN8@GetStartLa
$LN19@GetStartLa:
	xor	eax, eax
$LN8@GetStartLa:
	mov	rdi, QWORD PTR [rsp+328]
	mov	rbx, QWORD PTR [rsp+320]

; 772  : }

	add	rsp, 296				; 00000128H
	ret	0
GetStartLabel ENDP
_TEXT	ENDS
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$coff_flushfunc DD 071701H
	DD	05d417H
	DD	06c412H
	DD	0a640dH
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$coff_flushfunc DD @imagerel(coff_flushfunc#)
	DD	@imagerel(coff_flushfunc#+61)
	DD	@imagerel($unwind$coff_flushfunc#)
pdata	ENDS
xdata	SEGMENT
$chain$5$coff_flushfunc DD 061321H
	DD	0b7413H
	DD	09540eH
	DD	083405H
	DD	@imagerel(coff_flushfunc#)
	DD	@imagerel(coff_flushfunc#+61)
	DD	@imagerel($unwind$coff_flushfunc#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$coff_flushfunc DD @imagerel(coff_flushfunc#+61)
	DD	@imagerel(coff_flushfunc#+151)
	DD	@imagerel($chain$5$coff_flushfunc#)
pdata	ENDS
xdata	SEGMENT
$chain$6$coff_flushfunc DD 020021H
	DD	095400H
	DD	@imagerel(coff_flushfunc#)
	DD	@imagerel(coff_flushfunc#+61)
	DD	@imagerel($unwind$coff_flushfunc#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$coff_flushfunc DD @imagerel(coff_flushfunc#+151)
	DD	@imagerel(coff_flushfunc#+208)
	DD	@imagerel($chain$6$coff_flushfunc#)
pdata	ENDS
xdata	SEGMENT
$chain$7$coff_flushfunc DD 021H
	DD	@imagerel(coff_flushfunc#)
	DD	@imagerel(coff_flushfunc#+61)
	DD	@imagerel($unwind$coff_flushfunc#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$coff_flushfunc DD @imagerel(coff_flushfunc#+208)
	DD	@imagerel(coff_flushfunc#+260)
	DD	@imagerel($chain$7$coff_flushfunc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
seg$ = 64
curr$ = 72
size$ = 80
pv$ = 88
coff_flushfunc PROC NEAR

; 778  : {

	sub	rsp, 56					; 00000038H

; 779  :     unsigned currsize = curr - seg->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR [rcx+104]
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+48], r12
	mov	QWORD PTR [rsp+40], r13
	mov	r13d, edx
	mov	rsi, r9
	sub	r13d, DWORD PTR [rax+16]
	mov	r12, rcx

; 780  :     struct coffmod *cm;
; 781  :     int i;
; 782  :     uint_8 *p;
; 783  : 
; 784  :     if ( ( currsize + size ) > SIZE_CV_SEGBUF ) {

	lea	eax, DWORD PTR [r13+r8]
	cmp	eax, 2048				; 00000800H
	jbe	$LN4@coff_flush

; 785  :         if ( currsize ) {

	test	r13d, r13d
	je	$LN3@coff_flush
	mov	QWORD PTR [rsp+64], rbx

; 786  :             p = LclAlloc( currsize + sizeof( struct qditem ) );

	lea	rcx, QWORD PTR [r13+16]
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+88], rdi
	call	LclAlloc

; 787  :             ((struct qditem *)p)->next = NULL;

	xor	edi, edi
	mov	QWORD PTR [rax], rdi

; 788  :             ((struct qditem *)p)->size = currsize;

	mov	DWORD PTR [rax+8], r13d

; 789  :             memcpy( p + sizeof( struct qditem ), seg->e.seginfo->CodeBuffer, currsize );

	mov	rdx, QWORD PTR [r12+104]
	mov	rdx, QWORD PTR [rdx+16]
	lea	rcx, QWORD PTR [rax+16]
	mov	r8d, r13d
	mov	rbp, rax
	call	memcpy

; 790  :             cm = pv;
; 791  :             i = ( seg == cm->SymDeb[DBGS_TYPES].seg ? DBGS_TYPES : DBGS_SYMBOLS );

	cmp	r12, QWORD PTR [rsi+72]
	mov	rbx, QWORD PTR [rsp+64]
	sete	dil

; 792  :             if ( cm->SymDeb[i].q.head == NULL )

	movsxd	rcx, edi
	mov	rdi, QWORD PTR [rsp+88]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	cmp	QWORD PTR [rsi+rdx*8+56], 0
	jne	SHORT $LN2@coff_flush

; 793  :                 cm->SymDeb[i].q.head = cm->SymDeb[i].q.tail = p;

	mov	QWORD PTR [rsi+rdx*8+64], rbp
	mov	QWORD PTR [rsi+rdx*8+56], rbp

; 794  :             else {

	jmp	SHORT $LN1@coff_flush
$LN2@coff_flush:

; 795  :                 ((struct qditem *)(cm->SymDeb[i].q.tail))->next = p;

	mov	rax, QWORD PTR [rsi+rdx*8+64]
	mov	QWORD PTR [rax], rbp

; 796  :                 cm->SymDeb[i].q.tail = p;

	mov	QWORD PTR [rsi+rdx*8+64], rbp
$LN1@coff_flush:

; 797  :             }
; 798  :             seg->e.seginfo->current_loc = seg->e.seginfo->start_loc + currsize;

	mov	rdx, QWORD PTR [r12+104]
	mov	rbp, QWORD PTR [rsp+72]
	mov	eax, DWORD PTR [rdx+8]
	lea	ecx, DWORD PTR [r13+rax]
	mov	DWORD PTR [rdx+12], ecx

; 799  :             seg->e.seginfo->start_loc = seg->e.seginfo->current_loc;

	mov	rcx, QWORD PTR [r12+104]
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rcx+8], eax
$LN3@coff_flush:

; 800  :         }
; 801  :         return( seg->e.seginfo->CodeBuffer );

	mov	rax, QWORD PTR [r12+104]
	mov	rax, QWORD PTR [rax+16]
	mov	r13, QWORD PTR [rsp+40]
	mov	r12, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+80]

; 804  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN4@coff_flush:
	mov	r13, QWORD PTR [rsp+40]
	mov	r12, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+80]

; 802  :     }
; 803  :     return( curr );

	mov	rax, rdx

; 804  : }

	add	rsp, 56					; 00000038H
	ret	0
coff_flushfunc ENDP
_TEXT	ENDS
EXTRN	AddPublicData:NEAR
xdata	SEGMENT
$unwind$SetSymbolIndices DD 0b1f01H
	DD	06e41fH
	DD	08c41aH
	DD	0d7415H
	DD	0b540eH
	DD	0a3409H
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetSymbolIndices DD @imagerel(SetSymbolIndices#)
	DD	@imagerel(SetSymbolIndices#+298)
	DD	@imagerel($unwind$SetSymbolIndices#)
pdata	ENDS
xdata	SEGMENT
$chain$6$SetSymbolIndices DD 040f21H
	DD	0c640fH
	DD	07d405H
	DD	@imagerel(SetSymbolIndices#)
	DD	@imagerel(SetSymbolIndices#+298)
	DD	@imagerel($unwind$SetSymbolIndices#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$SetSymbolIndices DD @imagerel(SetSymbolIndices#+298)
	DD	@imagerel(SetSymbolIndices#+506)
	DD	@imagerel($chain$6$SetSymbolIndices#)
pdata	ENDS
xdata	SEGMENT
$chain$7$SetSymbolIndices DD 021H
	DD	@imagerel(SetSymbolIndices#)
	DD	@imagerel(SetSymbolIndices#+298)
	DD	@imagerel($unwind$SetSymbolIndices#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$SetSymbolIndices DD @imagerel(SetSymbolIndices#+506)
	DD	@imagerel(SetSymbolIndices#+538)
	DD	@imagerel($chain$7$SetSymbolIndices#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
tv187 = 32
tv90 = 32
lastfproc$ = 32
ModuleInfo$ = 80
cm$ = 88
SetSymbolIndices PROC NEAR

; 812  : {

	sub	rsp, 72					; 00000048H
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+88], rbp

; 813  :     struct qnode *q;
; 814  :     struct dsym  *curr;
; 815  :     struct asym  *sym;
; 816  :     uint_32 index;
; 817  :     uint_32 i;
; 818  :     struct asym *lastfproc;
; 819  :     unsigned lastfile = 0;
; 820  : 
; 821  :     index = 0;
; 822  :     cm->lastproc = NULL;
; 823  :     cm->start_files = 0;  /* v2.11: added */
; 824  : 
; 825  : #if COMPID
; 826  :     index++;
; 827  : #endif
; 828  :     /* add absolute symbol @@feat.00 if -SAFESEH is set */
; 829  :     if ( Options.safeseh )

	xor	ebx, ebx
	mov	QWORD PTR [rsp+104], rdi
	mov	QWORD PTR [rsp+64], r12
	mov	QWORD PTR [rsp+48], r14
	xor	r14d, r14d
	mov	eax, 1
	mov	r12, rdx
	mov	QWORD PTR [rdx+16], r14
	mov	DWORD PTR [rdx+40], r14d
	cmp	BYTE PTR Options+151, bl
	cmovne	ebx, eax

; 830  :         index++;
; 831  : 
; 832  :     /* count AUX entries for .file. Depends on sizeof filename */
; 833  : 
; 834  :     if ( Options.no_file_entry == FALSE ) {

	cmp	BYTE PTR Options+122, r14b
	mov	rbp, rcx
	mov	rdx, -2049638230412172401		; e38e38e38e38e38fH
	jne	SHORT $LN20@SetSymbolI

; 835  :         i = strlen( cm->dot_file_value );

	mov	rdi, QWORD PTR [r12+24]
	xor	eax, eax
	mov	rcx, -1
	repne scasb

; 836  :         index += i / sizeof( IMAGE_AUX_SYMBOL ) + 1;

	mov	rax, rdx
	not	rcx
	dec	rcx
	mov	ecx, ecx
	mul	rcx
	shr	rdx, 4
	lea	rax, QWORD PTR [rdx+rdx*8]
	lea	ebx, DWORD PTR [rbx+rdx+1]
	add	rax, rax
	sub	rcx, rax

; 837  :         if ( i % sizeof( IMAGE_AUX_SYMBOL ) )

	je	SHORT $LN20@SetSymbolI

; 838  :             index++;

	inc	ebx
$LN20@SetSymbolI:

; 839  :     }
; 840  : 
; 841  :     /* add entries for sections */
; 842  : 
; 843  :     cm->sectionstart = index;

	mov	DWORD PTR [r12+44], ebx

; 844  :     index += ModuleInfo->g.num_segs;

	mov	eax, DWORD PTR [rbp+8]
	add	ebx, eax

; 845  :     if ( Options.no_section_aux_entry == FALSE )

	cmp	BYTE PTR Options+124, r14b
	jne	SHORT $LN19@SetSymbolI

; 846  :         index += ModuleInfo->g.num_segs;

	add	ebx, eax
$LN19@SetSymbolI:

; 847  : 
; 848  :     /* count externals and protos */
; 849  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ; curr = curr->next ) {

	mov	rax, QWORD PTR SymTables+16
	test	rax, rax
	je	SHORT $LN16@SetSymbolI
	npad	10
$LL18@SetSymbolI:

; 850  :         if ( curr->sym.iscomm == FALSE && curr->sym.weak == TRUE )

	movzx	edx, BYTE PTR [rax+55]
	movzx	ecx, dl
	shr	cl, 2
	and	cl, 1
	jne	SHORT $LN15@SetSymbolI
	test	dl, 8
	jne	SHORT $LN17@SetSymbolI
$LN15@SetSymbolI:

; 851  :             continue;
; 852  :         curr->sym.ext_idx = index++;

	mov	DWORD PTR [rax+96], ebx
	inc	ebx

; 853  :         /* weak externals need an additional aux entry */
; 854  :         if ( curr->sym.iscomm == FALSE && curr->sym.altname )

	test	cl, cl
	jne	SHORT $LN17@SetSymbolI
	cmp	QWORD PTR [rax+72], r14
	je	SHORT $LN17@SetSymbolI

; 855  :             index++;

	inc	ebx
$LN17@SetSymbolI:

; 847  : 
; 848  :     /* count externals and protos */
; 849  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ; curr = curr->next ) {

	mov	rax, QWORD PTR [rax+112]
	test	rax, rax
	jne	SHORT $LL18@SetSymbolI
$LN16@SetSymbolI:

; 856  :     }
; 857  : 
; 858  : #if STATIC_PROCS
; 859  :     /* v2.04: count private procedures (will become static symbols) */
; 860  :     if ( Options.no_static_procs == FALSE )

	cmp	BYTE PTR Options+123, r14b
	jne	SHORT $LN10@SetSymbolI

; 861  :         for( curr = SymTables[TAB_PROC].head ; curr != NULL ; curr = curr->nextproc )

	mov	rdi, QWORD PTR SymTables+64
	test	rdi, rdi
	je	SHORT $LN10@SetSymbolI
$LL12@SetSymbolI:

; 862  :             if ( curr->sym.state == SYM_INTERNAL && curr->sym.ispublic == FALSE && curr->sym.included == FALSE ) {

	cmp	DWORD PTR [rdi+40], 1
	jne	SHORT $LN11@SetSymbolI
	test	BYTE PTR [rdi+48], 128			; 00000080H
	jne	SHORT $LN11@SetSymbolI
	movzx	eax, BYTE PTR [rdi+49]
	test	al, 64					; 00000040H
	jne	SHORT $LN11@SetSymbolI

; 863  :                 curr->sym.included = TRUE;

	or	al, 64					; 00000040H

; 864  :                 AddPublicData( &curr->sym );

	mov	rcx, rdi
	mov	BYTE PTR [rdi+49], al
	call	AddPublicData
$LN11@SetSymbolI:
	mov	rdi, QWORD PTR [rdi+120]
	test	rdi, rdi
	jne	SHORT $LL12@SetSymbolI
$LN10@SetSymbolI:

; 865  :             }
; 866  : #endif
; 867  :     /* count items in public queue */
; 868  :     for ( q = ModuleInfo->g.PubQueue.head; q; q = q->next ) {

	mov	rbp, QWORD PTR [rbp+16]
	test	rbp, rbp
	je	$LN34@SetSymbolI
	mov	QWORD PTR [rsp+56], r13
	mov	r13, QWORD PTR lastfproc$[rsp]
	mov	QWORD PTR [rsp+96], rsi
	npad	7
$LL8@SetSymbolI:

; 869  :         sym = q->sym;
; 870  :         /* if line numbers are on, co, add 6 entries for procs */
; 871  :         if ( Options.line_numbers && sym->isproc ) {

	cmp	BYTE PTR Options+1, 0
	mov	rsi, QWORD PTR [rbp+8]
	je	$LN5@SetSymbolI
	test	BYTE PTR [rsi+49], 8
	je	$LN5@SetSymbolI

; 872  :             if (  sym->debuginfo->file != lastfile ) {

	mov	rax, QWORD PTR [rsi+72]
	movzx	ecx, WORD PTR [rax+14]
	cmp	ecx, r14d
	je	SHORT $LN4@SetSymbolI

; 873  :                 if ( cm->start_files == 0 )

	cmp	DWORD PTR [r12+40], 0
	jne	SHORT $LN3@SetSymbolI

; 874  :                     cm->start_files = index;

	mov	DWORD PTR [r12+40], ebx

; 875  :                 else

	jmp	SHORT $LN2@SetSymbolI
$LN3@SetSymbolI:

; 876  :                     lastfproc->debuginfo->next_file = index;

	mov	rax, QWORD PTR [r13+72]
	mov	DWORD PTR [rax+20], ebx
$LN2@SetSymbolI:

; 877  :                 lastfproc = sym;
; 878  :                 index += 1 + GetFileAuxEntries( sym->debuginfo->file, NULL );

	mov	rax, QWORD PTR [rsi+72]
	mov	r13, rsi
	movzx	ecx, WORD PTR [rax+14]
	call	GetFName
	mov	rcx, -1
	mov	rdi, QWORD PTR [rax]
	xor	eax, eax
	repne scasb
	mov	rax, -2049638230412172401		; e38e38e38e38e38fH
	not	rcx
	dec	rcx
	mov	ecx, ecx
	mul	rcx
	shr	rdx, 4
	lea	rax, QWORD PTR [rdx+rdx*8]
	add	rax, rax
	sub	rcx, rax
	mov	eax, 0
	setne	al
	add	eax, edx
	lea	ebx, DWORD PTR [rbx+rax+1]

; 879  :                 lastfile = sym->debuginfo->file;

	mov	rax, QWORD PTR [rsi+72]
	movzx	r14d, WORD PTR [rax+14]
$LN4@SetSymbolI:

; 880  :             }
; 881  :             sym->ext_idx = index++;

	mov	DWORD PTR [rsi+96], ebx

; 882  :             index += 6;

	add	ebx, 7

; 883  :         } else

	jmp	SHORT $LN7@SetSymbolI
$LN5@SetSymbolI:

; 884  :             sym->ext_idx = index++;

	mov	DWORD PTR [rsi+96], ebx
	inc	ebx
$LN7@SetSymbolI:
	mov	rbp, QWORD PTR [rbp]
	test	rbp, rbp
	jne	$LL8@SetSymbolI
	mov	r13, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+96]
$LN34@SetSymbolI:
	mov	r14, QWORD PTR [rsp+48]
	mov	r12, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+88]

; 885  :     }
; 886  :     return( index );

	mov	eax, ebx
	mov	rbx, QWORD PTR [rsp+80]

; 887  : }

	add	rsp, 72					; 00000048H
	ret	0
SetSymbolIndices ENDP
_TEXT	ENDS
EXTRN	EmitErr:NEAR
EXTRN	__ImageBase:BYTE
xdata	SEGMENT
$unwind$coff_write_fixups DD 010701H
	DD	08207H
xdata	ENDS
pdata	SEGMENT
$pdata$coff_write_fixups DD @imagerel(coff_write_fixups#)
	DD	@imagerel(coff_write_fixups#+11)
	DD	@imagerel($unwind$coff_write_fixups#)
pdata	ENDS
xdata	SEGMENT
$chain$5$coff_write_fixups DD 0c2721H
	DD	07d427H
	DD	08c41cH
	DD	0d7415H
	DD	0c6411H
	DD	0b5408H
	DD	0a3404H
	DD	@imagerel(coff_write_fixups#)
	DD	@imagerel(coff_write_fixups#+11)
	DD	@imagerel($unwind$coff_write_fixups#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$coff_write_fixups DD @imagerel(coff_write_fixups#+11)
	DD	@imagerel(coff_write_fixups#+137)
	DD	@imagerel($chain$5$coff_write_fixups#)
pdata	ENDS
xdata	SEGMENT
$chain$6$coff_write_fixups DD 020521H
	DD	06e405H
	DD	@imagerel(coff_write_fixups#+11)
	DD	@imagerel(coff_write_fixups#+137)
	DD	@imagerel($chain$5$coff_write_fixups#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$coff_write_fixups DD @imagerel(coff_write_fixups#+137)
	DD	@imagerel(coff_write_fixups#+546)
	DD	@imagerel($chain$6$coff_write_fixups#)
pdata	ENDS
xdata	SEGMENT
$chain$7$coff_write_fixups DD 021H
	DD	@imagerel(coff_write_fixups#+11)
	DD	@imagerel(coff_write_fixups#+137)
	DD	@imagerel($chain$5$coff_write_fixups#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$coff_write_fixups DD @imagerel(coff_write_fixups#+546)
	DD	@imagerel(coff_write_fixups#+592)
	DD	@imagerel($chain$7$coff_write_fixups#)
pdata	ENDS
xdata	SEGMENT
$chain$9$coff_write_fixups DD 0e0021H
	DD	06e400H
	DD	07d400H
	DD	08c400H
	DD	0d7400H
	DD	0c6400H
	DD	0b5400H
	DD	0a3400H
	DD	@imagerel(coff_write_fixups#)
	DD	@imagerel(coff_write_fixups#+11)
	DD	@imagerel($unwind$coff_write_fixups#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$coff_write_fixups DD @imagerel(coff_write_fixups#+592)
	DD	@imagerel(coff_write_fixups#+704)
	DD	@imagerel($chain$9$coff_write_fixups#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
ir$ = 32
section$ = 80
poffset$ = 88
pindex$ = 96
coff_write_fixups PROC NEAR

; 893  : {

	mov	r11, rsp
	sub	rsp, 72					; 00000048H

; 894  :     uint_32 offset = *poffset;
; 895  :     uint_32 index = *pindex;
; 896  :     struct fixup *fix;
; 897  :     IMAGE_RELOCATION ir;
; 898  : 
; 899  :     /* v2.10: handle the reloc-overflow-case */
; 900  :     if ( section->e.seginfo->num_relocs > 0xffff ) {

	mov	rax, QWORD PTR [rcx+104]
	mov	QWORD PTR [r11+8], rbx
	mov	QWORD PTR [r11+16], rbp
	mov	eax, DWORD PTR [rax+64]
	mov	ebp, DWORD PTR [rdx]
	mov	QWORD PTR [r11+24], rsi
	mov	QWORD PTR [r11+32], rdi
	mov	edi, DWORD PTR [r8]
	mov	QWORD PTR [r11-8], r12
	xor	ebx, ebx
	cmp	eax, 65535				; 0000ffffH
	mov	QWORD PTR [r11-16], r13
	mov	r12, r8
	mov	rsi, rcx
	mov	r13, rdx
	jbe	SHORT $LN33@coff_write@3

; 901  :         DebugMsg(("coff_write_fixups(%s): enter, num_relocs=%" I32_SPEC "u\n", section->sym.name, section->e.seginfo->num_relocs ));
; 902  :         ir.VirtualAddress = section->e.seginfo->num_relocs + 1;
; 903  :         ir.SymbolTableIndex = 0;
; 904  :         ir.Type = IMAGE_REL_I386_ABSOLUTE; /* doesn't matter if 32- or 64-bit */
; 905  :         if ( fwrite( &ir, 1, sizeof(ir), CurrFile[OBJ] ) != sizeof(ir) )

	mov	r9, QWORD PTR ModuleInfo+104
	inc	eax
	lea	edx, QWORD PTR [rbx+1]
	lea	r8d, QWORD PTR [rbx+10]
	lea	rcx, QWORD PTR [r11-40]
	mov	DWORD PTR ir$[rsp], eax
	mov	DWORD PTR ir$[rsp+4], ebx
	mov	WORD PTR ir$[rsp+8], bx
	call	fwrite
	cmp	rax, 10
	je	SHORT $LN32@coff_write@3

; 906  :             WriteError();

	call	WriteError
$LN32@coff_write@3:

; 907  :         offset += sizeof( ir );

	add	ebp, 10
$LN33@coff_write@3:

; 908  :     }
; 909  :     /* reset counter */
; 910  :     section->e.seginfo->num_relocs = 0;

	mov	rax, QWORD PTR [rsi+104]
	mov	DWORD PTR [rax+64], ebx

; 911  : 
; 912  :     for ( fix = section->e.seginfo->FixupList.head; fix ; fix = fix->nextrlc ) {

	mov	rax, QWORD PTR [rsi+104]
	mov	rbx, QWORD PTR [rax+40]
	test	rbx, rbx
	je	$LN40@coff_write@3
	mov	QWORD PTR [rsp+48], r14
	lea	r14, OFFSET FLAT:__ImageBase
$LL31@coff_write@3:

; 913  : #if AMD64_SUPPORT
; 914  :         if ( section->e.seginfo->Ofssize == USE64 ) {

	mov	rax, QWORD PTR [rsi+104]
	cmp	BYTE PTR [rax+104], 2
	jne	SHORT $LN28@coff_write@3

; 915  :             switch ( fix->type ) {

	movsxd	rdx, DWORD PTR [rbx+24]
	cmp	edx, 13
	ja	SHORT $LN18@coff_write@3
	mov	ecx, DWORD PTR $LN39@coff_write@3[r14+rdx*4]
	add	rcx, r14
	jmp	rcx
$LN24@coff_write@3:

; 916  :             case FIX_VOID:
; 917  :                 continue;
; 918  :             case FIX_RELOFF32: /* 32bit offset */
; 919  :                 /* translated to IMAGE_REL_AMD64_REL32_[1|2|3|4|5] */
; 920  :                 ir.Type = IMAGE_REL_AMD64_REL32 + (fix->addbytes - 4);

	movzx	eax, BYTE PTR [rbx+32]
	mov	WORD PTR ir$[rsp+8], ax

; 921  :                 break;

	jmp	$LN15@coff_write@3
$LN23@coff_write@3:

; 922  :             case FIX_OFF32: /* 32bit offset */
; 923  :                 ir.Type = IMAGE_REL_AMD64_ADDR32;

	mov	WORD PTR ir$[rsp+8], 2

; 924  :                 break;

	jmp	$LN15@coff_write@3
$LN22@coff_write@3:

; 925  : #if IMAGERELSUPP
; 926  :             case FIX_OFF32_IMGREL:
; 927  :                 ir.Type = IMAGE_REL_AMD64_ADDR32NB;

	mov	WORD PTR ir$[rsp+8], 3

; 928  :                 break;

	jmp	$LN15@coff_write@3
$LN21@coff_write@3:

; 929  : #endif
; 930  : #if SECTIONRELSUPP
; 931  :             case FIX_OFF32_SECREL:
; 932  :                 ir.Type = IMAGE_REL_AMD64_SECREL;

	mov	WORD PTR ir$[rsp+8], 11

; 933  :                 break;

	jmp	$LN15@coff_write@3
$LN20@coff_write@3:

; 934  : #endif
; 935  :             case FIX_OFF64: /* 64bit offset */
; 936  :                 ir.Type = IMAGE_REL_AMD64_ADDR64;

	mov	WORD PTR ir$[rsp+8], 1

; 937  :                 break;

	jmp	SHORT $LN15@coff_write@3
$LN19@coff_write@3:

; 938  :             case FIX_SEG: /* segment fixup */
; 939  :                 ir.Type = IMAGE_REL_AMD64_SECTION; /* ??? */

	mov	WORD PTR ir$[rsp+8], 10

; 955  :                 //break;
; 956  :             }
; 957  :         } else

	jmp	SHORT $LN15@coff_write@3
$LN18@coff_write@3:

; 940  :                 break;
; 941  : #if 0 /* not supported by COFF64! shouldn't reach this point */
; 942  :             case FIX_RELOFF8:
; 943  :             case FIX_RELOFF16:
; 944  :             case FIX_OFF8:
; 945  :             case FIX_OFF16:
; 946  :             case FIX_HIBYTE:
; 947  :             case FIX_PTR16: /* 16bit far pointer */
; 948  :             case FIX_PTR32: /* 32bit far pointer */
; 949  : #endif
; 950  :             default:
; 951  :                 DebugMsg(("coff_write_fixups(%s, %Xh): reloc loc=%X type=%u idx=%u sym=%s\n",
; 952  :                           section->sym.name, offset, fix->locofs, fix->type, fix->sym->ext_idx, fix->sym->name));
; 953  :                 EmitErr( UNKNOWN_FIXUP_TYPE, fix->type, section->sym.name, fix->locofs );

	mov	r9d, DWORD PTR [rbx+20]
	mov	r8, QWORD PTR [rsi+8]
	mov	ecx, 196				; 000000c4H
	call	EmitErr

; 954  :                 continue; /* v2.03: skip this fixup */

	jmp	$LN30@coff_write@3
$LN28@coff_write@3:

; 958  : #endif
; 959  :             switch ( fix->type ) {

	movsxd	rdx, DWORD PTR [rbx+24]
	cmp	edx, 13
	ja	$LN6@coff_write@3
	mov	ecx, DWORD PTR $LN38@coff_write@3[r14+rdx*4]
	add	rcx, r14
	jmp	rcx
$LN13@coff_write@3:

; 960  :             case FIX_VOID:
; 961  :                 continue;
; 962  :             case FIX_RELOFF16: /* 16bit offset */
; 963  :                 ir.Type = IMAGE_REL_I386_REL16;

	mov	WORD PTR ir$[rsp+8], 2

; 964  :                 break;

	jmp	SHORT $LN15@coff_write@3
$LN12@coff_write@3:

; 965  :             case FIX_OFF16: /* 16bit offset */
; 966  :                 ir.Type = IMAGE_REL_I386_DIR16;

	mov	WORD PTR ir$[rsp+8], 1

; 967  :                 break;

	jmp	SHORT $LN15@coff_write@3
$LN11@coff_write@3:

; 968  :             case FIX_RELOFF32: /* 32bit offset */
; 969  :                 ir.Type = IMAGE_REL_I386_REL32;

	mov	WORD PTR ir$[rsp+8], 20

; 970  :                 break;

	jmp	SHORT $LN15@coff_write@3
$LN10@coff_write@3:

; 971  :             case FIX_OFF32: /* 32bit offset */
; 972  :                 ir.Type = IMAGE_REL_I386_DIR32;

	mov	WORD PTR ir$[rsp+8], 6

; 973  :                 break;

	jmp	SHORT $LN15@coff_write@3
$LN9@coff_write@3:

; 974  : #if IMAGERELSUPP
; 975  :             case FIX_OFF32_IMGREL:
; 976  :                 ir.Type = IMAGE_REL_I386_DIR32NB;

	mov	WORD PTR ir$[rsp+8], 7

; 977  :                 break;

	jmp	SHORT $LN15@coff_write@3
$LN8@coff_write@3:

; 978  : #endif
; 979  : #if SECTIONRELSUPP
; 980  :             case FIX_OFF32_SECREL:
; 981  :                 ir.Type = IMAGE_REL_I386_SECREL;

	mov	WORD PTR ir$[rsp+8], 11

; 982  :                 break;

	jmp	SHORT $LN15@coff_write@3
$LN7@coff_write@3:

; 983  : #endif
; 984  :             case FIX_SEG: /* segment fixup */
; 985  :                 ir.Type = IMAGE_REL_I386_SECTION; /* ??? */

	mov	WORD PTR ir$[rsp+8], 10
$LN15@coff_write@3:

; 998  :                 continue; /* v2.03: skip this fixup */
; 999  :                 //break;
; 1000 :             }
; 1001 :         /* if it's not EXTERNAL/PUBLIC, add symbol */
; 1002 :         /* if it's an assembly time variable, create helper symbol */
; 1003 :         if ( fix->sym->variable == TRUE ) {

	mov	rax, QWORD PTR [rbx+56]
	movzx	ecx, BYTE PTR [rax+48]
	test	cl, 64					; 00000040H
	je	SHORT $LN5@coff_write@3

; 1004 : #if HELPSYMS
; 1005 :             struct asym *sym;
; 1006 :             char buffer[12];
; 1007 :             sprintf( buffer, "$$%06X", fix->offset );
; 1008 :             sym = SymAlloc( buffer );
; 1009 :             sym->state = fix->sym->state;
; 1010 :             sym->mem_type = fix->sym->mem_type;
; 1011 :             sym->offset = fix->offset;
; 1012 :             sym->segment = fix->segment;
; 1013 :             sym->variable = TRUE; /* storage class LABEL */
; 1014 :             fix->sym = sym;
; 1015 :             AddPublicData( fix->sym );
; 1016 :             fix->sym->idx = index++;
; 1017 : #else
; 1018 :             /* just use the segment entry. This approach requires
; 1019 :              * that the offset is stored inline at the reloc location
; 1020 :              * (patch in fixup.c)
; 1021 :              */
; 1022 :             fix->sym = fix->segment_var;

	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR [rbx+56], rax

; 1023 : #endif
; 1024 :         } else if (( fix->sym->state == SYM_INTERNAL ) &&

	jmp	SHORT $LN2@coff_write@3
$LN5@coff_write@3:

; 1025 :                    fix->sym->included == FALSE &&
; 1026 :                    fix->sym->ispublic == FALSE ) {

	cmp	DWORD PTR [rax+40], 1
	jne	SHORT $LN2@coff_write@3
	test	BYTE PTR [rax+49], 64			; 00000040H
	jne	SHORT $LN2@coff_write@3
	test	cl, cl
	js	SHORT $LN2@coff_write@3

; 1027 :             fix->sym->included = TRUE;

	or	BYTE PTR [rax+49], 64			; 00000040H

; 1028 :             AddPublicData( fix->sym );

	mov	rcx, QWORD PTR [rbx+56]
	call	AddPublicData

; 1029 :             DebugMsg(("coff_write_fixups(%s, %Xh): %s added to symbol table, idx=%u\n",
; 1030 :                       section->sym.name, offset, fix->sym->name, index ));
; 1031 :             fix->sym->ext_idx = index++;

	mov	r11, QWORD PTR [rbx+56]
	mov	DWORD PTR [r11+96], edi
	inc	edi

; 1032 :             if ( Options.line_numbers && fix->sym->isproc )

	cmp	BYTE PTR Options+1, 0
	je	SHORT $LN2@coff_write@3
	mov	rax, QWORD PTR [rbx+56]
	test	BYTE PTR [rax+49], 8
	je	SHORT $LN2@coff_write@3

; 1033 :                 index += 6;

	add	edi, 6
$LN2@coff_write@3:

; 1034 :         }
; 1035 :         ir.VirtualAddress = fix->locofs;

	mov	eax, DWORD PTR [rbx+20]

; 1036 :         ir.SymbolTableIndex = fix->sym->ext_idx;
; 1037 :         if ( fwrite( &ir, 1, sizeof(ir), CurrFile[OBJ] ) != sizeof(ir) )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	edx, 1
	mov	DWORD PTR ir$[rsp], eax
	mov	rax, QWORD PTR [rbx+56]
	lea	r8d, QWORD PTR [rdx+9]
	mov	ecx, DWORD PTR [rax+96]
	mov	DWORD PTR ir$[rsp+4], ecx
	lea	rcx, QWORD PTR ir$[rsp]
	call	fwrite
	cmp	rax, 10
	je	SHORT $LN1@coff_write@3

; 1038 :             WriteError();

	call	WriteError
$LN1@coff_write@3:

; 1039 :         DebugMsg(("coff_write_fixups(%s, %Xh): reloc loc=%X type=%u idx=%u sym=%s\n",
; 1040 :                   section->sym.name, offset, ir.VirtualAddress, ir.Type, ir.SymbolTableIndex, fix->sym->name));
; 1041 :         offset += sizeof( ir );
; 1042 :         section->e.seginfo->num_relocs++;

	mov	rax, QWORD PTR [rsi+104]
	add	ebp, 10
	inc	DWORD PTR [rax+64]

; 1043 :     } /* end for */

	jmp	SHORT $LN30@coff_write@3
$LN6@coff_write@3:

; 986  :                 break;
; 987  : #if 0
; 988  :             case FIX_OFF8:
; 989  :             case FIX_RELOFF8:
; 990  :             case FIX_HIBYTE:
; 991  :             case FIX_PTR16: /* 16bit far pointer */
; 992  :             case FIX_PTR32: /* 32bit far pointer */
; 993  : #endif
; 994  :             default:
; 995  :                 DebugMsg(("coff_write_fixups(%s, %Xh): reloc loc=%X type=%u idx=%u sym=%s\n",
; 996  :                           section->sym.name, offset, fix->locofs, fix->type, fix->sym->ext_idx, fix->sym->name));
; 997  :                 EmitErr( UNKNOWN_FIXUP_TYPE, fix->type, section->sym.name, fix->locofs );

	mov	r9d, DWORD PTR [rbx+20]
	mov	r8, QWORD PTR [rsi+8]
	mov	ecx, 196				; 000000c4H
	call	EmitErr
$LN30@coff_write@3:
	mov	rbx, QWORD PTR [rbx+8]
	test	rbx, rbx
	jne	$LL31@coff_write@3
	mov	r14, QWORD PTR [rsp+48]
$LN40@coff_write@3:
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [rsp+80]

; 1044 :     DebugMsg(("coff_write_fixups(%s): exit, num_relocs=%" I32_SPEC "u\n", section->sym.name, section->e.seginfo->num_relocs ));
; 1045 :     *poffset = offset;

	mov	DWORD PTR [r13], ebp
	mov	r13, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+88]

; 1046 :     *pindex = index;

	mov	DWORD PTR [r12], edi
	mov	r12, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+104]

; 1047 : }

	add	rsp, 72					; 00000048H
	ret	0
	npad	3
$LN39@coff_write@3:
	DD	$LN30@coff_write@3
	DD	$LN18@coff_write@3
	DD	$LN18@coff_write@3
	DD	$LN24@coff_write@3
	DD	$LN18@coff_write@3
	DD	$LN18@coff_write@3
	DD	$LN23@coff_write@3
	DD	$LN20@coff_write@3
	DD	$LN19@coff_write@3
	DD	$LN18@coff_write@3
	DD	$LN18@coff_write@3
	DD	$LN18@coff_write@3
	DD	$LN22@coff_write@3
	DD	$LN21@coff_write@3
$LN38@coff_write@3:
	DD	$LN30@coff_write@3
	DD	$LN6@coff_write@3
	DD	$LN13@coff_write@3
	DD	$LN11@coff_write@3
	DD	$LN6@coff_write@3
	DD	$LN12@coff_write@3
	DD	$LN10@coff_write@3
	DD	$LN6@coff_write@3
	DD	$LN7@coff_write@3
	DD	$LN6@coff_write@3
	DD	$LN6@coff_write@3
	DD	$LN6@coff_write@3
	DD	$LN9@coff_write@3
	DD	$LN8@coff_write@3
coff_write_fixups ENDP
_TEXT	ENDS
EXTRN	fseek:NEAR
xdata	SEGMENT
$unwind$coff_write_data DD 0b6101H
	DD	0e6461H
	DD	08e418H
	DD	09d413H
	DD	0f740eH
	DD	0c3409H
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$coff_write_data DD @imagerel(coff_write_data#)
	DD	@imagerel(coff_write_data#+163)
	DD	@imagerel($unwind$coff_write_data#)
pdata	ENDS
xdata	SEGMENT
$chain$7$coff_write_data DD 060f21H
	DD	0ac40fH
	DD	0d540aH
	DD	07f405H
	DD	@imagerel(coff_write_data#)
	DD	@imagerel(coff_write_data#+163)
	DD	@imagerel($unwind$coff_write_data#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$coff_write_data DD @imagerel(coff_write_data#+163)
	DD	@imagerel(coff_write_data#+680)
	DD	@imagerel($chain$7$coff_write_data#)
pdata	ENDS
xdata	SEGMENT
$chain$8$coff_write_data DD 021H
	DD	@imagerel(coff_write_data#)
	DD	@imagerel(coff_write_data#+163)
	DD	@imagerel($unwind$coff_write_data#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$coff_write_data DD @imagerel(coff_write_data#+680)
	DD	@imagerel(coff_write_data#+716)
	DD	@imagerel($chain$8$coff_write_data#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
offset$ = 32
index$ = 36
il$6259 = 40
modinfo$ = 96
cm$ = 104
coff_write_data PROC NEAR

; 1053 : {

	sub	rsp, 88					; 00000058H
	mov	QWORD PTR [rsp+96], rbx
	mov	QWORD PTR [rsp+120], rdi
	mov	QWORD PTR [rsp+72], r13
	mov	QWORD PTR [rsp+64], r14

; 1054 :     struct dsym *section;
; 1055 :     uint_32 offset = 0; /* offset within section contents */

	xor	r14d, r14d
	mov	r13, rdx
	mov	edi, r14d
	mov	rbx, rcx

; 1056 :     int i;
; 1057 :     uint_32 index;
; 1058 : 
; 1059 :     DebugMsg(("coff_write_data(%s): enter\n", modinfo->name ));
; 1060 : 
; 1061 :     /* v2.11: removed. max_offset has been set already */
; 1062 :     //if ( directives )
; 1063 :     //    directives->sym.max_offset = size_drectve;
; 1064 : 
; 1065 :     /* calc the current index for the COFF symbol table */
; 1066 :     index = SetSymbolIndices( modinfo, cm );

	call	SetSymbolIndices

; 1067 : 
; 1068 :     /* fill the SafeSEH array */
; 1069 :     if ( modinfo->g.SafeSEHQueue.head ) {

	mov	r8, QWORD PTR [rbx+48]
	mov	DWORD PTR index$[rsp], eax
	test	r8, r8
	je	SHORT $LN25@coff_write@4

; 1070 :         struct qnode *sehp;
; 1071 :         struct qnode *sehp2;
; 1072 :         uint_32 *pdw;
; 1073 :         for( sehp = modinfo->g.SafeSEHQueue.head, pdw = (uint_32 *)cm->sxdata->e.seginfo->CodeBuffer; sehp ; sehp = sehp2 ) {

	mov	rax, QWORD PTR [r13+8]
	mov	rcx, QWORD PTR [rax+104]
	mov	r9, QWORD PTR [rcx+16]
$LL27@coff_write@4:

; 1074 :             sehp2 = sehp->next;
; 1075 :             DebugMsg(("coff_write_data: .sxdata value=%08Xh\n", ((struct asym *)sehp->elmt)->ext_idx));
; 1076 :             *pdw++ = ((struct asym *)sehp->elmt)->ext_idx;

	mov	rax, QWORD PTR [r8+8]
	mov	rdx, QWORD PTR [r8]
	add	r9, 4
	test	rdx, rdx
	mov	ecx, DWORD PTR [rax+96]
	mov	r8, rdx
	mov	DWORD PTR [r9-4], ecx
	jne	SHORT $LL27@coff_write@4
$LN25@coff_write@4:
	mov	QWORD PTR [rsp+112], rsi

; 1077 :             LclFree( sehp );
; 1078 :         }
; 1079 :     }
; 1080 : 
; 1081 : #if HELPSYMS==0
; 1082 :     for( i = 0, section = SymTables[TAB_SEG].head; section ; i++, section = section->next ) {

	mov	rsi, QWORD PTR SymTables+32
	mov	ecx, r14d
	test	rsi, rsi
	je	SHORT $LN22@coff_write@4
$LL24@coff_write@4:

; 1083 :         section->sym.ext_idx = cm->sectionstart + i;

	mov	edx, DWORD PTR [r13+44]
	add	edx, ecx
	mov	DWORD PTR [rsi+96], edx

; 1084 :         if ( Options.no_section_aux_entry == FALSE )

	cmp	BYTE PTR Options+124, dil
	jne	SHORT $LN23@coff_write@4

; 1085 :             section->sym.ext_idx += i;

	lea	eax, DWORD PTR [rdx+rcx]
	mov	DWORD PTR [rsi+96], eax
$LN23@coff_write@4:
	mov	rsi, QWORD PTR [rsi+112]
	inc	ecx
	test	rsi, rsi
	jne	SHORT $LL24@coff_write@4

; 1077 :             LclFree( sehp );
; 1078 :         }
; 1079 :     }
; 1080 : 
; 1081 : #if HELPSYMS==0
; 1082 :     for( i = 0, section = SymTables[TAB_SEG].head; section ; i++, section = section->next ) {

	mov	rsi, QWORD PTR SymTables+32
$LN22@coff_write@4:

; 1086 :     }
; 1087 : #endif
; 1088 : 
; 1089 :     /* now scan the section's relocations. If a relocation refers to
; 1090 :      a symbol which is not public/external, it must be added to the
; 1091 :      symbol table. If the symbol is an assembly time variable, a helper
; 1092 :      symbol - name is $$<offset:6> is to be added.
; 1093 :      */
; 1094 : 
; 1095 :     for( section = SymTables[TAB_SEG].head; section ; section = section->next ) {

	test	rsi, rsi
	je	$LN39@coff_write@4
	mov	QWORD PTR [rsp+56], r15
	mov	QWORD PTR [rsp+104], rbp
	mov	QWORD PTR [rsp+80], r12
	mov	r15d, 32767				; 00007fffH
	npad	8
$LL20@coff_write@4:

; 1096 :         uint_32 size;
; 1097 :         size = section->sym.max_offset;
; 1098 : #ifdef DEBUG_OUT
; 1099 :         if ( section->e.seginfo->CodeBuffer )
; 1100 :             DebugMsg(("coff_write_data(%s, %Xh): size=%X, written=%X, content=[%02X %02X ...]\n",
; 1101 :                       section->sym.name, offset, size - section->e.seginfo->start_loc, section->e.seginfo->bytes_written, *(section->e.seginfo->CodeBuffer), *(section->e.seginfo->CodeBuffer+1)));
; 1102 :         else
; 1103 :             DebugMsg(("coff_write_data(%s, %Xh): size=%X, buffer=NULL\n",
; 1104 :                       section->sym.name, offset, size - section->e.seginfo->start_loc ));
; 1105 : #endif
; 1106 : 
; 1107 :         /* don't write section data for bss and uninitialized stack segments */
; 1108 :         if ( section->e.seginfo->combine == COMB_STACK && section->e.seginfo->bytes_written == 0 )

	mov	rcx, QWORD PTR [rsi+104]
	mov	ebx, DWORD PTR [rsi+64]
	movzx	eax, BYTE PTR [rcx+108]
	and	al, 7
	cmp	al, 5
	jne	SHORT $LN17@coff_write@4
	cmp	DWORD PTR [rcx+24], r14d
	je	$LN19@coff_write@4
$LN17@coff_write@4:

; 1109 :             continue;
; 1110 :         if ( section->e.seginfo->segtype == SEGTYPE_BSS )

	cmp	DWORD PTR [rcx+72], 3
	je	$LN19@coff_write@4

; 1111 :             continue;
; 1112 : 
; 1113 :         if ( size ) {

	test	ebx, ebx
	je	$LN15@coff_write@4

; 1114 :             offset += size;

	add	edi, ebx

; 1115 :             if ((offset & 1) && section->e.seginfo->FixupList.head ) {

	test	dil, 1
	mov	DWORD PTR offset$[rsp], edi
	je	SHORT $LN14@coff_write@4
	cmp	QWORD PTR [rcx+40], r14
	je	SHORT $LN14@coff_write@4

; 1116 :                 offset++;

	inc	edi

; 1117 :                 size++;

	inc	ebx
	mov	DWORD PTR offset$[rsp], edi
$LN14@coff_write@4:

; 1118 :             }
; 1119 :             if ( section->e.seginfo->CodeBuffer == NULL ) {

	cmp	QWORD PTR [rcx+16], r14
	jne	SHORT $LN13@coff_write@4

; 1120 :                 fseek( CurrFile[OBJ], size, SEEK_CUR );

	mov	rcx, QWORD PTR ModuleInfo+104
	mov	r8d, 1
	mov	edx, ebx
	call	fseek

; 1121 :             } else {

	jmp	SHORT $LN10@coff_write@4
$LN13@coff_write@4:

; 1122 :                 /* if there was an ORG, the buffer content will
; 1123 :                  * start with the ORG address. The bytes from
; 1124 :                  * 0 - ORG must be written by moving the file pointer!
; 1125 :                  */
; 1126 :                 if ( section->e.seginfo->start_loc ) {

	mov	edx, DWORD PTR [rcx+8]
	test	edx, edx
	je	SHORT $LN11@coff_write@4

; 1127 :                     fseek( CurrFile[OBJ], section->e.seginfo->start_loc, SEEK_CUR );

	mov	rcx, QWORD PTR ModuleInfo+104
	mov	r8d, 1
	call	fseek

; 1128 :                     size -= section->e.seginfo->start_loc;

	mov	rcx, QWORD PTR [rsi+104]
	sub	ebx, DWORD PTR [rcx+8]
$LN11@coff_write@4:

; 1129 :                 }
; 1130 : 
; 1131 :                 if ( fwrite( section->e.seginfo->CodeBuffer, 1, size, CurrFile[OBJ] ) != size )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	rcx, QWORD PTR [rcx+16]
	mov	r8, rbx
	mov	edx, 1
	call	fwrite
	cmp	rax, rbx
	je	SHORT $LN10@coff_write@4

; 1132 :                     WriteError();

	call	WriteError
$LN10@coff_write@4:

; 1133 :             }
; 1134 : 
; 1135 :             coff_write_fixups( section, &offset, &index );

	lea	r8, QWORD PTR index$[rsp]
	lea	rdx, QWORD PTR offset$[rsp]
	mov	rcx, rsi
	call	coff_write_fixups
	mov	edi, DWORD PTR offset$[rsp]
$LN15@coff_write@4:

; 1136 :         } /* end if (size) */
; 1137 : 
; 1138 :         /* v2.07: the following block has beem moved outside of "if(size)" block,
; 1139 :          * because it may happen that a segment has size 0 and still debug info.
; 1140 :          * In any case it's important to initialize section->e.seginfo->num_linnums
; 1141 :          */
; 1142 :         /* write line number data. The peculiarity of COFF (compared to OMF) is
; 1143 :          * that line numbers are always relative to a function start.
; 1144 :          *
; 1145 :          * an item with line number 0 has a special meaning - it contains a reference
; 1146 :          * ( a symbol table index ) to the function whose line numbers are to follow.
; 1147 :          * this item is to be followed by an item with line number 32767, which then
; 1148 :          * tells the function's start offset ( undocumented! ).
; 1149 :          *
; 1150 :          */
; 1151 :         if( Options.line_numbers && section->e.seginfo->LinnumQueue ) {

	cmp	BYTE PTR Options+1, r14b
	je	$LN19@coff_write@4
	mov	rax, QWORD PTR [rsi+104]
	cmp	QWORD PTR [rax+56], r14
	je	$LN19@coff_write@4

; 1152 :             IMAGE_LINENUMBER il;
; 1153 :             struct line_num_info *lni;
; 1154 :             struct asym *last;
; 1155 :             uint_32 line_numbers = 0;
; 1156 :             last = NULL;
; 1157 :             lni = (struct line_num_info *)((struct qdesc *)section->e.seginfo->LinnumQueue)->head;

	mov	rax, QWORD PTR [rax+56]
	mov	r12d, r14d
	mov	rbp, r14
	mov	rbx, QWORD PTR [rax]

; 1158 :             DebugMsg(("coff_write_data(%s): writing linnum data\n", section->sym.name ));
; 1159 :             for( ; lni; lni = lni->next ) {

	test	rbx, rbx
	je	$LN6@coff_write@4
	npad	4
$LL8@coff_write@4:

; 1160 :                 DebugMsg(("coff_write_data(%s, %Xh): linnum, #=%u, %s=%X, sym=%s\n",
; 1161 :                           section->sym.name, offset, lni->number, lni->number ? "ofs" : "idx", lni->offset, lni->number ? "NULL" : lni->sym->name ));
; 1162 :                 if ( lni->number == 0 ) {

	cmp	DWORD PTR [rbx+8], r14d
	jne	SHORT $LN5@coff_write@4

; 1163 :                     last = lni->sym;
; 1164 :                     if ( cm->lastproc )

	mov	rcx, QWORD PTR [r13+16]
	mov	rbp, QWORD PTR [rbx+16]
	test	rcx, rcx
	je	SHORT $LN4@coff_write@4

; 1165 :                         cm->lastproc->debuginfo->next_proc = lni->sym->ext_idx;

	mov	rcx, QWORD PTR [rcx+72]
	mov	eax, DWORD PTR [rbp+96]
	mov	DWORD PTR [rcx+16], eax
$LN4@coff_write@4:

; 1166 :                     cm->lastproc = lni->sym;

	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [r13+16], rax

; 1167 :                     lni->sym->debuginfo->next_proc = 0;

	mov	rax, QWORD PTR [rbx+16]
	mov	rcx, QWORD PTR [rax+72]
	mov	DWORD PTR [rcx+16], r14d

; 1168 :                     il.Linenumber = 0;

	mov	WORD PTR il$6259[rsp+4], r14w

; 1169 : #ifdef DEBUG_OUT
; 1170 :                     /* if symbol table index is 0, then the proc wasn't added
; 1171 :                      * to the "publics" queue in AddLinnumDataRef().
; 1172 :                      */
; 1173 :                     if ( lni->sym->ext_idx == 0 ) {
; 1174 :                         DebugMsg(("coff_write_data(%s, %Xh): error, %s has symbol table index 0\n",
; 1175 :                                   section->sym.name, offset, lni->sym->name ));
; 1176 :                     }
; 1177 : #endif
; 1178 :                     il.Type.SymbolTableIndex = lni->sym->ext_idx;

	mov	rax, QWORD PTR [rbx+16]
	mov	ecx, DWORD PTR [rax+96]
	mov	DWORD PTR il$6259[rsp], ecx

; 1179 :                     lni->sym->debuginfo->start_line = lni->line_number;

	mov	rax, QWORD PTR [rbx+16]
	mov	edx, DWORD PTR [rbx+12]
	mov	rcx, QWORD PTR [rax+72]
	and	edx, 1048575				; 000fffffH
	mov	DWORD PTR [rcx], edx

; 1180 :                     //((struct dsym *)lni->sym)->e.procinfo->file = lni->file;
; 1181 :                     lni->sym->debuginfo->ln_fileofs = cm->start_data + offset;

	mov	eax, DWORD PTR [r13+32]
	lea	edx, DWORD PTR [rdi+rax]
	mov	rax, QWORD PTR [rbx+16]
	mov	rcx, QWORD PTR [rax+72]
	mov	DWORD PTR [rcx+8], edx

; 1182 :                     DebugMsg(("coff_write_data(%s, %Xh): proc %s start_line=%u\n",
; 1183 :                               section->sym.name, offset, lni->sym->name, lni->sym->debuginfo->start_line ));
; 1184 :                 } else {

	jmp	SHORT $LN3@coff_write@4
$LN5@coff_write@4:

; 1185 :                     /**/myassert( last != NULL );
; 1186 :                     il.Linenumber = lni->number - last->debuginfo->start_line;

	mov	rax, QWORD PTR [rbp+72]
	movzx	ecx, WORD PTR [rbx+8]
	sub	cx, WORD PTR [rax]

; 1187 :                     /* if current line number - start line number is 0,
; 1188 :                      * generate a "32767" line number item.
; 1189 :                      */
; 1190 :                     if ( il.Linenumber == 0 )

	cmove	cx, r15w
	mov	WORD PTR il$6259[rsp+4], cx

; 1191 :                         il.Linenumber = 0x7FFF;
; 1192 :                     il.Type.VirtualAddress = lni->offset;

	mov	eax, DWORD PTR [rbx+12]
	mov	DWORD PTR il$6259[rsp], eax
$LN3@coff_write@4:

; 1193 :                 }
; 1194 :                 /* v2.11: last is always != NULL */
; 1195 :                 //if ( last ) {
; 1196 :                     last->debuginfo->line_numbers++;

	mov	rax, QWORD PTR [rbp+72]

; 1197 :                     last->debuginfo->end_line = lni->number;
; 1198 :                 //}
; 1199 :                 if ( fwrite( &il, 1, sizeof(il), CurrFile[OBJ] ) != sizeof(il) )

	mov	edx, 1
	inc	WORD PTR [rax+12]
	mov	rcx, QWORD PTR [rbp+72]
	mov	eax, DWORD PTR [rbx+8]
	mov	DWORD PTR [rcx+4], eax
	mov	r9, QWORD PTR ModuleInfo+104
	lea	r8d, QWORD PTR [rdx+5]
	lea	rcx, QWORD PTR il$6259[rsp]
	call	fwrite
	cmp	rax, 6
	je	SHORT $LN1@coff_write@4

; 1200 :                     WriteError();

	call	WriteError
$LN1@coff_write@4:

; 1158 :             DebugMsg(("coff_write_data(%s): writing linnum data\n", section->sym.name ));
; 1159 :             for( ; lni; lni = lni->next ) {

	mov	rbx, QWORD PTR [rbx]

; 1201 :                 offset += sizeof(il);

	add	edi, 6

; 1202 :                 line_numbers++;

	inc	r12d
	test	rbx, rbx
	jne	$LL8@coff_write@4
$LN6@coff_write@4:

; 1203 :             } /* end for */
; 1204 :             section->e.seginfo->num_linnums = line_numbers;

	mov	rax, QWORD PTR [rsi+104]
	mov	DWORD PTR [rax+56], r12d
$LN19@coff_write@4:
	mov	rsi, QWORD PTR [rsi+112]
	test	rsi, rsi
	jne	$LL20@coff_write@4
	mov	r15, QWORD PTR [rsp+56]
	mov	r12, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+104]

; 1205 :         } /* end if (Options.line_numbers...) */
; 1206 :     } /* end for */
; 1207 : 
; 1208 :     cm->size_data = offset;

	mov	DWORD PTR [r13+36], edi

; 1209 : 
; 1210 :     DebugMsg(("coff_write_data: exit, size of sections=%Xh\n", cm->size_data ));
; 1211 : 
; 1212 :     return( NOT_ERROR );

	jmp	SHORT $LN40@coff_write@4
$LN39@coff_write@4:

; 1205 :         } /* end if (Options.line_numbers...) */
; 1206 :     } /* end for */
; 1207 : 
; 1208 :     cm->size_data = offset;

	mov	DWORD PTR [r13+36], r14d
$LN40@coff_write@4:
	mov	r14, QWORD PTR [rsp+64]
	mov	r13, QWORD PTR [rsp+72]
	mov	rdi, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [rsp+96]

; 1209 : 
; 1210 :     DebugMsg(("coff_write_data: exit, size of sections=%Xh\n", cm->size_data ));
; 1211 : 
; 1212 :     return( NOT_ERROR );

	xor	eax, eax

; 1213 : }

	add	rsp, 88					; 00000058H
	ret	0
coff_write_data ENDP
_TEXT	ENDS
EXTRN	strchr:NEAR
EXTRN	CreateIntSegment:NEAR
xdata	SEGMENT
$unwind$coff_create_drectve DD 0c2a01H
	DD	047f42aH
	DD	048e423H
	DD	04ac416H
	DD	04e6412H
	DD	04d540eH
	DD	04b010aH
xdata	ENDS
pdata	SEGMENT
$pdata$coff_create_drectve DD @imagerel(coff_create_drectve#)
	DD	@imagerel(coff_create_drectve#+240)
	DD	@imagerel($unwind$coff_create_drectve#)
pdata	ENDS
xdata	SEGMENT
$chain$5$coff_create_drectve DD 020821H
	DD	04f7408H
	DD	@imagerel(coff_create_drectve#)
	DD	@imagerel(coff_create_drectve#+240)
	DD	@imagerel($unwind$coff_create_drectve#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$coff_create_drectve DD @imagerel(coff_create_drectve#+240)
	DD	@imagerel(coff_create_drectve#+248)
	DD	@imagerel($chain$5$coff_create_drectve#)
pdata	ENDS
xdata	SEGMENT
$chain$7$coff_create_drectve DD 045a21H
	DD	04c345aH
	DD	049d408H
	DD	@imagerel(coff_create_drectve#+240)
	DD	@imagerel(coff_create_drectve#+248)
	DD	@imagerel($chain$5$coff_create_drectve#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$coff_create_drectve DD @imagerel(coff_create_drectve#+248)
	DD	@imagerel(coff_create_drectve#+832)
	DD	@imagerel($chain$7$coff_create_drectve#)
pdata	ENDS
xdata	SEGMENT
$chain$8$coff_create_drectve DD 020021H
	DD	04c3400H
	DD	@imagerel(coff_create_drectve#+240)
	DD	@imagerel(coff_create_drectve#+248)
	DD	@imagerel($chain$5$coff_create_drectve#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$coff_create_drectve DD @imagerel(coff_create_drectve#+832)
	DD	@imagerel(coff_create_drectve#+1484)
	DD	@imagerel($chain$8$coff_create_drectve#)
pdata	ENDS
xdata	SEGMENT
$chain$9$coff_create_drectve DD 021H
	DD	@imagerel(coff_create_drectve#)
	DD	@imagerel(coff_create_drectve#+240)
	DD	@imagerel($unwind$coff_create_drectve#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$coff_create_drectve DD @imagerel(coff_create_drectve#+1484)
	DD	@imagerel(coff_create_drectve#+1532)
	DD	@imagerel($chain$9$coff_create_drectve#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buffer$ = 48
temp$6959 = 304
temp$6938 = 304
modinfo$ = 608
cm$ = 616
coff_create_drectve PROC NEAR

; 1221 : {

	mov	rax, rsp
	sub	rsp, 600				; 00000258H
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax-8], r12

; 1222 :     struct dsym *exp;
; 1223 : #if DLLIMPORT
; 1224 :     struct dsym *imp = NULL;
; 1225 : #endif
; 1226 :     char buffer[MAX_ID_LEN + MANGLE_BYTES + 1];
; 1227 : 
; 1228 :     /* does a proc exist with the EXPORT attribute? */
; 1229 :     for( exp = SymTables[TAB_PROC].head; exp != NULL; exp = exp->nextproc ) {

	mov	r12, QWORD PTR SymTables+64
	xor	ebp, ebp
	mov	QWORD PTR [rax-24], r14
	test	r12, r12
	mov	QWORD PTR [rax-32], r15
	mov	r14, rcx
	mov	r15, rdx
	mov	rsi, rbp
	je	SHORT $LN104@coff_creat
	npad	11
$LL45@coff_creat:

; 1230 :         if( exp->e.procinfo->isexport )

	mov	rax, QWORD PTR [r12+104]
	test	BYTE PTR [rax+128], 4
	jne	SHORT $LN104@coff_creat
	mov	r12, QWORD PTR [r12+120]
	test	r12, r12
	jne	SHORT $LL45@coff_creat
$LN104@coff_creat:

; 1231 :             break;
; 1232 :     }
; 1233 : #if DLLIMPORT
; 1234 :     /* check if an impdef record is there */
; 1235 :     if ( Options.write_impdef && !Options.names[OPTN_LNKDEF_FN] )

	cmp	BYTE PTR Options+131, sil
	je	SHORT $LN105@coff_creat
	cmp	QWORD PTR Options+56, rsi
	jne	SHORT $LN105@coff_creat

; 1236 :         for ( imp = SymTables[TAB_EXT].head; imp; imp = imp->next )

	mov	rsi, QWORD PTR SymTables+16
	test	rsi, rsi
	je	SHORT $LN105@coff_creat
$LL40@coff_creat:

; 1237 :             if ( imp->sym.isproc && ( imp->sym.weak == FALSE || imp->sym.iat_used == TRUE ) )

	test	BYTE PTR [rsi+49], 8
	je	SHORT $LN39@coff_creat
	test	BYTE PTR [rsi+55], 8
	je	SHORT $LN36@coff_creat
	test	BYTE PTR [rsi+48], 8
	je	SHORT $LN39@coff_creat
$LN36@coff_creat:

; 1238 :                 if ( imp->sym.dll && *imp->sym.dll->name )

	mov	rax, QWORD PTR [rsi+64]
	test	rax, rax
	je	SHORT $LN39@coff_creat
	cmp	BYTE PTR [rax+12], bpl
	jne	SHORT $LN105@coff_creat
$LN39@coff_creat:

; 1236 :         for ( imp = SymTables[TAB_EXT].head; imp; imp = imp->next )

	mov	rsi, QWORD PTR [rsi+112]
	test	rsi, rsi
	jne	SHORT $LL40@coff_creat
$LN105@coff_creat:

; 1239 :                     break;
; 1240 : #endif
; 1241 :     /* add a .drectve section if
; 1242 :      - a start_label is defined    and/or
; 1243 :      - a library is included       and/or
; 1244 :      - a proc is exported          and/or
; 1245 :      - impdefs are to be written (-Zd)
; 1246 :      */
; 1247 :     if ( modinfo->g.start_label != NULL ||
; 1248 :         modinfo->g.LibQueue.head != NULL ||
; 1249 : #if DLLIMPORT
; 1250 :         imp != NULL ||
; 1251 : #endif
; 1252 :         exp != NULL ) {

	cmp	QWORD PTR [rcx+208], rbp
	jne	SHORT $LN33@coff_creat
	cmp	QWORD PTR [rcx+64], rbp
	jne	SHORT $LN33@coff_creat
	test	rsi, rsi
	jne	SHORT $LN33@coff_creat
	test	r12, r12
	je	$LN3@coff_creat
$LN33@coff_creat:

; 1253 :         if ( cm->directives = (struct dsym *)CreateIntSegment( szdrectve, "", MAX_SEGALIGNMENT, modinfo->Ofssize, FALSE ) ) {

	movzx	r9d, BYTE PTR [rcx+404]
	lea	rdx, OFFSET FLAT:$SG6305
	lea	rcx, OFFSET FLAT:szdrectve
	mov	r8b, 255				; 000000ffH
	mov	BYTE PTR [rsp+32], bpl
	call	CreateIntSegment
	test	rax, rax
	mov	QWORD PTR [r15], rax
	je	$LN3@coff_creat

; 1254 :             struct dsym *tmp;
; 1255 :             int size = 0;
; 1256 :             struct qitem *q;
; 1257 :             uint_8 *p;
; 1258 :             cm->directives->e.seginfo->info = TRUE;

	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR [rsp+632], rdi
	mov	QWORD PTR [rsp+584], r13
	or	BYTE PTR [rax+107], 2

; 1259 :             DebugMsg(("coff_create_drectve: %s section added\n", szdrectve));
; 1260 : 
; 1261 :             /* calc the size for this segment */
; 1262 :             /* 1. exports */
; 1263 :             for( tmp = exp; tmp ; tmp = tmp->nextproc ) {

	test	r12, r12
	mov	r13d, ebp
	mov	rdi, r12
	je	SHORT $LN29@coff_creat
	npad	1
$LL31@coff_creat:

; 1264 :                 if( tmp->e.procinfo->isexport ) {

	mov	rax, QWORD PTR [rdi+104]
	test	BYTE PTR [rax+128], 4
	je	SHORT $LN30@coff_creat

; 1265 :                     size += Mangle( &tmp->sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rdi
	call	Mangle

; 1266 :                     size += sizeof("-export:");
; 1267 :                     if ( Options.no_export_decoration == TRUE )

	cmp	BYTE PTR Options+127, 1
	lea	r13d, DWORD PTR [r13+rax+9]
	jne	SHORT $LN30@coff_creat

; 1268 :                         size += tmp->sym.name_size + 1;

	movzx	eax, BYTE PTR [rdi+80]
	lea	r13d, DWORD PTR [r13+rax+1]
$LN30@coff_creat:
	mov	rdi, QWORD PTR [rdi+120]
	test	rdi, rdi
	jne	SHORT $LL31@coff_creat
$LN29@coff_creat:
	mov	QWORD PTR [rsp+608], rbx

; 1269 :                 }
; 1270 :             }
; 1271 :             /* 2. defaultlibs */
; 1272 :             for( q = modinfo->g.LibQueue.head; q ; q = q->next ) {

	mov	rbx, QWORD PTR [r14+64]
	test	rbx, rbx
	je	SHORT $LN24@coff_creat
	npad	5
$LL26@coff_creat:

; 1273 :                 size += strlen( q->value ) + sizeof("-defaultlib:");

	xor	eax, eax
	lea	rdi, QWORD PTR [rbx+8]
	mov	rcx, -1
	repne scasb

; 1274 :                 /* if the name isn't enclosed in double quotes and contains
; 1275 :                  a space, add 2 bytes to enclose it */
; 1276 :                 if ( *q->value != '"' && strchr( q->value, ' ') )

	cmp	BYTE PTR [rbx+8], 34			; 00000022H
	not	rcx
	lea	r13d, DWORD PTR [r13+rcx+12]
	je	SHORT $LN25@coff_creat
	lea	edx, QWORD PTR [rax+32]
	lea	rcx, QWORD PTR [rbx+8]
	call	strchr
	test	rax, rax
	je	SHORT $LN25@coff_creat

; 1277 :                     size += 2;

	add	r13d, 2
$LN25@coff_creat:

; 1269 :                 }
; 1270 :             }
; 1271 :             /* 2. defaultlibs */
; 1272 :             for( q = modinfo->g.LibQueue.head; q ; q = q->next ) {

	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL26@coff_creat
$LN24@coff_creat:

; 1278 :             }
; 1279 :             /* 3. start label */
; 1280 :             size += GetStartLabel( buffer, TRUE );

	mov	rax, QWORD PTR ModuleInfo+208
	mov	ecx, ebp
	test	rax, rax
	je	$LN56@coff_creat
	lea	rdx, QWORD PTR temp$6938[rsp]
	mov	rcx, rax
	call	Mangle
	cmp	BYTE PTR Options+128, bpl
	je	SHORT $LN55@coff_creat
	mov	rcx, rbp
	npad	8
$LL59@coff_creat:
	movzx	eax, BYTE PTR temp$6938[rsp+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR buffer$[rsp+rcx-1], al
	jne	SHORT $LL59@coff_creat
	jmp	$LN49@coff_creat
$LN55@coff_creat:
	mov	rcx, QWORD PTR ModuleInfo+208
	mov	eax, DWORD PTR [rcx+84]
	cmp	eax, 1
	je	SHORT $LN53@coff_creat
	cmp	eax, 3
	je	SHORT $LN53@coff_creat
	cmp	eax, 2
	je	SHORT $LN53@coff_creat
	mov	r8, QWORD PTR [rcx+8]
	cmp	BYTE PTR [r8], 95			; 0000005fH
	je	SHORT $LN52@coff_creat
	cmp	DWORD PTR ModuleInfo+376, 2
	je	SHORT $LN51@coff_creat
	mov	edx, 194				; 000000c2H
	mov	ecx, 2
	call	EmitWarn
$LN51@coff_creat:
	mov	rcx, rbp
	npad	10
$LL60@coff_creat:
	movzx	eax, BYTE PTR temp$6938[rsp+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR buffer$[rsp+rcx-1], al
	jne	SHORT $LL60@coff_creat
	jmp	SHORT $LN49@coff_creat
$LN52@coff_creat:
	mov	rcx, rbp
	npad	8
$LL61@coff_creat:
	movzx	eax, BYTE PTR temp$6938[rsp+rcx+1]
	inc	rcx
	test	al, al
	mov	BYTE PTR buffer$[rsp+rcx-1], al
	jne	SHORT $LL61@coff_creat
	jmp	SHORT $LN49@coff_creat
$LN53@coff_creat:
	mov	rcx, rbp
	npad	8
$LL62@coff_creat:
	movzx	eax, BYTE PTR temp$6938[rsp+rcx+1]
	inc	rcx
	test	al, al
	mov	BYTE PTR buffer$[rsp+rcx-1], al
	jne	SHORT $LL62@coff_creat
$LN49@coff_creat:
	xor	eax, eax
	lea	rdi, QWORD PTR buffer$[rsp]
	mov	rcx, -1
	repne scasb
	not	rcx
	add	ecx, 7
$LN56@coff_creat:
	add	r13d, ecx

; 1281 : #if DLLIMPORT
; 1282 :             /* 4. impdefs */
; 1283 :             for( tmp = imp; tmp ; tmp = tmp->next ) {

	test	rsi, rsi
	mov	rbx, rsi
	je	SHORT $LN20@coff_creat
$LL22@coff_creat:

; 1284 :                 if ( tmp->sym.isproc && ( tmp->sym.weak == FALSE || tmp->sym.iat_used == TRUE ) &&
; 1285 :                     tmp->sym.dll && *tmp->sym.dll->name ) {

	test	BYTE PTR [rbx+49], 8
	je	SHORT $LN21@coff_creat
	test	BYTE PTR [rbx+55], 8
	je	SHORT $LN18@coff_creat
	test	BYTE PTR [rbx+48], 8
	je	SHORT $LN21@coff_creat
$LN18@coff_creat:
	mov	rax, QWORD PTR [rbx+64]
	test	rax, rax
	je	SHORT $LN21@coff_creat
	cmp	BYTE PTR [rax+12], bpl
	je	SHORT $LN21@coff_creat

; 1286 :                     /* format is:
; 1287 :                      * "-import:<mangled_name>=<module_name>.<unmangled_name>" or
; 1288 :                      * "-import:<mangled_name>=<module_name>"
; 1289 :                      */
; 1290 :                     size += sizeof("-import:");
; 1291 :                     size += Mangle( &tmp->sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rbx
	call	Mangle

; 1292 :                     size += 1 + strlen( tmp->sym.dll->name );

	mov	rdi, QWORD PTR [rbx+64]
	mov	rcx, -1
	lea	edx, DWORD PTR [r13+rax+9]
	xor	eax, eax
	add	rdi, 12
	repne scasb

; 1293 :                     size += 1 + tmp->sym.name_size;

	movzx	eax, BYTE PTR [rbx+80]
	not	rcx
	add	eax, edx
	lea	r13d, DWORD PTR [rax+rcx+1]
$LN21@coff_creat:
	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL22@coff_creat
$LN20@coff_creat:

; 1294 :                 }
; 1295 :             }
; 1296 : #endif
; 1297 :             cm->directives->sym.max_offset = size;

	mov	rax, QWORD PTR [r15]
	mov	DWORD PTR [rax+64], r13d

; 1298 :             /* v2.09: allocate 1 byte more, because sprintf() is used, which
; 1299 :              * adds a NULLC.
; 1300 :              */
; 1301 :             //directives->e.seginfo->CodeBuffer = LclAlloc( size );
; 1302 :             cm->directives->e.seginfo->CodeBuffer = LclAlloc( size + 1 );

	lea	eax, DWORD PTR [r13+1]
	movsxd	rcx, eax
	call	LclAlloc

; 1303 :             p = cm->directives->e.seginfo->CodeBuffer;
; 1304 : 
; 1305 :             /* copy the data */
; 1306 : 
; 1307 :             /* 1. exports */
; 1308 :             for( tmp = exp; tmp ; tmp = tmp->nextproc ) {

	test	r12, r12
	mov	rcx, QWORD PTR [r15]
	mov	rdx, QWORD PTR [rcx+104]
	mov	r13, QWORD PTR [rsp+584]
	mov	QWORD PTR [rdx+16], rax
	mov	rax, QWORD PTR [r15]
	mov	rcx, QWORD PTR [rax+104]
	mov	rbx, QWORD PTR [rcx+16]
	je	SHORT $LN15@coff_creat
	npad	9
$LL17@coff_creat:

; 1309 :                 if( tmp->e.procinfo->isexport ) {

	mov	rax, QWORD PTR [r12+104]
	test	BYTE PTR [rax+128], 4
	je	SHORT $LN16@coff_creat

; 1310 :                     Mangle( &tmp->sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, r12
	call	Mangle

; 1311 :                     if ( Options.no_export_decoration == FALSE )

	cmp	BYTE PTR Options+127, bpl
	jne	SHORT $LN13@coff_creat

; 1312 :                         p += sprintf( (char *)p, "-export:%s ", buffer );

	lea	r8, QWORD PTR buffer$[rsp]
	lea	rdx, OFFSET FLAT:$SG6330
	mov	rcx, rbx
	call	sprintf
	movsxd	rcx, eax
	add	rbx, rcx

; 1313 :                     else

	jmp	SHORT $LN16@coff_creat
$LN13@coff_creat:

; 1314 :                         p += sprintf( (char *)p, "-export:%s=%s ", tmp->sym.name, buffer );

	mov	r8, QWORD PTR [r12+8]
	lea	r9, QWORD PTR buffer$[rsp]
	lea	rdx, OFFSET FLAT:$SG6333
	mov	rcx, rbx
	call	sprintf
	movsxd	rcx, eax
	add	rbx, rcx
$LN16@coff_creat:
	mov	r12, QWORD PTR [r12+120]
	test	r12, r12
	jne	SHORT $LL17@coff_creat
$LN15@coff_creat:

; 1315 :                 }
; 1316 :             }
; 1317 :             /* 2. libraries */
; 1318 :             for( q = modinfo->g.LibQueue.head; q ; q = q->next ) {

	mov	rdi, QWORD PTR [r14+64]
	test	rdi, rdi
	je	SHORT $LN9@coff_creat
$LL11@coff_creat:

; 1319 :                 if ( *q->value != '"' && strchr( q->value, ' ' ) )

	cmp	BYTE PTR [rdi+8], 34			; 00000022H
	je	SHORT $LN8@coff_creat
	lea	rcx, QWORD PTR [rdi+8]
	mov	edx, 32					; 00000020H
	call	strchr
	test	rax, rax
	je	SHORT $LN8@coff_creat

; 1320 :                     p += sprintf( (char *)p,"-defaultlib:\"%s\" ", (char *)q->value );

	lea	r8, QWORD PTR [rdi+8]
	lea	rdx, OFFSET FLAT:$SG6340
	mov	rcx, rbx
	call	sprintf
	movsxd	rcx, eax
	add	rbx, rcx

; 1321 :                 else

	jmp	SHORT $LN10@coff_creat
$LN8@coff_creat:

; 1322 :                     p += sprintf( (char *)p,"-defaultlib:%s ", (char *)q->value );

	lea	r8, QWORD PTR [rdi+8]
	lea	rdx, OFFSET FLAT:$SG6344
	mov	rcx, rbx
	call	sprintf
	movsxd	rcx, eax
	add	rbx, rcx
$LN10@coff_creat:
	mov	rdi, QWORD PTR [rdi]
	test	rdi, rdi
	jne	SHORT $LL11@coff_creat
$LN9@coff_creat:

; 1323 :             }
; 1324 :             /* 3. entry */
; 1325 :             if ( modinfo->g.start_label ) {

	cmp	QWORD PTR [r14+208], rbp
	je	$LN6@coff_creat

; 1326 :                 GetStartLabel( buffer, FALSE );

	mov	rcx, QWORD PTR ModuleInfo+208
	test	rcx, rcx
	je	$LN63@coff_creat
	lea	rdx, QWORD PTR temp$6959[rsp]
	call	Mangle
	cmp	BYTE PTR Options+128, bpl
	je	SHORT $LN69@coff_creat
	npad	6
$LL73@coff_creat:
	movzx	eax, BYTE PTR temp$6959[rsp+rbp]
	inc	rbp
	test	al, al
	mov	BYTE PTR buffer$[rsp+rbp-1], al
	jne	SHORT $LL73@coff_creat
	jmp	SHORT $LN63@coff_creat
$LN69@coff_creat:
	mov	rcx, QWORD PTR ModuleInfo+208
	mov	eax, DWORD PTR [rcx+84]
	cmp	eax, 1
	je	SHORT $LL67@coff_creat
	cmp	eax, 3
	je	SHORT $LL67@coff_creat
	cmp	eax, 2
	je	SHORT $LL67@coff_creat
	mov	rax, QWORD PTR [rcx+8]
	cmp	BYTE PTR [rax], 95			; 0000005fH
	je	SHORT $LL66@coff_creat
	npad	9
$LL74@coff_creat:
	movzx	eax, BYTE PTR temp$6959[rsp+rbp]
	inc	rbp
	test	al, al
	mov	BYTE PTR buffer$[rsp+rbp-1], al
	jne	SHORT $LL74@coff_creat
	jmp	SHORT $LN63@coff_creat
	npad	11
$LL66@coff_creat:
	movzx	eax, BYTE PTR temp$6959[rsp+rbp+1]
	inc	rbp
	test	al, al
	mov	BYTE PTR buffer$[rsp+rbp-1], al
	jne	SHORT $LL66@coff_creat
	jmp	SHORT $LN63@coff_creat
	npad	11
$LL67@coff_creat:
	movzx	eax, BYTE PTR temp$6959[rsp+rbp+1]
	inc	rbp
	test	al, al
	mov	BYTE PTR buffer$[rsp+rbp-1], al
	jne	SHORT $LL67@coff_creat
$LN63@coff_creat:

; 1327 :                 p += sprintf( (char *)p, "-entry:%s ", buffer );

	lea	r8, QWORD PTR buffer$[rsp]
	lea	rdx, OFFSET FLAT:$SG6347
	mov	rcx, rbx
	call	sprintf
	movsxd	rcx, eax
	add	rbx, rcx
$LN6@coff_creat:

; 1328 :             }
; 1329 : #if DLLIMPORT
; 1330 :             /* 4. impdefs */
; 1331 :             for( tmp = imp; tmp ; tmp = tmp->next ) {

	test	rsi, rsi
	je	$LN111@coff_creat
$LL5@coff_creat:

; 1332 :                 if ( tmp->sym.isproc && ( tmp->sym.weak == FALSE || tmp->sym.iat_used == TRUE ) &&
; 1333 :                     tmp->sym.dll && *tmp->sym.dll->name ) {

	test	BYTE PTR [rsi+49], 8
	je	$LN4@coff_creat
	test	BYTE PTR [rsi+55], 8
	je	SHORT $LN1@coff_creat
	test	BYTE PTR [rsi+48], 8
	je	$LN4@coff_creat
$LN1@coff_creat:
	mov	rax, QWORD PTR [rsi+64]
	test	rax, rax
	je	$LN4@coff_creat
	cmp	BYTE PTR [rax+12], 0
	je	$LN4@coff_creat

; 1334 :                     strcpy( p, "-import:" );

	mov	rax, QWORD PTR $SG6353

; 1335 :                     p += 8;

	add	rbx, 8

; 1336 :                     p += Mangle( &tmp->sym, p );

	mov	rcx, rsi
	mov	QWORD PTR [rbx-8], rax
	movzx	eax, BYTE PTR $SG6353+8
	mov	rdx, rbx
	mov	BYTE PTR [rbx], al
	call	Mangle
	movsxd	rcx, eax
	add	rbx, rcx

; 1337 :                     *p++ = '=';

	inc	rbx
	mov	BYTE PTR [rbx-1], 61			; 0000003dH

; 1338 :                     strcpy( p, tmp->sym.dll->name );

	mov	rcx, QWORD PTR [rsi+64]
	mov	rdx, rbx
	add	rcx, 12
$LL48@coff_creat:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL48@coff_creat

; 1339 :                     p += strlen( p );

	mov	rdi, rbx
	xor	eax, eax
	mov	rcx, -1
	repne scasb
	not	rcx
	dec	rcx
	add	rbx, rcx

; 1340 :                     *p++ = '.';

	inc	rbx
	mov	BYTE PTR [rbx-1], 46			; 0000002eH

; 1341 :                     memcpy( p, tmp->sym.name, tmp->sym.name_size );

	movzx	r8d, BYTE PTR [rsi+80]
	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, rbx
	call	memcpy

; 1342 :                     p += tmp->sym.name_size;

	movzx	edx, BYTE PTR [rsi+80]
	add	rbx, rdx

; 1343 :                     *p++ = ' ';

	inc	rbx
	mov	BYTE PTR [rbx-1], 32			; 00000020H
$LN4@coff_creat:
	mov	rsi, QWORD PTR [rsi+112]
	test	rsi, rsi
	jne	$LL5@coff_creat
$LN111@coff_creat:
	mov	rbx, QWORD PTR [rsp+608]
	mov	rdi, QWORD PTR [rsp+632]
$LN3@coff_creat:
	mov	r15, QWORD PTR [rsp+568]
	mov	r14, QWORD PTR [rsp+576]
	mov	r12, QWORD PTR [rsp+592]
	mov	rsi, QWORD PTR [rsp+624]
	mov	rbp, QWORD PTR [rsp+616]

; 1344 :                 }
; 1345 :             }
; 1346 : #endif
; 1347 :             /**/myassert( size == p - cm->directives->e.seginfo->CodeBuffer );
; 1348 :             //size_drectve = p - directives->e.seginfo->CodeBuffer; /* v2.11:removed */
; 1349 :         }
; 1350 :     }
; 1351 : }

	add	rsp, 600				; 00000258H
	ret	0
coff_create_drectve ENDP
_TEXT	ENDS
EXTRN	time:NEAR
EXTRN	cv_write_debug_tables:NEAR
EXTRN	memset:NEAR
xdata	SEGMENT
$unwind$coff_write_module DD 020a01H
	DD	01d010aH
xdata	ENDS
pdata	SEGMENT
$pdata$coff_write_module DD @imagerel(coff_write_module#)
	DD	@imagerel(coff_write_module#+10)
	DD	@imagerel($unwind$coff_write_module#)
pdata	ENDS
xdata	SEGMENT
$chain$1$coff_write_module DD 040821H
	DD	0217408H
	DD	01e3404H
	DD	@imagerel(coff_write_module#)
	DD	@imagerel(coff_write_module#+10)
	DD	@imagerel($unwind$coff_write_module#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$coff_write_module DD @imagerel(coff_write_module#+10)
	DD	@imagerel(coff_write_module#+18)
	DD	@imagerel($chain$1$coff_write_module#)
pdata	ENDS
xdata	SEGMENT
$chain$3$coff_write_module DD 041621H
	DD	01ae416H
	DD	01cc404H
	DD	@imagerel(coff_write_module#+10)
	DD	@imagerel(coff_write_module#+18)
	DD	@imagerel($chain$1$coff_write_module#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$coff_write_module DD @imagerel(coff_write_module#+18)
	DD	@imagerel(coff_write_module#+84)
	DD	@imagerel($chain$3$coff_write_module#)
pdata	ENDS
xdata	SEGMENT
$chain$5$coff_write_module DD 041021H
	DD	0206410H
	DD	01f5408H
	DD	@imagerel(coff_write_module#+18)
	DD	@imagerel(coff_write_module#+84)
	DD	@imagerel($chain$3$coff_write_module#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$coff_write_module DD @imagerel(coff_write_module#+84)
	DD	@imagerel(coff_write_module#+100)
	DD	@imagerel($chain$5$coff_write_module#)
pdata	ENDS
xdata	SEGMENT
$chain$6$coff_write_module DD 020821H
	DD	01bd408H
	DD	@imagerel(coff_write_module#+84)
	DD	@imagerel(coff_write_module#+100)
	DD	@imagerel($chain$5$coff_write_module#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$coff_write_module DD @imagerel(coff_write_module#+100)
	DD	@imagerel(coff_write_module#+264)
	DD	@imagerel($chain$6$coff_write_module#)
pdata	ENDS
xdata	SEGMENT
$chain$7$coff_write_module DD 021H
	DD	@imagerel(coff_write_module#+84)
	DD	@imagerel(coff_write_module#+100)
	DD	@imagerel($chain$5$coff_write_module#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$coff_write_module DD @imagerel(coff_write_module#+264)
	DD	@imagerel(coff_write_module#+407)
	DD	@imagerel($chain$7$coff_write_module#)
pdata	ENDS
xdata	SEGMENT
$chain$8$coff_write_module DD 021H
	DD	@imagerel(coff_write_module#+18)
	DD	@imagerel(coff_write_module#+84)
	DD	@imagerel($chain$3$coff_write_module#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$coff_write_module DD @imagerel(coff_write_module#+407)
	DD	@imagerel(coff_write_module#+672)
	DD	@imagerel($chain$8$coff_write_module#)
pdata	ENDS
xdata	SEGMENT
$chain$9$coff_write_module DD 020021H
	DD	01ae400H
	DD	@imagerel(coff_write_module#+10)
	DD	@imagerel(coff_write_module#+18)
	DD	@imagerel($chain$1$coff_write_module#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$coff_write_module DD @imagerel(coff_write_module#+672)
	DD	@imagerel(coff_write_module#+736)
	DD	@imagerel($chain$9$coff_write_module#)
pdata	ENDS
xdata	SEGMENT
$chain$10$coff_write_module DD 021H
	DD	@imagerel(coff_write_module#+10)
	DD	@imagerel(coff_write_module#+18)
	DD	@imagerel($chain$1$coff_write_module#)
xdata	ENDS
pdata	SEGMENT
$pdata$10$coff_write_module DD @imagerel(coff_write_module#+736)
	DD	@imagerel(coff_write_module#+882)
	DD	@imagerel($chain$10$coff_write_module#)
pdata	ENDS
xdata	SEGMENT
$chain$11$coff_write_module DD 021H
	DD	@imagerel(coff_write_module#)
	DD	@imagerel(coff_write_module#+10)
	DD	@imagerel($unwind$coff_write_module#)
xdata	ENDS
pdata	SEGMENT
$pdata$11$coff_write_module DD @imagerel(coff_write_module#+882)
	DD	@imagerel(coff_write_module#+897)
	DD	@imagerel($chain$11$coff_write_module#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
ifh$ = 48
cm$ = 80
modinfo$ = 240
coff_write_module PROC NEAR

; 1359 : {

	mov	rax, rsp
	sub	rsp, 232				; 000000e8H
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+32], rdi
	mov	QWORD PTR [rax-8], r12

; 1360 :     struct stringitem  *pName;
; 1361 :     struct coffmod cm;
; 1362 :     struct IMAGE_FILE_HEADER ifh;
; 1363 : 
; 1364 :     DebugMsg(("coff_write_module: enter, sections=%u\n", modinfo->g.num_segs ));
; 1365 : 
; 1366 :     memset( &cm, 0, sizeof( cm ) );

	xor	edx, edx
	mov	r12, rcx
	lea	rcx, QWORD PTR cm$[rsp]
	lea	r8d, QWORD PTR [rdx+120]
	mov	QWORD PTR [rax-24], r14
	call	memset

; 1367 :     //directives = NULL;
; 1368 :     //LongNames.head = NULL;
; 1369 :     cm.LongNames.size = sizeof( uint_32 );
; 1370 : 
; 1371 :     /* get value for .file symbol */
; 1372 :     cm.dot_file_value = CurrFName[ASM];

	mov	rax, QWORD PTR ModuleInfo+128

; 1373 : #if 0 /* v2.09: always add the name in CurrFName[ASM] */
; 1374 :     cm.dot_file_value += strlen( dot_file_value );
; 1375 :     while ( cm.dot_file_value > CurrFName[ASM] &&
; 1376 :            *(cm.dot_file_value-1) != '/' &&
; 1377 :            *(cm.dot_file_value-1) != '\\') cm.dot_file_value--;
; 1378 : #endif
; 1379 : 
; 1380 :     /* it might be necessary to add "internal" sections:
; 1381 :      * - .debug$S and .debug$T sections if -Zi was set
; 1382 :      * - .sxdata section if .SAFESEH was used
; 1383 :      * - .drectve section if start label, exports or includelibs are used
; 1384 :      */
; 1385 : 	
; 1386 :     /* if -Zi is set, add .debug$S and .debug$T sections */
; 1387 :     if ( Options.debug_symbols ) {

	xor	r14d, r14d
	cmp	BYTE PTR Options+2, r14b
	mov	DWORD PTR cm$[rsp+112], 4
	mov	QWORD PTR cm$[rsp+24], rax
	je	$LN18@coff_write@5
	mov	QWORD PTR [rsp+248], rbp
	mov	QWORD PTR [rsp+256], rsi
	mov	QWORD PTR [rsp+216], r13

; 1388 :         int i;
; 1389 :         for ( i = 0; i < DBGS_MAX; i++ ) {

	lea	r13, OFFSET FLAT:coff_flushfunc
	mov	ebp, r14d
	mov	esi, r14d
	lea	rdi, QWORD PTR cm$[rsp+48]
	lea	rbx, OFFSET FLAT:SymDebName
	npad	8
$LL25@coff_write@5:

; 1390 :             if ( NULL == ( cm.SymDeb[i].seg = (struct dsym *)CreateIntSegment( SymDebName[i], "", 0, USE32, TRUE ) ) )

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:$SG6371
	mov	r9b, 1
	xor	r8d, r8d
	mov	BYTE PTR [rsp+32], 1
	call	CreateIntSegment
	test	rax, rax
	mov	QWORD PTR [rdi], rax
	je	SHORT $LN36@coff_write@5

; 1391 :                 break;
; 1392 :             DebugMsg(("coff_write_module: %s section added\n", SymDebName[i] ));
; 1393 :             cm.SymDeb[i].seg->e.seginfo->characteristics = (IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_DISCARDABLE) >> 24;

	mov	rax, QWORD PTR [rax+104]

; 1394 :             /* use the source line buffer as code buffer. It isn't needed anymore */
; 1395 :             cm.SymDeb[i].seg->e.seginfo->CodeBuffer = CurrSource + i * SIZE_CV_SEGBUF;

	movsxd	rdx, esi
	add	esi, 2048				; 00000800H
	mov	BYTE PTR [rax+105], 66			; 00000042H
	mov	rax, QWORD PTR [rdi]
	add	rdx, QWORD PTR ModuleInfo+464
	mov	rcx, QWORD PTR [rax+104]
	add	rdi, 24
	inc	ebp
	mov	QWORD PTR [rcx+16], rdx

; 1396 :             cm.SymDeb[i].seg->e.seginfo->flushfunc = coff_flushfunc;

	mov	rax, QWORD PTR [rdi-24]
	add	rbx, 8
	cmp	esi, 4096				; 00001000H
	mov	rcx, QWORD PTR [rax+104]
	mov	QWORD PTR [rcx+32], r13

; 1397 :             cm.SymDeb[i].q.head = NULL;

	mov	QWORD PTR [rdi-16], r14
	jl	SHORT $LL25@coff_write@5
$LN36@coff_write@5:

; 1398 :         }
; 1399 :         if ( i == DBGS_MAX ) {

	cmp	ebp, 2
	mov	r13, QWORD PTR [rsp+216]
	jne	$LN44@coff_write@5

; 1400 :             cv_write_debug_tables( cm.SymDeb[DBGS_SYMBOLS].seg, cm.SymDeb[DBGS_TYPES].seg, &cm );

	mov	rdx, QWORD PTR cm$[rsp+72]
	mov	rcx, QWORD PTR cm$[rsp+48]
	lea	r8, QWORD PTR cm$[rsp]
	call	cv_write_debug_tables
	lea	rsi, QWORD PTR cm$[rsp+48]
	mov	ebp, 2
	npad	1
$LL20@coff_write@5:

; 1405 :                 uint_8 *src;
; 1406 :                 uint_8 *dst;
; 1407 :                 if ( cm.SymDeb[i].seg->sym.max_offset ) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+64]
	test	ecx, ecx
	je	SHORT $LN19@coff_write@5

; 1408 :                     cm.SymDeb[i].seg->e.seginfo->CodeBuffer = LclAlloc( cm.SymDeb[i].seg->sym.max_offset );

	call	LclAlloc
	mov	rcx, QWORD PTR [rsi]
	mov	rdx, QWORD PTR [rcx+104]
	mov	QWORD PTR [rdx+16], rax

; 1409 :                     dst = cm.SymDeb[i].seg->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR [rsi]

; 1410 :                     for ( src = cm.SymDeb[i].q.head; src; src = ((struct qditem *)src)->next ) {

	mov	rdi, QWORD PTR [rsi+8]
	test	rdi, rdi
	mov	rcx, QWORD PTR [rax+104]
	mov	rbx, QWORD PTR [rcx+16]
	je	SHORT $LN19@coff_write@5
	npad	1
$LL16@coff_write@5:

; 1411 :                         memcpy( dst, src + sizeof( struct qditem ), ((struct qditem *)src)->size );

	mov	r8d, DWORD PTR [rdi+8]
	lea	rdx, QWORD PTR [rdi+16]
	mov	rcx, rbx
	call	memcpy

; 1412 :                         dst += ((struct qditem *)src)->size;

	mov	edx, DWORD PTR [rdi+8]
	mov	rdi, QWORD PTR [rdi]
	add	rbx, rdx
	test	rdi, rdi
	jne	SHORT $LL16@coff_write@5
$LN19@coff_write@5:

; 1401 :             /* the contents have been written in queues. now
; 1402 :              * copy all queue items in ONE buffer.
; 1403 :              */
; 1404 :             for ( i = 0; i < DBGS_MAX; i++ ) {

	add	rsi, 24
	dec	rbp
	jne	SHORT $LL20@coff_write@5
$LN44@coff_write@5:
	mov	rbp, QWORD PTR [rsp+248]
	mov	rsi, QWORD PTR [rsp+256]
$LN18@coff_write@5:

; 1413 :                         /* fixme: free the queue items if FASTMEM==0 */
; 1414 :                     }
; 1415 :                 }
; 1416 :             }
; 1417 :         }
; 1418 :     }
; 1419 : 
; 1420 :     /* if safeSEH procs are defined, add a .sxdata section */
; 1421 :     if ( modinfo->g.SafeSEHQueue.head ) {

	cmp	QWORD PTR [r12+48], r14
	je	SHORT $LN12@coff_write@5

; 1422 :         struct qnode *sehp;
; 1423 :         unsigned cnt = 0;
; 1424 :         if ( cm.sxdata = (struct dsym *)CreateIntSegment( ".sxdata", "", MAX_SEGALIGNMENT, modinfo->Ofssize, FALSE ) ) {

	movzx	r9d, BYTE PTR [r12+404]
	lea	rdx, OFFSET FLAT:$SG6392
	lea	rcx, OFFSET FLAT:$SG6393
	mov	edi, r14d
	mov	r8b, 255				; 000000ffH
	mov	BYTE PTR [rsp+32], dil
	call	CreateIntSegment
	test	rax, rax
	mov	QWORD PTR cm$[rsp+8], rax
	je	SHORT $LN12@coff_write@5

; 1425 :             cm.sxdata->e.seginfo->info = TRUE;

	mov	rax, QWORD PTR [rax+104]
	or	BYTE PTR [rax+107], 2

; 1426 :             /* calc the size for this segment */
; 1427 :             for( sehp = modinfo->g.SafeSEHQueue.head; sehp ; sehp = sehp->next, cnt++ );

	mov	rax, QWORD PTR [r12+48]
	test	rax, rax
	je	SHORT $LN9@coff_write@5
$LL11@coff_write@5:
	mov	rax, QWORD PTR [rax]
	inc	edi
	test	rax, rax
	jne	SHORT $LL11@coff_write@5
$LN9@coff_write@5:

; 1428 :             cm.sxdata->sym.max_offset = cnt*4;

	mov	rax, QWORD PTR cm$[rsp+8]
	lea	ecx, DWORD PTR [rdi*4]
	mov	DWORD PTR [rax+64], ecx

; 1429 :             cm.sxdata->e.seginfo->CodeBuffer = LclAlloc( cnt*4 );

	call	LclAlloc
	mov	rcx, QWORD PTR cm$[rsp+8]
	mov	rdx, QWORD PTR [rcx+104]
	mov	QWORD PTR [rdx+16], rax
$LN12@coff_write@5:

; 1430 :             DebugMsg(("coff_write_module: .sxdata section added, size=%u\n", cnt*4));
; 1431 :         }
; 1432 :     }
; 1433 : 
; 1434 :     /* create .drectve section if necessary */
; 1435 :     coff_create_drectve( modinfo, &cm );

	lea	rdx, QWORD PTR cm$[rsp]
	mov	rcx, r12
	call	coff_create_drectve

; 1436 : 
; 1437 :     /* v2.11: removed, max_offset has been set already */
; 1438 :     //if ( directives )
; 1439 :     //    directives->sym.max_offset = size_drectve;
; 1440 : 
; 1441 : #if AMD64_SUPPORT
; 1442 :     if ( modinfo->defOfssize == USE64 )

	cmp	BYTE PTR [r12+405], 2
	mov	eax, 34404				; 00008664H
	mov	edx, 332				; 0000014cH

; 1443 :         ifh.Machine = IMAGE_FILE_MACHINE_AMD64;
; 1444 :     else
; 1445 : #endif
; 1446 :         ifh.Machine = IMAGE_FILE_MACHINE_I386;
; 1447 :     ifh.NumberOfSections = modinfo->g.num_segs;
; 1448 : #if 0 //def __UNIX__
; 1449 :     time((int_32 *)&ifh.TimeDateStamp);
; 1450 : #else
; 1451 :     time((time_t *)&ifh.TimeDateStamp);

	lea	rcx, QWORD PTR ifh$[rsp+4]
	cmove	dx, ax
	movzx	eax, WORD PTR [r12+8]
	mov	WORD PTR ifh$[rsp+2], ax
	mov	WORD PTR ifh$[rsp], dx
	call	time

; 1452 : #endif
; 1453 :     ifh.SizeOfOptionalHeader = 0;
; 1454 :     ifh.Characteristics = 0;
; 1455 : 
; 1456 :     /* position behind coff file header */
; 1457 :     fseek( CurrFile[OBJ], sizeof( ifh ), SEEK_SET );

	mov	rcx, QWORD PTR ModuleInfo+104
	xor	r8d, r8d
	mov	WORD PTR ifh$[rsp+16], r14w
	lea	edx, QWORD PTR [r8+20]
	mov	WORD PTR ifh$[rsp+18], r14w
	call	fseek

; 1458 : 
; 1459 :     coff_write_section_table( modinfo, &cm );

	lea	rdx, QWORD PTR cm$[rsp]
	mov	rcx, r12
	call	coff_write_section_table

; 1460 :     coff_write_data( modinfo, &cm );

	lea	rdx, QWORD PTR cm$[rsp]
	mov	rcx, r12
	call	coff_write_data

; 1461 :     /* v2.12: check that calculated sizes are identical to those that have been written */
; 1462 :     /*myassert( cm.start_symtab == ( cm.start_data + cm.size_data ) );*/
; 1463 : 
; 1464 :     ifh.NumberOfSymbols = coff_write_symbols( modinfo, &cm );

	lea	rdx, QWORD PTR cm$[rsp]
	mov	rcx, r12
	call	coff_write_symbols
	mov	r12, QWORD PTR [rsp+224]

; 1465 :     ifh.PointerToSymbolTable = ( ifh.NumberOfSymbols ? cm.start_data + cm.size_data : 0 );

	test	eax, eax
	mov	DWORD PTR ifh$[rsp+12], eax
	je	SHORT $LN29@coff_write@5
	mov	ecx, DWORD PTR cm$[rsp+32]
	mov	eax, DWORD PTR cm$[rsp+36]
	add	ecx, eax
	mov	DWORD PTR ifh$[rsp+8], ecx
	jmp	SHORT $LN30@coff_write@5
$LN29@coff_write@5:
	mov	DWORD PTR ifh$[rsp+8], r14d
$LN30@coff_write@5:

; 1466 : 
; 1467 :     /* the string table is ALWAYS written, even if no strings are defined */
; 1468 :     DebugMsg(("coff_write_module: string_table size=%u\n", cm.LongNames.size ));
; 1469 :     if ( fwrite( &cm.LongNames.size, 1, sizeof( cm.LongNames.size ), CurrFile[OBJ] ) != sizeof( cm.LongNames.size ) )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	edx, 1
	lea	rcx, QWORD PTR cm$[rsp+112]
	lea	r8d, QWORD PTR [rdx+3]
	call	fwrite
	mov	r14, QWORD PTR [rsp+208]
	cmp	rax, 4
	je	SHORT $LN6@coff_write@5

; 1470 :         WriteError();

	call	WriteError
$LN6@coff_write@5:

; 1471 :     for ( pName = cm.LongNames.head; pName; pName = pName->next ) {

	mov	rbx, QWORD PTR cm$[rsp+96]
	test	rbx, rbx
	je	SHORT $LN3@coff_write@5
$LL5@coff_write@5:

; 1472 :         int i = strlen( pName->string ) + 1;
; 1473 :         if ( fwrite( pName->string, 1, i, CurrFile[OBJ] ) != i )

	mov	r9, QWORD PTR ModuleInfo+104
	xor	eax, eax
	lea	rdi, QWORD PTR [rbx+8]
	mov	rcx, -1
	lea	edx, QWORD PTR [rax+1]
	repne scasb
	not	rcx
	and	ecx, ecx
	movsxd	rdi, ecx
	lea	rcx, QWORD PTR [rbx+8]
	mov	r8, rdi
	call	fwrite
	cmp	rax, rdi
	je	SHORT $LN4@coff_write@5

; 1474 :             WriteError();

	call	WriteError
$LN4@coff_write@5:

; 1471 :     for ( pName = cm.LongNames.head; pName; pName = pName->next ) {

	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL5@coff_write@5
$LN3@coff_write@5:

; 1475 :     }
; 1476 : #if FASTMEM==0
; 1477 :     for ( ; cm.LongNames.head; ) {
; 1478 :         pName = cm.LongNames.head;
; 1479 :         cm.LongNames.head = cm.LongNames.head->next;
; 1480 :         LclFree( pName );
; 1481 :     }
; 1482 : #endif
; 1483 :     /* finally write the COFF file header */
; 1484 :     fseek( CurrFile[OBJ], 0, SEEK_SET);

	mov	rcx, QWORD PTR ModuleInfo+104
	xor	r8d, r8d
	xor	edx, edx
	call	fseek

; 1485 :     if ( fwrite( &ifh, 1, sizeof( ifh ), CurrFile[OBJ] ) != sizeof( ifh ) ) {

	mov	r9, QWORD PTR ModuleInfo+104
	mov	edx, 1
	lea	r8d, QWORD PTR [rdx+19]
	lea	rcx, QWORD PTR ifh$[rsp]
	call	fwrite
	mov	rdi, QWORD PTR [rsp+264]
	mov	rbx, QWORD PTR [rsp+240]
	cmp	rax, 20
	je	SHORT $LN42@coff_write@5

; 1486 :         DebugMsg(("coff_write_module: error writing file header\n"));
; 1487 :         WriteError();

	call	WriteError
$LN42@coff_write@5:

; 1488 :     }
; 1489 : 
; 1490 :     DebugMsg(("coff_write_module: exit\n"));
; 1491 :     return( NOT_ERROR );

	xor	eax, eax

; 1492 : }

	add	rsp, 232				; 000000e8H
	ret	0
coff_write_module ENDP
_TEXT	ENDS
PUBLIC	coff_init
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
modinfo$ = 8
coff_init PROC NEAR

; 1497 :     modinfo->g.WriteModule = coff_write_module;

	lea	rax, OFFSET FLAT:coff_write_module
	mov	QWORD PTR [rcx+288], rax

; 1498 :     return;
; 1499 : }

	ret	0
coff_init ENDP
_TEXT	ENDS
END
