; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG6408	DB	01H DUP (?)
	ALIGN	4

$SG6403	DB	02H DUP (?)
	ALIGN	4

$SG6400	DB	01H DUP (?)
	ALIGN	4

$SG6389	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
flaginstr DB	07aH
	DB	063H
	DB	073H
	DB	070H
	DB	06fH
	DB	06cH
	DB	067H
	DB	061H
	DB	065H
	DB	062H
	ORG $+2
unsigned_cjmptype DB 07aH
	DB	07aH
	DB	061H
	DB	062H
	DB	062H
	DB	061H
	ORG $+2
signed_cjmptype DB 07aH
	DB	07aH
	DB	067H
	DB	06cH
	DB	06cH
	DB	067H
	ORG $+2
neg_cjmptype DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
CONST	ENDS
_DATA	SEGMENT
$SG5645	DB	'ZERO', 00H
	ORG $+3
$SG5648	DB	'CARRY', 00H
	ORG $+2
$SG5651	DB	'SIGN', 00H
	ORG $+3
$SG5654	DB	'PARITY', 00H
	ORG $+1
$SG5657	DB	'OVERFLOW', 00H
	ORG $+3
$SG5660	DB	'LESS', 00H
	ORG $+7
$SG5663	DB	'GREATER', 00H
$SG5666	DB	'ABOVE', 00H
	ORG $+2
$SG5669	DB	'EQUAL', 00H
	ORG $+2
$SG5672	DB	'BELOW', 00H
	ORG $+2
$SG5749	DB	', %d', 00H
	ORG $+3
$SG5756	DB	'@C%04X', 00H
	ORG $+1
$SG5858	DB	'test', 00H
	ORG $+3
$SG5860	DB	'cmp', 00H
	ORG $+4
$SG5866	DB	'jmp @C%04X', 0aH, 00H
$SG5871	DB	'test', 00H
	ORG $+3
$SG5876	DB	'or', 00H
	ORG $+1
$SG5880	DB	'test', 00H
	ORG $+3
$SG5882	DB	'cmp', 00H
$SG5890	DB	'jmp ', 00H
	ORG $+3
$SG5951	DB	0aH, 00H
	ORG $+2
$SG5953	DB	':', 0aH, 00H
	ORG $+1
$SG5957	DB	':', 0aH, 00H
	ORG $+1
$SG5988	DB	0aH, 00H
	ORG $+2
$SG5992	DB	'%s:', 0aH, 00H
	ORG $+3
$SG5994	DB	'%s:', 0aH, 00H
	ORG $+3
$SG5998	DB	':', 0aH, 00H
	ORG $+1
$SG6044	DB	'loope', 00H
	ORG $+2
$SG6048	DB	'loop', 00H
	ORG $+3
$SG6055	DB	'ax', 00H
	ORG $+1
$SG6056	DB	'eax', 00H
$SG6057	DB	'rax', 00H
	ORG $+4
reax	DQ	FLAT:$SG6055
	DQ	FLAT:$SG6056
	DQ	FLAT:$SG6057
$SG6059	DB	'dx', 00H
	ORG $+1
$SG6060	DB	'edx', 00H
$SG6061	DB	'rdx', 00H
	ORG $+4
redx	DQ	FLAT:$SG6059
	DQ	FLAT:$SG6060
	DQ	FLAT:$SG6061
$SG6063	DB	'cx', 00H
	ORG $+1
$SG6064	DB	'ecx', 00H
$SG6065	DB	'rcx', 00H
	ORG $+4
recx	DQ	FLAT:$SG6063
	DQ	FLAT:$SG6064
	DQ	FLAT:$SG6065
$SG6075	DB	', ', 00H
	ORG $+5
$SG6099	DB	'=!<>&|-+*^%/', 00H
	ORG $+3
$SG6105	DB	' inc ', 00H
	ORG $+2
$SG6108	DB	' dec ', 00H
	ORG $+2
$SG6130	DB	' mov  ', 00H
	ORG $+1
$SG6133	DB	' cdq ', 00H
	ORG $+2
$SG6135	DB	' mov  ', 00H
	ORG $+1
$SG6138	DB	' idiv ', 00H
	ORG $+1
$SG6140	DB	' imul ', 00H
	ORG $+1
$SG6145	DB	' idiv ', 00H
	ORG $+1
$SG6147	DB	' imul ', 00H
	ORG $+1
$SG6150	DB	' mov  ', 00H
	ORG $+1
$SG6151	DB	' mov  ', 00H
	ORG $+1
$SG6154	DB	' cdq ', 00H
	ORG $+2
$SG6155	DB	' idiv ', 00H
	ORG $+1
$SG6157	DB	' imul ', 00H
	ORG $+1
$SG6159	DB	' mov  ', 00H
	ORG $+1
$SG6162	DB	' mov  ', 00H
	ORG $+1
$SG6167	DB	' cdq ', 00H
	ORG $+2
$SG6168	DB	' idiv ', 00H
	ORG $+1
$SG6170	DB	' imul ', 00H
	ORG $+1
$SG6172	DB	' mov  ', 00H
	ORG $+1
$SG6177	DB	' cdq ', 00H
	ORG $+2
$SG6178	DB	' idiv ', 00H
	ORG $+1
$SG6180	DB	' imul ', 00H
	ORG $+1
$SG6182	DB	' mov  ', 00H
	ORG $+1
$SG6186	DB	' mov  ', 00H
	ORG $+1
$SG6189	DB	' cdq ', 00H
	ORG $+2
$SG6190	DB	' idiv ', 00H
	ORG $+1
$SG6192	DB	' imul ', 00H
	ORG $+1
$SG6194	DB	' mov  ', 00H
	ORG $+1
$SG6197	DB	' sub ', 00H
	ORG $+2
$SG6200	DB	' add ', 00H
	ORG $+2
$SG6203	DB	' and ', 00H
	ORG $+2
$SG6206	DB	' or ', 00H
	ORG $+3
$SG6209	DB	' xor ', 00H
	ORG $+2
$SG6212	DB	' shl ', 00H
	ORG $+2
$SG6215	DB	' shr ', 00H
	ORG $+2
$SG6221	DB	' xor  ', 00H
	ORG $+1
$SG6227	DB	'BYTE PTR', 00H
	ORG $+3
$SG6228	DB	'BPTR', 00H
	ORG $+3
$SG6229	DB	'WPTR', 00H
	ORG $+7
$SG6230	DB	'WORD PTR', 00H
	ORG $+7
$SG6231	DB	' movzx  ', 00H
	ORG $+3
$SG6234	DB	'ADDR', 00H
	ORG $+3
$SG6235	DB	' lea  ', 00H
	ORG $+1
$SG6237	DB	' mov  ', 00H
	ORG $+1
$SG6242	DB	'OFFSET', 00H
	ORG $+1
$SG6243	DB	' lea  ', 00H
	ORG $+1
$SG6245	DB	' mov  ', 00H
	ORG $+5
$SG6251	DB	'DWORD PTR', 00H
	ORG $+2
$SG6252	DB	'DPTR', 00H
	ORG $+7
$SG6254	DB	' movsxd  ', 00H
	ORG $+2
$SG6256	DB	' mov  ', 00H
	ORG $+5
$SG6268	DB	' invoke  ', 00H
	ORG $+2
$SG6269	DB	' mov  ', 00H
	ORG $+1
$SG6272	DB	' mov  ', 00H
	ORG $+5
$SG6276	DB	' mov  byte ptr ', 00H
$SG6278	DB	' mov  ', 00H
	ORG $+1
$SG6332	DB	' movzx eax, %s', 00H
	ORG $+1
$SG6335	DB	' mov eax, %s', 00H
	ORG $+3
$SG6340	DB	' movzx eax, %s', 00H
	ORG $+1
$SG6343	DB	' mov eax, %s', 00H
	ORG $+3
$SG6346	DB	' mov rax, %s', 00H
	ORG $+3
$SG6351	DB	' movzx eax, %s', 00H
	ORG $+1
$SG6353	DB	' mov eax, %s', 00H
	ORG $+3
$SG6357	DB	' movzx eax, %s', 00H
	ORG $+1
$SG6360	DB	' mov eax, %s', 00H
	ORG $+3
$SG6362	DB	' mov rax, %s', 00H
	ORG $+3
$SG6364	DB	'jmp %s', 00H
	ORG $+1
$SG6374	DB	'(::)', 00H
	ORG $+3
$SG6398	DB	' jmp %s', 00H
$SG6402	DB	'.for ', 00H
	ORG $+2
$SG6404	DB	'.for', 00H, 00H
	ORG $+2
$SG6409	DB	'%s:', 00H
$SG6418	DB	'jmp', 00H
$SG6419	DB	'jmp %s', 00H
	ORG $+1
$SG6421	DB	'%s:', 00H
$SG6454	DB	'%s:', 00H
$SG6461	DB	'jmp %s', 00H
	ORG $+1
$SG6463	DB	'%s:', 00H
	ORG $+4
$SG6464	DB	'ALIGN %d', 00H
	ORG $+3
$SG6465	DB	'%s:', 00H
$SG6499	DB	'cmp  eax,%d', 00H
$SG6500	DB	'je  %s', 00H
	ORG $+5
$SG6502	DB	'jmp  %s', 00H
$SG6504	DB	'jmp  %s', 00H
$SG6506	DB	'push rdx', 00H
	ORG $+7
$SG6507	DB	'mov rdx, %q', 00H
	ORG $+4
$SG6508	DB	'cmp rax, rdx', 00H
	ORG $+3
$SG6509	DB	'pop rdx', 00H
$SG6510	DB	'je  %s', 00H
	ORG $+1
$SG6512	DB	'jmp  %s', 00H
$SG6514	DB	'jmp  %s', 00H
$SG6519	DB	'cmp  eax,%d', 00H
$SG6520	DB	'je  %s', 00H
	ORG $+5
$SG6521	DB	'cmp  eax,%d', 00H
$SG6522	DB	'je  %s', 00H
	ORG $+5
$SG6524	DB	'jmp  %s', 00H
$SG6526	DB	'jmp  %s', 00H
$SG6528	DB	'push rdx', 00H
	ORG $+7
$SG6529	DB	'mov rdx, %q', 00H
	ORG $+4
$SG6530	DB	'cmp rax, rdx', 00H
	ORG $+3
$SG6531	DB	'pop rdx', 00H
$SG6532	DB	'je  %s', 00H
	ORG $+1
$SG6533	DB	'push rdx', 00H
	ORG $+7
$SG6534	DB	'mov rdx, %q', 00H
	ORG $+4
$SG6535	DB	'cmp rax, rdx', 00H
	ORG $+3
$SG6536	DB	'pop rdx', 00H
$SG6537	DB	'je  %s', 00H
	ORG $+1
$SG6539	DB	'jmp  %s', 00H
$SG6541	DB	'jmp  %s', 00H
$SG6546	DB	'cmp  eax,%d', 00H
$SG6547	DB	'je  %s', 00H
	ORG $+5
$SG6548	DB	'cmp  eax,%d', 00H
$SG6549	DB	'je  %s', 00H
	ORG $+5
$SG6550	DB	'cmp  eax,%d', 00H
$SG6551	DB	'je  %s', 00H
	ORG $+5
$SG6553	DB	'jmp  %s', 00H
$SG6555	DB	'jmp  %s', 00H
$SG6557	DB	'push rdx', 00H
	ORG $+7
$SG6558	DB	'mov rdx, %q', 00H
	ORG $+4
$SG6559	DB	'cmp rax, rdx', 00H
	ORG $+3
$SG6560	DB	'pop rdx', 00H
$SG6561	DB	'je  %s', 00H
	ORG $+1
$SG6562	DB	'push rdx', 00H
	ORG $+7
$SG6563	DB	'mov rdx, %q', 00H
	ORG $+4
$SG6564	DB	'cmp rax, rdx', 00H
	ORG $+3
$SG6565	DB	'pop rdx', 00H
$SG6566	DB	'je  %s', 00H
	ORG $+1
$SG6567	DB	'push rdx', 00H
	ORG $+7
$SG6568	DB	'mov rdx, %q', 00H
	ORG $+4
$SG6569	DB	'cmp rax, rdx', 00H
	ORG $+3
$SG6570	DB	'pop rdx', 00H
$SG6571	DB	'je  %s', 00H
	ORG $+1
$SG6573	DB	'jmp  %s', 00H
$SG6575	DB	'jmp  %s', 00H
$SG6581	DB	'cmp eax,%d', 00H
	ORG $+1
$SG6582	DB	'jl  %s', 00H
	ORG $+5
$SG6583	DB	'cmp eax,%d', 00H
	ORG $+1
$SG6584	DB	'ja  %s', 00H
	ORG $+5
$SG6586	DB	'push', 09H, 'rax', 00H
	ORG $+7
$SG6587	DB	'push', 09H, 'rdx', 00H
	ORG $+7
$SG6588	DB	'mov rdx, %q', 00H
	ORG $+4
$SG6589	DB	'cmp rax, rdx', 00H
	ORG $+3
$SG6590	DB	'pop', 09H, 'rdx', 00H
$SG6591	DB	'pop', 09H, 'rax', 00H
$SG6592	DB	'jl  %s', 00H
	ORG $+1
$SG6593	DB	'mov rdx, %q', 00H
	ORG $+4
$SG6594	DB	'cmp rax, rdx', 00H
	ORG $+3
$SG6595	DB	'pop', 09H, 'rdx', 00H
$SG6596	DB	'pop', 09H, 'rax', 00H
$SG6597	DB	'ja  %s', 00H
	ORG $+1
$SG6599	DB	'push', 09H, ' eax', 00H
	ORG $+6
$SG6600	DB	'movzx eax,byte ptr %s[%r - %d]', 00H
	ORG $+1
$SG6601	DB	'mov   eax,%s[%r*4]', 00H
	ORG $+5
$SG6602	DB	'xchg', 09H, ' eax,[esp]', 00H
$SG6603	DB	'retn', 00H
	ORG $+3
$SG6606	DB	'push', 09H, 'rax', 00H
	ORG $+7
$SG6607	DB	'push', 09H, 'rdx', 00H
	ORG $+7
$SG6608	DB	'lea   rdx,%s', 00H
	ORG $+3
$SG6609	DB	'movzx edx,byte ptr[rdx+rax-%u]', 00H
	ORG $+1
$SG6610	DB	'lea   rax,%s', 00H
	ORG $+3
$SG6611	DB	'mov   rax, qword ptr[rax+rdx*8]', 00H
$SG6612	DB	'pop   rdx', 00H
	ORG $+6
$SG6613	DB	'xchg', 09H, ' rax,[rsp]', 00H
$SG6614	DB	'retn', 00H
	ORG $+3
$SG6616	DB	'push', 09H, 'rax', 00H
	ORG $+7
$SG6617	DB	'push', 09H, 'rdx', 00H
	ORG $+7
$SG6618	DB	'lea   rdx,%s', 00H
	ORG $+3
$SG6619	DB	'movzx rdx,byte ptr[rdx+rax-%q]', 00H
	ORG $+1
$SG6620	DB	'lea   rax,%s', 00H
	ORG $+3
$SG6621	DB	'mov   rax, qword ptr[rax+rdx*8]', 00H
$SG6622	DB	'pop   rdx', 00H
	ORG $+6
$SG6623	DB	'xchg', 09H, ' rax,[rsp]', 00H
$SG6624	DB	'retn', 00H
	ORG $+3
$SG6630	DB	'cmp eax,%d', 00H
	ORG $+1
$SG6631	DB	'jl  %s', 00H
	ORG $+5
$SG6632	DB	'cmp eax,%d', 00H
	ORG $+1
$SG6633	DB	'ja  %s', 00H
	ORG $+5
$SG6635	DB	'push', 09H, 'rax', 00H
	ORG $+7
$SG6636	DB	'push', 09H, 'rdx', 00H
	ORG $+7
$SG6637	DB	'mov rdx, %q', 00H
	ORG $+4
$SG6638	DB	'cmp rax, rdx', 00H
	ORG $+3
$SG6639	DB	'pop', 09H, 'rdx', 00H
$SG6640	DB	'pop', 09H, 'rax', 00H
$SG6641	DB	'jl  %s', 00H
	ORG $+1
$SG6642	DB	'push', 09H, 'rax', 00H
	ORG $+7
$SG6643	DB	'push', 09H, 'rdx', 00H
	ORG $+7
$SG6644	DB	'mov rdx, %q', 00H
	ORG $+4
$SG6645	DB	'cmp rax, rdx', 00H
	ORG $+3
$SG6646	DB	'pop', 09H, 'rdx', 00H
$SG6647	DB	'pop', 09H, 'rax', 00H
$SG6648	DB	'ja  %s', 00H
	ORG $+1
$SG6650	DB	'push', 09H, ' eax', 00H
	ORG $+6
$SG6651	DB	'sub   eax,%u', 00H
	ORG $+3
$SG6652	DB	'movzx eax,word ptr %s[%r*2]', 00H
	ORG $+4
$SG6653	DB	'mov   eax,%s[%r*4]', 00H
	ORG $+5
$SG6654	DB	'xchg', 09H, ' eax,[esp]', 00H
$SG6655	DB	'retn', 00H
	ORG $+3
$SG6657	DB	'push', 09H, 'rax', 00H
	ORG $+7
$SG6658	DB	'push', 09H, 'rdx', 00H
	ORG $+7
$SG6660	DB	'lea   rdx,%s', 00H
	ORG $+3
$SG6661	DB	'sub   eax,%u', 00H
	ORG $+3
$SG6662	DB	'movzx rdx,word ptr[rdx+rax*2]', 00H
	ORG $+2
$SG6663	DB	'lea   rax,%s', 00H
	ORG $+3
$SG6664	DB	'mov   rax, qword ptr[rax+rdx*8]', 00H
$SG6665	DB	'pop   rdx', 00H
	ORG $+6
$SG6666	DB	'xchg', 09H, ' rax,[rsp]', 00H
$SG6667	DB	'retn', 00H
	ORG $+3
$SG6669	DB	'lea   rdx,%s', 00H
	ORG $+3
$SG6670	DB	'sub   rax,%u', 00H
	ORG $+3
$SG6671	DB	'movzx rdx,word ptr[rdx+rax*2]', 00H
	ORG $+2
$SG6672	DB	'lea   rax,%s', 00H
	ORG $+3
$SG6673	DB	'mov   rax, qword ptr[rax+rdx*8]', 00H
$SG6674	DB	'pop   rdx', 00H
	ORG $+6
$SG6675	DB	'xchg', 09H, ' rax,[rsp]', 00H
$SG6676	DB	'retn', 00H
	ORG $+3
$SG6682	DB	'cmp eax,%d', 00H
	ORG $+1
$SG6683	DB	'jl  %s', 00H
	ORG $+5
$SG6684	DB	'cmp eax,%d', 00H
	ORG $+1
$SG6685	DB	'ja  %s', 00H
	ORG $+5
$SG6687	DB	'push', 09H, 'rax', 00H
	ORG $+7
$SG6688	DB	'push', 09H, 'rdx', 00H
	ORG $+7
$SG6689	DB	'mov rdx, %q', 00H
	ORG $+4
$SG6690	DB	'cmp rax, rdx', 00H
	ORG $+3
$SG6691	DB	'pop', 09H, 'rdx', 00H
$SG6692	DB	'pop', 09H, 'rax', 00H
$SG6693	DB	'jl  %s', 00H
	ORG $+1
$SG6694	DB	'push', 09H, 'rax', 00H
	ORG $+7
$SG6695	DB	'push', 09H, 'rdx', 00H
	ORG $+7
$SG6696	DB	'mov rdx, %q', 00H
	ORG $+4
$SG6697	DB	'cmp rax, rdx', 00H
	ORG $+3
$SG6698	DB	'pop', 09H, 'rdx', 00H
$SG6699	DB	'pop', 09H, 'rax', 00H
$SG6700	DB	'ja  %s', 00H
	ORG $+1
$SG6702	DB	'push', 09H, ' eax', 00H
	ORG $+6
$SG6703	DB	'sub eax,%d', 00H
	ORG $+5
$SG6704	DB	'mov   eax,%s[%r*4]', 00H
	ORG $+5
$SG6705	DB	'xchg', 09H, ' eax,[esp]', 00H
$SG6706	DB	'retn', 00H
	ORG $+3
$SG6708	DB	'push', 09H, 'rax', 00H
	ORG $+7
$SG6709	DB	'push', 09H, 'rdx', 00H
	ORG $+7
$SG6711	DB	'sub   eax,%d', 00H
	ORG $+3
$SG6713	DB	'mov rdx,%q', 00H
	ORG $+5
$SG6714	DB	'sub rax,rdx', 00H
	ORG $+4
$SG6715	DB	'lea   rdx,%s', 00H
	ORG $+3
$SG6716	DB	'mov   rax, qword ptr[rdx+rax*8]', 00H
$SG6717	DB	'pop   rdx', 00H
	ORG $+6
$SG6718	DB	'xchg', 09H, ' rax,[rsp]', 00H
$SG6719	DB	'retn', 00H
	ORG $+3
$SG6723	DB	'push', 09H, 'eax', 00H
	ORG $+7
$SG6724	DB	'push', 09H, 'edx', 00H
	ORG $+7
$SG6725	DB	'push', 09H, 'ecx', 00H
	ORG $+7
$SG6726	DB	'push', 09H, 'ebx', 00H
	ORG $+7
$SG6727	DB	'push', 09H, 'esi', 00H
	ORG $+7
$SG6728	DB	'push', 09H, 'edi', 00H
	ORG $+7
$SG6729	DB	'mov  esi,eax', 00H
	ORG $+3
$SG6730	DB	'mov  ebx,%d', 00H
	ORG $+4
$SG6731	DB	'xor  ecx,ecx', 00H
	ORG $+3
$SG6732	DB	'lea  edi,%s', 00H
$SG6734	DB	'js  %s', 00H
	ORG $+1
$SG6736	DB	'js  %s', 00H
	ORG $+5
$SG6738	DB	'push', 09H, 'rax', 00H
	ORG $+7
$SG6739	DB	'push', 09H, 'rdx', 00H
	ORG $+7
$SG6740	DB	'push', 09H, 'rcx', 00H
	ORG $+7
$SG6741	DB	'push', 09H, 'rbx', 00H
	ORG $+7
$SG6742	DB	'push', 09H, 'rsi', 00H
	ORG $+7
$SG6743	DB	'push', 09H, 'rdi', 00H
	ORG $+7
$SG6745	DB	'mov  esi,eax', 00H
	ORG $+3
$SG6746	DB	'mov  ebx,%d', 00H
	ORG $+4
$SG6747	DB	'xor  ecx,ecx', 00H
	ORG $+3
$SG6748	DB	'lea  rdi,%s', 00H
	ORG $+4
$SG6750	DB	'mov  rsi,rax', 00H
	ORG $+3
$SG6751	DB	'mov  rbx,%q', 00H
	ORG $+4
$SG6752	DB	'xor  ecx,ecx', 00H
	ORG $+3
$SG6753	DB	'lea  rdi,%s', 00H
$SG6755	DB	'js  %s', 00H
	ORG $+1
$SG6757	DB	'js  %s', 00H
	ORG $+1
$SG6758	DB	'%s:', 00H
$SG6762	DB	'lea     eax,[ecx + ebx]', 00H
$SG6763	DB	'cdq', 00H
	ORG $+4
$SG6764	DB	'sub     eax,edx', 00H
$SG6765	DB	'sar     eax,1', 00H
	ORG $+2
$SG6766	DB	'cmp     [edi+eax*4],esi', 00H
$SG6767	DB	'je  %s', 00H
	ORG $+1
$SG6768	DB	'jge %s', 00H
	ORG $+1
$SG6769	DB	'lea     ecx,[eax+1]', 00H
$SG6770	DB	'jmp %s', 00H
	ORG $+5
$SG6773	DB	'lea     eax,[rcx + rbx]', 00H
$SG6774	DB	'cdq', 00H
	ORG $+4
$SG6775	DB	'sub     eax,edx', 00H
$SG6776	DB	'sar     rax,1', 00H
	ORG $+2
$SG6777	DB	'cmp     [rdi+rax*8],esi', 00H
$SG6778	DB	'je  %s', 00H
	ORG $+1
$SG6779	DB	'jge %s', 00H
	ORG $+1
$SG6780	DB	'lea     ecx,[rax+1]', 00H
$SG6781	DB	'jmp %s', 00H
	ORG $+5
$SG6783	DB	'lea     rax,[rcx + rbx]', 00H
$SG6784	DB	'cdq', 00H
	ORG $+4
$SG6785	DB	'sub     rax,rdx', 00H
$SG6786	DB	'sar     rax,1', 00H
	ORG $+2
$SG6787	DB	'cmp     [rdi+rax*8],rsi', 00H
$SG6788	DB	'je  %s', 00H
	ORG $+1
$SG6789	DB	'jge %s', 00H
	ORG $+1
$SG6790	DB	'lea     rcx,[rax+1]', 00H
$SG6791	DB	'jmp %s', 00H
	ORG $+1
$SG6792	DB	'%s:', 00H
$SG6796	DB	'pop', 09H, 'edi', 00H
$SG6797	DB	'pop', 09H, 'esi', 00H
$SG6798	DB	'pop', 09H, 'ebx', 00H
$SG6799	DB	'pop', 09H, 'ecx', 00H
$SG6800	DB	'pop', 09H, 'edx', 00H
$SG6801	DB	'mov  eax,%s[%r*4]', 00H
	ORG $+6
$SG6802	DB	'xchg', 09H, ' eax,[esp]', 00H
$SG6803	DB	'retn', 00H
	ORG $+3
$SG6805	DB	'pop', 09H, 'rdi', 00H
$SG6806	DB	'pop', 09H, 'rsi', 00H
$SG6807	DB	'pop', 09H, 'rbx', 00H
$SG6808	DB	'pop', 09H, 'rcx', 00H
$SG6809	DB	'lea   rdx,%s', 00H
	ORG $+3
$SG6810	DB	'mov   rax, qword ptr[rdx+rax*8]', 00H
$SG6811	DB	'pop   rdx', 00H
	ORG $+6
$SG6812	DB	'xchg', 09H, ' rax,[rsp]', 00H
$SG6813	DB	'retn', 00H
	ORG $+3
$SG6814	DB	'%s:', 00H
	ORG $+4
$SG6818	DB	'lea     ebx,[eax-1]', 00H
	ORG $+4
$SG6821	DB	'lea     ebx,[rax-1]', 00H
	ORG $+4
$SG6823	DB	'lea     rbx,[rax-1]', 00H
$SG6824	DB	'%s:', 00H
$SG6828	DB	'cmp  ecx,ebx', 00H
	ORG $+3
$SG6829	DB	'jle %s', 00H
	ORG $+1
$SG6830	DB	'pop', 09H, 'edi', 00H
$SG6831	DB	'pop', 09H, 'esi', 00H
$SG6832	DB	'pop', 09H, 'ebx', 00H
$SG6833	DB	'pop', 09H, 'ecx', 00H
$SG6834	DB	'pop', 09H, 'edx', 00H
$SG6835	DB	'pop', 09H, 'eax', 00H
$SG6837	DB	'jmp  %s', 00H
$SG6839	DB	'jmp  %s', 00H
$SG6842	DB	'cmp  ecx,ebx', 00H
	ORG $+3
$SG6844	DB	'cmp  rcx,rbx', 00H
	ORG $+3
$SG6845	DB	'jle  %s', 00H
$SG6846	DB	'pop', 09H, 'rdi', 00H
$SG6847	DB	'pop', 09H, 'rsi', 00H
$SG6848	DB	'pop', 09H, 'rbx', 00H
$SG6849	DB	'pop', 09H, 'rcx', 00H
$SG6850	DB	'pop', 09H, 'rdx', 00H
$SG6851	DB	'pop', 09H, 'rax', 00H
$SG6853	DB	'jmp  %s', 00H
$SG6855	DB	'jmp  %s', 00H
$SG6856	DB	'ALIGN %d', 00H
	ORG $+3
$SG6857	DB	'%s:', 00H
$SG6865	DB	' dd %s', 00H
	ORG $+1
$SG6871	DB	' dd %s', 00H
	ORG $+1
$SG6877	DB	' dd %s', 00H
	ORG $+1
$SG6887	DB	' dd %s', 00H
	ORG $+1
$SG6889	DB	' dd %s', 00H
	ORG $+1
$SG6890	DB	' dd %s', 00H
	ORG $+1
$SG6892	DB	' dd %s', 00H
	ORG $+1
$SG6894	DB	' dd %s', 00H
	ORG $+1
$SG6902	DB	' dq %s', 00H
	ORG $+1
$SG6908	DB	' dq %s', 00H
	ORG $+1
$SG6920	DB	' dq %s', 00H
	ORG $+1
$SG6922	DB	' dq %s', 00H
	ORG $+1
$SG6923	DB	' dq %s', 00H
	ORG $+1
$SG6925	DB	' dq %s', 00H
	ORG $+1
$SG6927	DB	' dq %s', 00H
	ORG $+1
$SG6928	DB	'%s:', 00H
$SG6938	DB	' db %d', 00H
	ORG $+1
$SG6940	DB	' db %d', 00H
	ORG $+1
$SG6951	DB	' db %d', 00H
	ORG $+1
$SG6953	DB	' db %d', 00H
	ORG $+1
$SG6964	DB	' dw %d', 00H
	ORG $+1
$SG6966	DB	' dw %d', 00H
	ORG $+1
$SG6977	DB	' dw %d', 00H
	ORG $+1
$SG6979	DB	' dw %d', 00H
	ORG $+1
$SG6986	DB	' dd %d', 00H
	ORG $+1
$SG6991	DB	' dq %q', 00H
	ORG $+1
$SG6997	DB	'%s:', 00H
$SG7003	DB	'%s:', 00H
$SG7005	DB	'%s:', 00H
$SG7007	DB	' jmp %s', 00H
$SG7009	DB	' jmp %s', 00H
$SG7013	DB	'%s:', 00H
$SG7017	DB	'%s:', 00H
$SG7023	DB	'loop %s', 00H
$SG7027	DB	'%s:', 00H
$SG7031	DB	'%s:', 00H
$SG7065	DB	'jmp %s', 00H
	ORG $+1
$SG7067	DB	'%s:', 00H
$SG7073	DB	'jmp %s', 00H
	ORG $+1
$SG7078	DB	'%s:', 00H
$SG7118	DB	'jmp %s', 00H
	ORG $+1
$SG7120	DB	'%s:', 00H
$SG7142	DB	'jmp %s', 00H
	ORG $+5
$SG7150	DB	'.if-.repeat-.while', 00H
_DATA	ENDS
PUBLIC	GetHllLabel
EXTRN	ModuleInfo:BYTE
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\hll.c
_TEXT	SEGMENT
GetHllLabel PROC NEAR

; 180  :   return (++ModuleInfo.hll_label);

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax

; 181  : }

	ret	0
GetHllLabel ENDP
_TEXT	ENDS
EXTRN	_memicmp:NEAR
xdata	SEGMENT
$unwind$GetCOp DD 030c01H
	DD	08340cH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$GetCOp DD @imagerel(GetCOp#)
	DD	@imagerel(GetCOp#+281)
	DD	@imagerel($unwind$GetCOp#)
pdata	ENDS
xdata	SEGMENT
$chain$1$GetCOp DD 020521H
	DD	097405H
	DD	@imagerel(GetCOp#)
	DD	@imagerel(GetCOp#+281)
	DD	@imagerel($unwind$GetCOp#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$GetCOp DD @imagerel(GetCOp#+281)
	DD	@imagerel(GetCOp#+325)
	DD	@imagerel($chain$1$GetCOp#)
pdata	ENDS
xdata	SEGMENT
$chain$2$GetCOp DD 021H
	DD	@imagerel(GetCOp#)
	DD	@imagerel(GetCOp#+281)
	DD	@imagerel($unwind$GetCOp#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$GetCOp DD @imagerel(GetCOp#+325)
	DD	@imagerel(GetCOp#+776)
	DD	@imagerel($chain$2$GetCOp#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
item$ = 48
GetCOp	PROC NEAR

; 200  : {

	sub	rsp, 40					; 00000028H

; 201  :   int size;
; 202  :   enum c_bop rc;
; 203  :   char *p = item->string_ptr;
; 204  : 
; 205  :   size = (item->token == T_STRING ? item->stringlen : 0);

	movzx	eax, BYTE PTR [rcx]
	mov	QWORD PTR [rsp+64], rbx
	mov	rbx, QWORD PTR [rcx+8]
	cmp	al, 9
	jne	$LN31@GetCOp
	mov	edx, DWORD PTR [rcx+16]

; 206  : 
; 207  :   if (size == 2) {

	cmp	edx, 2
	jne	$LN42@GetCOp

; 208  :     switch (*(uint_16 *)p) {

	movzx	ecx, WORD PTR [rbx]
	cmp	ecx, 15677				; 00003d3dH
	jg	SHORT $LN47@GetCOp
	cmp	ecx, 15677				; 00003d3dH
	je	SHORT $LN39@GetCOp
	sub	ecx, 9766				; 00002626H
	je	SHORT $LN35@GetCOp
	sub	ecx, 5883				; 000016fbH
	je	SHORT $LN38@GetCOp
	cmp	ecx, 27
	jne	$LN2@GetCOp

; 212  :     case CHARS_LE:  rc = COP_LE;  break;

	lea	eax, QWORD PTR [rdx+4]
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN38@GetCOp:

; 210  :     case CHARS_NE:  rc = COP_NE;  break;

	mov	eax, 2
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN35@GetCOp:

; 213  :     case CHARS_AND: rc = COP_AND; break;

	mov	eax, 7
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN39@GetCOp:

; 209  :     case CHARS_EQ:  rc = COP_EQ;  break;

	mov	eax, 1
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN47@GetCOp:

; 208  :     switch (*(uint_16 *)p) {

	cmp	ecx, 15678				; 00003d3eH
	je	SHORT $LN37@GetCOp
	cmp	ecx, 31868				; 00007c7cH

; 215  :     default: return(COP_NONE);

	jne	$LN2@GetCOp

; 214  :     case CHARS_OR:  rc = COP_OR;  break;

	mov	eax, 8
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN37@GetCOp:

; 211  :     case CHARS_GE:  rc = COP_GE;  break;

	mov	eax, 5
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN42@GetCOp:

; 216  :     }
; 217  :   }
; 218  :   else if (size == 1) {

	cmp	edx, 1
	jne	SHORT $LN31@GetCOp

; 219  :     switch (*p) {

	mov	al, BYTE PTR [rbx]
	cmp	al, 33					; 00000021H
	je	SHORT $LN25@GetCOp
	cmp	al, 38					; 00000026H
	je	SHORT $LN26@GetCOp
	cmp	al, 60					; 0000003cH
	je	SHORT $LN27@GetCOp
	cmp	al, 62					; 0000003eH

; 224  :     default: return(COP_NONE);

	jne	$LN2@GetCOp

; 220  :     case '>': rc = COP_GT;   break;

	lea	eax, QWORD PTR [rdx+2]
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN27@GetCOp:

; 221  :     case '<': rc = COP_LT;   break;

	mov	eax, 4
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN26@GetCOp:

; 222  :     case '&': rc = COP_ANDB; break;

	mov	eax, 9
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN25@GetCOp:

; 223  :     case '!': rc = COP_NEG;  break;

	mov	eax, 10
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN31@GetCOp:

; 225  :     }
; 226  :   }
; 227  :   else {
; 228  :     if (item->token != T_ID)

	cmp	al, 8

; 229  :       return(COP_NONE);

	jne	$LN2@GetCOp
	mov	QWORD PTR [rsp+72], rdi

; 230  :     /* a valid "flag" string must end with a question mark */
; 231  :     size = strlen(p);

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	mov	rdi, QWORD PTR [rsp+72]
	not	rcx
	dec	rcx

; 232  :     if (*(p + size - 1) != '?')

	movsxd	rax, ecx
	cmp	BYTE PTR [rax+rbx-1], 63		; 0000003fH

; 233  :       return(COP_NONE);

	jne	$LN2@GetCOp

; 234  :     if (size == 5 && (0 == _memicmp(p, "ZERO", 4)))

	cmp	ecx, 5
	jne	SHORT $LN20@GetCOp
	lea	r8d, QWORD PTR [rcx-1]
	lea	rdx, OFFSET FLAT:$SG5645
	mov	rcx, rbx
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN48@GetCOp

; 235  :       rc = COP_ZERO;

	mov	eax, 11
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN20@GetCOp:

; 236  :     else if (size == 6 && (0 == _memicmp(p, "CARRY", 5)))

	cmp	ecx, 6
	jne	SHORT $LN16@GetCOp
	lea	r8d, QWORD PTR [rcx-1]
	lea	rdx, OFFSET FLAT:$SG5648
	mov	rcx, rbx
	call	_memicmp
	test	eax, eax
	jne	$LN49@GetCOp

; 237  :       rc = COP_CARRY;

	mov	eax, 12
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN48@GetCOp:

; 238  :     else if (size == 5 && (0 == _memicmp(p, "SIGN", 4)))

	lea	rdx, OFFSET FLAT:$SG5651
	mov	r8d, 4
	mov	rcx, rbx
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN50@GetCOp

; 239  :       rc = COP_SIGN;

	mov	eax, 13
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN16@GetCOp:

; 240  :     else if (size == 7 && (0 == _memicmp(p, "PARITY", 6)))

	cmp	ecx, 7
	jne	SHORT $LN14@GetCOp
	lea	r8d, QWORD PTR [rcx-1]
	lea	rdx, OFFSET FLAT:$SG5654
	mov	rcx, rbx
	call	_memicmp
	test	eax, eax
	jne	$LN2@GetCOp

; 241  :       rc = COP_PARITY;

	mov	eax, 14
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN14@GetCOp:

; 242  :     else if (size == 9 && (0 == _memicmp(p, "OVERFLOW", 8)))

	cmp	ecx, 9
	jne	SHORT $LN10@GetCOp
	lea	r8d, QWORD PTR [rcx-1]
	lea	rdx, OFFSET FLAT:$SG5657
	mov	rcx, rbx
	call	_memicmp
	test	eax, eax
	jne	$LN2@GetCOp

; 243  :       rc = COP_OVERFLOW;

	mov	eax, 15
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN50@GetCOp:

; 244  :     //added by habran
; 245  :     else if (size == 5 && (0 == _memicmp(p, "LESS", 4)))

	lea	rdx, OFFSET FLAT:$SG5660
	mov	r8d, 4
	mov	rcx, rbx
	call	_memicmp
	test	eax, eax
	jne	$LN2@GetCOp

; 246  :       rc = COP_LESS;

	mov	eax, 16
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN10@GetCOp:

; 247  :     else if (size == 8 && (0 == _memicmp(p, "GREATER", 7)))

	cmp	ecx, 8
	jne	$LN2@GetCOp
	lea	r8d, QWORD PTR [rcx-1]
	lea	rdx, OFFSET FLAT:$SG5663
	mov	rcx, rbx
	call	_memicmp
	test	eax, eax
	jne	$LN2@GetCOp

; 248  :       rc = COP_GREATER;

	mov	eax, 17
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN49@GetCOp:

; 249  :     else if (size == 6 && (0 == _memicmp(p, "ABOVE", 5)))

	lea	rdx, OFFSET FLAT:$SG5666
	mov	r8d, 5
	mov	rcx, rbx
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN51@GetCOp

; 250  :       rc = COP_ABOVE;

	mov	eax, 18
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN51@GetCOp:

; 251  :     else if (size == 6 && (0 == _memicmp(p, "EQUAL", 5)))

	lea	rdx, OFFSET FLAT:$SG5669
	mov	r8d, 5
	mov	rcx, rbx
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN52@GetCOp

; 252  :       rc = COP_EQUAL;

	mov	eax, 19
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN52@GetCOp:

; 253  :     else if (size == 6 && (0 == _memicmp(p, "BELOW", 5)))

	lea	rdx, OFFSET FLAT:$SG5672
	mov	r8d, 5
	mov	rcx, rbx
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN2@GetCOp

; 254  :       rc = COP_BELOW;

	mov	eax, 20
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@GetCOp:

; 255  :     else
; 256  :       return(COP_NONE);

	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+64]

; 257  :   }
; 258  :   return(rc);
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
GetCOp	ENDP
_TEXT	ENDS
PUBLIC	hex2dec
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
src$ = 8
hex2dec	PROC NEAR

; 264  :   uint_32 a;
; 265  :   uint_32 b = 0;
; 266  :   for (;;)
; 267  :   {
; 268  :     a = *src;

	movsx	eax, BYTE PTR [rcx]
	xor	edx, edx
	mov	r9, rcx

; 269  :     if (!a) break;

	test	eax, eax
	je	SHORT $LN13@hex2dec
	npad	4
$LL6@hex2dec:

; 270  :     b = (b << 4);
; 271  :     if (a >= '0' && a <= '9') a -= '0';

	lea	r8d, DWORD PTR [rax-48]
	shl	edx, 4
	cmp	r8d, 9
	ja	SHORT $LN3@hex2dec
	mov	eax, r8d

; 272  :     else {

	jmp	SHORT $LN1@hex2dec
$LN3@hex2dec:

; 273  :       a |= 0x20;

	or	eax, 32					; 00000020H

; 274  :       if (a >= 'a' && a <= 'f') a -= 'a' - 10;

	lea	ecx, DWORD PTR [rax-97]
	cmp	ecx, 5
	ja	SHORT $LN1@hex2dec
	add	eax, -87				; ffffffa9H
$LN1@hex2dec:

; 275  :     }
; 276  :     b = b + a;
; 277  :     src++;

	inc	r9
	add	edx, eax
	movsx	eax, BYTE PTR [r9]
	test	eax, eax
	jne	SHORT $LL6@hex2dec
$LN13@hex2dec:

; 278  :   }
; 279  :   return (b);

	mov	eax, edx

; 280  : }

	ret	0
hex2dec	ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$bubblesort DD 040d01H
	DD	03640dH
	DD	025408H
xdata	ENDS
pdata	SEGMENT
$pdata$bubblesort DD @imagerel(bubblesort#)
	DD	@imagerel(bubblesort#+24)
	DD	@imagerel($unwind$bubblesort#)
pdata	ENDS
xdata	SEGMENT
$chain$3$bubblesort DD 040a21H
	DD	04740aH
	DD	013405H
	DD	@imagerel(bubblesort#)
	DD	@imagerel(bubblesort#+24)
	DD	@imagerel($unwind$bubblesort#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$bubblesort DD @imagerel(bubblesort#+24)
	DD	@imagerel(bubblesort#+130)
	DD	@imagerel($chain$3$bubblesort#)
pdata	ENDS
xdata	SEGMENT
$chain$4$bubblesort DD 021H
	DD	@imagerel(bubblesort#)
	DD	@imagerel(bubblesort#+24)
	DD	@imagerel($unwind$bubblesort#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$bubblesort DD @imagerel(bubblesort#+130)
	DD	@imagerel(bubblesort#+161)
	DD	@imagerel($chain$4$bubblesort#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
hll$ = 8
lbl$ = 16
src$ = 24
n$ = 32
bubblesort PROC NEAR

; 283  :   /*******************************************************************************************************************************/
; 284  :   int i;
; 285  :   int j;
; 286  :   int temp1;
; 287  :   uint_16 temp2;
; 288  : 
; 289  :   for (i = 0; i < n; ++i)

	test	r9d, r9d
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	rsi, rdx
	mov	rbp, rcx

; 290  :   {
; 291  :     for (j = i + 1; j < n; ++j)

	movsxd	r10, r9d
	jle	SHORT $LN5@bubblesort
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], rdi
	mov	r11d, 1
	mov	rdi, r10
	mov	rbx, rdx
	mov	r9, r8
$LL7@bubblesort:
	cmp	r11, r10
	mov	rdx, r11
	jge	SHORT $LN6@bubblesort
	npad	7
$LL4@bubblesort:

; 292  :     {
; 293  :       if (src[i] > src[j])

	mov	ecx, DWORD PTR [r9]
	mov	eax, DWORD PTR [r8+rdx*4]
	cmp	ecx, eax
	jle	SHORT $LN3@bubblesort

; 294  :       {
; 295  :         temp1 = src[i];
; 296  :         src[i] = src[j];

	mov	DWORD PTR [r9], eax

; 297  :         src[j] = temp1;

	mov	DWORD PTR [r8+rdx*4], ecx

; 298  :         temp2 = lbl[i];
; 299  :         lbl[i] = lbl[j];

	movzx	eax, WORD PTR [rsi+rdx*2]
	movzx	ecx, WORD PTR [rbx]
	mov	WORD PTR [rbx], ax

; 300  :         lbl[j] = temp2;

	mov	WORD PTR [rsi+rdx*2], cx
$LN3@bubblesort:
	inc	rdx
	cmp	rdx, r10
	jl	SHORT $LL4@bubblesort
$LN6@bubblesort:

; 283  :   /*******************************************************************************************************************************/
; 284  :   int i;
; 285  :   int j;
; 286  :   int temp1;
; 287  :   uint_16 temp2;
; 288  : 
; 289  :   for (i = 0; i < n; ++i)

	inc	r11
	add	r9, 4
	add	rbx, 2
	dec	rdi
	jne	SHORT $LL7@bubblesort
	mov	rdi, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+8]
$LN5@bubblesort:

; 301  :       }
; 302  :     }
; 303  :   }
; 304  : 
; 305  :   hll->mincase = src[0];

	mov	eax, DWORD PTR [r8]
	mov	rsi, QWORD PTR [rsp+24]
	mov	DWORD PTR [rbp+92], eax

; 306  :   hll->maxcase = src[n - 1];

	mov	eax, DWORD PTR [r8+r10*4-4]
	mov	DWORD PTR [rbp+88], eax

; 307  :   hll->delta = hll->maxcase - hll->mincase;

	sub	eax, DWORD PTR [rbp+92]
	mov	DWORD PTR [rbp+96], eax
	mov	rbp, QWORD PTR [rsp+16]

; 308  : }

	ret	0
bubblesort ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$bubblesort64 DD 040d01H
	DD	03640dH
	DD	025408H
xdata	ENDS
pdata	SEGMENT
$pdata$bubblesort64 DD @imagerel(bubblesort64#)
	DD	@imagerel(bubblesort64#+24)
	DD	@imagerel($unwind$bubblesort64#)
pdata	ENDS
xdata	SEGMENT
$chain$3$bubblesort64 DD 040a21H
	DD	04740aH
	DD	013405H
	DD	@imagerel(bubblesort64#)
	DD	@imagerel(bubblesort64#+24)
	DD	@imagerel($unwind$bubblesort64#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$bubblesort64 DD @imagerel(bubblesort64#+24)
	DD	@imagerel(bubblesort64#+131)
	DD	@imagerel($chain$3$bubblesort64#)
pdata	ENDS
xdata	SEGMENT
$chain$4$bubblesort64 DD 021H
	DD	@imagerel(bubblesort64#)
	DD	@imagerel(bubblesort64#+24)
	DD	@imagerel($unwind$bubblesort64#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$bubblesort64 DD @imagerel(bubblesort64#+131)
	DD	@imagerel(bubblesort64#+178)
	DD	@imagerel($chain$4$bubblesort64#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
hll$ = 8
lbl$ = 16
src$ = 24
n$ = 32
bubblesort64 PROC NEAR

; 311  :   /*******************************************************************************************************************************/
; 312  :   int i;
; 313  :   int j;
; 314  :   int_64 temp1;
; 315  :   uint_16 temp2;
; 316  :   for (i = 0; i < n; ++i)

	test	r9d, r9d
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	rsi, rdx
	mov	rbp, rcx

; 317  :   {
; 318  :     for (j = i + 1; j < n; ++j)

	movsxd	r10, r9d
	jle	SHORT $LN5@bubblesort@2
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], rdi
	mov	r11d, 1
	mov	rdi, r10
	mov	rbx, rdx
	mov	r9, r8
$LL7@bubblesort@2:
	cmp	r11, r10
	mov	rdx, r11
	jge	SHORT $LN6@bubblesort@2
	npad	7
$LL4@bubblesort@2:

; 319  :     {
; 320  :       if (src[i] > src[j])

	mov	rcx, QWORD PTR [r9]
	mov	rax, QWORD PTR [r8+rdx*8]
	cmp	rcx, rax
	jle	SHORT $LN3@bubblesort@2

; 321  :       {
; 322  :         temp1 = src[i];
; 323  :         src[i] = src[j];

	mov	QWORD PTR [r9], rax

; 324  :         src[j] = temp1;

	mov	QWORD PTR [r8+rdx*8], rcx

; 325  :         temp2 = lbl[i];
; 326  :         lbl[i] = lbl[j];

	movzx	eax, WORD PTR [rsi+rdx*2]
	movzx	ecx, WORD PTR [rbx]
	mov	WORD PTR [rbx], ax

; 327  :         lbl[j] = temp2;

	mov	WORD PTR [rsi+rdx*2], cx
$LN3@bubblesort@2:
	inc	rdx
	cmp	rdx, r10
	jl	SHORT $LL4@bubblesort@2
$LN6@bubblesort@2:

; 311  :   /*******************************************************************************************************************************/
; 312  :   int i;
; 313  :   int j;
; 314  :   int_64 temp1;
; 315  :   uint_16 temp2;
; 316  :   for (i = 0; i < n; ++i)

	inc	r11
	add	r9, 8
	add	rbx, 2
	dec	rdi
	jne	SHORT $LL7@bubblesort@2
	mov	rdi, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+8]
$LN5@bubblesort@2:

; 328  :       }
; 329  :     }
; 330  :   }
; 331  : 
; 332  :   hll->mincase64 = src[0];

	mov	rax, QWORD PTR [r8]
	mov	rsi, QWORD PTR [rsp+24]
	mov	QWORD PTR [rbp+136], rax

; 333  :   hll->maxcase64 = src[n - 1];

	mov	rax, QWORD PTR [r8+r10*8-8]
	mov	QWORD PTR [rbp+128], rax

; 334  :   hll->delta64 = hll->maxcase64 - hll->mincase64;

	sub	rax, QWORD PTR [rbp+136]
	mov	QWORD PTR [rbp+144], rax
	mov	rbp, QWORD PTR [rsp+16]

; 335  : }

	ret	0
bubblesort64 ENDP
_TEXT	ENDS
EXTRN	sprintf:NEAR
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$RenderInstr DD 050e01H
	DD	07540eH
	DD	083409H
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$RenderInstr DD @imagerel(RenderInstr#)
	DD	@imagerel(RenderInstr#+17)
	DD	@imagerel($unwind$RenderInstr#)
pdata	ENDS
xdata	SEGMENT
$chain$3$RenderInstr DD 040a21H
	DD	05740aH
	DD	066405H
	DD	@imagerel(RenderInstr#)
	DD	@imagerel(RenderInstr#+17)
	DD	@imagerel($unwind$RenderInstr#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$RenderInstr DD @imagerel(RenderInstr#+17)
	DD	@imagerel(RenderInstr#+144)
	DD	@imagerel($chain$3$RenderInstr#)
pdata	ENDS
xdata	SEGMENT
$chain$4$RenderInstr DD 020021H
	DD	057400H
	DD	@imagerel(RenderInstr#)
	DD	@imagerel(RenderInstr#+17)
	DD	@imagerel($unwind$RenderInstr#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$RenderInstr DD @imagerel(RenderInstr#+144)
	DD	@imagerel(RenderInstr#+268)
	DD	@imagerel($chain$4$RenderInstr#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
dst$ = 80
instr$ = 88
start1$ = 96
end1$ = 104
start2$ = 112
end2$ = 120
tokenarray$ = 128
RenderInstr PROC NEAR

; 340  : {

	sub	rsp, 72					; 00000048H
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	rbp, rcx
	mov	QWORD PTR [rsp+48], rsi
	mov	QWORD PTR [rsp+40], rdi

; 341  :   int i;
; 342  : #ifdef DEBUG_OUT
; 343  :   char *old = dst;
; 344  : #endif
; 345  :   i = strlen(instr);

	xor	eax, eax
	mov	rdi, rdx
	movsxd	rbx, r8d
	mov	rcx, -1
	repne scasb
	movsxd	rsi, r9d
	not	rcx
	dec	rcx

; 346  :   /* copy the instruction */
; 347  :   memcpy(dst, instr, i);

	movsxd	rdi, ecx
	mov	rcx, rbp
	mov	r8, rdi
	call	memcpy

; 348  :   dst += i;

	add	rbp, rdi

; 349  :   /* copy the first operand's tokens */
; 350  :   *dst++ = ' ';
; 351  :   i = tokenarray[end1].tokpos - tokenarray[start1].tokpos;

	mov	rdx, rbx
	mov	rbx, QWORD PTR tokenarray$[rsp]
	mov	BYTE PTR [rbp], 32			; 00000020H
	shl	rdx, 5
	mov	rax, rsi
	inc	rbp
	shl	rax, 5
	mov	ecx, DWORD PTR [rax+rbx+24]
	sub	ecx, DWORD PTR [rdx+rbx+24]

; 352  :   memcpy(dst, tokenarray[start1].tokpos, i);

	mov	rdx, QWORD PTR [rdx+rbx+24]
	movsxd	rdi, ecx
	mov	rcx, rbp
	mov	r8, rdi
	call	memcpy

; 353  :   dst += i;
; 354  :   if (start2 != EMPTY) {

	movsxd	rax, DWORD PTR start2$[rsp]
	mov	rsi, QWORD PTR [rsp+48]
	add	rbp, rdi
	cmp	eax, -2
	je	SHORT $LN3@RenderInst

; 355  :     *dst++ = ',';

	mov	BYTE PTR [rbp], 44			; 0000002cH

; 356  :     /* copy the second operand's tokens */
; 357  :     *dst++ = ' ';

	mov	BYTE PTR [rbp+1], 32			; 00000020H

; 358  :     i = tokenarray[end2].tokpos - tokenarray[start2].tokpos;

	mov	rdx, rax
	movsxd	rax, DWORD PTR end2$[rsp]
	shl	rdx, 5
	add	rbp, 2
	shl	rax, 5
	mov	ecx, DWORD PTR [rax+rbx+24]
	sub	ecx, DWORD PTR [rdx+rbx+24]

; 359  :     memcpy(dst, tokenarray[start2].tokpos, i);

	mov	rdx, QWORD PTR [rdx+rbx+24]
	movsxd	rdi, ecx
	mov	rcx, rbp
	mov	r8, rdi
	call	memcpy

; 360  :     dst += i;

	add	rbp, rdi
	jmp	SHORT $LN1@RenderInst
$LN3@RenderInst:

; 361  :   }
; 362  :   else if (end2 != EMPTY) {

	mov	r8d, DWORD PTR end2$[rsp]
	cmp	r8d, -2
	je	SHORT $LN1@RenderInst

; 363  :     dst += sprintf(dst, ", %d", end2);

	lea	rdx, OFFSET FLAT:$SG5749
	mov	rcx, rbp
	call	sprintf
	movsxd	rcx, eax
	add	rbp, rcx
$LN1@RenderInst:
	mov	rdi, QWORD PTR [rsp+40]
	mov	rbx, QWORD PTR [rsp+64]

; 364  :   }
; 365  :   *dst++ = EOLCHAR;

	mov	BYTE PTR [rbp], 10

; 366  :   *dst = NULLC;

	mov	BYTE PTR [rbp+1], 0

; 367  :   DebugMsg1(("%u RenderInstr(%s)=>%s<\n", evallvl, instr, old));
; 368  :   return(dst);

	lea	rax, QWORD PTR [rbp+1]
	mov	rbp, QWORD PTR [rsp+56]

; 369  : }

	add	rsp, 72					; 00000048H
	ret	0
RenderInstr ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$GetLabelStr DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$GetLabelStr DD @imagerel(GetLabelStr#)
	DD	@imagerel(GetLabelStr#+36)
	DD	@imagerel($unwind$GetLabelStr#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
label$ = 48
buff$ = 56
GetLabelStr PROC NEAR

; 373  : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 374  :   sprintf(buff, LABELFMT, label);

	mov	r8d, ecx
	lea	rdx, OFFSET FLAT:$SG5756
	mov	rcx, rbx
	call	sprintf

; 375  :   return(buff);

	mov	rax, rbx

; 376  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
GetLabelStr ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$RenderJcc DD 053e01H
	DD	09743eH
	DD	08340cH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$RenderJcc DD @imagerel(RenderJcc#)
	DD	@imagerel(RenderJcc#+116)
	DD	@imagerel($unwind$RenderJcc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
dst$ = 48
cc$ = 56
neg$ = 64
label$ = 72
RenderJcc PROC NEAR

; 382  : {

	sub	rsp, 40					; 00000028H

; 383  : #ifdef DEBUG_OUT
; 384  :   char *old = dst;
; 385  : #endif
; 386  :   /* create the jump opcode: j[n]cc */
; 387  :   *dst++ = 'j';
; 388  :   if (neg)

	test	r8d, r8d
	mov	QWORD PTR [rsp+64], rbx
	mov	BYTE PTR [rcx], 106			; 0000006aH
	lea	rbx, QWORD PTR [rcx+1]
	je	SHORT $LN2@RenderJcc

; 389  :     *dst++ = 'n';

	mov	BYTE PTR [rbx], 110			; 0000006eH
	inc	rbx
$LN2@RenderJcc:

; 390  :   *dst++ = cc;

	mov	BYTE PTR [rbx], dl
	inc	rbx

; 391  :   if (neg == FALSE)

	test	r8d, r8d
	jne	SHORT $LN1@RenderJcc

; 392  :     *dst++ = ' '; /* make sure there's room for the inverse jmp */

	mov	BYTE PTR [rbx], 32			; 00000020H
	inc	rbx
$LN1@RenderJcc:

; 393  : 
; 394  :   *dst++ = ' ';
; 395  :   GetLabelStr(label, dst);

	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR [rbx+1]
	mov	r8d, r9d
	mov	QWORD PTR [rsp+72], rdi
	mov	BYTE PTR [rbx], 32			; 00000020H
	call	sprintf

; 396  :   dst += strlen(dst);

	xor	eax, eax
	lea	rdi, QWORD PTR [rbx+1]
	mov	rcx, -1
	repne scasb
	mov	rdi, QWORD PTR [rsp+72]
	not	rcx

; 397  :   *dst++ = EOLCHAR;

	mov	BYTE PTR [rbx+rcx], 10

; 398  :   *dst = NULLC;

	mov	BYTE PTR [rbx+rcx+1], al

; 399  :   DebugMsg1(("%u RenderJcc()=>%s<\n", evallvl, old));
; 400  :   return(dst);

	lea	rax, QWORD PTR [rbx+rcx+1]
	mov	rbx, QWORD PTR [rsp+64]

; 401  : }

	add	rsp, 40					; 00000028H
	ret	0
RenderJcc ENDP
_TEXT	ENDS
EXTRN	EmitError:NEAR
EXTRN	EvalOperand:NEAR
xdata	SEGMENT
$unwind$GetToken DD 092001H
	DD	077420H
	DD	08641bH
	DD	095410H
	DD	0a3409H
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$GetToken DD @imagerel(GetToken#)
	DD	@imagerel(GetToken#+160)
	DD	@imagerel($unwind$GetToken#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
hll$ = 96
i$ = 104
tokenarray$ = 112
opnd$ = 120
GetToken PROC NEAR

; 407  : {

	sub	rsp, 88					; 00000058H
	mov	QWORD PTR [rsp+80], rbx

; 408  :   int end_tok;
; 409  : 
; 410  :   /* scan for the next C operator in the token array.
; 411  :   * because the ASM evaluator may report an error if such a thing
; 412  :   * is found ( CARRY?, ZERO? and alikes will be regarded as - not yet defined - labels )
; 413  :   */
; 414  :   for (end_tok = *i; end_tok < Token_Count; end_tok++) {

	mov	ebx, DWORD PTR [rdx]
	mov	QWORD PTR [rsp+72], rbp
	cmp	ebx, DWORD PTR ModuleInfo+496
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+56], rdi
	mov	rbp, r9
	mov	rsi, r8
	mov	rdi, rdx
	jge	SHORT $LN13@GetToken
	npad	5
$LL7@GetToken:

; 415  :     if ((GetCOp(&tokenarray[end_tok])) != COP_NONE)

	movsxd	rcx, ebx
	shl	rcx, 5
	add	rcx, rsi
	call	GetCOp
	test	eax, eax
	jne	SHORT $LN13@GetToken
	inc	ebx
	cmp	ebx, DWORD PTR ModuleInfo+496
	jl	SHORT $LL7@GetToken
$LN13@GetToken:

; 416  :       break;
; 417  :   }
; 418  :   if (end_tok == *i) {

	cmp	ebx, DWORD PTR [rdi]
	jne	SHORT $LN3@GetToken

; 419  :     opnd->kind = EXPR_EMPTY;

	mov	DWORD PTR [rbp+60], -2
$LN1@GetToken:

; 430  :   }
; 431  : 
; 432  :   return(NOT_ERROR);

	xor	eax, eax
$LN8@GetToken:
	mov	rdi, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+80]

; 433  : }

	add	rsp, 88					; 00000058H
	ret	0
$LN3@GetToken:

; 420  :     return(NOT_ERROR);
; 421  :   }
; 422  :   if (ERROR == EvalOperand(i, tokenarray, end_tok, opnd, 0))

	mov	r9, rbp
	mov	r8d, ebx
	mov	rdx, rsi
	mov	rcx, rdi
	mov	BYTE PTR [rsp+32], 0
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN2@GetToken

; 423  :     return(ERROR);

	jmp	SHORT $LN8@GetToken
$LN2@GetToken:

; 424  : 
; 425  :   /* v2.11: emit error 'syntax error in control flow directive'.
; 426  :   * May happen for expressions like ".if 1 + CARRY?"
; 427  :   */
; 428  :   if (*i > end_tok) {

	cmp	DWORD PTR [rdi], ebx
	jle	SHORT $LN1@GetToken

; 429  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	mov	ecx, 199				; 000000c7H
	call	EmitError
	jmp	SHORT $LN8@GetToken
GetToken ENDP
; Function compile flags: /Ogtpy
hll$ = 8
index$ = 16
GetLabel PROC NEAR

; 438  :   /**/myassert(hll->labels[index]);
; 439  :   return(hll->labels[index]);

	movsxd	rax, edx
	mov	eax, DWORD PTR [rcx+rax*4+8]

; 440  : }

	ret	0
GetLabel ENDP
_TEXT	ENDS
EXTRN	Options:BYTE
EXTRN	EmitConstError:NEAR
EXTRN	__ImageBase:BYTE
xdata	SEGMENT
$unwind$GetSimpleExpression DD 012ad01H
	DD	028c4adH
	DD	02b54a5H
	DD	025f42cH
	DD	026e428H
	DD	027d424H
	DD	0297420H
	DD	02a641cH
	DD	02c3418H
	DD	02d0114H
xdata	ENDS
pdata	SEGMENT
$pdata$GetSimpleExpression DD @imagerel(GetSimpleExpression#)
	DD	@imagerel(GetSimpleExpression#+1853)
	DD	@imagerel($unwind$GetSimpleExpression#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
op1$ = 64
op2$ = 176
hll$ = 368
label$1$ = 376
i$ = 376
op2_pos$1$ = 384
tokenarray$ = 384
ilabel$ = 392
is_true$ = 400
buffer$ = 408
hllop$ = 416
GetSimpleExpression PROC NEAR

; 450  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, rsp
	sub	rsp, 360				; 00000168H
	mov	QWORD PTR [rax-8], rbx
	mov	QWORD PTR [rax-24], rsi
	mov	QWORD PTR [rax-32], rdi
	mov	QWORD PTR [rax-48], r13
	mov	QWORD PTR [rax-56], r14
	mov	QWORD PTR [rax-64], r15

; 451  :   enum c_bop op;
; 452  :   char instr;
; 453  :   int op1_pos;
; 454  :   int op1_end;
; 455  :   int op2_pos;
; 456  :   int op2_end;
; 457  :   char *p;
; 458  :   struct expr op1;
; 459  :   struct expr op2;
; 460  :   uint_32 label;
; 461  : 
; 462  :   DebugMsg1(("%u GetSimpleExpression(>%.32s< buf=>%s<) enter\n", evallvl, tokenarray[*i].tokpos, buffer));
; 463  : 
; 464  :   while (tokenarray[*i].string_ptr[0] == '!' && tokenarray[*i].string_ptr[1] == '\0') {

	movsxd	rax, DWORD PTR [rdx]
	mov	r14d, r9d
	mov	rsi, r8
	shl	rax, 5
	mov	rdi, rdx
	mov	r15, rcx
	mov	rax, QWORD PTR [rax+r8+8]
	mov	ebx, 1
	cmp	BYTE PTR [rax], 33			; 00000021H
	jne	SHORT $LN143@GetSimpleE
	movzx	r13d, BYTE PTR is_true$[rsp]
	npad	9
$LL50@GetSimpleE:
	movsxd	rdx, DWORD PTR [rdi]
	mov	rax, rdx
	shl	rax, 5
	mov	rax, QWORD PTR [rax+r8+8]
	cmp	BYTE PTR [rax+1], 0
	jne	SHORT $LN49@GetSimpleE

; 465  :     (*i)++; //GetCOp( i );

	lea	eax, DWORD PTR [rdx+1]
	mov	DWORD PTR [rdi], eax

; 466  :     is_true = 1 - is_true;

	mov	eax, ebx
	sub	al, r13b
	mov	r13b, al
	movsxd	rax, DWORD PTR [rdi]
	shl	rax, 5
	mov	rax, QWORD PTR [rax+r8+8]
	cmp	BYTE PTR [rax], 33			; 00000021H
	je	SHORT $LL50@GetSimpleE

; 451  :   enum c_bop op;
; 452  :   char instr;
; 453  :   int op1_pos;
; 454  :   int op1_end;
; 455  :   int op2_pos;
; 456  :   int op2_end;
; 457  :   char *p;
; 458  :   struct expr op1;
; 459  :   struct expr op2;
; 460  :   uint_32 label;
; 461  : 
; 462  :   DebugMsg1(("%u GetSimpleExpression(>%.32s< buf=>%s<) enter\n", evallvl, tokenarray[*i].tokpos, buffer));
; 463  : 
; 464  :   while (tokenarray[*i].string_ptr[0] == '!' && tokenarray[*i].string_ptr[1] == '\0') {

	jmp	SHORT $LN49@GetSimpleE
$LN143@GetSimpleE:
	mov	r13b, BYTE PTR is_true$[rsp]
$LN49@GetSimpleE:
	mov	QWORD PTR [rsp+344], rbp
	mov	QWORD PTR [rsp+320], r12

; 467  :   }
; 468  : 
; 469  :   /* the problem with '()' is that is might enclose just a standard Masm
; 470  :   * expression or a "hll" expression. The first case is to be handled
; 471  :   * entirely by the expression evaluator, while the latter case is to be
; 472  :   * handled HERE!
; 473  :   */
; 474  :   if (tokenarray[*i].token == T_OP_BRACKET) {

	movsxd	r12, DWORD PTR [rdi]
	mov	rax, r12
	shl	rax, 5
	cmp	BYTE PTR [rax+r8], 40			; 00000028H
	jne	SHORT $LN38@GetSimpleE

; 475  :     int brcnt;
; 476  :     int j;
; 477  :     for (brcnt = 1, j = *i + 1; tokenarray[j].token != T_FINAL; j++) {

	inc	r12d
	movsxd	rcx, r12d
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+r8], 0
	je	$LN137@GetSimpleE
	shl	rcx, 5
	lea	rax, QWORD PTR [rcx+r8]
	mov	rbp, rax
$LL47@GetSimpleE:

; 478  :       if (tokenarray[j].token == T_OP_BRACKET)

	movzx	eax, BYTE PTR [rax]
	cmp	al, 40					; 00000028H
	jne	SHORT $LN44@GetSimpleE

; 479  :         brcnt++;

	inc	ebx
	jmp	SHORT $LN46@GetSimpleE
$LN44@GetSimpleE:

; 480  :       else if (tokenarray[j].token == T_CL_BRACKET) {

	cmp	al, 41					; 00000029H
	jne	SHORT $LN42@GetSimpleE

; 481  :         brcnt--;

	dec	ebx

; 482  :         if (brcnt == 0) /* a standard Masm expression? */

	jne	SHORT $LN46@GetSimpleE
$LN38@GetSimpleE:

; 501  :     }
; 502  :   }
; 503  : 
; 504  :   /* get (first) operand */
; 505  :   op1_pos = *i;

	movsxd	r12, DWORD PTR [rdi]

; 506  :   if (ERROR == GetToken(hll, i, tokenarray, &op1))

	cmp	r12d, DWORD PTR ModuleInfo+496
	mov	ebx, r12d
	jge	SHORT $LN144@GetSimpleE
	npad	13
$LL100@GetSimpleE:
	movsxd	rcx, ebx
	shl	rcx, 5
	add	rcx, rsi
	call	GetCOp
	test	eax, eax
	jne	SHORT $LN144@GetSimpleE
	inc	ebx
	cmp	ebx, DWORD PTR ModuleInfo+496
	jl	SHORT $LL100@GetSimpleE
$LN144@GetSimpleE:
	cmp	ebx, DWORD PTR [rdi]
	jne	$LN96@GetSimpleE
	mov	DWORD PTR op1$[rsp+60], -2
	jmp	$LN35@GetSimpleE
$LN42@GetSimpleE:

; 483  :           break;
; 484  :       }
; 485  :       else if ((GetCOp(&tokenarray[j])) != COP_NONE)

	movsxd	rcx, r12d
	shl	rcx, 5
	add	rcx, rsi
	call	GetCOp
	test	eax, eax
	jne	SHORT $LN129@GetSimpleE
$LN46@GetSimpleE:

; 475  :     int brcnt;
; 476  :     int j;
; 477  :     for (brcnt = 1, j = *i + 1; tokenarray[j].token != T_FINAL; j++) {

	add	rbp, 32					; 00000020H
	inc	r12d
	cmp	BYTE PTR [rbp], 0
	mov	rax, rbp
	jne	$LL47@GetSimpleE
$LN129@GetSimpleE:

; 486  :         break;
; 487  :     }
; 488  :     if (brcnt) {

	test	ebx, ebx
	je	SHORT $LN38@GetSimpleE
$LN137@GetSimpleE:

; 489  :       (*i)++;
; 490  :       DebugMsg1(("%u GetSimpleExpression: calling GetExpression, i=%u\n", evallvl, *i));
; 491  :       if (ERROR == GetExpression(hll, i, tokenarray, ilabel, is_true, buffer, hllop))

	mov	rax, QWORD PTR hllop$[rsp]
	inc	DWORD PTR [rdi]
	mov	r9d, r14d
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR buffer$[rsp]
	mov	r8, rsi
	mov	QWORD PTR [rsp+40], rax
	mov	rdx, rdi
	mov	rcx, r15
	mov	BYTE PTR [rsp+32], r13b
	call	GetExpression
	cmp	eax, -1

; 492  :         return(ERROR);

	je	$LN142@GetSimpleE

; 493  : 
; 494  :       if (tokenarray[*i].token != T_CL_BRACKET) {

	movsxd	rcx, DWORD PTR [rdi]
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 41			; 00000029H

; 495  :         //if (( tokenarray[*i].token == T_FINAL ) || ( tokenarray[*i].token == T_CL_BRACKET ))
; 496  :         DebugMsg(("GetSimpleExpression: expected ')', found: %s\n", tokenarray[*i].string_ptr));
; 497  :         return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	jne	$LN26@GetSimpleE

; 498  :       }
; 499  :       (*i)++;

	lea	eax, DWORD PTR [rcx+1]
	mov	DWORD PTR [rdi], eax

; 500  :       return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN51@GetSimpleE

; 506  :   if (ERROR == GetToken(hll, i, tokenarray, &op1))

$LN96@GetSimpleE:
	lea	r9, QWORD PTR op1$[rsp]
	mov	r8d, ebx
	mov	rdx, rsi
	mov	rcx, rdi
	mov	BYTE PTR [rsp+32], 0
	call	EvalOperand
	cmp	eax, -1
	je	$LN142@GetSimpleE
	cmp	DWORD PTR [rdi], ebx
	jle	SHORT $LN35@GetSimpleE
	mov	ecx, 199				; 000000c7H
	call	EmitError
	cmp	eax, -1

; 507  :     return (ERROR);

	je	$LN142@GetSimpleE
$LN35@GetSimpleE:

; 508  :   op1_end = *i;

	movsxd	r14, DWORD PTR [rdi]

; 509  : 
; 510  :   op = GetCOp(&tokenarray[*i]); /* get operator */

	mov	rcx, r14
	shl	rcx, 5
	add	rcx, rsi
	call	GetCOp

; 511  : 
; 512  :                                 /* lower precedence operator ( && or || ) detected? */
; 513  :   if (op == COP_AND || op == COP_OR) {

	xor	r15d, r15d
	cmp	eax, 7
	mov	ebp, eax
	je	SHORT $LN33@GetSimpleE
	cmp	eax, 8
	je	SHORT $LN33@GetSimpleE

; 518  :   }
; 519  :   else if (op != COP_NONE)

	test	eax, eax
	je	SHORT $LN31@GetSimpleE

; 520  :     (*i)++;

	inc	DWORD PTR [rdi]
	jmp	SHORT $LN31@GetSimpleE
$LN33@GetSimpleE:

; 514  :     /* v2.11: next 2 lines removed - && and || operators need a valid first operand */
; 515  :     //if ( op1.kind == EXPR_EMPTY )
; 516  :     //    return( NOT_ERROR );
; 517  :     op = COP_NONE;

	mov	ebp, r15d
$LN31@GetSimpleE:

; 521  : 
; 522  :   label = GetLabel(hll, ilabel);
; 523  : 
; 524  :   DebugMsg1(("%u GetSimpleExpression: EvalOperand ok, kind=%X, i=%u [%s]\n", evallvl, op1.kind, *i, tokenarray[*i].tokpos));
; 525  : 
; 526  :   /* check for special operators with implicite operand:
; 527  :   * COP_ZERO, COP_CARRY, COP_SIGN, COP_PARITY, COP_OVERFLOW
; 528  :   */
; 529  :   if (op >= COP_ZERO) {

	cmp	ebp, 11
	movsxd	rax, DWORD PTR ilabel$[rsp]
	mov	rcx, QWORD PTR hll$[rsp]
	mov	r8d, DWORD PTR [rcx+rax*4+8]
	mov	DWORD PTR label$1$[rsp], r8d
	jl	$LN30@GetSimpleE

; 530  :     if (op1.kind != EXPR_EMPTY) {

	cmp	DWORD PTR op1$[rsp+60], -2

; 531  :       DebugMsg(("GetSimpleExpression: non-empty expression rejected: %s\n", tokenarray[op1_pos].tokpos));
; 532  :       return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	jne	$LN26@GetSimpleE

; 533  :     }
; 534  :     p = buffer;
; 535  :     hllop->lastjmp = p;

	mov	rcx, QWORD PTR buffer$[rsp]
	mov	rax, QWORD PTR hllop$[rsp]

; 536  :     RenderJcc(p, flaginstr[op - COP_ZERO], !is_true, label);

	test	r13b, r13b
	mov	QWORD PTR [rax], rcx
	lea	rdx, OFFSET FLAT:__ImageBase
	movsxd	rax, ebp
	movzx	edx, BYTE PTR flaginstr[rax+rdx-11]
	sete	r15b
	lea	rbx, QWORD PTR [rcx+1]
	test	r15d, r15d
	mov	BYTE PTR [rcx], 106			; 0000006aH
	je	SHORT $LN106@GetSimpleE
	mov	BYTE PTR [rbx], 110			; 0000006eH
	inc	rbx
$LN106@GetSimpleE:
	mov	BYTE PTR [rbx], dl
	inc	rbx
	test	r15d, r15d
	jne	SHORT $LN105@GetSimpleE
	mov	BYTE PTR [rbx], 32			; 00000020H
	inc	rbx
$LN105@GetSimpleE:
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR [rbx+1]
	mov	BYTE PTR [rbx], 32			; 00000020H
	call	sprintf
	xor	eax, eax
	lea	rdi, QWORD PTR [rbx+1]
	mov	rcx, -1
	repne scasb
	not	rcx
	mov	BYTE PTR [rbx+rcx], 10
	mov	BYTE PTR [rbx+rcx+1], al

; 537  :     return(NOT_ERROR);

	jmp	$LN51@GetSimpleE
$LN30@GetSimpleE:

; 538  :   }
; 539  : 
; 540  :   switch (op1.kind) {

	mov	ecx, DWORD PTR op1$[rsp+60]
	cmp	ecx, -2
	je	$LN26@GetSimpleE
	cmp	ecx, 3
	je	$LN25@GetSimpleE

; 547  :   }
; 548  : 
; 549  :   if (op == COP_NONE){

	test	ebp, ebp
	jne	$LN24@GetSimpleE

; 550  :     switch (op1.kind) {

	test	ecx, ecx
	je	$LN18@GetSimpleE
	dec	ecx
	je	SHORT $LN20@GetSimpleE
	dec	ecx
	jne	$LN13@GetSimpleE

; 551  :     case EXPR_REG:
; 552  :       if (op1.indirect == FALSE) {

	test	BYTE PTR op1$[rsp+72], 1
	jne	SHORT $LN20@GetSimpleE

; 553  :         p = RenderInstr(buffer, "test", op1_pos, op1_end, op1_pos, op1_end, tokenarray);

	mov	rcx, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+48], rsi
	lea	rdx, OFFSET FLAT:$SG5858
	mov	r9d, r14d
	mov	r8d, r12d
	mov	DWORD PTR [rsp+40], r14d
	mov	DWORD PTR [rsp+32], r12d
	call	RenderInstr

; 554  :         hllop->lastjmp = p;

	mov	rcx, QWORD PTR hllop$[rsp]

; 555  :         RenderJcc(p, 'z', is_true, label);

	mov	r9d, DWORD PTR label$1$[rsp]
	mov	QWORD PTR [rcx], rax
	movzx	r8d, r13b
	mov	rcx, rax
	mov	dl, 122					; 0000007aH
	call	RenderJcc

; 584  :       }
; 585  :       break;
; 586  : #ifdef DEBUG_OUT
; 587  :     default: /**/myassert(0); break;
; 588  : #endif
; 589  :     }
; 590  :     return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN51@GetSimpleE
$LN20@GetSimpleE:

; 556  :         break;
; 557  :       }
; 558  :       /* no break */
; 559  :     case EXPR_ADDR:
; 560  :       p = RenderInstr(buffer, "cmp", op1_pos, op1_end, EMPTY, 0, tokenarray);

	xor	eax, eax
	lea	rdi, OFFSET FLAT:$SG5860
	mov	rcx, -1
	repne scasb
	mov	rdi, QWORD PTR buffer$[rsp]
	lea	rdx, OFFSET FLAT:$SG5860
	not	rcx
	dec	rcx
	movsxd	rbx, ecx
	mov	rcx, rdi
	mov	r8, rbx
	call	memcpy
	add	rbx, rdi
	mov	rax, r14
	mov	BYTE PTR [rbx], 32			; 00000020H
	shl	rax, 5
	mov	rdx, r12
	mov	eax, DWORD PTR [rax+rsi+24]
	shl	rdx, 5
	inc	rbx
	sub	eax, DWORD PTR [rdx+rsi+24]
	mov	rdx, QWORD PTR [rdx+rsi+24]
	mov	rcx, rbx
	movsxd	rdi, eax
	mov	r8, rdi
	call	memcpy
	add	rbx, rdi
	lea	rdx, OFFSET FLAT:$SG5749
	mov	rcx, rbx
	xor	r8d, r8d
	call	sprintf

; 561  :       hllop->lastjmp = p;
; 562  :       RenderJcc(p, 'z', is_true, label);

	mov	r9d, DWORD PTR label$1$[rsp]
	movzx	r8d, r13b
	movsxd	rdx, eax
	mov	rax, QWORD PTR hllop$[rsp]
	add	rbx, rdx
	mov	dl, 122					; 0000007aH
	mov	BYTE PTR [rbx], 10
	inc	rbx
	mov	BYTE PTR [rbx], r15b
	mov	rcx, rbx
	mov	QWORD PTR [rax], rbx
	call	RenderJcc

; 584  :       }
; 585  :       break;
; 586  : #ifdef DEBUG_OUT
; 587  :     default: /**/myassert(0); break;
; 588  : #endif
; 589  :     }
; 590  :     return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN51@GetSimpleE
$LN18@GetSimpleE:

; 563  :       break;
; 564  :     case EXPR_CONST:
; 565  : #if 0
; 566  :       /* v2.05: string constant is allowed! */
; 567  :       if (op1.string != NULL) {
; 568  :         return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));
; 569  :       }
; 570  : #endif
; 571  :       /* v2.11: error if constant doesn't fit in 32-bits */
; 572  :       if (op1.hvalue != 0 && op1.hvalue != -1)

	mov	eax, DWORD PTR op1$[rsp+4]
	test	eax, eax
	je	SHORT $LN17@GetSimpleE
	cmp	eax, -1
	je	SHORT $LN17@GetSimpleE

; 573  :         return(EmitConstError(&op1));

	lea	rcx, QWORD PTR op1$[rsp]
	call	EmitConstError
	jmp	$LN51@GetSimpleE
$LN17@GetSimpleE:

; 574  : 
; 575  :       hllop->lastjmp = buffer;
; 576  : 
; 577  :       if ((is_true == TRUE && op1.value) ||
; 578  :         (is_true == FALSE && op1.value == 0)) {

	cmp	r13b, 1
	mov	rax, QWORD PTR hllop$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rax], rcx
	jne	SHORT $LN14@GetSimpleE
	cmp	DWORD PTR op1$[rsp], r15d
	jne	SHORT $LN15@GetSimpleE
$LN16@GetSimpleE:

; 580  :       }
; 581  :       else {
; 582  :         //strcpy( buffer, " " EOLSTR ); /* v2.11: obsolete */
; 583  :         *buffer = NULLC;

	mov	BYTE PTR [rcx], r15b
$LN13@GetSimpleE:

; 584  :       }
; 585  :       break;
; 586  : #ifdef DEBUG_OUT
; 587  :     default: /**/myassert(0); break;
; 588  : #endif
; 589  :     }
; 590  :     return(NOT_ERROR);

	xor	eax, eax
	jmp	SHORT $LN51@GetSimpleE
$LN14@GetSimpleE:

; 574  : 
; 575  :       hllop->lastjmp = buffer;
; 576  : 
; 577  :       if ((is_true == TRUE && op1.value) ||
; 578  :         (is_true == FALSE && op1.value == 0)) {

	test	r13b, r13b
	jne	SHORT $LN16@GetSimpleE
	cmp	DWORD PTR op1$[rsp], r15d
	jne	SHORT $LN16@GetSimpleE
$LN15@GetSimpleE:

; 579  :         sprintf(buffer, "jmp " LABELFMT EOLSTR, label);

	lea	rdx, OFFSET FLAT:$SG5866
	call	sprintf

; 584  :       }
; 585  :       break;
; 586  : #ifdef DEBUG_OUT
; 587  :     default: /**/myassert(0); break;
; 588  : #endif
; 589  :     }
; 590  :     return(NOT_ERROR);

	xor	eax, eax
	jmp	SHORT $LN51@GetSimpleE
$LN24@GetSimpleE:

; 591  :   }
; 592  : 
; 593  :   /* get second operand for binary operator */
; 594  :   op2_pos = *i;

	mov	eax, DWORD PTR [rdi]

; 595  :   if (ERROR == GetToken(hll, i, tokenarray, &op2)) {

	cmp	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR op2_pos$1$[rsp], eax
	mov	ebx, eax
	jge	SHORT $LN145@GetSimpleE
	npad	1
$LL122@GetSimpleE:
	movsxd	rcx, ebx
	shl	rcx, 5
	add	rcx, rsi
	call	GetCOp
	test	eax, eax
	jne	SHORT $LN145@GetSimpleE
	inc	ebx
	cmp	ebx, DWORD PTR ModuleInfo+496
	jl	SHORT $LL122@GetSimpleE
$LN145@GetSimpleE:
	cmp	ebx, DWORD PTR [rdi]
	jne	SHORT $LN118@GetSimpleE
	mov	DWORD PTR op2$[rsp+60], -2
$LN26@GetSimpleE:

; 541  :   case EXPR_EMPTY:
; 542  :     DebugMsg(("GetSimpleExpression: empty expression rejected\n"));
; 543  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE)); /* v2.09: changed from NOT_ERROR to ERROR */

	mov	ecx, 199				; 000000c7H
$LN147@GetSimpleE:
	call	EmitError
$LN51@GetSimpleE:
	mov	r15, QWORD PTR [rsp+296]
	mov	r14, QWORD PTR [rsp+304]
	mov	r13, QWORD PTR [rsp+312]
	mov	r12, QWORD PTR [rsp+320]
	mov	rdi, QWORD PTR [rsp+328]
	mov	rsi, QWORD PTR [rsp+336]
	mov	rbp, QWORD PTR [rsp+344]
	mov	rbx, QWORD PTR [rsp+352]

; 642  : }

	add	rsp, 360				; 00000168H
	ret	0

; 595  :   if (ERROR == GetToken(hll, i, tokenarray, &op2)) {

$LN118@GetSimpleE:
	lea	r9, QWORD PTR op2$[rsp]
	mov	r8d, ebx
	mov	rdx, rsi
	mov	rcx, rdi
	mov	BYTE PTR [rsp+32], r15b
	call	EvalOperand
	cmp	eax, -1
	je	SHORT $LN142@GetSimpleE
	cmp	DWORD PTR [rdi], ebx
	jle	SHORT $LN12@GetSimpleE
	mov	ecx, 199				; 000000c7H
	call	EmitError
	cmp	eax, -1
	jne	SHORT $LN12@GetSimpleE
$LN142@GetSimpleE:

; 596  :     return(ERROR);

	mov	eax, -1
	jmp	$LN51@GetSimpleE
$LN12@GetSimpleE:

; 597  :   }
; 598  :   DebugMsg1(("%u GetSimpleExpression: EvalOperand 2 ok, type=%X, i=%u [%s]\n", evallvl, op2.type, *i, tokenarray[*i].tokpos));
; 599  :   if (op2.kind != EXPR_CONST && op2.kind != EXPR_ADDR && op2.kind != EXPR_REG) {

	mov	eax, DWORD PTR op2$[rsp+60]
	test	eax, eax
	je	SHORT $LN11@GetSimpleE
	cmp	eax, 1
	je	SHORT $LN11@GetSimpleE
	cmp	eax, 2

; 600  :     DebugMsg(("GetSimpleExpression: syntax error, op2.kind=%u\n", op2.kind));
; 601  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	jne	$LN26@GetSimpleE
$LN11@GetSimpleE:

; 602  :   }
; 603  :   op2_end = *i;
; 604  : 
; 605  :   /* now generate ASM code for expression */
; 606  : 
; 607  :   if (op == COP_ANDB) {

	cmp	ebp, 9
	mov	r8d, DWORD PTR [rdi]
	jne	SHORT $LN10@GetSimpleE

; 608  :     p = RenderInstr(buffer, "test", op1_pos, op1_end, op2_pos, op2_end, tokenarray);

	mov	eax, DWORD PTR op2_pos$1$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+48], rsi
	mov	DWORD PTR [rsp+40], r8d
	lea	rdx, OFFSET FLAT:$SG5871
	mov	r9d, r14d
	mov	r8d, r12d
	mov	DWORD PTR [rsp+32], eax
	call	RenderInstr

; 609  :     hllop->lastjmp = p;

	mov	rcx, QWORD PTR hllop$[rsp]

; 610  :     RenderJcc(p, 'e', is_true, label);

	mov	r9d, DWORD PTR label$1$[rsp]
	mov	QWORD PTR [rcx], rax
	movzx	r8d, r13b
	mov	dl, 101					; 00000065H
	mov	rcx, rax
	call	RenderJcc

; 635  :   }
; 636  :   else {
; 637  :     DebugMsg(("GetSimpleExpression: unexpected operator %s\n", tokenarray[op1_pos].tokpos));
; 638  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));
; 639  :   }
; 640  :   exitle:
; 641  :   return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN51@GetSimpleE
$LN10@GetSimpleE:

; 611  :   }
; 612  :   else if (op <= COP_LE) { /* ==, !=, >, <, >= or <= operator */

	cmp	ebp, 6
	jg	$LN26@GetSimpleE

; 613  :                            /*
; 614  :                            * optimisation: generate 'or EAX,EAX' instead of 'cmp EAX,0'.
; 615  :                            * v2.11: use op2.value64 instead of op2.value
; 616  :                            */
; 617  :     if (Options.masm_compat_gencode &&
; 618  :       (op == COP_EQ || op == COP_NE) &&
; 619  :       op1.kind == EXPR_REG && op1.indirect == FALSE &&
; 620  :       op2.kind == EXPR_CONST && op2.value64 == 0) {

	cmp	BYTE PTR Options+137, r15b
	mov	edi, DWORD PTR op1$[rsp+72]
	mov	ecx, DWORD PTR op1$[rsp+60]
	mov	rdx, QWORD PTR op2$[rsp]
	je	SHORT $LN7@GetSimpleE
	cmp	ebp, 1
	je	SHORT $LN6@GetSimpleE
	cmp	ebp, 2
	jne	SHORT $LN7@GetSimpleE
$LN6@GetSimpleE:
	cmp	ecx, 2
	jne	SHORT $LN7@GetSimpleE
	test	dil, 1
	jne	SHORT $LN7@GetSimpleE
	test	eax, eax
	jne	SHORT $LN7@GetSimpleE
	test	rdx, rdx
	jne	SHORT $LN7@GetSimpleE

; 621  :       p = RenderInstr(buffer, "or", op1_pos, op1_end, op1_pos, op1_end, tokenarray);

	mov	rcx, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+48], rsi
	lea	rdx, OFFSET FLAT:$SG5876
	mov	r9d, r14d
	mov	r8d, r12d
	mov	DWORD PTR [rsp+40], r14d
	mov	DWORD PTR [rsp+32], r12d
	call	RenderInstr
	mov	rdi, rax

; 622  :       }
; 623  :     /* HJWasm 2.18 optimisation: generate 'test EAX,EAX' instead of 'cmp EAX,0'. */
; 624  :     else if ((op == COP_EQ || op == COP_NE) &&

	jmp	SHORT $LN2@GetSimpleE
$LN7@GetSimpleE:

; 625  :       op1.kind == EXPR_REG && op1.indirect == FALSE &&
; 626  :       op2.kind == EXPR_CONST && op2.value64 == 0) {

	cmp	ebp, 1
	je	SHORT $LN3@GetSimpleE
	cmp	ebp, 2
	jne	SHORT $LN4@GetSimpleE
$LN3@GetSimpleE:
	cmp	ecx, 2
	jne	SHORT $LN4@GetSimpleE
	test	dil, 1
	jne	SHORT $LN4@GetSimpleE
	test	eax, eax
	jne	SHORT $LN4@GetSimpleE
	test	rdx, rdx
	jne	SHORT $LN4@GetSimpleE

; 627  :       p = RenderInstr(buffer, "test", op1_pos, op1_end, op1_pos, op1_end, tokenarray);

	mov	rcx, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+48], rsi
	lea	rdx, OFFSET FLAT:$SG5880
	mov	r9d, r14d
	mov	r8d, r12d
	mov	DWORD PTR [rsp+40], r14d
	mov	DWORD PTR [rsp+32], r12d
	call	RenderInstr
	mov	rdi, rax

; 628  :     }
; 629  :     else {  

	jmp	SHORT $LN2@GetSimpleE
$LN4@GetSimpleE:

; 630  :       p = RenderInstr(buffer, "cmp", op1_pos, op1_end, op2_pos, op2_end, tokenarray);

	mov	eax, DWORD PTR op2_pos$1$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+48], rsi
	mov	DWORD PTR [rsp+40], r8d
	lea	rdx, OFFSET FLAT:$SG5882
	mov	r9d, r14d
	mov	r8d, r12d
	mov	DWORD PTR [rsp+32], eax
	call	RenderInstr
	mov	rdi, rax
$LN2@GetSimpleE:

; 631  :     }
; 632  :     instr = ((IS_SIGNED(op1.mem_type) || IS_SIGNED(op2.mem_type)) ? signed_cjmptype[op - COP_EQ] : unsigned_cjmptype[op - COP_EQ]);

	mov	eax, DWORD PTR op1$[rsp+64]
	and	al, -64					; ffffffffffffffc0H
	cmp	al, 64					; 00000040H
	je	SHORT $LN53@GetSimpleE
	mov	eax, DWORD PTR op2$[rsp+64]
	and	al, -64					; ffffffffffffffc0H
	cmp	al, 64					; 00000040H
	je	SHORT $LN53@GetSimpleE
	lea	rdx, OFFSET FLAT:__ImageBase
	movsxd	rcx, ebp
	movzx	r10d, BYTE PTR unsigned_cjmptype[rcx+rdx-1]
	jmp	SHORT $LN54@GetSimpleE
$LN53@GetSimpleE:
	lea	rdx, OFFSET FLAT:__ImageBase
	movsxd	rcx, ebp
	mov	r10b, BYTE PTR signed_cjmptype[rcx+rdx-1]
$LN54@GetSimpleE:

; 633  :     hllop->lastjmp = p;

	mov	rax, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rax], rdi

; 634  :     RenderJcc(p, instr, neg_cjmptype[op - COP_EQ] ? is_true : !is_true, label);

	cmp	BYTE PTR neg_cjmptype[rcx+rdx-1], r15b
	je	SHORT $LN55@GetSimpleE
	movzx	r15d, r13b
	jmp	SHORT $LN56@GetSimpleE
$LN55@GetSimpleE:
	test	r13b, r13b
	sete	r15b
$LN56@GetSimpleE:
	mov	r9d, DWORD PTR label$1$[rsp]
	mov	r8d, r15d
	movzx	edx, r10b
	mov	rcx, rdi
	call	RenderJcc

; 635  :   }
; 636  :   else {
; 637  :     DebugMsg(("GetSimpleExpression: unexpected operator %s\n", tokenarray[op1_pos].tokpos));
; 638  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));
; 639  :   }
; 640  :   exitle:
; 641  :   return(NOT_ERROR);

	xor	eax, eax
$exitle$5884:
	jmp	$LN51@GetSimpleE
$LN25@GetSimpleE:

; 544  :   case EXPR_FLOAT:
; 545  :     DebugMsg(("GetSimpleExpression: float expression rejected: %s\n", tokenarray[op1_pos].tokpos));
; 546  :     return(EmitError(REAL_OR_BCD_NUMBER_NOT_ALLOWED)); /* v2.10: added */

	mov	ecx, 271				; 0000010fH
	jmp	$LN147@GetSimpleE
GetSimpleExpression ENDP
; Function compile flags: /Ogtpy
p$ = 8
InvertJump PROC NEAR

; 658  :   if (*p == NULLC) { /* v2.11: convert 0 to "jmp" */

	cmp	BYTE PTR [rcx], 0
	jne	SHORT $LN17@InvertJump

; 659  :     strcpy(p, "jmp ");

	mov	eax, DWORD PTR $SG5890
	mov	DWORD PTR [rcx], eax
	movzx	eax, BYTE PTR $SG5890+4
	mov	BYTE PTR [rcx+4], al

; 695  :     *p = ' ';
; 696  :   else
; 697  :     *p = 'e';
; 698  :   return;
; 699  : }

	ret	0
$LN17@InvertJump:

; 660  :     return;
; 661  :   }
; 662  : 
; 663  :   p++;
; 664  :   if (*p == 'e' || *p == 'z' || *p == 'c' || *p == 's' || *p == 'p' || *p == 'o') {

	movzx	eax, BYTE PTR [rcx+1]
	cmp	al, 101					; 00000065H
	je	SHORT $LN15@InvertJump
	cmp	al, 122					; 0000007aH
	je	SHORT $LN15@InvertJump
	cmp	al, 99					; 00000063H
	je	SHORT $LN15@InvertJump
	cmp	al, 115					; 00000073H
	je	SHORT $LN15@InvertJump
	cmp	al, 112					; 00000070H
	je	SHORT $LN15@InvertJump
	cmp	al, 111					; 0000006fH
	je	SHORT $LN15@InvertJump

; 667  :     return;
; 668  :   }
; 669  :   else if (*p == 'n') {

	cmp	al, 110					; 0000006eH
	jne	SHORT $LN13@InvertJump

; 670  :     *p = *(p + 1);

	movzx	eax, BYTE PTR [rcx+2]

; 671  :     *(p + 1) = ' ';

	mov	BYTE PTR [rcx+2], 32			; 00000020H
	mov	BYTE PTR [rcx+1], al

; 695  :     *p = ' ';
; 696  :   else
; 697  :     *p = 'e';
; 698  :   return;
; 699  : }

	ret	0
$LN13@InvertJump:

; 672  :     return;
; 673  :   }
; 674  :   else if (*p == 'a') {

	cmp	al, 97					; 00000061H
	jne	SHORT $LN11@InvertJump

; 675  :     *p++ = 'b';

	mov	BYTE PTR [rcx+1], 98			; 00000062H
	jmp	SHORT $LN20@InvertJump
$LN11@InvertJump:

; 676  :   }
; 677  :   else if (*p == 'b') {

	cmp	al, 98					; 00000062H
	jne	SHORT $LN9@InvertJump

; 678  :     *p++ = 'a';

	mov	BYTE PTR [rcx+1], 97			; 00000061H
	jmp	SHORT $LN20@InvertJump
$LN9@InvertJump:

; 679  :   }
; 680  :   else if (*p == 'g') {

	cmp	al, 103					; 00000067H
	jne	SHORT $LN7@InvertJump

; 681  :     *p++ = 'l';

	mov	BYTE PTR [rcx+1], 108			; 0000006cH
	jmp	SHORT $LN20@InvertJump
$LN7@InvertJump:

; 682  :   }
; 683  :   else if (*p == 'l') {

	cmp	al, 108					; 0000006cH
	jne	SHORT $LN5@InvertJump

; 684  :     *p++ = 'g';

	mov	BYTE PTR [rcx+1], 103			; 00000067H
$LN20@InvertJump:
	add	rcx, 2

; 691  :     }
; 692  :     return;
; 693  :   }
; 694  :   if (*p == 'e')

	mov	eax, 101				; 00000065H
	mov	edx, 32					; 00000020H
	cmp	BYTE PTR [rcx], al
	cmove	eax, edx
	mov	BYTE PTR [rcx], al

; 695  :     *p = ' ';
; 696  :   else
; 697  :     *p = 'e';
; 698  :   return;
; 699  : }

	ret	0
$LN5@InvertJump:

; 685  :   }
; 686  :   else {
; 687  :     /* v2.11: convert "jmp" to 0 */
; 688  :     if (*p == 'm') {

	cmp	al, 109					; 0000006dH
	jne	SHORT $LN1@InvertJump

; 689  :       p--;
; 690  :       *p = NULLC;

	mov	BYTE PTR [rcx], 0

; 695  :     *p = ' ';
; 696  :   else
; 697  :     *p = 'e';
; 698  :   return;
; 699  : }

	ret	0
$LN15@InvertJump:

; 665  :     *(p + 1) = *p;

	mov	BYTE PTR [rcx+2], al

; 666  :     *p = 'n';

	mov	BYTE PTR [rcx+1], 110			; 0000006eH
$LN1@InvertJump:

; 695  :     *p = ' ';
; 696  :   else
; 697  :     *p = 'e';
; 698  :   return;
; 699  : }

	ret	0
InvertJump ENDP
_TEXT	ENDS
EXTRN	strstr:NEAR
xdata	SEGMENT
$unwind$ReplaceLabel DD 071601H
	DD	0d7416H
	DD	0c6411H
	DD	0b3409H
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$ReplaceLabel DD @imagerel(ReplaceLabel#)
	DD	@imagerel(ReplaceLabel#+170)
	DD	@imagerel($unwind$ReplaceLabel#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
newlbl$ = 32
oldlbl$ = 48
p$ = 80
olabel$ = 88
nlabel$ = 96
ReplaceLabel PROC NEAR

; 709  : {

	sub	rsp, 72					; 00000048H
	mov	QWORD PTR [rsp+88], rbx
	mov	rbx, rcx
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+104], rdi
	mov	edi, r8d

; 710  :   char oldlbl[16];
; 711  :   char newlbl[16];
; 712  :   int i;
; 713  : 
; 714  :   GetLabelStr(olabel, oldlbl);

	mov	r8d, edx
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR oldlbl$[rsp]
	call	sprintf

; 715  :   GetLabelStr(nlabel, newlbl);

	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR newlbl$[rsp]
	mov	r8d, edi
	call	sprintf

; 716  : 
; 717  :   i = strlen(newlbl);

	xor	eax, eax
	lea	rdi, QWORD PTR newlbl$[rsp]
	mov	rcx, -1

; 718  : 
; 719  :   DebugMsg1(("%u ReplaceLabel(%s->%s, >%s<)\n", evallvl, oldlbl, newlbl, p));
; 720  :   while (p = strstr(p, oldlbl)) {

	lea	rdx, QWORD PTR oldlbl$[rsp]
	repne scasb
	not	rcx
	lea	rsi, QWORD PTR [rcx-1]
	mov	rcx, rbx
	call	strstr
	test	rax, rax
	mov	rdi, rax
	je	SHORT $LN1@ReplaceLab
	movsxd	rbx, esi
$LL2@ReplaceLab:

; 721  :     memcpy(p, newlbl, i);

	lea	rdx, QWORD PTR newlbl$[rsp]
	mov	r8, rbx
	mov	rcx, rdi
	call	memcpy

; 722  :     p += i;

	lea	rcx, QWORD PTR [rbx+rdi]
	lea	rdx, QWORD PTR oldlbl$[rsp]
	call	strstr
	test	rax, rax
	mov	rdi, rax
	jne	SHORT $LL2@ReplaceLab
$LN1@ReplaceLab:
	mov	rdi, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [rsp+88]

; 723  :   }
; 724  : }

	add	rsp, 72					; 00000048H
	ret	0
ReplaceLabel ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$GetAndExpression DD 0104001H
	DD	013f440H
	DD	014e43cH
	DD	015d438H
	DD	016c434H
	DD	0177428H
	DD	0186424H
	DD	0195418H
	DD	01b0114H
xdata	ENDS
pdata	SEGMENT
$pdata$GetAndExpression DD @imagerel(GetAndExpression#)
	DD	@imagerel(GetAndExpression#+127)
	DD	@imagerel($unwind$GetAndExpression#)
pdata	ENDS
xdata	SEGMENT
$chain$7$GetAndExpression DD 020821H
	DD	01a3408H
	DD	@imagerel(GetAndExpression#)
	DD	@imagerel(GetAndExpression#+127)
	DD	@imagerel($unwind$GetAndExpression#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$GetAndExpression DD @imagerel(GetAndExpression#+127)
	DD	@imagerel(GetAndExpression#+1185)
	DD	@imagerel($chain$7$GetAndExpression#)
pdata	ENDS
xdata	SEGMENT
$chain$8$GetAndExpression DD 021H
	DD	@imagerel(GetAndExpression#)
	DD	@imagerel(GetAndExpression#+127)
	DD	@imagerel($unwind$GetAndExpression#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$GetAndExpression DD @imagerel(GetAndExpression#+1185)
	DD	@imagerel(GetAndExpression#+1249)
	DD	@imagerel($chain$8$GetAndExpression#)
pdata	ENDS
xdata	SEGMENT
$chain$9$GetAndExpression DD 020021H
	DD	01a3400H
	DD	@imagerel(GetAndExpression#)
	DD	@imagerel(GetAndExpression#+127)
	DD	@imagerel($unwind$GetAndExpression#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$GetAndExpression DD @imagerel(GetAndExpression#+1249)
	DD	@imagerel(GetAndExpression#+1256)
	DD	@imagerel($chain$9$GetAndExpression#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
newlbl$7504 = 64
oldlbl$7503 = 80
newlbl$7534 = 96
oldlbl$7533 = 112
buff$ = 128
hll$ = 224
i$ = 232
tokenarray$ = 240
ilabel$ = 248
is_true$ = 256
buffer$ = 264
hllop$ = 272
GetAndExpression PROC NEAR

; 730  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, rsp
	sub	rsp, 216				; 000000d8H
	mov	QWORD PTR [rax-16], rbp

; 731  :   char *ptr = buffer;
; 732  :   uint_32 truelabel = 0;
; 733  :   char buff[16];
; 734  :   int nlabel;
; 735  :   int olabel;
; 736  : 
; 737  :   DebugMsg1(("%u GetAndExpression(>%.32s< buf=>%s<) enter\n", evallvl, tokenarray[*i].tokpos, buffer));
; 738  : 
; 739  :   if (ERROR == GetSimpleExpression(hll, i, tokenarray, ilabel, is_true, ptr, hllop))

	mov	rbp, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rax-24], rsi
	mov	QWORD PTR [rax-32], rdi
	movzx	edi, BYTE PTR is_true$[rsp]
	mov	QWORD PTR [rax-40], r12
	mov	QWORD PTR [rax-48], r13
	mov	QWORD PTR [rax-56], r14
	mov	QWORD PTR [rax-64], r15
	mov	rax, rcx
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+48], rbp
	mov	QWORD PTR [rsp+40], rcx
	mov	r12, rcx
	mov	rcx, rax
	mov	esi, r9d
	mov	r15, r8
	mov	r13, rdx
	xor	r14d, r14d
	mov	BYTE PTR [rsp+32], dil
	call	GetSimpleExpression
	cmp	eax, -1
	jne	SHORT $LN60@GetAndExpr

; 740  :     return(ERROR);

	jmp	$LN11@GetAndExpr
$LN60@GetAndExpr:

; 741  :   while (COP_AND == GetCOp(&tokenarray[*i])) {

	movsxd	rcx, DWORD PTR [r13]
	mov	QWORD PTR [rsp+208], rbx
	shl	rcx, 5
	add	rcx, r15
	call	GetCOp
	cmp	eax, 7
	jne	$LN1@GetAndExpr
	lea	edx, QWORD PTR [rax+25]
	lea	rbx, OFFSET FLAT:$SG5951
	npad	10
$LL9@GetAndExpr:

; 742  : 
; 743  :     (*i)++;

	inc	DWORD PTR [r13]

; 744  :     DebugMsg1(("%u GetAndExpression: &&-operator found, is_true=%u, lastjmp=%s\n", evallvl, is_true, hllop->lastjmp ? hllop->lastjmp : "NULL"));
; 745  : 
; 746  :     if (is_true) {

	test	dil, dil
	je	$LN6@GetAndExpr

; 747  :       /* todo: please describe what's done here and why! */
; 748  :       if (hllop->lastjmp) {

	mov	rdi, QWORD PTR [rbp]
	test	rdi, rdi
	je	$LN6@GetAndExpr

; 749  :         char *p = hllop->lastjmp;
; 750  :         InvertJump(p);          /* step 1 */

	cmp	BYTE PTR [rdi], 0
	jne	SHORT $LN29@GetAndExpr
	mov	eax, DWORD PTR $SG5890
	mov	DWORD PTR [rdi], eax
	movzx	eax, BYTE PTR $SG5890+4
	mov	BYTE PTR [rdi+4], al
	jmp	$LN13@GetAndExpr
$LN29@GetAndExpr:
	movzx	eax, BYTE PTR [rdi+1]
	lea	rcx, QWORD PTR [rdi+1]
	cmp	al, 101					; 00000065H
	je	$LN27@GetAndExpr
	cmp	al, 122					; 0000007aH
	je	$LN27@GetAndExpr
	cmp	al, 99					; 00000063H
	je	$LN27@GetAndExpr
	cmp	al, 115					; 00000073H
	je	$LN27@GetAndExpr
	cmp	al, 112					; 00000070H
	je	SHORT $LN27@GetAndExpr
	cmp	al, 111					; 0000006fH
	je	SHORT $LN27@GetAndExpr
	cmp	al, 110					; 0000006eH
	jne	SHORT $LN25@GetAndExpr
	movzx	eax, BYTE PTR [rcx+1]
	mov	BYTE PTR [rcx+1], 32			; 00000020H
	mov	BYTE PTR [rcx], al
	jmp	SHORT $LN13@GetAndExpr
$LN25@GetAndExpr:
	cmp	al, 97					; 00000061H
	jne	SHORT $LN23@GetAndExpr
	mov	BYTE PTR [rcx], 98			; 00000062H
	inc	rcx
	mov	eax, 101				; 00000065H
	cmp	BYTE PTR [rcx], al
	cmove	eax, edx
	mov	BYTE PTR [rcx], al
	jmp	SHORT $LN13@GetAndExpr
$LN23@GetAndExpr:
	cmp	al, 98					; 00000062H
	jne	SHORT $LN21@GetAndExpr
	mov	BYTE PTR [rcx], 97			; 00000061H
	inc	rcx
	mov	eax, 101				; 00000065H
	cmp	BYTE PTR [rcx], al
	cmove	eax, edx
	mov	BYTE PTR [rcx], al
	jmp	SHORT $LN13@GetAndExpr
$LN21@GetAndExpr:
	cmp	al, 103					; 00000067H
	jne	SHORT $LN19@GetAndExpr
	mov	BYTE PTR [rcx], 108			; 0000006cH
	inc	rcx
	mov	eax, 101				; 00000065H
	cmp	BYTE PTR [rcx], al
	cmove	eax, edx
	mov	BYTE PTR [rcx], al
	jmp	SHORT $LN13@GetAndExpr
$LN19@GetAndExpr:
	cmp	al, 108					; 0000006cH
	jne	SHORT $LN17@GetAndExpr
	mov	BYTE PTR [rcx], 103			; 00000067H
	inc	rcx
	mov	eax, 101				; 00000065H
	cmp	BYTE PTR [rcx], al
	cmove	eax, edx
	mov	BYTE PTR [rcx], al
	jmp	SHORT $LN13@GetAndExpr
$LN17@GetAndExpr:
	cmp	al, 109					; 0000006dH
	jne	SHORT $LN13@GetAndExpr
	mov	BYTE PTR [rcx-1], 0
	jmp	SHORT $LN13@GetAndExpr
$LN27@GetAndExpr:
	mov	BYTE PTR [rcx+1], al
	mov	BYTE PTR [rcx], 110			; 0000006eH
$LN13@GetAndExpr:

; 751  :         if (truelabel == 0)     /* step 2 */

	test	r14d, r14d
	jne	SHORT $LN70@GetAndExpr

; 752  :           truelabel = GetHllLabel();

	mov	ebx, DWORD PTR ModuleInfo+352
	inc	ebx
	mov	DWORD PTR ModuleInfo+352, ebx
	mov	r14d, ebx
	lea	rbx, OFFSET FLAT:$SG5951
$LN70@GetAndExpr:

; 753  : 
; 754  :         if (*p ) {/* v2.11: there might be a 0 at lastjmp */

	cmp	BYTE PTR [rdi], 0
	je	SHORT $LN4@GetAndExpr

; 755  :           p += 4;               /* skip 'jcc ' or 'jmp ' */

	add	rdi, 4

; 756  :           GetLabelStr(truelabel, p);

	lea	rdx, OFFSET FLAT:$SG5756
	mov	r8d, r14d
	mov	rcx, rdi
	call	sprintf

; 757  :           strcat(p, EOLSTR);

	xor	eax, eax
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	5
$LL69@GetAndExpr:
	movzx	eax, BYTE PTR [rbx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL69@GetAndExpr
$LN4@GetAndExpr:

; 758  :         }
; 759  :         /* HJWasm 2.18  fixed WHILE with &&  */
; 760  :         if (hllop->lasttruelabel)

	mov	r8d, DWORD PTR [rbp+8]
	test	r8d, r8d
	je	$LN71@GetAndExpr

; 761  :           ReplaceLabel(buffer,hllop->lasttruelabel, truelabel);

	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR oldlbl$7503[rsp]
	call	sprintf
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR newlbl$7504[rsp]
	mov	r8d, r14d
	call	sprintf
	xor	eax, eax
	lea	rdi, QWORD PTR newlbl$7504[rsp]
	mov	rcx, -1
	lea	rdx, QWORD PTR oldlbl$7503[rsp]
	repne scasb
	not	rcx
	lea	rbx, QWORD PTR [rcx-1]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strstr
	test	rax, rax
	mov	rdi, rax
	je	SHORT $LN71@GetAndExpr
	movsxd	rbx, ebx
	npad	11
$LL37@GetAndExpr:
	lea	rdx, QWORD PTR newlbl$7504[rsp]
	mov	r8, rbx
	mov	rcx, rdi
	call	memcpy
	lea	rcx, QWORD PTR [rbx+rdi]
	lea	rdx, QWORD PTR oldlbl$7503[rsp]
	call	strstr
	test	rax, rax
	mov	rdi, rax
	jne	SHORT $LL37@GetAndExpr
$LN71@GetAndExpr:

; 762  :           nlabel = GetHllLabel();

	mov	ebx, DWORD PTR ModuleInfo+352

; 763  :           olabel = GetLabel(hll, ilabel);

	mov	rcx, QWORD PTR hll$[rsp]
	movsxd	rax, esi
	inc	ebx

; 764  :           GetLabelStr(olabel, buff);

	lea	rdx, OFFSET FLAT:$SG5756
	mov	DWORD PTR ModuleInfo+352, ebx
	mov	esi, DWORD PTR [rcx+rax*4+8]
	lea	rcx, QWORD PTR buff$[rsp]
	mov	r8d, esi
	call	sprintf

; 765  :           strcat(ptr, buff);

	xor	eax, eax
	mov	rdi, r12
	mov	rcx, -1
	lea	rdx, QWORD PTR buff$[rsp]
	repne scasb
	xor	ecx, ecx
	npad	14
$LL68@GetAndExpr:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL68@GetAndExpr

; 766  :           strcat(ptr, LABELQUAL EOLSTR);

	xor	eax, eax
	mov	rdi, r12
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rbp, OFFSET FLAT:$SG5953
	npad	10
$LL67@GetAndExpr:
	movzx	eax, BYTE PTR [rcx+rbp]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL67@GetAndExpr
	mov	rbp, QWORD PTR hllop$[rsp]

; 767  :           DebugMsg1(("%u GetAndExpression: label added >%s<\n", evallvl, ptr));
; 768  :           ReplaceLabel(buffer, olabel, nlabel);

	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR oldlbl$7533[rsp]
	mov	r8d, esi
	call	sprintf
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR newlbl$7534[rsp]
	mov	r8d, ebx
	call	sprintf
	xor	eax, eax
	lea	rdi, QWORD PTR newlbl$7534[rsp]
	mov	rcx, -1
	lea	rdx, QWORD PTR oldlbl$7533[rsp]
	repne scasb
	not	rcx
	lea	rbx, QWORD PTR [rcx-1]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strstr
	test	rax, rax
	mov	rdi, rax
	je	SHORT $LN50@GetAndExpr
	movsxd	rbx, ebx
	npad	13
$LL51@GetAndExpr:
	lea	rdx, QWORD PTR newlbl$7534[rsp]
	mov	r8, rbx
	mov	rcx, rdi
	call	memcpy
	lea	rcx, QWORD PTR [rbx+rdi]
	lea	rdx, QWORD PTR oldlbl$7533[rsp]
	call	strstr
	test	rax, rax
	mov	rdi, rax
	jne	SHORT $LL51@GetAndExpr
$LN50@GetAndExpr:
	mov	esi, DWORD PTR ilabel$[rsp]

; 769  :           hllop->lastjmp = NULL;

	mov	QWORD PTR [rbp], 0
	lea	rbx, OFFSET FLAT:$SG5951
$LN6@GetAndExpr:

; 770  :       }
; 771  :     }
; 772  :     ptr += strlen(ptr);

	xor	eax, eax
	mov	rdi, r12

; 773  :     hllop->lasttruelabel = 0; /* v2.08 */
; 774  :     if (ERROR == GetSimpleExpression(hll, i, tokenarray, ilabel, is_true, ptr, hllop))

	mov	QWORD PTR [rsp+48], rbp
	mov	rcx, -1
	mov	r9d, esi
	mov	r8, r15
	repne scasb
	mov	dil, BYTE PTR is_true$[rsp]
	mov	rdx, r13
	not	rcx
	mov	DWORD PTR [rbp+8], eax
	dec	rcx
	add	r12, rcx
	mov	rcx, QWORD PTR hll$[rsp]
	mov	QWORD PTR [rsp+40], r12
	mov	BYTE PTR [rsp+32], dil
	call	GetSimpleExpression
	cmp	eax, -1
	je	$LN63@GetAndExpr
	movsxd	rcx, DWORD PTR [r13]
	shl	rcx, 5
	add	rcx, r15
	call	GetCOp
	mov	edx, 32					; 00000020H
	cmp	eax, 7
	je	$LL9@GetAndExpr

; 776  :   };
; 777  : 
; 778  :   if (truelabel > 0) {

	test	r14d, r14d
	je	SHORT $LN1@GetAndExpr

; 779  :     ptr += strlen(ptr);

	xor	eax, eax
	mov	rdi, r12
	mov	rcx, -1
	repne scasb

; 780  :     GetLabelStr(truelabel, ptr);

	lea	rdx, OFFSET FLAT:$SG5756
	mov	r8d, r14d
	not	rcx
	dec	rcx
	add	r12, rcx
	mov	rcx, r12
	call	sprintf

; 781  :     strcat(ptr, LABELQUAL EOLSTR);

	xor	eax, eax
	mov	rdi, r12
	mov	rcx, -1
	lea	rdx, OFFSET FLAT:$SG5957
	repne scasb
	xor	ecx, ecx
	npad	1
$LL66@GetAndExpr:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL66@GetAndExpr

; 782  :     DebugMsg1(("%u GetAndExpression: label added >%s<\n", evallvl, ptr));
; 783  :     hllop->lastjmp = NULL;

	mov	QWORD PTR [rbp], 0
$LN1@GetAndExpr:

; 784  :   }
; 785  :   return(NOT_ERROR);

	xor	eax, eax
$LN72@GetAndExpr:
	mov	rbx, QWORD PTR [rsp+208]
$LN11@GetAndExpr:
	mov	r15, QWORD PTR [rsp+152]
	mov	r14, QWORD PTR [rsp+160]
	mov	r13, QWORD PTR [rsp+168]
	mov	r12, QWORD PTR [rsp+176]
	mov	rdi, QWORD PTR [rsp+184]
	mov	rsi, QWORD PTR [rsp+192]
	mov	rbp, QWORD PTR [rsp+200]

; 786  : }

	add	rsp, 216				; 000000d8H
	ret	0
$LN63@GetAndExpr:

; 775  :       return(ERROR);

	mov	eax, -1
	jmp	SHORT $LN72@GetAndExpr
GetAndExpression ENDP
_TEXT	ENDS
EXTRN	strchr:NEAR
xdata	SEGMENT
$unwind$GetExpression DD 0104001H
	DD	017f440H
	DD	018e43cH
	DD	019d430H
	DD	01ac42cH
	DD	01b7428H
	DD	01d5424H
	DD	01e3418H
	DD	01f0114H
xdata	ENDS
pdata	SEGMENT
$pdata$GetExpression DD @imagerel(GetExpression#)
	DD	@imagerel(GetExpression#+121)
	DD	@imagerel($unwind$GetExpression#)
pdata	ENDS
xdata	SEGMENT
$chain$7$GetExpression DD 020821H
	DD	01c6408H
	DD	@imagerel(GetExpression#)
	DD	@imagerel(GetExpression#+121)
	DD	@imagerel($unwind$GetExpression#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$GetExpression DD @imagerel(GetExpression#+121)
	DD	@imagerel(GetExpression#+1389)
	DD	@imagerel($chain$7$GetExpression#)
pdata	ENDS
xdata	SEGMENT
$chain$8$GetExpression DD 021H
	DD	@imagerel(GetExpression#)
	DD	@imagerel(GetExpression#+121)
	DD	@imagerel($unwind$GetExpression#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$GetExpression DD @imagerel(GetExpression#+1389)
	DD	@imagerel(GetExpression#+1453)
	DD	@imagerel($chain$8$GetExpression#)
pdata	ENDS
xdata	SEGMENT
$chain$9$GetExpression DD 020021H
	DD	01c6400H
	DD	@imagerel(GetExpression#)
	DD	@imagerel(GetExpression#+121)
	DD	@imagerel($unwind$GetExpression#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$GetExpression DD @imagerel(GetExpression#+1453)
	DD	@imagerel(GetExpression#+1460)
	DD	@imagerel($chain$9$GetExpression#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buff$5982 = 64
newlbl$7623 = 80
oldlbl$7622 = 96
newlbl$7649 = 112
oldlbl$7648 = 128
newlbl$7674 = 144
oldlbl$7673 = 160
hll$ = 256
i$ = 264
tokenarray$ = 272
ilabel$ = 280
is_true$ = 288
buffer$ = 296
hllop$ = 304
GetExpression PROC NEAR

; 792  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	rax, rsp
	sub	rsp, 248				; 000000f8H
	mov	QWORD PTR [rax-8], rbx

; 794  :   uint_32 truelabel = 0;
; 795  : 
; 796  :   DebugMsg1(("%u GetExpression(>%.32s< buf=>%s<) enter\n", ++evallvl, tokenarray[*i].tokpos, buffer));
; 797  : 
; 798  :   /* v2.08: structure changed from for(;;) to while() to increase
; 799  :   * readability and - optionally - handle the second operand differently
; 800  :   * than the first.
; 801  :   */
; 802  : 
; 803  :   if (ERROR == GetAndExpression(hll, i, tokenarray, ilabel, is_true, ptr, hllop)) {

	movzx	ebx, BYTE PTR is_true$[rsp]
	mov	QWORD PTR [rax-16], rbp
	mov	QWORD PTR [rax-32], rdi
	mov	QWORD PTR [rax-40], r12
	mov	QWORD PTR [rax-48], r13
	mov	r13, QWORD PTR hllop$[rsp]
	mov	QWORD PTR [rax-56], r14
	mov	QWORD PTR [rax-64], r15
	mov	r15, rcx
	mov	rcx, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rsp+48], r13
	mov	QWORD PTR [rsp+40], rcx
	mov	r12, rcx
	mov	rcx, r15
	mov	rdi, r8
	mov	r14, rdx
	xor	ebp, ebp
	mov	BYTE PTR [rsp+32], bl
	call	GetAndExpression
	cmp	eax, -1
	jne	SHORT $LN73@GetExpress

; 804  :     DebugMsg1(("%u GetExpression exit, error\n", evallvl--));
; 805  :     return(ERROR);

	jmp	$LN14@GetExpress
$LN73@GetExpress:

; 806  :   }
; 807  :  // __debugbreak();
; 808  :   while (COP_OR == GetCOp(&tokenarray[*i])) {

	movsxd	rcx, DWORD PTR [r14]
	mov	QWORD PTR [rsp+224], rsi
	shl	rcx, 5
	add	rcx, rdi
	call	GetCOp
	cmp	eax, 8
	jne	$LN2@GetExpress
	lea	edx, QWORD PTR [rax+24]
	lea	rsi, OFFSET FLAT:$SG5988
$LL12@GetExpress:

; 809  : 
; 810  :     uint_32 nlabel;
; 811  :     uint_32 olabel;
; 812  :     char buff[16];
; 813  : 
; 814  :     /* the generated code of last simple expression has to be modified
; 815  :     1. the last jump must be inverted
; 816  :     2. a "is_true" label must be created (it's used to jump "behind" the expr)
; 817  :     3. create a new label
; 818  :     4. the current "false" label must be generated
; 819  : 
; 820  :     if it is a .REPEAT, step 4 is slightly more difficult, since the "false"
; 821  :     label is already "gone":
; 822  :     4a. create a new label
; 823  :     4b. replace the "false" label in the generated code by the new label
; 824  :     */
; 825  : 
; 826  :     (*i)++;

	inc	DWORD PTR [r14]

; 827  :     DebugMsg1(("%u GetExpression: ||-operator found, is_true=%u, lastjmp=%s\n", evallvl, is_true, hllop->lastjmp ? hllop->lastjmp : "NULL"));
; 828  : 
; 829  :     if (is_true == FALSE) {

	test	bl, bl
	jne	$LN63@GetExpress

; 830  :       if (hllop->lastjmp) {

	mov	rdi, QWORD PTR [r13]
	test	rdi, rdi
	je	$LN63@GetExpress

; 831  :         char *p = hllop->lastjmp;
; 832  :         InvertJump(p);           /* step 1 */

	cmp	BYTE PTR [rdi], bl
	jne	SHORT $LN32@GetExpress
	mov	eax, DWORD PTR $SG5890
	mov	DWORD PTR [rdi], eax
	movzx	eax, BYTE PTR $SG5890+4
	mov	BYTE PTR [rdi+4], al
	jmp	$LN16@GetExpress
$LN32@GetExpress:
	movzx	eax, BYTE PTR [rdi+1]
	lea	rcx, QWORD PTR [rdi+1]
	cmp	al, 101					; 00000065H
	je	$LN30@GetExpress
	cmp	al, 122					; 0000007aH
	je	$LN30@GetExpress
	cmp	al, 99					; 00000063H
	je	$LN30@GetExpress
	cmp	al, 115					; 00000073H
	je	$LN30@GetExpress
	cmp	al, 112					; 00000070H
	je	$LN30@GetExpress
	cmp	al, 111					; 0000006fH
	je	$LN30@GetExpress
	cmp	al, 110					; 0000006eH
	jne	SHORT $LN28@GetExpress
	movzx	eax, BYTE PTR [rcx+1]
	mov	BYTE PTR [rcx+1], 32			; 00000020H
	mov	BYTE PTR [rcx], al
	jmp	SHORT $LN16@GetExpress
$LN28@GetExpress:
	cmp	al, 97					; 00000061H
	jne	SHORT $LN26@GetExpress
	mov	BYTE PTR [rcx], 98			; 00000062H
	inc	rcx
	mov	eax, 101				; 00000065H
	cmp	BYTE PTR [rcx], al
	cmove	eax, edx
	mov	BYTE PTR [rcx], al
	jmp	SHORT $LN16@GetExpress
$LN26@GetExpress:
	cmp	al, 98					; 00000062H
	jne	SHORT $LN24@GetExpress
	mov	BYTE PTR [rcx], 97			; 00000061H
	inc	rcx
	mov	eax, 101				; 00000065H
	cmp	BYTE PTR [rcx], al
	cmove	eax, edx
	mov	BYTE PTR [rcx], al
	jmp	SHORT $LN16@GetExpress
$LN24@GetExpress:
	cmp	al, 103					; 00000067H
	jne	SHORT $LN22@GetExpress
	mov	BYTE PTR [rcx], 108			; 0000006cH
	inc	rcx
	mov	eax, 101				; 00000065H
	cmp	BYTE PTR [rcx], al
	cmove	eax, edx
	mov	BYTE PTR [rcx], al
	jmp	SHORT $LN16@GetExpress
$LN22@GetExpress:
	cmp	al, 108					; 0000006cH
	jne	SHORT $LN20@GetExpress
	mov	BYTE PTR [rcx], 103			; 00000067H
	inc	rcx
	mov	eax, 101				; 00000065H
	cmp	BYTE PTR [rcx], al
	cmove	eax, edx
	mov	BYTE PTR [rcx], al
	jmp	SHORT $LN16@GetExpress
$LN20@GetExpress:
	cmp	al, 109					; 0000006dH
	jne	SHORT $LN16@GetExpress
	mov	BYTE PTR [rcx-1], 0
	jmp	SHORT $LN16@GetExpress
$LN30@GetExpress:
	mov	BYTE PTR [rcx+1], al
	mov	BYTE PTR [rcx], 110			; 0000006eH
$LN16@GetExpress:

; 833  :         if (truelabel == 0)      /* step 2 */

	test	ebp, ebp
	jne	SHORT $LN8@GetExpress

; 834  :           truelabel = GetHllLabel();

	mov	ebp, DWORD PTR ModuleInfo+352
	inc	ebp
	mov	DWORD PTR ModuleInfo+352, ebp
$LN8@GetExpress:

; 835  :         if (*p ) { /* v2.11: there might be a 0 at lastjmp */

	cmp	BYTE PTR [rdi], 0
	je	SHORT $LN7@GetExpress

; 836  :           p += 4;                /* skip 'jcc ' or 'jmp ' */

	add	rdi, 4

; 837  :           GetLabelStr(truelabel, p);

	lea	rdx, OFFSET FLAT:$SG5756
	mov	r8d, ebp
	mov	rcx, rdi
	call	sprintf

; 838  :           strcat(p, EOLSTR);

	xor	eax, eax
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	11
$LL82@GetExpress:
	movzx	eax, BYTE PTR [rsi+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL82@GetExpress
$LN7@GetExpress:

; 839  :         }
; 840  :         /* v2.08: if-block added */
; 841  :         if (hllop->lasttruelabel)

	mov	r8d, DWORD PTR [r13+8]
	test	r8d, r8d
	je	SHORT $LN39@GetExpress

; 842  :           ReplaceLabel(ptr, hllop->lasttruelabel, truelabel);

	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR oldlbl$7622[rsp]
	call	sprintf
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR newlbl$7623[rsp]
	mov	r8d, ebp
	call	sprintf
	xor	eax, eax
	lea	rdi, QWORD PTR newlbl$7623[rsp]
	mov	rcx, -1
	lea	rdx, QWORD PTR oldlbl$7622[rsp]
	repne scasb
	not	rcx
	lea	rbx, QWORD PTR [rcx-1]
	mov	rcx, r12
	call	strstr
	test	rax, rax
	mov	rdi, rax
	je	SHORT $LN39@GetExpress
	movsxd	rbx, ebx
	npad	4
$LL40@GetExpress:
	lea	rdx, QWORD PTR newlbl$7623[rsp]
	mov	r8, rbx
	mov	rcx, rdi
	call	memcpy
	lea	rcx, QWORD PTR [rbx+rdi]
	lea	rdx, QWORD PTR oldlbl$7622[rsp]
	call	strstr
	test	rax, rax
	mov	rdi, rax
	jne	SHORT $LL40@GetExpress
$LN39@GetExpress:

; 843  :         DebugMsg1(("%u GetExpression: jmp inverted, dest changed >%s<\n", evallvl, ptr));
; 844  :         hllop->lastjmp = NULL;
; 845  : 
; 846  :         nlabel = GetHllLabel();  /* step 3 */
; 847  :         olabel = GetLabel(hll, ilabel);

	movsxd	rax, DWORD PTR ilabel$[rsp]
	mov	QWORD PTR [r13], 0
	mov	esi, DWORD PTR ModuleInfo+352
	inc	esi
	mov	DWORD PTR ModuleInfo+352, esi

; 848  :         if (hll->cmd == HLL_REPEAT) {

	cmp	DWORD PTR [r15+68], 2
	mov	ebx, DWORD PTR [r15+rax*4+8]
	jne	$LN5@GetExpress

; 849  :           ReplaceLabel(buffer, olabel, nlabel);

	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR oldlbl$7648[rsp]
	mov	r8d, ebx
	call	sprintf
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR newlbl$7649[rsp]
	mov	r8d, esi
	call	sprintf
	xor	eax, eax
	lea	rdi, QWORD PTR newlbl$7649[rsp]
	mov	rcx, -1
	lea	rdx, QWORD PTR oldlbl$7648[rsp]
	repne scasb
	not	rcx
	lea	rbx, QWORD PTR [rcx-1]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strstr
	test	rax, rax
	mov	rdi, rax
	je	SHORT $LN51@GetExpress
	movsxd	rbx, ebx
	npad	10
$LL52@GetExpress:
	lea	rdx, QWORD PTR newlbl$7649[rsp]
	mov	r8, rbx
	mov	rcx, rdi
	call	memcpy
	lea	rcx, QWORD PTR [rbx+rdi]
	lea	rdx, QWORD PTR oldlbl$7648[rsp]
	call	strstr
	test	rax, rax
	mov	rdi, rax
	jne	SHORT $LL52@GetExpress
$LN51@GetExpress:

; 850  :           sprintf(ptr + strlen(ptr), "%s" LABELQUAL EOLSTR, GetLabelStr(nlabel, buff));

	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$5982[rsp]
	mov	r8d, esi
	call	sprintf
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, r12
	lea	r8, QWORD PTR buff$5982[rsp]
	lea	rdx, OFFSET FLAT:$SG5992
	repne scasb
	not	rcx
	dec	rcx
	add	rcx, r12
	call	sprintf

; 851  :         }
; 852  :         else {

	lea	rsi, OFFSET FLAT:$SG5988
	jmp	$LN63@GetExpress
$LN5@GetExpress:

; 853  :           sprintf(ptr + strlen(ptr), "%s" LABELQUAL EOLSTR, GetLabelStr(olabel, buff));

	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$5982[rsp]
	mov	r8d, ebx
	call	sprintf
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, r12
	lea	r8, QWORD PTR buff$5982[rsp]
	lea	rdx, OFFSET FLAT:$SG5994
	repne scasb
	not	rcx
	dec	rcx
	add	rcx, r12
	call	sprintf

; 854  :           ReplaceLabel(buffer, olabel, nlabel);

	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR oldlbl$7673[rsp]
	mov	r8d, ebx
	call	sprintf
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR newlbl$7674[rsp]
	mov	r8d, esi
	call	sprintf
	xor	eax, eax
	lea	rdi, QWORD PTR newlbl$7674[rsp]
	mov	rcx, -1
	lea	rdx, QWORD PTR oldlbl$7673[rsp]
	repne scasb
	not	rcx
	lea	rbx, QWORD PTR [rcx-1]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	strstr
	test	rax, rax
	mov	rdi, rax
	je	SHORT $LN83@GetExpress
	movsxd	rbx, ebx
	npad	11
$LL64@GetExpress:
	lea	rdx, QWORD PTR newlbl$7674[rsp]
	mov	r8, rbx
	mov	rcx, rdi
	call	memcpy
	lea	rcx, QWORD PTR [rbx+rdi]
	lea	rdx, QWORD PTR oldlbl$7673[rsp]
	call	strstr
	test	rax, rax
	mov	rdi, rax
	jne	SHORT $LL64@GetExpress

; 793  :   char *ptr = buffer;

	lea	rsi, OFFSET FLAT:$SG5988
	jmp	SHORT $LN63@GetExpress
$LN83@GetExpress:
	lea	rsi, OFFSET FLAT:$SG5988

; 854  :           ReplaceLabel(buffer, olabel, nlabel);

$LN63@GetExpress:

; 855  :         }
; 856  :         DebugMsg1(("%u GetExpression: dest changed, label added >%s<\n", evallvl, ptr));
; 857  :       }
; 858  :     }
; 859  :     ptr += strlen(ptr);
; 860  :     hllop->lasttruelabel = 0; /* v2.08 */
; 861  :     if (ERROR == GetAndExpression(hll, i, tokenarray, ilabel, is_true, ptr, hllop)) {

	mov	r9d, DWORD PTR ilabel$[rsp]
	xor	eax, eax
	mov	rdi, r12
	mov	QWORD PTR [rsp+48], r13
	mov	rcx, -1
	mov	rdx, r14
	repne scasb
	mov	rdi, QWORD PTR tokenarray$[rsp]
	mov	DWORD PTR [r13+8], eax
	mov	al, BYTE PTR is_true$[rsp]
	not	rcx
	mov	r8, rdi
	dec	rcx
	add	r12, rcx
	mov	rcx, r15
	mov	QWORD PTR [rsp+40], r12
	mov	BYTE PTR [rsp+32], al
	call	GetAndExpression
	cmp	eax, -1
	je	$LN77@GetExpress
	movsxd	rcx, DWORD PTR [r14]
	shl	rcx, 5
	add	rcx, rdi
	call	GetCOp
	mov	bl, BYTE PTR is_true$[rsp]
	mov	edx, 32					; 00000020H
	cmp	eax, 8
	je	$LL12@GetExpress

; 864  :     }
; 865  :   }
; 866  :   if (truelabel > 0) {

	test	ebp, ebp
	je	$LN2@GetExpress

; 867  :     /* v2.08: this is needed, but ober-hackish. to be improved... */
; 868  :     if (hllop->lastjmp && hllop->lasttruelabel) {

	cmp	QWORD PTR [r13], 0
	je	SHORT $LN1@GetExpress
	mov	edx, DWORD PTR [r13+8]
	test	edx, edx
	je	SHORT $LN1@GetExpress

; 869  :       DebugMsg1(("%u GetExpression: suppressed ReplaceLabel %u -> %u, lastjmp=%s\n", evallvl, hllop->lasttruelabel, truelabel, hllop->lastjmp));
; 870  :       ReplaceLabel(ptr, hllop->lasttruelabel, truelabel);

	mov	r8d, ebp
	mov	rcx, r12
	call	ReplaceLabel

; 871  :       *(strchr(hllop->lastjmp, EOLCHAR) + 1) = NULLC;

	mov	rcx, QWORD PTR [r13]
	mov	edx, 10
	call	strchr
	mov	BYTE PTR [rax+1], 0
$LN1@GetExpress:

; 872  :     }
; 873  :     ptr += strlen(ptr);

	xor	eax, eax
	mov	rdi, r12
	mov	rcx, -1
	repne scasb

; 874  :     GetLabelStr(truelabel, ptr);

	lea	rdx, OFFSET FLAT:$SG5756
	mov	r8d, ebp
	not	rcx
	dec	rcx
	add	r12, rcx
	mov	rcx, r12
	call	sprintf

; 875  :     strcat(ptr, LABELQUAL EOLSTR);

	xor	eax, eax
	mov	rdi, r12
	mov	rcx, -1
	lea	rdx, OFFSET FLAT:$SG5998
	repne scasb
	xor	ecx, ecx
	npad	5
$LL81@GetExpress:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL81@GetExpress

; 876  :     DebugMsg1(("%u GetExpression: label added >%s<\n", evallvl, ptr));
; 877  :     hllop->lasttruelabel = truelabel; /* v2.08 */

	mov	DWORD PTR [r13+8], ebp
$LN2@GetExpress:

; 878  :   }
; 879  :   DebugMsg1(("%u GetExpression exit\n", evallvl--));
; 880  :   return(NOT_ERROR);

	xor	eax, eax
$LN84@GetExpress:
	mov	rsi, QWORD PTR [rsp+224]
$LN14@GetExpress:
	mov	r15, QWORD PTR [rsp+184]
	mov	r14, QWORD PTR [rsp+192]
	mov	r13, QWORD PTR [rsp+200]
	mov	r12, QWORD PTR [rsp+208]
	mov	rdi, QWORD PTR [rsp+216]
	mov	rbp, QWORD PTR [rsp+232]
	mov	rbx, QWORD PTR [rsp+240]

; 881  : }

	add	rsp, 248				; 000000f8H
	ret	0
$LN77@GetExpress:

; 862  :       DebugMsg1(("%u GetExpression exit, error\n", evallvl--));
; 863  :       return(ERROR);

	mov	eax, -1
	jmp	SHORT $LN84@GetExpress
GetExpression ENDP
_TEXT	ENDS
EXTRN	AddLineQueue:NEAR
xdata	SEGMENT
$unwind$QueueTestLines DD 030c01H
	DD	08340cH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$QueueTestLines DD @imagerel(QueueTestLines#)
	DD	@imagerel(QueueTestLines#+17)
	DD	@imagerel($unwind$QueueTestLines#)
pdata	ENDS
xdata	SEGMENT
$chain$1$QueueTestLines DD 020521H
	DD	097405H
	DD	@imagerel(QueueTestLines#)
	DD	@imagerel(QueueTestLines#+17)
	DD	@imagerel($unwind$QueueTestLines#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$QueueTestLines DD @imagerel(QueueTestLines#+17)
	DD	@imagerel(QueueTestLines#+85)
	DD	@imagerel($chain$1$QueueTestLines#)
pdata	ENDS
xdata	SEGMENT
$chain$2$QueueTestLines DD 021H
	DD	@imagerel(QueueTestLines#)
	DD	@imagerel(QueueTestLines#+17)
	DD	@imagerel($unwind$QueueTestLines#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$QueueTestLines DD @imagerel(QueueTestLines#+85)
	DD	@imagerel(QueueTestLines#+97)
	DD	@imagerel($chain$2$QueueTestLines#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
src$ = 48
QueueTestLines PROC NEAR

; 890  : {

	sub	rsp, 40					; 00000028H

; 891  :   char *start;
; 892  : 
; 893  :   DebugMsg1(("QueueTestLines(\"%s\") enter\n", src ? src : "NULL"));
; 894  :   while (src) {

	test	rcx, rcx
	mov	QWORD PTR [rsp+64], rbx
	mov	rbx, rcx
	je	SHORT $LN8@QueueTestL
	mov	QWORD PTR [rsp+72], rdi
	npad	10
$LL4@QueueTestL:

; 895  :     //if (*src == ' ') src++; /* v2.11: obsolete */
; 896  :     start = src;
; 897  :     if (src = strchr(src, EOLCHAR))

	mov	edx, 10
	mov	rcx, rbx
	mov	rdi, rbx
	call	strchr
	test	rax, rax
	mov	rbx, rax
	je	SHORT $LN2@QueueTestL

; 898  :       *src++ = NULLC;

	mov	BYTE PTR [rax], 0
	inc	rbx
$LN2@QueueTestL:

; 899  :     if (*start)

	cmp	BYTE PTR [rdi], 0
	je	SHORT $LN1@QueueTestL

; 900  :       AddLineQueue(start);

	mov	rcx, rdi
	call	AddLineQueue
$LN1@QueueTestL:

; 891  :   char *start;
; 892  : 
; 893  :   DebugMsg1(("QueueTestLines(\"%s\") enter\n", src ? src : "NULL"));
; 894  :   while (src) {

	test	rbx, rbx
	jne	SHORT $LL4@QueueTestL
	mov	rdi, QWORD PTR [rsp+72]
$LN8@QueueTestL:

; 901  :   }
; 902  : 
; 903  :   DebugMsg1(("QueueTestLines exit\n"));
; 904  :   return(NOT_ERROR);

	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+64]

; 905  : }

	add	rsp, 40					; 00000028H
	ret	0
QueueTestLines ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$EvaluateHllExpression DD 051001H
	DD	0b7410H
	DD	0c340bH
	DD	0c204H
xdata	ENDS
pdata	SEGMENT
$pdata$EvaluateHllExpression DD @imagerel(EvaluateHllExpression#)
	DD	@imagerel(EvaluateHllExpression#+152)
	DD	@imagerel($unwind$EvaluateHllExpression#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
hllop$ = 64
hll$ = 112
i$ = 120
tokenarray$ = 128
ilabel$ = 136
is_true$ = 144
buffer$ = 152
EvaluateHllExpression PROC NEAR

; 927  : {

	sub	rsp, 104				; 00000068H

; 928  :   struct hll_opnd hllop = { NULL, 0 };

	xor	eax, eax
	mov	QWORD PTR [rsp+96], rbx
	mov	QWORD PTR [rsp+88], rdi
	mov	QWORD PTR hllop$[rsp], rax
	mov	DWORD PTR hllop$[rsp+8], eax

; 929  : 
; 930  :   DebugMsg1(("EvaluateHllExpression enter\n"));
; 931  : 
; 932  :   *buffer = NULLC;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	rdi, rdx

; 933  :   if (ERROR == GetExpression(hll, i, tokenarray, ilabel, is_true, buffer, &hllop))

	lea	rdx, QWORD PTR hllop$[rsp]
	mov	BYTE PTR [rax], 0
	mov	QWORD PTR [rsp+48], rdx
	mov	QWORD PTR [rsp+40], rax
	movzx	eax, BYTE PTR is_true$[rsp]
	mov	rdx, rdi
	mov	rbx, r8
	mov	BYTE PTR [rsp+32], al
	call	GetExpression
	cmp	eax, -1
	jne	SHORT $LN2@EvaluateHl
	mov	rdi, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+96]

; 943  : }

	add	rsp, 104				; 00000068H
	ret	0
$LN2@EvaluateHl:

; 934  :     return(ERROR);
; 935  :   /* v2.11: changed */
; 936  :   //if ( *buffer == EOLCHAR ) {
; 937  :   //DebugMsg(( "EvaluateHllExpression: EOL at pos 0 in line buffer\n" ));
; 938  :   if (tokenarray[*i].token != T_FINAL) {

	movsxd	rax, DWORD PTR [rdi]
	shl	rax, 5
	cmp	BYTE PTR [rax+rbx], 0
	je	SHORT $LN1@EvaluateHl

; 939  :     DebugMsg(("EvaluateHllExpression: unexpected tokens >%s<\n", tokenarray[*i].tokpos));
; 940  :     return(EmitError(SYNTAX_ERROR_IN_CONTROL_FLOW_DIRECTIVE));

	mov	ecx, 199				; 000000c7H
	call	EmitError
	mov	rdi, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+96]

; 943  : }

	add	rsp, 104				; 00000068H
	ret	0
$LN1@EvaluateHl:
	mov	rdi, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+96]

; 941  :   }
; 942  :   return(NOT_ERROR);

	xor	eax, eax

; 943  : }

	add	rsp, 104				; 00000068H
	ret	0
EvaluateHllExpression ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$CheckCXZLines DD 092501H
	DD	097425H
	DD	086416H
	DD	075411H
	DD	06340cH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$CheckCXZLines DD @imagerel(CheckCXZLines#)
	DD	@imagerel(CheckCXZLines#+274)
	DD	@imagerel($unwind$CheckCXZLines#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
p$ = 48
CheckCXZLines PROC NEAR

; 952  : {

	sub	rsp, 40					; 00000028H

; 953  :   int lines = 0;
; 954  :   int i;
; 955  :   int addchars;
; 956  :   char *px;
; 957  :   bool NL = TRUE;
; 958  : 
; 959  :   DebugMsg1(("CheckCXZLines enter, p=>%s<\n", p));
; 960  :   /* syntax ".untilcxz 1" has a problem: there's no "jmp" generated at all.
; 961  :   * if this syntax is to be supported, activate the #if below.
; 962  :   */
; 963  :   for (; *p; p++) {

	movzx	eax, BYTE PTR [rcx]
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	xor	esi, esi
	test	al, al
	mov	rbx, rcx
	mov	bpl, 1
	mov	QWORD PTR [rsp+72], rdi
	je	$LN1@CheckCXZLi
	npad	5
$LL16@CheckCXZLi:

; 964  :     if (*p == EOLCHAR) {

	cmp	al, 10
	jne	SHORT $LN13@CheckCXZLi

; 965  :       NL = TRUE;

	mov	bpl, 1

; 966  :       lines++;

	inc	esi
	jmp	$LN15@CheckCXZLi
$LN13@CheckCXZLi:

; 967  :     }
; 968  :     else if (NL) {

	test	bpl, bpl
	je	$LN15@CheckCXZLi

; 969  :       NL = FALSE;

	xor	bpl, bpl

; 970  :       if (*p == 'j') {

	cmp	al, 106					; 0000006aH
	jne	$LN15@CheckCXZLi

; 971  :         p++;
; 972  :         /* v2.06: rewritten */
; 973  :         if (*p == 'm' && lines == 0) {

	movzx	eax, BYTE PTR [rbx+1]
	cmp	al, 109					; 0000006dH
	jne	SHORT $LN9@CheckCXZLi
	test	esi, esi
	jne	SHORT $LN9@CheckCXZLi

; 974  :           addchars = 2; /* make room for 2 chars, to replace "jmp" by "loope" */

	lea	edx, QWORD PTR [rsi+2]

; 975  :           px = "loope";

	lea	r9, OFFSET FLAT:$SG6044
	jmp	SHORT $LN5@CheckCXZLi
$LN9@CheckCXZLi:

; 976  :         }
; 977  :         else if (lines == 1 && (*p == 'z' || (*p == 'n' && *(p + 1) == 'z'))) {

	cmp	esi, 1
	jne	$LN7@CheckCXZLi
	cmp	al, 122					; 0000007aH
	je	SHORT $LN6@CheckCXZLi
	cmp	al, 110					; 0000006eH
	jne	SHORT $LN7@CheckCXZLi
	cmp	BYTE PTR [rbx+2], 122			; 0000007aH
	jne	SHORT $LN7@CheckCXZLi
$LN6@CheckCXZLi:

; 978  :           addchars = 3; /* make room for 3 chars, to replace "jz"/"jnz" by "loopz"/"loopnz" */

	mov	edx, 3

; 979  :           px = "loop";

	lea	r9, OFFSET FLAT:$SG6048
$LN5@CheckCXZLi:

; 980  :         }
; 981  :         else
; 982  :           return(ERROR); /* anything else is "too complex" */
; 983  :                          //replace_instr:
; 984  :         for (p--, i = strlen(p); i >= 0; i--) {

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	dec	rcx
	movsxd	rcx, ecx
	test	rcx, rcx
	js	SHORT $LN2@CheckCXZLi
	add	rdx, rbx
	npad	4
$LL4@CheckCXZLi:

; 985  :           *(p + addchars + i) = *(p + i);

	movzx	eax, BYTE PTR [rcx+rbx]
	dec	rcx
	mov	BYTE PTR [rdx+rcx+1], al
	jns	SHORT $LL4@CheckCXZLi
$LN2@CheckCXZLi:

; 986  :         }
; 987  :         memcpy(p, px, strlen(px));

	xor	eax, eax
	mov	rdi, r9
	mov	rcx, -1
	repne scasb
	mov	rdx, r9
	not	rcx
	lea	r8, QWORD PTR [rcx-1]
	mov	rcx, rbx
	call	memcpy
$LN15@CheckCXZLi:
	mov	al, BYTE PTR [rbx+1]
	inc	rbx
	test	al, al
	jne	$LL16@CheckCXZLi

; 988  :       }
; 989  : #if 0 /* handle ".untilcxz 1" like masm does */
; 990  :       else if (*p == ' ' && *(p + 1) == EOLCHAR && lines == 0) {
; 991  :         p++;
; 992  :         GetLabelStr(hll->labels[LSTART], p);
; 993  :         strcat(p, EOLSTR);
; 994  :         addchars = 5;
; 995  :         px = "loope";
; 996  :         goto replace_instr;
; 997  :       }
; 998  : #endif
; 999  :     }
; 1000 :   }
; 1001 :   if (lines > 2)

	cmp	esi, 2
	jle	SHORT $LN1@CheckCXZLi
$LN7@CheckCXZLi:

; 1002 :     return(ERROR);

	mov	eax, -1
	jmp	SHORT $LN17@CheckCXZLi
$LN1@CheckCXZLi:

; 1003 :   return(NOT_ERROR);

	xor	eax, eax
$LN17@CheckCXZLi:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 1004 : }

	add	rsp, 40					; 00000028H
	ret	0
CheckCXZLines ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$WriteAsmLine DD 030901H
	DD	0240109H
	DD	07002H
xdata	ENDS
pdata	SEGMENT
$pdata$WriteAsmLine DD @imagerel(WriteAsmLine#)
	DD	@imagerel(WriteAsmLine#+195)
	DD	@imagerel($unwind$WriteAsmLine#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
codebuff$ = 32
cmd$ = 304
s1$ = 312
s2$ = 320
WriteAsmLine PROC NEAR

; 1009 : static void WriteAsmLine(const char *cmd, const char *s1, const char *s2) {

	push	rdi
	sub	rsp, 288				; 00000120H
	mov	r9, rdx

; 1010 :   char codebuff[256];
; 1011 :   strcpy(codebuff, cmd);

	lea	rdx, QWORD PTR codebuff$[rsp]
	sub	rdx, rcx
	npad	12
$LL3@WriteAsmLi:
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx+rcx-1], al
	jne	SHORT $LL3@WriteAsmLi

; 1012 :   strcat(codebuff, s1);

	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
$LL7@WriteAsmLi:
	movzx	eax, BYTE PTR [r9+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL7@WriteAsmLi

; 1013 :   strcat(codebuff, ", ");

	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$[rsp]
	mov	rcx, -1
	repne scasb
	xor	edx, edx
	lea	r9, OFFSET FLAT:$SG6075
	npad	7
$LL6@WriteAsmLi:
	movzx	eax, BYTE PTR [r9+rdx]
	inc	rdx
	test	al, al
	mov	BYTE PTR [rdi+rdx-2], al
	jne	SHORT $LL6@WriteAsmLi

; 1014 :   strcat(codebuff, s2);

	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	14
$LL5@WriteAsmLi:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL5@WriteAsmLi

; 1015 :   AddLineQueue(codebuff);				// MOV RAX,param

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1016 :   return;
; 1017 : }

	add	rsp, 288				; 00000120H
	pop	rdi
	ret	0
WriteAsmLine ENDP
_TEXT	ENDS
EXTRN	_stricmp:NEAR
EXTRN	Tokenize:NEAR
xdata	SEGMENT
$unwind$ForInitAndNext DD 0123b01H
	DD	08f743bH
	DD	08c3426H
	DD	087f422H
	DD	088e41eH
	DD	089d41aH
	DD	08ac416H
	DD	08e6412H
	DD	08d540eH
	DD	08b010aH
xdata	ENDS
pdata	SEGMENT
$pdata$ForInitAndNext DD @imagerel(ForInitAndNext#)
	DD	@imagerel(ForInitAndNext#+7525)
	DD	@imagerel($unwind$ForInitAndNext#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
op$ = 32
codebuff$7908 = 48
codebuff$7902 = 48
codebuff$7896 = 48
codebuff$7889 = 48
codebuff$7883 = 48
codebuff$7877 = 48
codebuff$7871 = 48
codebuff$7865 = 48
codebuff$7859 = 48
codebuff$7853 = 48
codebuff$7847 = 48
codebuff$7840 = 48
codebuff$7833 = 48
codebuff$7826 = 48
codebuff$7819 = 48
codebuff$7812 = 48
codebuff$7805 = 48
codebuff$7798 = 48
codebuff$7791 = 48
codebuff$7784 = 48
codebuff$7777 = 48
codebuff$ = 304
init$ = 560
param$ = 816
tokenarray$ = 1120
cnt$ = 1128
buff$ = 1136
ForInitAndNext PROC NEAR

; 1018 : static ret_code ForInitAndNext(struct asm_tok tokenarray[], int cnt, char *buff) {

	mov	rax, rsp
	sub	rsp, 1112				; 00000458H
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax-8], r12
	mov	QWORD PTR [rax-16], r13
	mov	QWORD PTR [rax-24], r14
	mov	QWORD PTR [rax-32], r15
	mov	QWORD PTR [rax+8], rbx

; 1019 :   int a;
; 1020 :   int j;
; 1021 :   int	b = 0;

	xor	ebp, ebp
	mov	r13, r8
	mov	esi, edx
	mov	r14, rcx

; 1022 :   bool brct = 0;

	lea	r15, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [rax+32], rdi
	xor	r12b, r12b
	npad	2
$LL124@ForInitAnd:

; 1023 :   char codebuff[256];
; 1024 :   char param[256];
; 1025 :   char init[256];
; 1026 :   char op[4];
; 1027 :   char *p;
; 1028 :   //create valid command and add to LineQueue
; 1029 :   do {
; 1030 :     //extracting the first parameter "param" before the operator
; 1031 :     a = 0;
; 1032 :     while (buff[b] && !strchr("=!<>&|-+*^%/", buff[b]))

	movsxd	rax, ebp
	xor	ebx, ebx
	lea	rdi, QWORD PTR [rax+r13]
	cmp	BYTE PTR [rdi], bl
	je	SHORT $LN300@ForInitAnd
	npad	3
$LL121@ForInitAnd:
	movsx	edx, BYTE PTR [rdi]
	lea	rcx, OFFSET FLAT:$SG6099
	call	strchr
	test	rax, rax
	jne	SHORT $LN300@ForInitAnd

; 1033 :     {
; 1034 :       if (buff[b] == '-' || buff[b] == '+') break;

	movzx	eax, BYTE PTR [rdi]
	cmp	al, 45					; 0000002dH
	je	SHORT $LN300@ForInitAnd
	cmp	al, 43					; 0000002bH
	je	SHORT $LN300@ForInitAnd

; 1035 :       param[a] = buff[b];
; 1036 :       b++;

	inc	rdi
	mov	BYTE PTR param$[rsp+rbx], al
	inc	ebp

; 1037 :       a++;

	inc	rbx
	cmp	BYTE PTR [rdi], 0
	jne	SHORT $LL121@ForInitAnd
$LN300@ForInitAnd:

; 1038 :     }
; 1039 :     param[a] = '\0';
; 1040 :     //end of param
; 1041 :     //is it simple operator
; 1042 :     if ((buff[b + 1] == '+') || (buff[b + 1] == '-')) {            //if ++ or -- finish it here

	movsxd	rcx, ebp
	mov	BYTE PTR param$[rsp+rbx], 0
	movzx	eax, BYTE PTR [rcx+r13+1]
	cmp	al, 43					; 0000002bH
	je	$LN116@ForInitAnd
	cmp	al, 45					; 0000002dH
	je	$LN116@ForInitAnd

; 1049 :     }
; 1050 : 
; 1051 :     //we finis here "inc REX" or  "dec REX" or "inc mem" or "dec mem"
; 1052 :     else						//if not ++ or --
; 1053 :     {							//extracting the operator
; 1054 :       op[0] = buff[b];

	movzx	ebx, BYTE PTR [rcx+r13]

; 1055 :       b++;

	inc	ebp

; 1056 :       if (op[0] == '=') {     //if operator is only '='

	cmp	bl, 61					; 0000003dH
	mov	BYTE PTR op$[rsp], bl
	jne	SHORT $LN111@ForInitAnd

; 1057 :         op[1] = '\0';       //finish here

	xor	dil, dil
	mov	BYTE PTR op$[rsp+1], dil

; 1058 :       }
; 1059 :       else {                 //extract next operator

	jmp	SHORT $LN107@ForInitAnd
$LN111@ForInitAnd:

; 1060 :         op[1] = buff[b];

	movsxd	rax, ebp

; 1061 :         b++;

	inc	ebp
	movzx	edi, BYTE PTR [rax+r13]

; 1062 :         if ((op[1] == '<' || op[1] == '>') && (buff[b] == '=')) {

	cmp	dil, 60					; 0000003cH
	mov	BYTE PTR op$[rsp+1], dil
	je	SHORT $LN108@ForInitAnd
	cmp	dil, 62					; 0000003eH
	jne	SHORT $LN109@ForInitAnd
$LN108@ForInitAnd:
	movsxd	rax, ebp
	cmp	BYTE PTR [rax+r13], 61			; 0000003dH
	jne	SHORT $LN109@ForInitAnd

; 1063 :           op[2] = buff[b]; //if a second operator is shift sign "<<=" or ">>="

	mov	BYTE PTR op$[rsp+2], 61			; 0000003dH

; 1064 :           op[3] = NULLC;

	mov	BYTE PTR op$[rsp+3], 0

; 1065 :           b++;

	inc	ebp
	jmp	SHORT $LN107@ForInitAnd
$LN109@ForInitAnd:

; 1066 :         }
; 1067 :         else op[2] = NULLC; //not shift so we have two operands

	mov	BYTE PTR op$[rsp+2], 0
$LN107@ForInitAnd:

; 1068 : 
; 1069 :       }
; 1070 :       //we finished with param and op
; 1071 :       //now extracting the second parameter "init" after the operator
; 1072 :       for (a = 0; buff[b];) { //checking if we have a char in a single ' '

	movsxd	rax, ebp
	xor	edx, edx
	cmp	BYTE PTR [rax+r13], dl
	je	SHORT $LN301@ForInitAnd
	movzx	ecx, BYTE PTR [rax+r13]
$LL106@ForInitAnd:

; 1073 :         if (buff[b] == '(' && buff[b - 1] != 39 && buff[b + 1] != 39 && b) break;

	cmp	cl, 40					; 00000028H
	jne	SHORT $LN104@ForInitAnd
	cmp	BYTE PTR [rax+r13-1], 39		; 00000027H
	je	SHORT $LN103@ForInitAnd
	cmp	BYTE PTR [rax+r13+1], 39		; 00000027H
	je	SHORT $LN103@ForInitAnd
	test	rax, rax
	jne	SHORT $LN301@ForInitAnd

; 1074 :         if (buff[b] == ',' && buff[b - 1] != 39 && buff[b + 1] != 39 && b) break;

	jmp	SHORT $LN103@ForInitAnd
$LN104@ForInitAnd:
	cmp	cl, 44					; 0000002cH
	jne	SHORT $LN103@ForInitAnd
	cmp	BYTE PTR [rax+r13-1], 39		; 00000027H
	je	SHORT $LN103@ForInitAnd
	cmp	BYTE PTR [rax+r13+1], 39		; 00000027H
	je	SHORT $LN103@ForInitAnd
	test	rax, rax
	jne	SHORT $LN301@ForInitAnd
$LN103@ForInitAnd:

; 1075 :         init[a] = buff[b];
; 1076 :         b++;

	inc	rax
	mov	BYTE PTR init$[rsp+rdx], cl
	inc	ebp
	mov	cl, BYTE PTR [rax+r13]

; 1077 :         a++;

	inc	rdx
	test	cl, cl
	jne	SHORT $LL106@ForInitAnd
$LN301@ForInitAnd:

; 1078 :       }
; 1079 :       if (buff[b] == '(' && buff[b - 1] != 39 && buff[b + 1] != 39 && b) {

	movsxd	rax, ebp
	cmp	BYTE PTR [rax+r13], 40			; 00000028H
	jne	SHORT $LN102@ForInitAnd
	cmp	BYTE PTR [rax+r13-1], 39		; 00000027H
	je	SHORT $LN102@ForInitAnd
	cmp	BYTE PTR [rax+r13+1], 39		; 00000027H
	je	SHORT $LN102@ForInitAnd
	test	ebp, ebp
	je	SHORT $LN102@ForInitAnd
	lea	rcx, QWORD PTR [rax+r13]

; 1080 :         for (; buff[b] && buff[b] != ')'; b++, a++) {

	movzx	eax, BYTE PTR [rax+r13]
	npad	6
$LL101@ForInitAnd:
	cmp	al, 41					; 00000029H
	je	SHORT $LN99@ForInitAnd
	inc	rcx

; 1081 :           init[a] = buff[b];

	mov	BYTE PTR init$[rsp+rdx], al
	inc	ebp
	mov	al, BYTE PTR [rcx]
	inc	rdx
	test	al, al
	jne	SHORT $LL101@ForInitAnd
$LN99@ForInitAnd:

; 1082 :         }
; 1083 :         if (buff[b] == ')' && buff[b - 1] != 39 && buff[b + 1] != 39) {

	movsxd	rax, ebp
	cmp	BYTE PTR [rax+r13], 41			; 00000029H
	jne	SHORT $LN98@ForInitAnd
	cmp	BYTE PTR [rax+r13-1], 39		; 00000027H
	je	SHORT $LN98@ForInitAnd
	cmp	BYTE PTR [rax+r13+1], 39		; 00000027H
	je	SHORT $LN98@ForInitAnd

; 1084 :           init[a] = buff[b];

	mov	BYTE PTR init$[rsp+rdx], 41		; 00000029H

; 1085 :           b++;

	inc	ebp

; 1086 :           a++;

	inc	rdx
$LN98@ForInitAnd:

; 1087 :         }
; 1088 :         brct = TRUE;

	mov	r12b, 1
$LN102@ForInitAnd:

; 1089 :       }
; 1090 :       init[a] = NULLC;
; 1091 :       b++;

	inc	ebp

; 1092 :       //we finished with init
; 1093 :       //is operator devision, multiplication or mod
; 1094 :       if (op[0] == '/' || op[0] == '*' || op[0] == '%') {

	cmp	bl, 47					; 0000002fH
	mov	BYTE PTR init$[rsp+rdx], 0
	je	$LN96@ForInitAnd
	cmp	bl, 42					; 0000002aH
	je	$LN96@ForInitAnd
	cmp	bl, 37					; 00000025H
	je	$LN96@ForInitAnd

; 1185 :         }
; 1186 :       }
; 1187 :       //if operator not devision, multiplication or mod
; 1188 :       else if (op[0] == '-') strcpy(codebuff, " sub ");

	cmp	bl, 45					; 0000002dH
	jne	SHORT $LN55@ForInitAnd
	mov	eax, DWORD PTR $SG6197[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6197[r15+4]
	mov	WORD PTR [rcx+4], ax
	jmp	$LN62@ForInitAnd
$LN55@ForInitAnd:

; 1189 :       else if (op[0] == '+') strcpy(codebuff, " add ");

	cmp	bl, 43					; 0000002bH
	jne	SHORT $LN53@ForInitAnd
	mov	eax, DWORD PTR $SG6200[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6200[r15+4]
	mov	WORD PTR [rcx+4], ax
	jmp	$LN62@ForInitAnd
$LN53@ForInitAnd:

; 1190 :       else if (op[0] == '&') strcpy(codebuff, " and ");

	cmp	bl, 38					; 00000026H
	jne	SHORT $LN51@ForInitAnd
	mov	eax, DWORD PTR $SG6203[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6203[r15+4]
	mov	WORD PTR [rcx+4], ax
	jmp	$LN62@ForInitAnd
$LN51@ForInitAnd:

; 1191 :       else if (op[0] == '|') strcpy(codebuff, " or ");

	cmp	bl, 124					; 0000007cH
	jne	SHORT $LN49@ForInitAnd
	mov	eax, DWORD PTR $SG6206[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, BYTE PTR $SG6206[r15+4]
	mov	BYTE PTR [rcx+4], al
	jmp	$LN62@ForInitAnd
$LN49@ForInitAnd:

; 1192 :       else if (op[0] == '^') strcpy(codebuff, " xor ");

	cmp	bl, 94					; 0000005eH
	jne	SHORT $LN47@ForInitAnd
	mov	eax, DWORD PTR $SG6209[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6209[r15+4]
	mov	WORD PTR [rcx+4], ax
	jmp	$LN62@ForInitAnd
$LN47@ForInitAnd:

; 1193 :       else if (op[0] == '<' && op[1] == '<') strcpy(codebuff, " shl ");

	cmp	bl, 60					; 0000003cH
	jne	SHORT $LN45@ForInitAnd
	cmp	dil, bl
	jne	$LN62@ForInitAnd
	mov	eax, DWORD PTR $SG6212[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6212[r15+4]
	mov	WORD PTR [rcx+4], ax
	jmp	$LN62@ForInitAnd
$LN45@ForInitAnd:

; 1194 :       else if (op[0] == '>' && op[1] == '>') strcpy(codebuff, " shr ");

	cmp	bl, 62					; 0000003eH
	jne	$LN62@ForInitAnd
	cmp	dil, bl
	jne	$LN62@ForInitAnd
	mov	eax, DWORD PTR $SG6215[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6215[r15+4]
	mov	WORD PTR [rcx+4], ax
	jmp	$LN62@ForInitAnd
$LN96@ForInitAnd:

; 1095 :         Tokenize(param, 0, tokenarray, 0);

	lea	rcx, QWORD PTR param$[rsp]
	xor	r9d, r9d
	mov	r8, r14
	xor	edx, edx
	call	Tokenize

; 1096 :         if (strcasecmp(param, reax[ModuleInfo.Ofssize]) && strcasecmp(init, reax[ModuleInfo.Ofssize])) { //param not rax init not rax?

	movzx	edx, BYTE PTR ModuleInfo+404
	lea	rcx, QWORD PTR param$[rsp]
	mov	rdx, QWORD PTR reax[r15+rdx*8]
	call	_stricmp
	test	eax, eax
	je	$LN95@ForInitAnd
	movzx	edx, BYTE PTR ModuleInfo+404
	lea	rcx, QWORD PTR init$[rsp]
	mov	rdx, QWORD PTR reax[r15+rdx*8]
	call	_stricmp
	test	eax, eax
	je	$LN95@ForInitAnd

; 1097 :           if (tokenarray[0].token == T_REG) {			//is param register

	movzx	eax, BYTE PTR [r14]
	cmp	al, 2
	jne	$LN94@ForInitAnd

; 1098 :             if (strcasecmp(param, recx[ModuleInfo.Ofssize])) {				//make sure that param is not rcx

	movzx	edx, BYTE PTR ModuleInfo+404
	lea	rcx, QWORD PTR param$[rsp]
	mov	rdx, QWORD PTR recx[r15+rdx*8]
	call	_stricmp
	test	eax, eax
	je	$LN127@ForInitAnd

; 1099 :               WriteAsmLine(" mov  ", reax[ModuleInfo.Ofssize], param);				// MOV RAX,param

	movzx	eax, BYTE PTR ModuleInfo+404
	xor	ecx, ecx
	mov	rdx, QWORD PTR reax[r15+rax*8]
	npad	4
$LL129@ForInitAnd:
	movzx	eax, BYTE PTR $SG6130[rcx+r15]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7777[rsp+rcx-1], al
	jne	SHORT $LL129@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7777[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	10
$LL298@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL298@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7777[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, OFFSET FLAT:$SG6075
	npad	8
$LL297@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL297@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7777[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, QWORD PTR param$[rsp]
	npad	7
$LL296@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL296@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7777[rsp]
	call	AddLineQueue
$LN127@ForInitAnd:

; 1100 :             }						if (op[0] == '/' || op[0] == '%') {

	cmp	bl, 47					; 0000002fH
	je	SHORT $LN91@ForInitAnd
	cmp	bl, 37					; 00000025H
	jne	SHORT $LN92@ForInitAnd
$LN91@ForInitAnd:

; 1101 :               strcpy(codebuff, " cdq ");			//extend to RDX if division

	mov	eax, DWORD PTR $SG6133[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6133[r15+4]
	mov	WORD PTR [rcx+4], ax

; 1102 :               AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue
$LN92@ForInitAnd:

; 1103 :             }
; 1104 :             Tokenize(init, 0, tokenarray, 0);

	lea	rcx, QWORD PTR init$[rsp]
	xor	r9d, r9d
	mov	r8, r14
	xor	edx, edx
	call	Tokenize

; 1105 :             if (tokenarray[0].token == T_NUM) {      //is init number?

	cmp	BYTE PTR [r14], 10
	jne	$LN90@ForInitAnd

; 1106 :               WriteAsmLine(" mov  ", recx[ModuleInfo.Ofssize], init);        //MOV RCX,init

	movzx	eax, BYTE PTR ModuleInfo+404
	xor	ecx, ecx
	mov	rdx, QWORD PTR recx[r15+rax*8]
	npad	3
$LL132@ForInitAnd:
	movzx	eax, BYTE PTR $SG6135[rcx+r15]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7784[rsp+rcx-1], al
	jne	SHORT $LL132@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7784[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	10
$LL295@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL295@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7784[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG6075
	npad	8
$LL294@ForInitAnd:
	movzx	eax, BYTE PTR [r15+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL294@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7784[rsp]
	mov	rcx, -1
	repne scasb
	lea	r15, OFFSET FLAT:__ImageBase
	lea	rdx, QWORD PTR init$[rsp]
	xor	ecx, ecx
$LL293@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL293@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7784[rsp]
	call	AddLineQueue

; 1107 :               if (op[0] == '/' || op[0] == '%')

	cmp	bl, 47					; 0000002fH
	je	SHORT $LN88@ForInitAnd
	cmp	bl, 37					; 00000025H
	je	SHORT $LN88@ForInitAnd

; 1109 :               else strcpy(codebuff, " imul ");		//IMUL RCX

	mov	eax, DWORD PTR $SG6140[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6140[r15+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR $SG6140[r15+6]
	mov	BYTE PTR [rcx+6], al
	jmp	SHORT $LN87@ForInitAnd
$LN88@ForInitAnd:

; 1108 :                 strcpy(codebuff, " idiv ");		//IDIV RCX

	mov	eax, DWORD PTR $SG6138[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6138[r15+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR $SG6138[r15+6]
	mov	BYTE PTR [rcx+6], al
$LN87@ForInitAnd:

; 1110 :               strcat(codebuff, recx[ModuleInfo.Ofssize]);

	movzx	edx, BYTE PTR ModuleInfo+404
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$[rsp]
	mov	r8, QWORD PTR recx[r15+rdx*8]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	6
$LL292@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL292@ForInitAnd

; 1111 :               AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1112 :               goto cont;

	jmp	$cont$6141
$LN90@ForInitAnd:

; 1113 :             }
; 1114 :             else {
; 1115 :               if (op[0] == '/' || op[0] == '%') //it is a variable

	cmp	bl, 47					; 0000002fH
	je	SHORT $LN84@ForInitAnd
	cmp	bl, 37					; 00000025H
	je	SHORT $LN84@ForInitAnd

; 1117 :               else strcpy(codebuff, " imul ");

	mov	eax, DWORD PTR $SG6147[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6147[r15+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR $SG6147[r15+6]
	mov	BYTE PTR [rcx+6], al
	jmp	SHORT $LN83@ForInitAnd
$LN84@ForInitAnd:

; 1116 :                 strcpy(codebuff, " idiv ");

	mov	eax, DWORD PTR $SG6145[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6145[r15+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR $SG6145[r15+6]
	mov	BYTE PTR [rcx+6], al
$LN83@ForInitAnd:

; 1118 :               strcat(codebuff, init);

	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, QWORD PTR init$[rsp]
	npad	5
$LL291@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL291@ForInitAnd

; 1119 :               AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1120 :               goto cont;

	jmp	$cont$6141
$LN94@ForInitAnd:

; 1121 :             }
; 1122 :           }
; 1123 :           //if param is a variable
; 1124 :           else if (tokenarray[0].token == T_ID) {		 //YES

	cmp	al, 8
	jne	$LN62@ForInitAnd

; 1125 :             WriteAsmLine(" mov  ", recx[ModuleInfo.Ofssize], init);        //MOV RCX,init

	movzx	eax, BYTE PTR ModuleInfo+404
	xor	ecx, ecx
	mov	rdx, QWORD PTR recx[r15+rax*8]
	npad	6
$LL135@ForInitAnd:
	movzx	eax, BYTE PTR $SG6150[rcx+r15]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7791[rsp+rcx-1], al
	jne	SHORT $LL135@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7791[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	10
$LL290@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL290@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7791[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG6075
	npad	8
$LL289@ForInitAnd:
	movzx	eax, BYTE PTR [r15+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL289@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7791[rsp]
	mov	rcx, -1
	repne scasb
	lea	r15, OFFSET FLAT:__ImageBase
	lea	rdx, QWORD PTR init$[rsp]
	xor	ecx, ecx
$LL288@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL288@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7791[rsp]
	call	AddLineQueue

; 1126 :             WriteAsmLine(" mov  ", reax[ModuleInfo.Ofssize], param);		// MOV RAX,param

	movzx	edx, BYTE PTR ModuleInfo+404
	xor	ecx, ecx
	mov	r8, QWORD PTR reax[r15+rdx*8]
	npad	5
$LL138@ForInitAnd:
	movzx	eax, BYTE PTR $SG6151[rcx+r15]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7798[rsp+rcx-1], al
	jne	SHORT $LL138@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7798[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	10
$LL287@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL287@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7798[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG6075
	npad	7
$LL286@ForInitAnd:
	movzx	eax, BYTE PTR [r15+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL286@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7798[rsp]
	mov	rcx, -1
	repne scasb
	lea	r15, OFFSET FLAT:__ImageBase
	lea	rdx, QWORD PTR param$[rsp]
	xor	ecx, ecx
$LL285@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL285@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7798[rsp]
	call	AddLineQueue

; 1127 :             if (op[0] == '/' || op[0] == '%') {

	cmp	bl, 47					; 0000002fH
	je	SHORT $LN79@ForInitAnd
	cmp	bl, 37					; 00000025H
	je	SHORT $LN79@ForInitAnd

; 1131 :             }
; 1132 :             else strcpy(codebuff, " imul ");

	mov	eax, DWORD PTR $SG6157[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6157[r15+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR $SG6157[r15+6]
	mov	BYTE PTR [rcx+6], al
	jmp	SHORT $LN78@ForInitAnd
$LN79@ForInitAnd:

; 1128 :               strcpy(codebuff, " cdq ");

	mov	eax, DWORD PTR $SG6154[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6154[r15+4]
	mov	WORD PTR [rcx+4], ax

; 1129 :               AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1130 :               strcpy(codebuff, " idiv ");

	mov	eax, DWORD PTR $SG6155[r15]
	lea	rdx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rdx], eax
	movzx	eax, WORD PTR $SG6155[r15+4]
	mov	WORD PTR [rdx+4], ax
	movzx	eax, BYTE PTR $SG6155[r15+6]
	mov	BYTE PTR [rdx+6], al
$LN78@ForInitAnd:

; 1133 :             strcat(codebuff, recx[ModuleInfo.Ofssize]);

	movzx	edx, BYTE PTR ModuleInfo+404
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$[rsp]
	mov	r8, QWORD PTR recx[r15+rdx*8]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	12
$LL284@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL284@ForInitAnd

; 1134 :             AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue
$cont$6141:

; 1135 :           cont:
; 1136 :             if (op[0] == '%') {

	cmp	bl, 37					; 00000025H
	jne	$LN77@ForInitAnd

; 1137 :               WriteAsmLine(" mov  ", param, redx[ModuleInfo.Ofssize]);

	movzx	eax, BYTE PTR ModuleInfo+404
	xor	ecx, ecx
	mov	rdx, QWORD PTR redx[r15+rax*8]
	npad	9
$LL141@ForInitAnd:
	movzx	eax, BYTE PTR $SG6159[rcx+r15]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7805[rsp+rcx-1], al
	jne	SHORT $LL141@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7805[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r8, QWORD PTR param$[rsp]
	npad	2
$LL283@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL283@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7805[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG6075
	npad	7
$LL282@ForInitAnd:
	movzx	eax, BYTE PTR [r15+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL282@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7805[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:__ImageBase
	npad	7
$LL281@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL281@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7805[rsp]
	call	AddLineQueue

; 1138 :               goto skip;

	jmp	$skip$6160
$LN77@ForInitAnd:

; 1139 :             }
; 1140 :             else {
; 1141 :               WriteAsmLine(" mov  ", param, reax[ModuleInfo.Ofssize]);

	movzx	eax, BYTE PTR ModuleInfo+404
	xor	ecx, ecx
	mov	rdx, QWORD PTR reax[r15+rax*8]
	npad	1
$LL144@ForInitAnd:
	movzx	eax, BYTE PTR $SG6162[rcx+r15]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7812[rsp+rcx-1], al
	jne	SHORT $LL144@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7812[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r8, QWORD PTR param$[rsp]
	npad	2
$LL280@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL280@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7812[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG6075
	npad	7
$LL279@ForInitAnd:
	movzx	eax, BYTE PTR [r15+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL279@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7812[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:__ImageBase
	npad	7
$LL278@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL278@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7812[rsp]
	call	AddLineQueue

; 1142 :               goto skip;

	jmp	$skip$6160
$LN95@ForInitAnd:

; 1143 :             }
; 1144 :           }
; 1145 :         }
; 1146 :         // if param is not RAX and init is RCX
; 1147 :         else if ((strcasecmp(param, reax[ModuleInfo.Ofssize]) && !(strcasecmp(init, recx[ModuleInfo.Ofssize])))) {

	movzx	edx, BYTE PTR ModuleInfo+404
	lea	rcx, QWORD PTR param$[rsp]
	mov	rdx, QWORD PTR reax[r15+rdx*8]
	call	_stricmp
	test	eax, eax
	je	$LN74@ForInitAnd
	movzx	edx, BYTE PTR ModuleInfo+404
	lea	rcx, QWORD PTR init$[rsp]
	mov	rdx, QWORD PTR recx[r15+rdx*8]
	call	_stricmp
	test	eax, eax
	jne	$LN74@ForInitAnd

; 1148 :           if (op[0] == '/' || op[0] == '%') {

	cmp	bl, 47					; 0000002fH
	je	SHORT $LN72@ForInitAnd
	cmp	bl, 37					; 00000025H
	je	SHORT $LN72@ForInitAnd

; 1152 :           }
; 1153 :           else strcpy(codebuff, " imul ");

	mov	eax, DWORD PTR $SG6170[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6170[r15+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR $SG6170[r15+6]
	mov	BYTE PTR [rcx+6], al
	jmp	SHORT $LN71@ForInitAnd
$LN72@ForInitAnd:

; 1149 :             strcpy(codebuff, " cdq ");

	mov	eax, DWORD PTR $SG6167[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6167[r15+4]
	mov	WORD PTR [rcx+4], ax

; 1150 :             AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1151 :             strcpy(codebuff, " idiv ");

	mov	eax, DWORD PTR $SG6168[r15]
	lea	rdx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rdx], eax
	movzx	eax, WORD PTR $SG6168[r15+4]
	mov	WORD PTR [rdx+4], ax
	movzx	eax, BYTE PTR $SG6168[r15+6]
	mov	BYTE PTR [rdx+6], al
$LN71@ForInitAnd:

; 1154 :           strcat(codebuff, recx[ModuleInfo.Ofssize]);

	movzx	edx, BYTE PTR ModuleInfo+404
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$[rsp]
	mov	r8, QWORD PTR recx[r15+rdx*8]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
$LL277@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL277@ForInitAnd

; 1155 :           AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1156 :           if (op[0] == '%') WriteAsmLine(" mov  ", param, redx[ModuleInfo.Ofssize]);

	cmp	bl, 37					; 00000025H
	jne	$skip$6160
	movzx	eax, BYTE PTR ModuleInfo+404
	xor	ecx, ecx
	mov	rdx, QWORD PTR redx[r15+rax*8]
	npad	9
$LL147@ForInitAnd:
	movzx	eax, BYTE PTR $SG6172[rcx+r15]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7819[rsp+rcx-1], al
	jne	SHORT $LL147@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7819[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r8, QWORD PTR param$[rsp]
	npad	2
$LL276@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL276@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7819[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG6075
	npad	7
$LL275@ForInitAnd:
	movzx	eax, BYTE PTR [r15+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL275@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7819[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:__ImageBase
	npad	7
$LL274@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL274@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7819[rsp]
	call	AddLineQueue
	jmp	$skip$6160
$LN74@ForInitAnd:

; 1157 :           goto skip;
; 1158 :         }
; 1159 :         // if param is RAX and init is RCX
; 1160 :         else if ((!(strcasecmp(param, reax[ModuleInfo.Ofssize])) && (!(strcmp(init, recx[ModuleInfo.Ofssize]))))) {

	movzx	edx, BYTE PTR ModuleInfo+404
	lea	rcx, QWORD PTR param$[rsp]
	mov	rdx, QWORD PTR reax[r15+rdx*8]
	call	_stricmp
	movzx	r8d, BYTE PTR ModuleInfo+404
	test	eax, eax
	jne	$LN68@ForInitAnd
	movzx	eax, r8b
	lea	rcx, QWORD PTR init$[rsp]
	mov	rdi, QWORD PTR recx[r15+rax*8]
	sub	rdi, rcx
$LL272@ForInitAnd:
	movzx	edx, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rcx+rdi]
	sub	edx, eax
	jne	SHORT $LN273@ForInitAnd
	inc	rcx
	test	eax, eax
	jne	SHORT $LL272@ForInitAnd
$LN273@ForInitAnd:
	test	edx, edx
	jne	$LN68@ForInitAnd

; 1161 :           if (op[0] == '/' || op[0] == '%') {

	cmp	bl, 47					; 0000002fH
	je	SHORT $LN66@ForInitAnd
	cmp	bl, 37					; 00000025H
	je	SHORT $LN66@ForInitAnd

; 1165 :           }
; 1166 :           else strcpy(codebuff, " imul ");

	mov	eax, DWORD PTR $SG6180[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6180[r15+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR $SG6180[r15+6]
	mov	BYTE PTR [rcx+6], al
	jmp	SHORT $LN65@ForInitAnd
$LN66@ForInitAnd:

; 1162 :             strcpy(codebuff, " cdq ");

	mov	eax, DWORD PTR $SG6177[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6177[r15+4]
	mov	WORD PTR [rcx+4], ax

; 1163 :             AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1164 :             strcpy(codebuff, " idiv ");

	mov	eax, DWORD PTR $SG6178[r15]
	mov	r8b, BYTE PTR ModuleInfo+404
	lea	rdx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rdx], eax
	movzx	eax, WORD PTR $SG6178[r15+4]
	mov	WORD PTR [rdx+4], ax
	movzx	eax, BYTE PTR $SG6178[r15+6]
	mov	BYTE PTR [rdx+6], al
$LN65@ForInitAnd:

; 1167 :           strcat(codebuff, recx[ModuleInfo.Ofssize]);

	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$[rsp]
	movzx	edx, r8b
	mov	r8, QWORD PTR recx[r15+rdx*8]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	7
$LL271@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL271@ForInitAnd

; 1168 :           AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1169 :           if (op[0] == '%') WriteAsmLine(" mov  ", param, redx[ModuleInfo.Ofssize]);

	cmp	bl, 37					; 00000025H
	jne	$skip$6160
	movzx	eax, BYTE PTR ModuleInfo+404
	xor	ecx, ecx
	mov	rdx, QWORD PTR redx[r15+rax*8]
	npad	9
$LL150@ForInitAnd:
	movzx	eax, BYTE PTR $SG6182[rcx+r15]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7826[rsp+rcx-1], al
	jne	SHORT $LL150@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7826[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r8, QWORD PTR param$[rsp]
	npad	2
$LL270@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL270@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7826[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG6075
	npad	7
$LL269@ForInitAnd:
	movzx	eax, BYTE PTR [r15+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL269@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7826[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:__ImageBase
	npad	7
$LL268@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL268@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7826[rsp]
	call	AddLineQueue
	jmp	$skip$6160
$LN68@ForInitAnd:

; 1170 :           goto skip;
; 1171 :         }
; 1172 :         // if param is RAX and init is not RCX
; 1173 :         else if (!(strcasecmp(param, reax[ModuleInfo.Ofssize]) && (strcasecmp(init, recx[ModuleInfo.Ofssize])))) {

	movzx	edx, r8b
	lea	rcx, QWORD PTR param$[rsp]
	mov	rdx, QWORD PTR reax[r15+rdx*8]
	call	_stricmp
	test	eax, eax
	je	$LN61@ForInitAnd
	movzx	edx, BYTE PTR ModuleInfo+404
	lea	rcx, QWORD PTR init$[rsp]
	mov	rdx, QWORD PTR recx[r15+rdx*8]
	call	_stricmp
	test	eax, eax
	je	$LN61@ForInitAnd
$LN62@ForInitAnd:

; 1195 :       Tokenize(init, 0, tokenarray, 0);

	lea	rcx, QWORD PTR init$[rsp]
	xor	r9d, r9d
	mov	r8, r14
	xor	edx, edx
	call	Tokenize

; 1196 :       if (tokenarray[0].token == T_REG || tokenarray[0].token == T_NUM || tokenarray[0].token == T_FLOAT || tokenarray[0].token == T_DIRECTIVE)

	movzx	edx, BYTE PTR [r14]
	cmp	dl, 2
	je	$simple$6218
	cmp	dl, 10
	je	$simple$6218
	cmp	dl, 11
	je	$simple$6218
	cmp	dl, 3
	je	$simple$6218

; 1197 :         goto simple;
; 1198 :       Tokenize(param, 0, tokenarray, 0);

	lea	rcx, QWORD PTR param$[rsp]
	xor	r9d, r9d
	mov	r8, r14
	xor	edx, edx
	call	Tokenize

; 1199 :       if (tokenarray[0].token == T_REG) {

	cmp	BYTE PTR [r14], 2
	je	$simple$6218

; 1250 :       {
; 1251 :         if (init[0] == 39 && init[2] == 39)

	cmp	BYTE PTR init$[rsp], 39			; 00000027H
	jne	$LN3@ForInitAnd
	cmp	BYTE PTR init$[rsp+2], 39		; 00000027H
	jne	$LN3@ForInitAnd

; 1252 :           WriteAsmLine(" mov  byte ptr ", param, init);

	xor	ecx, ecx
	npad	3
$LL189@ForInitAnd:
	movzx	eax, BYTE PTR $SG6276[rcx+r15]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7908[rsp+rcx-1], al
	jne	SHORT $LL189@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7908[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, QWORD PTR param$[rsp]
	npad	2
$LL267@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL267@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7908[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG6075
	npad	8
$LL266@ForInitAnd:
	movzx	eax, BYTE PTR [r15+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL266@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7908[rsp]
	mov	rcx, -1
	repne scasb
	lea	r15, OFFSET FLAT:__ImageBase
	lea	rdx, QWORD PTR init$[rsp]
	xor	ecx, ecx
$LL265@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL265@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7908[rsp]
	call	AddLineQueue

; 1253 :         else {

	jmp	$skip$6160
$LN3@ForInitAnd:

; 1254 :           WriteAsmLine(" mov  ", reax[ModuleInfo.Ofssize], init);

	movzx	edx, BYTE PTR ModuleInfo+404
	lea	r8, QWORD PTR init$[rsp]
	lea	rcx, OFFSET FLAT:$SG6278
	mov	rdx, QWORD PTR reax[r15+rdx*8]
	call	WriteAsmLine

; 1255 :           WriteAsmLine(codebuff, param, reax[ModuleInfo.Ofssize]);

	movzx	r8d, BYTE PTR ModuleInfo+404
	lea	rdx, QWORD PTR param$[rsp]
	mov	r8, QWORD PTR reax[r15+r8*8]
	lea	rcx, QWORD PTR codebuff$[rsp]
	call	WriteAsmLine
	jmp	$skip$6160
$simple$6218:

; 1200 :       simple:			Tokenize(param, 0, tokenarray, 0);

	lea	rcx, QWORD PTR param$[rsp]
	xor	r9d, r9d
	mov	r8, r14
	xor	edx, edx
	call	Tokenize

; 1201 : 
; 1202 :         if (strlen(init) == 1 && init[0] == '0')                        //REX=0?

	xor	eax, eax
	lea	rdi, QWORD PTR init$[rsp]
	mov	rcx, -1
	repne scasb
	not	rcx
	dec	rcx
	cmp	rcx, 1
	mov	rdx, rcx
	jne	$LN39@ForInitAnd
	cmp	BYTE PTR init$[rsp], 48			; 00000030H
	jne	$LN39@ForInitAnd

; 1203 :           WriteAsmLine(" xor  ", param, param);							            //XOR REX,REX //instead MOV REX,0

	xor	ecx, ecx
	npad	9
$LL159@ForInitAnd:
	movzx	eax, BYTE PTR $SG6221[rcx+r15]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7847[rsp+rcx-1], al
	jne	SHORT $LL159@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7847[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, QWORD PTR param$[rsp]
	npad	2
$LL264@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL264@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7847[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG6075
	npad	8
$LL263@ForInitAnd:
	movzx	eax, BYTE PTR [r15+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL263@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7847[rsp]
	mov	rcx, -1
	repne scasb
	lea	r15, OFFSET FLAT:__ImageBase
	lea	rdx, QWORD PTR param$[rsp]
	xor	ecx, ecx
$LL262@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL262@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7847[rsp]
	call	AddLineQueue
	jmp	$skip$6160
$LN39@ForInitAnd:

; 1204 :         else if ((strlen(op) == 1) && ((init[4] == ' ') || (init[4] == '\t'))) {  //op is '='

	lea	rdi, QWORD PTR op$[rsp]
	mov	rcx, -1
	repne scasb
	not	rcx
	dec	rcx
	cmp	rcx, 1
	jne	$LN37@ForInitAnd
	movzx	eax, BYTE PTR init$[rsp+4]
	cmp	al, 32					; 00000020H
	je	SHORT $LN36@ForInitAnd
	cmp	al, 9
	jne	$LN37@ForInitAnd
$LN36@ForInitAnd:

; 1205 :           if ((0 == _memicmp(init, "BYTE PTR", 8)) ||                   //reax=BYTE PTR al
; 1206 :             (0 == _memicmp(init, "BPTR", 4)) ||
; 1207 :             (0 == _memicmp(init, "WPTR", 4)) ||
; 1208 :             (0 == _memicmp(init, "WORD PTR", 8)))                     //reax=WORD PTR ax

	lea	rdx, OFFSET FLAT:$SG6227
	lea	rcx, QWORD PTR init$[rsp]
	mov	r8d, 8
	call	_memicmp
	test	eax, eax
	je	$LN34@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG6228
	lea	rcx, QWORD PTR init$[rsp]
	mov	r8d, 4
	call	_memicmp
	test	eax, eax
	je	$LN34@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG6229
	lea	rcx, QWORD PTR init$[rsp]
	mov	r8d, 4
	call	_memicmp
	test	eax, eax
	je	$LN34@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG6230
	lea	rcx, QWORD PTR init$[rsp]
	mov	r8d, 8
	call	_memicmp
	test	eax, eax
	je	$LN34@ForInitAnd

; 1211 :           else if (0 == _memicmp(init, "ADDR", 4))

	lea	rdx, OFFSET FLAT:$SG6234
	lea	rcx, QWORD PTR init$[rsp]
	mov	r8d, 4
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN32@ForInitAnd

; 1212 :             WriteAsmLine(" lea  ", param, init + 5);

	lea	r8, QWORD PTR init$[rsp+5]
	lea	rdx, QWORD PTR param$[rsp]
	lea	rcx, OFFSET FLAT:$SG6235
	call	WriteAsmLine
	jmp	$skip$6160
$LN32@ForInitAnd:

; 1213 :           else WriteAsmLine(" mov  ", param, init);

	xor	ecx, ecx
	npad	6
$LL165@ForInitAnd:
	movzx	eax, BYTE PTR $SG6237[rcx+r15]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7859[rsp+rcx-1], al
	jne	SHORT $LL165@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7859[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, QWORD PTR param$[rsp]
	npad	2
$LL261@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL261@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7859[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG6075
	npad	8
$LL260@ForInitAnd:
	movzx	eax, BYTE PTR [r15+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL260@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7859[rsp]
	mov	rcx, -1
	repne scasb
	lea	r15, OFFSET FLAT:__ImageBase
	lea	rdx, QWORD PTR init$[rsp]
	xor	ecx, ecx
$LL259@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL259@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7859[rsp]
	call	AddLineQueue
	jmp	$skip$6160
$LN34@ForInitAnd:

; 1209 : 
; 1210 :             WriteAsmLine(" movzx  ", param, init);                      //movzx reax,ax

	xor	ecx, ecx
$LL162@ForInitAnd:
	movzx	eax, BYTE PTR $SG6231[rcx+r15]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7853[rsp+rcx-1], al
	jne	SHORT $LL162@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7853[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, QWORD PTR param$[rsp]
	npad	1
$LL258@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL258@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7853[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG6075
	npad	8
$LL257@ForInitAnd:
	movzx	eax, BYTE PTR [r15+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL257@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7853[rsp]
	mov	rcx, -1
	repne scasb
	lea	r15, OFFSET FLAT:__ImageBase
	lea	rdx, QWORD PTR init$[rsp]
	xor	ecx, ecx
$LL256@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL256@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7853[rsp]
	call	AddLineQueue

; 1213 :           else WriteAsmLine(" mov  ", param, init);

	jmp	$skip$6160
$LN37@ForInitAnd:

; 1214 :         }
; 1215 :         else if ((strlen(op) == 1) && ((init[6] == ' ') || (init[6] == '\t'))) {

	cmp	rcx, 1
	jne	$LN29@ForInitAnd
	movzx	eax, BYTE PTR init$[rsp+6]
	cmp	al, 32					; 00000020H
	je	SHORT $LN28@ForInitAnd
	cmp	al, 9
	jne	$LN29@ForInitAnd
$LN28@ForInitAnd:

; 1216 :           if (0 == _memicmp(init, "OFFSET", 6))

	lea	rdx, OFFSET FLAT:$SG6242
	lea	rcx, QWORD PTR init$[rsp]
	mov	r8d, 6
	call	_memicmp
	test	eax, eax
	jne	$LN27@ForInitAnd

; 1217 :             WriteAsmLine(" lea  ", param, init + 7);

	xor	ecx, ecx
$LL168@ForInitAnd:
	movzx	eax, BYTE PTR $SG6243[rcx+r15]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7865[rsp+rcx-1], al
	jne	SHORT $LL168@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7865[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, QWORD PTR param$[rsp]
	npad	1
$LL255@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL255@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7865[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG6075
	npad	8
$LL254@ForInitAnd:
	movzx	eax, BYTE PTR [r15+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL254@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7865[rsp]
	mov	rcx, -1
	repne scasb
	lea	r15, OFFSET FLAT:__ImageBase
	lea	rdx, QWORD PTR init$[rsp+7]
	xor	ecx, ecx
$LL253@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL253@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7865[rsp]
	call	AddLineQueue
	jmp	$skip$6160
$LN27@ForInitAnd:

; 1218 :           else WriteAsmLine(" mov  ", param, init);

	xor	ecx, ecx
$LL171@ForInitAnd:
	movzx	eax, BYTE PTR $SG6245[rcx+r15]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7871[rsp+rcx-1], al
	jne	SHORT $LL171@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7871[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, QWORD PTR param$[rsp]
	npad	1
$LL252@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL252@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7871[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG6075
	npad	8
$LL251@ForInitAnd:
	movzx	eax, BYTE PTR [r15+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL251@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7871[rsp]
	mov	rcx, -1
	repne scasb
	lea	r15, OFFSET FLAT:__ImageBase
	lea	rdx, QWORD PTR init$[rsp]
	xor	ecx, ecx
$LL250@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL250@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7871[rsp]
	call	AddLineQueue
	jmp	$skip$6160
$LN29@ForInitAnd:

; 1219 :         }
; 1220 :         else if ((strlen(op) == 1) && ((init[5] == ' ') || (init[5] == '\t'))) {            //op is '='

	cmp	rcx, 1
	jne	$LN24@ForInitAnd
	movzx	eax, BYTE PTR init$[rsp+5]
	cmp	al, 32					; 00000020H
	je	SHORT $LN23@ForInitAnd
	cmp	al, 9
	jne	$LN24@ForInitAnd
$LN23@ForInitAnd:

; 1221 :           if ((0 == _memicmp(init, "DWORD PTR", 9) || 0 == _memicmp(init, "DPTR", 4)
; 1222 :             && (param[0] == 'r' || param[0] == 'R'))) 							   //rax=DWORD PTR eax

	lea	rdx, OFFSET FLAT:$SG6251
	lea	rcx, QWORD PTR init$[rsp]
	mov	r8d, 9
	call	_memicmp
	test	eax, eax
	je	$LN20@ForInitAnd
	lea	rdx, OFFSET FLAT:$SG6252
	lea	rcx, QWORD PTR init$[rsp]
	mov	r8d, 4
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN22@ForInitAnd
	movzx	eax, BYTE PTR param$[rsp]
	cmp	al, 114					; 00000072H
	je	$LN20@ForInitAnd
	cmp	al, 82					; 00000052H
	je	$LN20@ForInitAnd
$LN22@ForInitAnd:

; 1224 :           else WriteAsmLine(" mov  ", param, init);

	xor	ecx, ecx
	npad	9
$LL177@ForInitAnd:
	movzx	eax, BYTE PTR $SG6256[rcx+r15]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7883[rsp+rcx-1], al
	jne	SHORT $LL177@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7883[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, QWORD PTR param$[rsp]
	npad	2
$LL249@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL249@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7883[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG6075
	npad	8
$LL248@ForInitAnd:
	movzx	eax, BYTE PTR [r15+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL248@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7883[rsp]
	mov	rcx, -1
	repne scasb
	lea	r15, OFFSET FLAT:__ImageBase
	lea	rdx, QWORD PTR init$[rsp]
	xor	ecx, ecx
$LL247@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL247@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7883[rsp]
	call	AddLineQueue
	jmp	$skip$6160
$LN20@ForInitAnd:

; 1223 :             WriteAsmLine(" movsxd  ", param, init);								     //movsxd rax,eax

	xor	ecx, ecx
$LL174@ForInitAnd:
	movzx	eax, BYTE PTR $SG6254[rcx+r15]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7877[rsp+rcx-1], al
	jne	SHORT $LL174@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7877[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, QWORD PTR param$[rsp]
	npad	1
$LL246@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL246@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7877[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG6075
	npad	8
$LL245@ForInitAnd:
	movzx	eax, BYTE PTR [r15+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL245@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7877[rsp]
	mov	rcx, -1
	repne scasb
	lea	r15, OFFSET FLAT:__ImageBase
	lea	rdx, QWORD PTR init$[rsp]
	xor	ecx, ecx
$LL244@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL244@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7877[rsp]
	call	AddLineQueue

; 1224 :           else WriteAsmLine(" mov  ", param, init);

	jmp	$skip$6160
$LN24@ForInitAnd:

; 1225 :         }
; 1226 :         else if ((strlen(op) == 1) && brct) {											    //op is '='

	cmp	rcx, 1
	jne	$LN17@ForInitAnd
	test	r12b, r12b
	je	$LN17@ForInitAnd

; 1227 :           for (j = strlen(init); j; j--) {

	test	edx, edx
	movsxd	rdi, edx
	je	SHORT $LN14@ForInitAnd
	npad	7
$LL16@ForInitAnd:

; 1228 :             if (init[j] == ')') init[j] = NULLC;

	cmp	BYTE PTR init$[rsp+rdi], 41		; 00000029H
	lea	rdx, QWORD PTR init$[rsp+rdi]
	jne	SHORT $LN13@ForInitAnd
	mov	BYTE PTR [rdx], 0
$LN13@ForInitAnd:

; 1229 :             if (init[j] == '(') {

	cmp	BYTE PTR [rdx], 40			; 00000028H
	jne	SHORT $LN15@ForInitAnd

; 1230 :               for (p = init, p += j; *p; p++) {

	movzx	eax, BYTE PTR [rdx]
	mov	rcx, rdx
	test	al, al
	je	SHORT $LN9@ForInitAnd
$LL11@ForInitAnd:

; 1231 :                 if (*p == ',' && cnt) --cnt;

	cmp	al, 44					; 0000002cH
	jne	SHORT $LN10@ForInitAnd
	test	esi, esi
	je	SHORT $LN10@ForInitAnd
	dec	esi
$LN10@ForInitAnd:

; 1230 :               for (p = init, p += j; *p; p++) {

	mov	al, BYTE PTR [rcx+1]
	inc	rcx
	test	al, al
	jne	SHORT $LL11@ForInitAnd
$LN9@ForInitAnd:

; 1232 :               }
; 1233 :               init[j] = ',';

	mov	BYTE PTR [rdx], 44			; 0000002cH
$LN15@ForInitAnd:

; 1227 :           for (j = strlen(init); j; j--) {

	dec	rdi
	jne	SHORT $LL16@ForInitAnd
$LN14@ForInitAnd:

; 1234 :             }
; 1235 :           }
; 1236 :           strcpy(codebuff, " invoke  ");

	mov	rax, QWORD PTR $SG6268[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]

; 1237 :           strcat(codebuff, init);

	lea	rdi, QWORD PTR codebuff$[rsp]
	mov	QWORD PTR [rcx], rax
	movzx	eax, WORD PTR $SG6268[r15+8]
	lea	rdx, QWORD PTR init$[rsp]
	mov	WORD PTR [rcx+8], ax
	xor	eax, eax
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	5
$LL243@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL243@ForInitAnd

; 1238 :           AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1239 :           WriteAsmLine(" mov  ", param, reax[ModuleInfo.Ofssize]);

	movzx	edx, BYTE PTR ModuleInfo+404
	xor	ecx, ecx
	mov	r8, QWORD PTR reax[r15+rdx*8]
	npad	3
$LL180@ForInitAnd:
	movzx	eax, BYTE PTR $SG6269[rcx+r15]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7889[rsp+rcx-1], al
	jne	SHORT $LL180@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7889[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, QWORD PTR param$[rsp]
	npad	2
$LL242@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL242@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7889[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG6075
	npad	8
$LL241@ForInitAnd:
	movzx	eax, BYTE PTR [r15+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL241@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7889[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:__ImageBase
	npad	7
$LL240@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL240@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7889[rsp]
	call	AddLineQueue

; 1240 :           brct = FALSE;

	xor	r12b, r12b

; 1241 :         }
; 1242 :         else {

	jmp	$skip$6160
$LN17@ForInitAnd:

; 1243 :           if (strlen(op) == 1)

	cmp	rcx, 1
	jne	$LN6@ForInitAnd

; 1244 :             WriteAsmLine(" mov  ", param, init);

	xor	ecx, ecx
	npad	2
$LL183@ForInitAnd:
	movzx	eax, BYTE PTR $SG6272[rcx+r15]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7896[rsp+rcx-1], al
	jne	SHORT $LL183@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7896[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, QWORD PTR param$[rsp]
	npad	2
$LL239@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL239@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7896[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG6075
	npad	8
$LL238@ForInitAnd:
	movzx	eax, BYTE PTR [r15+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL238@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7896[rsp]
	mov	rcx, -1
	repne scasb
	lea	r15, OFFSET FLAT:__ImageBase
	lea	rdx, QWORD PTR init$[rsp]
	xor	ecx, ecx
$LL237@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL237@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7896[rsp]
	call	AddLineQueue

; 1245 :           else

	jmp	$skip$6160
$LN6@ForInitAnd:

; 1246 :             WriteAsmLine(codebuff, param, init);

	xor	ecx, ecx
$LL186@ForInitAnd:
	movzx	eax, BYTE PTR codebuff$[rsp+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7902[rsp+rcx-1], al
	jne	SHORT $LL186@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7902[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, QWORD PTR param$[rsp]
	npad	2
$LL236@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL236@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7902[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG6075
	npad	8
$LL235@ForInitAnd:
	movzx	eax, BYTE PTR [r15+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL235@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7902[rsp]
	mov	rcx, -1
	repne scasb
	lea	r15, OFFSET FLAT:__ImageBase
	lea	rdx, QWORD PTR init$[rsp]
	xor	ecx, ecx
$LL234@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL234@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7902[rsp]
	call	AddLineQueue

; 1247 :         }
; 1248 :       }
; 1249 :       else

	jmp	$skip$6160
$LN61@ForInitAnd:

; 1174 :           WriteAsmLine(" mov  ", recx[ModuleInfo.Ofssize], init);        //MOV RCX,init

	movzx	eax, BYTE PTR ModuleInfo+404
	xor	ecx, ecx
	mov	rdx, QWORD PTR recx[r15+rax*8]
$LL153@ForInitAnd:
	movzx	eax, BYTE PTR $SG6186[rcx+r15]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7833[rsp+rcx-1], al
	jne	SHORT $LL153@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7833[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	10
$LL233@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL233@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7833[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG6075
	npad	8
$LL232@ForInitAnd:
	movzx	eax, BYTE PTR [r15+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL232@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7833[rsp]
	mov	rcx, -1
	repne scasb
	lea	r15, OFFSET FLAT:__ImageBase
	lea	rdx, QWORD PTR init$[rsp]
	xor	ecx, ecx
$LL231@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL231@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7833[rsp]
	call	AddLineQueue

; 1175 :           if (op[0] == '/' || op[0] == '%') {

	cmp	bl, 47					; 0000002fH
	je	SHORT $LN59@ForInitAnd
	cmp	bl, 37					; 00000025H
	je	SHORT $LN59@ForInitAnd

; 1179 :           }
; 1180 :           else strcpy(codebuff, " imul ");

	mov	eax, DWORD PTR $SG6192[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6192[r15+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR $SG6192[r15+6]
	mov	BYTE PTR [rcx+6], al
	jmp	SHORT $LN58@ForInitAnd
$LN59@ForInitAnd:

; 1176 :             strcpy(codebuff, " cdq ");

	mov	eax, DWORD PTR $SG6189[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6189[r15+4]
	mov	WORD PTR [rcx+4], ax

; 1177 :             AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1178 :             strcpy(codebuff, " idiv ");

	mov	eax, DWORD PTR $SG6190[r15]
	lea	rdx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rdx], eax
	movzx	eax, WORD PTR $SG6190[r15+4]
	mov	WORD PTR [rdx+4], ax
	movzx	eax, BYTE PTR $SG6190[r15+6]
	mov	BYTE PTR [rdx+6], al
$LN58@ForInitAnd:

; 1181 :           strcat(codebuff, recx[ModuleInfo.Ofssize]);

	movzx	edx, BYTE PTR ModuleInfo+404
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$[rsp]
	mov	r8, QWORD PTR recx[r15+rdx*8]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	12
$LL230@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL230@ForInitAnd

; 1182 :           AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1183 :           if (op[0] == '%') WriteAsmLine(" mov  ", param, redx[ModuleInfo.Ofssize]);

	cmp	bl, 37					; 00000025H
	jne	$skip$6160
	movzx	eax, BYTE PTR ModuleInfo+404
	xor	ecx, ecx
	mov	rdx, QWORD PTR redx[r15+rax*8]
	npad	9
$LL156@ForInitAnd:
	movzx	eax, BYTE PTR $SG6194[rcx+r15]
	inc	rcx
	test	al, al
	mov	BYTE PTR codebuff$7840[rsp+rcx-1], al
	jne	SHORT $LL156@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7840[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r8, QWORD PTR param$[rsp]
	npad	2
$LL229@ForInitAnd:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL229@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7840[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:$SG6075
	npad	7
$LL228@ForInitAnd:
	movzx	eax, BYTE PTR [r15+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL228@ForInitAnd
	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$7840[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	r15, OFFSET FLAT:__ImageBase
	npad	7
$LL227@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL227@ForInitAnd
	lea	rcx, QWORD PTR codebuff$7840[rsp]
	call	AddLineQueue

; 1184 :           goto skip;

	jmp	$skip$6160
$LN116@ForInitAnd:

; 1043 :       param[a] = '\0';
; 1044 :       if ((buff[b] == '+') && (buff[b + 1] == '+')) strcpy(codebuff, " inc ");

	movzx	edx, BYTE PTR [rcx+r13]
	mov	BYTE PTR param$[rsp+rbx], 0
	cmp	dl, 43					; 0000002bH
	jne	SHORT $LN115@ForInitAnd
	cmp	al, dl
	jne	SHORT $LN115@ForInitAnd
	mov	eax, DWORD PTR $SG6105[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6105[r15+4]
	mov	WORD PTR [rcx+4], ax
	jmp	SHORT $LN113@ForInitAnd
$LN115@ForInitAnd:

; 1045 :       else if ((buff[b] == '-') && (buff[b + 1] == '-')) strcpy(codebuff, " dec ");

	cmp	dl, 45					; 0000002dH
	jne	SHORT $LN113@ForInitAnd
	cmp	al, dl
	jne	SHORT $LN113@ForInitAnd
	mov	eax, DWORD PTR $SG6108[r15]
	lea	rcx, QWORD PTR codebuff$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6108[r15+4]
	mov	WORD PTR [rcx+4], ax
$LN113@ForInitAnd:

; 1046 :       strcat(codebuff, param);

	xor	eax, eax
	lea	rdi, QWORD PTR codebuff$[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, QWORD PTR param$[rsp]
	npad	10
$LL226@ForInitAnd:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL226@ForInitAnd

; 1047 :       AddLineQueue(codebuff);

	lea	rcx, QWORD PTR codebuff$[rsp]
	call	AddLineQueue

; 1048 :       b += 3;

	add	ebp, 3
$skip$6160:

; 1256 :         }
; 1257 :       }
; 1258 :     }
; 1259 :   skip:
; 1260 :     if (cnt) cnt--;

	test	esi, esi
	je	SHORT $LN299@ForInitAnd
	dec	esi

; 1261 :   } while (cnt);

	jne	$LL124@ForInitAnd
$LN299@ForInitAnd:
	mov	r15, QWORD PTR [rsp+1080]
	mov	r14, QWORD PTR [rsp+1088]
	mov	r13, QWORD PTR [rsp+1096]
	mov	r12, QWORD PTR [rsp+1104]
	mov	rdi, QWORD PTR [rsp+1144]
	mov	rsi, QWORD PTR [rsp+1136]
	mov	rbp, QWORD PTR [rsp+1128]
	mov	rbx, QWORD PTR [rsp+1120]

; 1262 :   return(NOT_ERROR);

	xor	eax, eax

; 1263 : }

	add	rsp, 1112				; 00000458H
	ret	0
ForInitAndNext ENDP
_TEXT	ENDS
PUBLIC	HllStartDir
EXTRN	RunLineQueue:NEAR
EXTRN	LstWrite:NEAR
EXTRN	GetCurrOffset:NEAR
EXTRN	EmitErr:NEAR
EXTRN	tolower:NEAR
EXTRN	AddLineQueueX:NEAR
EXTRN	LclAlloc:NEAR
EXTRN	__chkstk:NEAR
xdata	SEGMENT
$unwind$HllStartDir DD 0e7d01H
	DD	03a3547dH
	DD	039ae449H
	DD	039bd43bH
	DD	039d7430H
	DD	039e6428H
	DD	03a23419H
	DD	039f0111H
xdata	ENDS
pdata	SEGMENT
$pdata$HllStartDir DD @imagerel($LN319#)
	DD	@imagerel($LN319#+997)
	DD	@imagerel($unwind$HllStartDir#)
pdata	ENDS
xdata	SEGMENT
$chain$6$HllStartDir DD 020821H
	DD	039cc408H
	DD	@imagerel($LN319#)
	DD	@imagerel($LN319#+997)
	DD	@imagerel($unwind$HllStartDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$HllStartDir DD @imagerel($LN319#+997)
	DD	@imagerel($LN319#+1193)
	DD	@imagerel($chain$6$HllStartDir#)
pdata	ENDS
xdata	SEGMENT
$chain$7$HllStartDir DD 021H
	DD	@imagerel($LN319#)
	DD	@imagerel($LN319#+997)
	DD	@imagerel($unwind$HllStartDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$HllStartDir DD @imagerel($LN319#+1193)
	DD	@imagerel($LN319#+3381)
	DD	@imagerel($chain$7$HllStartDir#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
hllop$8680 = 64
hllop$8390 = 64
hllop$8062 = 64
buff$ = 80
opndx$ = 96
forbuff$ = 208
forbuffcnt$ = 1232
buffer$ = 2256
forbuffcond$ = 4304
forbuffinit$ = 5328
transformed$ = 6352
i$ = 7424
tokenarray$ = 7432
HllStartDir PROC NEAR

; 1269 : {

$LN319:
	mov	DWORD PTR [rsp+8], ecx
	mov	eax, 7416				; 00001cf8H
	call	__chkstk
	sub	rsp, rax
	mov	QWORD PTR [rsp+7440], rbx

; 1270 :   struct hll_item      *hll;
; 1271 :   ret_code             rc = NOT_ERROR;
; 1272 :   int                  cmd = tokenarray[i].tokval;
; 1273 :   char buff[16];
; 1274 :   char buffer[MAX_LINE_LEN * 2];
; 1275 :   char codebuff[256];
; 1276 :   char param[256];
; 1277 :   char init[256];
; 1278 :   char limit[MAX_LINE_LEN];
; 1279 :   char op[4];
; 1280 :   char forbuff[MAX_LINE_LEN];
; 1281 :   char forbuffinit[MAX_LINE_LEN];
; 1282 :   char forbuffcond[MAX_LINE_LEN];
; 1283 :   char forbuffcnt[MAX_LINE_LEN];
; 1284 :   char transformed[MAX_LINE_LEN];
; 1285 :   int a;
; 1286 :   int j;
; 1287 :   int b;
; 1288 :   int e;
; 1289 :   int size;
; 1290 :   int eqcnt;
; 1291 :   int cmcnt;
; 1292 :   char *p;
; 1293 :   char c;
; 1294 :   struct expr         opndx;
; 1295 :   struct asm_tok      *t;
; 1296 :   DebugMsg1(("HllStartDir(%s) enter\n", tokenarray[i].string_ptr));
; 1297 : 
; 1298 :   i++; /* skip directive */
; 1299 : 
; 1300 :        /* v2.06: is there an item on the free stack? */
; 1301 :   if (HllFree) {

	mov	rbx, QWORD PTR ModuleInfo+232
	mov	QWORD PTR [rsp+7408], rsi
	mov	QWORD PTR [rsp+7400], rdi
	movsxd	rax, ecx
	mov	QWORD PTR [rsp+7384], r13
	shl	rax, 5
	inc	ecx
	mov	QWORD PTR [rsp+7376], r14
	mov	edi, DWORD PTR [rax+rdx+16]
	xor	r14d, r14d
	test	rbx, rbx
	mov	DWORD PTR i$[rsp], ecx
	mov	rsi, rdx
	mov	r13d, r14d
	jne	SHORT $LN82@HllStartDi

; 1302 :     hll = HllFree;
; 1303 :     DebugCmd(cntReused++);
; 1304 :   }
; 1305 :   else {
; 1306 :     hll = LclAlloc(sizeof(struct hll_item));

	mov	ecx, 160				; 000000a0H
	call	LclAlloc
	mov	rbx, rax
$LN82@HllStartDi:

; 1307 :     DebugCmd(cntAlloc++);
; 1308 :   }
; 1309 : 
; 1310 :   /* structure for .IF .ELSE .ENDIF
; 1311 :   *    cond jump to LTEST-label
; 1312 :   *    ...
; 1313 :   *    jmp LEXIT
; 1314 :   *  LTEST:
; 1315 :   *    ...
; 1316 :   *  LEXIT:
; 1317 : 
; 1318 :   * structure for .IF .ELSEIF
; 1319 :   *    cond jump to LTEST
; 1320 :   *    ...
; 1321 :   *    jmp LEXIT
; 1322 :   *  LTEST:
; 1323 :   *    cond jump to (new) LTEST
; 1324 :   *    ...
; 1325 :   *    jmp LEXIT
; 1326 :   *  LTEST:
; 1327 :   *    ...
; 1328 : 
; 1329 :   * structure for .WHILE and .REPEAT:
; 1330 :   *   jmp LTEST (for .WHILE only)
; 1331 :   * LSTART:
; 1332 :   *   ...
; 1333 :   * LTEST: (jumped to by .continue)
; 1334 :   *   a) test end condition, cond jump to LSTART label
; 1335 :   *   b) unconditional jump to LSTART label
; 1336 :   * LEXIT: (jumped to by .BREAK)
; 1337 :   */
; 1338 : 
; 1339 :   hll->labels[LEXIT] = 0;
; 1340 : 
; 1341 :   switch (cmd) {

	cmp	edi, 328				; 00000148H
	mov	QWORD PTR [rsp+7448], rbp
	mov	DWORD PTR [rbx+12], r14d
	je	$LN79@HllStartDi
	cmp	edi, 328				; 00000148H
	jle	$LN77@HllStartDi
	cmp	edi, 330				; 0000014aH
	jle	$LN11@HllStartDi
	cmp	edi, 331				; 0000014bH
	je	$LN46@HllStartDi
	cmp	edi, 341				; 00000155H
	jne	$LN77@HllStartDi

; 1355 :       }
; 1356 :     }
; 1357 :     break;
; 1358 :     // added by habran
; 1359 :   case T_DOT_SWITCH:
; 1360 :     hll->cmd = HLL_SWITCH;

	mov	DWORD PTR [rbx+68], 5

; 1361 :     hll->flags = HLLF_WHILE;

	mov	DWORD PTR [rbx+76], 4

; 1362 :     hll->labels[LSKIP] = GetHllLabel();   /* used by .ENDSWITCH */

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+20], eax

; 1363 :     hll->labels[LJUMP] = GetHllLabel();   /* used by .ENDSWITCH */

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+44], eax

; 1364 :     hll->labels[LEXIT] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+12], eax

; 1365 :     hll->labels[LDATA1] = GetHllLabel();   /* used by .ENDSWITCH */

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+32], eax

; 1366 :     hll->labels[LSTART] = GetHllLabel();   /* used by .CASE      */

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+16], eax

; 1367 :     hll->labels[LTEST] = 0;               /* used by .CASE      */

	mov	DWORD PTR [rbx+8], r14d

; 1368 :     hll->labels[LDEF] = 0;   /* used by .DEFAULT   */

	mov	DWORD PTR [rbx+28], r14d

; 1369 :     hll->labels[LDATA2] = GetHllLabel();   /* used by .ENDSWITCH */

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+36], eax

; 1370 :     hll->labels[LTOP] = GetHllLabel();   /* used by .ENDSWITCH */

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+40], eax

; 1371 :     hll->labels[LCONT] = GetHllLabel();   /* used by .ENDSWITCH */

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+24], eax

; 1372 :     hll->maxalloccasen = 0;

	mov	DWORD PTR [rbx+100], r14d

; 1373 :     hll->casecnt = 0;

	mov	DWORD PTR [rbx+80], r14d

; 1374 :     hll->csize = 4;

	mov	BYTE PTR [rbx+84], 4

; 1375 :     hll->breakoccured = TRUE; //first label for .CASE hast to be set

	mov	BYTE PTR [rbx+122], 1

; 1376 : 
; 1377 :     if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], r13b
	je	$LN75@HllStartDi

; 1378 :       DebugMsg1(("HllStartDir(%s): calling EvalOperand, i=%u\n", tokenarray[i].string_ptr, i));
; 1379 :       if (EvalOperand(&i, tokenarray, Token_Count, &opndx, 0) == ERROR) {

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rsi
	mov	BYTE PTR [rsp+32], r13b
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN74@HllStartDi

; 1380 :         DebugMsg(("HllStartDir(%s): EvalOperand() failed\n", tokenarray[i].string_ptr));
; 1381 :         return(ERROR);

	jmp	$LN84@HllStartDi
$LN74@HllStartDi:

; 1382 :       }
; 1383 :       i--; //EvalOperand increases i, decrease it to point to proper tokenarray[i].tokpos

	mov	ecx, DWORD PTR i$[rsp]

; 1384 :       switch (opndx.kind) {

	mov	edx, DWORD PTR opndx$[rsp+60]
	dec	ecx
	dec	edx
	mov	DWORD PTR i$[rsp], ecx
	je	$LN58@HllStartDi
	dec	edx
	jne	$LN48@HllStartDi

; 1385 :       case EXPR_REG:
; 1386 :         t = opndx.base_reg;
; 1387 :         if (ModuleInfo.Ofssize == USE32) {

	cmp	BYTE PTR ModuleInfo+404, 1
	jne	SHORT $LN70@HllStartDi

; 1388 :           if (t->tokval <= T_BX)   // AL, CL, DL, BL, AH, CH, DH, BH, AX, CX, DX, BX

	mov	rax, QWORD PTR opndx$[rsp+24]
	mov	edx, DWORD PTR [rax+16]
	cmp	edx, 12
	ja	SHORT $LN69@HllStartDi

; 1389 :             AddLineQueueX(" movzx eax, %s", tokenarray[i].tokpos);

	movsxd	rdx, ecx
	lea	rcx, OFFSET FLAT:$SG6332
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]
	call	AddLineQueueX

; 1390 :           else {

	mov	ecx, DWORD PTR i$[rsp]
	jmp	$LN48@HllStartDi
$LN69@HllStartDi:

; 1391 :             if (t->tokval != T_EAX) //skip it, no need to write MOV EAX,EAX

	cmp	edx, 17
	je	$LN48@HllStartDi

; 1392 :               AddLineQueueX(" mov eax, %s", tokenarray[i].tokpos);

	movsxd	rdx, ecx
	lea	rcx, OFFSET FLAT:$SG6335
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]
	call	AddLineQueueX

; 1393 :           }
; 1394 :         }
; 1395 : #if AMD64_SUPPORT
; 1396 :         else             //USE64

	mov	ecx, DWORD PTR i$[rsp]
	jmp	$LN48@HllStartDi
$LN70@HllStartDi:

; 1397 :         {
; 1398 :           if ((t->tokval <= T_EAX))

	mov	rax, QWORD PTR opndx$[rsp+24]
	mov	edx, DWORD PTR [rax+16]
	cmp	edx, 17
	jbe	$LN48@HllStartDi

; 1399 :             ; //skip it, no need to write MOV EAX,EAX
; 1400 :           else if (t->tokval <= T_BX) // AL, CL, DL, BL, AH, CH, DH, BH, AX, CX, DX, BX

	cmp	edx, 12
	ja	SHORT $LN63@HllStartDi

; 1401 :             AddLineQueueX(" movzx eax, %s", tokenarray[i].tokpos);

	movsxd	rdx, ecx
	lea	rcx, OFFSET FLAT:$SG6340
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]
	call	AddLineQueueX
	mov	ecx, DWORD PTR i$[rsp]
	jmp	$LN48@HllStartDi
$LN63@HllStartDi:

; 1402 :           else if (t->tokval <= T_EDI) //EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI

	cmp	edx, 24
	ja	SHORT $LN61@HllStartDi

; 1403 :             AddLineQueueX(" mov eax, %s", tokenarray[i].tokpos);

	movsxd	rdx, ecx
	lea	rcx, OFFSET FLAT:$SG6343
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]
	call	AddLineQueueX

; 1404 :           else {

	mov	ecx, DWORD PTR i$[rsp]
	jmp	$LN48@HllStartDi
$LN61@HllStartDi:

; 1405 :             if (t->tokval != T_RAX) //skip it, no need to write MOV RAX,RAX

	cmp	edx, 115				; 00000073H
	je	SHORT $LN59@HllStartDi

; 1406 :               AddLineQueueX(" mov rax, %s", tokenarray[i].tokpos);

	movsxd	rdx, ecx
	lea	rcx, OFFSET FLAT:$SG6346
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]
	call	AddLineQueueX
$LN59@HllStartDi:

; 1407 :             hll->csize = 8;

	mov	BYTE PTR [rbx+84], 8

; 1408 :           }
; 1409 :         }               //end USE64
; 1410 : #endif
; 1411 :         break;

	mov	ecx, DWORD PTR i$[rsp]
	jmp	$LN48@HllStartDi
$LN58@HllStartDi:

; 1412 :       case EXPR_ADDR:
; 1413 :         if (ModuleInfo.Ofssize == USE32) {

	cmp	BYTE PTR ModuleInfo+404, 1
	jne	SHORT $LN57@HllStartDi

; 1414 :           if (opndx.mem_type == MT_BYTE || opndx.mem_type == MT_WORD)

	mov	eax, DWORD PTR opndx$[rsp+64]
	test	eax, eax
	je	SHORT $LN55@HllStartDi
	cmp	eax, 1
	je	SHORT $LN55@HllStartDi

; 1416 :           else
; 1417 :             AddLineQueueX(" mov eax, %s", tokenarray[i].tokpos);

	movsxd	rdx, ecx
	lea	rcx, OFFSET FLAT:$SG6353
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]
	call	AddLineQueueX
	mov	ecx, DWORD PTR i$[rsp]
	jmp	$LN48@HllStartDi
$LN55@HllStartDi:

; 1415 :             AddLineQueueX(" movzx eax, %s", tokenarray[i].tokpos);

	movsxd	rdx, ecx
	lea	rcx, OFFSET FLAT:$SG6351
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]
	call	AddLineQueueX

; 1418 :         }
; 1419 : #if AMD64_SUPPORT
; 1420 :         else             //USE64

	mov	ecx, DWORD PTR i$[rsp]
	jmp	SHORT $LN48@HllStartDi
$LN57@HllStartDi:

; 1421 :         {
; 1422 :           if (opndx.mem_type == MT_BYTE || opndx.mem_type == MT_WORD)

	mov	eax, DWORD PTR opndx$[rsp+64]
	test	eax, eax
	je	SHORT $LN51@HllStartDi
	cmp	eax, 1
	je	SHORT $LN51@HllStartDi

; 1424 :           else if (opndx.mem_type == MT_DWORD)

	cmp	eax, 3
	jne	SHORT $LN49@HllStartDi

; 1425 :             AddLineQueueX(" mov eax, %s", tokenarray[i].tokpos);

	movsxd	rdx, ecx
	lea	rcx, OFFSET FLAT:$SG6360
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]
	call	AddLineQueueX

; 1426 :           else {

	mov	ecx, DWORD PTR i$[rsp]
	jmp	SHORT $LN48@HllStartDi
$LN49@HllStartDi:

; 1427 :             AddLineQueueX(" mov rax, %s", tokenarray[i].tokpos);

	movsxd	rdx, ecx
	lea	rcx, OFFSET FLAT:$SG6362
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]
	call	AddLineQueueX

; 1428 :             hll->csize = 8;

	mov	BYTE PTR [rbx+84], 8
	mov	ecx, DWORD PTR i$[rsp]
	jmp	SHORT $LN48@HllStartDi
$LN51@HllStartDi:

; 1423 :             AddLineQueueX(" movzx eax, %s", tokenarray[i].tokpos);

	movsxd	rdx, ecx
	lea	rcx, OFFSET FLAT:$SG6357
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]
	call	AddLineQueueX
	mov	ecx, DWORD PTR i$[rsp]
$LN48@HllStartDi:

; 1438 :     }
; 1439 :     i++;

	inc	ecx

; 1440 :     AddLineQueueX(JMPPREFIX "jmp %s", GetLabelStr(hll->labels[LSTART], buff));

	lea	rdx, OFFSET FLAT:$SG5756
	mov	DWORD PTR i$[rsp], ecx
	mov	r8d, DWORD PTR [rbx+16]
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6364
	call	AddLineQueueX

; 1441 :     break;

	jmp	$LN77@HllStartDi
$LN75@HllStartDi:

; 1429 :           }
; 1430 :         }                //end USE64
; 1431 : #endif
; 1432 :         break;
; 1433 :       }
; 1434 :     }
; 1435 :     else {
; 1436 :       DebugMsg(("HllExitDir stack error\n"));
; 1437 :       return(EmitError(MISSING_OPERATOR_IN_EXPRESSION));

	mov	ecx, 150				; 00000096H
	call	EmitError
	jmp	$LN84@HllStartDi
$LN46@HllStartDi:

; 1442 :   case T_DOT_FOR:
; 1443 :     /* create the label to loop start */
; 1444 :     hll->labels[LSTART] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352
	mov	QWORD PTR [rsp+7392], r12

; 1445 :     hll->labels[LSKIP] = GetHllLabel();
; 1446 :     hll->labels[LCONT] = 0;
; 1447 :     hll->labels[LTEST] = 0;
; 1448 :     hll->flags = 0;
; 1449 :     hll->cmd = HLL_FOR;
; 1450 :     //copy string to the buffer and get read of spaces
; 1451 :     p = tokenarray[i].tokpos;
; 1452 :     for (b = 0; *p; p++)

	mov	r12d, r14d
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+16], eax
	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+20], eax
	mov	DWORD PTR [rbx+24], r14d
	mov	DWORD PTR [rbx+8], r14d
	mov	DWORD PTR [rbx+76], r14d
	mov	DWORD PTR [rbx+68], 4
	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	mov	rbp, QWORD PTR [rax+rsi+24]
	movzx	eax, BYTE PTR [rbp]
	test	al, al
	je	SHORT $LN43@HllStartDi

; 1442 :   case T_DOT_FOR:
; 1443 :     /* create the label to loop start */
; 1444 :     hll->labels[LSTART] = GetHllLabel();

	lea	rdi, QWORD PTR forbuff$[rsp]
$LL45@HllStartDi:

; 1453 :     {
; 1454 :       if ((*p == ' ') || (*p == '\t')) {

	cmp	al, 32					; 00000020H
	je	SHORT $LN41@HllStartDi
	cmp	al, 9
	je	SHORT $LN41@HllStartDi

; 1460 :         }
; 1461 :       }
; 1462 :       else {
; 1463 :         forbuff[b] = *p;

	mov	BYTE PTR [rdi], al

; 1464 :         b++;

	inc	r12d
	inc	rdi
	jmp	SHORT $LN44@HllStartDi
$LN41@HllStartDi:

; 1455 :         //if there is QWORD PTR, DWORD PTR, WORD PTR, BYTE PTR, OFFSET or ADDR leave a space between
; 1456 :         c = tolower(*(p + 1));

	movsx	ecx, BYTE PTR [rbp+1]
	call	tolower

; 1457 :         if ((c >= 'a') && (c <= 'z')) {

	sub	al, 97					; 00000061H
	cmp	al, 25
	ja	SHORT $LN44@HllStartDi

; 1458 :           forbuff[b] = *p;

	movzx	eax, BYTE PTR [rbp]

; 1459 :           b++;

	inc	r12d
	inc	rdi
	mov	BYTE PTR [rdi-1], al
$LN44@HllStartDi:
	mov	al, BYTE PTR [rbp+1]
	inc	rbp
	test	al, al
	jne	SHORT $LL45@HllStartDi
$LN43@HllStartDi:

; 1465 :       }
; 1466 :     }
; 1467 :     forbuff[b] = NULLC;

	movsxd	rax, r12d

; 1468 :     if (0 == _memicmp(forbuff, "(::)", 4)) {

	lea	rdx, OFFSET FLAT:$SG6374
	lea	rcx, QWORD PTR forbuff$[rsp]
	mov	r8d, 4
	mov	BYTE PTR forbuff$[rsp+rax], r13b
	call	_memicmp
	mov	r12, QWORD PTR [rsp+7392]
	test	eax, eax
	jne	SHORT $LN38@HllStartDi

; 1469 :       hll->cmcnt = 0;

	mov	DWORD PTR [rbx+64], r14d

; 1470 :     }
; 1471 :     else {

	jmp	$LN12@HllStartDi
$LN38@HllStartDi:

; 1472 :       //count initializers
; 1473 :       eqcnt = 1;

	mov	r9d, 1

; 1474 :       forbuffinit[0] = NULLC;
; 1475 :       for (j = 1, b = 0; forbuff[j];) {

	mov	rcx, r14
	mov	BYTE PTR forbuffinit$[rsp], r13b
	cmp	BYTE PTR forbuff$[rsp+1], cl
	mov	edi, r9d
	mov	r8d, r14d
	mov	rax, r9
	je	$LN317@HllStartDi
	npad	7
$LL36@HllStartDi:

; 1476 :         c = forbuff[j];

	movzx	edx, BYTE PTR forbuff$[rsp+rax]

; 1477 :         if (c == ':') {

	cmp	dl, 58					; 0000003aH
	jne	SHORT $LN33@HllStartDi

; 1478 :           if (forbuff[j - 1] != 39 && forbuff[j + 1] != 39) break;

	cmp	BYTE PTR forbuff$[rsp+rax-1], 39	; 00000027H
	je	SHORT $LN32@HllStartDi
	cmp	BYTE PTR forbuff$[rsp+rax+1], 39	; 00000027H
	jne	SHORT $LN317@HllStartDi

; 1479 :         }
; 1480 :         if (c == ',' && forbuff[j - 1] != 39 && forbuff[j + 1] != 39) eqcnt++;

	jmp	SHORT $LN32@HllStartDi
$LN33@HllStartDi:
	cmp	dl, 44					; 0000002cH
	jne	SHORT $LN32@HllStartDi
	cmp	BYTE PTR forbuff$[rsp+rax-1], 39	; 00000027H
	je	SHORT $LN32@HllStartDi
	cmp	BYTE PTR forbuff$[rsp+rax+1], 39	; 00000027H
	je	SHORT $LN32@HllStartDi
	inc	r9d
$LN32@HllStartDi:

; 1481 :         forbuffinit[b] = c;
; 1482 :         if (c == 39 && forbuffinit[b - 2] == 39) {

	cmp	dl, 39					; 00000027H
	mov	BYTE PTR forbuffinit$[rsp+rcx], dl
	jne	SHORT $LN31@HllStartDi
	cmp	BYTE PTR forbuffinit$[rsp+rcx-2], dl
	jne	SHORT $LN31@HllStartDi

; 1483 :           b++;

	inc	r8d
	inc	rcx

; 1484 :           forbuffinit[b] = ' ';

	mov	BYTE PTR forbuffinit$[rsp+rcx], 32	; 00000020H
$LN31@HllStartDi:

; 1485 :         }
; 1486 :         j++;

	inc	rax
	inc	edi

; 1487 :         b++;

	inc	r8d
	inc	rcx
	cmp	BYTE PTR forbuff$[rsp+rax], r13b
	jne	SHORT $LL36@HllStartDi
$LN317@HllStartDi:

; 1488 :       }
; 1489 :       forbuffinit[b] = NULLC;

	movsxd	rax, r8d

; 1490 :       j++;

	inc	edi

; 1491 :       //coppy the condition to the buffer
; 1492 :       forbuffcond[0] = NULLC;
; 1493 :       hll->labels[LTEST] = 0;
; 1494 :       for (b = 0; forbuff[j] && forbuff[j] != ':'; forbuffcond[b] = forbuff[j], j++, b++);

	mov	r8d, r14d
	mov	BYTE PTR forbuffinit$[rsp+rax], r13b
	movsxd	rax, edi
	mov	DWORD PTR [rbx+8], r14d
	cmp	BYTE PTR forbuff$[rsp+rax], r8b
	mov	BYTE PTR forbuffcond$[rsp], r13b
	je	SHORT $LN318@HllStartDi
	lea	rax, QWORD PTR forbuff$[rsp+rax]
	lea	rcx, QWORD PTR forbuffcond$[rsp]
$LL30@HllStartDi:
	movzx	edx, BYTE PTR [rax]
	cmp	dl, 58					; 0000003aH
	je	SHORT $LN318@HllStartDi
	inc	rax
	mov	BYTE PTR [rcx], dl
	inc	edi
	inc	r8d
	inc	rcx
	cmp	BYTE PTR [rax], r13b
	jne	SHORT $LL30@HllStartDi
$LN318@HllStartDi:

; 1495 :       if (forbuffcond[b - 2] == '>' && forbuffcond[b - 1] == '0') forbuffcond[b - 2] = NULLC;

	movsxd	rax, r8d
	cmp	BYTE PTR forbuffcond$[rsp+rax-2], 62	; 0000003eH
	jne	SHORT $LN27@HllStartDi
	cmp	BYTE PTR forbuffcond$[rsp+rax-1], 48	; 00000030H
	jne	SHORT $LN27@HllStartDi
	mov	BYTE PTR forbuffcond$[rsp+rax-2], r13b
$LN27@HllStartDi:

; 1496 :       forbuffcond[b] = NULLC;

	mov	BYTE PTR forbuffcond$[rsp+rax], r13b

; 1497 :       if (!b) hll->cond = FALSE;

	test	r8d, r8d

; 1498 :       else    hll->cond = TRUE;
; 1499 :       j++;
; 1500 :       //copy the counter to the buffer
; 1501 :       cmcnt = 0;

	mov	ebp, r14d
	setne	al
	inc	edi

; 1502 :       forbuffcnt[0] = NULLC;

	mov	BYTE PTR forbuffcnt$[rsp], bpl
	mov	BYTE PTR [rbx+72], al

; 1503 :       hll->condlines = "";

	lea	rax, OFFSET FLAT:$SG6389

; 1504 :       for (b = 0; forbuff[j] != ')'; b++, j++) {

	movsxd	rcx, edi
	mov	QWORD PTR [rbx+48], rax
	cmp	BYTE PTR forbuff$[rsp+rcx], 41		; 00000029H
	mov	edx, r14d
	mov	rax, r14
	je	SHORT $LN22@HllStartDi
	npad	11
$LL24@HllStartDi:

; 1505 :         forbuffcnt[b] = forbuff[j];

	movzx	edi, BYTE PTR forbuff$[rsp+rcx]

; 1506 :         if (forbuffcnt[b] == ',' && forbuff[j - 1] != 39 && forbuff[j + 1] != 39) ++cmcnt;

	cmp	dil, 44					; 0000002cH
	mov	BYTE PTR forbuffcnt$[rsp+rax], dil
	jne	SHORT $LN21@HllStartDi
	cmp	BYTE PTR forbuff$[rsp+rcx-1], 39	; 00000027H
	je	SHORT $LN21@HllStartDi
	cmp	BYTE PTR forbuff$[rsp+rcx+1], 39	; 00000027H
	je	SHORT $LN21@HllStartDi
	inc	ebp
$LN21@HllStartDi:

; 1507 :         if (forbuffcnt[b] == 39 && forbuffcnt[b - 2] == 39) {

	cmp	dil, 39					; 00000027H
	jne	SHORT $LN23@HllStartDi
	cmp	BYTE PTR forbuffcnt$[rsp+rax-2], dil
	jne	SHORT $LN23@HllStartDi

; 1508 :           b++;

	inc	edx
	inc	rax

; 1509 :           forbuffcnt[b] = ' ';

	mov	BYTE PTR forbuffcnt$[rsp+rax], 32	; 00000020H
$LN23@HllStartDi:
	inc	rcx
	inc	edx
	inc	rax
	cmp	BYTE PTR forbuff$[rsp+rcx], 41		; 00000029H
	jne	SHORT $LL24@HllStartDi
$LN22@HllStartDi:

; 1510 :         }
; 1511 :       }
; 1512 :       if (forbuffcnt[b - 1] == ')') b--;

	movsxd	rax, edx
	cmp	BYTE PTR forbuffcnt$[rsp+rax-1], 41	; 00000029H
	jne	SHORT $LN19@HllStartDi
	dec	edx
$LN19@HllStartDi:

; 1513 :       forbuffcnt[b] = NULLC;
; 1514 :       //create valid command and add to LineQueue to initiate .for loop vars
; 1515 :       //anything that is before the first ':'
; 1516 :       if (forbuffinit[0]) ForInitAndNext(tokenarray, eqcnt, forbuffinit);

	cmp	BYTE PTR forbuffinit$[rsp], r13b
	movsxd	rax, edx
	mov	BYTE PTR forbuffcnt$[rsp+rax], r13b
	je	SHORT $LN18@HllStartDi
	lea	r8, QWORD PTR forbuffinit$[rsp]
	mov	edx, r9d
	mov	rcx, rsi
	call	ForInitAndNext
$LN18@HllStartDi:

; 1517 :       //note hll->counterlines is new var in the struct hll_item for store of forbuffcnt used in .ENDFOR
; 1518 :       //hll->cmcnt is also new var in the struct hll_item for commas counter used in .ENDFOR
; 1519 :       //copy forbuffcnt context to hll->counterlines
; 1520 :       //forbuffcnt contains anything that is written after the second ':'
; 1521 :       hll->cmcnt = 0;
; 1522 :       if (forbuffcnt[0])

	cmp	BYTE PTR forbuffcnt$[rsp], r13b
	mov	DWORD PTR [rbx+64], r14d
	je	SHORT $LN17@HllStartDi

; 1523 :       {
; 1524 :         //skip altering conditions the first time
; 1525 :         AddLineQueueX(" jmp %s", GetLabelStr(hll->labels[LSKIP], buff));

	mov	r8d, DWORD PTR [rbx+20]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6398
	call	AddLineQueueX

; 1526 :         size = strlen(forbuffcnt) + 1;

	xor	eax, eax
	lea	rdi, QWORD PTR forbuffcnt$[rsp]
	mov	rcx, -1
	repne scasb
	not	rcx
	and	ecx, ecx

; 1527 :         hll->counterlines = LclAlloc(size);

	movsxd	rdi, ecx
	mov	rcx, rdi
	call	LclAlloc

; 1528 :         memcpy(hll->counterlines, forbuffcnt, size);

	lea	rdx, QWORD PTR forbuffcnt$[rsp]
	mov	r8, rdi
	mov	rcx, rax
	mov	QWORD PTR [rbx+56], rax
	call	memcpy

; 1529 :         hll->cmcnt = cmcnt + 1;

	lea	edx, DWORD PTR [rbp+1]
	mov	DWORD PTR [rbx+64], edx
	jmp	SHORT $LN16@HllStartDi
$LN17@HllStartDi:

; 1530 :       }
; 1531 :       else hll->counterlines = "";    //there is nothing after the second ':'

	lea	rax, OFFSET FLAT:$SG6400
	mov	QWORD PTR [rbx+56], rax
$LN16@HllStartDi:

; 1532 :       if (forbuffcond[0]) {

	cmp	BYTE PTR forbuffcond$[rsp], r13b
	je	$LN12@HllStartDi

; 1533 :         strcpy(transformed, ".for ");

	mov	eax, DWORD PTR $SG6402
	lea	rcx, QWORD PTR transformed$[rsp]

; 1534 :         strcat(transformed, forbuffcond);

	lea	rdi, QWORD PTR transformed$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG6402+4
	lea	rdx, QWORD PTR forbuffcond$[rsp]
	mov	WORD PTR [rcx+4], ax
	xor	eax, eax
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	7
$LL316@HllStartDi:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL316@HllStartDi

; 1535 :         strcat(transformed, "\0");

	xor	eax, eax
	lea	rdi, QWORD PTR transformed$[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, OFFSET FLAT:$SG6403
	npad	5
$LL315@HllStartDi:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL315@HllStartDi

; 1536 :         tokenarray[0].string_ptr = ".for\0";

	lea	rax, OFFSET FLAT:$SG6404

; 1537 :         tokenarray[0].tokpos = transformed;
; 1538 :         Token_Count = Tokenize(tokenarray[0].tokpos, 0, tokenarray, 0);

	lea	rcx, QWORD PTR transformed$[rsp]
	xor	r9d, r9d
	mov	QWORD PTR [rsi+8], rax
	lea	rax, QWORD PTR transformed$[rsp]
	mov	r8, rsi
	xor	edx, edx
	mov	QWORD PTR [rsi+24], rax
	call	Tokenize
	mov	DWORD PTR ModuleInfo+496, eax

; 1539 :         if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], r13b
	je	$LN14@HllStartDi

; 1540 :           rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, TRUE, buffer);

	lea	rax, QWORD PTR hllop$8390[rsp]
	lea	rdx, QWORD PTR i$[rsp]
	mov	r9d, 2
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR buffer$[rsp]
	mov	r8, rsi
	mov	QWORD PTR [rsp+40], rax
	mov	rcx, rbx
	mov	QWORD PTR hllop$8390[rsp], r14
	mov	BYTE PTR [rsp+32], 1
	mov	DWORD PTR hllop$8390[rsp+8], r14d
	mov	BYTE PTR buffer$[rsp], r13b
	lea	rbp, QWORD PTR buffer$[rsp]
	call	GetAndExpression
	cmp	eax, -1
	je	$LN310@HllStartDi
	movsxd	rcx, DWORD PTR i$[rsp]
	shl	rcx, 5
	add	rcx, rsi
	call	GetCOp
	cmp	eax, 8
	jne	SHORT $LN123@HllStartDi
	npad	8
$LL137@HllStartDi:
	inc	DWORD PTR i$[rsp]
	xor	eax, eax
	mov	rdi, rbp
	mov	rcx, -1
	lea	rdx, QWORD PTR i$[rsp]
	mov	r9d, 2
	repne scasb
	lea	rax, QWORD PTR hllop$8390[rsp]
	mov	r8, rsi
	not	rcx
	mov	QWORD PTR [rsp+48], rax
	mov	DWORD PTR hllop$8390[rsp+8], r14d
	dec	rcx
	add	rbp, rcx
	mov	rcx, rbx
	mov	QWORD PTR [rsp+40], rbp
	mov	BYTE PTR [rsp+32], 1
	call	GetAndExpression
	cmp	eax, -1
	je	SHORT $LN310@HllStartDi
	movsxd	rcx, DWORD PTR i$[rsp]
	shl	rcx, 5
	add	rcx, rsi
	call	GetCOp
	cmp	eax, 8
	je	SHORT $LL137@HllStartDi
$LN123@HllStartDi:
	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], r13b
	je	SHORT $LN311@HllStartDi
	mov	ecx, 199				; 000000c7H
	call	EmitError

; 1541 :           if (rc == NOT_ERROR) {

	test	eax, eax
	mov	r13d, eax
	jne	SHORT $LN12@HllStartDi
$LN311@HllStartDi:

; 1542 :             size = strlen(buffer) + 1;

	xor	eax, eax
	lea	rdi, QWORD PTR buffer$[rsp]
	mov	rcx, -1
	repne scasb
	not	rcx
	and	ecx, ecx

; 1543 :             hll->condlines = LclAlloc(size);

	movsxd	rdi, ecx
	mov	rcx, rdi
	call	LclAlloc

; 1544 :             memcpy(hll->condlines, buffer, size);

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	r8, rdi
	mov	rcx, rax
	mov	QWORD PTR [rbx+48], rax
	call	memcpy

; 1545 :             DebugCmd(cntCond++); DebugCmd(cntCondBytes += size);
; 1546 :           }
; 1547 :         }
; 1548 :         else

	jmp	SHORT $LN12@HllStartDi
$LN310@HllStartDi:

; 1540 :           rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, TRUE, buffer);

	mov	r13d, -1
	jmp	SHORT $LN12@HllStartDi
$LN14@HllStartDi:

; 1549 :           hll->condlines = "";

	lea	rax, OFFSET FLAT:$SG6408
	mov	QWORD PTR [rbx+48], rax
$LN12@HllStartDi:

; 1550 :       }
; 1551 :     }
; 1552 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LSTART], buff));

	mov	r8d, DWORD PTR [rbx+16]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6409
	call	AddLineQueueX

; 1553 :     tokenarray[i].token = T_FINAL;

	movsxd	rdx, DWORD PTR i$[rsp]
	shl	rdx, 5
	mov	BYTE PTR [rdx+rsi], r14b

; 1554 :     break;

	jmp	$LN77@HllStartDi
$LN11@HllStartDi:

; 1555 :     //end of .FOR
; 1556 :   case T_DOT_WHILE:
; 1557 :   case T_DOT_REPEAT:
; 1558 :     /* create the label to start of loop */
; 1559 :     hll->labels[LSTART] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax

; 1560 :     hll->labels[LTEST] = 0; /* v2.11: test label is created only if needed */
; 1561 :                             //hll->labels[LEXIT] = GetHllLabel(); /* v2.11: LEXIT is only needed for .BREAK */
; 1562 :     if (cmd == T_DOT_WHILE) {

	cmp	edi, 330				; 0000014aH
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+16], eax
	mov	DWORD PTR [rbx+8], r14d
	jne	$LN10@HllStartDi

; 1563 :       hll->cmd = HLL_WHILE;
; 1564 :       hll->condlines = NULL;

	mov	QWORD PTR [rbx+48], r14
	mov	r9d, 1
	mov	DWORD PTR [rbx+68], r9d

; 1565 :       if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], r13b
	je	$LN9@HllStartDi

; 1566 :         /* Here we need second test label if && is in second breckets*/
; 1567 :        // __debugbreak();
; 1568 :         rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, TRUE, buffer);

	lea	rax, QWORD PTR hllop$8680[rsp]
	lea	rdx, QWORD PTR i$[rsp]
	mov	r8, rsi
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR buffer$[rsp]
	mov	rcx, rbx
	mov	QWORD PTR [rsp+40], rax
	mov	BYTE PTR [rsp+32], r9b
	mov	r9d, 2
	mov	QWORD PTR hllop$8680[rsp], r14
	mov	DWORD PTR hllop$8680[rsp+8], r14d
	mov	BYTE PTR buffer$[rsp], r13b
	lea	rbp, QWORD PTR buffer$[rsp]
	call	GetAndExpression
	cmp	eax, -1
	je	$LN312@HllStartDi
	movsxd	rcx, DWORD PTR i$[rsp]
	shl	rcx, 5
	add	rcx, rsi
	call	GetCOp
	cmp	eax, 8
	jne	SHORT $LN203@HllStartDi
$LL217@HllStartDi:
	inc	DWORD PTR i$[rsp]
	xor	eax, eax
	mov	rdi, rbp
	mov	rcx, -1
	lea	rdx, QWORD PTR i$[rsp]
	mov	r9d, 2
	repne scasb
	lea	rax, QWORD PTR hllop$8680[rsp]
	mov	r8, rsi
	not	rcx
	mov	QWORD PTR [rsp+48], rax
	mov	DWORD PTR hllop$8680[rsp+8], r14d
	dec	rcx
	add	rbp, rcx
	mov	rcx, rbx
	mov	QWORD PTR [rsp+40], rbp
	mov	BYTE PTR [rsp+32], 1
	call	GetAndExpression
	cmp	eax, -1
	je	SHORT $LN312@HllStartDi
	movsxd	rcx, DWORD PTR i$[rsp]
	shl	rcx, 5
	add	rcx, rsi
	call	GetCOp
	cmp	eax, 8
	je	SHORT $LL217@HllStartDi
$LN203@HllStartDi:
	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], r13b
	je	SHORT $LN313@HllStartDi
	mov	ecx, 199				; 000000c7H
	call	EmitError

; 1569 :         if (rc == NOT_ERROR) {

	test	eax, eax
	mov	r13d, eax
	jne	SHORT $LN7@HllStartDi
$LN313@HllStartDi:

; 1570 :           int size;
; 1571 :           size = strlen(buffer) + 1;

	xor	eax, eax
	lea	rdi, QWORD PTR buffer$[rsp]
	mov	rcx, -1
	repne scasb
	not	rcx
	and	ecx, ecx

; 1572 :           hll->condlines = LclAlloc(size);

	movsxd	rdi, ecx
	mov	rcx, rdi
	call	LclAlloc

; 1573 :           memcpy(hll->condlines, buffer, size);

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	r8, rdi
	mov	rcx, rax
	mov	QWORD PTR [rbx+48], rax
	call	memcpy

; 1574 :           DebugCmd(cntCond++); DebugCmd(cntCondBytes += size);
; 1575 :         }
; 1576 :       }
; 1577 :       else

	jmp	SHORT $LN7@HllStartDi
$LN312@HllStartDi:

; 1566 :         /* Here we need second test label if && is in second breckets*/
; 1567 :        // __debugbreak();
; 1568 :         rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, TRUE, buffer);

	mov	r13d, -1
	jmp	SHORT $LN7@HllStartDi
$LN9@HllStartDi:

; 1578 :         buffer[0] = NULLC;  /* just ".while" without expression is accepted */

	mov	BYTE PTR buffer$[rsp], r13b
$LN7@HllStartDi:

; 1579 : 
; 1580 :                             /* create a jump to test label */
; 1581 :                             /* optimisation: if line at 'test' label is just a jump, dont create label and don't jump! */
; 1582 :       if (_memicmp(buffer, "jmp", 3)) {

	lea	rdx, OFFSET FLAT:$SG6418
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	r8d, 3
	call	_memicmp
	test	eax, eax
	je	SHORT $LN5@HllStartDi

; 1583 :         hll->labels[LTEST] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352

; 1584 :         AddLineQueueX(JMPPREFIX "jmp %s", GetLabelStr(hll->labels[LTEST], buff));

	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	r8d, eax
	mov	DWORD PTR [rbx+8], eax
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6419
	call	AddLineQueueX

; 1585 :       }
; 1586 :     }
; 1587 :     else {

	jmp	SHORT $LN5@HllStartDi
$LN10@HllStartDi:

; 1588 :       hll->cmd = HLL_REPEAT;

	mov	DWORD PTR [rbx+68], 2
$LN5@HllStartDi:

; 1589 :     }
; 1590 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LSTART], buff));

	mov	r8d, DWORD PTR [rbx+16]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6421
	call	AddLineQueueX

; 1591 :     break;

	jmp	$LN77@HllStartDi
$LN79@HllStartDi:

; 1342 :   case T_DOT_IF:
; 1343 :     hll->labels[LSTART] = 0; /* not used by .IF */

	mov	DWORD PTR [rbx+16], r14d

; 1344 :     hll->labels[LTEST] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352

; 1345 :     hll->cmd = HLL_IF;
; 1346 :     hll->flags = 0;
; 1347 :     /* get the C-style expression, convert to ASM code lines */
; 1348 :     rc = EvaluateHllExpression(hll, &i, tokenarray, LTEST, FALSE, buffer);

	lea	rdx, QWORD PTR i$[rsp]
	inc	eax
	xor	r9d, r9d
	mov	r8, rsi
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+8], eax
	lea	rax, QWORD PTR hllop$8062[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR buffer$[rsp]
	mov	DWORD PTR [rbx+68], r14d
	mov	DWORD PTR [rbx+76], r14d
	mov	QWORD PTR [rsp+40], rax
	mov	rcx, rbx
	mov	BYTE PTR [rsp+32], r13b
	mov	QWORD PTR hllop$8062[rsp], r14
	mov	DWORD PTR hllop$8062[rsp+8], r14d
	mov	BYTE PTR buffer$[rsp], r13b
	call	GetExpression
	cmp	eax, -1
	jne	SHORT $LN89@HllStartDi
	mov	r13d, eax
	jmp	SHORT $LN77@HllStartDi
$LN89@HllStartDi:
	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], r13b
	je	SHORT $LN314@HllStartDi
	mov	ecx, 199				; 000000c7H
	call	EmitError

; 1349 :     if (rc == NOT_ERROR) {

	test	eax, eax
	mov	r13d, eax
	jne	SHORT $LN77@HllStartDi
$LN314@HllStartDi:

; 1350 :       QueueTestLines(buffer);

	lea	rdi, QWORD PTR buffer$[rsp]
	npad	4
$LL95@HllStartDi:
	mov	edx, 10
	mov	rcx, rdi
	mov	rbp, rdi
	call	strchr
	test	rax, rax
	mov	rdi, rax
	je	SHORT $LN93@HllStartDi
	mov	BYTE PTR [rax], r14b
	inc	rdi
$LN93@HllStartDi:
	cmp	BYTE PTR [rbp], r14b
	je	SHORT $LN92@HllStartDi
	mov	rcx, rbp
	call	AddLineQueue
$LN92@HllStartDi:
	test	rdi, rdi
	jne	SHORT $LL95@HllStartDi

; 1351 :       /* if no lines have been created, the LTEST label isn't needed */
; 1352 :       //if ( !is_linequeue_populated() ) {
; 1353 :       if (buffer[0] == NULLC) {

	cmp	BYTE PTR buffer$[rsp], r14b
	jne	SHORT $LN77@HllStartDi

; 1354 :         hll->labels[LTEST] = 0;

	mov	DWORD PTR [rbx+8], r14d
$LN77@HllStartDi:

; 1592 : #ifdef DEBUG_OUT
; 1593 :   default: /**/myassert(0); break;
; 1594 : #endif
; 1595 :   }
; 1596 : 
; 1597 :   if (tokenarray[i].token != T_FINAL && rc == NOT_ERROR) {

	movsxd	rdx, DWORD PTR i$[rsp]
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rsi], r14b
	je	SHORT $LN4@HllStartDi
	test	r13d, r13d
	jne	SHORT $LN4@HllStartDi

; 1598 :     DebugMsg(("HllStartDir: unexpected token [%s]\n", tokenarray[i].tokpos));
; 1599 :     EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos);

	mov	rdx, QWORD PTR [rdx+rsi+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 1600 :     rc = ERROR;

	mov	r13d, -1
$LN4@HllStartDi:

; 1601 :     //return( ERROR ); /* v2.08: continue and parse the line queue */
; 1602 :   }
; 1603 :   /* v2.06: remove the item from the free stack */
; 1604 :   if (hll == HllFree)

	cmp	rbx, QWORD PTR ModuleInfo+232
	jne	SHORT $LN3@HllStartDi

; 1605 :     HllFree = hll->next;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR ModuleInfo+232, rax
$LN3@HllStartDi:

; 1606 :   hll->next = HllStack;

	mov	rax, QWORD PTR ModuleInfo+224
	mov	QWORD PTR [rbx], rax

; 1607 :   HllStack = hll;
; 1608 : 
; 1609 :   if (ModuleInfo.list)

	bt	DWORD PTR ModuleInfo+408, 12
	mov	QWORD PTR ModuleInfo+224, rbx
	jae	SHORT $LN2@HllStartDi

; 1610 :     LstWrite(LSTTYPE_DIRECTIVE, GetCurrOffset(), NULL);

	call	GetCurrOffset
	xor	r8d, r8d
	lea	ecx, QWORD PTR [r8+4]
	mov	edx, eax
	call	LstWrite
$LN2@HllStartDi:

; 1611 : 
; 1612 :   if (is_linequeue_populated()) /* might be NULL! (".if 1") */

	cmp	QWORD PTR ModuleInfo+184, r14
	je	SHORT $LN1@HllStartDi

; 1613 :     RunLineQueue();

	call	RunLineQueue
$LN1@HllStartDi:

; 1614 : 
; 1615 :   return(rc);

	mov	eax, r13d
$LN84@HllStartDi:
	mov	r14, QWORD PTR [rsp+7376]
	mov	r13, QWORD PTR [rsp+7384]
	mov	rdi, QWORD PTR [rsp+7400]
	mov	rsi, QWORD PTR [rsp+7408]
	mov	rbp, QWORD PTR [rsp+7448]
	mov	rbx, QWORD PTR [rsp+7440]

; 1616 : }

	add	rsp, 7416				; 00001cf8H
	ret	0
HllStartDir ENDP
_TEXT	ENDS
PUBLIC	HllEndDir
EXTRN	Parse_Pass:DWORD
xdata	SEGMENT
$unwind$HllEndDir DD 0c3001H
	DD	0111d430H
	DD	0112c42cH
	DD	01137426H
	DD	01195422H
	DD	01183417H
	DD	01150113H
xdata	ENDS
pdata	SEGMENT
$pdata$HllEndDir DD @imagerel($LN541#)
	DD	@imagerel($LN541#+99)
	DD	@imagerel($unwind$HllEndDir#)
pdata	ENDS
xdata	SEGMENT
$chain$5$HllEndDir DD 020821H
	DD	01146408H
	DD	@imagerel($LN541#)
	DD	@imagerel($LN541#+99)
	DD	@imagerel($unwind$HllEndDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$HllEndDir DD @imagerel($LN541#+99)
	DD	@imagerel($LN541#+6907)
	DD	@imagerel($chain$5$HllEndDir#)
pdata	ENDS
xdata	SEGMENT
$chain$7$HllEndDir DD 041021H
	DD	010ff410H
	DD	0110e408H
	DD	@imagerel($LN541#+99)
	DD	@imagerel($LN541#+6907)
	DD	@imagerel($chain$5$HllEndDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$HllEndDir DD @imagerel($LN541#+6907)
	DD	@imagerel($LN541#+8870)
	DD	@imagerel($chain$7$HllEndDir#)
pdata	ENDS
xdata	SEGMENT
$chain$8$HllEndDir DD 021H
	DD	@imagerel($LN541#+99)
	DD	@imagerel($LN541#+6907)
	DD	@imagerel($chain$5$HllEndDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$HllEndDir DD @imagerel($LN541#+8870)
	DD	@imagerel($LN541#+10227)
	DD	@imagerel($chain$8$HllEndDir#)
pdata	ENDS
xdata	SEGMENT
$chain$9$HllEndDir DD 021H
	DD	@imagerel($LN541#)
	DD	@imagerel($LN541#+99)
	DD	@imagerel($unwind$HllEndDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$HllEndDir DD @imagerel($LN541#+10227)
	DD	@imagerel($LN541#+10276)
	DD	@imagerel($chain$9$HllEndDir#)
pdata	ENDS
xdata	SEGMENT
$chain$10$HllEndDir DD 020021H
	DD	01146400H
	DD	@imagerel($LN541#)
	DD	@imagerel($LN541#+99)
	DD	@imagerel($unwind$HllEndDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$10$HllEndDir DD @imagerel($LN541#+10276)
	DD	@imagerel($LN541#+10312)
	DD	@imagerel($chain$10$HllEndDir#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buff$ = 64
bcnt$1$ = 80
acnt$1$ = 84
hllop$9216 = 88
hllop$9193 = 88
buffer$ = 112
i$ = 2224
tokenarray$ = 2232
HllEndDir PROC NEAR

; 1624 : {

$LN541:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	mov	rax, rsp
	sub	rsp, 2216				; 000008a8H
	mov	QWORD PTR [rax+24], rbx

; 1625 :   //struct asym       *sym;
; 1626 :   struct hll_item     *hll;
; 1627 :   ret_code            rc = NOT_ERROR;
; 1628 :   int                 cmd = tokenarray[i].tokval;
; 1629 :   int                 j, n;
; 1630 :   int                 temp;
; 1631 :   int                 acnt = 0;
; 1632 :   int                 bcnt = 0;
; 1633 :   int                 dsize;
; 1634 :   uint_16             lbl;
; 1635 : 
; 1636 :   char buff[16];
; 1637 :   //char buffer[MAX_LINE_LEN*2];
; 1638 : 
; 1639 : 
; 1640 :   char buffer[MAX_LINE_LEN * 2];
; 1641 : 
; 1642 :   DebugMsg1(("HllEndDir(%s) enter\n", tokenarray[i].string_ptr));
; 1643 : 
; 1644 :   if (HllStack == NULL) {

	mov	rbx, QWORD PTR ModuleInfo+224
	mov	QWORD PTR [rax+32], rbp
	mov	QWORD PTR [rax-16], rdi
	xor	ebp, ebp
	mov	QWORD PTR [rax-24], r12
	mov	QWORD PTR [rax-32], r13
	movsxd	rax, ecx
	mov	rdi, rdx
	shl	rax, 5
	test	rbx, rbx
	mov	DWORD PTR acnt$1$[rsp], ebp
	mov	ecx, DWORD PTR [rax+rdx+16]
	mov	r13d, ebp
	mov	r12d, ebp
	mov	DWORD PTR bcnt$1$[rsp], ebp
	jne	SHORT $LN259@HllEndDir

; 1645 :     DebugMsg(("HllEndDir: hll stack is empty\n"));
; 1646 :     return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));

	mov	ecx, 245				; 000000f5H
	call	EmitError
	jmp	$LN260@HllEndDir
$LN259@HllEndDir:

; 1647 :   }
; 1648 : 
; 1649 :   hll = HllStack;
; 1650 :   HllStack = hll->next;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rsp+2208], rsi

; 1651 :   /* v2.06: move the item to the free stack */
; 1652 :   hll->next = HllFree;
; 1653 :   HllFree = hll;
; 1654 : 
; 1655 :   switch (cmd) {

	mov	esi, 4
	mov	QWORD PTR ModuleInfo+224, rax
	mov	rax, QWORD PTR ModuleInfo+232
	mov	QWORD PTR [rbx], rax
	lea	eax, DWORD PTR [rcx-336]
	mov	QWORD PTR ModuleInfo+232, rbx
	cmp	eax, 8
	ja	$LN535@HllEndDir
	lea	rdx, OFFSET FLAT:__ImageBase
	cdqe
	mov	ecx, DWORD PTR $LN534@HllEndDir[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN256@HllEndDir:

; 1656 :   case T_DOT_ENDIF:
; 1657 :     if (hll->cmd != HLL_IF) {

	cmp	DWORD PTR [rbx+68], ebp
	je	SHORT $LN255@HllEndDir
$LN540@HllEndDir:

; 1658 :       DebugMsg(("HllEndDir: no .IF on the hll stack\n"));
; 1659 :       return(EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr));

	movsxd	rdx, DWORD PTR i$[rsp]
	mov	ecx, 80					; 00000050H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+8]
	call	EmitErr
	jmp	$LN539@HllEndDir
$LN255@HllEndDir:

; 1660 :     }
; 1661 :     i++;

	inc	DWORD PTR i$[rsp]

; 1662 :     /* if a test label isn't created yet, create it */
; 1663 :     if (hll->labels[LTEST]) {

	mov	r8d, DWORD PTR [rbx+8]
	test	r8d, r8d
	je	$LN535@HllEndDir

; 1664 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6454
	call	AddLineQueueX

; 1665 :     }
; 1666 :     break;

	jmp	$LN535@HllEndDir
$LN253@HllEndDir:

; 1667 :     // added by habran
; 1668 :   case T_DOT_ENDSWITCH:
; 1669 :     if (hll->cmd != HLL_SWITCH) {

	cmp	DWORD PTR [rbx+68], 5
	je	SHORT $LN252@HllEndDir

; 1670 :       DebugMsg(("HllExitDir stack error\n"));
; 1671 :       return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));

	mov	ecx, 245				; 000000f5H
	call	EmitError
	jmp	$LN539@HllEndDir
$LN252@HllEndDir:

; 1672 :     }
; 1673 :     i++;

	inc	DWORD PTR i$[rsp]

; 1674 :     if (ModuleInfo.Ofssize == USE32) dsize = 4;

	cmp	BYTE PTR ModuleInfo+404, 1
	mov	edi, 8
	cmove	edi, esi

; 1675 : #if AMD64_SUPPORT
; 1676 :     else dsize = 8;
; 1677 : #endif
; 1678 :     if (ModuleInfo.switch_style == ASMSWITCH) {

	bt	DWORD PTR ModuleInfo+408, 20
	jb	SHORT $LN249@HllEndDir

; 1679 :       if (hll->labels[LEXIT] == 0)

	cmp	DWORD PTR [rbx+12], ebp
	jne	SHORT $LN248@HllEndDir

; 1680 :         hll->labels[LEXIT] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+12], eax
$LN248@HllEndDir:

; 1681 :       AddLineQueueX(JMPPREFIX "jmp %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6461
	call	AddLineQueueX
$LN249@HllEndDir:

; 1682 :     }
; 1683 :     if (hll->labels[LDEF] == 0) {

	cmp	DWORD PTR [rbx+28], ebp
	jne	SHORT $LN247@HllEndDir

; 1684 :       hll->labels[LDEF] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352

; 1685 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LDEF], buff));

	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	r8d, eax
	mov	DWORD PTR [rbx+28], eax
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6463
	call	AddLineQueueX
$LN247@HllEndDir:

; 1686 :     }
; 1687 :     AddLineQueueX("ALIGN %d", dsize);

	lea	rcx, OFFSET FLAT:$SG6464
	mov	edx, edi
	call	AddLineQueueX

; 1688 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LSTART], buff));

	mov	r8d, DWORD PTR [rbx+16]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6465
	call	AddLineQueueX

; 1689 :     if (Parse_Pass) {

	cmp	DWORD PTR Parse_Pass, ebp
	je	$LN151@HllEndDir

; 1690 :       if (hll->casecnt == 1)

	mov	r9d, DWORD PTR [rbx+80]
	cmp	r9d, 1
	jne	SHORT $LN245@HllEndDir

; 1691 :         hll->cflag = 1;

	mov	BYTE PTR [rbx+85], r9b
	jmp	$LN218@HllEndDir
$LN245@HllEndDir:

; 1692 :       else if (hll->casecnt == 2)

	cmp	r9d, 2
	jne	SHORT $LN243@HllEndDir

; 1693 :         hll->cflag = 2;

	mov	BYTE PTR [rbx+85], r9b
	jmp	$LN218@HllEndDir
$LN243@HllEndDir:

; 1694 :       else if (hll->casecnt == 3)

	cmp	r9d, 3
	jne	SHORT $LN241@HllEndDir

; 1695 :         hll->cflag = 3;

	mov	BYTE PTR [rbx+85], r9b

; 1696 :       else

	jmp	$LN218@HllEndDir
$LN241@HllEndDir:

; 1697 :       {
; 1698 :         if (hll->plabels) {

	mov	rdx, QWORD PTR [rbx+112]
	test	rdx, rdx
	je	$LN218@HllEndDir

; 1699 :           if (ModuleInfo.Ofssize == USE32) {

	cmp	BYTE PTR ModuleInfo+404, 1
	jne	SHORT $LN238@HllEndDir

; 1700 :             bubblesort(hll, hll->plabels, hll->pcases, hll->casecnt);

	mov	r8, QWORD PTR [rbx+104]
	mov	rcx, rbx
	call	bubblesort

; 1701 :             if ((hll->delta * 4) <= (hll->casecnt * 4 + hll->casecnt * 2))

	mov	eax, DWORD PTR [rbx+80]
	mov	r8d, DWORD PTR [rbx+96]
	lea	ecx, DWORD PTR [rax+rax*2]
	lea	edx, DWORD PTR [r8*4]
	add	ecx, ecx
	cmp	edx, ecx
	ja	SHORT $LN237@HllEndDir

; 1702 :               hll->cflag = 6;

	mov	BYTE PTR [rbx+85], 6
	jmp	$LN218@HllEndDir
$LN237@HllEndDir:

; 1703 :             else if (hll->delta < 256)

	cmp	r8d, 256				; 00000100H
	jge	SHORT $LN235@HllEndDir

; 1704 :               hll->cflag = 4;

	mov	BYTE PTR [rbx+85], sil
	jmp	$LN218@HllEndDir
$LN235@HllEndDir:

; 1705 :             else if (hll->delta < 512)

	mov	eax, 5
	mov	ecx, 7
	cmp	r8d, 512				; 00000200H
	cmovl	eax, ecx
	mov	BYTE PTR [rbx+85], al

; 1706 :               hll->cflag = 7;
; 1707 :             else
; 1708 :               hll->cflag = 5;
; 1709 :           }
; 1710 : #if AMD64_SUPPORT
; 1711 :           else {     //USE64

	jmp	$LN218@HllEndDir
$LN238@HllEndDir:

; 1712 :             if (hll->csize == 4) {

	cmp	BYTE PTR [rbx+84], sil
	jne	SHORT $LN230@HllEndDir

; 1713 :               bubblesort(hll, hll->plabels, hll->pcases, hll->casecnt);

	mov	r8, QWORD PTR [rbx+104]
	mov	rcx, rbx
	call	bubblesort

; 1714 :               if ((hll->delta * 8) <= (hll->casecnt * 8 + hll->casecnt * 2))

	mov	eax, DWORD PTR [rbx+80]
	mov	r8d, DWORD PTR [rbx+96]
	lea	ecx, DWORD PTR [rax+rax*4]
	lea	edx, DWORD PTR [r8*8]
	add	ecx, ecx
	cmp	edx, ecx
	ja	SHORT $LN229@HllEndDir

; 1715 :                 hll->cflag = 6;

	mov	BYTE PTR [rbx+85], 6
	jmp	$LN218@HllEndDir
$LN229@HllEndDir:

; 1716 :               else if (hll->delta < 256)

	cmp	r8d, 256				; 00000100H
	jge	SHORT $LN227@HllEndDir

; 1717 :                 hll->cflag = 4;

	mov	BYTE PTR [rbx+85], sil
	jmp	SHORT $LN218@HllEndDir
$LN227@HllEndDir:

; 1718 :               else if (hll->delta < 512)

	mov	eax, 5
	mov	ecx, 7
	cmp	r8d, 512				; 00000200H
	cmovl	eax, ecx
	mov	BYTE PTR [rbx+85], al

; 1719 :                 hll->cflag = 7;
; 1720 :               else
; 1721 :                 hll->cflag = 5;
; 1722 :             }
; 1723 :             else {

	jmp	SHORT $LN218@HllEndDir
$LN230@HllEndDir:

; 1724 :               bubblesort64(hll, hll->plabels, hll->pcases64, hll->casecnt);

	mov	r8, QWORD PTR [rbx+152]
	mov	rcx, rbx
	call	bubblesort64

; 1725 :               if ((hll->delta64 * 8) <= (hll->casecnt * 8 + hll->casecnt * 2))

	mov	eax, DWORD PTR [rbx+80]
	mov	r8, QWORD PTR [rbx+144]
	lea	ecx, DWORD PTR [rax+rax*4]
	lea	rax, QWORD PTR [r8*8]
	lea	edx, DWORD PTR [rcx+rcx]
	cmp	rax, rdx
	ja	SHORT $LN222@HllEndDir

; 1726 :                 hll->cflag = 6;

	mov	BYTE PTR [rbx+85], 6
	jmp	SHORT $LN218@HllEndDir
$LN222@HllEndDir:

; 1727 :               else if (hll->delta64 < 256)

	cmp	r8, 256					; 00000100H
	jae	SHORT $LN220@HllEndDir

; 1728 :                 hll->cflag = 4;

	mov	BYTE PTR [rbx+85], sil
	jmp	SHORT $LN218@HllEndDir
$LN220@HllEndDir:

; 1729 :               else if (hll->delta64 < 512)

	mov	eax, 5
	mov	ecx, 7
	cmp	r8, 512					; 00000200H
	cmovb	eax, ecx
	mov	BYTE PTR [rbx+85], al
$LN218@HllEndDir:

; 1730 :                 hll->cflag = 7;
; 1731 :               else
; 1732 :                 hll->cflag = 5;
; 1733 :             }
; 1734 :           }
; 1735 : #endif
; 1736 :         }
; 1737 :       }
; 1738 :       if (hll->cflag == 1) {

	movzx	eax, BYTE PTR [rbx+85]
	cmp	al, 1
	jne	$LN216@HllEndDir

; 1739 :         if ((ModuleInfo.Ofssize == USE32) || (hll->csize == 4)) {

	cmp	BYTE PTR ModuleInfo+404, al
	je	$LN214@HllEndDir
	cmp	BYTE PTR [rbx+84], sil
	je	$LN214@HllEndDir

; 1746 :         }
; 1747 : #if AMD64_SUPPORT
; 1748 :         else
; 1749 :         {
; 1750 :           AddLineQueueX("push rdx");

	lea	rcx, OFFSET FLAT:$SG6506
	call	AddLineQueueX

; 1751 :           AddLineQueueX("mov rdx, %q", hll->pcases64[0]);

	mov	rdx, QWORD PTR [rbx+152]
	lea	rcx, OFFSET FLAT:$SG6507
	mov	rdx, QWORD PTR [rdx]
	call	AddLineQueueX

; 1752 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG6508
	call	AddLineQueueX

; 1753 :           AddLineQueueX("pop rdx");

	lea	rcx, OFFSET FLAT:$SG6509
	call	AddLineQueueX

; 1754 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[0], buff));

	mov	r11, QWORD PTR [rbx+112]
	lea	rdx, OFFSET FLAT:$SG5756
	movzx	r8d, WORD PTR [r11]
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6510
	call	AddLineQueueX

; 1755 :           if (hll->flags & HLLF_DEFAULTOCCURED)

	test	BYTE PTR [rbx+76], 2
	je	SHORT $LN210@HllEndDir

; 1756 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+28]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6512
	call	AddLineQueueX

; 1757 :           else

	jmp	$LN151@HllEndDir
$LN210@HllEndDir:

; 1758 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6514
	call	AddLineQueueX
	jmp	$LN151@HllEndDir
$LN214@HllEndDir:

; 1740 :           AddLineQueueX("cmp  eax,%d", hll->pcases[0]);

	mov	rax, QWORD PTR [rbx+104]
	lea	rcx, OFFSET FLAT:$SG6499
	mov	edx, DWORD PTR [rax]
	call	AddLineQueueX

; 1741 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[0], buff));

	mov	r11, QWORD PTR [rbx+112]
	lea	rdx, OFFSET FLAT:$SG5756
	movzx	r8d, WORD PTR [r11]
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6500
	call	AddLineQueueX

; 1742 :           if (hll->flags & HLLF_DEFAULTOCCURED)

	test	BYTE PTR [rbx+76], 2
	je	SHORT $LN213@HllEndDir

; 1743 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+28]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6502
	call	AddLineQueueX

; 1744 :           else

	jmp	$LN151@HllEndDir
$LN213@HllEndDir:

; 1745 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6504
	call	AddLineQueueX

; 1759 :         }

	jmp	$LN151@HllEndDir
$LN216@HllEndDir:

; 1760 : #endif
; 1761 :       }
; 1762 :       else if (hll->cflag == 2) {

	cmp	al, 2
	jne	$LN207@HllEndDir

; 1763 :         if ((ModuleInfo.Ofssize == USE32) || (hll->csize == 4)) {

	cmp	BYTE PTR ModuleInfo+404, 1
	je	$LN205@HllEndDir
	cmp	BYTE PTR [rbx+84], sil
	je	$LN205@HllEndDir

; 1772 :         }
; 1773 : #if AMD64_SUPPORT
; 1774 :         else
; 1775 :         {
; 1776 :           AddLineQueueX("push rdx");

	lea	rcx, OFFSET FLAT:$SG6528
	call	AddLineQueueX

; 1777 :           AddLineQueueX("mov rdx, %q", hll->pcases64[0]);

	mov	rdx, QWORD PTR [rbx+152]
	lea	rcx, OFFSET FLAT:$SG6529
	mov	rdx, QWORD PTR [rdx]
	call	AddLineQueueX

; 1778 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG6530
	call	AddLineQueueX

; 1779 :           AddLineQueueX("pop rdx");

	lea	rcx, OFFSET FLAT:$SG6531
	call	AddLineQueueX

; 1780 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[0], buff));

	mov	rax, QWORD PTR [rbx+112]
	lea	rdx, OFFSET FLAT:$SG5756
	movzx	r8d, WORD PTR [rax]
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6532
	call	AddLineQueueX

; 1781 :           AddLineQueueX("push rdx");

	lea	rcx, OFFSET FLAT:$SG6533
	call	AddLineQueueX

; 1782 :           AddLineQueueX("mov rdx, %q", hll->pcases64[1]);

	mov	rdx, QWORD PTR [rbx+152]
	lea	rcx, OFFSET FLAT:$SG6534
	mov	rdx, QWORD PTR [rdx+8]
	call	AddLineQueueX

; 1783 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG6535
	call	AddLineQueueX

; 1784 :           AddLineQueueX("pop rdx");

	lea	rcx, OFFSET FLAT:$SG6536
	call	AddLineQueueX

; 1785 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[1], buff));

	mov	r11, QWORD PTR [rbx+112]
	lea	rdx, OFFSET FLAT:$SG5756
	movzx	r8d, WORD PTR [r11+2]
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6537
	call	AddLineQueueX

; 1786 :           if (hll->flags & HLLF_DEFAULTOCCURED)

	test	BYTE PTR [rbx+76], 2
	je	SHORT $LN201@HllEndDir

; 1787 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+28]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6539
	call	AddLineQueueX

; 1788 :           else

	jmp	$LN151@HllEndDir
$LN201@HllEndDir:

; 1789 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6541
	call	AddLineQueueX
	jmp	$LN151@HllEndDir
$LN205@HllEndDir:

; 1764 :           AddLineQueueX("cmp  eax,%d", hll->pcases[0]);

	mov	rax, QWORD PTR [rbx+104]
	lea	rcx, OFFSET FLAT:$SG6519
	mov	edx, DWORD PTR [rax]
	call	AddLineQueueX

; 1765 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[0], buff));

	mov	rax, QWORD PTR [rbx+112]
	lea	rdx, OFFSET FLAT:$SG5756
	movzx	r8d, WORD PTR [rax]
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6520
	call	AddLineQueueX

; 1766 :           AddLineQueueX("cmp  eax,%d", hll->pcases[1]);

	mov	r11, QWORD PTR [rbx+104]
	lea	rcx, OFFSET FLAT:$SG6521
	mov	edx, DWORD PTR [r11+4]
	call	AddLineQueueX

; 1767 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[1], buff));

	mov	r11, QWORD PTR [rbx+112]
	lea	rdx, OFFSET FLAT:$SG5756
	movzx	r8d, WORD PTR [r11+2]
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6522
	call	AddLineQueueX

; 1768 :           if (hll->flags & HLLF_DEFAULTOCCURED)

	test	BYTE PTR [rbx+76], 2
	je	SHORT $LN204@HllEndDir

; 1769 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+28]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6524
	call	AddLineQueueX

; 1770 :           else

	jmp	$LN151@HllEndDir
$LN204@HllEndDir:

; 1771 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6526
	call	AddLineQueueX

; 1790 :         }

	jmp	$LN151@HllEndDir
$LN207@HllEndDir:

; 1791 : #endif
; 1792 :       }
; 1793 :       else if (hll->cflag == 3) { 

	cmp	al, 3
	jne	$LN198@HllEndDir

; 1794 :         if ((ModuleInfo.Ofssize == USE32) || (hll->csize == 4)) {

	cmp	BYTE PTR ModuleInfo+404, 1
	je	$LN196@HllEndDir
	cmp	BYTE PTR [rbx+84], sil
	je	$LN196@HllEndDir

; 1805 :         }
; 1806 : #if AMD64_SUPPORT
; 1807 :         else
; 1808 :         {
; 1809 :           AddLineQueueX("push rdx");

	lea	rcx, OFFSET FLAT:$SG6557
	call	AddLineQueueX

; 1810 :           AddLineQueueX("mov rdx, %q", hll->pcases64[0]);

	mov	rdx, QWORD PTR [rbx+152]
	lea	rcx, OFFSET FLAT:$SG6558
	mov	rdx, QWORD PTR [rdx]
	call	AddLineQueueX

; 1811 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG6559
	call	AddLineQueueX

; 1812 :           AddLineQueueX("pop rdx");

	lea	rcx, OFFSET FLAT:$SG6560
	call	AddLineQueueX

; 1813 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[0], buff));

	mov	rax, QWORD PTR [rbx+112]
	lea	rdx, OFFSET FLAT:$SG5756
	movzx	r8d, WORD PTR [rax]
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6561
	call	AddLineQueueX

; 1814 :           AddLineQueueX("push rdx");

	lea	rcx, OFFSET FLAT:$SG6562
	call	AddLineQueueX

; 1815 :           AddLineQueueX("mov rdx, %q", hll->pcases64[1]);

	mov	rdx, QWORD PTR [rbx+152]
	lea	rcx, OFFSET FLAT:$SG6563
	mov	rdx, QWORD PTR [rdx+8]
	call	AddLineQueueX

; 1816 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG6564
	call	AddLineQueueX

; 1817 :           AddLineQueueX("pop rdx");

	lea	rcx, OFFSET FLAT:$SG6565
	call	AddLineQueueX

; 1818 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[1], buff));

	mov	r11, QWORD PTR [rbx+112]
	lea	rdx, OFFSET FLAT:$SG5756
	movzx	r8d, WORD PTR [r11+2]
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6566
	call	AddLineQueueX

; 1819 :           AddLineQueueX("push rdx");

	lea	rcx, OFFSET FLAT:$SG6567
	call	AddLineQueueX

; 1820 :           AddLineQueueX("mov rdx, %q", hll->pcases64[2]);

	mov	rdx, QWORD PTR [rbx+152]
	lea	rcx, OFFSET FLAT:$SG6568
	mov	rdx, QWORD PTR [rdx+16]
	call	AddLineQueueX

; 1821 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG6569
	call	AddLineQueueX

; 1822 :           AddLineQueueX("pop rdx");

	lea	rcx, OFFSET FLAT:$SG6570
	call	AddLineQueueX

; 1823 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[2], buff));

	mov	r11, QWORD PTR [rbx+112]
	lea	rdx, OFFSET FLAT:$SG5756
	movzx	r8d, WORD PTR [r11+4]
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6571
	call	AddLineQueueX

; 1824 :           if (hll->flags & HLLF_DEFAULTOCCURED)

	test	BYTE PTR [rbx+76], 2
	je	SHORT $LN192@HllEndDir

; 1825 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+28]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6573
	call	AddLineQueueX

; 1826 :           else

	jmp	$LN151@HllEndDir
$LN192@HllEndDir:

; 1827 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6575
	call	AddLineQueueX
	jmp	$LN151@HllEndDir
$LN196@HllEndDir:

; 1795 :           AddLineQueueX("cmp  eax,%d", hll->pcases[0]);

	mov	rax, QWORD PTR [rbx+104]
	lea	rcx, OFFSET FLAT:$SG6546
	mov	edx, DWORD PTR [rax]
	call	AddLineQueueX

; 1796 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[0], buff));

	mov	rax, QWORD PTR [rbx+112]
	lea	rdx, OFFSET FLAT:$SG5756
	movzx	r8d, WORD PTR [rax]
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6547
	call	AddLineQueueX

; 1797 :           AddLineQueueX("cmp  eax,%d", hll->pcases[1]);

	mov	r11, QWORD PTR [rbx+104]
	lea	rcx, OFFSET FLAT:$SG6548
	mov	edx, DWORD PTR [r11+4]
	call	AddLineQueueX

; 1798 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[1], buff));

	mov	r11, QWORD PTR [rbx+112]
	lea	rdx, OFFSET FLAT:$SG5756
	movzx	r8d, WORD PTR [r11+2]
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6549
	call	AddLineQueueX

; 1799 :           AddLineQueueX("cmp  eax,%d", hll->pcases[2]);

	mov	r11, QWORD PTR [rbx+104]
	lea	rcx, OFFSET FLAT:$SG6550
	mov	edx, DWORD PTR [r11+8]
	call	AddLineQueueX

; 1800 :           AddLineQueueX("je  %s", GetLabelStr(hll->plabels[2], buff));

	mov	r11, QWORD PTR [rbx+112]
	lea	rdx, OFFSET FLAT:$SG5756
	movzx	r8d, WORD PTR [r11+4]
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6551
	call	AddLineQueueX

; 1801 :           if (hll->flags & HLLF_DEFAULTOCCURED)

	test	BYTE PTR [rbx+76], 2
	je	SHORT $LN195@HllEndDir

; 1802 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+28]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6553
	call	AddLineQueueX

; 1803 :           else

	jmp	$LN151@HllEndDir
$LN195@HllEndDir:

; 1804 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6555
	call	AddLineQueueX

; 1828 :         }

	jmp	$LN151@HllEndDir
$LN198@HllEndDir:

; 1829 : #endif
; 1830 :       }
; 1831 :       else if (hll->cflag == 4) {

	cmp	al, sil
	jne	$LN189@HllEndDir

; 1832 :         if (hll->flags & HLLF_DEFAULTOCCURED)

	test	BYTE PTR [rbx+76], 2
	je	SHORT $LN188@HllEndDir

; 1833 :           GetLabelStr(hll->labels[LDEF], buff);

	mov	r8d, DWORD PTR [rbx+28]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf

; 1834 :         else {

	jmp	SHORT $LN324@HllEndDir
$LN188@HllEndDir:

; 1835 :           GetLabelStr(hll->labels[LEXIT], buff);

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
$LN324@HllEndDir:

; 1836 :         }
; 1837 :         if (hll->csize == 4) {

	cmp	BYTE PTR [rbx+84], sil
	jne	SHORT $LN186@HllEndDir

; 1838 :           AddLineQueueX("cmp eax,%d", hll->mincase);

	mov	edx, DWORD PTR [rbx+92]
	lea	rcx, OFFSET FLAT:$SG6581
	call	AddLineQueueX

; 1839 :           AddLineQueueX("jl  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6582
	call	AddLineQueueX

; 1840 :           AddLineQueueX("cmp eax,%d", hll->maxcase);

	mov	edx, DWORD PTR [rbx+88]
	lea	rcx, OFFSET FLAT:$SG6583
	call	AddLineQueueX

; 1841 :           AddLineQueueX("ja  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6584
	call	AddLineQueueX

; 1842 :         }
; 1843 : #if AMD64_SUPPORT
; 1844 :         else {

	jmp	$LN185@HllEndDir
$LN186@HllEndDir:

; 1845 :           AddLineQueueX("push	rax");

	lea	rcx, OFFSET FLAT:$SG6586
	call	AddLineQueueX

; 1846 :           AddLineQueueX("push	rdx");

	lea	rcx, OFFSET FLAT:$SG6587
	call	AddLineQueueX

; 1847 :           AddLineQueueX("mov rdx, %q", hll->mincase64);

	mov	rdx, QWORD PTR [rbx+136]
	lea	rcx, OFFSET FLAT:$SG6588
	call	AddLineQueueX

; 1848 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG6589
	call	AddLineQueueX

; 1849 :           AddLineQueueX("pop	rdx");

	lea	rcx, OFFSET FLAT:$SG6590
	call	AddLineQueueX

; 1850 :           AddLineQueueX("pop	rax");

	lea	rcx, OFFSET FLAT:$SG6591
	call	AddLineQueueX

; 1851 :           AddLineQueueX("jl  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6592
	call	AddLineQueueX

; 1852 :           AddLineQueueX("mov rdx, %q", hll->maxcase64);

	mov	rdx, QWORD PTR [rbx+128]
	lea	rcx, OFFSET FLAT:$SG6593
	call	AddLineQueueX

; 1853 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG6594
	call	AddLineQueueX

; 1854 :           AddLineQueueX("pop	rdx");

	lea	rcx, OFFSET FLAT:$SG6595
	call	AddLineQueueX

; 1855 :           AddLineQueueX("pop	rax");

	lea	rcx, OFFSET FLAT:$SG6596
	call	AddLineQueueX

; 1856 :           AddLineQueueX("ja  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6597
	call	AddLineQueueX
$LN185@HllEndDir:

; 1857 :         }
; 1858 : #endif
; 1859 :         if (ModuleInfo.Ofssize == USE32) {

	cmp	BYTE PTR ModuleInfo+404, 1
	jne	$LN184@HllEndDir

; 1860 :           GetLabelStr(hll->labels[LDATA2], buff);

	mov	r8d, DWORD PTR [rbx+36]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf

; 1861 :           AddLineQueueX("push	 eax");

	lea	rcx, OFFSET FLAT:$SG6599
	call	AddLineQueueX

; 1862 :           AddLineQueueX("movzx eax,byte ptr %s[%r - %d]", buff, T_EAX, hll->mincase);

	mov	r9d, DWORD PTR [rbx+92]
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6600
	mov	r8d, 17
	call	AddLineQueueX

; 1863 :           GetLabelStr(hll->labels[LDATA1], buff);

	mov	r8d, DWORD PTR [rbx+32]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf

; 1864 :           AddLineQueueX("mov   eax,%s[%r*4]", buff, T_EAX);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6601
	mov	r8d, 17
	call	AddLineQueueX

; 1865 :           AddLineQueueX("xchg	 eax,[esp]");

	lea	rcx, OFFSET FLAT:$SG6602
	call	AddLineQueueX

; 1866 :           AddLineQueueX("retn");

	lea	rcx, OFFSET FLAT:$SG6603
	call	AddLineQueueX

; 1867 :         }
; 1868 : #if AMD64_SUPPORT
; 1869 :         else {

	jmp	$LN151@HllEndDir
$LN184@HllEndDir:

; 1870 :           if (hll->csize == 4) {

	cmp	BYTE PTR [rbx+84], sil
	jne	$LN182@HllEndDir

; 1871 :             GetLabelStr(hll->labels[LDATA2], buff);

	mov	r8d, DWORD PTR [rbx+36]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf

; 1872 :             AddLineQueueX("push	rax");

	lea	rcx, OFFSET FLAT:$SG6606
	call	AddLineQueueX

; 1873 :             AddLineQueueX("push	rdx");

	lea	rcx, OFFSET FLAT:$SG6607
	call	AddLineQueueX

; 1874 :             AddLineQueueX("lea   rdx,%s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6608
	call	AddLineQueueX

; 1875 :             AddLineQueueX("movzx edx,byte ptr[rdx+rax-%u]", hll->mincase);

	mov	edx, DWORD PTR [rbx+92]
	lea	rcx, OFFSET FLAT:$SG6609
	call	AddLineQueueX

; 1876 :             GetLabelStr(hll->labels[LDATA1], buff);

	mov	r8d, DWORD PTR [rbx+32]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf

; 1877 :             AddLineQueueX("lea   rax,%s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6610
	call	AddLineQueueX

; 1878 :             AddLineQueueX("mov   rax, qword ptr[rax+rdx*8]");

	lea	rcx, OFFSET FLAT:$SG6611
	call	AddLineQueueX

; 1879 :             AddLineQueueX("pop   rdx");

	lea	rcx, OFFSET FLAT:$SG6612
	call	AddLineQueueX

; 1880 :             AddLineQueueX("xchg	 rax,[rsp]");

	lea	rcx, OFFSET FLAT:$SG6613
	call	AddLineQueueX

; 1881 :             AddLineQueueX("retn");

	lea	rcx, OFFSET FLAT:$SG6614
	call	AddLineQueueX

; 1882 :           }
; 1883 :           else {

	jmp	$LN151@HllEndDir
$LN182@HllEndDir:

; 1884 :             GetLabelStr(hll->labels[LDATA2], buff);

	mov	r8d, DWORD PTR [rbx+36]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf

; 1885 :             AddLineQueueX("push	rax");

	lea	rcx, OFFSET FLAT:$SG6616
	call	AddLineQueueX

; 1886 :             AddLineQueueX("push	rdx");

	lea	rcx, OFFSET FLAT:$SG6617
	call	AddLineQueueX

; 1887 :             AddLineQueueX("lea   rdx,%s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6618
	call	AddLineQueueX

; 1888 :             AddLineQueueX("movzx rdx,byte ptr[rdx+rax-%q]", hll->mincase64);

	mov	rdx, QWORD PTR [rbx+136]
	lea	rcx, OFFSET FLAT:$SG6619
	call	AddLineQueueX

; 1889 :             GetLabelStr(hll->labels[LDATA1], buff);

	mov	r8d, DWORD PTR [rbx+32]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf

; 1890 :             AddLineQueueX("lea   rax,%s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6620
	call	AddLineQueueX

; 1891 :             AddLineQueueX("mov   rax, qword ptr[rax+rdx*8]");

	lea	rcx, OFFSET FLAT:$SG6621
	call	AddLineQueueX

; 1892 :             AddLineQueueX("pop   rdx");

	lea	rcx, OFFSET FLAT:$SG6622
	call	AddLineQueueX

; 1893 :             AddLineQueueX("xchg	 rax,[rsp]");

	lea	rcx, OFFSET FLAT:$SG6623
	call	AddLineQueueX

; 1894 :             AddLineQueueX("retn");

	lea	rcx, OFFSET FLAT:$SG6624
	call	AddLineQueueX

; 1895 :           }
; 1896 :         }

	jmp	$LN151@HllEndDir
$LN189@HllEndDir:

; 1897 : #endif
; 1898 :       }
; 1899 :       else if (hll->cflag == 7) {

	cmp	al, 7
	jne	$LN179@HllEndDir

; 1900 :         if (hll->flags & HLLF_DEFAULTOCCURED)

	test	BYTE PTR [rbx+76], 2
	je	SHORT $LN178@HllEndDir

; 1901 :           GetLabelStr(hll->labels[LDEF], buff);

	mov	r8d, DWORD PTR [rbx+28]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf

; 1902 :         else {

	jmp	SHORT $LN340@HllEndDir
$LN178@HllEndDir:

; 1903 :           GetLabelStr(hll->labels[LEXIT], buff);

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
$LN340@HllEndDir:

; 1904 :         }
; 1905 :         if (hll->csize == 4) {

	cmp	BYTE PTR [rbx+84], sil
	jne	SHORT $LN176@HllEndDir

; 1906 :           AddLineQueueX("cmp eax,%d", hll->mincase);

	mov	edx, DWORD PTR [rbx+92]
	lea	rcx, OFFSET FLAT:$SG6630
	call	AddLineQueueX

; 1907 :           AddLineQueueX("jl  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6631
	call	AddLineQueueX

; 1908 :           AddLineQueueX("cmp eax,%d", hll->maxcase);

	mov	edx, DWORD PTR [rbx+88]
	lea	rcx, OFFSET FLAT:$SG6632
	call	AddLineQueueX

; 1909 :           AddLineQueueX("ja  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6633
	call	AddLineQueueX

; 1910 :         }
; 1911 : #if AMD64_SUPPORT
; 1912 :         else {

	jmp	$LN175@HllEndDir
$LN176@HllEndDir:

; 1913 :           AddLineQueueX("push	rax");

	lea	rcx, OFFSET FLAT:$SG6635
	call	AddLineQueueX

; 1914 :           AddLineQueueX("push	rdx");

	lea	rcx, OFFSET FLAT:$SG6636
	call	AddLineQueueX

; 1915 :           AddLineQueueX("mov rdx, %q", hll->mincase64);

	mov	rdx, QWORD PTR [rbx+136]
	lea	rcx, OFFSET FLAT:$SG6637
	call	AddLineQueueX

; 1916 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG6638
	call	AddLineQueueX

; 1917 :           AddLineQueueX("pop	rdx");

	lea	rcx, OFFSET FLAT:$SG6639
	call	AddLineQueueX

; 1918 :           AddLineQueueX("pop	rax");

	lea	rcx, OFFSET FLAT:$SG6640
	call	AddLineQueueX

; 1919 :           AddLineQueueX("jl  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6641
	call	AddLineQueueX

; 1920 :           AddLineQueueX("push	rax");

	lea	rcx, OFFSET FLAT:$SG6642
	call	AddLineQueueX

; 1921 :           AddLineQueueX("push	rdx");

	lea	rcx, OFFSET FLAT:$SG6643
	call	AddLineQueueX

; 1922 :           AddLineQueueX("mov rdx, %q", hll->maxcase64);

	mov	rdx, QWORD PTR [rbx+128]
	lea	rcx, OFFSET FLAT:$SG6644
	call	AddLineQueueX

; 1923 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG6645
	call	AddLineQueueX

; 1924 :           AddLineQueueX("pop	rdx");

	lea	rcx, OFFSET FLAT:$SG6646
	call	AddLineQueueX

; 1925 :           AddLineQueueX("pop	rax");

	lea	rcx, OFFSET FLAT:$SG6647
	call	AddLineQueueX

; 1926 :           AddLineQueueX("ja  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6648
	call	AddLineQueueX
$LN175@HllEndDir:

; 1927 :         }
; 1928 : #endif
; 1929 :         if (ModuleInfo.Ofssize == USE32) {

	cmp	BYTE PTR ModuleInfo+404, 1
	jne	$LN174@HllEndDir

; 1930 :           GetLabelStr(hll->labels[LDATA2], buff);

	mov	r8d, DWORD PTR [rbx+36]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf

; 1931 :           AddLineQueueX("push	 eax");

	lea	rcx, OFFSET FLAT:$SG6650
	call	AddLineQueueX

; 1932 :           AddLineQueueX("sub   eax,%u", hll->mincase);

	mov	edx, DWORD PTR [rbx+92]
	lea	rcx, OFFSET FLAT:$SG6651
	call	AddLineQueueX

; 1933 :           AddLineQueueX("movzx eax,word ptr %s[%r*2]", buff, T_EAX);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6652
	mov	r8d, 17
	call	AddLineQueueX

; 1934 :           GetLabelStr(hll->labels[LDATA1], buff);

	mov	r8d, DWORD PTR [rbx+32]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf

; 1935 :           AddLineQueueX("mov   eax,%s[%r*4]", buff, T_EAX);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6653
	mov	r8d, 17
	call	AddLineQueueX

; 1936 :           AddLineQueueX("xchg	 eax,[esp]");

	lea	rcx, OFFSET FLAT:$SG6654
	call	AddLineQueueX

; 1937 :           AddLineQueueX("retn");

	lea	rcx, OFFSET FLAT:$SG6655
	call	AddLineQueueX

; 1938 :         }
; 1939 : #if AMD64_SUPPORT
; 1940 :         else {

	jmp	$LN151@HllEndDir
$LN174@HllEndDir:

; 1941 :           AddLineQueueX("push	rax");

	lea	rcx, OFFSET FLAT:$SG6657
	call	AddLineQueueX

; 1942 :           AddLineQueueX("push	rdx");

	lea	rcx, OFFSET FLAT:$SG6658
	call	AddLineQueueX

; 1943 :           if (hll->csize == 4) {

	cmp	BYTE PTR [rbx+84], sil
	jne	$LN172@HllEndDir

; 1944 :             GetLabelStr(hll->labels[LDATA2], buff);

	mov	r8d, DWORD PTR [rbx+36]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf

; 1945 :             AddLineQueueX("lea   rdx,%s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6660
	call	AddLineQueueX

; 1946 :             AddLineQueueX("sub   eax,%u", hll->mincase);

	mov	edx, DWORD PTR [rbx+92]
	lea	rcx, OFFSET FLAT:$SG6661
	call	AddLineQueueX

; 1947 :             AddLineQueueX("movzx rdx,word ptr[rdx+rax*2]");

	lea	rcx, OFFSET FLAT:$SG6662
	call	AddLineQueueX

; 1948 :             GetLabelStr(hll->labels[LDATA1], buff);

	mov	r8d, DWORD PTR [rbx+32]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf

; 1949 :             AddLineQueueX("lea   rax,%s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6663
	call	AddLineQueueX

; 1950 :             AddLineQueueX("mov   rax, qword ptr[rax+rdx*8]");

	lea	rcx, OFFSET FLAT:$SG6664
	call	AddLineQueueX

; 1951 :             AddLineQueueX("pop   rdx");

	lea	rcx, OFFSET FLAT:$SG6665
	call	AddLineQueueX

; 1952 :             AddLineQueueX("xchg	 rax,[rsp]");

	lea	rcx, OFFSET FLAT:$SG6666
	call	AddLineQueueX

; 1953 :             AddLineQueueX("retn");

	lea	rcx, OFFSET FLAT:$SG6667
	call	AddLineQueueX

; 1954 :           }
; 1955 :           else {

	jmp	$LN151@HllEndDir
$LN172@HllEndDir:

; 1956 :             GetLabelStr(hll->labels[LDATA2], buff);

	mov	r8d, DWORD PTR [rbx+36]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf

; 1957 :             AddLineQueueX("lea   rdx,%s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6669
	call	AddLineQueueX

; 1958 :             AddLineQueueX("sub   rax,%u", hll->mincase64);

	mov	rdx, QWORD PTR [rbx+136]
	lea	rcx, OFFSET FLAT:$SG6670
	call	AddLineQueueX

; 1959 :             AddLineQueueX("movzx rdx,word ptr[rdx+rax*2]");

	lea	rcx, OFFSET FLAT:$SG6671
	call	AddLineQueueX

; 1960 :             GetLabelStr(hll->labels[LDATA1], buff);

	mov	r8d, DWORD PTR [rbx+32]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf

; 1961 :             AddLineQueueX("lea   rax,%s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6672
	call	AddLineQueueX

; 1962 :             AddLineQueueX("mov   rax, qword ptr[rax+rdx*8]");

	lea	rcx, OFFSET FLAT:$SG6673
	call	AddLineQueueX

; 1963 :             AddLineQueueX("pop   rdx");

	lea	rcx, OFFSET FLAT:$SG6674
	call	AddLineQueueX

; 1964 :             AddLineQueueX("xchg	 rax,[rsp]");

	lea	rcx, OFFSET FLAT:$SG6675
	call	AddLineQueueX

; 1965 :             AddLineQueueX("retn");

	lea	rcx, OFFSET FLAT:$SG6676
	call	AddLineQueueX

; 1966 :           }
; 1967 :         }

	jmp	$LN151@HllEndDir
$LN179@HllEndDir:

; 1968 : #endif
; 1969 :       }
; 1970 :       else if (hll->cflag == 6) {

	cmp	al, 6
	jne	$LN169@HllEndDir

; 1971 :         if (hll->flags & HLLF_DEFAULTOCCURED)

	test	BYTE PTR [rbx+76], 2
	je	SHORT $LN168@HllEndDir

; 1972 :           GetLabelStr(hll->labels[LDEF], buff);

	mov	r8d, DWORD PTR [rbx+28]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf

; 1973 :         else {

	jmp	SHORT $LN356@HllEndDir
$LN168@HllEndDir:

; 1974 :           GetLabelStr(hll->labels[LEXIT], buff);

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
$LN356@HllEndDir:

; 1975 :         }
; 1976 :         if (hll->csize == 4) {

	cmp	BYTE PTR [rbx+84], sil
	jne	SHORT $LN166@HllEndDir

; 1977 :           AddLineQueueX("cmp eax,%d", hll->mincase);

	mov	edx, DWORD PTR [rbx+92]
	lea	rcx, OFFSET FLAT:$SG6682
	call	AddLineQueueX

; 1978 :           AddLineQueueX("jl  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6683
	call	AddLineQueueX

; 1979 :           AddLineQueueX("cmp eax,%d", hll->maxcase);

	mov	edx, DWORD PTR [rbx+88]
	lea	rcx, OFFSET FLAT:$SG6684
	call	AddLineQueueX

; 1980 :           AddLineQueueX("ja  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6685
	call	AddLineQueueX

; 1981 :         }
; 1982 : #if AMD64_SUPPORT
; 1983 :         else {

	jmp	$LN165@HllEndDir
$LN166@HllEndDir:

; 1984 :           AddLineQueueX("push	rax");

	lea	rcx, OFFSET FLAT:$SG6687
	call	AddLineQueueX

; 1985 :           AddLineQueueX("push	rdx");

	lea	rcx, OFFSET FLAT:$SG6688
	call	AddLineQueueX

; 1986 :           AddLineQueueX("mov rdx, %q", hll->mincase64);

	mov	rdx, QWORD PTR [rbx+136]
	lea	rcx, OFFSET FLAT:$SG6689
	call	AddLineQueueX

; 1987 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG6690
	call	AddLineQueueX

; 1988 :           AddLineQueueX("pop	rdx");

	lea	rcx, OFFSET FLAT:$SG6691
	call	AddLineQueueX

; 1989 :           AddLineQueueX("pop	rax");

	lea	rcx, OFFSET FLAT:$SG6692
	call	AddLineQueueX

; 1990 :           AddLineQueueX("jl  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6693
	call	AddLineQueueX

; 1991 :           AddLineQueueX("push	rax");

	lea	rcx, OFFSET FLAT:$SG6694
	call	AddLineQueueX

; 1992 :           AddLineQueueX("push	rdx");

	lea	rcx, OFFSET FLAT:$SG6695
	call	AddLineQueueX

; 1993 :           AddLineQueueX("mov rdx, %q", hll->maxcase64);

	mov	rdx, QWORD PTR [rbx+128]
	lea	rcx, OFFSET FLAT:$SG6696
	call	AddLineQueueX

; 1994 :           AddLineQueueX("cmp rax, rdx");

	lea	rcx, OFFSET FLAT:$SG6697
	call	AddLineQueueX

; 1995 :           AddLineQueueX("pop	rdx");

	lea	rcx, OFFSET FLAT:$SG6698
	call	AddLineQueueX

; 1996 :           AddLineQueueX("pop	rax");

	lea	rcx, OFFSET FLAT:$SG6699
	call	AddLineQueueX

; 1997 :           AddLineQueueX("ja  %s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6700
	call	AddLineQueueX
$LN165@HllEndDir:

; 1998 :         }
; 1999 : #endif 
; 2000 : 
; 2001 :         if (ModuleInfo.Ofssize == USE32) {

	cmp	BYTE PTR ModuleInfo+404, 1
	jne	SHORT $LN164@HllEndDir

; 2002 :           AddLineQueueX("push	 eax");

	lea	rcx, OFFSET FLAT:$SG6702
	call	AddLineQueueX

; 2003 :           AddLineQueueX("sub eax,%d", hll->mincase);

	mov	edx, DWORD PTR [rbx+92]
	lea	rcx, OFFSET FLAT:$SG6703
	call	AddLineQueueX

; 2004 :           AddLineQueueX("mov   eax,%s[%r*4]", GetLabelStr(hll->labels[LDATA1], buff), T_EAX);

	mov	r8d, DWORD PTR [rbx+32]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6704
	mov	r8d, 17
	call	AddLineQueueX

; 2005 :           AddLineQueueX("xchg	 eax,[esp]");

	lea	rcx, OFFSET FLAT:$SG6705
	call	AddLineQueueX

; 2006 :           AddLineQueueX("retn");

	lea	rcx, OFFSET FLAT:$SG6706
	call	AddLineQueueX

; 2007 :         }
; 2008 : #if AMD64_SUPPORT
; 2009 :         else {

	jmp	$LN151@HllEndDir
$LN164@HllEndDir:

; 2010 :           AddLineQueueX("push	rax");

	lea	rcx, OFFSET FLAT:$SG6708
	call	AddLineQueueX

; 2011 :           AddLineQueueX("push	rdx");

	lea	rcx, OFFSET FLAT:$SG6709
	call	AddLineQueueX

; 2012 :           if (hll->csize == 4)

	cmp	BYTE PTR [rbx+84], sil
	jne	SHORT $LN162@HllEndDir

; 2013 :             AddLineQueueX("sub   eax,%d", hll->mincase);

	mov	edx, DWORD PTR [rbx+92]
	lea	rcx, OFFSET FLAT:$SG6711
	call	AddLineQueueX

; 2014 :           else{

	jmp	SHORT $LN161@HllEndDir
$LN162@HllEndDir:

; 2015 :             AddLineQueueX("mov rdx,%q", hll->mincase64);

	mov	rdx, QWORD PTR [rbx+136]
	lea	rcx, OFFSET FLAT:$SG6713
	call	AddLineQueueX

; 2016 :             AddLineQueueX("sub rax,rdx");

	lea	rcx, OFFSET FLAT:$SG6714
	call	AddLineQueueX
$LN161@HllEndDir:

; 2017 :           }
; 2018 :           AddLineQueueX("lea   rdx,%s", GetLabelStr(hll->labels[LDATA1], buff));

	mov	r8d, DWORD PTR [rbx+32]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6715
	call	AddLineQueueX

; 2019 :           AddLineQueueX("mov   rax, qword ptr[rdx+rax*8]");

	lea	rcx, OFFSET FLAT:$SG6716
	call	AddLineQueueX

; 2020 :           AddLineQueueX("pop   rdx");

	lea	rcx, OFFSET FLAT:$SG6717
	call	AddLineQueueX

; 2021 :           AddLineQueueX("xchg	 rax,[rsp]");

	lea	rcx, OFFSET FLAT:$SG6718
	call	AddLineQueueX

; 2022 :           AddLineQueueX("retn");

	lea	rcx, OFFSET FLAT:$SG6719
	call	AddLineQueueX

; 2023 :         }

	jmp	$LN151@HllEndDir
$LN169@HllEndDir:

; 2024 : #endif
; 2025 :       }
; 2026 :       /* simple binary tree
; 2027 :       while (low <= high) {
; 2028 :       int mid = (low + high) / 2;
; 2029 :       if (hll->pcases[mid] == hll->casecnt)
; 2030 :       return mid;
; 2031 :       else if (hll->pcases[mid] < x)
; 2032 :       low = mid + 1;
; 2033 :       else high = mid - 1;
; 2034 :       }*/
; 2035 :       else if (hll->cflag == 5) {

	cmp	al, 5
	jne	$LN151@HllEndDir

; 2036 :         if (ModuleInfo.Ofssize == USE32) {

	cmp	BYTE PTR ModuleInfo+404, 1
	jne	$LN158@HllEndDir

; 2037 :           AddLineQueueX("push	eax");

	lea	rcx, OFFSET FLAT:$SG6723
	call	AddLineQueueX

; 2038 :           AddLineQueueX("push	edx");

	lea	rcx, OFFSET FLAT:$SG6724
	call	AddLineQueueX

; 2039 :           AddLineQueueX("push	ecx");

	lea	rcx, OFFSET FLAT:$SG6725
	call	AddLineQueueX

; 2040 :           AddLineQueueX("push	ebx");

	lea	rcx, OFFSET FLAT:$SG6726
	call	AddLineQueueX

; 2041 :           AddLineQueueX("push	esi");

	lea	rcx, OFFSET FLAT:$SG6727
	call	AddLineQueueX

; 2042 :           AddLineQueueX("push	edi");

	lea	rcx, OFFSET FLAT:$SG6728
	call	AddLineQueueX

; 2043 :           AddLineQueueX("mov  esi,eax");

	lea	rcx, OFFSET FLAT:$SG6729
	call	AddLineQueueX

; 2044 :           AddLineQueueX("mov  ebx,%d", hll->casecnt - 1);//int high = len - 1;

	mov	edx, DWORD PTR [rbx+80]
	lea	rcx, OFFSET FLAT:$SG6730
	dec	edx
	call	AddLineQueueX

; 2045 :           AddLineQueueX("xor  ecx,ecx");//int low = 0;

	lea	rcx, OFFSET FLAT:$SG6731
	call	AddLineQueueX

; 2046 :           AddLineQueueX("lea  edi,%s", GetLabelStr(hll->labels[LDATA2], buff));//int hll->pcases

	mov	r8d, DWORD PTR [rbx+36]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6732
	call	AddLineQueueX

; 2047 :           if (hll->flags & HLLF_DEFAULTOCCURED)

	test	BYTE PTR [rbx+76], 2
	je	SHORT $LN157@HllEndDir

; 2048 :             AddLineQueueX("js  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+28]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6734
	call	AddLineQueueX

; 2049 :           else

	jmp	$LN151@HllEndDir
$LN157@HllEndDir:

; 2050 :             AddLineQueueX("js  %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6736
	call	AddLineQueueX

; 2051 : 
; 2052 :         }
; 2053 : #if AMD64_SUPPORT
; 2054 :         else {

	jmp	$LN151@HllEndDir
$LN158@HllEndDir:

; 2055 :           AddLineQueueX("push	rax");

	lea	rcx, OFFSET FLAT:$SG6738
	call	AddLineQueueX

; 2056 :           AddLineQueueX("push	rdx");

	lea	rcx, OFFSET FLAT:$SG6739
	call	AddLineQueueX

; 2057 :           AddLineQueueX("push	rcx");

	lea	rcx, OFFSET FLAT:$SG6740
	call	AddLineQueueX

; 2058 :           AddLineQueueX("push	rbx");

	lea	rcx, OFFSET FLAT:$SG6741
	call	AddLineQueueX

; 2059 :           AddLineQueueX("push	rsi");

	lea	rcx, OFFSET FLAT:$SG6742
	call	AddLineQueueX

; 2060 :           AddLineQueueX("push	rdi");

	lea	rcx, OFFSET FLAT:$SG6743
	call	AddLineQueueX

; 2061 :           if (hll->csize == 4) {

	cmp	BYTE PTR [rbx+84], sil
	jne	SHORT $LN154@HllEndDir

; 2062 :             AddLineQueueX("mov  esi,eax");

	lea	rcx, OFFSET FLAT:$SG6745
	call	AddLineQueueX

; 2063 :             AddLineQueueX("mov  ebx,%d", hll->casecnt - 1);//int high = len - 1;

	mov	edx, DWORD PTR [rbx+80]
	lea	rcx, OFFSET FLAT:$SG6746
	dec	edx
	call	AddLineQueueX

; 2064 :             AddLineQueueX("xor  ecx,ecx");//int low = 0;

	lea	rcx, OFFSET FLAT:$SG6747
	call	AddLineQueueX

; 2065 :             AddLineQueueX("lea  rdi,%s", GetLabelStr(hll->labels[LDATA2], buff));//int hll->pcases

	mov	r8d, DWORD PTR [rbx+36]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6748
	call	AddLineQueueX

; 2066 :           }
; 2067 :           else {

	jmp	SHORT $LN153@HllEndDir
$LN154@HllEndDir:

; 2068 :             AddLineQueueX("mov  rsi,rax");

	lea	rcx, OFFSET FLAT:$SG6750
	call	AddLineQueueX

; 2069 :             AddLineQueueX("mov  rbx,%q", hll->casecnt - 1);//int high = len - 1;

	mov	edx, DWORD PTR [rbx+80]
	lea	rcx, OFFSET FLAT:$SG6751
	dec	edx
	call	AddLineQueueX

; 2070 :             AddLineQueueX("xor  ecx,ecx");//int low = 0;

	lea	rcx, OFFSET FLAT:$SG6752
	call	AddLineQueueX

; 2071 :             AddLineQueueX("lea  rdi,%s", GetLabelStr(hll->labels[LDATA2], buff));//int hll->pcases

	mov	r8d, DWORD PTR [rbx+36]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6753
	call	AddLineQueueX
$LN153@HllEndDir:

; 2072 :           }
; 2073 :           if (hll->flags & HLLF_DEFAULTOCCURED)

	test	BYTE PTR [rbx+76], 2
	je	SHORT $LN152@HllEndDir

; 2074 :             AddLineQueueX("js  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+28]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6755
	call	AddLineQueueX

; 2075 :           else

	jmp	SHORT $LN151@HllEndDir
$LN152@HllEndDir:

; 2076 :             AddLineQueueX("js  %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6757
	call	AddLineQueueX
$LN151@HllEndDir:

; 2077 :         }
; 2078 : #endif
; 2079 :       }
; 2080 :     } //end if Parse_Pass
; 2081 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTOP], buff));

	mov	r8d, DWORD PTR [rbx+40]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6758
	call	AddLineQueueX

; 2082 :     if (Parse_Pass) {

	cmp	DWORD PTR Parse_Pass, ebp
	je	$LN145@HllEndDir

; 2083 :       if (hll->cflag == 5) {

	cmp	BYTE PTR [rbx+85], 5
	jne	$LN145@HllEndDir

; 2084 :         if (ModuleInfo.Ofssize == USE32) {

	cmp	BYTE PTR ModuleInfo+404, 1
	jne	$LN148@HllEndDir

; 2085 :           AddLineQueueX("lea     eax,[ecx + ebx]");//int eax = (ecx + ebx) / 2;

	lea	rcx, OFFSET FLAT:$SG6762
	call	AddLineQueueX

; 2086 :           AddLineQueueX("cdq");

	lea	rcx, OFFSET FLAT:$SG6763
	call	AddLineQueueX

; 2087 :           AddLineQueueX("sub     eax,edx");

	lea	rcx, OFFSET FLAT:$SG6764
	call	AddLineQueueX

; 2088 :           AddLineQueueX("sar     eax,1");

	lea	rcx, OFFSET FLAT:$SG6765
	call	AddLineQueueX

; 2089 :           AddLineQueueX("cmp     [edi+eax*4],esi");

	lea	rcx, OFFSET FLAT:$SG6766
	call	AddLineQueueX

; 2090 :           AddLineQueueX("je  %s", GetLabelStr(hll->labels[LJUMP], buff));//got it, jump to the case

	mov	r8d, DWORD PTR [rbx+44]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6767
	call	AddLineQueueX

; 2091 :           AddLineQueueX("jge %s", GetLabelStr(hll->labels[LSKIP], buff));//else if (hll->pcases[mid] < hll->casecnt)

	mov	r8d, DWORD PTR [rbx+20]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6768
	call	AddLineQueueX

; 2092 :           AddLineQueueX("lea     ecx,[eax+1]");                          //low = mid + 1

	lea	rcx, OFFSET FLAT:$SG6769
	call	AddLineQueueX

; 2093 :           AddLineQueueX("jmp %s", GetLabelStr(hll->labels[LCONT], buff));//not found yet, continue search

	mov	r8d, DWORD PTR [rbx+24]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6770
	call	AddLineQueueX

; 2094 :         }
; 2095 : #if AMD64_SUPPORT
; 2096 :         else {

	jmp	$LN145@HllEndDir
$LN148@HllEndDir:

; 2097 :           if (hll->csize == 4) {

	cmp	BYTE PTR [rbx+84], sil
	jne	$LN146@HllEndDir

; 2098 :             AddLineQueueX("lea     eax,[rcx + rbx]");//int eax = (ecx + ebx) / 2;

	lea	rcx, OFFSET FLAT:$SG6773
	call	AddLineQueueX

; 2099 :             AddLineQueueX("cdq");

	lea	rcx, OFFSET FLAT:$SG6774
	call	AddLineQueueX

; 2100 :             AddLineQueueX("sub     eax,edx");

	lea	rcx, OFFSET FLAT:$SG6775
	call	AddLineQueueX

; 2101 :             AddLineQueueX("sar     rax,1");

	lea	rcx, OFFSET FLAT:$SG6776
	call	AddLineQueueX

; 2102 :             AddLineQueueX("cmp     [rdi+rax*8],esi");

	lea	rcx, OFFSET FLAT:$SG6777
	call	AddLineQueueX

; 2103 :             AddLineQueueX("je  %s", GetLabelStr(hll->labels[LJUMP], buff));//got it, jump to the case

	mov	r8d, DWORD PTR [rbx+44]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6778
	call	AddLineQueueX

; 2104 :             AddLineQueueX("jge %s", GetLabelStr(hll->labels[LSKIP], buff));//else if (hll->pcases[mid] < hll->casecnt)

	mov	r8d, DWORD PTR [rbx+20]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6779
	call	AddLineQueueX

; 2105 :             AddLineQueueX("lea     ecx,[rax+1]");                          //low = mid + 1

	lea	rcx, OFFSET FLAT:$SG6780
	call	AddLineQueueX

; 2106 :             AddLineQueueX("jmp %s", GetLabelStr(hll->labels[LCONT], buff));//not found yet, continue search

	mov	r8d, DWORD PTR [rbx+24]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6781
	call	AddLineQueueX

; 2107 :           }
; 2108 :           else {

	jmp	$LN145@HllEndDir
$LN146@HllEndDir:

; 2109 :             AddLineQueueX("lea     rax,[rcx + rbx]");//int eax = (ecx + ebx) / 2;

	lea	rcx, OFFSET FLAT:$SG6783
	call	AddLineQueueX

; 2110 :             AddLineQueueX("cdq");

	lea	rcx, OFFSET FLAT:$SG6784
	call	AddLineQueueX

; 2111 :             AddLineQueueX("sub     rax,rdx");

	lea	rcx, OFFSET FLAT:$SG6785
	call	AddLineQueueX

; 2112 :             AddLineQueueX("sar     rax,1");

	lea	rcx, OFFSET FLAT:$SG6786
	call	AddLineQueueX

; 2113 :             AddLineQueueX("cmp     [rdi+rax*8],rsi");

	lea	rcx, OFFSET FLAT:$SG6787
	call	AddLineQueueX

; 2114 :             AddLineQueueX("je  %s", GetLabelStr(hll->labels[LJUMP], buff));//got it, jump to the case

	mov	r8d, DWORD PTR [rbx+44]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6788
	call	AddLineQueueX

; 2115 :             AddLineQueueX("jge %s", GetLabelStr(hll->labels[LSKIP], buff));//else if (hll->pcases[mid] < hll->casecnt)

	mov	r8d, DWORD PTR [rbx+20]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6789
	call	AddLineQueueX

; 2116 :             AddLineQueueX("lea     rcx,[rax+1]");                          //low = mid + 1

	lea	rcx, OFFSET FLAT:$SG6790
	call	AddLineQueueX

; 2117 :             AddLineQueueX("jmp %s", GetLabelStr(hll->labels[LCONT], buff));//not found yet, continue search

	mov	r8d, DWORD PTR [rbx+24]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6791
	call	AddLineQueueX
$LN145@HllEndDir:

; 2118 :           }
; 2119 :         }
; 2120 : #endif
; 2121 :       }
; 2122 :     }
; 2123 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LJUMP], buff));

	mov	r8d, DWORD PTR [rbx+44]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6792
	call	AddLineQueueX

; 2124 :     if (Parse_Pass) {

	cmp	DWORD PTR Parse_Pass, ebp
	je	$LN141@HllEndDir

; 2125 :       if (hll->cflag == 5) {

	cmp	BYTE PTR [rbx+85], 5
	jne	$LN141@HllEndDir

; 2126 :         if (ModuleInfo.Ofssize == USE32) {

	cmp	BYTE PTR ModuleInfo+404, 1
	jne	$LN142@HllEndDir

; 2127 :           GetLabelStr(hll->labels[LDATA1], buff);

	mov	r8d, DWORD PTR [rbx+32]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf

; 2128 :           AddLineQueueX("pop	edi");

	lea	rcx, OFFSET FLAT:$SG6796
	call	AddLineQueueX

; 2129 :           AddLineQueueX("pop	esi");

	lea	rcx, OFFSET FLAT:$SG6797
	call	AddLineQueueX

; 2130 :           AddLineQueueX("pop	ebx");

	lea	rcx, OFFSET FLAT:$SG6798
	call	AddLineQueueX

; 2131 :           AddLineQueueX("pop	ecx");

	lea	rcx, OFFSET FLAT:$SG6799
	call	AddLineQueueX

; 2132 :           AddLineQueueX("pop	edx");

	lea	rcx, OFFSET FLAT:$SG6800
	call	AddLineQueueX

; 2133 :           AddLineQueueX("mov  eax,%s[%r*4]", buff, T_EAX);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6801
	mov	r8d, 17
	call	AddLineQueueX

; 2134 :           AddLineQueueX("xchg	 eax,[esp]");

	lea	rcx, OFFSET FLAT:$SG6802
	call	AddLineQueueX

; 2135 :           AddLineQueueX("retn");

	lea	rcx, OFFSET FLAT:$SG6803
	call	AddLineQueueX

; 2136 :         }
; 2137 : #if AMD64_SUPPORT
; 2138 :         else {

	jmp	$LN141@HllEndDir
$LN142@HllEndDir:

; 2139 :           AddLineQueueX("pop	rdi");

	lea	rcx, OFFSET FLAT:$SG6805
	call	AddLineQueueX

; 2140 :           AddLineQueueX("pop	rsi");

	lea	rcx, OFFSET FLAT:$SG6806
	call	AddLineQueueX

; 2141 :           AddLineQueueX("pop	rbx");

	lea	rcx, OFFSET FLAT:$SG6807
	call	AddLineQueueX

; 2142 :           AddLineQueueX("pop	rcx");

	lea	rcx, OFFSET FLAT:$SG6808
	call	AddLineQueueX

; 2143 :           GetLabelStr(hll->labels[LDATA1], buff);

	mov	r8d, DWORD PTR [rbx+32]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf

; 2144 :           AddLineQueueX("lea   rdx,%s", buff);

	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6809
	call	AddLineQueueX

; 2145 :           AddLineQueueX("mov   rax, qword ptr[rdx+rax*8]");

	lea	rcx, OFFSET FLAT:$SG6810
	call	AddLineQueueX

; 2146 :           AddLineQueueX("pop   rdx");

	lea	rcx, OFFSET FLAT:$SG6811
	call	AddLineQueueX

; 2147 :           AddLineQueueX("xchg	 rax,[rsp]");

	lea	rcx, OFFSET FLAT:$SG6812
	call	AddLineQueueX

; 2148 :           AddLineQueueX("retn");

	lea	rcx, OFFSET FLAT:$SG6813
	call	AddLineQueueX
$LN141@HllEndDir:

; 2149 :         }
; 2150 : #endif
; 2151 :       }
; 2152 :     }
; 2153 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LSKIP], buff));

	mov	r8d, DWORD PTR [rbx+20]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6814
	call	AddLineQueueX

; 2154 :     if (Parse_Pass) {

	cmp	DWORD PTR Parse_Pass, ebp
	je	SHORT $LN135@HllEndDir

; 2155 :       if (hll->cflag == 5) {

	cmp	BYTE PTR [rbx+85], 5
	jne	SHORT $LN135@HllEndDir

; 2156 :         if (ModuleInfo.Ofssize == USE32)

	cmp	BYTE PTR ModuleInfo+404, 1
	jne	SHORT $LN138@HllEndDir

; 2157 :           AddLineQueueX("lea     ebx,[eax-1]");//else high = mid - 1;

	lea	rcx, OFFSET FLAT:$SG6818
	call	AddLineQueueX

; 2158 : #if AMD64_SUPPORT
; 2159 :         else {

	jmp	SHORT $LN135@HllEndDir
$LN138@HllEndDir:

; 2160 :           if (hll->csize == 4)

	cmp	BYTE PTR [rbx+84], sil
	jne	SHORT $LN136@HllEndDir

; 2161 :             AddLineQueueX("lea     ebx,[rax-1]");//else high = mid - 1;

	lea	rcx, OFFSET FLAT:$SG6821
	call	AddLineQueueX

; 2162 :           else

	jmp	SHORT $LN135@HllEndDir
$LN136@HllEndDir:

; 2163 :             AddLineQueueX("lea     rbx,[rax-1]");//else high = mid - 1;

	lea	rcx, OFFSET FLAT:$SG6823
	call	AddLineQueueX
$LN135@HllEndDir:

; 2164 :         }
; 2165 : #endif
; 2166 :       }
; 2167 :     }
; 2168 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LCONT], buff));

	mov	r8d, DWORD PTR [rbx+24]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6824
	call	AddLineQueueX

; 2169 :     if (Parse_Pass) {

	cmp	DWORD PTR Parse_Pass, ebp
	je	$LN125@HllEndDir

; 2170 :       if (hll->cflag == 5) {

	cmp	BYTE PTR [rbx+85], 5
	jne	$LN125@HllEndDir

; 2171 :         if (ModuleInfo.Ofssize == USE32) {

	cmp	BYTE PTR ModuleInfo+404, 1
	jne	$LN132@HllEndDir

; 2172 :           AddLineQueueX("cmp  ecx,ebx");

	lea	rcx, OFFSET FLAT:$SG6828
	call	AddLineQueueX

; 2173 :           AddLineQueueX("jle %s", GetLabelStr(hll->labels[LTOP], buff));

	mov	r8d, DWORD PTR [rbx+40]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6829
	call	AddLineQueueX

; 2174 :           AddLineQueueX("pop	edi");

	lea	rcx, OFFSET FLAT:$SG6830
	call	AddLineQueueX

; 2175 :           AddLineQueueX("pop	esi");

	lea	rcx, OFFSET FLAT:$SG6831
	call	AddLineQueueX

; 2176 :           AddLineQueueX("pop	ebx");

	lea	rcx, OFFSET FLAT:$SG6832
	call	AddLineQueueX

; 2177 :           AddLineQueueX("pop	ecx");

	lea	rcx, OFFSET FLAT:$SG6833
	call	AddLineQueueX

; 2178 :           AddLineQueueX("pop	edx");

	lea	rcx, OFFSET FLAT:$SG6834
	call	AddLineQueueX

; 2179 :           AddLineQueueX("pop	eax");

	lea	rcx, OFFSET FLAT:$SG6835
	call	AddLineQueueX

; 2180 :           if (hll->flags & HLLF_DEFAULTOCCURED)

	test	BYTE PTR [rbx+76], 2
	je	SHORT $LN131@HllEndDir

; 2181 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+28]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6837
	call	AddLineQueueX

; 2182 :           else

	jmp	$LN125@HllEndDir
$LN131@HllEndDir:

; 2183 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6839
	call	AddLineQueueX

; 2184 :         }
; 2185 : #if AMD64_SUPPORT
; 2186 :         else

	jmp	$LN125@HllEndDir
$LN132@HllEndDir:

; 2187 :         {
; 2188 :           if (hll->csize == 4)

	cmp	BYTE PTR [rbx+84], sil
	jne	SHORT $LN128@HllEndDir

; 2189 :             AddLineQueueX("cmp  ecx,ebx");

	lea	rcx, OFFSET FLAT:$SG6842
	call	AddLineQueueX

; 2190 :           else

	jmp	SHORT $LN127@HllEndDir
$LN128@HllEndDir:

; 2191 :             AddLineQueueX("cmp  rcx,rbx");

	lea	rcx, OFFSET FLAT:$SG6844
	call	AddLineQueueX
$LN127@HllEndDir:

; 2192 :           AddLineQueueX("jle  %s", GetLabelStr(hll->labels[LTOP], buff));

	mov	r8d, DWORD PTR [rbx+40]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6845
	call	AddLineQueueX

; 2193 :           AddLineQueueX("pop	rdi");

	lea	rcx, OFFSET FLAT:$SG6846
	call	AddLineQueueX

; 2194 :           AddLineQueueX("pop	rsi");

	lea	rcx, OFFSET FLAT:$SG6847
	call	AddLineQueueX

; 2195 :           AddLineQueueX("pop	rbx");

	lea	rcx, OFFSET FLAT:$SG6848
	call	AddLineQueueX

; 2196 :           AddLineQueueX("pop	rcx");

	lea	rcx, OFFSET FLAT:$SG6849
	call	AddLineQueueX

; 2197 :           AddLineQueueX("pop	rdx");

	lea	rcx, OFFSET FLAT:$SG6850
	call	AddLineQueueX

; 2198 :           AddLineQueueX("pop	rax");

	lea	rcx, OFFSET FLAT:$SG6851
	call	AddLineQueueX

; 2199 :           if (hll->flags & HLLF_DEFAULTOCCURED)

	test	BYTE PTR [rbx+76], 2
	je	SHORT $LN126@HllEndDir

; 2200 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+28]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6853
	call	AddLineQueueX

; 2201 :           else

	jmp	SHORT $LN125@HllEndDir
$LN126@HllEndDir:

; 2202 :             AddLineQueueX("jmp  %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6855
	call	AddLineQueueX
$LN125@HllEndDir:

; 2203 :         }
; 2204 : #endif
; 2205 :       }
; 2206 :     }
; 2207 : 
; 2208 :     AddLineQueueX("ALIGN %d", dsize);

	lea	rcx, OFFSET FLAT:$SG6856
	mov	edx, edi
	mov	QWORD PTR [rsp+2176], r14
	mov	QWORD PTR [rsp+2168], r15
	call	AddLineQueueX

; 2209 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LDATA1], buff));

	mov	r8d, DWORD PTR [rbx+32]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6857
	call	AddLineQueueX

; 2210 :     if (hll->cflag > 3) {

	movzx	eax, BYTE PTR [rbx+85]
	cmp	al, 3
	jle	$LN72@HllEndDir

; 2211 :       if (ModuleInfo.Ofssize == USE32) {

	cmp	BYTE PTR ModuleInfo+404, 1
	jne	$LN123@HllEndDir

; 2212 :         lbl = 0;

	xor	cx, cx

; 2213 :         if (hll->cflag == 4) {

	cmp	al, sil
	jne	SHORT $LN119@HllEndDir

; 2214 :           for (j = 0; j < hll->casecnt; j++) {

	cmp	DWORD PTR [rbx+80], ebp
	mov	esi, ebp
	jbe	SHORT $LN119@HllEndDir
	mov	rdi, rbp
$LL121@HllEndDir:

; 2215 :             if (hll->plabels[j] != lbl) {

	mov	rax, QWORD PTR [rbx+112]
	movzx	edx, WORD PTR [rdi+rax]
	cmp	dx, cx
	je	SHORT $LN118@HllEndDir

; 2216 :               AddLineQueueX(" dd %s", GetLabelStr(hll->plabels[j], buff));

	movzx	r8d, dx
	lea	rcx, QWORD PTR buff$[rsp]
	lea	rdx, OFFSET FLAT:$SG5756
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6865
	call	AddLineQueueX

; 2217 :               acnt++;

	inc	r13d
$LN118@HllEndDir:

; 2218 :             }
; 2219 :             lbl = hll->plabels[j];

	mov	rax, QWORD PTR [rbx+112]
	inc	esi
	add	rdi, 2
	cmp	esi, DWORD PTR [rbx+80]
	movzx	ecx, WORD PTR [rdi+rax-2]
	jb	SHORT $LL121@HllEndDir
	mov	DWORD PTR acnt$1$[rsp], r13d
$LN119@HllEndDir:

; 2220 :           }
; 2221 :         }
; 2222 :         if (hll->cflag == 7) {

	movzx	eax, BYTE PTR [rbx+85]
	cmp	al, 7
	jne	SHORT $LN117@HllEndDir

; 2223 :           for (j = 0; j < hll->casecnt; j++) {

	cmp	DWORD PTR [rbx+80], ebp
	mov	esi, ebp
	jbe	$LN103@HllEndDir
	mov	rdi, rbp
	npad	10
$LL116@HllEndDir:

; 2224 :             if (hll->plabels[j] != lbl) {

	mov	rax, QWORD PTR [rbx+112]
	movzx	edx, WORD PTR [rdi+rax]
	cmp	dx, cx
	je	SHORT $LN113@HllEndDir

; 2225 :               AddLineQueueX(" dd %s", GetLabelStr(hll->plabels[j], buff));

	movzx	r8d, dx
	lea	rcx, QWORD PTR buff$[rsp]
	lea	rdx, OFFSET FLAT:$SG5756
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6871
	call	AddLineQueueX

; 2226 :               acnt++;

	inc	r13d
$LN113@HllEndDir:

; 2227 :             }
; 2228 :             lbl = hll->plabels[j];

	mov	rax, QWORD PTR [rbx+112]
	inc	esi
	add	rdi, 2
	cmp	esi, DWORD PTR [rbx+80]
	mov	cx, WORD PTR [rdi+rax-2]
	jb	SHORT $LL116@HllEndDir
	mov	DWORD PTR acnt$1$[rsp], r13d

; 2229 :           }
; 2230 :         }
; 2231 :         else if (hll->cflag == 5) {

	jmp	$LN103@HllEndDir
$LN117@HllEndDir:
	cmp	al, 5
	jne	SHORT $LN111@HllEndDir

; 2232 :           for (j = 0; j < hll->casecnt; j++)

	cmp	DWORD PTR [rbx+80], ebp
	mov	edi, ebp
	jbe	$LN103@HllEndDir
	mov	rsi, rbp
	npad	10
$LL110@HllEndDir:

; 2233 :             AddLineQueueX(" dd %s", GetLabelStr(hll->plabels[j], buff));

	mov	rax, QWORD PTR [rbx+112]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	movzx	r8d, WORD PTR [rax+rsi]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6877
	call	AddLineQueueX
	inc	edi
	add	rsi, 2
	cmp	edi, DWORD PTR [rbx+80]
	jb	SHORT $LL110@HllEndDir

; 2234 :         }
; 2235 :         else if (hll->cflag == 6) {

	jmp	$LN103@HllEndDir
$LN111@HllEndDir:
	cmp	al, 6
	jne	$LN103@HllEndDir

; 2236 :           for (j = 0, n = 0; j < hll->casecnt; j++) {

	cmp	DWORD PTR [rbx+80], ebp
	mov	r13d, ebp
	mov	esi, ebp
	jbe	$LN103@HllEndDir
	mov	r14, rbp
	npad	12
$LL105@HllEndDir:

; 2237 :             temp = hll->pcases[j] - hll->mincase;

	mov	rax, QWORD PTR [rbx+104]
	mov	ecx, DWORD PTR [rax+r12]
	sub	ecx, DWORD PTR [rbx+92]

; 2238 :             while (n < temp) {

	cmp	esi, ecx
	jge	SHORT $LN101@HllEndDir
	sub	ecx, esi
	mov	edi, ecx
	add	esi, ecx
$LL102@HllEndDir:

; 2239 :               if (hll->flags & HLLF_DEFAULTOCCURED)

	test	BYTE PTR [rbx+76], 2
	je	SHORT $LN100@HllEndDir

; 2240 :                 AddLineQueueX(" dd %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+28]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6887
	call	AddLineQueueX

; 2241 :               else

	jmp	SHORT $LN99@HllEndDir
$LN100@HllEndDir:

; 2242 :                 AddLineQueueX(" dd %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6889
	call	AddLineQueueX
$LN99@HllEndDir:

; 2238 :             while (n < temp) {

	dec	rdi
	jne	SHORT $LL102@HllEndDir
$LN101@HllEndDir:

; 2243 :               n++;
; 2244 :             }
; 2245 :             AddLineQueueX(" dd %s", GetLabelStr(hll->plabels[j], buff));

	mov	rax, QWORD PTR [rbx+112]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	movzx	r8d, WORD PTR [rax+r14]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6890
	call	AddLineQueueX
	inc	r13d

; 2246 :             n++;

	inc	esi
	add	r12, 4
	add	r14, 2
	cmp	r13d, DWORD PTR [rbx+80]
	jb	$LL105@HllEndDir
	mov	r12d, DWORD PTR bcnt$1$[rsp]
$LN103@HllEndDir:

; 2247 :           }
; 2248 :         }
; 2249 :         if (hll->flags & HLLF_DEFAULTOCCURED)

	test	BYTE PTR [rbx+76], 2
	je	SHORT $LN98@HllEndDir

; 2250 :           AddLineQueueX(" dd %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+28]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6892
	call	AddLineQueueX

; 2251 :         else

	jmp	$LN72@HllEndDir
$LN98@HllEndDir:

; 2252 :           AddLineQueueX(" dd %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6894
	call	AddLineQueueX

; 2253 :       }
; 2254 : #if AMD64_SUPPORT
; 2255 :       else {

	jmp	$LN72@HllEndDir
$LN123@HllEndDir:

; 2256 :         lbl = 0;

	xor	dx, dx

; 2257 :         if ((hll->cflag == 4)||(hll->cflag == 7)) {

	cmp	al, sil
	je	$LN94@HllEndDir
	cmp	al, 7
	je	$LN94@HllEndDir

; 2264 :           }
; 2265 :         }
; 2266 :         else if (hll->cflag == 5) {

	cmp	al, 5
	jne	SHORT $LN88@HllEndDir

; 2267 :           for (j = 0; j < hll->casecnt; j++)

	cmp	DWORD PTR [rbx+80], ebp
	mov	edi, ebp
	jbe	$LN91@HllEndDir
	mov	rsi, rbp
	npad	9
$LL87@HllEndDir:

; 2268 :             AddLineQueueX(" dq %s", GetLabelStr(hll->plabels[j], buff));

	mov	rax, QWORD PTR [rbx+112]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	movzx	r8d, WORD PTR [rax+rsi]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6908
	call	AddLineQueueX
	inc	edi
	add	rsi, 2
	cmp	edi, DWORD PTR [rbx+80]
	jb	SHORT $LL87@HllEndDir

; 2269 :         }
; 2270 :         else if (hll->cflag == 6) {

	jmp	$LN91@HllEndDir
$LN88@HllEndDir:
	cmp	al, 6
	jne	$LN91@HllEndDir

; 2271 :           for (j = 0, n = 0; j < hll->casecnt; j++) {

	cmp	DWORD PTR [rbx+80], ebp
	mov	r14d, ebp
	mov	esi, ebp
	jbe	$LN91@HllEndDir
	mov	r15, rbp
$LL82@HllEndDir:

; 2272 :             if (hll->csize == 4)

	cmp	BYTE PTR [rbx+84], 4
	jne	SHORT $LN79@HllEndDir

; 2273 :               temp = hll->pcases[j] - hll->mincase;

	mov	rax, QWORD PTR [rbx+104]
	mov	ecx, DWORD PTR [rax+r13]
	sub	ecx, DWORD PTR [rbx+92]

; 2274 :             else

	jmp	SHORT $LN499@HllEndDir
$LN79@HllEndDir:

; 2275 :               temp = hll->pcases64[j] - hll->mincase64;

	mov	rax, QWORD PTR [rbx+152]
	mov	ecx, DWORD PTR [rax+r12]
	sub	ecx, DWORD PTR [rbx+136]
$LN499@HllEndDir:

; 2276 :             while (n < temp) {

	cmp	esi, ecx
	jge	SHORT $LN76@HllEndDir
	sub	ecx, esi
	mov	edi, ecx
	add	esi, ecx
$LL77@HllEndDir:

; 2277 :               if (hll->flags & HLLF_DEFAULTOCCURED)

	test	BYTE PTR [rbx+76], 2
	je	SHORT $LN75@HllEndDir

; 2278 :                 AddLineQueueX(" dq %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+28]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6920
	call	AddLineQueueX

; 2279 :               else

	jmp	SHORT $LN74@HllEndDir
$LN75@HllEndDir:

; 2280 :                 AddLineQueueX(" dq %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6922
	call	AddLineQueueX
$LN74@HllEndDir:

; 2276 :             while (n < temp) {

	dec	rdi
	jne	SHORT $LL77@HllEndDir
$LN76@HllEndDir:

; 2281 :               n++;
; 2282 :             }
; 2283 :             AddLineQueueX(" dq %s", GetLabelStr(hll->plabels[j], buff));

	mov	rax, QWORD PTR [rbx+112]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	movzx	r8d, WORD PTR [rax+r15]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6923
	call	AddLineQueueX
	inc	r14d

; 2284 :             n++;

	inc	esi
	add	r13, 4
	add	r12, 8
	add	r15, 2
	cmp	r14d, DWORD PTR [rbx+80]
	jb	$LL82@HllEndDir

; 1739 :         if ((ModuleInfo.Ofssize == USE32) || (hll->csize == 4)) {

	mov	r12d, DWORD PTR bcnt$1$[rsp]
	jmp	SHORT $LN91@HllEndDir
$LN94@HllEndDir:

; 2258 :           for (j = 0; j < hll->casecnt; j++) {

	cmp	DWORD PTR [rbx+80], ebp
	mov	esi, ebp
	jbe	SHORT $LN91@HllEndDir
	mov	rdi, rbp
$LL93@HllEndDir:

; 2259 :             if (hll->plabels[j] != lbl) {

	mov	rax, QWORD PTR [rbx+112]
	movzx	ecx, WORD PTR [rdi+rax]
	cmp	cx, dx
	je	SHORT $LN90@HllEndDir

; 2260 :               AddLineQueueX(" dq %s", GetLabelStr(hll->plabels[j], buff));

	movzx	r8d, cx
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6902
	call	AddLineQueueX

; 2261 :               acnt++;

	inc	r13d
$LN90@HllEndDir:

; 2262 :             }
; 2263 :             lbl = hll->plabels[j];

	mov	rax, QWORD PTR [rbx+112]
	inc	esi
	add	rdi, 2
	cmp	esi, DWORD PTR [rbx+80]
	movzx	edx, WORD PTR [rdi+rax-2]
	jb	SHORT $LL93@HllEndDir
	mov	DWORD PTR acnt$1$[rsp], r13d
$LN91@HllEndDir:

; 2285 :           }
; 2286 :         }
; 2287 :         if (hll->flags & HLLF_DEFAULTOCCURED)

	test	BYTE PTR [rbx+76], 2
	je	SHORT $LN73@HllEndDir

; 2288 :           AddLineQueueX(" dq %s", GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+28]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6925
	call	AddLineQueueX

; 2289 :         else

	jmp	SHORT $LN72@HllEndDir
$LN73@HllEndDir:

; 2290 :           AddLineQueueX(" dq %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6927
	call	AddLineQueueX
$LN72@HllEndDir:

; 2291 :       }
; 2292 : #endif
; 2293 :     }
; 2294 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LDATA2], buff));

	mov	r8d, DWORD PTR [rbx+36]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6928
	call	AddLineQueueX

; 2295 :     if (hll->cflag == 4) {

	cmp	BYTE PTR [rbx+85], 4
	jne	$LN60@HllEndDir

; 2296 :       n = 0;
; 2297 :       if (hll->csize == 4) {

	cmp	BYTE PTR [rbx+84], 4
	mov	esi, ebp
	jne	$LN70@HllEndDir

; 2298 :         for (j = 0; j < hll->casecnt; j++) {

	cmp	DWORD PTR [rbx+80], ebp
	mov	r13d, ebp
	jbe	$LN60@HllEndDir
	mov	r15, rbp
	mov	r14, rbp
	mov	ebp, DWORD PTR acnt$1$[rsp]
	npad	9
$LL69@HllEndDir:

; 2299 :           temp = hll->pcases[j] - hll->mincase;

	mov	rax, QWORD PTR [rbx+104]
	mov	ecx, DWORD PTR [rax+r14]
	sub	ecx, DWORD PTR [rbx+92]

; 2300 :           while (n < temp) {

	cmp	esi, ecx
	jge	SHORT $LN65@HllEndDir
	sub	ecx, esi
	movsx	r12d, bpl
	mov	edi, ecx
	add	esi, ecx
	npad	7
$LL66@HllEndDir:

; 2301 :             AddLineQueueX(" db %d", (int_8)acnt);

	lea	rcx, OFFSET FLAT:$SG6938
	mov	edx, r12d
	call	AddLineQueueX
	dec	rdi
	jne	SHORT $LL66@HllEndDir
	mov	r12d, DWORD PTR bcnt$1$[rsp]
$LN65@HllEndDir:

; 2302 :             n++;
; 2303 :           }
; 2304 :           AddLineQueueX(" db %d", (int_8)bcnt);

	lea	rcx, OFFSET FLAT:$SG6940
	movsx	edx, r12b
	call	AddLineQueueX

; 2305 :           n++;
; 2306 :           if (hll->plabels[j] != hll->plabels[j + 1])

	mov	rcx, QWORD PTR [rbx+112]
	inc	esi
	movzx	eax, WORD PTR [rcx+r15+2]
	cmp	WORD PTR [rcx+r15], ax
	je	SHORT $LN68@HllEndDir

; 2307 :             bcnt++;

	inc	r12d
	mov	DWORD PTR bcnt$1$[rsp], r12d
$LN68@HllEndDir:
	inc	r13d
	add	r14, 4
	add	r15, 2
	cmp	r13d, DWORD PTR [rbx+80]
	jb	SHORT $LL69@HllEndDir

; 2308 :         }
; 2309 :       }
; 2310 : #if AMD64_SUPPORT
; 2311 :       else {

	xor	ebp, ebp
	jmp	$LN60@HllEndDir
$LN70@HllEndDir:

; 2312 :         n = 0;
; 2313 :         for (j = 0; j < hll->casecnt; j++) {

	cmp	DWORD PTR [rbx+80], esi
	mov	r13d, ebp
	jbe	$LN60@HllEndDir
	mov	r15, rbp
	mov	r14, rbp
	mov	ebp, DWORD PTR acnt$1$[rsp]
$LL62@HllEndDir:

; 2314 :           temp = (int)hll->pcases64[j] - hll->mincase64;

	mov	rax, QWORD PTR [rbx+152]
	mov	ecx, DWORD PTR [rax+r14]
	sub	ecx, DWORD PTR [rbx+136]

; 2315 :           while (n < temp) {

	cmp	esi, ecx
	jge	SHORT $LN58@HllEndDir
	sub	ecx, esi
	movsx	r12d, bpl
	mov	edi, ecx
	add	esi, ecx
$LL59@HllEndDir:

; 2316 :             AddLineQueueX(" db %d", (int_8)acnt);

	lea	rcx, OFFSET FLAT:$SG6951
	mov	edx, r12d
	call	AddLineQueueX
	dec	rdi
	jne	SHORT $LL59@HllEndDir
	mov	r12d, DWORD PTR bcnt$1$[rsp]
$LN58@HllEndDir:

; 2317 :             n++;
; 2318 :           }
; 2319 :           AddLineQueueX(" db %d", (int_8)bcnt);

	lea	rcx, OFFSET FLAT:$SG6953
	movsx	edx, r12b
	call	AddLineQueueX

; 2320 :           n++;
; 2321 :           if (hll->plabels[j] != hll->plabels[j + 1]) bcnt++;

	mov	rcx, QWORD PTR [rbx+112]
	inc	esi
	movzx	eax, WORD PTR [rcx+r15+2]
	cmp	WORD PTR [rcx+r15], ax
	je	SHORT $LN61@HllEndDir
	inc	r12d
	mov	DWORD PTR bcnt$1$[rsp], r12d
$LN61@HllEndDir:
	inc	r13d
	add	r14, 8
	add	r15, 2
	cmp	r13d, DWORD PTR [rbx+80]
	jb	SHORT $LL62@HllEndDir
	xor	ebp, ebp
$LN60@HllEndDir:

; 2322 :         }
; 2323 :       }
; 2324 : #endif
; 2325 :     }
; 2326 : 
; 2327 :     if (hll->cflag == 7) {

	cmp	BYTE PTR [rbx+85], 7
	jne	$LN45@HllEndDir

; 2328 :       n = 0;
; 2329 :       if (hll->csize == 4) {

	cmp	BYTE PTR [rbx+84], 4
	mov	esi, ebp
	jne	$LN55@HllEndDir

; 2330 :         for (j = 0; j < hll->casecnt; j++) {

	cmp	DWORD PTR [rbx+80], 0
	mov	r13d, ebp
	jbe	$LN45@HllEndDir
	mov	r15, rbp
	mov	r14, rbp
	mov	ebp, DWORD PTR acnt$1$[rsp]
	npad	11
$LL54@HllEndDir:

; 2331 :           temp = hll->pcases[j] - hll->mincase;

	mov	rax, QWORD PTR [rbx+104]
	mov	ecx, DWORD PTR [r14+rax]
	sub	ecx, DWORD PTR [rbx+92]

; 2332 :           while (n < (temp * 2)) {

	add	ecx, ecx
	cmp	esi, ecx
	jge	SHORT $LN50@HllEndDir
	sub	ecx, esi
	movsx	r12d, bp
	dec	ecx
	shr	ecx, 1
	inc	ecx
	mov	edi, ecx
	lea	esi, DWORD PTR [rsi+rcx*2]
	npad	14
$LL51@HllEndDir:

; 2333 :             AddLineQueueX(" dw %d", (int_16)acnt);

	lea	rcx, OFFSET FLAT:$SG6964
	mov	edx, r12d
	call	AddLineQueueX
	dec	rdi
	jne	SHORT $LL51@HllEndDir
	mov	r12d, DWORD PTR bcnt$1$[rsp]
$LN50@HllEndDir:

; 2334 :             n += 2;
; 2335 :           }
; 2336 :           AddLineQueueX(" dw %d", (int_16)bcnt);

	lea	rcx, OFFSET FLAT:$SG6966
	movsx	edx, r12w
	call	AddLineQueueX

; 2337 :           n += 2;
; 2338 :           if (hll->plabels[j] != hll->plabels[j + 1])

	mov	rcx, QWORD PTR [rbx+112]
	add	esi, 2
	movzx	eax, WORD PTR [rcx+r15+2]
	cmp	WORD PTR [rcx+r15], ax
	je	SHORT $LN53@HllEndDir

; 2339 :             bcnt++;

	inc	r12d
	mov	DWORD PTR bcnt$1$[rsp], r12d
$LN53@HllEndDir:
	inc	r13d
	add	r14, 4
	add	r15, 2
	cmp	r13d, DWORD PTR [rbx+80]
	jb	$LL54@HllEndDir

; 2340 :         }
; 2341 :       }
; 2342 : #if AMD64_SUPPORT
; 2343 :       else {

	xor	ebp, ebp
	jmp	$LN45@HllEndDir
$LN55@HllEndDir:

; 2344 :         n = 0;
; 2345 :         for (j = 0; j < hll->casecnt; j++) {

	cmp	DWORD PTR [rbx+80], 0
	mov	r13d, ebp
	jbe	$LN45@HllEndDir
	mov	r15, rbp
	mov	r14, rbp
	mov	ebp, DWORD PTR acnt$1$[rsp]
	npad	8
$LL47@HllEndDir:

; 2346 :           temp = (int)hll->pcases64[j] - hll->mincase64;

	mov	rax, QWORD PTR [rbx+152]
	mov	ecx, DWORD PTR [rax+r14]
	sub	ecx, DWORD PTR [rbx+136]

; 2347 :           while (n < (temp * 2)) {

	add	ecx, ecx
	cmp	esi, ecx
	jge	SHORT $LN43@HllEndDir
	sub	ecx, esi
	movsx	r12d, bp
	dec	ecx
	shr	ecx, 1
	inc	ecx
	mov	edi, ecx
	lea	esi, DWORD PTR [rsi+rcx*2]
	npad	8
$LL44@HllEndDir:

; 2348 :             AddLineQueueX(" dw %d", (int_16)acnt);

	lea	rcx, OFFSET FLAT:$SG6977
	mov	edx, r12d
	call	AddLineQueueX
	dec	rdi
	jne	SHORT $LL44@HllEndDir
	mov	r12d, DWORD PTR bcnt$1$[rsp]
$LN43@HllEndDir:

; 2349 :             n += 2;
; 2350 :           }
; 2351 :           AddLineQueueX(" dw %d", (int_16)bcnt);

	lea	rcx, OFFSET FLAT:$SG6979
	movsx	edx, r12w
	call	AddLineQueueX

; 2352 :           n += 2;
; 2353 :           if (hll->plabels[j] != hll->plabels[j + 1]) bcnt++;

	mov	rcx, QWORD PTR [rbx+112]
	add	esi, 2
	movzx	eax, WORD PTR [rcx+r15+2]
	cmp	WORD PTR [rcx+r15], ax
	je	SHORT $LN46@HllEndDir
	inc	r12d
	mov	DWORD PTR bcnt$1$[rsp], r12d
$LN46@HllEndDir:
	inc	r13d
	add	r14, 8
	add	r15, 2
	cmp	r13d, DWORD PTR [rbx+80]
	jb	$LL47@HllEndDir
	xor	ebp, ebp
$LN45@HllEndDir:

; 2354 :         }
; 2355 :       }
; 2356 : #endif
; 2357 :     }
; 2358 : 
; 2359 :     if (hll->cflag == 5) {

	cmp	BYTE PTR [rbx+85], 5
	mov	r15, QWORD PTR [rsp+2168]
	mov	r14, QWORD PTR [rsp+2176]
	jne	$LN537@HllEndDir

; 2360 :       if (hll->csize == 4) {

	cmp	BYTE PTR [rbx+84], 4
	jne	SHORT $LN40@HllEndDir

; 2361 :         for (j = 0; j < hll->casecnt; j++)

	cmp	DWORD PTR [rbx+80], 0
	mov	edi, ebp
	jbe	$LN536@HllEndDir
	mov	rsi, rbp
	npad	5
$LL39@HllEndDir:

; 2362 :           AddLineQueueX(" dd %d", hll->pcases[j]);

	mov	rax, QWORD PTR [rbx+104]
	lea	rcx, OFFSET FLAT:$SG6986
	mov	edx, DWORD PTR [rsi+rax]
	call	AddLineQueueX
	inc	edi
	add	rsi, 4
	cmp	edi, DWORD PTR [rbx+80]
	jb	SHORT $LL39@HllEndDir

; 2363 :       }
; 2364 : #if AMD64_SUPPORT
; 2365 :       else {

	mov	rdi, QWORD PTR tokenarray$[rsp]
	mov	esi, 4
	jmp	$LN535@HllEndDir
$LN40@HllEndDir:

; 2366 :         for (j = 0; j < hll->casecnt; j++)

	cmp	DWORD PTR [rbx+80], 0
	mov	edi, ebp
	jbe	$LN538@HllEndDir
	mov	rsi, rbp
	npad	1
$LL35@HllEndDir:

; 2367 :           AddLineQueueX(" dq %q", hll->pcases64[j]);

	mov	rdx, QWORD PTR [rbx+152]
	lea	rcx, OFFSET FLAT:$SG6991
	mov	rdx, QWORD PTR [rdx+rsi]
	call	AddLineQueueX
	inc	edi
	add	rsi, 8
	cmp	edi, DWORD PTR [rbx+80]
	jb	SHORT $LL35@HllEndDir

; 2368 :       }
; 2369 : #endif
; 2370 :     }
; 2371 :     if (hll->csize == 4) {
; 2372 :       LclFree(hll->pcases);
; 2373 :     }
; 2374 : #if AMD64_SUPPORT
; 2375 :     else
; 2376 :       LclFree(hll->pcases64);
; 2377 : #endif
; 2378 :     LclFree(hll->plabels);
; 2379 :     break;

	mov	rdi, QWORD PTR tokenarray$[rsp]
	mov	esi, 4
	jmp	$LN535@HllEndDir
$LN30@HllEndDir:

; 2380 :   case T_DOT_ENDFOR:
; 2381 :     if (hll->cmd != HLL_FOR) {

	cmp	DWORD PTR [rbx+68], esi
	je	SHORT $LN29@HllEndDir

; 2382 :       DebugMsg(("HllEndDir: no .FOR on the hll stack\n"));
; 2383 :       EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr);

	movsxd	rdx, DWORD PTR i$[rsp]
	mov	ecx, 80					; 00000050H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+8]
	call	EmitErr

; 2384 :       return(ERROR);

	mov	eax, -1
	jmp	$LN539@HllEndDir
$LN29@HllEndDir:

; 2385 :     }
; 2386 :     i++;

	inc	DWORD PTR i$[rsp]

; 2387 :     //Insert .CONTINUE label here if there is any
; 2388 :     if (hll->labels[LCONT])

	mov	r8d, DWORD PTR [rbx+24]
	test	r8d, r8d
	je	SHORT $LN28@HllEndDir

; 2389 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LCONT], buff));

	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG6997
	call	AddLineQueueX
$LN28@HllEndDir:

; 2390 :     //forever loop '.for (::)'
; 2391 :     if (hll->cmcnt == 0) goto adlabel;

	mov	edx, DWORD PTR [rbx+64]
	test	edx, edx
	je	$adlabel$6999

; 2392 :     //If counters exist
; 2393 :     else if (hll->counterlines[0]) {

	mov	r8, QWORD PTR [rbx+56]
	cmp	BYTE PTR [r8], bpl
	je	SHORT $LN25@HllEndDir

; 2394 :       //here we write counters
; 2395 :       if (hll->counterlines) {      //if there is something after second ':' expand it here

	test	r8, r8
	je	SHORT $LN24@HllEndDir

; 2396 :         ForInitAndNext(tokenarray, hll->cmcnt, hll->counterlines);

	mov	rcx, rdi
	call	ForInitAndNext
$LN24@HllEndDir:

; 2397 :         LclFree(hll->counterlines);
; 2398 :       }
; 2399 :       //first jump from the top happens here after the counters
; 2400 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LSKIP], buff));

	mov	r8d, DWORD PTR [rbx+20]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG7003
	call	AddLineQueueX

; 2401 :       /* create test label */
; 2402 :       if (hll->labels[LTEST]) {

	mov	r8d, DWORD PTR [rbx+8]
	test	r8d, r8d
	je	SHORT $LN23@HllEndDir

; 2403 :         AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG7005
	call	AddLineQueueX
$LN23@HllEndDir:

; 2404 :       }
; 2405 :       QueueTestLines(hll->condlines);

	mov	rcx, QWORD PTR [rbx+48]
	call	QueueTestLines

; 2406 :       LclFree(hll->condlines);
; 2407 :     }
; 2408 :     else

	jmp	SHORT $LN22@HllEndDir
$LN25@HllEndDir:

; 2409 :       AddLineQueueX(" jmp %s", GetLabelStr(hll->labels[LSTART], buff));

	mov	r8d, DWORD PTR [rbx+16]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG7007
	call	AddLineQueueX
$LN22@HllEndDir:

; 2410 :     if (!hll->cond)

	cmp	BYTE PTR [rbx+72], bpl
	jne	SHORT $LN21@HllEndDir
$adlabel$6999:

; 2411 :       adlabel:
; 2412 :     AddLineQueueX(" jmp %s", GetLabelStr(hll->labels[LSTART], buff));

	mov	r8d, DWORD PTR [rbx+16]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG7009
	call	AddLineQueueX
$LN21@HllEndDir:

; 2413 :     tokenarray[i].token = T_FINAL;

	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	mov	BYTE PTR [rax+rdi], bpl

; 2414 :     break;

	jmp	$LN535@HllEndDir
$LN20@HllEndDir:

; 2415 :     //end of .ENDFOR
; 2416 :   case T_DOT_ENDW:
; 2417 :     if (hll->cmd != HLL_WHILE) {

	cmp	DWORD PTR [rbx+68], 1

; 2418 :       DebugMsg(("HllEndDir: no .WHILE on the hll stack\n"));
; 2419 :       return(EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr));

	jne	$LN540@HllEndDir

; 2420 :     }
; 2421 :     i++;

	inc	DWORD PTR i$[rsp]

; 2422 :     /* create test label */
; 2423 :     if (hll->labels[LTEST]) {

	mov	r8d, DWORD PTR [rbx+8]
	test	r8d, r8d
	je	SHORT $LN18@HllEndDir

; 2424 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG7013
	call	AddLineQueueX
$LN18@HllEndDir:

; 2425 :     }
; 2426 :     QueueTestLines(hll->condlines);

	mov	rcx, QWORD PTR [rbx+48]
	call	QueueTestLines

; 2427 :     LclFree(hll->condlines);
; 2428 :     break;

	jmp	$LN535@HllEndDir
$LN17@HllEndDir:

; 2429 :   case T_DOT_UNTILCXZ:
; 2430 :     if (hll->cmd != HLL_REPEAT) {

	cmp	DWORD PTR [rbx+68], 2

; 2431 :       DebugMsg(("HllEndDir: no .REPEAT on the hll stack\n"));
; 2432 :       return(EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr));

	jne	$LN540@HllEndDir

; 2433 :     }
; 2434 :     i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 2435 :     if (hll->labels[LTEST]) /* v2.11: LTEST only needed if .CONTINUE has occured */

	mov	r8d, DWORD PTR [rbx+8]
	test	r8d, r8d
	je	SHORT $LN15@HllEndDir

; 2436 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG7017
	call	AddLineQueueX
	mov	eax, DWORD PTR i$[rsp]
$LN15@HllEndDir:

; 2437 : 
; 2438 :     /* read in optional (simple) expression */
; 2439 :     if (tokenarray[i].token != T_FINAL) {

	cdqe
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], bpl
	je	$LN14@HllEndDir

; 2440 :       rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, FALSE, buffer);

	lea	rax, QWORD PTR hllop$9193[rsp]
	lea	rdx, QWORD PTR i$[rsp]
	mov	r9d, 2
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR buffer$[rsp]
	mov	r8, rdi
	mov	QWORD PTR [rsp+40], rax
	mov	rcx, rbx
	mov	QWORD PTR hllop$9193[rsp], rbp
	mov	BYTE PTR [rsp+32], bpl
	mov	DWORD PTR hllop$9193[rsp+8], ebp
	mov	BYTE PTR buffer$[rsp], bpl
	call	GetExpression
	cmp	eax, -1
	jne	SHORT $LN467@HllEndDir
	mov	ebp, eax
	jmp	$LN535@HllEndDir
$LN467@HllEndDir:
	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], bpl
	je	SHORT $LN532@HllEndDir
	mov	ecx, 199				; 000000c7H
	call	EmitError

; 2441 :       if (rc == NOT_ERROR) {

	test	eax, eax
	mov	ebp, eax
	jne	$LN535@HllEndDir
$LN532@HllEndDir:

; 2442 :         rc = CheckCXZLines(buffer);

	lea	rcx, QWORD PTR buffer$[rsp]
	call	CheckCXZLines

; 2443 :         if (rc == NOT_ERROR)

	test	eax, eax
	mov	ebp, eax
	jne	SHORT $LN12@HllEndDir

; 2444 :           QueueTestLines(buffer); /* write condition lines */

	lea	rdi, QWORD PTR buffer$[rsp]
	npad	15
$LL473@HllEndDir:
	mov	edx, 10
	mov	rcx, rdi
	mov	rsi, rdi
	call	strchr
	test	rax, rax
	mov	rdi, rax
	je	SHORT $LN471@HllEndDir
	mov	BYTE PTR [rax], r12b
	inc	rdi
$LN471@HllEndDir:
	cmp	BYTE PTR [rsi], r12b
	je	SHORT $LN470@HllEndDir
	mov	rcx, rsi
	call	AddLineQueue
$LN470@HllEndDir:
	test	rdi, rdi
	jne	SHORT $LL473@HllEndDir

; 2445 :         else

	mov	rdi, QWORD PTR tokenarray$[rsp]
	mov	esi, 4
	jmp	$LN535@HllEndDir
$LN12@HllEndDir:

; 2446 :           EmitError(EXPR_TOO_COMPLEX_FOR_UNTILCXZ);

	mov	ecx, 191				; 000000bfH
	call	EmitError

; 2447 :       }
; 2448 :     }
; 2449 :     else {

	jmp	$LN535@HllEndDir
$LN14@HllEndDir:

; 2450 :       AddLineQueueX(JMPPREFIX "loop %s", GetLabelStr(hll->labels[LSTART], buff));

	mov	r8d, DWORD PTR [rbx+16]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG7023
	call	AddLineQueueX

; 2451 :     }
; 2452 :     break;

	jmp	$LN535@HllEndDir
$LN9@HllEndDir:

; 2453 :   case T_DOT_UNTIL:
; 2454 :     if (hll->cmd != HLL_REPEAT) {

	cmp	DWORD PTR [rbx+68], 2

; 2455 :       DebugMsg(("HllEndDir: no .REPEAT on the hll stack\n"));
; 2456 :       return(EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr));

	jne	$LN540@HllEndDir

; 2457 :     }
; 2458 :     i++;

	inc	DWORD PTR i$[rsp]

; 2459 :     if (hll->labels[LTEST]) /* v2.11: LTEST only needed if .CONTINUE has occured */

	mov	r8d, DWORD PTR [rbx+8]
	test	r8d, r8d
	je	SHORT $LN7@HllEndDir

; 2460 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG7027
	call	AddLineQueueX
$LN7@HllEndDir:

; 2461 : 
; 2462 :     /* read in (optional) expression */
; 2463 :     /* if expression is missing, just generate nothing */
; 2464 :     if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], bpl
	je	$LN535@HllEndDir

; 2465 :       rc = EvaluateHllExpression(hll, &i, tokenarray, LSTART, FALSE, buffer);

	lea	rax, QWORD PTR hllop$9216[rsp]
	lea	rdx, QWORD PTR i$[rsp]
	mov	r9d, 2
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR buffer$[rsp]
	mov	r8, rdi
	mov	QWORD PTR [rsp+40], rax
	mov	rcx, rbx
	mov	QWORD PTR hllop$9216[rsp], rbp
	mov	BYTE PTR [rsp+32], bpl
	mov	DWORD PTR hllop$9216[rsp+8], ebp
	mov	BYTE PTR buffer$[rsp], bpl
	call	GetExpression
	cmp	eax, -1
	jne	SHORT $LN481@HllEndDir
	mov	ebp, eax
	jmp	$LN535@HllEndDir
$LN481@HllEndDir:
	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], bpl
	je	SHORT $LN533@HllEndDir
	mov	ecx, 199				; 000000c7H
	call	EmitError

; 2466 :       if (rc == NOT_ERROR)

	test	eax, eax
	mov	ebp, eax
	jne	SHORT $LN535@HllEndDir
$LN533@HllEndDir:

; 2467 :         QueueTestLines(buffer); /* write condition lines */

	lea	rdi, QWORD PTR buffer$[rsp]
	npad	15
$LL487@HllEndDir:
	mov	edx, 10
	mov	rcx, rdi
	mov	rsi, rdi
	call	strchr
	test	rax, rax
	mov	rdi, rax
	je	SHORT $LN485@HllEndDir
	mov	BYTE PTR [rax], r12b
	inc	rdi
$LN485@HllEndDir:
	cmp	BYTE PTR [rsi], r12b
	je	SHORT $LN484@HllEndDir
	mov	rcx, rsi
	call	AddLineQueue
$LN484@HllEndDir:
	test	rdi, rdi
	jne	SHORT $LL487@HllEndDir
	mov	rdi, QWORD PTR tokenarray$[rsp]
	mov	esi, 4
	jmp	SHORT $LN535@HllEndDir
$LN536@HllEndDir:

; 2368 :       }
; 2369 : #endif
; 2370 :     }
; 2371 :     if (hll->csize == 4) {
; 2372 :       LclFree(hll->pcases);
; 2373 :     }
; 2374 : #if AMD64_SUPPORT
; 2375 :     else
; 2376 :       LclFree(hll->pcases64);
; 2377 : #endif
; 2378 :     LclFree(hll->plabels);
; 2379 :     break;

	mov	rdi, QWORD PTR tokenarray$[rsp]
	mov	esi, 4
	jmp	SHORT $LN535@HllEndDir
$LN537@HllEndDir:
	mov	rdi, QWORD PTR tokenarray$[rsp]
	mov	esi, 4
	jmp	SHORT $LN535@HllEndDir
$LN538@HllEndDir:
	mov	rdi, QWORD PTR tokenarray$[rsp]
	mov	esi, 4
$LN535@HllEndDir:

; 2468 :     }
; 2469 :     break;
; 2470 : #ifdef DEBUG_OUT
; 2471 :   default: /**/myassert(0); break;
; 2472 : #endif
; 2473 :   }
; 2474 : 
; 2475 :   /* create the exit label if it has been referenced */
; 2476 :   if (hll->labels[LEXIT])

	mov	r8d, DWORD PTR [rbx+12]
	test	r8d, r8d
	je	SHORT $LN4@HllEndDir

; 2477 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LEXIT], buff));

	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG7031
	call	AddLineQueueX
$LN4@HllEndDir:

; 2478 : 
; 2479 :   if (tokenarray[i].token != T_FINAL && rc == NOT_ERROR) {

	movsxd	rdx, DWORD PTR i$[rsp]
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rdi], 0
	je	SHORT $LN3@HllEndDir
	test	ebp, ebp
	jne	SHORT $LN3@HllEndDir

; 2480 :     EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos);

	mov	rdx, QWORD PTR [rdx+rdi+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 2481 :     rc = ERROR;

	mov	ebp, -1
$LN3@HllEndDir:

; 2482 :   }
; 2483 :   if (ModuleInfo.list)

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN2@HllEndDir

; 2484 :     LstWrite(LSTTYPE_DIRECTIVE, GetCurrOffset(), NULL);

	call	GetCurrOffset
	xor	r8d, r8d
	mov	ecx, esi
	mov	edx, eax
	call	LstWrite
$LN2@HllEndDir:

; 2485 : 
; 2486 :   /* v2.11: always run line-queue if it's not empty. */
; 2487 :   if (is_linequeue_populated())

	cmp	QWORD PTR ModuleInfo+184, 0
	je	SHORT $LN1@HllEndDir

; 2488 :     RunLineQueue();

	call	RunLineQueue
$LN1@HllEndDir:

; 2489 : 
; 2490 :   return(rc);

	mov	eax, ebp
$LN539@HllEndDir:
	mov	rsi, QWORD PTR [rsp+2208]
$LN260@HllEndDir:
	mov	r13, QWORD PTR [rsp+2184]
	mov	r12, QWORD PTR [rsp+2192]
	mov	rdi, QWORD PTR [rsp+2200]
	mov	rbp, QWORD PTR [rsp+2248]
	mov	rbx, QWORD PTR [rsp+2240]

; 2491 : }

	add	rsp, 2216				; 000008a8H
	ret	0
	npad	1
$LN534@HllEndDir:
	DD	$LN256@HllEndDir
	DD	$LN20@HllEndDir
	DD	$LN9@HllEndDir
	DD	$LN17@HllEndDir
	DD	$LN30@HllEndDir
	DD	$LN535@HllEndDir
	DD	$LN535@HllEndDir
	DD	$LN535@HllEndDir
	DD	$LN253@HllEndDir
HllEndDir ENDP
_TEXT	ENDS
PUBLIC	HllExitDir
EXTRN	atofloat:NEAR
xdata	SEGMENT
$unwind$HllExitDir DD 0a2501H
	DD	09ce425H
	DD	09ec421H
	DD	09f741dH
	DD	0a43412H
	DD	0a1010eH
xdata	ENDS
pdata	SEGMENT
$pdata$HllExitDir DD @imagerel($LN277#)
	DD	@imagerel($LN277#+75)
	DD	@imagerel($unwind$HllExitDir#)
pdata	ENDS
xdata	SEGMENT
$chain$6$HllExitDir DD 062121H
	DD	09bf421H
	DD	0a06416H
	DD	0a55408H
	DD	@imagerel($LN277#)
	DD	@imagerel($LN277#+75)
	DD	@imagerel($unwind$HllExitDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$HllExitDir DD @imagerel($LN277#+75)
	DD	@imagerel($LN277#+1895)
	DD	@imagerel($chain$6$HllExitDir#)
pdata	ENDS
xdata	SEGMENT
$chain$7$HllExitDir DD 020821H
	DD	09dd408H
	DD	@imagerel($LN277#+75)
	DD	@imagerel($LN277#+1895)
	DD	@imagerel($chain$6$HllExitDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$HllExitDir DD @imagerel($LN277#+1895)
	DD	@imagerel($LN277#+2238)
	DD	@imagerel($chain$7$HllExitDir#)
pdata	ENDS
xdata	SEGMENT
$chain$9$HllExitDir DD 020021H
	DD	09dd400H
	DD	@imagerel($LN277#+75)
	DD	@imagerel($LN277#+1895)
	DD	@imagerel($chain$6$HllExitDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$HllExitDir DD @imagerel($LN277#+2238)
	DD	@imagerel($LN277#+2258)
	DD	@imagerel($chain$9$HllExitDir#)
pdata	ENDS
xdata	SEGMENT
$chain$10$HllExitDir DD 021H
	DD	@imagerel($LN277#+75)
	DD	@imagerel($LN277#+1895)
	DD	@imagerel($chain$6$HllExitDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$10$HllExitDir DD @imagerel($LN277#+2258)
	DD	@imagerel($LN277#+2415)
	DD	@imagerel($chain$10$HllExitDir#)
pdata	ENDS
xdata	SEGMENT
$chain$11$HllExitDir DD 021H
	DD	@imagerel($LN277#)
	DD	@imagerel($LN277#+75)
	DD	@imagerel($unwind$HllExitDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$11$HllExitDir DD @imagerel($LN277#+2415)
	DD	@imagerel($LN277#+2456)
	DD	@imagerel($chain$11$HllExitDir#)
pdata	ENDS
xdata	SEGMENT
$chain$12$HllExitDir DD 060021H
	DD	09bf400H
	DD	0a06400H
	DD	0a55400H
	DD	@imagerel($LN277#)
	DD	@imagerel($LN277#+75)
	DD	@imagerel($unwind$HllExitDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$12$HllExitDir DD @imagerel($LN277#+2456)
	DD	@imagerel($LN277#+2504)
	DD	@imagerel($chain$12$HllExitDir#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buff$ = 64
hllop$9702 = 80
hllop$9402 = 80
opndx$ = 96
buffer$ = 208
i$ = 1296
tokenarray$ = 1304
HllExitDir PROC NEAR

; 2505 : {

$LN277:
	mov	DWORD PTR [rsp+8], ecx
	mov	rax, rsp
	sub	rsp, 1288				; 00000508H
	mov	QWORD PTR [rax+24], rbx

; 2506 :   struct expr         opndx;
; 2507 :   struct hll_item     *hll;
; 2508 :   ret_code            rc = NOT_ERROR;
; 2509 :   int                 j;
; 2510 :   int                 idx;
; 2511 :   int                 cmd = tokenarray[i].tokval;
; 2512 :   int                 *newcp;
; 2513 :   uint_16             *newlp;
; 2514 :   char buff[16];
; 2515 :   char                *p;
; 2516 :   char buffer[MAX_LINE_LEN];
; 2517 : #if AMD64_SUPPORT
; 2518 :   int_64              *newcp64;
; 2519 : #endif
; 2520 : 
; 2521 : 
; 2522 :   DebugMsg1(("HllExitDir(%s) enter\n", tokenarray[i].string_ptr));
; 2523 : 
; 2524 :   hll = HllStack;

	mov	rbx, QWORD PTR ModuleInfo+224
	mov	QWORD PTR [rax-16], rdi
	mov	QWORD PTR [rax-24], r12
	mov	QWORD PTR [rax-40], r14
	mov	r14, rdx
	movsxd	rdx, ecx
	xor	r12d, r12d
	shl	rdx, 5

; 2525 : 
; 2526 :   if (hll == NULL) {

	test	rbx, rbx
	mov	edi, DWORD PTR [rdx+r14+16]
	jne	SHORT $LN70@HllExitDir

; 2527 :     DebugMsg(("HllExitDir stack error\n"));
; 2528 :     return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));

	mov	ecx, 245				; 000000f5H
	call	EmitError
	jmp	$LN71@HllExitDir
$LN70@HllExitDir:
	mov	QWORD PTR [rsp+1320], rbp

; 2529 :   }
; 2530 :   switch (cmd) {

	lea	eax, DWORD PTR [rdi-332]
	mov	QWORD PTR [rsp+1280], rsi
	cmp	eax, 11
	mov	QWORD PTR [rsp+1240], r15
	mov	r15d, 4
	ja	$LN266@HllExitDir
	lea	r8, OFFSET FLAT:__ImageBase
	cdqe
	mov	ecx, DWORD PTR $LN260@HllExitDir[r8+rax*4]
	add	rcx, r8
	jmp	rcx
$LN67@HllExitDir:

; 2531 :   case T_DOT_DEFAULT:
; 2532 :     if (hll->flags & HLLF_DEFAULTOCCURED) {

	test	BYTE PTR [rbx+76], 2

; 2533 :       DebugMsg(("HllExitDir stack error\n"));
; 2534 :       return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));

	jne	$LN276@HllExitDir

; 2535 :     }
; 2536 :     if (ModuleInfo.switch_style == ASMSWITCH) {

	bt	DWORD PTR ModuleInfo+408, 20
	jb	SHORT $LN64@HllExitDir

; 2537 :       if (hll->casecnt) {

	cmp	DWORD PTR [rbx+80], r12d
	je	SHORT $LN64@HllExitDir

; 2538 :         if (hll->labels[LEXIT] == 0)

	cmp	DWORD PTR [rbx+12], r12d
	jne	SHORT $LN63@HllExitDir

; 2539 :           hll->labels[LEXIT] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+12], eax
$LN63@HllExitDir:

; 2540 :         AddLineQueueX("jmp %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG7065
	call	AddLineQueueX

; 2541 :         hll->breakoccured = TRUE;

	mov	BYTE PTR [rbx+122], 1
$LN64@HllExitDir:

; 2542 :       }
; 2543 :     }
; 2544 :     if (hll->labels[LDEF] == 0)

	cmp	DWORD PTR [rbx+28], r12d
	jne	SHORT $LN62@HllExitDir

; 2545 :       hll->labels[LDEF] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+28], eax
$LN62@HllExitDir:

; 2546 :     AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LDEF], buff));

	mov	r8d, DWORD PTR [rbx+28]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG7067
	call	AddLineQueueX

; 2547 :     hll->flags |= HLLF_DEFAULTOCCURED;

	or	DWORD PTR [rbx+76], 2

; 2548 :     i++;

	inc	DWORD PTR i$[rsp]

; 2549 :     break;

	jmp	$LN266@HllExitDir
$LN61@HllExitDir:

; 2550 :   case T_DOT_CASE:
; 2551 :     if (hll->cmd != HLL_SWITCH) {

	cmp	DWORD PTR [rbx+68], 5

; 2552 :       DebugMsg(("HllExitDir stack error\n"));
; 2553 :       return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));

	jne	$LN276@HllExitDir

; 2554 :     }
; 2555 :     if (ModuleInfo.switch_style == ASMSWITCH) {

	bt	DWORD PTR ModuleInfo+408, 20
	jb	SHORT $LN251@HllExitDir

; 2556 :       if (hll->casecnt) {

	cmp	DWORD PTR [rbx+80], r12d
	je	SHORT $LN251@HllExitDir

; 2557 :         if (hll->labels[LEXIT] == 0)

	cmp	DWORD PTR [rbx+12], r12d
	jne	SHORT $LN57@HllExitDir

; 2558 :           hll->labels[LEXIT] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+12], eax
$LN57@HllExitDir:

; 2559 :         AddLineQueueX("jmp %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG7073
	call	AddLineQueueX

; 2560 :         hll->breakoccured = TRUE;

	mov	BYTE PTR [rbx+122], 1
$LN251@HllExitDir:
	mov	ebp, 8
$LL56@HllExitDir:

; 2561 :       }
; 2562 :     }
; 2563 :     for (;;) {
; 2564 :       if (hll->breakoccured) {

	cmp	BYTE PTR [rbx+122], r12b
	je	$LN54@HllExitDir

; 2565 :         hll->labels[LTEST] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352

; 2566 :         hll->breakoccured = FALSE;  // if .break did not occure label will not be increased
; 2567 :         AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	r8d, eax
	mov	DWORD PTR [rbx+8], eax
	mov	BYTE PTR [rbx+122], r12b
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG7078
	call	AddLineQueueX

; 2568 :         hll->savedlab = hex2dec(buff + 2);

	movsx	ecx, BYTE PTR buff$[rsp+2]
	lea	rdi, QWORD PTR buff$[rsp+2]
	test	ecx, ecx
	mov	edx, r12d
	je	SHORT $LN218@HllExitDir
	npad	5
$LL95@HllExitDir:
	lea	eax, DWORD PTR [rcx-48]
	shl	edx, 4
	cmp	eax, 9
	ja	SHORT $LN92@HllExitDir
	mov	ecx, eax
	jmp	SHORT $LN90@HllExitDir
$LN92@HllExitDir:
	or	ecx, 32					; 00000020H
	lea	eax, DWORD PTR [rcx-97]
	cmp	eax, 5
	ja	SHORT $LN90@HllExitDir
	add	ecx, -87				; ffffffa9H
$LN90@HllExitDir:
	inc	rdi
	add	edx, ecx
	movsx	ecx, BYTE PTR [rdi]
	test	ecx, ecx
	jne	SHORT $LL95@HllExitDir
$LN218@HllExitDir:
	mov	WORD PTR [rbx+120], dx
$LN54@HllExitDir:

; 2569 :       }
; 2570 :       i++;

	mov	ecx, DWORD PTR i$[rsp]
	inc	ecx
	mov	DWORD PTR i$[rsp], ecx

; 2571 :       if (tokenarray[i].token != T_FINAL) {

	movsxd	rcx, ecx
	shl	rcx, 5
	cmp	BYTE PTR [rcx+r14], r12b
	je	$LN53@HllExitDir

; 2572 :         strcpy(buffer, tokenarray[i].tokpos);

	mov	rcx, QWORD PTR [rcx+r14+24]
	lea	rdx, QWORD PTR buffer$[rsp]
	npad	5
$LL73@HllExitDir:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL73@HllExitDir

; 2573 :         DebugMsg1(("HllExitDir(%s): calling EvalOperand, i=%u\n", tokenarray[i].string_ptr, i));
; 2574 :         if (EvalOperand(&i, tokenarray, Token_Count, &opndx, 0) == ERROR) {

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, r14
	mov	BYTE PTR [rsp+32], r12b
	call	EvalOperand
	cmp	eax, -1
	je	$LN219@HllExitDir

; 2577 :         }
; 2578 :         p = tokenarray[i].tokpos;
; 2579 :         switch (opndx.kind) {

	cmp	DWORD PTR opndx$[rsp+60], 3
	jne	SHORT $LN47@HllExitDir

; 2580 :         case EXPR_CONST:
; 2581 :           break;
; 2582 :         case EXPR_FLOAT:
; 2583 : #if FPIMMEDIATE
; 2584 :           if (Options.strict_masm_compat == FALSE) {

	cmp	BYTE PTR Options+136, r12b
	jne	SHORT $LN47@HllExitDir

; 2585 :             /* convert to REAL4, unless REAL8 coercion is requested */
; 2586 :             atofloat(&opndx.fvalue, opndx.float_tok->string_ptr, opndx.mem_type == MT_REAL8 ? 8 : 4, opndx.negative, opndx.float_tok->floattype);

	mov	rdx, QWORD PTR opndx$[rsp+16]
	mov	r9d, DWORD PTR opndx$[rsp+72]
	mov	r8d, r15d
	movsx	eax, BYTE PTR [rdx+1]
	mov	rdx, QWORD PTR [rdx+8]
	shr	r9d, 5
	and	r9d, 1
	cmp	DWORD PTR opndx$[rsp+64], 39		; 00000027H
	lea	rcx, QWORD PTR opndx$[rsp]
	cmove	r8d, ebp
	mov	DWORD PTR [rsp+32], eax
	call	atofloat
$LN47@HllExitDir:

; 2595 :       }
; 2596 :       if (hll->csize == 4) {

	movzx	eax, BYTE PTR [rbx+84]
	cmp	al, r15b
	jne	$LN45@HllExitDir

; 2597 :         if (!hll->maxalloccasen) {

	cmp	DWORD PTR [rbx+100], r12d
	jne	SHORT $LN44@HllExitDir

; 2598 :           hll->pcases = LclAlloc(hll->csize * 50);

	mov	ecx, 200				; 000000c8H
	call	LclAlloc

; 2599 :           hll->plabels = LclAlloc(sizeof(uint_16) * 50);

	mov	ecx, 100				; 00000064H
	mov	QWORD PTR [rbx+104], rax
	call	LclAlloc

; 2600 :           hll->maxalloccasen = 50;

	mov	DWORD PTR [rbx+100], 50			; 00000032H
	mov	QWORD PTR [rbx+112], rax
$LN44@HllExitDir:

; 2601 :         }
; 2602 :         if (hll->casecnt >= hll->maxalloccasen) {

	mov	ecx, DWORD PTR [rbx+100]
	cmp	DWORD PTR [rbx+80], ecx
	jb	$LN40@HllExitDir

; 2603 :           hll->maxalloccasen += 50;
; 2604 :           newcp = LclAlloc(hll->csize * hll->maxalloccasen);

	movsx	eax, BYTE PTR [rbx+84]
	add	ecx, 50					; 00000032H
	mov	DWORD PTR [rbx+100], ecx
	imul	eax, ecx
	movsxd	rcx, eax
	call	LclAlloc

; 2605 :           memcpy(newcp, hll->pcases, hll->casecnt * hll->csize);

	movsx	r8d, BYTE PTR [rbx+84]
	mov	rdx, QWORD PTR [rbx+104]
	imul	r8d, DWORD PTR [rbx+80]
	mov	rcx, rax
	mov	rdi, rax
	call	memcpy

; 2606 :           LclFree(hll->pcases);
; 2607 :           hll->pcases = newcp;
; 2608 : 
; 2609 :           newlp = LclAlloc(sizeof(uint_16) * hll->maxalloccasen);

	movsxd	rcx, DWORD PTR [rbx+100]
	mov	QWORD PTR [rbx+104], rdi
	add	rcx, rcx
	call	LclAlloc

; 2610 :           memcpy(newlp, hll->plabels, hll->casecnt * sizeof(uint_16));

	mov	r8d, DWORD PTR [rbx+80]
	mov	rdx, QWORD PTR [rbx+112]
	add	r8, r8
	mov	rcx, rax
	mov	rdi, rax
	call	memcpy

; 2611 :           LclFree(hll->plabels);
; 2612 :           hll->plabels = newlp;

	mov	QWORD PTR [rbx+112], rdi

; 2613 :         }
; 2614 :       }
; 2615 : #if AMD64_SUPPORT
; 2616 :       else {

	jmp	$LN40@HllExitDir
$LN45@HllExitDir:

; 2617 :         if (!hll->maxalloccasen) {

	cmp	DWORD PTR [rbx+100], r12d
	jne	SHORT $LN41@HllExitDir

; 2618 :           hll->pcases64 = LclAlloc(hll->csize * 50);

	movsx	eax, al
	imul	eax, 50					; 00000032H
	movsxd	rcx, eax
	call	LclAlloc

; 2619 :           hll->plabels = LclAlloc(sizeof(uint_16) * 50);

	mov	ecx, 100				; 00000064H
	mov	QWORD PTR [rbx+152], rax
	call	LclAlloc

; 2620 :           hll->maxalloccasen = 50;

	mov	DWORD PTR [rbx+100], 50			; 00000032H
	mov	QWORD PTR [rbx+112], rax
$LN41@HllExitDir:

; 2621 :         }
; 2622 :         if (hll->casecnt >= hll->maxalloccasen) {

	mov	ecx, DWORD PTR [rbx+100]
	cmp	DWORD PTR [rbx+80], ecx
	jb	SHORT $LN40@HllExitDir

; 2623 :           hll->maxalloccasen += 50;
; 2624 :           newcp64 = LclAlloc(hll->csize * hll->maxalloccasen);

	movsx	eax, BYTE PTR [rbx+84]
	add	ecx, 50					; 00000032H
	mov	DWORD PTR [rbx+100], ecx
	imul	eax, ecx
	movsxd	rcx, eax
	call	LclAlloc

; 2625 :           memcpy(newcp64, hll->pcases64, hll->casecnt * hll->csize);

	movsx	r8d, BYTE PTR [rbx+84]
	mov	rdx, QWORD PTR [rbx+152]
	imul	r8d, DWORD PTR [rbx+80]
	mov	rcx, rax
	mov	rdi, rax
	call	memcpy

; 2626 :           LclFree(hll->pcases64);
; 2627 :           hll->pcases64 = newcp64;
; 2628 : 
; 2629 :           newlp = LclAlloc(sizeof(uint_16) * hll->maxalloccasen);

	movsxd	rcx, DWORD PTR [rbx+100]
	mov	QWORD PTR [rbx+152], rdi
	add	rcx, rcx
	call	LclAlloc

; 2630 :           memcpy(newlp, hll->plabels, hll->casecnt * sizeof(uint_16));

	mov	r8d, DWORD PTR [rbx+80]
	mov	rdx, QWORD PTR [rbx+112]
	add	r8, r8
	mov	rcx, rax
	mov	rdi, rax
	call	memcpy

; 2631 :           LclFree(hll->plabels);
; 2632 :           hll->plabels = newlp;

	mov	QWORD PTR [rbx+112], rdi
$LN40@HllExitDir:

; 2633 :         }
; 2634 :       }
; 2635 : #endif
; 2636 :       if ((ModuleInfo.Ofssize == USE32) || (hll->csize == 4)) {

	cmp	BYTE PTR ModuleInfo+404, 1
	je	SHORT $LN38@HllExitDir
	cmp	BYTE PTR [rbx+84], r15b
	je	SHORT $LN38@HllExitDir

; 2642 :       }
; 2643 : #if AMD64_SUPPORT
; 2644 :       else {
; 2645 :         for (j = 0; j < hll->casecnt; j++) {

	cmp	DWORD PTR [rbx+80], r12d
	mov	esi, r12d
	jbe	SHORT $LN264@HllExitDir
	mov	rdi, r12
	npad	9
$LL32@HllExitDir:

; 2646 :           if (hll->pcases64[j] == opndx.value64)

	mov	rcx, QWORD PTR [rbx+152]
	mov	rax, QWORD PTR opndx$[rsp]
	cmp	QWORD PTR [rdi+rcx], rax
	jne	SHORT $LN31@HllExitDir

; 2647 :             EmitErr(CASE_ALREADY_OCCURED_IN_THIS_SWITCH_BLOCK, buffer);

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	ecx, 253				; 000000fdH
	call	EmitErr
$LN31@HllExitDir:
	inc	esi
	add	rdi, rbp
	cmp	esi, DWORD PTR [rbx+80]
	jb	SHORT $LL32@HllExitDir
$LN264@HllExitDir:

; 2648 :         }
; 2649 :         hll->pcases64[hll->casecnt] = opndx.value64;

	mov	edx, DWORD PTR [rbx+80]
	mov	rcx, QWORD PTR [rbx+152]
	mov	rax, QWORD PTR opndx$[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	jmp	SHORT $LN33@HllExitDir
$LN38@HllExitDir:

; 2637 :         for (j = 0; j < hll->casecnt; j++) {

	cmp	DWORD PTR [rbx+80], r12d
	mov	esi, r12d
	jbe	SHORT $LN265@HllExitDir
	mov	rdi, r12
	npad	1
$LL37@HllExitDir:

; 2638 :           if (hll->pcases[j] == opndx.value)

	mov	rcx, QWORD PTR [rbx+104]
	mov	eax, DWORD PTR opndx$[rsp]
	cmp	DWORD PTR [rdi+rcx], eax
	jne	SHORT $LN36@HllExitDir

; 2639 :             EmitErr(CASE_ALREADY_OCCURED_IN_THIS_SWITCH_BLOCK, buffer);

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	ecx, 253				; 000000fdH
	call	EmitErr
$LN36@HllExitDir:
	inc	esi
	add	rdi, r15
	cmp	esi, DWORD PTR [rbx+80]
	jb	SHORT $LL37@HllExitDir
$LN265@HllExitDir:

; 2640 :         }
; 2641 :         hll->pcases[hll->casecnt] = opndx.value;

	mov	edx, DWORD PTR [rbx+80]
	mov	rcx, QWORD PTR [rbx+104]
	mov	eax, DWORD PTR opndx$[rsp]
	mov	DWORD PTR [rcx+rdx*4], eax
$LN33@HllExitDir:

; 2650 :       }
; 2651 : #endif
; 2652 :       hll->plabels[hll->casecnt] = hll->savedlab;

	mov	edx, DWORD PTR [rbx+80]
	movzx	eax, WORD PTR [rbx+120]
	mov	rcx, QWORD PTR [rbx+112]
	mov	WORD PTR [rcx+rdx*2], ax

; 2653 :       hll->casecnt++;

	inc	DWORD PTR [rbx+80]

; 2654 :       if (tokenarray[i].token != T_COMMA)

	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+r14], 44			; 0000002cH
	je	$LL56@HllExitDir

; 2655 :         break;
; 2656 :     }

	jmp	$LN266@HllExitDir
$LN219@HllExitDir:

; 2575 :           DebugMsg(("HllExitDir(%s): EvalOperand() failed\n", tokenarray[i].string_ptr));
; 2576 :           return(ERROR);

	mov	eax, -1
	jmp	$LN275@HllExitDir
$LN53@HllExitDir:

; 2587 :             break;
; 2588 :           }
; 2589 : #endif
; 2590 :         }
; 2591 :       }
; 2592 :       else {
; 2593 :         DebugMsg(("HllExitDir stack error\n"));
; 2594 :         return(EmitError(MISSING_OPERATOR_IN_EXPRESSION));

	mov	ecx, 150				; 00000096H
	call	EmitError
	jmp	$LN275@HllExitDir
$LN27@HllExitDir:

; 2657 :     break;
; 2658 :   case T_DOT_ELSE:
; 2659 :   case T_DOT_ELSEIF:
; 2660 :     if (hll->cmd != HLL_IF) {

	cmp	DWORD PTR [rbx+68], r12d
	je	SHORT $LN26@HllExitDir

; 2661 :       DebugMsg(("HllExitDir(%s): labels[LTEST]=%X\n", tokenarray[i].string_ptr, hll->labels[LTEST]));
; 2662 :       return(EmitErr(BLOCK_NESTING_ERROR, tokenarray[i].string_ptr));

	mov	rdx, QWORD PTR [rdx+r14+8]
	mov	ecx, 80					; 00000050H
	call	EmitErr
	jmp	$LN275@HllExitDir
$LN26@HllExitDir:

; 2663 :     }
; 2664 :     /* v2.08: check for multiple ELSE clauses */
; 2665 :     if (hll->flags & HLLF_ELSEOCCURED) {

	test	BYTE PTR [rbx+76], 1
	je	SHORT $LN25@HllExitDir

; 2666 :       return(EmitError(DOT_ELSE_CLAUSE_ALREADY_OCCURED_IN_THIS_DOT_IF_BLOCK));

	mov	ecx, 67					; 00000043H
	call	EmitError
	jmp	$LN275@HllExitDir
$LN25@HllExitDir:

; 2667 :     }
; 2668 : 
; 2669 :     /* the 'exit'-label is only needed if an .ELSE branch exists.
; 2670 :     * That's why it is created delayed.
; 2671 :     */
; 2672 :     if (hll->labels[LEXIT] == 0)

	cmp	DWORD PTR [rbx+12], r12d
	jne	SHORT $LN24@HllExitDir

; 2673 :       hll->labels[LEXIT] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+12], eax
$LN24@HllExitDir:

; 2674 :     AddLineQueueX(JMPPREFIX "jmp %s", GetLabelStr(hll->labels[LEXIT], buff));

	mov	r8d, DWORD PTR [rbx+12]
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG7118
	call	AddLineQueueX

; 2675 : 
; 2676 :     if (hll->labels[LTEST] > 0) {

	mov	r8d, DWORD PTR [rbx+8]
	test	r8d, r8d
	je	SHORT $LN23@HllExitDir

; 2677 :       AddLineQueueX("%s" LABELQUAL, GetLabelStr(hll->labels[LTEST], buff));

	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG7120
	call	AddLineQueueX

; 2678 :       hll->labels[LTEST] = 0;

	mov	DWORD PTR [rbx+8], r12d
$LN23@HllExitDir:

; 2679 :     }
; 2680 :     i++;

	inc	DWORD PTR i$[rsp]

; 2681 :     if (cmd == T_DOT_ELSEIF) {

	cmp	edi, 335				; 0000014fH
	jne	$LN22@HllExitDir

; 2682 :       /* create new labels[LTEST] label */
; 2683 :       hll->labels[LTEST] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352

; 2684 :       rc = EvaluateHllExpression(hll, &i, tokenarray, LTEST, FALSE, buffer);

	lea	rdx, QWORD PTR i$[rsp]
	xor	r9d, r9d
	inc	eax
	mov	r8, r14
	mov	rcx, rbx
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+8], eax
	lea	rax, QWORD PTR hllop$9402[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR hllop$9402[rsp], r12
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR hllop$9402[rsp+8], r12d
	mov	BYTE PTR buffer$[rsp], r12b
	mov	BYTE PTR [rsp+32], r12b
	call	GetExpression
	cmp	eax, -1
	jne	SHORT $LN107@HllExitDir
	mov	r12d, eax
	jmp	$LN266@HllExitDir
$LN107@HllExitDir:
	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+r14], r12b
	je	SHORT $LN248@HllExitDir
	mov	ecx, 199				; 000000c7H
	call	EmitError

; 2685 :       if (rc == NOT_ERROR)

	test	eax, eax
	mov	r12d, eax
	jne	$LN266@HllExitDir
$LN248@HllExitDir:

; 2686 :         QueueTestLines(buffer);

	lea	rdi, QWORD PTR buffer$[rsp]
	npad	3
$LL113@HllExitDir:
	mov	edx, 10
	mov	rcx, rdi
	mov	rbx, rdi
	call	strchr
	test	rax, rax
	mov	rdi, rax
	je	SHORT $LN111@HllExitDir
	mov	BYTE PTR [rax], 0
	inc	rdi
$LN111@HllExitDir:
	cmp	BYTE PTR [rbx], 0
	je	SHORT $LN110@HllExitDir
	mov	rcx, rbx
	call	AddLineQueue
$LN110@HllExitDir:
	test	rdi, rdi
	jne	SHORT $LL113@HllExitDir

; 2687 :     }
; 2688 :     else

	jmp	$LN266@HllExitDir
$LN22@HllExitDir:

; 2689 :       hll->flags |= HLLF_ELSEOCCURED;

	or	DWORD PTR [rbx+76], 1

; 2690 : 
; 2691 :     break;

	jmp	$LN266@HllExitDir
	npad	2
$LL267@HllExitDir:

; 2692 :   case T_DOT_BREAK:
; 2693 :   case T_DOT_CONTINUE:
; 2694 :     for (; hll && hll->cmd == HLL_IF; hll = hll->next);

	cmp	DWORD PTR [rbx+68], r12d
	jne	SHORT $LN15@HllExitDir
	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL267@HllExitDir
$LN276@HllExitDir:

; 2695 :     if (hll == NULL) {
; 2696 :       return(EmitError(DIRECTIVE_MUST_BE_IN_CONTROL_BLOCK));

	mov	ecx, 245				; 000000f5H
	call	EmitError
	jmp	$LN275@HllExitDir
$LN15@HllExitDir:

; 2697 :     }
; 2698 :     /* v2.11: create 'exit' and 'test' labels delayed.
; 2699 :     */
; 2700 :     if (cmd == T_DOT_BREAK) {

	cmp	edi, 332				; 0000014cH
	jne	SHORT $LN14@HllExitDir

; 2701 :       hll->breakoccured = TRUE;
; 2702 :       if (hll->labels[LEXIT] == 0)

	cmp	DWORD PTR [rbx+12], r12d
	mov	BYTE PTR [rbx+122], 1
	jne	SHORT $LN13@HllExitDir

; 2703 :         hll->labels[LEXIT] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+12], eax
$LN13@HllExitDir:

; 2704 :       idx = LEXIT;

	mov	esi, 1
	jmp	SHORT $LN9@HllExitDir
$LN14@HllExitDir:

; 2705 :     }
; 2706 :     else if (hll->cmd == HLL_FOR) {

	mov	eax, DWORD PTR [rbx+68]
	cmp	eax, r15d
	jne	SHORT $LN11@HllExitDir

; 2707 :       /* added by habran
; 2708 :       .CONTINUE label is created here for .FOR loops only if it exists.
; 2709 :       It is different than .WHILE because it has to first alter counters
; 2710 :       */
; 2711 :       if (hll->labels[LCONT] == 0) hll->labels[LCONT] = GetHllLabel();

	cmp	DWORD PTR [rbx+24], r12d
	jne	SHORT $LN10@HllExitDir
	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+24], eax
$LN10@HllExitDir:

; 2712 :       idx = (hll->labels[LCONT] ? LCONT : LSTART);

	cmp	DWORD PTR [rbx+24], r12d
	mov	esi, 2
	cmovne	esi, r15d

; 2713 :     }
; 2714 :     else {

	jmp	SHORT $LN9@HllExitDir
$LN11@HllExitDir:

; 2715 :       /* 'test' is not created for .WHILE loops here; because
; 2716 :       * if it doesn't exist, there's no condition to test.
; 2717 :       */
; 2718 :       if (hll->cmd == HLL_REPEAT && hll->labels[LTEST] == 0)

	cmp	eax, 2
	jne	SHORT $LN8@HllExitDir
	cmp	DWORD PTR [rbx+8], r12d
	jne	SHORT $LN8@HllExitDir

; 2719 :         hll->labels[LTEST] = GetHllLabel();

	mov	eax, DWORD PTR ModuleInfo+352
	inc	eax
	mov	DWORD PTR ModuleInfo+352, eax
	mov	DWORD PTR [rbx+8], eax
$LN8@HllExitDir:

; 2720 :       idx = (hll->labels[LTEST] ? LTEST : LSTART);

	cmp	DWORD PTR [rbx+8], r12d
	mov	esi, 2
	cmovne	esi, r12d
$LN9@HllExitDir:

; 2721 :     }
; 2722 : 
; 2723 :     /* .BREAK .IF ... or .CONTINUE .IF ? */
; 2724 :     i++;

	mov	ecx, DWORD PTR i$[rsp]
	inc	ecx

; 2725 :     if (tokenarray[i].token != T_FINAL) {

	movsxd	rax, ecx
	mov	DWORD PTR i$[rsp], ecx
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+r14]
	test	cl, cl
	je	$LN7@HllExitDir

; 2726 :       if (tokenarray[i].token == T_DIRECTIVE && tokenarray[i].tokval == T_DOT_IF) {

	cmp	cl, 3
	jne	$LN266@HllExitDir
	cmp	DWORD PTR [rax+r14+16], 328		; 00000148H
	jne	$LN266@HllExitDir

; 2727 :         enum hll_cmd savedcmd = hll->cmd;
; 2728 :         hll->cmd = HLL_BREAK;
; 2729 :         i++;
; 2730 :         /* v2.11: set rc and don't exit if an error occurs; see hll3.aso */
; 2731 :         rc = EvaluateHllExpression(hll, &i, tokenarray, idx, TRUE, buffer);

	lea	rax, QWORD PTR hllop$9702[rsp]
	lea	rdx, QWORD PTR i$[rsp]
	mov	QWORD PTR [rsp+1256], r13
	mov	r13d, DWORD PTR [rbx+68]
	mov	QWORD PTR [rsp+48], rax
	mov	DWORD PTR [rbx+68], 3
	inc	DWORD PTR i$[rsp]
	lea	rax, QWORD PTR buffer$[rsp]
	mov	r9d, esi
	mov	QWORD PTR [rsp+40], rax
	mov	r8, r14
	mov	rcx, rbx
	mov	QWORD PTR hllop$9702[rsp], r12
	mov	DWORD PTR hllop$9702[rsp+8], r12d
	mov	BYTE PTR buffer$[rsp], r12b
	mov	BYTE PTR [rsp+32], 1
	lea	rbp, QWORD PTR buffer$[rsp]
	call	GetAndExpression
	cmp	eax, -1
	je	$LN249@HllExitDir
	movsxd	rcx, DWORD PTR i$[rsp]
	shl	rcx, 5
	add	rcx, r14
	call	GetCOp
	cmp	eax, 8
	jne	SHORT $LN123@HllExitDir
$LL137@HllExitDir:
	inc	DWORD PTR i$[rsp]
	xor	eax, eax
	mov	rdi, rbp
	mov	rcx, -1
	lea	rdx, QWORD PTR i$[rsp]
	mov	r9d, esi
	repne scasb
	lea	rax, QWORD PTR hllop$9702[rsp]
	mov	r8, r14
	not	rcx
	mov	QWORD PTR [rsp+48], rax
	mov	DWORD PTR hllop$9702[rsp+8], r12d
	dec	rcx
	add	rbp, rcx
	mov	rcx, rbx
	mov	QWORD PTR [rsp+40], rbp
	mov	BYTE PTR [rsp+32], 1
	call	GetAndExpression
	cmp	eax, -1
	je	$LN249@HllExitDir
	movsxd	rcx, DWORD PTR i$[rsp]
	shl	rcx, 5
	add	rcx, r14
	call	GetCOp
	cmp	eax, 8
	je	SHORT $LL137@HllExitDir
$LN123@HllExitDir:
	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+r14], r12b
	je	SHORT $LN250@HllExitDir
	mov	ecx, 199				; 000000c7H
	call	EmitError

; 2732 :         if (rc == NOT_ERROR)

	test	eax, eax
	mov	r12d, eax
	jne	SHORT $LN200@HllExitDir
$LN250@HllExitDir:

; 2733 :           QueueTestLines(buffer);

	lea	rdi, QWORD PTR buffer$[rsp]
	npad	4
$LL201@HllExitDir:
	mov	edx, 10
	mov	rcx, rdi
	mov	rsi, rdi
	call	strchr
	test	rax, rax
	mov	rdi, rax
	je	SHORT $LN199@HllExitDir
	mov	BYTE PTR [rax], 0
	inc	rdi
$LN199@HllExitDir:
	cmp	BYTE PTR [rsi], 0
	je	SHORT $LN198@HllExitDir
	mov	rcx, rsi
	call	AddLineQueue
$LN198@HllExitDir:
	test	rdi, rdi
	jne	SHORT $LL201@HllExitDir
$LN200@HllExitDir:

; 2734 :         hll->cmd = savedcmd;

	mov	DWORD PTR [rbx+68], r13d
	mov	r13, QWORD PTR [rsp+1256]

; 2735 :       }
; 2736 :     }
; 2737 :     else {

	jmp	SHORT $LN266@HllExitDir
$LN249@HllExitDir:

; 2734 :         hll->cmd = savedcmd;

	mov	DWORD PTR [rbx+68], r13d
	mov	r13, QWORD PTR [rsp+1256]
	mov	r12d, -1

; 2735 :       }
; 2736 :     }
; 2737 :     else {

	jmp	SHORT $LN266@HllExitDir
$LN7@HllExitDir:

; 2738 :       AddLineQueueX(JMPPREFIX "jmp %s", GetLabelStr(hll->labels[idx], buff));

	movsxd	rax, esi
	lea	rdx, OFFSET FLAT:$SG5756
	lea	rcx, QWORD PTR buff$[rsp]
	mov	r8d, DWORD PTR [rbx+rax*4+8]
	call	sprintf
	lea	rdx, QWORD PTR buff$[rsp]
	lea	rcx, OFFSET FLAT:$SG7142
	call	AddLineQueueX
$LN266@HllExitDir:

; 2739 :     }
; 2740 :     break;
; 2741 : #ifdef DEBUG_OUT
; 2742 :   default: /**/myassert(0); break;
; 2743 : #endif
; 2744 :   }
; 2745 :   if (tokenarray[i].token != T_FINAL && rc == NOT_ERROR) {

	movsxd	rdx, DWORD PTR i$[rsp]
	shl	rdx, 5
	cmp	BYTE PTR [rdx+r14], 0
	je	SHORT $LN3@HllExitDir
	test	r12d, r12d
	jne	SHORT $LN3@HllExitDir

; 2746 :     EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos);

	mov	rdx, QWORD PTR [rdx+r14+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 2747 :     rc = ERROR;

	mov	r12d, -1
$LN3@HllExitDir:

; 2748 :   }
; 2749 : 
; 2750 :   if (ModuleInfo.list)

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN2@HllExitDir

; 2751 :     LstWrite(LSTTYPE_DIRECTIVE, GetCurrOffset(), NULL);

	call	GetCurrOffset
	xor	r8d, r8d
	mov	ecx, r15d
	mov	edx, eax
	call	LstWrite
$LN2@HllExitDir:

; 2752 : 
; 2753 :   /* v2.11: always run line-queue if it's not empty. */
; 2754 :   if (is_linequeue_populated())

	cmp	QWORD PTR ModuleInfo+184, 0
	je	SHORT $LN1@HllExitDir

; 2755 :     RunLineQueue();

	call	RunLineQueue
$LN1@HllExitDir:

; 2756 : 
; 2757 :   return(rc);

	mov	eax, r12d
$LN275@HllExitDir:
	mov	rsi, QWORD PTR [rsp+1280]
	mov	rbp, QWORD PTR [rsp+1320]
	mov	r15, QWORD PTR [rsp+1240]
$LN71@HllExitDir:
	mov	r14, QWORD PTR [rsp+1248]
	mov	r12, QWORD PTR [rsp+1264]
	mov	rdi, QWORD PTR [rsp+1272]
	mov	rbx, QWORD PTR [rsp+1312]

; 2758 : }

	add	rsp, 1288				; 00000508H
	ret	0
	npad	1
$LN260@HllExitDir:
	DD	$LL267@HllExitDir
	DD	$LL267@HllExitDir
	DD	$LN27@HllExitDir
	DD	$LN27@HllExitDir
	DD	$LN266@HllExitDir
	DD	$LN266@HllExitDir
	DD	$LN266@HllExitDir
	DD	$LN266@HllExitDir
	DD	$LN266@HllExitDir
	DD	$LN266@HllExitDir
	DD	$LN61@HllExitDir
	DD	$LN67@HllExitDir
HllExitDir ENDP
_TEXT	ENDS
PUBLIC	HllCheckOpen
xdata	SEGMENT
$unwind$HllCheckOpen DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$HllCheckOpen DD @imagerel($LN4#)
	DD	@imagerel($LN4#+36)
	DD	@imagerel($unwind$HllCheckOpen#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
HllCheckOpen PROC NEAR

; 2764 : {

$LN4:
	sub	rsp, 40					; 00000028H

; 2765 :   if (HllStack) {

	cmp	QWORD PTR ModuleInfo+224, 0
	je	SHORT $LN1@HllCheckOp

; 2766 :     //EmitErr( BLOCK_NESTING_ERROR, ".if-.repeat-.while" );
; 2767 :     EmitErr(UNMATCHED_BLOCK_NESTING, ".if-.repeat-.while");

	lea	rdx, OFFSET FLAT:$SG7150
	mov	ecx, 142				; 0000008eH
	call	EmitErr
$LN1@HllCheckOp:

; 2768 :   }
; 2769 :   DebugMsg(("HllCheckOpen: allocated items:%u, reused items:%u, .while cond-blocks/bytes:%u/%u\n", cntAlloc, cntReused, cntCond, cntCondBytes));
; 2770 : }

	add	rsp, 40					; 00000028H
	ret	0
HllCheckOpen ENDP
_TEXT	ENDS
PUBLIC	HllInit
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
pass$ = 8
HllInit	PROC NEAR

; 2793 :   //if ( pass == PASS_1 )
; 2794 :   //    HllFree = NULL;
; 2795 : 
; 2796 :   //HllStack = NULL; /* empty stack of open hll directives */
; 2797 :   ModuleInfo.hll_label = 0; /* init hll label counter */

	mov	DWORD PTR ModuleInfo+352, 0

; 2798 : #ifdef DEBUG_OUT
; 2799 :   evallvl = 0;
; 2800 :   if (pass == PASS_1) {
; 2801 :     cntAlloc = 0;
; 2802 :     cntReused = 0;
; 2803 :     cntCond = 0;
; 2804 :     cntCondBytes = 0;
; 2805 :   }
; 2806 : #endif
; 2807 :   return;
; 2808 : }

	ret	0
HllInit	ENDP
_TEXT	ENDS
END
