; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG2641	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
$SG2638	DB	'HJWASM', 00H
	ORG $+1
$SG2651	DB	'%s', 00H
_DATA	ENDS
EXTRN	exit:NEAR
EXTRN	close_files:NEAR
EXTRN	EmitError:NEAR
xdata	SEGMENT
$unwind$genfailure DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$genfailure DD @imagerel(genfailure#)
	DD	@imagerel(genfailure#+35)
	DD	@imagerel($unwind$genfailure#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\main.c
pdata	ENDS
_TEXT	SEGMENT
signo$ = 48
genfailure PROC NEAR

; 50   : {

	sub	rsp, 40					; 00000028H

; 51   : #if CATCHBREAK
; 52   :     if (signo != SIGBREAK)

	cmp	ecx, 21
	je	SHORT $LN1@genfailure

; 53   : #else
; 54   :     if (signo != SIGTERM)
; 55   : #endif
; 56   :         EmitError( GENERAL_FAILURE );

	mov	ecx, 168				; 000000a8H
	call	EmitError
$LN1@genfailure:

; 57   :     close_files();

	call	close_files

; 58   :     exit( EXIT_FAILURE );

	mov	ecx, 1
	call	exit
	int	3
$LN4@genfailure:
genfailure ENDP
_TEXT	ENDS
PUBLIC	main
EXTRN	printf:NEAR
EXTRN	MsgGetEx:NEAR
EXTRN	CmdlineFini:NEAR
EXTRN	EmitErr:NEAR
EXTRN	ErrnoStr:NEAR
EXTRN	_findclose:NEAR
EXTRN	_findnext:NEAR
EXTRN	AssembleModule:NEAR
EXTRN	GetFNamePart:NEAR
EXTRN	_findfirst:NEAR
EXTRN	Options:BYTE
EXTRN	write_logo:NEAR
EXTRN	ParseCmdline:NEAR
EXTRN	signal:NEAR
EXTRN	getenv:NEAR
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$main DD	061201H
	DD	04e6412H
	DD	053540eH
	DD	04f010aH
xdata	ENDS
pdata	SEGMENT
$pdata$main DD	@imagerel($LN21#)
	DD	@imagerel($LN21#+20)
	DD	@imagerel($unwind$main#)
pdata	ENDS
xdata	SEGMENT
$chain$2$main DD 020421H
	DD	04cc404H
	DD	@imagerel($LN21#)
	DD	@imagerel($LN21#+20)
	DD	@imagerel($unwind$main#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$main DD @imagerel($LN21#+20)
	DD	@imagerel($LN21#+124)
	DD	@imagerel($chain$2$main#)
pdata	ENDS
xdata	SEGMENT
$chain$4$main DD 041021H
	DD	04d7410H
	DD	0523408H
	DD	@imagerel($LN21#+20)
	DD	@imagerel($LN21#+124)
	DD	@imagerel($chain$2$main#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$main DD @imagerel($LN21#+124)
	DD	@imagerel($LN21#+379)
	DD	@imagerel($chain$4$main#)
pdata	ENDS
xdata	SEGMENT
$chain$5$main DD 021H
	DD	@imagerel($LN21#+20)
	DD	@imagerel($LN21#+124)
	DD	@imagerel($chain$2$main#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$main DD @imagerel($LN21#+379)
	DD	@imagerel($LN21#+402)
	DD	@imagerel($chain$5$main#)
pdata	ENDS
xdata	SEGMENT
$chain$6$main DD 021H
	DD	@imagerel($LN21#)
	DD	@imagerel($LN21#+20)
	DD	@imagerel($unwind$main#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$main DD @imagerel($LN21#+402)
	DD	@imagerel($LN21#+474)
	DD	@imagerel($chain$6$main#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
finfo$ = 32
fname$ = 336
argc$ = 640
numArgs$ = 648
argv$ = 648
main	PROC NEAR

; 62   : {

$LN21:
	mov	rax, rsp
	sub	rsp, 632				; 00000278H
	mov	QWORD PTR [rax+32], rbp
	mov	QWORD PTR [rax-8], rsi

; 63   : 	char    *pEnv;
; 64   : 	int     numArgs = 0;

	xor	ebp, ebp
	mov	QWORD PTR [rax-24], r12

; 65   : 	int     numFiles = 0;
; 66   : 	int     rc = 0;
; 67   : 
; 68   : #if WILDCARDS
; 69   : 	/* v2.11: _findfirst/next/close() handle, should be of type intptr_t.
; 70   : 	* since this type isn't necessarily defined, type long is used as substitute.
; 71   : 	*/
; 72   : 
; 73   : 	size_t    fh;
; 74   : 	const char *pfn;
; 75   : 	int     dirsize;
; 76   : 	struct  _finddata_t finfo;
; 77   : 	char    fname[FILENAME_MAX];
; 78   : #endif
; 79   : 
; 80   : #if 0 //def DEBUG_OUT    /* DebugMsg() cannot be used that early */
; 81   : 	int i;
; 82   : 	for ( i = 1; i < argc; i++ ) {
; 83   : 		printf("argv[%u]=>%s<\n", i, argv[i] );
; 84   : 	}
; 85   : #endif
; 86   : 
; 87   : #ifdef TRMEM
; 88   : 	tm_Init();
; 89   : #endif
; 90   : 
; 91   : 	pEnv = getenv("HJWASM");

	lea	rcx, OFFSET FLAT:$SG2638
	mov	DWORD PTR [rax+16], ebp
	mov	esi, ebp
	mov	r12, rdx
	call	getenv

; 92   : 	if (pEnv == NULL)

	test	rax, rax
	lea	rcx, OFFSET FLAT:$SG2641

; 93   : 		pEnv = "";
; 94   : 	argv[0] = pEnv;
; 95   : 	
; 96   : 	/* Set the default module architecture to AVX */
; 97   : 	MODULEARCH = ARCH_AVX;
; 98   : 
; 99   : #ifndef DEBUG_OUT
; 100  : 	signal(SIGSEGV, genfailure);

	lea	rdx, OFFSET FLAT:genfailure
	cmovne	rcx, rax
	mov	QWORD PTR [r12], rcx
	lea	ecx, QWORD PTR [rbp+11]
	mov	BYTE PTR MODULEARCH, 1
	call	signal

; 101  : #endif
; 102  : 
; 103  : #if CATCHBREAK
; 104  : 	signal(SIGBREAK, genfailure);

	lea	rdx, OFFSET FLAT:genfailure
	lea	ecx, QWORD PTR [rbp+21]
	call	signal

; 105  : #else
; 106  : 	signal(SIGTERM, genfailure);
; 107  : #endif
; 108  : 	/* ParseCmdLine() returns NULL if no source file name has been found (anymore) */
; 109  : 	while (ParseCmdline((const char **)argv, &numArgs)) {

	lea	rdx, QWORD PTR numArgs$[rsp]
	mov	rcx, r12
	call	ParseCmdline
	test	rax, rax
	je	$LN8@main
	mov	QWORD PTR [rsp+656], rbx
	mov	QWORD PTR [rsp+616], rdi
	npad	4
$LL9@main:

; 110  : 		numFiles++;

	inc	ebp

; 111  : 		write_logo();

	call	write_logo

; 112  : #if WILDCARDS
; 113  : 		if ((fh = _findfirst(Options.names[ASM], &finfo)) == -1) {

	mov	rcx, QWORD PTR Options+16
	lea	rdx, QWORD PTR finfo$[rsp]
	call	_findfirst
	cmp	rax, -1
	mov	rdi, rax
	je	$LN17@main

; 116  : 			break;
; 117  : 		}
; 118  : 		/* v2.12: _splitpath()/_makepath() removed */
; 119  : 		//_splitpath( Options.names[ASM], drv, dir, NULL, NULL );
; 120  : 		//DebugMsg(("main: _splitpath(%s): drv=\"%s\" dir=\"%s\"\n", Options.names[ASM], drv, dir ));
; 121  : 		pfn = GetFNamePart(Options.names[ASM]);

	mov	rcx, QWORD PTR Options+16
	call	GetFNamePart

; 122  : 		dirsize = pfn - Options.names[ASM];

	mov	rdx, QWORD PTR Options+16

; 123  : 		memcpy(fname, Options.names[ASM], dirsize);

	lea	rcx, QWORD PTR fname$[rsp]
	sub	eax, edx
	movsxd	rbx, eax
	mov	r8, rbx
	call	memcpy
	lea	r11, QWORD PTR finfo$[rsp+36]
	sub	rbx, r11
	lea	rbx, QWORD PTR fname$[rsp+rbx]
	npad	3
$LL6@main:

; 124  : 			do {
; 125  : 				/* v2.12: _splitpath()/_makepath() removed */
; 126  : 				//_makepath( fname, drv, dir, finfo.name, NULL );
; 127  : 				//DebugMsg(("main: _makepath(\"%s\", \"%s\", \"%s\")=\"%s\"\n", drv, dir, finfo.name, fname ));
; 128  : 				strcpy(&fname[dirsize], finfo.name);

	lea	rcx, QWORD PTR finfo$[rsp+36]
	npad	11
$LL13@main:
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rbx+rcx-1], al
	jne	SHORT $LL13@main

; 129  : 				DebugMsg(("main: fname=%s\n", fname));
; 130  : 				rc = AssembleModule(fname);  /* assemble 1 module */

	lea	rcx, QWORD PTR fname$[rsp]
	call	AssembleModule

; 131  : 			} while ((_findnext(fh, &finfo) != -1));

	lea	rdx, QWORD PTR finfo$[rsp]
	mov	rcx, rdi
	mov	esi, eax
	call	_findnext
	cmp	eax, -1
	jne	SHORT $LL6@main

; 132  : 		    _findclose(fh);

	mov	rcx, rdi
	call	_findclose
	lea	rdx, QWORD PTR numArgs$[rsp]
	mov	rcx, r12
	call	ParseCmdline
	test	rax, rax
	jne	$LL9@main

; 112  : #if WILDCARDS
; 113  : 		if ((fh = _findfirst(Options.names[ASM], &finfo)) == -1) {

	jmp	SHORT $LN20@main
$LN17@main:

; 114  : 			DebugMsg(("main: _findfirst(%s) failed\n", Options.names[ASM]));
; 115  : 			EmitErr(CANNOT_OPEN_FILE, Options.names[ASM], ErrnoStr());

	call	ErrnoStr
	mov	rdx, QWORD PTR Options+16
	mov	ecx, 106				; 0000006aH
	mov	r8, rax
	call	EmitErr
$LN20@main:
	mov	rbx, QWORD PTR [rsp+656]
	mov	rdi, QWORD PTR [rsp+616]
$LN8@main:

; 133  : #else
; 134  : 		rc = AssembleModule( Options.names[ASM] );
; 135  : #endif
; 136  : 	};
; 137  : 	CmdlineFini();

	call	CmdlineFini

; 138  : 	if (numArgs == 0) {

	cmp	DWORD PTR numArgs$[rsp], 0
	mov	r12, QWORD PTR [rsp+608]
	jne	SHORT $LN3@main

; 139  : 		write_logo();

	call	write_logo

; 140  : 		printf("%s", MsgGetEx(MSG_USAGE));

	xor	ecx, ecx
	call	MsgGetEx
	lea	rcx, OFFSET FLAT:$SG2651
	mov	rdx, rax
	call	printf
	jmp	SHORT $LN1@main
$LN3@main:

; 141  : 	}
; 142  : 	else if (numFiles == 0)

	test	ebp, ebp
	jne	SHORT $LN1@main

; 143  : 		EmitError(NO_FILENAME_SPECIFIED);

	lea	ecx, QWORD PTR [rbp+104]
	call	EmitError
$LN1@main:
	mov	rbp, QWORD PTR [rsp+664]

; 144  : 
; 145  : #ifdef TRMEM
; 146  : 	tm_Fini();
; 147  : #endif
; 148  : 
; 149  : 	DebugMsg(("main: exit, return code=%u\n", 1 - rc));
; 150  : 	return(1 - rc); /* zero if no errors */

	mov	eax, 1
	sub	eax, esi
	mov	rsi, QWORD PTR [rsp+624]

; 151  : }

	add	rsp, 632				; 00000278H
	ret	0
main	ENDP
_TEXT	ENDS
END
