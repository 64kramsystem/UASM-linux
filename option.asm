; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
$SG5424	DB	'SSE', 00H
$SG5425	DB	'movaps', 00H
	ORG $+1
$SG5426	DB	'movdqa', 00H
	ORG $+1
$SG5427	DB	'movups', 00H
	ORG $+1
$SG5428	DB	'movdqu', 00H
	ORG $+1
$SG5429	DB	'movss', 00H
	ORG $+2
$SG5430	DB	'movsd', 00H
	ORG $+2
$SG5431	DB	'movd', 00H
	ORG $+3
$SG5432	DB	'movq', 00H
	ORG $+3
$SG5435	DB	'AVX', 00H
$SG5436	DB	'vmovaps', 00H
$SG5437	DB	'vmovdqa', 00H
$SG5438	DB	'vmovups', 00H
$SG5439	DB	'vmovdqu', 00H
$SG5440	DB	'vmovss', 00H
	ORG $+1
$SG5441	DB	'vmovsd', 00H
	ORG $+1
$SG5442	DB	'vmovd', 00H
	ORG $+2
$SG5443	DB	'vmovq', 00H
	ORG $+2
$SG5467	DB	'NONE', 00H
	ORG $+3
$SG5470	DB	'NOTPUBLIC', 00H
	ORG $+2
$SG5473	DB	'ALL', 00H
$SG5620	DB	'TRUE', 00H
	ORG $+3
$SG5623	DB	'FALSE', 00H
	ORG $+2
$SG5635	DB	'NONE', 00H
	ORG $+3
$SG5638	DB	'PROLOGUEDEF', 00H
$SG5651	DB	'NONE', 00H
	ORG $+7
$SG5654	DB	'EPILOGUEDEF', 00H
$SG5664	DB	'GROUP', 00H
	ORG $+2
$SG5667	DB	'FLAT', 00H
	ORG $+7
$SG5670	DB	'SEGMENT', 00H
$SG5685	DB	'PRIVATE', 00H
$SG5688	DB	'EXPORT', 00H
	ORG $+1
$SG5703	DB	'USE16', 00H
	ORG $+2
$SG5706	DB	'USE32', 00H
	ORG $+2
$SG5709	DB	'USE64', 00H
	ORG $+2
$SG5790	DB	'AUTO', 00H
	ORG $+3
$SG5793	DB	'NOAUTO', 00H
	ORG $+1
$SG5802	DB	'CSTYLE', 00H
	ORG $+1
$SG5805	DB	'ASMSTYLE', 00H
	ORG $+7
$SG5849	DB	'@StackBase', 00H
	ORG $+5
$SG5850	DB	'@ProcStatus', 00H
	ORG $+4
$SG5854	DB	'@StackBase', 00H
	ORG $+5
$SG5855	DB	'@ProcStatus', 00H
$SG5871	DB	'__imp_', 00H
	ORG $+1
$SG5872	DB	'_imp_', 00H
	ORG $+2
$SG5881	DB	'NONE', 00H
	ORG $+7
$SG5907	DB	'@StackBase', 00H
	ORG $+5
$SG5908	DB	'@ProcStatus', 00H
	ORG $+4
$SG5925	DB	'@StackBase', 00H
	ORG $+5
$SG5926	DB	'@ProcStatus', 00H
	ORG $+4
$SG5933	DB	'DOTNAME', 00H
$SG5934	DB	'NODOTNAME', 00H
	ORG $+2
$SG5935	DB	'M510', 00H
	ORG $+3
$SG5936	DB	'NOM510', 00H
	ORG $+1
$SG5937	DB	'SCOPED', 00H
	ORG $+5
$SG5938	DB	'NOSCOPED', 00H
	ORG $+7
$SG5939	DB	'OLDSTRUCTS', 00H
	ORG $+5
$SG5940	DB	'NOOLDSTRUCTS', 00H
	ORG $+3
$SG5941	DB	'EMULATOR', 00H
	ORG $+7
$SG5942	DB	'NOEMULATOR', 00H
	ORG $+1
$SG5943	DB	'LJMP', 00H
	ORG $+3
$SG5944	DB	'NOLJMP', 00H
	ORG $+5
$SG5945	DB	'READONLY', 00H
	ORG $+7
$SG5946	DB	'NOREADONLY', 00H
	ORG $+5
$SG5947	DB	'OLDMACROS', 00H
	ORG $+6
$SG5948	DB	'NOOLDMACROS', 00H
$SG5949	DB	'EXPR16', 00H
	ORG $+1
$SG5950	DB	'EXPR32', 00H
	ORG $+5
$SG5951	DB	'NOSIGNEXTEND', 00H
	ORG $+3
$SG5952	DB	'CASEMAP', 00H
$SG5953	DB	'PROC', 00H
	ORG $+3
$SG5954	DB	'PROLOGUE', 00H
	ORG $+7
$SG5955	DB	'EPILOGUE', 00H
	ORG $+7
$SG5956	DB	'LANGUAGE', 00H
	ORG $+7
$SG5957	DB	'NOKEYWORD', 00H
	ORG $+2
$SG5958	DB	'SETIF2', 00H
	ORG $+1
$SG5959	DB	'OFFSET', 00H
	ORG $+5
$SG5960	DB	'SEGMENT', 00H
$SG5961	DB	'FIELDALIGN', 00H
	ORG $+5
$SG5962	DB	'PROCALIGN', 00H
	ORG $+2
$SG5963	DB	'MZ', 00H
	ORG $+1
$SG5964	DB	'FRAME', 00H
	ORG $+2
$SG5965	DB	'ELF', 00H
	ORG $+4
$SG5966	DB	'RENAMEKEYWORD', 00H
	ORG $+2
$SG5967	DB	'WIN64', 00H
	ORG $+2
$SG5968	DB	'DLLIMPORT', 00H
	ORG $+6
$SG5969	DB	'CODEVIEW', 00H
	ORG $+7
$SG5970	DB	'STACKBASE', 00H
	ORG $+2
$SG5971	DB	'EVEX', 00H
	ORG $+7
$SG5972	DB	'ZEROLOCALS', 00H
	ORG $+5
$SG5973	DB	'SWITCHSTYLE', 00H
$SG5974	DB	'FLAT', 00H
	ORG $+3
$SG5975	DB	'ARCH', 00H
_DATA	ENDS
CONST	SEGMENT
optiontab DQ	FLAT:$SG5933
	DQ	FLAT:SetDotName
	DQ	FLAT:$SG5934
	DQ	FLAT:SetNoDotName
	DQ	FLAT:$SG5935
	DQ	FLAT:SetM510
	DQ	FLAT:$SG5936
	DQ	FLAT:SetNoM510
	DQ	FLAT:$SG5937
	DQ	FLAT:SetScoped
	DQ	FLAT:$SG5938
	DQ	FLAT:SetNoScoped
	DQ	FLAT:$SG5939
	DQ	FLAT:SetOldStructs
	DQ	FLAT:$SG5940
	DQ	FLAT:SetNoOldStructs
	DQ	FLAT:$SG5941
	DQ	FLAT:SetEmulator
	DQ	FLAT:$SG5942
	DQ	FLAT:SetNoEmulator
	DQ	FLAT:$SG5943
	DQ	FLAT:SetLJmp
	DQ	FLAT:$SG5944
	DQ	FLAT:SetNoLJmp
	DQ	FLAT:$SG5945
	DQ	FLAT:Unsupported
	DQ	FLAT:$SG5946
	DQ	FLAT:SetNoReadonly
	DQ	FLAT:$SG5947
	DQ	FLAT:Unsupported
	DQ	FLAT:$SG5948
	DQ	FLAT:SetNoOldmacros
	DQ	FLAT:$SG5949
	DQ	FLAT:Unsupported
	DQ	FLAT:$SG5950
	DQ	FLAT:SetExpr32
	DQ	FLAT:$SG5951
	DQ	FLAT:SetNoSignExt
	DQ	FLAT:$SG5952
	DQ	FLAT:SetCaseMap
	DQ	FLAT:$SG5953
	DQ	FLAT:SetProc
	DQ	FLAT:$SG5954
	DQ	FLAT:SetPrologue
	DQ	FLAT:$SG5955
	DQ	FLAT:SetEpilogue
	DQ	FLAT:$SG5956
	DQ	FLAT:SetLanguage
	DQ	FLAT:$SG5957
	DQ	FLAT:SetNoKeyword
	DQ	FLAT:$SG5958
	DQ	FLAT:SetSetIF2
	DQ	FLAT:$SG5959
	DQ	FLAT:SetOffset
	DQ	FLAT:$SG5960
	DQ	FLAT:SetSegment
	DQ	FLAT:$SG5961
	DQ	FLAT:SetFieldAlign
	DQ	FLAT:$SG5962
	DQ	FLAT:SetProcAlign
	DQ	FLAT:$SG5963
	DQ	FLAT:SetMZ
	DQ	FLAT:$SG5964
	DQ	FLAT:SetFrame
	DQ	FLAT:$SG5965
	DQ	FLAT:SetElf
	DQ	FLAT:$SG5966
	DQ	FLAT:SetRenameKey
	DQ	FLAT:$SG5967
	DQ	FLAT:SetWin64
	DQ	FLAT:$SG5968
	DQ	FLAT:SetDllImport
	DQ	FLAT:$SG5969
	DQ	FLAT:SetCodeView
	DQ	FLAT:$SG5970
	DQ	FLAT:SetStackBase
	DQ	FLAT:$SG5971
	DQ	FLAT:SetEvex
	DQ	FLAT:$SG5972
	DQ	FLAT:SetZeroLocals
	DQ	FLAT:$SG5973
	DQ	FLAT:SetSwitchStile
	DQ	FLAT:$SG5974
	DQ	FLAT:SetFlat
	DQ	FLAT:$SG5975
	DQ	FLAT:SetArch
CONST	ENDS
EXTRN	EmitError:NEAR
EXTRN	EmitConstError:NEAR
EXTRN	EvalOperand:NEAR
EXTRN	ModuleInfo:BYTE
xdata	SEGMENT
$unwind$SetEvex DD 030c01H
	DD	014010cH
	DD	03002H
xdata	ENDS
pdata	SEGMENT
$pdata$SetEvex DD @imagerel(SetEvex#)
	DD	@imagerel(SetEvex#+142)
	DD	@imagerel($unwind$SetEvex#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\option.c
pdata	ENDS
_TEXT	SEGMENT
opndx$ = 48
i$ = 176
pi$ = 176
tokenarray$ = 184
SetEvex	PROC NEAR

; 40   : {

	push	rbx
	mov	r11, rsp
	sub	rsp, 160				; 000000a0H

; 41   : 	int i = *pi;

	mov	eax, DWORD PTR [rcx]

; 42   : 	struct expr opndx;
; 43   : 
; 44   : 	if (EvalOperand(&i, tokenarray, Token_Count, &opndx, 0) == ERROR)

	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rbx, rcx
	lea	r9, QWORD PTR [r11-112]
	lea	rcx, QWORD PTR [r11+16]
	mov	BYTE PTR [rsp+32], 0
	mov	DWORD PTR [r11+16], eax
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN4@SetEvex

; 57   : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN4@SetEvex:

; 45   : 		return(ERROR);
; 46   : 	if (opndx.kind == EXPR_CONST) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN3@SetEvex

; 47   : 		if (opndx.llvalue > 1) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	rax, 1
	jbe	SHORT $LN2@SetEvex

; 48   : 			return(EmitConstError(&opndx));

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError

; 57   : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN2@SetEvex:

; 49   : 		}
; 50   : 		evex = opndx.llvalue;

	mov	BYTE PTR evex, al

; 54   : 	}
; 55   : 	*pi = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR [rbx], eax

; 56   : 	return(NOT_ERROR);

	xor	eax, eax

; 57   : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN3@SetEvex:

; 51   : 	}
; 52   : 	else {
; 53   : 		return(EmitError(CONSTANT_EXPECTED));

	mov	ecx, 65					; 00000041H
	call	EmitError

; 57   : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
SetEvex	ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SetZeroLocals DD 030c01H
	DD	014010cH
	DD	03002H
xdata	ENDS
pdata	SEGMENT
$pdata$SetZeroLocals DD @imagerel(SetZeroLocals#)
	DD	@imagerel(SetZeroLocals#+142)
	DD	@imagerel($unwind$SetZeroLocals#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
opndx$ = 48
i$ = 176
pi$ = 176
tokenarray$ = 184
SetZeroLocals PROC NEAR

; 81   : {

	push	rbx
	mov	r11, rsp
	sub	rsp, 160				; 000000a0H

; 82   : 	int i = *pi;

	mov	eax, DWORD PTR [rcx]

; 83   : 	struct expr opndx;
; 84   : 
; 85   : 	if (EvalOperand(&i, tokenarray, Token_Count, &opndx, 0) == ERROR)

	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rbx, rcx
	lea	r9, QWORD PTR [r11-112]
	lea	rcx, QWORD PTR [r11+16]
	mov	BYTE PTR [rsp+32], 0
	mov	DWORD PTR [r11+16], eax
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN4@SetZeroLoc

; 98   : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN4@SetZeroLoc:

; 86   : 		return(ERROR);
; 87   : 	if (opndx.kind == EXPR_CONST) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN3@SetZeroLoc

; 88   : 		if (opndx.llvalue > 1) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	rax, 1
	jbe	SHORT $LN2@SetZeroLoc

; 89   : 			return(EmitConstError(&opndx));

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError

; 98   : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN2@SetZeroLoc:

; 90   : 		}
; 91   : 		ZEROLOCALS = opndx.llvalue;

	mov	BYTE PTR ZEROLOCALS, al

; 95   : 	}
; 96   : 	*pi = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR [rbx], eax

; 97   : 	return(NOT_ERROR);

	xor	eax, eax

; 98   : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN3@SetZeroLoc:

; 92   : 	}
; 93   : 	else {
; 94   : 		return(EmitError(CONSTANT_EXPECTED));

	mov	ecx, 65					; 00000041H
	call	EmitError

; 98   : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
SetZeroLocals ENDP
_TEXT	ENDS
EXTRN	EmitErr:NEAR
EXTRN	MOVE_SIMD_QWORD:QWORD
EXTRN	MOVE_SIMD_DWORD:QWORD
EXTRN	MOVE_DOUBLE:QWORD
EXTRN	MOVE_SINGLE:QWORD
EXTRN	MOVE_UNALIGNED_INT:QWORD
EXTRN	MOVE_UNALIGNED_FLOAT:QWORD
EXTRN	MOVE_ALIGNED_INT:QWORD
EXTRN	__ImageBase:BYTE
EXTRN	MOVE_ALIGNED_FLOAT:QWORD
EXTRN	_stricmp:NEAR
xdata	SEGMENT
$unwind$SetArch DD 091e01H
	DD	09741eH
	DD	086416H
	DD	07540eH
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetArch DD @imagerel(SetArch#)
	DD	@imagerel(SetArch#+647)
	DD	@imagerel($unwind$SetArch#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetArch	PROC NEAR

; 102  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp

; 103  : 	int i = *pi;

	movsxd	rbp, DWORD PTR [rcx]
	mov	QWORD PTR [rsp+64], rsi

; 104  : 	if (tokenarray[i].token == T_ID) {

	mov	rbx, rbp
	mov	QWORD PTR [rsp+72], rdi
	shl	rbx, 5
	mov	rdi, rdx
	mov	rsi, rcx
	cmp	BYTE PTR [rbx+rdx], 8
	jne	$LN6@SetArch

; 105  : 		if (0 == _stricmp(tokenarray[i].string_ptr, "SSE")) {

	mov	rcx, QWORD PTR [rbx+rdi+8]
	lea	rdx, OFFSET FLAT:$SG5424
	call	_stricmp
	test	eax, eax
	jne	$LN5@SetArch

; 106  : 			MODULEARCH = ARCH_SSE;
; 107  : 			ModuleInfo.arch = ARCH_SSE;
; 108  : 			strcpy(MOVE_ALIGNED_FLOAT, "movaps");

	mov	rcx, QWORD PTR MOVE_ALIGNED_FLOAT
	and	DWORD PTR ModuleInfo+408, -2		; fffffffeH
	mov	BYTE PTR MODULEARCH, al
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $SG5425[rdx]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG5425[rdx+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR $SG5425[rdx+6]
	mov	BYTE PTR [rcx+6], al

; 109  : 			strcpy(MOVE_ALIGNED_INT, "movdqa");

	mov	eax, DWORD PTR $SG5426[rdx]
	mov	rcx, QWORD PTR MOVE_ALIGNED_INT
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG5426[rdx+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR $SG5426[rdx+6]
	mov	BYTE PTR [rcx+6], al

; 110  : 			strcpy(MOVE_UNALIGNED_FLOAT, "movups");

	mov	eax, DWORD PTR $SG5427[rdx]
	mov	rcx, QWORD PTR MOVE_UNALIGNED_FLOAT
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG5427[rdx+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR $SG5427[rdx+6]
	mov	BYTE PTR [rcx+6], al

; 111  : 			strcpy(MOVE_UNALIGNED_INT, "movdqu");

	mov	eax, DWORD PTR $SG5428[rdx]
	mov	rcx, QWORD PTR MOVE_UNALIGNED_INT
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG5428[rdx+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR $SG5428[rdx+6]
	mov	BYTE PTR [rcx+6], al

; 112  : 			strcpy(MOVE_SINGLE, "movss");

	mov	eax, DWORD PTR $SG5429[rdx]
	mov	rcx, QWORD PTR MOVE_SINGLE
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG5429[rdx+4]
	mov	WORD PTR [rcx+4], ax

; 113  : 			strcpy(MOVE_DOUBLE, "movsd");

	mov	eax, DWORD PTR $SG5430[rdx]
	mov	rcx, QWORD PTR MOVE_DOUBLE
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG5430[rdx+4]
	mov	WORD PTR [rcx+4], ax

; 114  : 			strcpy(MOVE_SIMD_DWORD, "movd");

	mov	eax, DWORD PTR $SG5431[rdx]
	mov	rcx, QWORD PTR MOVE_SIMD_DWORD
	mov	DWORD PTR [rcx], eax
	movzx	eax, BYTE PTR $SG5431[rdx+4]
	mov	BYTE PTR [rcx+4], al

; 115  : 			strcpy(MOVE_SIMD_QWORD, "movq");

	mov	eax, DWORD PTR $SG5432[rdx]
	mov	rcx, QWORD PTR MOVE_SIMD_QWORD
	mov	DWORD PTR [rcx], eax
	movzx	eax, BYTE PTR $SG5432[rdx+4]
	mov	BYTE PTR [rcx+4], al

; 131  : 		}
; 132  : 		DebugMsg1(("SetArch(%s) ok\n", tokenarray[i].string_ptr));
; 133  : 		i++;

	lea	eax, DWORD PTR [rbp+1]

; 137  : 	}
; 138  : 	*pi = i;

	mov	DWORD PTR [rsi], eax

; 139  : 	return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN7@SetArch
$LN5@SetArch:

; 116  : 		}
; 117  : 		else if (0 == _stricmp(tokenarray[i].string_ptr, "AVX")) {

	mov	rcx, QWORD PTR [rbx+rdi+8]
	lea	rdx, OFFSET FLAT:$SG5435
	call	_stricmp
	test	eax, eax
	jne	$LN3@SetArch

; 118  : 			MODULEARCH = ARCH_AVX;
; 119  : 			ModuleInfo.arch = ARCH_AVX;
; 120  : 			strcpy(MOVE_ALIGNED_FLOAT, "vmovaps");

	mov	rcx, QWORD PTR MOVE_ALIGNED_FLOAT
	mov	rax, QWORD PTR $SG5436
	or	DWORD PTR ModuleInfo+408, 1
	mov	BYTE PTR MODULEARCH, 1
	mov	QWORD PTR [rcx], rax

; 121  : 			strcpy(MOVE_ALIGNED_INT, "vmovdqa");

	mov	rcx, QWORD PTR MOVE_ALIGNED_INT
	mov	rax, QWORD PTR $SG5437

; 122  : 			strcpy(MOVE_UNALIGNED_FLOAT, "vmovups");
; 123  : 			strcpy(MOVE_UNALIGNED_INT, "vmovdqu");
; 124  : 			strcpy(MOVE_SINGLE, "vmovss");

	lea	rdx, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [rcx], rax
	mov	rcx, QWORD PTR MOVE_UNALIGNED_FLOAT
	mov	rax, QWORD PTR $SG5438
	mov	QWORD PTR [rcx], rax
	mov	rcx, QWORD PTR MOVE_UNALIGNED_INT
	mov	rax, QWORD PTR $SG5439
	mov	QWORD PTR [rcx], rax
	mov	eax, DWORD PTR $SG5440[rdx]
	mov	rcx, QWORD PTR MOVE_SINGLE
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG5440[rdx+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR $SG5440[rdx+6]
	mov	BYTE PTR [rcx+6], al

; 125  : 			strcpy(MOVE_DOUBLE, "vmovsd");

	mov	eax, DWORD PTR $SG5441[rdx]
	mov	rcx, QWORD PTR MOVE_DOUBLE
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG5441[rdx+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR $SG5441[rdx+6]
	mov	BYTE PTR [rcx+6], al

; 126  : 			strcpy(MOVE_SIMD_DWORD, "vmovd");

	mov	eax, DWORD PTR $SG5442[rdx]
	mov	rcx, QWORD PTR MOVE_SIMD_DWORD
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG5442[rdx+4]
	mov	WORD PTR [rcx+4], ax

; 127  : 			strcpy(MOVE_SIMD_QWORD, "vmovq");

	mov	eax, DWORD PTR $SG5443[rdx]
	mov	rcx, QWORD PTR MOVE_SIMD_QWORD
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG5443[rdx+4]
	mov	WORD PTR [rcx+4], ax

; 131  : 		}
; 132  : 		DebugMsg1(("SetArch(%s) ok\n", tokenarray[i].string_ptr));
; 133  : 		i++;

	lea	eax, DWORD PTR [rbp+1]

; 137  : 	}
; 138  : 	*pi = i;

	mov	DWORD PTR [rsi], eax

; 139  : 	return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN7@SetArch
$LN3@SetArch:

; 128  : 		}
; 129  : 		else {
; 130  : 			return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos));

	mov	rdx, QWORD PTR [rbx+rdi+24]
	jmp	SHORT $LN9@SetArch
$LN6@SetArch:

; 134  : 	}
; 135  : 	else {
; 136  : 		return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos));

	mov	rdx, QWORD PTR [rbx+rdx+24]
$LN9@SetArch:
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN7@SetArch:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 140  : }

	add	rsp, 40					; 00000028H
	ret	0
SetArch	ENDP
; Function compile flags: /Ogtpy
pi$ = 8
tokenarray$ = 16
SetDotName PROC NEAR

; 146  :     ModuleInfo.dotname = TRUE;

	or	DWORD PTR ModuleInfo+408, 32		; 00000020H

; 147  :     return( NOT_ERROR );

	xor	eax, eax

; 148  : }

	ret	0
SetDotName ENDP
; Function compile flags: /Ogtpy
pi$ = 8
tokenarray$ = 16
SetNoDotName PROC NEAR

; 155  :     ModuleInfo.dotname = FALSE;

	and	DWORD PTR ModuleInfo+408, -33		; ffffffdfH

; 156  :     return( NOT_ERROR );

	xor	eax, eax

; 157  : }

	ret	0
SetNoDotName ENDP
_TEXT	ENDS
EXTRN	SymSetCmpFunc:NEAR
xdata	SEGMENT
$unwind$SetCaseMap DD 091e01H
	DD	09741eH
	DD	086416H
	DD	07540eH
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetCaseMap DD @imagerel(SetCaseMap#)
	DD	@imagerel(SetCaseMap#+251)
	DD	@imagerel($unwind$SetCaseMap#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetCaseMap PROC NEAR

; 163  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp

; 164  :     int i = *pi;

	movsxd	rbp, DWORD PTR [rcx]
	mov	QWORD PTR [rsp+64], rsi

; 165  :     if ( tokenarray[i].token == T_ID ) {

	mov	rbx, rbp
	mov	QWORD PTR [rsp+72], rdi
	shl	rbx, 5
	mov	rdi, rdx
	mov	rsi, rcx
	cmp	BYTE PTR [rbx+rdx], 8
	jne	$LN8@SetCaseMap

; 166  :         if ( 0 == _stricmp( tokenarray[i].string_ptr, "NONE" ) ) {

	mov	rcx, QWORD PTR [rbx+rdi+8]
	lea	rdx, OFFSET FLAT:$SG5467
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN7@SetCaseMap
	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -5					; fffffffbH

; 167  :             ModuleInfo.case_sensitive = TRUE;        /* -Cx */

	or	eax, 2

; 168  :             ModuleInfo.convert_uppercase = FALSE;

	mov	DWORD PTR ModuleInfo+408, eax

; 177  :         }
; 178  :         DebugMsg1(("SetCaseMap(%s) ok\n", tokenarray[i].string_ptr ));
; 179  :         i++;
; 180  :         SymSetCmpFunc();

	call	SymSetCmpFunc
	lea	r11d, DWORD PTR [rbp+1]

; 183  :     }
; 184  :     *pi = i;

	mov	DWORD PTR [rsi], r11d

; 185  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN9@SetCaseMap
$LN7@SetCaseMap:

; 169  :         } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "NOTPUBLIC" ) ) {

	mov	rcx, QWORD PTR [rbx+rdi+8]
	lea	rdx, OFFSET FLAT:$SG5470
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN5@SetCaseMap

; 170  :             ModuleInfo.case_sensitive = FALSE;       /* -Cp */
; 171  :             ModuleInfo.convert_uppercase = FALSE;

	and	DWORD PTR ModuleInfo+408, -7		; fffffff9H

; 177  :         }
; 178  :         DebugMsg1(("SetCaseMap(%s) ok\n", tokenarray[i].string_ptr ));
; 179  :         i++;
; 180  :         SymSetCmpFunc();

	call	SymSetCmpFunc
	lea	r11d, DWORD PTR [rbp+1]

; 183  :     }
; 184  :     *pi = i;

	mov	DWORD PTR [rsi], r11d

; 185  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN9@SetCaseMap
$LN5@SetCaseMap:

; 172  :         } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "ALL" ) ) {

	mov	rcx, QWORD PTR [rbx+rdi+8]
	lea	rdx, OFFSET FLAT:$SG5473
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN3@SetCaseMap

; 173  :             ModuleInfo.case_sensitive = FALSE;       /* -Cu */

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -3					; fffffffdH

; 174  :             ModuleInfo.convert_uppercase = TRUE;

	or	eax, 4
	mov	DWORD PTR ModuleInfo+408, eax

; 177  :         }
; 178  :         DebugMsg1(("SetCaseMap(%s) ok\n", tokenarray[i].string_ptr ));
; 179  :         i++;
; 180  :         SymSetCmpFunc();

	call	SymSetCmpFunc
	lea	r11d, DWORD PTR [rbp+1]

; 183  :     }
; 184  :     *pi = i;

	mov	DWORD PTR [rsi], r11d

; 185  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN9@SetCaseMap
$LN3@SetCaseMap:

; 175  :         } else {
; 176  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rbx+rdi+24]
	jmp	SHORT $LN11@SetCaseMap
$LN8@SetCaseMap:

; 181  :     } else {
; 182  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rbx+rdx+24]
$LN11@SetCaseMap:
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN9@SetCaseMap:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 186  : }

	add	rsp, 40					; 00000028H
	ret	0
SetCaseMap ENDP
_TEXT	ENDS
EXTRN	SetMasm510:NEAR
xdata	SEGMENT
$unwind$SetM510 DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetM510 DD @imagerel(SetM510#)
	DD	@imagerel(SetM510#+18)
	DD	@imagerel($unwind$SetM510#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetM510	PROC NEAR

; 192  : {

	sub	rsp, 40					; 00000028H

; 193  :     SetMasm510( TRUE );

	mov	cl, 1
	call	SetMasm510

; 194  :     return( NOT_ERROR );

	xor	eax, eax

; 195  : }

	add	rsp, 40					; 00000028H
	ret	0
SetM510	ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SetNoM510 DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetNoM510 DD @imagerel(SetNoM510#)
	DD	@imagerel(SetNoM510#+18)
	DD	@imagerel($unwind$SetNoM510#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetNoM510 PROC NEAR

; 201  : {

	sub	rsp, 40					; 00000028H

; 202  :     SetMasm510(FALSE);

	xor	ecx, ecx
	call	SetMasm510

; 203  :     return( NOT_ERROR );

	xor	eax, eax

; 204  : }

	add	rsp, 40					; 00000028H
	ret	0
SetNoM510 ENDP
; Function compile flags: /Ogtpy
pi$ = 8
tokenarray$ = 16
SetScoped PROC NEAR

; 211  :     ModuleInfo.scoped = TRUE;

	bts	DWORD PTR ModuleInfo+408, 8

; 212  :     return( NOT_ERROR );

	xor	eax, eax

; 213  : }

	ret	0
SetScoped ENDP
; Function compile flags: /Ogtpy
pi$ = 8
tokenarray$ = 16
SetNoScoped PROC NEAR

; 220  :     ModuleInfo.scoped = FALSE;

	btr	DWORD PTR ModuleInfo+408, 8

; 221  :     return( NOT_ERROR );

	xor	eax, eax

; 222  : }

	ret	0
SetNoScoped ENDP
; Function compile flags: /Ogtpy
pi$ = 8
tokenarray$ = 16
SetOldStructs PROC NEAR

; 229  :     ModuleInfo.oldstructs = TRUE;

	bts	DWORD PTR ModuleInfo+408, 9

; 230  :     return( NOT_ERROR );

	xor	eax, eax

; 231  : }

	ret	0
SetOldStructs ENDP
; Function compile flags: /Ogtpy
pi$ = 8
tokenarray$ = 16
SetNoOldStructs PROC NEAR

; 238  :     ModuleInfo.oldstructs = FALSE;

	btr	DWORD PTR ModuleInfo+408, 9

; 239  :     return( NOT_ERROR );

	xor	eax, eax

; 240  : }

	ret	0
SetNoOldStructs ENDP
; Function compile flags: /Ogtpy
pi$ = 8
tokenarray$ = 16
SetEmulator PROC NEAR

; 247  :     ModuleInfo.emulator = TRUE;

	bts	DWORD PTR ModuleInfo+408, 10

; 248  :     return( NOT_ERROR );

	xor	eax, eax

; 249  : }

	ret	0
SetEmulator ENDP
; Function compile flags: /Ogtpy
pi$ = 8
tokenarray$ = 16
SetNoEmulator PROC NEAR

; 256  :     ModuleInfo.emulator = FALSE;

	btr	DWORD PTR ModuleInfo+408, 10

; 257  :     return( NOT_ERROR );

	xor	eax, eax

; 258  : }

	ret	0
SetNoEmulator ENDP
; Function compile flags: /Ogtpy
pi$ = 8
tokenarray$ = 16
SetLJmp	PROC NEAR

; 265  :     ModuleInfo.ljmp = TRUE;

	or	DWORD PTR ModuleInfo+408, 64		; 00000040H

; 266  :     return( NOT_ERROR );

	xor	eax, eax

; 267  : }

	ret	0
SetLJmp	ENDP
; Function compile flags: /Ogtpy
pi$ = 8
tokenarray$ = 16
SetNoLJmp PROC NEAR

; 274  :     ModuleInfo.ljmp = FALSE;

	and	DWORD PTR ModuleInfo+408, -65		; ffffffbfH

; 275  :     return( NOT_ERROR );

	xor	eax, eax

; 276  : }

	ret	0
SetNoLJmp ENDP
; Function compile flags: /Ogtpy
pi$ = 8
tokenarray$ = 16
SetNoReadonly PROC NEAR

; 283  :     /* default, nothing to do */
; 284  :     return( NOT_ERROR );

	xor	eax, eax

; 285  : }

	ret	0
SetNoReadonly ENDP
; Function compile flags: /Ogtpy
pi$ = 8
tokenarray$ = 16
SetNoOldmacros PROC NEAR

; 292  :     /* default, nothing to do */
; 293  :     return( NOT_ERROR );

	xor	eax, eax

; 294  : }

	ret	0
SetNoOldmacros ENDP
; Function compile flags: /Ogtpy
pi$ = 8
tokenarray$ = 16
SetExpr32 PROC NEAR

; 301  :     /* default, nothing to do */
; 302  :     return( NOT_ERROR );

	xor	eax, eax

; 303  : }

	ret	0
SetExpr32 ENDP
; Function compile flags: /Ogtpy
pi$ = 8
tokenarray$ = 16
SetNoSignExt PROC NEAR

; 308  :     ModuleInfo.NoSignExtend = TRUE;

	bts	DWORD PTR ModuleInfo+408, 19

; 309  :     return( NOT_ERROR );

	xor	eax, eax

; 310  : }

	ret	0
SetNoSignExt ENDP
; Function compile flags: /Ogtpy
pi$ = 8
tokenarray$ = 16
SkipOption PROC NEAR

; 315  :     while ( tokenarray[*pi].token != T_FINAL &&
; 316  :            tokenarray[*pi].token != T_COMMA )

	movsxd	rax, DWORD PTR [rcx]
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], 0
	je	SHORT $LN1@SkipOption
	npad	3
$LL2@SkipOption:
	movsxd	r8, DWORD PTR [rcx]
	mov	rax, r8
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], 44			; 0000002cH
	je	SHORT $LN1@SkipOption

; 317  :         (*pi)++;

	lea	eax, DWORD PTR [r8+1]
	mov	DWORD PTR [rcx], eax
	cdqe
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], 0
	jne	SHORT $LL2@SkipOption
$LN1@SkipOption:

; 318  : }

	ret	0
SkipOption ENDP
_TEXT	ENDS
EXTRN	IsKeywordDisabled:NEAR
EXTRN	DisableKeyword:NEAR
EXTRN	FindResWord:NEAR
EXTRN	isspace:NEAR
EXTRN	Parse_Pass:DWORD
xdata	SEGMENT
$unwind$SetNoKeyword DD 051501H
	DD	04c415H
	DD	075410H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetNoKeyword DD @imagerel(SetNoKeyword#)
	DD	@imagerel(SetNoKeyword#+127)
	DD	@imagerel($unwind$SetNoKeyword#)
pdata	ENDS
xdata	SEGMENT
$chain$4$SetNoKeyword DD 061721H
	DD	097417H
	DD	08640fH
	DD	063405H
	DD	@imagerel(SetNoKeyword#)
	DD	@imagerel(SetNoKeyword#+127)
	DD	@imagerel($unwind$SetNoKeyword#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$SetNoKeyword DD @imagerel(SetNoKeyword#+127)
	DD	@imagerel(SetNoKeyword#+378)
	DD	@imagerel($chain$4$SetNoKeyword#)
pdata	ENDS
xdata	SEGMENT
$chain$6$SetNoKeyword DD 060021H
	DD	097400H
	DD	086400H
	DD	063400H
	DD	@imagerel(SetNoKeyword#)
	DD	@imagerel(SetNoKeyword#+127)
	DD	@imagerel($unwind$SetNoKeyword#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$SetNoKeyword DD @imagerel(SetNoKeyword#+378)
	DD	@imagerel(SetNoKeyword#+390)
	DD	@imagerel($chain$6$SetNoKeyword#)
pdata	ENDS
xdata	SEGMENT
$chain$7$SetNoKeyword DD 021H
	DD	@imagerel(SetNoKeyword#)
	DD	@imagerel(SetNoKeyword#+127)
	DD	@imagerel($unwind$SetNoKeyword#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$SetNoKeyword DD @imagerel(SetNoKeyword#+390)
	DD	@imagerel(SetNoKeyword#+419)
	DD	@imagerel($chain$7$SetNoKeyword#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetNoKeyword PROC NEAR

; 325  : {

	sub	rsp, 40					; 00000028H

; 326  :     int i = *pi;
; 327  :     //struct ReservedWord *resw;
; 328  :     unsigned index;
; 329  :     char *p;
; 330  : 
; 331  :     if( Parse_Pass != PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+32], r12
	movsxd	r12, DWORD PTR [rcx]
	mov	rbp, rcx
	je	SHORT $LN19@SetNoKeywo

; 332  :         SkipOption( pi, tokenarray );

	mov	rax, r12
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], 0
	je	SHORT $LN37@SetNoKeywo
	npad	6
$LL23@SetNoKeywo:
	movsxd	r8, DWORD PTR [rcx]
	mov	rax, r8
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], 44			; 0000002cH
	je	SHORT $LN37@SetNoKeywo
	lea	eax, DWORD PTR [r8+1]
	mov	DWORD PTR [rcx], eax
	cdqe
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], 0
	jne	SHORT $LL23@SetNoKeywo
$LN37@SetNoKeywo:

; 333  :         return( NOT_ERROR);

	xor	eax, eax
	mov	r12, QWORD PTR [rsp+32]
	mov	rbp, QWORD PTR [rsp+56]

; 367  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN19@SetNoKeywo:

; 334  :     }
; 335  :     if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	mov	rax, r12
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], 9
	jne	$LN17@SetNoKeywo
	cmp	BYTE PTR [rax+rdx+1], 60		; 0000003cH
	jne	$LN17@SetNoKeywo
	mov	QWORD PTR [rsp+48], rbx

; 337  :     }
; 338  :     for ( p = tokenarray[i].string_ptr; *p; ) {

	mov	rbx, QWORD PTR [rax+rdx+8]
	mov	QWORD PTR [rsp+64], rsi
	movzx	eax, BYTE PTR [rbx]
	mov	QWORD PTR [rsp+72], rdi
	test	al, al
	je	$LN15@SetNoKeywo
	npad	2
$LL16@SetNoKeywo:

; 339  :         while ( isspace( *p ) ) p++;

	movsx	ecx, al
	call	isspace
	test	eax, eax
	je	SHORT $LN13@SetNoKeywo
	npad	4
$LL14@SetNoKeywo:
	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL14@SetNoKeywo
$LN13@SetNoKeywo:

; 340  :         if ( *p ) {

	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	SHORT $LN30@SetNoKeywo

; 341  :             char *p2 = p;

	mov	rsi, rbx
	npad	6
$LL11@SetNoKeywo:

; 342  :             unsigned char cnt;
; 343  :             //struct instr_item *instruct;
; 344  :             for ( ;*p; p++ ) {
; 345  :                 if ( isspace( *p ) || *p == ',' )

	movsx	ecx, al
	call	isspace
	test	eax, eax
	jne	SHORT $LN31@SetNoKeywo
	cmp	BYTE PTR [rbx], 44			; 0000002cH
	je	SHORT $LN31@SetNoKeywo
	mov	al, BYTE PTR [rbx+1]
	inc	rbx
	test	al, al
	jne	SHORT $LL11@SetNoKeywo
$LN31@SetNoKeywo:

; 346  :                     break;
; 347  :             }
; 348  :             cnt = p - p2;

	movzx	edi, bl

; 349  :             /* todo: if MAX_ID_LEN can be > 255, then check size,
; 350  :              * since a reserved word's size must be <= 255
; 351  :              */
; 352  :             index = FindResWord( p2, cnt );

	mov	rcx, rsi
	sub	dil, sil
	movzx	edx, dil
	call	FindResWord

; 353  :             if ( index != 0 )

	test	eax, eax
	je	SHORT $LN6@SetNoKeywo

; 354  :                 DisableKeyword( index );

	mov	ecx, eax
	call	DisableKeyword

; 355  :             else {

	jmp	SHORT $LN30@SetNoKeywo
$LN6@SetNoKeywo:

; 356  :                 if ( IsKeywordDisabled( p2, cnt ) ) {

	movzx	edx, dil
	mov	rcx, rsi
	call	IsKeywordDisabled
	test	al, al
	jne	SHORT $LN32@SetNoKeywo
$LN30@SetNoKeywo:

; 358  :                 }
; 359  :             }
; 360  :         }
; 361  :         while ( isspace(*p) ) p++;

	movsx	ecx, BYTE PTR [rbx]
	call	isspace
	test	eax, eax
	je	SHORT $LN2@SetNoKeywo
	npad	10
$LL3@SetNoKeywo:
	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL3@SetNoKeywo
$LN2@SetNoKeywo:

; 362  :         if (*p == ',') p++;

	cmp	BYTE PTR [rbx], 44			; 0000002cH
	jne	SHORT $LN1@SetNoKeywo
	inc	rbx
$LN1@SetNoKeywo:

; 337  :     }
; 338  :     for ( p = tokenarray[i].string_ptr; *p; ) {

	mov	al, BYTE PTR [rbx]
	test	al, al
	jne	$LL16@SetNoKeywo
$LN15@SetNoKeywo:

; 363  :     }
; 364  :     i++;

	lea	eax, DWORD PTR [r12+1]

; 365  :     *pi = i;

	mov	DWORD PTR [rbp], eax

; 366  :     return( NOT_ERROR );

	xor	eax, eax
$LN40@SetNoKeywo:
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+72]
	mov	r12, QWORD PTR [rsp+32]
	mov	rbp, QWORD PTR [rsp+56]

; 367  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN32@SetNoKeywo:

; 357  :                     return( EmitError( RESERVED_WORD_EXPECTED ) );

	mov	ecx, 158				; 0000009eH
	call	EmitError
	jmp	SHORT $LN40@SetNoKeywo
$LN17@SetNoKeywo:

; 336  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rax+rdx+24]
	mov	ecx, 209				; 000000d1H
	mov	r12, QWORD PTR [rsp+32]
	mov	rbp, QWORD PTR [rsp+56]

; 367  : }

	add	rsp, 40					; 00000028H
	jmp	EmitErr
SetNoKeyword ENDP
_TEXT	ENDS
EXTRN	sym_Interface:QWORD
EXTRN	GetLangType:NEAR
xdata	SEGMENT
$unwind$SetLanguage DD 051101H
	DD	097411H
	DD	08340cH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetLanguage DD @imagerel(SetLanguage#)
	DD	@imagerel(SetLanguage#+156)
	DD	@imagerel($unwind$SetLanguage#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
pi$ = 48
tokenarray$ = 56
SetLanguage PROC NEAR

; 373  : {

	sub	rsp, 40					; 00000028H

; 374  :     int i = *pi;

	movsxd	r8, DWORD PTR [rcx]
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi

; 375  :     //lang_type langtype;
; 376  :     //int language = ERROR;
; 377  : 
; 378  :     if ( tokenarray[i].token == T_RES_ID ) {

	mov	rax, r8
	mov	DWORD PTR i$[rsp], r8d
	mov	rdi, rdx
	shl	rax, 5
	mov	rbx, rcx
	cmp	BYTE PTR [rax+rdx], 7
	jne	SHORT $LN2@SetLanguag

; 379  :         if ( GetLangType( &i, tokenarray, &ModuleInfo.langtype ) == NOT_ERROR ) {

	lea	r8, OFFSET FLAT:ModuleInfo+364
	lea	rcx, QWORD PTR i$[rsp]
	call	GetLangType
	test	eax, eax
	jne	SHORT $LN6@SetLanguag

; 380  :             /* update @Interface assembly time variable */
; 381  :             if ( ModuleInfo.model != MODEL_NONE && sym_Interface )

	cmp	DWORD PTR ModuleInfo+360, eax
	je	SHORT $LN1@SetLanguag
	mov	rcx, QWORD PTR sym_Interface
	test	rcx, rcx
	je	SHORT $LN1@SetLanguag

; 382  :                 sym_Interface->value = ModuleInfo.langtype;

	mov	eax, DWORD PTR ModuleInfo+364
	mov	DWORD PTR [rcx+16], eax
$LN1@SetLanguag:

; 383  :             *pi = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR [rbx], eax

; 384  :             return( NOT_ERROR );

	xor	eax, eax
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 388  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@SetLanguag:

; 384  :             return( NOT_ERROR );

	mov	r8d, DWORD PTR i$[rsp]
$LN2@SetLanguag:

; 385  :         }
; 386  :     }
; 387  :     return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rdx, r8d
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+24]
	call	EmitErr
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 388  : }

	add	rsp, 40					; 00000028H
	ret	0
SetLanguage ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SetSetIF2 DD 092501H
	DD	097425H
	DD	086416H
	DD	075411H
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetSetIF2 DD @imagerel(SetSetIF2#)
	DD	@imagerel(SetSetIF2#+131)
	DD	@imagerel($unwind$SetSetIF2#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetSetIF2 PROC NEAR

; 396  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx

; 397  :     int i = *pi;

	movsxd	rbx, DWORD PTR [rcx]
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	rbp, rdx

; 398  : 
; 399  :     if ( 0 == _stricmp( tokenarray[i].string_ptr, "TRUE" ) ) {

	mov	rsi, rbx
	shl	rsi, 5
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx
	mov	rcx, QWORD PTR [rsi+rbp+8]
	lea	rdx, OFFSET FLAT:$SG5620
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN3@SetSetIF2

; 400  :         ModuleInfo.setif2 = TRUE;

	bts	DWORD PTR ModuleInfo+408, 11

; 401  :         i++;

	jmp	SHORT $LN7@SetSetIF2
$LN3@SetSetIF2:

; 402  :     } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "FALSE" ) ) {

	mov	rcx, QWORD PTR [rsi+rbp+8]
	lea	rdx, OFFSET FLAT:$SG5623
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN6@SetSetIF2

; 403  :         ModuleInfo.setif2 = FALSE;

	btr	DWORD PTR ModuleInfo+408, 11
$LN7@SetSetIF2:

; 404  :         i++;

	inc	ebx
$LN6@SetSetIF2:
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]

; 405  :     }
; 406  :     *pi = i;

	mov	DWORD PTR [rdi], ebx
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+48]

; 407  :     return( NOT_ERROR );

	xor	eax, eax

; 408  : }

	add	rsp, 40					; 00000028H
	ret	0
SetSetIF2 ENDP
_TEXT	ENDS
EXTRN	LclAlloc:NEAR
xdata	SEGMENT
$unwind$SetPrologue DD 091801H
	DD	04c418H
	DD	086413H
	DD	07540eH
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetPrologue DD @imagerel(SetPrologue#)
	DD	@imagerel(SetPrologue#+143)
	DD	@imagerel($unwind$SetPrologue#)
pdata	ENDS
xdata	SEGMENT
$chain$4$SetPrologue DD 020521H
	DD	097405H
	DD	@imagerel(SetPrologue#)
	DD	@imagerel(SetPrologue#+143)
	DD	@imagerel($unwind$SetPrologue#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$SetPrologue DD @imagerel(SetPrologue#+143)
	DD	@imagerel(SetPrologue#+192)
	DD	@imagerel($chain$4$SetPrologue#)
pdata	ENDS
xdata	SEGMENT
$chain$5$SetPrologue DD 021H
	DD	@imagerel(SetPrologue#)
	DD	@imagerel(SetPrologue#+143)
	DD	@imagerel($unwind$SetPrologue#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$SetPrologue DD @imagerel(SetPrologue#+192)
	DD	@imagerel(SetPrologue#+243)
	DD	@imagerel($chain$5$SetPrologue#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetPrologue PROC NEAR

; 429  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+32], r12

; 430  :     int i = *pi;

	movsxd	r12, DWORD PTR [rcx]
	mov	rsi, rdx

; 431  : 
; 432  :     if ( tokenarray[i].token != T_ID ) {

	mov	rbx, r12
	mov	rbp, rcx
	shl	rbx, 5
	cmp	BYTE PTR [rbx+rdx], 8
	je	SHORT $LN6@SetPrologu

; 433  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rbx+rdx+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN7@SetPrologu
$LN6@SetPrologu:

; 434  :     }
; 435  :     if ( ModuleInfo.proc_prologue ) {

	mov	QWORD PTR ModuleInfo+320, 0

; 436  :         LclFree( ModuleInfo.proc_prologue );
; 437  :         ModuleInfo.proc_prologue = NULL;
; 438  :     }
; 439  :     if ( 0 == _stricmp( tokenarray[i].string_ptr, "NONE" ) ) {

	mov	rcx, QWORD PTR [rbx+rsi+8]
	lea	rdx, OFFSET FLAT:$SG5635
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN4@SetPrologu

; 440  :         ModuleInfo.prologuemode = PEM_NONE;

	mov	BYTE PTR ModuleInfo+424, 2
	jmp	SHORT $LN1@SetPrologu
$LN4@SetPrologu:

; 441  :     } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "PROLOGUEDEF" ) ) {

	mov	rcx, QWORD PTR [rbx+rsi+8]
	lea	rdx, OFFSET FLAT:$SG5638
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN2@SetPrologu

; 442  :         ModuleInfo.prologuemode = PEM_DEFAULT;

	mov	BYTE PTR ModuleInfo+424, al

; 443  :     } else {

	jmp	SHORT $LN1@SetPrologu
$LN2@SetPrologu:

; 444  :         ModuleInfo.prologuemode = PEM_MACRO;

	mov	BYTE PTR ModuleInfo+424, 1
	mov	QWORD PTR [rsp+72], rdi

; 445  :         ModuleInfo.proc_prologue = LclAlloc( strlen( tokenarray[i].string_ptr ) + 1);

	mov	rdi, QWORD PTR [rbx+rsi+8]
	xor	eax, eax
	mov	rcx, -1
	repne scasb
	not	rcx
	call	LclAlloc
	mov	rdi, QWORD PTR [rsp+72]
	mov	QWORD PTR ModuleInfo+320, rax

; 446  :         strcpy( ModuleInfo.proc_prologue, tokenarray[i].string_ptr );

	mov	rdx, QWORD PTR [rbx+rsi+8]
	npad	3
$LL9@SetPrologu:
	movzx	ecx, BYTE PTR [rdx]
	inc	rax
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL9@SetPrologu
$LN1@SetPrologu:

; 447  :     }
; 448  : 
; 449  :     i++;

	lea	eax, DWORD PTR [r12+1]

; 450  :     *pi = i;

	mov	DWORD PTR [rbp], eax

; 451  :     return( NOT_ERROR );

	xor	eax, eax
$LN7@SetPrologu:
	mov	r12, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 452  : }

	add	rsp, 40					; 00000028H
	ret	0
SetPrologue ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SetEpilogue DD 091801H
	DD	04c418H
	DD	086413H
	DD	07540eH
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetEpilogue DD @imagerel(SetEpilogue#)
	DD	@imagerel(SetEpilogue#+143)
	DD	@imagerel($unwind$SetEpilogue#)
pdata	ENDS
xdata	SEGMENT
$chain$4$SetEpilogue DD 020521H
	DD	097405H
	DD	@imagerel(SetEpilogue#)
	DD	@imagerel(SetEpilogue#+143)
	DD	@imagerel($unwind$SetEpilogue#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$SetEpilogue DD @imagerel(SetEpilogue#+143)
	DD	@imagerel(SetEpilogue#+192)
	DD	@imagerel($chain$4$SetEpilogue#)
pdata	ENDS
xdata	SEGMENT
$chain$5$SetEpilogue DD 021H
	DD	@imagerel(SetEpilogue#)
	DD	@imagerel(SetEpilogue#+143)
	DD	@imagerel($unwind$SetEpilogue#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$SetEpilogue DD @imagerel(SetEpilogue#+192)
	DD	@imagerel(SetEpilogue#+243)
	DD	@imagerel($chain$5$SetEpilogue#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetEpilogue PROC NEAR

; 461  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+32], r12

; 462  :     int i = *pi;

	movsxd	r12, DWORD PTR [rcx]
	mov	rsi, rdx

; 463  : 
; 464  :     if ( tokenarray[i].token != T_ID ) {

	mov	rbx, r12
	mov	rbp, rcx
	shl	rbx, 5
	cmp	BYTE PTR [rbx+rdx], 8
	je	SHORT $LN6@SetEpilogu

; 465  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rbx+rdx+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN7@SetEpilogu
$LN6@SetEpilogu:

; 466  :     }
; 467  :     if ( ModuleInfo.proc_epilogue ) {

	mov	QWORD PTR ModuleInfo+328, 0

; 468  :         LclFree( ModuleInfo.proc_epilogue );
; 469  :         ModuleInfo.proc_epilogue = NULL;
; 470  :     }
; 471  : 
; 472  :     if ( 0 == _stricmp( tokenarray[i].string_ptr, "NONE" ) ) {

	mov	rcx, QWORD PTR [rbx+rsi+8]
	lea	rdx, OFFSET FLAT:$SG5651
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN4@SetEpilogu

; 473  :         ModuleInfo.epiloguemode = PEM_NONE;

	mov	BYTE PTR ModuleInfo+425, 2
	jmp	SHORT $LN1@SetEpilogu
$LN4@SetEpilogu:

; 474  :     } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "EPILOGUEDEF" ) ) {

	mov	rcx, QWORD PTR [rbx+rsi+8]
	lea	rdx, OFFSET FLAT:$SG5654
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN2@SetEpilogu

; 475  :         ModuleInfo.epiloguemode = PEM_DEFAULT;

	mov	BYTE PTR ModuleInfo+425, al

; 476  :     } else {

	jmp	SHORT $LN1@SetEpilogu
$LN2@SetEpilogu:

; 477  :         ModuleInfo.epiloguemode = PEM_MACRO;

	mov	BYTE PTR ModuleInfo+425, 1
	mov	QWORD PTR [rsp+72], rdi

; 478  :         ModuleInfo.proc_epilogue = LclAlloc( strlen( tokenarray[i].string_ptr ) + 1);

	mov	rdi, QWORD PTR [rbx+rsi+8]
	xor	eax, eax
	mov	rcx, -1
	repne scasb
	not	rcx
	call	LclAlloc
	mov	rdi, QWORD PTR [rsp+72]
	mov	QWORD PTR ModuleInfo+328, rax

; 479  :         strcpy( ModuleInfo.proc_epilogue, tokenarray[i].string_ptr );

	mov	rdx, QWORD PTR [rbx+rsi+8]
	npad	3
$LL9@SetEpilogu:
	movzx	ecx, BYTE PTR [rdx]
	inc	rax
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL9@SetEpilogu
$LN1@SetEpilogu:

; 480  :     }
; 481  : 
; 482  :     i++;

	lea	eax, DWORD PTR [r12+1]

; 483  :     *pi = i;

	mov	DWORD PTR [rbp], eax

; 484  :     return( NOT_ERROR );

	xor	eax, eax
$LN7@SetEpilogu:
	mov	r12, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 485  : }

	add	rsp, 40					; 00000028H
	ret	0
SetEpilogue ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SetOffset DD 092101H
	DD	097421H
	DD	086416H
	DD	07540eH
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetOffset DD @imagerel(SetOffset#)
	DD	@imagerel(SetOffset#+196)
	DD	@imagerel($unwind$SetOffset#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetOffset PROC NEAR

; 493  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp

; 494  :     int i = *pi;

	movsxd	rbp, DWORD PTR [rcx]
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, rcx

; 495  : 
; 496  :     if ( 0 == _stricmp( tokenarray[i].string_ptr, "GROUP" ) ) {

	mov	rbx, rbp
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rdx
	shl	rbx, 5
	mov	rcx, QWORD PTR [rbx+rdi+8]
	lea	rdx, OFFSET FLAT:$SG5664
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN6@SetOffset

; 497  :         ModuleInfo.offsettype = OT_GROUP;

	mov	DWORD PTR ModuleInfo+384, eax

; 504  :     }
; 505  :     i++;

	lea	eax, DWORD PTR [rbp+1]

; 506  :     *pi = i;

	mov	DWORD PTR [rsi], eax

; 507  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN7@SetOffset
$LN6@SetOffset:

; 498  :     } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "FLAT" ) ) {

	mov	rcx, QWORD PTR [rbx+rdi+8]
	lea	rdx, OFFSET FLAT:$SG5667
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN4@SetOffset

; 504  :     }
; 505  :     i++;

	lea	eax, DWORD PTR [rbp+1]
	mov	DWORD PTR ModuleInfo+384, 1

; 506  :     *pi = i;

	mov	DWORD PTR [rsi], eax

; 507  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN7@SetOffset
$LN4@SetOffset:

; 499  :         ModuleInfo.offsettype = OT_FLAT;
; 500  :     } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "SEGMENT" ) ) {

	mov	rcx, QWORD PTR [rbx+rdi+8]
	lea	rdx, OFFSET FLAT:$SG5670
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN2@SetOffset

; 504  :     }
; 505  :     i++;

	lea	eax, DWORD PTR [rbp+1]
	mov	DWORD PTR ModuleInfo+384, 2

; 506  :     *pi = i;

	mov	DWORD PTR [rsi], eax

; 507  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN7@SetOffset
$LN2@SetOffset:

; 501  :         ModuleInfo.offsettype = OT_SEGMENT;
; 502  :     } else {
; 503  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rbx+rdi+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN7@SetOffset:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 508  : }

	add	rsp, 40					; 00000028H
	ret	0
SetOffset ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SetProc DD 091b01H
	DD	09741bH
	DD	086416H
	DD	075411H
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetProc DD @imagerel(SetProc#)
	DD	@imagerel(SetProc#+182)
	DD	@imagerel($unwind$SetProc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetProc	PROC NEAR

; 514  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx

; 515  :     int i = *pi;

	movsxd	rbx, DWORD PTR [rcx]
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi

; 516  : 
; 517  :     switch ( tokenarray[i].token ) {

	mov	rdi, rbx
	shl	rdi, 5
	mov	rsi, rdx
	mov	rbp, rcx
	mov	al, BYTE PTR [rdi+rdx]
	cmp	al, 3
	je	SHORT $LN2@SetProc
	cmp	al, 8
	jne	SHORT $LN1@SetProc

; 518  :     case T_ID:
; 519  :         if ( 0 == _stricmp( tokenarray[i].string_ptr, "PRIVATE" ) ) {

	mov	rcx, QWORD PTR [rdi+rsi+8]
	lea	rdx, OFFSET FLAT:$SG5685
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN5@SetProc
	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -17				; ffffffefH

; 520  :             ModuleInfo.procs_private = TRUE;

	or	eax, 8

; 521  :             ModuleInfo.procs_export = FALSE;

	mov	DWORD PTR ModuleInfo+408, eax

; 522  :             i++;

	jmp	SHORT $LN11@SetProc
$LN5@SetProc:

; 523  :         } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "EXPORT" ) ) {

	mov	rcx, QWORD PTR [rdi+rsi+8]
	lea	rdx, OFFSET FLAT:$SG5688
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN1@SetProc

; 524  :             ModuleInfo.procs_private = FALSE;

	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -9					; fffffff7H

; 525  :             ModuleInfo.procs_export = TRUE;

	or	eax, 16
	mov	DWORD PTR ModuleInfo+408, eax

; 526  :             i++;
; 527  :         }
; 528  :         break;

	jmp	SHORT $LN11@SetProc
$LN2@SetProc:

; 529  :     case T_DIRECTIVE: /* word PUBLIC is a directive */
; 530  :         if ( tokenarray[i].tokval == T_PUBLIC ) {

	cmp	DWORD PTR [rdi+rdx+16], 431		; 000001afH
	jne	SHORT $LN1@SetProc

; 531  :             ModuleInfo.procs_private = FALSE;
; 532  :             ModuleInfo.procs_export = FALSE;

	and	DWORD PTR ModuleInfo+408, -25		; ffffffe7H
$LN11@SetProc:

; 533  :             i++;

	inc	ebx
$LN1@SetProc:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]

; 534  :         }
; 535  :         break;
; 536  :     }
; 537  :     *pi = i;

	mov	DWORD PTR [rbp], ebx
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 538  :     return( NOT_ERROR );

	xor	eax, eax

; 539  : }

	add	rsp, 40					; 00000028H
	ret	0
SetProc	ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SetSegment DD 091e01H
	DD	09741eH
	DD	086416H
	DD	07540eH
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetSegment DD @imagerel(SetSegment#)
	DD	@imagerel(SetSegment#+261)
	DD	@imagerel($unwind$SetSegment#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetSegment PROC NEAR

; 548  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp

; 549  :     int i = *pi;

	movsxd	rbp, DWORD PTR [rcx]
	mov	QWORD PTR [rsp+64], rsi

; 550  : 
; 551  :     if ( tokenarray[i].token == T_RES_ID && tokenarray[i].tokval == T_FLAT ) {

	mov	rbx, rbp
	mov	QWORD PTR [rsp+72], rdi
	shl	rbx, 5
	mov	rdi, rdx
	mov	rsi, rcx
	movzx	eax, BYTE PTR [rbx+rdx]
	cmp	al, 7
	jne	SHORT $LN10@SetSegment
	cmp	DWORD PTR [rbx+rdx+16], 261		; 00000105H
	jne	SHORT $LN10@SetSegment

; 552  : #if AMD64_SUPPORT
; 553  :         if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_64 )

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 112				; 00000070H
	setge	al
	inc	al
	mov	BYTE PTR ModuleInfo+405, al

; 568  :     }
; 569  :     i++;

	lea	eax, DWORD PTR [rbp+1]

; 570  :     *pi = i;

	mov	DWORD PTR [rcx], eax

; 571  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN11@SetSegment
$LN10@SetSegment:

; 554  :             ModuleInfo.defOfssize = USE64;
; 555  :         else
; 556  : #endif
; 557  :             ModuleInfo.defOfssize = USE32;
; 558  :     } else if ( tokenarray[i].token == T_ID && _stricmp( tokenarray[i].string_ptr, "USE16" ) == 0) {

	cmp	al, 8
	jne	SHORT $LN6@SetSegment
	mov	rcx, QWORD PTR [rbx+rdi+8]
	lea	rdx, OFFSET FLAT:$SG5703
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN6@SetSegment

; 559  :         ModuleInfo.defOfssize = USE16;

	mov	BYTE PTR ModuleInfo+405, al

; 568  :     }
; 569  :     i++;

	lea	eax, DWORD PTR [rbp+1]

; 570  :     *pi = i;

	mov	DWORD PTR [rsi], eax

; 571  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN11@SetSegment
$LN6@SetSegment:

; 560  :     } else if ( tokenarray[i].token == T_ID && _stricmp( tokenarray[i].string_ptr, "USE32" ) == 0) {

	cmp	BYTE PTR [rbx+rdi], 8
	jne	SHORT $LN4@SetSegment
	mov	rcx, QWORD PTR [rbx+rdi+8]
	lea	rdx, OFFSET FLAT:$SG5706
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN4@SetSegment

; 568  :     }
; 569  :     i++;

	lea	eax, DWORD PTR [rbp+1]
	mov	BYTE PTR ModuleInfo+405, 1

; 570  :     *pi = i;

	mov	DWORD PTR [rsi], eax

; 571  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN11@SetSegment
$LN4@SetSegment:

; 561  :         ModuleInfo.defOfssize = USE32;
; 562  : #if AMD64_SUPPORT
; 563  :     } else if ( tokenarray[i].token == T_ID && _stricmp( tokenarray[i].string_ptr, "USE64" ) == 0) {

	cmp	BYTE PTR [rbx+rdi], 8
	jne	SHORT $LN2@SetSegment
	mov	rcx, QWORD PTR [rbx+rdi+8]
	lea	rdx, OFFSET FLAT:$SG5709
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN2@SetSegment

; 568  :     }
; 569  :     i++;

	lea	eax, DWORD PTR [rbp+1]
	mov	BYTE PTR ModuleInfo+405, 2

; 570  :     *pi = i;

	mov	DWORD PTR [rsi], eax

; 571  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN11@SetSegment
$LN2@SetSegment:

; 564  :         ModuleInfo.defOfssize = USE64;
; 565  : #endif
; 566  :     } else {
; 567  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rbx+rdi+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN11@SetSegment:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 572  : }

	add	rsp, 40					; 00000028H
	ret	0
SetSegment ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SetFieldAlign DD 030c01H
	DD	014010cH
	DD	03002H
xdata	ENDS
pdata	SEGMENT
$pdata$SetFieldAlign DD @imagerel(SetFieldAlign#)
	DD	@imagerel(SetFieldAlign#+183)
	DD	@imagerel($unwind$SetFieldAlign#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
opndx$ = 48
i$ = 176
pi$ = 176
tokenarray$ = 184
SetFieldAlign PROC NEAR

; 579  : {

	push	rbx
	mov	r11, rsp
	sub	rsp, 160				; 000000a0H

; 580  :     int i = *pi;

	mov	eax, DWORD PTR [rcx]

; 581  :     unsigned temp, temp2;
; 582  :     struct expr opndx;
; 583  : 
; 584  :     if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rbx, rcx
	lea	r9, QWORD PTR [r11-112]
	lea	rcx, QWORD PTR [r11+16]
	mov	BYTE PTR [rsp+32], 2
	mov	DWORD PTR [r11+16], eax
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN7@SetFieldAl

; 599  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN7@SetFieldAl:

; 585  :         return( ERROR );
; 586  :     if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN6@SetFieldAl

; 587  :         return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 599  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN6@SetFieldAl:

; 588  :     }
; 589  :     if( opndx.uvalue > MAX_STRUCT_ALIGN ) {

	mov	edx, DWORD PTR opndx$[rsp]
	cmp	edx, 32					; 00000020H
	jbe	SHORT $LN5@SetFieldAl

; 590  :         return( EmitError( STRUCT_ALIGN_TOO_HIGH ) );

	mov	ecx, 214				; 000000d6H
	call	EmitError

; 599  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN5@SetFieldAl:

; 591  :     }
; 592  :     for( temp = 1, temp2 = 0; temp < opndx.uvalue ; temp <<= 1, temp2++ );

	mov	eax, 1
	xor	ecx, ecx
	cmp	eax, edx
	jae	SHORT $LN12@SetFieldAl
	npad	3
$LL4@SetFieldAl:
	add	eax, eax
	inc	ecx
	cmp	eax, edx
	jb	SHORT $LL4@SetFieldAl
$LN12@SetFieldAl:

; 593  :     if( temp != opndx.uvalue ) {

	je	SHORT $LN1@SetFieldAl

; 594  :         return( EmitErr( POWER_OF_2, opndx.value ) );

	mov	ecx, 129				; 00000081H
	call	EmitErr

; 599  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN1@SetFieldAl:

; 595  :     }
; 596  :     ModuleInfo.fieldalign = temp2;
; 597  :     *pi = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	BYTE PTR ModuleInfo+397, cl
	mov	DWORD PTR [rbx], eax

; 598  :     return( NOT_ERROR );

	xor	eax, eax

; 599  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
SetFieldAlign ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SetProcAlign DD 030c01H
	DD	014010cH
	DD	03002H
xdata	ENDS
pdata	SEGMENT
$pdata$SetProcAlign DD @imagerel(SetProcAlign#)
	DD	@imagerel(SetProcAlign#+175)
	DD	@imagerel($unwind$SetProcAlign#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
opndx$ = 48
i$ = 176
pi$ = 176
tokenarray$ = 184
SetProcAlign PROC NEAR

; 607  : {

	push	rbx
	mov	r11, rsp
	sub	rsp, 160				; 000000a0H

; 608  :     int i = *pi;

	mov	eax, DWORD PTR [rcx]

; 609  :     int temp, temp2;
; 610  :     struct expr opndx;
; 611  : 
; 612  :     if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rbx, rcx
	lea	r9, QWORD PTR [r11-112]
	lea	rcx, QWORD PTR [r11+16]
	mov	BYTE PTR [rsp+32], 2
	mov	DWORD PTR [r11+16], eax
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN7@SetProcAli

; 627  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN7@SetProcAli:

; 613  :         return( ERROR );
; 614  :     if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN6@SetProcAli

; 615  :         return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 627  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN6@SetProcAli:

; 616  :     }
; 617  :     if( opndx.value > MAX_STRUCT_ALIGN ) {

	mov	edx, DWORD PTR opndx$[rsp]
	cmp	edx, 32					; 00000020H
	jle	SHORT $LN5@SetProcAli

; 618  :         EmitError( STRUCT_ALIGN_TOO_HIGH );

	mov	ecx, 214				; 000000d6H
	call	EmitError
	mov	edx, DWORD PTR opndx$[rsp]
$LN5@SetProcAli:

; 619  :     }
; 620  :     for( temp = 1, temp2 = 0; temp < opndx.value ; temp <<= 1, temp2++ );

	mov	eax, 1
	xor	ecx, ecx
	cmp	eax, edx
	jge	SHORT $LN12@SetProcAli
$LL4@SetProcAli:
	add	eax, eax
	inc	ecx
	cmp	eax, edx
	jl	SHORT $LL4@SetProcAli
$LN12@SetProcAli:

; 621  :     if( temp != opndx.value ) {

	je	SHORT $LN1@SetProcAli

; 622  :         return( EmitErr( POWER_OF_2, opndx.value ) );

	mov	ecx, 129				; 00000081H
	call	EmitErr

; 627  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN1@SetProcAli:

; 623  :     }
; 624  :     ModuleInfo.procalign = temp2;
; 625  :     *pi = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	BYTE PTR ModuleInfo+399, cl
	mov	DWORD PTR [rbx], eax

; 626  :     return( NOT_ERROR );

	xor	eax, eax

; 627  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
SetProcAlign ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SetMZ DD 0a1d01H
	DD	01b741dH
	DD	01a6419H
	DD	0195415H
	DD	0183411H
	DD	017010aH
xdata	ENDS
pdata	SEGMENT
$pdata$SetMZ DD	@imagerel(SetMZ#)
	DD	@imagerel(SetMZ#+433)
	DD	@imagerel($unwind$SetMZ#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
opndx$ = 64
pi$ = 192
tokenarray$ = 200
SetMZ	PROC NEAR

; 633  : {

	mov	rax, rsp
	sub	rsp, 184				; 000000b8H

; 634  :     int i = *pi;

	mov	r8d, DWORD PTR [rcx]
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	lea	rbx, OFFSET FLAT:ModuleInfo+412
	mov	DWORD PTR i$[rsp], r8d
	mov	rdi, rdx
	mov	rsi, rcx
	lea	rbp, OFFSET FLAT:ModuleInfo+420
	npad	10
$LL25@SetMZ:

; 635  :     int j;
; 636  :     uint_16 *parms;
; 637  :     struct expr opndx;
; 638  : 
; 639  :     for ( j = 0, parms = (uint_16 *)&ModuleInfo.mz_data ; j < 4; j++ ) {
; 640  :         int k;
; 641  :         for ( k = i; tokenarray[k].token != T_FINAL; k++ )

	movsxd	rax, r8d
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 0
	je	SHORT $LN38@SetMZ
	lea	rcx, QWORD PTR [rax+rdi]
	movzx	eax, BYTE PTR [rax+rdi]
$LL22@SetMZ:

; 642  :             if ( tokenarray[k].token == T_COMMA ||
; 643  :                 tokenarray[k].token == T_COLON ||
; 644  :                 tokenarray[k].token == T_DBL_COLON )

	cmp	al, 44					; 0000002cH
	je	SHORT $LN38@SetMZ
	cmp	al, 58					; 0000003aH
	je	SHORT $LN38@SetMZ
	cmp	al, 13
	je	SHORT $LN38@SetMZ
	mov	al, BYTE PTR [rcx+32]
	add	rcx, 32					; 00000020H
	inc	r8d
	test	al, al
	jne	SHORT $LL22@SetMZ
$LN38@SetMZ:

; 645  :                 break;
; 646  :         if ( EvalOperand( &i, tokenarray, k, &opndx, 0 ) == ERROR )

	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rdi
	mov	BYTE PTR [rsp+32], 0
	call	EvalOperand
	cmp	eax, -1
	je	$LN32@SetMZ

; 648  :         if ( opndx.kind == EXPR_EMPTY ) {

	mov	eax, DWORD PTR opndx$[rsp+60]
	cmp	eax, -2
	je	SHORT $LN37@SetMZ

; 649  :         } else if ( opndx.kind == EXPR_CONST ) {

	test	eax, eax
	jne	$LN14@SetMZ

; 650  :             if ( opndx.value64 > 0xFFFF ) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	rax, 65535				; 0000ffffH
	jg	$LN33@SetMZ

; 652  :             }
; 653  :             if ( ModuleInfo.sub_format == SFORMAT_MZ )

	cmp	DWORD PTR ModuleInfo+372, 1
	jne	SHORT $LN37@SetMZ

; 654  :                 *(parms + j) = opndx.value;

	mov	WORD PTR [rbx], ax
$LN37@SetMZ:

; 657  :         }
; 658  :         if ( tokenarray[i].token == T_COLON )

	movsxd	r8, DWORD PTR i$[rsp]
	mov	rax, r8
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+rdi]
	cmp	cl, 58					; 0000003aH
	jne	SHORT $LN10@SetMZ

; 659  :             i++;

	inc	r8d
	mov	DWORD PTR i$[rsp], r8d
	jmp	SHORT $LN24@SetMZ
$LN10@SetMZ:

; 660  :         else if ( tokenarray[i].token == T_DBL_COLON ) {

	cmp	cl, 13
	jne	SHORT $LN24@SetMZ

; 661  :             i++;

	inc	r8d

; 662  :             j++;

	add	rbx, 2
	mov	DWORD PTR i$[rsp], r8d
$LN24@SetMZ:
	add	rbx, 2
	cmp	rbx, rbp
	jl	$LL25@SetMZ

; 663  :         }
; 664  :     }
; 665  : 
; 666  :     /* ensure data integrity of the params */
; 667  :     if ( ModuleInfo.sub_format == SFORMAT_MZ ) {

	cmp	DWORD PTR ModuleInfo+372, 1
	jne	SHORT $LN1@SetMZ

; 668  :         if ( ModuleInfo.mz_data.ofs_fixups < 0x1E )

	movzx	eax, WORD PTR ModuleInfo+412
	mov	ecx, 30
	cmp	ax, cx
	cmovb	ax, cx
	movzx	ecx, WORD PTR ModuleInfo+414
	mov	WORD PTR ModuleInfo+412, ax

; 669  :             ModuleInfo.mz_data.ofs_fixups = 0x1E;
; 670  : 
; 671  :         for( j = 16; j < ModuleInfo.mz_data.alignment; j <<= 1 );

	mov	eax, 16
	cmp	ecx, eax
	jle	SHORT $LN3@SetMZ
	npad	3
$LL5@SetMZ:
	add	eax, eax
	cmp	eax, ecx
	jl	SHORT $LL5@SetMZ
$LN3@SetMZ:

; 672  :         if( j != ModuleInfo.mz_data.alignment )

	cmp	eax, ecx
	je	SHORT $LN2@SetMZ

; 673  :             EmitError( INVALID_HEADER_ALIGNMENT );

	mov	ecx, 205				; 000000cdH
	call	EmitError
	mov	r8d, DWORD PTR i$[rsp]
$LN2@SetMZ:

; 674  : 
; 675  :         if ( ModuleInfo.mz_data.heapmax < ModuleInfo.mz_data.heapmin )

	movzx	ecx, WORD PTR ModuleInfo+418
	movzx	eax, WORD PTR ModuleInfo+416
	cmp	cx, ax
	cmovb	cx, ax
	mov	WORD PTR ModuleInfo+418, cx
$LN1@SetMZ:

; 676  :             ModuleInfo.mz_data.heapmax = ModuleInfo.mz_data.heapmin;
; 677  :     }
; 678  :     *pi = i;

	mov	DWORD PTR [rsi], r8d

; 679  :     return( NOT_ERROR );

	xor	eax, eax
$LN26@SetMZ:
	mov	rdi, QWORD PTR [rsp+216]
	mov	rsi, QWORD PTR [rsp+208]
	mov	rbp, QWORD PTR [rsp+200]
	mov	rbx, QWORD PTR [rsp+192]

; 680  : }

	add	rsp, 184				; 000000b8H
	ret	0
$LN32@SetMZ:

; 647  :             return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN26@SetMZ
$LN33@SetMZ:

; 651  :                 return( EmitConstError( &opndx ) );

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError
	jmp	SHORT $LN26@SetMZ
$LN14@SetMZ:

; 655  :         } else {
; 656  :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	SHORT $LN26@SetMZ
SetMZ	ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SetFrame DD 092501H
	DD	097425H
	DD	086416H
	DD	075411H
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetFrame DD @imagerel(SetFrame#)
	DD	@imagerel(SetFrame#+131)
	DD	@imagerel($unwind$SetFrame#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetFrame PROC NEAR

; 689  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx

; 690  :     int i = *pi;

	movsxd	rbx, DWORD PTR [rcx]
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	rbp, rdx

; 691  : 
; 692  :     if ( 0 == _stricmp( tokenarray[i].string_ptr, "AUTO" ) ) {

	mov	rsi, rbx
	shl	rsi, 5
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx
	mov	rcx, QWORD PTR [rsi+rbp+8]
	lea	rdx, OFFSET FLAT:$SG5790
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN3@SetFrame

; 693  :         ModuleInfo.frame_auto = 1;

	bts	DWORD PTR ModuleInfo+408, 18

; 694  :         i++;

	jmp	SHORT $LN7@SetFrame
$LN3@SetFrame:

; 695  :     } else if ( 0 == _stricmp( tokenarray[i].string_ptr, "NOAUTO" ) ) {

	mov	rcx, QWORD PTR [rsi+rbp+8]
	lea	rdx, OFFSET FLAT:$SG5793
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN6@SetFrame

; 696  :         ModuleInfo.frame_auto = 0;

	btr	DWORD PTR ModuleInfo+408, 18
$LN7@SetFrame:

; 697  :         i++;

	inc	ebx
$LN6@SetFrame:
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]

; 698  :     }
; 699  :     *pi = i;

	mov	DWORD PTR [rdi], ebx
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+48]

; 700  :     return( NOT_ERROR );

	xor	eax, eax

; 701  : }

	add	rsp, 40					; 00000028H
	ret	0
SetFrame ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SetSwitchStile DD 092501H
	DD	097425H
	DD	086416H
	DD	075411H
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetSwitchStile DD @imagerel(SetSwitchStile#)
	DD	@imagerel(SetSwitchStile#+131)
	DD	@imagerel($unwind$SetSwitchStile#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetSwitchStile PROC NEAR

; 705  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx

; 706  :   int i = *pi;

	movsxd	rbx, DWORD PTR [rcx]
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	rbp, rdx

; 707  : 
; 708  :   if (0 == _stricmp(tokenarray[i].string_ptr, "CSTYLE")) {

	mov	rsi, rbx
	shl	rsi, 5
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx
	mov	rcx, QWORD PTR [rsi+rbp+8]
	lea	rdx, OFFSET FLAT:$SG5802
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN3@SetSwitchS

; 709  :     ModuleInfo.switch_style = 1;

	bts	DWORD PTR ModuleInfo+408, 20

; 710  :     i++;

	jmp	SHORT $LN7@SetSwitchS
$LN3@SetSwitchS:

; 711  :   }
; 712  :   else if (0 == _stricmp(tokenarray[i].string_ptr, "ASMSTYLE")) {

	mov	rcx, QWORD PTR [rsi+rbp+8]
	lea	rdx, OFFSET FLAT:$SG5805
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN6@SetSwitchS

; 713  :     ModuleInfo.switch_style = 0;

	btr	DWORD PTR ModuleInfo+408, 20
$LN7@SetSwitchS:

; 714  :     i++;

	inc	ebx
$LN6@SetSwitchS:
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]

; 715  :     }
; 716  :   *pi = i;

	mov	DWORD PTR [rdi], ebx
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+48]

; 717  :   return(NOT_ERROR);

	xor	eax, eax

; 718  : }

	add	rsp, 40					; 00000028H
	ret	0
SetSwitchStile ENDP
_TEXT	ENDS
EXTRN	Options:BYTE
xdata	SEGMENT
$unwind$SetElf DD 030c01H
	DD	014010cH
	DD	03002H
xdata	ENDS
pdata	SEGMENT
$pdata$SetElf DD @imagerel(SetElf#)
	DD	@imagerel(SetElf#+164)
	DD	@imagerel($unwind$SetElf#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
opndx$ = 48
i$ = 176
pi$ = 176
tokenarray$ = 184
SetElf	PROC NEAR

; 723  :   {

	push	rbx
	mov	r11, rsp
	sub	rsp, 160				; 000000a0H

; 724  :   int i = *pi;

	mov	eax, DWORD PTR [rcx]

; 725  :   struct expr opndx;
; 726  : 
; 727  :   if (EvalOperand(&i, tokenarray, Token_Count, &opndx, 0) == ERROR)

	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rbx, rcx
	lea	r9, QWORD PTR [r11-112]
	lea	rcx, QWORD PTR [r11+16]
	mov	BYTE PTR [rsp+32], 0
	mov	DWORD PTR [r11+16], eax
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN5@SetElf

; 741  :   }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN5@SetElf:

; 728  :     return(ERROR);
; 729  :   if (opndx.kind == EXPR_CONST) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN4@SetElf

; 730  :     if (opndx.llvalue > 0xFF) {

	mov	rax, QWORD PTR opndx$[rsp]
	cmp	rax, 255				; 000000ffH
	jbe	SHORT $LN3@SetElf

; 731  :       return(EmitConstError(&opndx));

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError

; 741  :   }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN3@SetElf:

; 732  :       }
; 733  :     if (Options.output_format == OFORMAT_ELF)

	movzx	ecx, BYTE PTR ModuleInfo+412
	cmp	DWORD PTR Options+156, 3
	movzx	eax, al
	cmove	ecx, eax

; 738  :     }
; 739  :   *pi = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	BYTE PTR ModuleInfo+412, cl
	mov	DWORD PTR [rbx], eax

; 740  :   return(NOT_ERROR);

	xor	eax, eax

; 741  :   }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN4@SetElf:

; 734  :       ModuleInfo.elf_osabi = opndx.value;
; 735  :     }
; 736  :   else {
; 737  :     return(EmitError(CONSTANT_EXPECTED));

	mov	ecx, 65					; 00000041H
	call	EmitError

; 741  :   }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
SetElf	ENDP
_TEXT	ENDS
EXTRN	RenameKeyword:NEAR
xdata	SEGMENT
$unwind$SetRenameKey DD 071901H
	DD	04c419H
	DD	086411H
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetRenameKey DD @imagerel(SetRenameKey#)
	DD	@imagerel(SetRenameKey#+93)
	DD	@imagerel($unwind$SetRenameKey#)
pdata	ENDS
xdata	SEGMENT
$chain$3$SetRenameKey DD 020521H
	DD	075405H
	DD	@imagerel(SetRenameKey#)
	DD	@imagerel(SetRenameKey#+93)
	DD	@imagerel($unwind$SetRenameKey#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$SetRenameKey DD @imagerel(SetRenameKey#+93)
	DD	@imagerel(SetRenameKey#+128)
	DD	@imagerel($chain$3$SetRenameKey#)
pdata	ENDS
xdata	SEGMENT
$chain$4$SetRenameKey DD 020521H
	DD	097405H
	DD	@imagerel(SetRenameKey#+93)
	DD	@imagerel(SetRenameKey#+128)
	DD	@imagerel($chain$3$SetRenameKey#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$SetRenameKey DD @imagerel(SetRenameKey#+128)
	DD	@imagerel(SetRenameKey#+184)
	DD	@imagerel($chain$4$SetRenameKey#)
pdata	ENDS
xdata	SEGMENT
$chain$5$SetRenameKey DD 021H
	DD	@imagerel(SetRenameKey#+93)
	DD	@imagerel(SetRenameKey#+128)
	DD	@imagerel($chain$3$SetRenameKey#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$SetRenameKey DD @imagerel(SetRenameKey#+184)
	DD	@imagerel(SetRenameKey#+209)
	DD	@imagerel($chain$5$SetRenameKey#)
pdata	ENDS
xdata	SEGMENT
$chain$7$SetRenameKey DD 040021H
	DD	097400H
	DD	075400H
	DD	@imagerel(SetRenameKey#)
	DD	@imagerel(SetRenameKey#+93)
	DD	@imagerel($unwind$SetRenameKey#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$SetRenameKey DD @imagerel(SetRenameKey#+209)
	DD	@imagerel(SetRenameKey#+254)
	DD	@imagerel($chain$7$SetRenameKey#)
pdata	ENDS
xdata	SEGMENT
$chain$8$SetRenameKey DD 021H
	DD	@imagerel(SetRenameKey#)
	DD	@imagerel(SetRenameKey#+93)
	DD	@imagerel($unwind$SetRenameKey#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$SetRenameKey DD @imagerel(SetRenameKey#+254)
	DD	@imagerel(SetRenameKey#+288)
	DD	@imagerel($chain$8$SetRenameKey#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetRenameKey PROC NEAR

; 750  :   {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	rbx, rdx
	mov	QWORD PTR [rsp+64], rsi

; 751  :   int i = *pi;

	movsxd	rsi, DWORD PTR [rcx]
	mov	QWORD PTR [rsp+32], r12
	mov	r12, rcx

; 752  :   //struct ReservedWord *resw;
; 753  :   unsigned index;
; 754  :   char *oldname;
; 755  : 
; 756  : #if 0 /* v2.11: allow temporary renaming of keywords */
; 757  :   /* do nothing if pass > 1 */
; 758  :   if( Parse_Pass != PASS_1 ) {
; 759  :     SkipOption( pi, tokenarray );
; 760  :     return( NOT_ERROR );
; 761  :     }
; 762  : #endif
; 763  :   if (tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<')  {

	mov	rdx, rsi
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbx], 9
	jne	$LN5@SetRenameK
	cmp	BYTE PTR [rdx+rbx+1], 60		; 0000003cH
	jne	$LN5@SetRenameK

; 765  :     }
; 766  :   oldname = tokenarray[i].string_ptr;

	mov	r8, QWORD PTR [rdx+rbx+8]

; 767  :   i++;

	inc	esi

; 768  :   /* v2.06: syntax changed */
; 769  :   //if ( tokenarray[i].token != T_COMMA ) {
; 770  :   if (tokenarray[i].token != T_DIRECTIVE || tokenarray[i].dirtype != DRT_EQUALSGN) {

	movsxd	rdx, esi
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbx], 3
	jne	$LN5@SetRenameK
	cmp	BYTE PTR [rdx+rbx+1], 48		; 00000030H
	jne	$LN5@SetRenameK

; 771  :     //EmitError( EXPECTING_COMMA );
; 772  :     return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos));
; 773  :     }
; 774  :   i++;

	inc	esi
	mov	QWORD PTR [rsp+56], rbp

; 775  :   if (tokenarray[i].token != T_ID)  {

	movsxd	rbp, esi
	shl	rbp, 5
	cmp	BYTE PTR [rbx+rbp], 8
	je	SHORT $LN2@SetRenameK

; 776  :     return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos));

	mov	rdx, QWORD PTR [rbx+rbp+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN9@SetRenameK
$LN2@SetRenameK:
	mov	QWORD PTR [rsp+72], rdi

; 777  :     }
; 778  : 
; 779  :   /* todo: if MAX_ID_LEN can be > 255, then check size,
; 780  :    * since a reserved word's size must be <= 255 */
; 781  :   index = FindResWord(oldname, strlen(oldname));

	xor	eax, eax
	mov	rdi, r8
	mov	rcx, -1
	repne scasb
	not	rcx
	lea	rdx, QWORD PTR [rcx-1]
	mov	rcx, r8
	call	FindResWord

; 782  :   if (index == 0) {

	test	eax, eax
	mov	r11d, eax
	jne	SHORT $LN1@SetRenameK

; 783  :     return(EmitError(RESERVED_WORD_EXPECTED));

	mov	ecx, 158				; 0000009eH
	call	EmitError
$LN10@SetRenameK:
	mov	rdi, QWORD PTR [rsp+72]
$LN9@SetRenameK:
	mov	rbp, QWORD PTR [rsp+56]
	mov	r12, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]

; 789  :   }

	add	rsp, 40					; 00000028H
	ret	0
$LN1@SetRenameK:

; 784  :     }
; 785  :   RenameKeyword(index, tokenarray[i].string_ptr, strlen(tokenarray[i].string_ptr));

	mov	rdx, QWORD PTR [rbx+rbp+8]
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rdx
	repne scasb
	not	rcx
	lea	r8, QWORD PTR [rcx-1]
	mov	ecx, r11d
	call	RenameKeyword

; 786  :   i++;

	lea	edx, DWORD PTR [rsi+1]

; 787  :   *pi = i;
; 788  :   return(NOT_ERROR);

	xor	eax, eax
	mov	DWORD PTR [r12], edx
	jmp	SHORT $LN10@SetRenameK
$LN5@SetRenameK:

; 764  :     return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos));

	mov	rdx, QWORD PTR [rdx+rbx+24]
	mov	ecx, 209				; 000000d1H
	mov	r12, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]

; 789  :   }

	add	rsp, 40					; 00000028H
	jmp	EmitErr
SetRenameKey ENDP
_TEXT	ENDS
EXTRN	CreateVariable:NEAR
EXTRN	UpdateProcStatus:NEAR
EXTRN	UpdateStackBase:NEAR
xdata	SEGMENT
$unwind$SetWin64 DD 041901H
	DD	0183419H
	DD	0170107H
xdata	ENDS
pdata	SEGMENT
$pdata$SetWin64 DD @imagerel(SetWin64#)
	DD	@imagerel(SetWin64#+199)
	DD	@imagerel($unwind$SetWin64#)
pdata	ENDS
xdata	SEGMENT
$chain$3$SetWin64 DD 061821H
	DD	01b7418H
	DD	01a6410H
	DD	0195408H
	DD	@imagerel(SetWin64#)
	DD	@imagerel(SetWin64#+199)
	DD	@imagerel($unwind$SetWin64#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$SetWin64 DD @imagerel(SetWin64#+199)
	DD	@imagerel(SetWin64#+555)
	DD	@imagerel($chain$3$SetWin64#)
pdata	ENDS
xdata	SEGMENT
$chain$4$SetWin64 DD 021H
	DD	@imagerel(SetWin64#)
	DD	@imagerel(SetWin64#+199)
	DD	@imagerel($unwind$SetWin64#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$SetWin64 DD @imagerel(SetWin64#+555)
	DD	@imagerel(SetWin64#+581)
	DD	@imagerel($chain$4$SetWin64#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
opndx$ = 64
pi$ = 192
tokenarray$ = 200
SetWin64 PROC NEAR

; 795  :   {

	sub	rsp, 184				; 000000b8H

; 796  :   int i = *pi;
; 797  :   struct expr opndx;
; 798  : 
; 799  :   /* if -win64 isn't set, skip the option */
; 800  :   /* v2.09: skip option if Ofssize != USE64 */
; 801  :   if (ModuleInfo.defOfssize != USE64) {

	cmp	BYTE PTR ModuleInfo+405, 2
	movsxd	rax, DWORD PTR [rcx]
	mov	QWORD PTR [rsp+192], rbx
	mov	DWORD PTR i$[rsp], eax
	mov	rbx, rcx
	je	SHORT $LN11@SetWin64

; 802  :     SkipOption(pi, tokenarray);

	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], 0
	je	SHORT $LN21@SetWin64
	npad	4
$LL15@SetWin64:
	movsxd	rcx, DWORD PTR [rbx]
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], 44			; 0000002cH
	je	SHORT $LN21@SetWin64
	lea	eax, DWORD PTR [rcx+1]
	mov	DWORD PTR [rbx], eax
	cdqe
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], 0
	jne	SHORT $LL15@SetWin64
$LN21@SetWin64:

; 803  :     return(NOT_ERROR);

	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+192]

; 860  : }

	add	rsp, 184				; 000000b8H
	ret	0
$LN11@SetWin64:

; 804  :     }
; 805  :   if (EvalOperand(&i, tokenarray, Token_Count, &opndx, 0) == ERROR)

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	BYTE PTR [rsp+32], 0
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN10@SetWin64
	mov	rbx, QWORD PTR [rsp+192]

; 860  : }

	add	rsp, 184				; 000000b8H
	ret	0
$LN10@SetWin64:

; 806  :       return(ERROR);
; 807  :   if (opndx.kind == EXPR_CONST) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	$LN9@SetWin64

; 808  :     if (opndx.llvalue & (~W64F_ALL)) {

	mov	rax, QWORD PTR opndx$[rsp]
	test	rax, -16
	je	SHORT $LN8@SetWin64

; 809  :       return(EmitConstError(&opndx));

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError
	mov	rbx, QWORD PTR [rsp+192]

; 860  : }

	add	rsp, 184				; 000000b8H
	ret	0
$LN8@SetWin64:

; 810  :       }
; 811  :    
; 812  :     /* OPTION win64:11 can work only with OPTION STACKBASE:RSP */
; 813  :     if (opndx.llvalue & W64F_SMART) {  

	test	al, 8
	mov	QWORD PTR [rsp+200], rbp
	mov	QWORD PTR [rsp+208], rsi
	mov	QWORD PTR [rsp+216], rdi
	lea	rsi, OFFSET FLAT:UpdateStackBase
	lea	rbp, OFFSET FLAT:UpdateProcStatus
	lea	rdi, OFFSET FLAT:ModuleInfo
	je	SHORT $LN20@SetWin64

; 814  :         /* In this case STACKBASESUPP must be set */
; 815  :         #ifndef STACKBASESUPP
; 816  :         #define STACKBASESUPP 1       /* support OPTION STACKBASE              */
; 817  :         #endif
; 818  :       /* ensure that W64F_SAVEREGPARAMS and W64F_AUTOSTACKSP options are also set*/
; 819  :       opndx.llvalue |= 3;
; 820  :         /* ensure that basereg is RSP */
; 821  :       if (ModuleInfo.basereg[ModuleInfo.Ofssize] != T_RSP){

	movzx	ecx, BYTE PTR ModuleInfo+404
	or	rax, 3
	cmp	DWORD PTR [rdi+rcx*4+500], 119		; 00000077H
	mov	QWORD PTR opndx$[rsp], rax
	je	SHORT $LN20@SetWin64

; 822  :         ModuleInfo.basereg[ModuleInfo.Ofssize] = T_RSP;

	mov	DWORD PTR [rdi+rcx*4+500], 119		; 00000077H

; 823  :         if (!ModuleInfo.g.StackBase) {

	cmp	QWORD PTR ModuleInfo+272, 0
	jne	SHORT $LN20@SetWin64

; 824  :           ModuleInfo.g.StackBase = CreateVariable("@StackBase", 0);

	lea	rcx, OFFSET FLAT:$SG5849
	xor	edx, edx
	call	CreateVariable

; 825  :           ModuleInfo.g.StackBase->predefined = TRUE;
; 826  :           ModuleInfo.g.StackBase->sfunc_ptr = UpdateStackBase;
; 827  :           ModuleInfo.g.ProcStatus = CreateVariable("@ProcStatus", 0);

	lea	rcx, OFFSET FLAT:$SG5850
	xor	edx, edx
	mov	QWORD PTR ModuleInfo+272, rax
	or	BYTE PTR [rax+48], 32			; 00000020H
	mov	rax, QWORD PTR ModuleInfo+272
	mov	QWORD PTR [rax+72], rsi
	call	CreateVariable
	mov	QWORD PTR ModuleInfo+280, rax

; 828  :           ModuleInfo.g.ProcStatus->predefined = TRUE;

	or	BYTE PTR [rax+48], 32			; 00000020H

; 829  :           ModuleInfo.g.ProcStatus->sfunc_ptr = UpdateProcStatus;

	mov	rax, QWORD PTR ModuleInfo+280
	mov	QWORD PTR [rax+72], rbp
	mov	rax, QWORD PTR opndx$[rsp]
$LN20@SetWin64:

; 830  :           }
; 831  :         }
; 832  :       }
; 833  : 	/* Force option 1 and 2 to == 3 with frame auto */
; 834  : /*	if (opndx.llvalue == 1 || opndx.llvalue == 2)
; 835  : 	{
; 836  : 		ModuleInfo.frame_auto = 1;
; 837  : 		opndx.llvalue = 3;
; 838  : 	}*/
; 839  : 	if (opndx.llvalue == 3)

	cmp	rax, 3
	jne	SHORT $LN2@SetWin64

; 840  : 	{
; 841  : 		opndx.llvalue = 11;
; 842  : 		if (ModuleInfo.basereg[ModuleInfo.Ofssize] != T_RSP) {

	movzx	ecx, BYTE PTR ModuleInfo+404
	mov	eax, 11
	cmp	DWORD PTR [rdi+rcx*4+500], 119		; 00000077H
	mov	QWORD PTR opndx$[rsp], rax
	je	SHORT $LN2@SetWin64

; 843  : 			ModuleInfo.basereg[ModuleInfo.Ofssize] = T_RSP;

	mov	DWORD PTR [rdi+rcx*4+500], 119		; 00000077H

; 844  : 			if (!ModuleInfo.g.StackBase) {

	cmp	QWORD PTR ModuleInfo+272, 0
	jne	SHORT $LN2@SetWin64

; 845  : 				ModuleInfo.g.StackBase = CreateVariable("@StackBase", 0);

	lea	rcx, OFFSET FLAT:$SG5854
	xor	edx, edx
	call	CreateVariable

; 846  : 				ModuleInfo.g.StackBase->predefined = TRUE;
; 847  : 				ModuleInfo.g.StackBase->sfunc_ptr = UpdateStackBase;
; 848  : 				ModuleInfo.g.ProcStatus = CreateVariable("@ProcStatus", 0);

	lea	rcx, OFFSET FLAT:$SG5855
	xor	edx, edx
	mov	QWORD PTR ModuleInfo+272, rax
	or	BYTE PTR [rax+48], 32			; 00000020H
	mov	rax, QWORD PTR ModuleInfo+272
	mov	QWORD PTR [rax+72], rsi
	call	CreateVariable
	mov	QWORD PTR ModuleInfo+280, rax

; 849  : 				ModuleInfo.g.ProcStatus->predefined = TRUE;

	or	BYTE PTR [rax+48], 32			; 00000020H

; 850  : 				ModuleInfo.g.ProcStatus->sfunc_ptr = UpdateProcStatus;

	mov	rax, QWORD PTR ModuleInfo+280
	mov	QWORD PTR [rax+72], rbp
	mov	rax, QWORD PTR opndx$[rsp]
$LN2@SetWin64:
	mov	rdi, QWORD PTR [rsp+216]
	mov	rsi, QWORD PTR [rsp+208]
	mov	rbp, QWORD PTR [rsp+200]

; 856  :     }
; 857  :   ModuleInfo.win64_flags = opndx.llvalue;

	mov	BYTE PTR ModuleInfo+413, al

; 858  :     *pi = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR [rbx], eax

; 859  :     return( NOT_ERROR );

	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+192]

; 860  : }

	add	rsp, 184				; 000000b8H
	ret	0
$LN9@SetWin64:

; 851  : 			}
; 852  : 		}
; 853  : 	}
; 854  :     } else {
; 855  :         return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	mov	rbx, QWORD PTR [rsp+192]

; 860  : }

	add	rsp, 184				; 000000b8H
	ret	0
SetWin64 ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$IncludeDll DD 030c01H
	DD	08640cH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$IncludeDll DD @imagerel(IncludeDll#)
	DD	@imagerel(IncludeDll#+37)
	DD	@imagerel($unwind$IncludeDll#)
pdata	ENDS
xdata	SEGMENT
$chain$2$IncludeDll DD 044021H
	DD	097440H
	DD	073405H
	DD	@imagerel(IncludeDll#)
	DD	@imagerel(IncludeDll#+37)
	DD	@imagerel($unwind$IncludeDll#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$IncludeDll DD @imagerel(IncludeDll#+37)
	DD	@imagerel(IncludeDll#+217)
	DD	@imagerel($chain$2$IncludeDll#)
pdata	ENDS
xdata	SEGMENT
$chain$4$IncludeDll DD 020021H
	DD	073400H
	DD	@imagerel(IncludeDll#)
	DD	@imagerel(IncludeDll#+37)
	DD	@imagerel($unwind$IncludeDll#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$IncludeDll DD @imagerel(IncludeDll#+217)
	DD	@imagerel(IncludeDll#+235)
	DD	@imagerel($chain$4$IncludeDll#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
IncludeDll PROC NEAR

; 867  : {

	sub	rsp, 40					; 00000028H

; 868  :     struct dll_desc **q;
; 869  :     struct dll_desc *node;
; 870  : 
; 871  :     /* allow a zero-sized name! */
; 872  :     if ( *name == NULLC )

	cmp	BYTE PTR [rcx], 0
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, rcx
	jne	SHORT $LN5@IncludeDll

; 873  :         return( NULL );

	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+64]

; 892  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN5@IncludeDll:

; 874  : 
; 875  :     for ( q = &ModuleInfo.g.DllQueue; *q ; q = &(*q)->next ) {

	cmp	QWORD PTR ModuleInfo+80, 0
	mov	QWORD PTR [rsp+56], rbx
	lea	rbx, OFFSET FLAT:ModuleInfo+80
	je	SHORT $LN2@IncludeDll
	npad	13
$LL4@IncludeDll:

; 876  :         if ( _stricmp( (*q)->name, name ) == 0 )

	mov	rcx, QWORD PTR [rbx]
	mov	rdx, rsi
	add	rcx, 12
	call	_stricmp
	test	eax, eax
	je	$LN11@IncludeDll
	mov	rbx, QWORD PTR [rbx]
	cmp	QWORD PTR [rbx], 0
	jne	SHORT $LL4@IncludeDll
$LN2@IncludeDll:
	mov	QWORD PTR [rsp+72], rdi

; 878  :     }
; 879  :     node = LclAlloc( sizeof( struct dll_desc ) + strlen( name ) );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rsi
	repne scasb
	not	rcx
	add	rcx, 15
	call	LclAlloc
	mov	rdi, rax

; 880  :     node->next = NULL;

	xor	eax, eax

; 881  :     node->cnt = 0;
; 882  :     strcpy( node->name, name );

	lea	rdx, QWORD PTR [rdi+12]
	mov	QWORD PTR [rdi], rax
	mov	DWORD PTR [rdi+8], eax
	sub	rdx, rsi
$LL8@IncludeDll:
	movzx	ecx, BYTE PTR [rsi]
	inc	rsi
	test	cl, cl
	mov	BYTE PTR [rdx+rsi-1], cl
	jne	SHORT $LL8@IncludeDll

; 883  :     *q = node;

	mov	QWORD PTR [rbx], rdi

; 884  : 
; 885  : #if AMD64_SUPPORT
; 886  :     ModuleInfo.g.imp_prefix = ( ( ModuleInfo.defOfssize == USE64 ) ? "__imp_" : "_imp_" );

	cmp	BYTE PTR ModuleInfo+405, 2
	mov	rbx, QWORD PTR [rsp+56]
	lea	rcx, OFFSET FLAT:$SG5871
	lea	rax, OFFSET FLAT:$SG5872
	cmove	rax, rcx
	mov	QWORD PTR ModuleInfo+88, rax

; 887  : #else
; 888  :     ModuleInfo.g.imp_prefix = "_imp_";
; 889  : #endif
; 890  : 
; 891  :     return( node );

	mov	rax, rdi
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]

; 892  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN11@IncludeDll:

; 877  :             return( *q );

	mov	rax, QWORD PTR [rbx]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 892  : }

	add	rsp, 40					; 00000028H
	ret	0
IncludeDll ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SetDllImport DD 091e01H
	DD	09741eH
	DD	086416H
	DD	075411H
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetDllImport DD @imagerel(SetDllImport#)
	DD	@imagerel(SetDllImport#+150)
	DD	@imagerel($unwind$SetDllImport#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetDllImport PROC NEAR

; 896  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx

; 897  :     int i = *pi;

	movsxd	rbx, DWORD PTR [rcx]
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi

; 898  : 
; 899  :     /* used for COFF only */
; 900  :     //if ( Options.output_format != OFORMAT_COFF ) {
; 901  :     //    SkipOption( pi, tokenarray );
; 902  :     //    return( NOT_ERROR);
; 903  :     //}
; 904  : 
; 905  :     if ( tokenarray[i].token == T_ID &&
; 906  :         ( _stricmp( tokenarray[i].string_ptr, "NONE" ) == 0 ) ) {

	mov	rsi, rbx
	mov	QWORD PTR [rsp+72], rdi
	shl	rsi, 5
	mov	rbp, rdx
	mov	rdi, rcx
	cmp	BYTE PTR [rsi+rdx], 8
	jne	SHORT $LN4@SetDllImpo
	mov	rcx, QWORD PTR [rsi+rbp+8]
	lea	rdx, OFFSET FLAT:$SG5881
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN4@SetDllImpo

; 907  :         ModuleInfo.CurrDll = NULL;

	mov	QWORD PTR ModuleInfo+336, 0

; 908  :         i++;

	jmp	SHORT $LN1@SetDllImpo
$LN4@SetDllImpo:

; 909  :     } else if ( tokenarray[i].token == T_STRING && tokenarray[i].string_delim == '<' ) {

	cmp	BYTE PTR [rsi+rbp], 9
	jne	SHORT $LN8@SetDllImpo
	cmp	BYTE PTR [rsi+rbp+1], 60		; 0000003cH
	jne	SHORT $LN8@SetDllImpo

; 910  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN1@SetDllImpo

; 911  :             ModuleInfo.CurrDll = IncludeDll( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rsi+rbp+8]
	call	IncludeDll
	mov	QWORD PTR ModuleInfo+336, rax
$LN1@SetDllImpo:

; 912  :         i++;

	inc	ebx
$LN8@SetDllImpo:
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]

; 913  :     }
; 914  :     *pi = i;

	mov	DWORD PTR [rdi], ebx
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+48]

; 915  :     return( NOT_ERROR );

	xor	eax, eax

; 916  : }

	add	rsp, 40					; 00000028H
	ret	0
SetDllImport ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SetCodeView DD 030c01H
	DD	014010cH
	DD	03002H
xdata	ENDS
pdata	SEGMENT
$pdata$SetCodeView DD @imagerel(SetCodeView#)
	DD	@imagerel(SetCodeView#+117)
	DD	@imagerel($unwind$SetCodeView#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
opnd$ = 48
i$ = 176
pi$ = 176
tokenarray$ = 184
SetCodeView PROC NEAR

; 922  : {

	push	rbx
	mov	r11, rsp
	sub	rsp, 160				; 000000a0H

; 923  :     int i = *pi;

	mov	eax, DWORD PTR [rcx]

; 924  :     struct expr opnd;
; 925  : 
; 926  :     if ( EvalOperand( &i, tokenarray, Token_Count, &opnd, 0 ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rbx, rcx
	lea	r9, QWORD PTR [r11-112]
	lea	rcx, QWORD PTR [r11+16]
	mov	BYTE PTR [rsp+32], 0
	mov	DWORD PTR [r11+16], eax
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN3@SetCodeVie

; 935  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN3@SetCodeVie:

; 927  :         return( ERROR );
; 928  :     if ( opnd.kind == EXPR_CONST ) {

	cmp	DWORD PTR opnd$[rsp+60], 0
	jne	SHORT $LN2@SetCodeVie

; 929  :         ModuleInfo.cv_opt = opnd.value;

	movzx	eax, BYTE PTR opnd$[rsp]
	mov	BYTE PTR ModuleInfo+427, al

; 932  :     }
; 933  :     *pi = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR [rbx], eax

; 934  :     return( NOT_ERROR );

	xor	eax, eax

; 935  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN2@SetCodeVie:

; 930  :     } else {
; 931  :         return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 935  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
SetCodeView ENDP
_TEXT	ENDS
EXTRN	SpecialTable:BYTE
xdata	SEGMENT
$unwind$SetStackBase DD 050e01H
	DD	09740eH
	DD	083409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetStackBase DD @imagerel(SetStackBase#)
	DD	@imagerel(SetStackBase#+243)
	DD	@imagerel($unwind$SetStackBase#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetStackBase PROC NEAR

; 943  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi

; 944  :     int i = *pi;

	movsxd	rdi, DWORD PTR [rcx]

; 945  : 
; 946  :     if ( tokenarray[i].token != T_REG ) {

	mov	rax, rdi
	mov	rbx, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], 2
	je	SHORT $LN3@SetStackBa

; 947  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rax+rdx+8]
	mov	ecx, 209				; 000000d1H
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 964  : }

	add	rsp, 40					; 00000028H
	jmp	EmitErr
$LN3@SetStackBa:

; 948  :     }
; 949  :     if ( !( GetSflagsSp( tokenarray[i].tokval ) & SFR_IREG ) ) {

	mov	ecx, DWORD PTR [rax+rdx+16]
	lea	rdx, OFFSET FLAT:__ImageBase
	lea	rax, QWORD PTR [rcx+rcx*2]
	test	BYTE PTR SpecialTable[rdx+rax*4+4], 32	; 00000020H
	jne	SHORT $LN2@SetStackBa

; 950  :         return( EmitError( MUST_BE_INDEX_OR_BASE_REGISTER ) );

	mov	ecx, 33					; 00000021H
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 964  : }

	add	rsp, 40					; 00000028H
	jmp	EmitError
$LN2@SetStackBa:

; 951  :     }
; 952  :     ModuleInfo.basereg[ModuleInfo.Ofssize] = tokenarray[i].tokval;

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	DWORD PTR ModuleInfo[rdx+rax*4+500], ecx

; 953  :     if ( !ModuleInfo.g.StackBase ) {

	cmp	QWORD PTR ModuleInfo+272, 0
	jne	SHORT $LN1@SetStackBa

; 954  :         ModuleInfo.g.StackBase = CreateVariable( "@StackBase", 0 );

	lea	rcx, OFFSET FLAT:$SG5907
	xor	edx, edx
	call	CreateVariable

; 955  :         ModuleInfo.g.StackBase->predefined = TRUE;
; 956  :         ModuleInfo.g.StackBase->sfunc_ptr = UpdateStackBase;

	lea	rcx, OFFSET FLAT:UpdateStackBase

; 957  :         ModuleInfo.g.ProcStatus = CreateVariable( "@ProcStatus", 0 );

	xor	edx, edx
	mov	QWORD PTR ModuleInfo+272, rax
	or	BYTE PTR [rax+48], 32			; 00000020H
	mov	rax, QWORD PTR ModuleInfo+272
	mov	QWORD PTR [rax+72], rcx
	lea	rcx, OFFSET FLAT:$SG5908
	call	CreateVariable

; 958  :         ModuleInfo.g.ProcStatus->predefined = TRUE;
; 959  :         ModuleInfo.g.ProcStatus->sfunc_ptr = UpdateProcStatus;

	lea	rcx, OFFSET FLAT:UpdateProcStatus
	mov	QWORD PTR ModuleInfo+280, rax
	or	BYTE PTR [rax+48], 32			; 00000020H
	mov	rax, QWORD PTR ModuleInfo+280
	mov	QWORD PTR [rax+72], rcx
$LN1@SetStackBa:

; 960  :     }
; 961  :     i++;

	lea	eax, DWORD PTR [rdi+1]
	mov	rdi, QWORD PTR [rsp+72]

; 962  :     *pi = i;

	mov	DWORD PTR [rbx], eax
	mov	rbx, QWORD PTR [rsp+64]

; 963  :     return( NOT_ERROR );

	xor	eax, eax

; 964  : }

	add	rsp, 40					; 00000028H
	ret	0
SetStackBase ENDP
; Function compile flags: /Ogtpy
pi$ = 8
tokenarray$ = 16
Unsupported PROC NEAR

; 969  : {

	mov	rax, rdx

; 970  :     return( EmitErr( NOT_SUPPORTED, tokenarray[(*pi)-2].tokpos ) );

	movsxd	rdx, DWORD PTR [rcx]
	mov	ecx, 72					; 00000048H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rax-40]

; 971  : }

	jmp	EmitErr
Unsupported ENDP
_TEXT	ENDS
EXTRN	SetCPU:NEAR
xdata	SEGMENT
$unwind$SetFlat DD 051101H
	DD	097411H
	DD	083409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetFlat DD @imagerel(SetFlat#)
	DD	@imagerel(SetFlat#+247)
	DD	@imagerel($unwind$SetFlat#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pi$ = 48
tokenarray$ = 56
SetFlat	PROC NEAR

; 974  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rbx
	mov	rbx, rcx
	mov	QWORD PTR [rsp+72], rdi

; 975  : 	const char  *textvalue;
; 976  : 
; 977  : 	int i = *pi;

	mov	edi, DWORD PTR [rcx]

; 978  : 
; 979  : 	ModuleInfo.offsettype = OT_FLAT; 
; 980  : 	Options.output_format = OFORMAT_BIN;
; 981  : 	ModuleInfo.curr_cpu = P_64p | P_AVX | P_CPU_MASK;
; 982  : 	SetCPU(P_64p);

	mov	ecx, 120				; 00000078H
	mov	DWORD PTR ModuleInfo+384, 1
	mov	DWORD PTR Options+156, 0
	mov	DWORD PTR ModuleInfo+392, 33016		; 000080f8H
	call	SetCPU

; 983  : 	ModuleInfo.model = MODEL_FLAT;
; 984  : 	ModuleInfo.fctype = FCT_WIN64;
; 985  : 	ModuleInfo.defOfssize = USE16;
; 986  : 	ModuleInfo.flat = TRUE;
; 987  : 	ModuleInfo.win64_flags = 11;
; 988  : 	#ifndef STACKBASESUPP
; 989  : 		#define STACKBASESUPP 1       /* support OPTION STACKBASE              */
; 990  : 	#endif
; 991  : 	ModuleInfo.frame_auto = 1;

	bts	DWORD PTR ModuleInfo+408, 18

; 992  : 	ModuleInfo.basereg[ModuleInfo.Ofssize] = T_RSP;

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:ModuleInfo+500
	mov	DWORD PTR ModuleInfo+360, 7
	mov	DWORD PTR ModuleInfo+376, 2
	mov	BYTE PTR ModuleInfo+405, 0
	mov	BYTE PTR ModuleInfo+772, 1
	mov	BYTE PTR ModuleInfo+413, 11
	mov	DWORD PTR [rcx+rax*4], 119		; 00000077H

; 993  : 	if (!ModuleInfo.g.StackBase) {

	cmp	QWORD PTR ModuleInfo+272, 0
	jne	SHORT $LN1@SetFlat

; 994  : 		ModuleInfo.g.StackBase = CreateVariable("@StackBase", 0);

	lea	rcx, OFFSET FLAT:$SG5925
	xor	edx, edx
	call	CreateVariable

; 995  : 		ModuleInfo.g.StackBase->predefined = TRUE;
; 996  : 		ModuleInfo.g.StackBase->sfunc_ptr = UpdateStackBase;

	lea	rcx, OFFSET FLAT:UpdateStackBase

; 997  : 		ModuleInfo.g.ProcStatus = CreateVariable("@ProcStatus", 0);

	xor	edx, edx
	mov	QWORD PTR ModuleInfo+272, rax
	or	BYTE PTR [rax+48], 32			; 00000020H
	mov	rax, QWORD PTR ModuleInfo+272
	mov	QWORD PTR [rax+72], rcx
	lea	rcx, OFFSET FLAT:$SG5926
	call	CreateVariable

; 998  : 		ModuleInfo.g.ProcStatus->predefined = TRUE;
; 999  : 		ModuleInfo.g.ProcStatus->sfunc_ptr = UpdateProcStatus;

	lea	rcx, OFFSET FLAT:UpdateProcStatus
	mov	QWORD PTR ModuleInfo+280, rax
	or	BYTE PTR [rax+48], 32			; 00000020H
	mov	rax, QWORD PTR ModuleInfo+280
	mov	QWORD PTR [rax+72], rcx
$LN1@SetFlat:

; 1000 : 	}
; 1001 : 	i++;

	lea	eax, DWORD PTR [rdi+1]
	mov	rdi, QWORD PTR [rsp+72]

; 1002 : 	*pi = i;

	mov	DWORD PTR [rbx], eax
	mov	rbx, QWORD PTR [rsp+64]

; 1003 : 	return(NOT_ERROR);

	xor	eax, eax

; 1004 : }

	add	rsp, 40					; 00000028H
	ret	0
SetFlat	ENDP
_TEXT	ENDS
PUBLIC	OptionDirective
EXTRN	MacroRebuild:BYTE
EXTRN	_strupr:NEAR
xdata	SEGMENT
$unwind$OptionDirective DD 092801H
	DD	057428H
	DD	06641aH
	DD	0b5412H
	DD	0a340dH
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$OptionDirective DD @imagerel($LN34#)
	DD	@imagerel($LN34#+441)
	DD	@imagerel($unwind$OptionDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 64
tokenarray$ = 72
OptionDirective PROC NEAR

; 1093 : {

$LN34:
	sub	rsp, 56					; 00000038H

; 1094 :     int idx = -1;
; 1095 : 
; 1096 :     DebugMsg1(( "OPTION directive enter, option=%s\n", tokenarray[i+1].string_ptr ));
; 1097 : 
; 1098 :     i++; /* skip OPTION directive */

	lea	r8d, DWORD PTR [rcx+1]
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+88], rbp

; 1099 :     while ( tokenarray[i].token != T_FINAL ) {

	movsxd	rcx, r8d
	mov	QWORD PTR [rsp+48], rsi
	mov	DWORD PTR i$[rsp], r8d
	shl	rcx, 5
	mov	QWORD PTR [rsp+40], rdi
	mov	rdi, rdx
	add	rcx, rdx
	cmp	BYTE PTR [rcx], 0
	je	SHORT $LN2@OptionDire
	lea	rbp, OFFSET FLAT:optiontab
	npad	6
$LL16@OptionDire:

; 1100 :         _strupr( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rcx+8]
	call	_strupr

; 1101 :         for ( idx = 0; idx < TABITEMS; idx++ ) {

	movsxd	r8, DWORD PTR i$[rsp]
	xor	ebx, ebx
	mov	rax, r8
	xor	r10d, r10d
	mov	r11, rbp
	shl	rax, 5
	mov	rsi, QWORD PTR [rax+rdi+8]
$LL14@OptionDire:

; 1102 :             if ( 0 == strcmp( tokenarray[i].string_ptr, optiontab[idx].name ) )

	mov	r9, QWORD PTR [r11]
	mov	rax, rsi
	sub	r9, rsi
	npad	5
$LL32@OptionDire:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r9]
	sub	edx, ecx
	jne	SHORT $LN33@OptionDire
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL32@OptionDire
$LN33@OptionDire:
	test	edx, edx
	je	SHORT $LN21@OptionDire
	inc	ebx
	inc	r10
	add	r11, 16
	cmp	ebx, 43					; 0000002bH
	jb	SHORT $LL14@OptionDire
$LN2@OptionDire:

; 1132 :         DebugMsg(( "option syntax error: >%s<\n", tokenarray[i].tokpos ));
; 1133 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rdx, r8d
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+24]
	call	EmitErr
$LN17@OptionDire:
	mov	rdi, QWORD PTR [rsp+40]
	mov	rsi, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]

; 1143 : }

	add	rsp, 56					; 00000038H
	ret	0
$LN21@OptionDire:

; 1103 :                 break;
; 1104 :         }
; 1105 :         if ( idx >= TABITEMS )

	cmp	ebx, 43					; 0000002bH
	jae	SHORT $LN2@OptionDire

; 1106 :             break;
; 1107 :         i++;

	inc	r8d

; 1108 :         /* v2.06: check for colon separator here */
; 1109 :         if ( idx >= NOARGOPTS ) {

	cmp	r10, 19
	mov	DWORD PTR i$[rsp], r8d
	jl	SHORT $LN6@OptionDire

; 1110 :             if ( tokenarray[i].token != T_COLON ) {

	movsxd	rax, r8d
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 58			; 0000003aH
	jne	$LN23@OptionDire

; 1112 :             }
; 1113 :             i++;

	inc	r8d

; 1114 :             /* there must be something after the colon */
; 1115 :             if ( tokenarray[i].token == T_FINAL ) {

	movsxd	rax, r8d
	mov	DWORD PTR i$[rsp], r8d
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 0
	je	$LN24@OptionDire

; 1118 :             }
; 1119 :             /* reject option if -Zne is set */
; 1120 :             if ( idx >= MASMOPTS && Options.strict_masm_compat ) {

	cmp	r10, 28
	jl	SHORT $LN6@OptionDire
	cmp	BYTE PTR Options+136, 0
	jne	$LN25@OptionDire
$LN6@OptionDire:

; 1123 :             }
; 1124 :         }
; 1125 :         if ( optiontab[idx].func( &i, tokenarray ) == ERROR )

	lea	rcx, QWORD PTR i$[rsp]
	add	r10, r10
	mov	rdx, rdi
	call	QWORD PTR [rbp+r10*8+8]
	cmp	eax, -1
	je	$LN26@OptionDire

; 1127 :         if ( tokenarray[i].token != T_COMMA )

	movsxd	r8, DWORD PTR i$[rsp]
	mov	rax, r8
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 44			; 0000002cH
	jne	SHORT $LN27@OptionDire

; 1128 :             break;
; 1129 :         i++;

	inc	r8d
	movsxd	rcx, r8d
	mov	DWORD PTR i$[rsp], r8d
	shl	rcx, 5
	add	rcx, rdi
	cmp	BYTE PTR [rcx], 0
	jne	$LL16@OptionDire
$LN27@OptionDire:

; 1130 :     }
; 1131 :     if ( idx >= TABITEMS  || tokenarray[i].token != T_FINAL ) {

	movsxd	rax, r8d
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 0
	jne	$LN2@OptionDire

; 1134 :     }
; 1135 : 
; 1136 : 	/* If we set the ARCH option */
; 1137 : 	if (idx == 42)

	movzx	eax, BYTE PTR MacroRebuild
	cmp	ebx, 42					; 0000002aH
	mov	ecx, 1
	cmove	eax, ecx
	mov	BYTE PTR MacroRebuild, al

; 1138 : 	{
; 1139 : 		MacroRebuild = TRUE;
; 1140 : 	}
; 1141 : 
; 1142 :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN17@OptionDire
$LN23@OptionDire:

; 1111 :                 return( EmitError( COLON_EXPECTED ) );

	mov	ecx, 84					; 00000054H
	call	EmitError
	jmp	$LN17@OptionDire
$LN24@OptionDire:

; 1116 :                 i -= 2; /* position back to option identifier */

	sub	r8d, 2
	mov	DWORD PTR i$[rsp], r8d

; 1117 :                 break;

	jmp	SHORT $LN27@OptionDire
$LN25@OptionDire:

; 1121 :                 i -= 2;

	sub	r8d, 2
	mov	DWORD PTR i$[rsp], r8d

; 1122 :                 break;

	jmp	SHORT $LN27@OptionDire
$LN26@OptionDire:

; 1126 :             return( ERROR );

	mov	eax, -1
	jmp	$LN17@OptionDire
OptionDirective ENDP
_TEXT	ENDS
END
