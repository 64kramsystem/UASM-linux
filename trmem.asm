; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	hTrmem:QWORD
COMM	FileTrmem:QWORD
_DATA	ENDS
CONST	SEGMENT
MSG_OUT_OF_MEMORY DB 'Tracker out of memory', 00H
	ORG $+2
MSG_CHUNK_BYTE_UNFREED DB '%U chunks (%L bytes) unfreed', 00H
	ORG $+3
MSG_SIZE_ZERO DB '%W size zero', 00H
	ORG $+3
MSG_OVERRUN_ALLOCATION DB '%W %D overrun allocation by %C of %U bytes', 00H
	ORG $+5
MSG_UNOWNED_CHUNK DB '%W unowned chunk %D', 00H
	ORG $+4
MSG_NULL_PTR DB	'%W NULL pointer', 00H
MSG_NO_ROUTINE DB 'Tracker was not given a %S routine!', 00H
	ORG $+4
MSG_NOT_IN_ALLOCATION DB '%W %D not in any allocation', 00H
	ORG $+4
MSG_OVERRUN_2 DB '%W %D+%U overruns allocation %D+%U', 00H
	ORG $+5
MSG_PRT_USAGE DB 'Current usage: %L bytes; Peak usage: %L bytes', 00H
	ORG $+2
MSG_MIN_ALLOC DB '%W allocation of %U less than minimum size', 00H
	ORG $+5
MSG_PRT_LIST_1 DB '  Who      Addr     Size     Call     Contents', 00H
	ORG $+1
MSG_PRT_LIST_2 DB '======== ======== ======== ======== =================='
	DB	'=========================', 00H
MSG_PRT_LIST_3 DB '%C %D %U %L %X', 00H
CONST	ENDS
_DATA	SEGMENT
$SG1775	DB	'0123456789abcdef', 00H
	ORG $+7
$SG2022	DB	'Validate', 00H
	ORG $+3
$SG2056	DB	'Alloc', 00H
	ORG $+2
$SG2060	DB	'Alloc', 00H
	ORG $+6
$SG2097	DB	'Validate', 00H
	ORG $+7
$SG2098	DB	'Validate', 00H
	ORG $+3
$SG2111	DB	'Free', 00H
	ORG $+3
$SG2114	DB	'Free', 00H
	ORG $+3
$SG2115	DB	'Free', 00H
	ORG $+7
$SG2181	DB	'Realloc', 00H
$SG2191	DB	'Expand', 00H
	ORG $+1
$SG2219	DB	'ChkRange', 00H
	ORG $+7
$SG2232	DB	'ChkRange', 00H
	ORG $+7
$SG2233	DB	'ChkRange', 00H
	ORG $+3
$SG2281	DB	'w', 00H
	ORG $+2
$SG2282	DB	'~hjwasm.trk', 00H
	ORG $+4
$SG2287	DB	'tm_Init: _trmem_open() failed', 0aH, 00H
	ORG $+1
$SG2289	DB	'tm_Init: fopen("~hjwasm.trk") failed [%u]', 0aH, 00H
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\trmem.c
_DATA	ENDS
_TEXT	SEGMENT
p$ = 8
size$ = 16
setSize	PROC NEAR

; 132  :     p->size = size ^ (size_t)p->mem ^ (size_t)p->who ^ (size_t)p;

	mov	rax, QWORD PTR [rcx+16]
	xor	rax, QWORD PTR [rcx+8]
	xor	rax, rcx
	xor	rax, rdx
	mov	QWORD PTR [rcx+24], rax

; 133  : }

	ret	0
setSize	ENDP
; Function compile flags: /Ogtpy
p$ = 8
getSize	PROC NEAR

; 137  :     return( p->size ^ (size_t)p->mem ^ (size_t)p->who ^ (size_t)p );

	mov	rax, QWORD PTR [rcx+24]
	xor	rax, QWORD PTR [rcx+16]
	xor	rax, QWORD PTR [rcx+8]
	xor	rax, rcx

; 138  : }

	ret	0
getSize	ENDP
; Function compile flags: /Ogtpy
dest$ = 8
src$ = 16
stpcpy	PROC NEAR

; 146  :     *dest = *src;

	movzx	eax, BYTE PTR [rdx]

; 147  :     while( *dest ) {

	cmp	al, 0
	mov	BYTE PTR [rcx], al
	je	SHORT $LN7@stpcpy
	npad	7
$LL2@stpcpy:

; 148  :         ++dest;
; 149  :         ++src;
; 150  :         *dest = *src;

	movzx	eax, BYTE PTR [rdx+1]
	inc	rdx
	inc	rcx
	cmp	al, 0
	mov	BYTE PTR [rcx], al
	jne	SHORT $LL2@stpcpy
$LN7@stpcpy:

; 151  :     }
; 152  :     return( dest );

	mov	rax, rcx

; 153  : }

	ret	0
stpcpy	ENDP
; Function compile flags: /Ogtpy
ptr$ = 8
data$ = 16
size$ = 24
formHex	PROC NEAR

; 157  :     char            *str;
; 158  : 
; 159  :     size *= 2;

	lea	r9d, DWORD PTR [r8+r8]

; 160  :     ptr += size;

	mov	eax, r9d
	add	rcx, rax

; 161  :     str = ptr;
; 162  :     for( ; size > 0; size-- ) {

	test	r9d, r9d
	mov	r8, rcx
	je	SHORT $LN8@formHex
	lea	r10, OFFSET FLAT:$SG1775
	npad	7
$LL3@formHex:

; 163  :         *--str = "0123456789abcdef"[data & 0x0f];

	mov	eax, edx
	dec	r8

; 164  :         data >>= 4;

	shr	edx, 4
	and	eax, 15
	add	r9d, -1					; ffffffffH
	movzx	eax, BYTE PTR [rax+r10]
	mov	BYTE PTR [r8], al
	jne	SHORT $LL3@formHex
$LN8@formHex:

; 165  :     }
; 166  :     return( ptr );

	mov	rax, rcx

; 167  : }

	ret	0
formHex	ENDP
; Function compile flags: /Ogtpy
hdl$ = 8
ptr$ = 16
who$ = 24
formCodePtr PROC NEAR

; 184  : #if defined( M_I86LM ) || defined( M_I86HM ) || defined( M_I86MM )
; 185  :     return formFarPtr( ptr, who );
; 186  : #else
; 187  :     return formHex( ptr, (uint_32) who, sizeof(who) );

	lea	rax, QWORD PTR [rdx+16]
	mov	r9d, 16
	lea	r10, OFFSET FLAT:$SG1775
	mov	rdx, rax
	npad	12
$LL5@formCodePt:
	mov	ecx, r8d
	dec	rdx
	shr	r8d, 4
	and	ecx, 15
	add	r9d, -1					; ffffffffH
	movzx	ecx, BYTE PTR [rcx+r10]
	mov	BYTE PTR [rdx], cl
	jne	SHORT $LL5@formCodePt

; 188  : #endif
; 189  : }

	ret	0
formCodePtr ENDP
_TEXT	ENDS
EXTRN	isprint:NEAR
EXTRN	__ImageBase:BYTE
xdata	SEGMENT
$unwind$trPrt DD 082d01H
	DD	015d42dH
	DD	016c429H
	DD	01a3420H
	DD	01b0119H
xdata	ENDS
pdata	SEGMENT
$pdata$trPrt DD	@imagerel(trPrt#)
	DD	@imagerel(trPrt#+67)
	DD	@imagerel($unwind$trPrt#)
pdata	ENDS
xdata	SEGMENT
$chain$7$trPrt DD 0a1f21H
	DD	017741fH
	DD	0186410H
	DD	019540cH
	DD	013f408H
	DD	014e404H
	DD	@imagerel(trPrt#)
	DD	@imagerel(trPrt#+67)
	DD	@imagerel($unwind$trPrt#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$trPrt DD @imagerel(trPrt#+67)
	DD	@imagerel(trPrt#+833)
	DD	@imagerel($chain$7$trPrt#)
pdata	ENDS
xdata	SEGMENT
$chain$8$trPrt DD 021H
	DD	@imagerel(trPrt#)
	DD	@imagerel(trPrt#+67)
	DD	@imagerel($unwind$trPrt#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$trPrt DD @imagerel(trPrt#+833)
	DD	@imagerel(trPrt#+900)
	DD	@imagerel($chain$8$trPrt#)
pdata	ENDS
xdata	SEGMENT
$chain$9$trPrt DD 0a0021H
	DD	013f400H
	DD	014e400H
	DD	0177400H
	DD	0186400H
	DD	0195400H
	DD	@imagerel(trPrt#)
	DD	@imagerel(trPrt#+67)
	DD	@imagerel($unwind$trPrt#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$trPrt DD @imagerel(trPrt#+900)
	DD	@imagerel(trPrt#+988)
	DD	@imagerel($chain$9$trPrt#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buff$ = 32
hdl$ = 224
fmt$ = 232
trPrt	PROC NEAR

; 192  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	mov	r11, rsp
	sub	rsp, 216				; 000000d8H

; 193  :     va_list     args;
; 194  :     char        buff[100];
; 195  :     char *      ptr;
; 196  :     char        ch;
; 197  :     uint        ui;
; 198  :     uint_32     ul;
; 199  :     void        *dp;
; 200  :     _trmem_who  who;
; 201  :     char *      start;
; 202  :     char *      xptr;
; 203  :     int         i;
; 204  :     size_t      size;
; 205  : 
; 206  :     va_start( args, fmt );
; 207  :     ptr = buff;
; 208  :     for(;;) {
; 209  :         ch = *fmt++;

	movzx	eax, BYTE PTR [rdx]
	mov	QWORD PTR [r11-8], rbx
	inc	rdx

; 210  :         if( ch == '\0' ) break;

	test	al, al
	mov	QWORD PTR [r11-40], r12
	mov	QWORD PTR [r11-48], r13
	mov	r13, rcx
	lea	r12, QWORD PTR [r11+24]
	lea	rbx, QWORD PTR buff$[rsp]
	mov	QWORD PTR [r11+16], rdx
	je	$LN83@trPrt
	mov	QWORD PTR [r11-56], r14
	mov	QWORD PTR [r11-64], r15
	mov	QWORD PTR [r11-16], rbp
	mov	QWORD PTR [r11-24], rsi
	add	r12, -8
	lea	r14, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [r11-32], rdi
	mov	r15d, 14
$LL28@trPrt:

; 211  :         if( ch == '%' ) {

	cmp	al, 37					; 00000025H
	jne	$LN25@trPrt

; 212  :             ch = *fmt++;

	movsx	r8d, BYTE PTR [rdx]
	inc	rdx

; 213  :             switch( ch ) {

	lea	eax, DWORD PTR [r8-67]
	mov	QWORD PTR fmt$[rsp], rdx
	cmp	eax, 21
	ja	$LN2@trPrt
	cdqe
	mov	ecx, DWORD PTR $LN94@trPrt[r14+rax*4]
	add	rcx, r14
	jmp	rcx
$LN22@trPrt:

; 214  :             case 'W':   /* "a1(a2):" */
; 215  :                 ptr = stpcpy( ptr, va_arg( args, const char * ) );

	mov	rdx, QWORD PTR [r12+8]
	mov	rcx, rbx
	movzx	eax, BYTE PTR [rdx]
	cmp	al, 0
	mov	BYTE PTR [rbx], al
	je	SHORT $LN31@trPrt
	npad	4
$LL32@trPrt:
	movzx	eax, BYTE PTR [rdx+1]
	inc	rdx
	inc	rcx
	cmp	al, 0
	mov	BYTE PTR [rcx], al
	jne	SHORT $LL32@trPrt
$LN31@trPrt:

; 216  :                 who = va_arg( args, _trmem_who );

	mov	rdx, QWORD PTR [r12+16]
	add	r12, 16
	mov	rbx, rcx

; 217  :                 if( who != _TRMEM_NO_ROUTINE ) {

	test	rdx, rdx
	je	SHORT $LN21@trPrt

; 218  :                     *ptr++ = '(';
; 219  :                     ptr = formHex( ptr, (uint_32)who, sizeof( who ) );

	lea	rbx, QWORD PTR [rcx+17]
	mov	BYTE PTR [rcx], 40			; 00000028H
	mov	r8d, 16
	mov	rcx, rbx
$LL37@trPrt:
	mov	eax, edx
	dec	rcx
	shr	edx, 4
	and	eax, 15
	add	r8d, -1					; ffffffffH
	movzx	eax, BYTE PTR $SG1775[rax+r14]
	mov	BYTE PTR [rcx], al
	jne	SHORT $LL37@trPrt

; 220  :                     *ptr++ = ')';

	mov	BYTE PTR [rbx], 41			; 00000029H
	inc	rbx
$LN21@trPrt:

; 221  :                 }
; 222  :                 *ptr++ = ':';

	mov	BYTE PTR [rbx], 58			; 0000003aH
	inc	rbx

; 223  :                 break;

	jmp	$LN1@trPrt
$LN20@trPrt:

; 224  :             case 'C':   /* code pointer */
; 225  :                 who = va_arg( args, _trmem_who );
; 226  :                 ptr = formCodePtr( hdl, ptr, who );

	mov	ecx, DWORD PTR [r12+8]
	add	r12, 8
	mov	r8d, 16
	add	rbx, r8
	mov	rdx, rbx
	npad	13
$LL44@trPrt:
	mov	eax, ecx
	dec	rdx
	shr	ecx, 4
	and	eax, 15
	add	r8d, -1					; ffffffffH
	movzx	eax, BYTE PTR $SG1775[rax+r14]
	mov	BYTE PTR [rdx], al
	jne	SHORT $LL44@trPrt

; 227  :                 break;

	jmp	$LN1@trPrt
$LN19@trPrt:

; 228  :             case 'D':   /* data pointer */
; 229  :                 dp = va_arg( args, void * );
; 230  : #if defined( M_I86LM ) || defined( M_I86HM ) || defined( M_I86CM )
; 231  :                 ptr = formFarPtr( ptr, dp );
; 232  : #else
; 233  :                 ptr = formHex( ptr, (uint_32)dp, sizeof( dp ) );

	mov	ecx, DWORD PTR [r12+8]
	add	r12, 8
	mov	r8d, 16
	add	rbx, r8
	mov	rdx, rbx
	npad	10
$LL49@trPrt:
	mov	eax, ecx
	dec	rdx
	shr	ecx, 4
	and	eax, 15
	add	r8d, -1					; ffffffffH
	movzx	eax, BYTE PTR $SG1775[rax+r14]
	mov	BYTE PTR [rdx], al
	jne	SHORT $LL49@trPrt

; 234  : #endif
; 235  :                 break;

	jmp	$LN1@trPrt
$LN18@trPrt:

; 236  :             case 'S':   /* char * (string) pointer */
; 237  :                 ptr = stpcpy( ptr, va_arg( args, char * ) );

	mov	rcx, QWORD PTR [r12+8]
	add	r12, 8
	movzx	eax, BYTE PTR [rcx]
	cmp	al, 0
	mov	BYTE PTR [rbx], al
	je	$LN1@trPrt
	npad	9
$LL53@trPrt:
	movzx	eax, BYTE PTR [rcx+1]
	inc	rcx
	inc	rbx
	cmp	al, 0
	mov	BYTE PTR [rbx], al
	jne	SHORT $LL53@trPrt

; 238  :                 break;

	jmp	$LN1@trPrt
$LN17@trPrt:

; 239  :             case 'U':   /* unsigned integer */
; 240  :                 ui = va_arg( args, uint );
; 241  :                 ptr = formHex( ptr, (uint_32)ui, sizeof( ui ) );

	mov	ecx, DWORD PTR [r12+8]
	add	r12, 8
	mov	r8d, 8
	add	rbx, r8
	mov	rdx, rbx
	npad	6
$LL58@trPrt:
	mov	eax, ecx
	dec	rdx
	shr	ecx, 4
	and	eax, 15
	add	r8d, -1					; ffffffffH
	movzx	eax, BYTE PTR $SG1775[rax+r14]
	mov	BYTE PTR [rdx], al
	jne	SHORT $LL58@trPrt

; 242  :                 break;

	jmp	$LN1@trPrt
$LN16@trPrt:

; 243  :             case 'L':   /* unsigned long */
; 244  :                 ul = va_arg( args, uint_32 );
; 245  :                 ptr = formHex( ptr, (uint_32)ul, sizeof( ul ) );

	mov	ecx, DWORD PTR [r12+8]
	add	r12, 8
	mov	r8d, 8
	add	rbx, r8
	mov	rdx, rbx
	npad	10
$LL63@trPrt:
	mov	eax, ecx
	dec	rdx
	shr	ecx, 4
	and	eax, 15
	add	r8d, -1					; ffffffffH
	movzx	eax, BYTE PTR $SG1775[rax+r14]
	mov	BYTE PTR [rdx], al
	jne	SHORT $LL63@trPrt

; 246  :                 break;

	jmp	$LN1@trPrt
$LN15@trPrt:

; 247  :             case 'X':   /* 14 bytes of hex data */
; 248  :                 start = va_arg( args, char* );

	mov	rsi, QWORD PTR [r12+8]

; 249  :                 size = va_arg( args, size_t );

	mov	rbp, QWORD PTR [r12+16]
	add	r12, 16

; 250  :                 if( size > 14 ) size = 14;

	cmp	rbp, r15

; 251  :                 xptr = start;

	mov	r10, rsi
	cmova	rbp, r15

; 252  :                 for( i=0; i<14; i++ ) {

	xor	ecx, ecx
	npad	5
$LL13@trPrt:

; 253  :                     if( i < size ) {

	movsxd	rax, ecx
	cmp	rax, rbp
	jae	SHORT $LN10@trPrt

; 254  :                         ptr = formHex( ptr, *xptr, sizeof( char ) );

	movsx	edx, BYTE PTR [r10]
	mov	r9d, 2
	add	rbx, r9
	mov	r8, rbx
	npad	8
$LL68@trPrt:
	mov	eax, edx
	dec	r8
	shr	edx, 4
	and	eax, 15
	add	r9d, -1					; ffffffffH
	movzx	eax, BYTE PTR $SG1775[rax+r14]
	mov	BYTE PTR [r8], al
	jne	SHORT $LL68@trPrt

; 255  :                         xptr++;

	inc	r10

; 256  :                     } else {    // no more to print, so make things line up.

	jmp	SHORT $LN9@trPrt
$LN10@trPrt:

; 257  :                         *ptr = ' ';

	mov	BYTE PTR [rbx], 32			; 00000020H

; 258  :                         *(ptr + 1) = ' ';

	mov	BYTE PTR [rbx+1], 32			; 00000020H

; 259  :                         ptr += 2;

	add	rbx, 2
$LN9@trPrt:

; 260  :                     }
; 261  :                     if( i == 7 ) {

	cmp	ecx, 7
	jne	SHORT $LN12@trPrt

; 262  :                         *ptr = ' ';

	mov	BYTE PTR [rbx], 32			; 00000020H

; 263  :                         ptr++;

	inc	rbx
$LN12@trPrt:
	inc	ecx
	cmp	ecx, r15d
	jl	SHORT $LL13@trPrt

; 264  :                     }
; 265  :                 }
; 266  :                 for( i=0; i < size; i++ ) {

	xor	edi, edi
	test	rbp, rbp
	je	SHORT $LN1@trPrt
$LL7@trPrt:

; 267  :                     if( isprint( *start ) ) {

	movsx	ecx, BYTE PTR [rsi]
	call	isprint
	test	eax, eax
	je	SHORT $LN4@trPrt

; 268  :                         *ptr = *start;

	movzx	eax, BYTE PTR [rsi]
	mov	BYTE PTR [rbx], al

; 269  :                     } else {

	jmp	SHORT $LN3@trPrt
$LN4@trPrt:

; 270  :                         *ptr = '.';

	mov	BYTE PTR [rbx], 46			; 0000002eH
$LN3@trPrt:

; 264  :                     }
; 265  :                 }
; 266  :                 for( i=0; i < size; i++ ) {

	inc	edi

; 271  :                     }
; 272  :                     ptr++;

	inc	rbx

; 273  :                     start++;

	inc	rsi
	movsxd	rax, edi
	cmp	rax, rbp
	jb	SHORT $LL7@trPrt

; 274  :                 }
; 275  :                 break;

	jmp	SHORT $LN1@trPrt
$LN2@trPrt:

; 276  :             default:
; 277  :                 *ptr++ = ch;

	mov	BYTE PTR [rbx], r8b
	inc	rbx

; 278  :                 break;
; 279  :             }
; 280  :         } else {

	jmp	SHORT $LN1@trPrt
$LN25@trPrt:

; 281  :            *ptr++ = ch;

	mov	BYTE PTR [rbx], al
	inc	rbx
$LN1@trPrt:
	mov	rdx, QWORD PTR fmt$[rsp]
	inc	rdx
	mov	al, BYTE PTR [rdx-1]
	mov	QWORD PTR fmt$[rsp], rdx
	test	al, al
	jne	$LL28@trPrt
	mov	r15, QWORD PTR [rsp+152]
	mov	r14, QWORD PTR [rsp+160]
	mov	rdi, QWORD PTR [rsp+184]
	mov	rsi, QWORD PTR [rsp+192]
	mov	rbp, QWORD PTR [rsp+200]
$LN83@trPrt:

; 282  :         }
; 283  :     }
; 284  :     va_end( args );
; 285  :     *ptr++ = '\n';

	mov	BYTE PTR [rbx], 10
	inc	rbx

; 286  :     *ptr = '\0';
; 287  :     hdl->prt_line( hdl->prt_parm, buff, ptr - buff );

	lea	rax, QWORD PTR buff$[rsp]
	mov	BYTE PTR [rbx], 0
	mov	rcx, QWORD PTR [r13+56]
	sub	rbx, rax
	lea	rdx, QWORD PTR buff$[rsp]
	mov	r8, rbx
	call	QWORD PTR [r13+64]
	mov	r13, QWORD PTR [rsp+168]
	mov	r12, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [rsp+208]

; 288  : }

	add	rsp, 216				; 000000d8H
	ret	0
	npad	2
$LN94@trPrt:
	DD	$LN20@trPrt
	DD	$LN19@trPrt
	DD	$LN2@trPrt
	DD	$LN2@trPrt
	DD	$LN2@trPrt
	DD	$LN2@trPrt
	DD	$LN2@trPrt
	DD	$LN2@trPrt
	DD	$LN2@trPrt
	DD	$LN16@trPrt
	DD	$LN2@trPrt
	DD	$LN2@trPrt
	DD	$LN2@trPrt
	DD	$LN2@trPrt
	DD	$LN2@trPrt
	DD	$LN2@trPrt
	DD	$LN18@trPrt
	DD	$LN2@trPrt
	DD	$LN17@trPrt
	DD	$LN2@trPrt
	DD	$LN22@trPrt
	DD	$LN15@trPrt
trPrt	ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$allocEntry DD 050e01H
	DD	09740eH
	DD	083409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$allocEntry DD @imagerel(allocEntry#)
	DD	@imagerel(allocEntry#+72)
	DD	@imagerel($unwind$allocEntry#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
hdl$ = 48
allocEntry PROC NEAR

; 291  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx

; 292  :     entry_ptr   tr;
; 293  : 
; 294  :     tr = (entry_ptr) hdl->alloc( sizeof( entry ) );

	mov	ecx, 40					; 00000028H
	call	QWORD PTR [rdi+24]

; 295  :     if( tr == NULL && ( hdl->flags & _TRMEM_OUT_OF_MEMORY ) ) {

	test	rax, rax
	mov	rbx, rax
	jne	SHORT $LN1@allocEntry
	test	BYTE PTR [rdi+72], 16
	je	SHORT $LN1@allocEntry

; 296  :         trPrt( hdl, MSG_OUT_OF_MEMORY );

	lea	rdx, OFFSET FLAT:MSG_OUT_OF_MEMORY
	mov	rcx, rdi
	call	trPrt

; 297  :     }
; 298  :     return( tr );

	mov	rax, rbx
$LN1@allocEntry:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 299  : }

	add	rsp, 40					; 00000028H
	ret	0
allocEntry ENDP
; Function compile flags: /Ogtpy
tr$ = 8
hdl$ = 16
freeEntry PROC NEAR

; 303  :     hdl->free( tr );
; 304  : }

	rex_jmp	QWORD PTR [rdx+32]
freeEntry ENDP
; Function compile flags: /Ogtpy
tr$ = 8
hdl$ = 16
addToList PROC NEAR

; 308  :     tr->next = hdl->alloc_list;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 309  :     hdl->alloc_list = tr;

	mov	QWORD PTR [rdx], rcx

; 310  : }

	ret	0
addToList ENDP
; Function compile flags: /Ogtpy
mem$ = 8
hdl$ = 16
findOnList PROC NEAR

; 314  :     entry_ptr       walk;
; 315  : 
; 316  :     walk = hdl->alloc_list;

	mov	rax, QWORD PTR [rdx]

; 317  :     while( walk ) {

	test	rax, rax
	je	SHORT $LN2@findOnList
$LL3@findOnList:

; 318  :         if( _PtrCmp( walk->mem, ==, mem ) ) {

	cmp	QWORD PTR [rax+8], rcx
	je	SHORT $LN4@findOnList

; 319  :             return( walk );
; 320  :         }
; 321  :         walk = walk->next;

	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL3@findOnList
$LN2@findOnList:

; 322  :     }
; 323  :     return( NULL );

	xor	eax, eax
$LN4@findOnList:

; 324  : }

	ret	0
findOnList ENDP
; Function compile flags: /Ogtpy
mem$ = 8
hdl$ = 16
removeFromList PROC NEAR

; 329  :     entry_ptr_ptr   walk;
; 330  :     entry_ptr       found;
; 331  : 
; 332  :     walk = &hdl->alloc_list;
; 333  :     while( *walk ) {

	cmp	QWORD PTR [rdx], 0
	je	SHORT $LN2@removeFrom
$LL3@removeFrom:

; 334  :         //printf("removeFromList: item=%p, next=%p, mem=%p\n", *walk, (*walk)->next, (*walk)->mem );
; 335  :         if( _PtrCmp( (*walk)->mem, ==, mem ) ) {

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rax+8], rcx
	je	SHORT $LN7@removeFrom
	cmp	QWORD PTR [rax], 0

; 338  :             return( found );
; 339  :         }
; 340  :         walk = &(*walk)->next;

	mov	rdx, rax
	jne	SHORT $LL3@removeFrom
$LN2@removeFrom:

; 341  :     }
; 342  :     return( NULL );

	xor	eax, eax

; 343  : }

	ret	0
$LN7@removeFrom:

; 336  :             found = *walk;
; 337  :             *walk = found->next;

	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR [rdx], rcx

; 343  : }

	ret	0
removeFromList ENDP
_TEXT	ENDS
PUBLIC	_trmem_open
xdata	SEGMENT
$unwind$_trmem_open DD 092001H
	DD	057420H
	DD	066416H
	DD	07540eH
	DD	083409H
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$_trmem_open DD @imagerel($LN4#)
	DD	@imagerel($LN4#+145)
	DD	@imagerel($unwind$_trmem_open#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
alloc$ = 80
free$ = 88
realloc$ = 96
expand$ = 104
prt_parm$ = 112
prt_line$ = 120
flags$ = 128
_trmem_open PROC NEAR

; 354  : {

$LN4:
	sub	rsp, 72					; 00000048H
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	rbx, rcx
	mov	QWORD PTR [rsp+48], rsi

; 355  :     _trmem_hdl  hdl;
; 356  : 
; 357  :     hdl = (_trmem_hdl) alloc( sizeof( struct _trmem_internal ) );

	mov	ecx, 88					; 00000058H
	mov	QWORD PTR [rsp+40], rdi
	mov	rdi, r9
	mov	rsi, r8
	mov	rbp, rdx
	call	rbx

; 358  :     if( hdl == NULL ) {

	test	rax, rax
	mov	r11, rax
	je	SHORT $LN2@trmem_open
$LN1@trmem_open:

; 359  :         return( NULL );
; 360  :     }
; 361  :     hdl->alloc          = alloc;

	mov	QWORD PTR [rax+24], rbx

; 362  :     hdl->free           = free;

	mov	QWORD PTR [rax+32], rbp

; 363  :     hdl->realloc        = realloc;

	mov	QWORD PTR [rax+40], rsi

; 364  :     hdl->expand         = expand;

	mov	QWORD PTR [rax+48], rdi

; 365  :     hdl->prt_parm       = prt_parm;

	mov	rax, QWORD PTR prt_parm$[rsp]
	mov	QWORD PTR [r11+56], rax

; 366  :     hdl->prt_line       = prt_line;

	mov	rax, QWORD PTR prt_line$[rsp]
	mov	QWORD PTR [r11+64], rax

; 367  :     hdl->flags          = flags;

	mov	eax, DWORD PTR flags$[rsp]
	mov	DWORD PTR [r11+72], eax

; 368  :     hdl->alloc_list     = NULL;

	xor	eax, eax
	mov	QWORD PTR [r11], rax

; 369  :     hdl->mem_used       = 0;

	mov	DWORD PTR [r11+8], eax

; 370  :     hdl->max_mem        = 0;

	mov	DWORD PTR [r11+12], eax

; 371  :     hdl->min_alloc      = 0;

	mov	QWORD PTR [r11+80], rax

; 372  :     hdl->alloc_no       = 0;

	mov	DWORD PTR [r11+16], eax

; 373  :     return( hdl );

	mov	rax, r11
$LN2@trmem_open:
	mov	rdi, QWORD PTR [rsp+40]
	mov	rsi, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+64]

; 374  : }

	add	rsp, 72					; 00000048H
	ret	0
_trmem_open ENDP
_TEXT	ENDS
PUBLIC	_trmem_set_min_alloc
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
size$ = 8
hdl$ = 16
_trmem_set_min_alloc PROC NEAR

; 431  :     hdl->min_alloc = size;

	mov	QWORD PTR [rdx+80], rcx

; 432  : }

	ret	0
_trmem_set_min_alloc ENDP
_TEXT	ENDS
PUBLIC	_trmem_alloc
EXTRN	memset:NEAR
xdata	SEGMENT
$unwind$_trmem_alloc DD 0b8d01H
	DD	06c48dH
	DD	0a6488H
	DD	0b741aH
	DD	095415H
	DD	083410H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$_trmem_alloc DD @imagerel($LN17#)
	DD	@imagerel($LN17#+295)
	DD	@imagerel($unwind$_trmem_alloc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
size$ = 64
who$ = 72
hdl$ = 80
_trmem_alloc PROC NEAR

; 436  : {

$LN17:
	sub	rsp, 56					; 00000038H

; 437  :     void        *mem;
; 438  :     entry_ptr   tr;
; 439  : 
; 440  :     hdl->alloc_no += 1;

	inc	DWORD PTR [r8+16]

; 441  :     if( size == 0 && ( hdl->flags & _TRMEM_ALLOC_SIZE_0 ) ) {

	test	rcx, rcx
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+88], rdi
	mov	rbx, r8
	mov	rdi, rcx
	mov	rbp, rdx
	jne	SHORT $LN6@trmem_allo
	test	BYTE PTR [r8+72], 1
	je	SHORT $LN6@trmem_allo

; 442  :         trPrt( hdl, MSG_SIZE_ZERO, "Alloc", who );

	mov	r9, rdx
	lea	r8, OFFSET FLAT:$SG2056
	lea	rdx, OFFSET FLAT:MSG_SIZE_ZERO
	mov	rcx, rbx
	call	trPrt

; 443  :         return ( NULL );

	xor	eax, eax
	mov	rdi, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 464  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN6@trmem_allo:

; 444  :     } else if( size < hdl->min_alloc ) {

	cmp	rcx, QWORD PTR [r8+80]
	jae	SHORT $LN4@trmem_allo

; 445  :         trPrt( hdl, MSG_MIN_ALLOC, "Alloc", who, size );

	mov	r9, rdx
	mov	QWORD PTR [rsp+32], rcx
	lea	r8, OFFSET FLAT:$SG2060
	lea	rdx, OFFSET FLAT:MSG_MIN_ALLOC
	mov	rcx, rbx
	call	trPrt
$LN4@trmem_allo:

; 446  :     }
; 447  :     mem = hdl->alloc( size + 1 );

	lea	rcx, QWORD PTR [rdi+1]
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+48], r12
	call	QWORD PTR [rbx+24]

; 448  :     if( mem != NULL ) {

	test	rax, rax
	mov	rsi, rax
	je	SHORT $LN1@trmem_allo

; 449  :         MEMSET( mem, ALLOC_BYTE, size + 1 );

	lea	r8, QWORD PTR [rdi+1]
	mov	edx, 165				; 000000a5H
	mov	rcx, rax
	call	memset

; 450  :         tr = allocEntry( hdl );

	mov	ecx, 40					; 00000028H
	call	QWORD PTR [rbx+24]
	test	rax, rax
	mov	r11, rax
	jne	SHORT $LN16@trmem_allo
	test	BYTE PTR [rbx+72], 16
	je	SHORT $LN14@trmem_allo
	lea	rdx, OFFSET FLAT:MSG_OUT_OF_MEMORY
	mov	rcx, rbx
	call	trPrt

; 451  :         if( tr != NULL ) {

	jmp	SHORT $LN14@trmem_allo
$LN16@trmem_allo:

; 452  :             tr->mem = mem;

	mov	QWORD PTR [rax+8], rsi

; 453  :             tr->who = who;

	mov	QWORD PTR [rax+16], rbp

; 454  :             tr->when = hdl->alloc_no;

	mov	eax, DWORD PTR [rbx+16]
	mov	DWORD PTR [r11+32], eax

; 455  :             setSize( tr, size );

	mov	rax, r11
	xor	rax, rsi
	xor	rax, rdi
	xor	rax, rbp
	mov	QWORD PTR [r11+24], rax

; 456  :             addToList( tr, hdl );

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [r11], rax
	mov	QWORD PTR [rbx], r11
$LN14@trmem_allo:

; 457  :         }
; 458  :         hdl->mem_used += size;

	add	DWORD PTR [rbx+8], edi
	mov	eax, DWORD PTR [rbx+8]

; 459  :         if( hdl->mem_used > hdl->max_mem ) {

	cmp	eax, DWORD PTR [rbx+12]
	jbe	SHORT $LN1@trmem_allo

; 460  :             hdl->max_mem = hdl->mem_used;

	mov	DWORD PTR [rbx+12], eax
$LN1@trmem_allo:
	mov	r12, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 461  :         }
; 462  :     }
; 463  :     return( mem );

	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+80]

; 464  : }

	add	rsp, 56					; 00000038H
	ret	0
_trmem_alloc ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$isValidChunk DD 020601H
	DD	030027206H
xdata	ENDS
pdata	SEGMENT
$pdata$isValidChunk DD @imagerel(isValidChunk#)
	DD	@imagerel(isValidChunk#+92)
	DD	@imagerel($unwind$isValidChunk#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
tr$ = 80
rtn$ = 88
who$ = 96
hdl$ = 104
isValidChunk PROC NEAR

; 468  : {

	push	rbx
	sub	rsp, 64					; 00000040H

; 469  :     void *mem;
; 470  :     size_t size;
; 471  :     size_t blk_size;
; 472  : 
; 473  :     size = getSize( tr );

	mov	r10, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx+24]
	mov	r11, QWORD PTR [rcx+16]
	xor	rax, r10
	mov	rbx, r9
	xor	rax, r11
	xor	rax, rcx

; 474  :     mem = tr->mem;
; 475  :     blk_size = *(size_t*)_PtrSub( mem, sizeof( size_t ) );
; 476  : #ifndef __NETWARE__
; 477  : #if 0
; 478  :     if(( blk_size & 1 ) == 0 ) {
; 479  :         trPrt( hdl, MSG_UNDERRUN_ALLOCATION, rtn, who, mem, tr->who, size );
; 480  :         return( 0 );
; 481  :     }
; 482  :     blk_size &= ~1;
; 483  :     if( size > blk_size || ( blk_size - size ) > SIZE_DELTA ) {
; 484  :         trPrt( hdl, MSG_UNDERRUN_ALLOCATION, rtn, who, mem, tr->who, size );
; 485  :         return( 0 );
; 486  :     }
; 487  : #endif
; 488  : #endif
; 489  :     if( *(unsigned char *)_PtrAdd( mem, size ) != ALLOC_BYTE ) {

	cmp	BYTE PTR [r10+rax], 165			; 000000a5H
	je	SHORT $LN1@isValidChu

; 490  :         trPrt( hdl, MSG_OVERRUN_ALLOCATION, rtn, who, mem, tr->who, size );

	mov	QWORD PTR [rsp+48], rax
	mov	r9, r8
	mov	r8, rdx
	mov	QWORD PTR [rsp+40], r11
	lea	rdx, OFFSET FLAT:MSG_OVERRUN_ALLOCATION
	mov	rcx, rbx
	mov	QWORD PTR [rsp+32], r10
	call	trPrt

; 491  :         return( 0 );

	xor	eax, eax

; 494  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN1@isValidChu:

; 492  :     }
; 493  :     return( 1 );

	mov	eax, 1

; 494  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
isValidChunk ENDP
_TEXT	ENDS
PUBLIC	_trmem_validate
xdata	SEGMENT
$unwind$_trmem_validate DD 010401H
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$_trmem_validate DD @imagerel($LN18#)
	DD	@imagerel($LN18#+147)
	DD	@imagerel($unwind$_trmem_validate#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
mem$ = 80
who$ = 88
hdl$ = 96
_trmem_validate PROC NEAR

; 498  : {

$LN18:
	sub	rsp, 72					; 00000048H

; 499  :     entry_ptr tr;
; 500  : 
; 501  :     tr = findOnList( mem, hdl );

	mov	rax, QWORD PTR [r8]
	mov	r10, r8
	mov	r9, rdx
	test	rax, rax
	je	SHORT $LN17@trmem_vali
$LL6@trmem_vali:
	cmp	QWORD PTR [rax+8], rcx
	je	SHORT $LN1@trmem_vali
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL6@trmem_vali
$LN17@trmem_vali:

; 502  :     if( tr == NULL ) {
; 503  :         trPrt( hdl, MSG_UNOWNED_CHUNK, "Validate", who, mem );

	mov	QWORD PTR [rsp+32], rcx
	lea	r8, OFFSET FLAT:$SG2097
	lea	rdx, OFFSET FLAT:MSG_UNOWNED_CHUNK
	mov	rcx, r10
	call	trPrt

; 504  :         return( 0 );

	xor	eax, eax

; 507  : }

	add	rsp, 72					; 00000048H
	ret	0
$LN1@trmem_vali:

; 505  :     }
; 506  :     return( isValidChunk( tr, "Validate", who, hdl ) );

	mov	rdx, QWORD PTR [rax+8]
	mov	r8, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR [rax+24]
	xor	rcx, r8
	xor	rcx, rdx
	xor	rcx, rax
	cmp	BYTE PTR [rdx+rcx], 165			; 000000a5H
	je	SHORT $LN9@trmem_vali
	mov	QWORD PTR [rsp+48], rcx
	mov	QWORD PTR [rsp+40], r8
	mov	QWORD PTR [rsp+32], rdx
	lea	rdx, OFFSET FLAT:MSG_OVERRUN_ALLOCATION
	lea	r8, OFFSET FLAT:$SG2098
	mov	rcx, r10
	call	trPrt
	xor	eax, eax

; 507  : }

	add	rsp, 72					; 00000048H
	ret	0

; 505  :     }
; 506  :     return( isValidChunk( tr, "Validate", who, hdl ) );

$LN9@trmem_vali:
	mov	eax, 1

; 507  : }

	add	rsp, 72					; 00000048H
	ret	0
_trmem_validate ENDP
_TEXT	ENDS
PUBLIC	_trmem_free
xdata	SEGMENT
$unwind$_trmem_free DD 07a401H
	DD	0c64a4H
	DD	0d7411H
	DD	0b340cH
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$_trmem_free DD @imagerel($LN24#)
	DD	@imagerel($LN24#+307)
	DD	@imagerel($unwind$_trmem_free#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
mem$ = 80
who$ = 88
hdl$ = 96
_trmem_free PROC NEAR

; 511  : {

$LN24:
	sub	rsp, 72					; 00000048H

; 512  :     entry_ptr   tr;
; 513  :     size_t      size;
; 514  : 
; 515  :     if( mem == NULL ) {

	test	rcx, rcx
	mov	QWORD PTR [rsp+88], rbx
	mov	QWORD PTR [rsp+104], rdi
	mov	rdi, rcx
	mov	rbx, r8
	jne	SHORT $LN3@trmem_free

; 516  :         if( hdl->flags & _TRMEM_FREE_NULL ) {

	test	BYTE PTR [r8+72], 8
	je	SHORT $LN2@trmem_free

; 517  :             trPrt( hdl, MSG_NULL_PTR, "Free", who );

	mov	r9, rdx
	lea	r8, OFFSET FLAT:$SG2111
	lea	rdx, OFFSET FLAT:MSG_NULL_PTR
	mov	rcx, rbx
	call	trPrt
$LN2@trmem_free:

; 518  :         }
; 519  :         hdl->free( mem );

	xor	ecx, ecx
	mov	rax, QWORD PTR [rbx+32]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+88]

; 534  : }

	add	rsp, 72					; 00000048H
	rex_jmp	rax
$LN3@trmem_free:

; 520  :         return;
; 521  :     }
; 522  :     //printf("trmem_free: item=%p\n", mem );
; 523  :     tr = removeFromList( mem, hdl );

	cmp	QWORD PTR [r8], 0
	mov	rcx, rbx
	je	SHORT $LN23@trmem_free
	npad	7
$LL8@trmem_free:
	mov	rax, QWORD PTR [rcx]
	cmp	QWORD PTR [rax+8], rdi
	je	SHORT $LN21@trmem_free
	cmp	QWORD PTR [rax], 0
	mov	rcx, rax
	jne	SHORT $LL8@trmem_free
$LN23@trmem_free:

; 524  :     if( tr == NULL ) {
; 525  :         trPrt( hdl, MSG_UNOWNED_CHUNK, "Free", who, mem );

	mov	r9, rdx
	lea	r8, OFFSET FLAT:$SG2114
	lea	rdx, OFFSET FLAT:MSG_UNOWNED_CHUNK
	mov	rcx, rbx
	mov	QWORD PTR [rsp+32], rdi
	call	trPrt
	mov	rdi, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+88]

; 534  : }

	add	rsp, 72					; 00000048H
	ret	0
$LN21@trmem_free:
	mov	QWORD PTR [rsp+96], rsi

; 520  :         return;
; 521  :     }
; 522  :     //printf("trmem_free: item=%p\n", mem );
; 523  :     tr = removeFromList( mem, hdl );

	mov	rsi, rax
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 526  :         return;
; 527  :     }
; 528  :     isValidChunk( tr, "Free", who, hdl );

	mov	rcx, QWORD PTR [rsi+8]
	mov	r8, QWORD PTR [rsi+16]
	mov	rax, rcx
	xor	rax, r8
	xor	rax, QWORD PTR [rsi+24]
	xor	rax, rsi
	cmp	BYTE PTR [rcx+rax], 165			; 000000a5H
	je	SHORT $LN11@trmem_free
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], r8
	mov	r9, rdx
	mov	QWORD PTR [rsp+32], rcx
	lea	r8, OFFSET FLAT:$SG2115
	lea	rdx, OFFSET FLAT:MSG_OVERRUN_ALLOCATION
	mov	rcx, rbx
	call	trPrt
$LN11@trmem_free:

; 529  :     size = getSize( tr );

	mov	r8, QWORD PTR [rsi+16]

; 530  :     hdl->mem_used -= size;
; 531  :     MEMSET( mem, FREED_BYTE, size + 1 );

	mov	edx, 189				; 000000bdH
	mov	rcx, rdi
	xor	r8, QWORD PTR [rsi+24]
	xor	r8, QWORD PTR [rsi+8]
	xor	r8, rsi
	sub	DWORD PTR [rbx+8], r8d
	inc	r8
	call	memset

; 532  :     freeEntry( tr, hdl );

	mov	rcx, rsi
	call	QWORD PTR [rbx+32]

; 533  :     hdl->free( mem );

	mov	rcx, rdi
	call	QWORD PTR [rbx+32]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+88]

; 534  : }

	add	rsp, 72					; 00000048H
	ret	0
_trmem_free ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$ChangeAlloc DD 0b1d01H
	DD	09d41dH
	DD	0ac418H
	DD	0b7413H
	DD	0d540eH
	DD	0e3409H
	DD	0e204H
xdata	ENDS
pdata	SEGMENT
$pdata$ChangeAlloc DD @imagerel(ChangeAlloc#)
	DD	@imagerel(ChangeAlloc#+87)
	DD	@imagerel($unwind$ChangeAlloc#)
pdata	ENDS
xdata	SEGMENT
$chain$5$ChangeAlloc DD 020521H
	DD	0c6405H
	DD	@imagerel(ChangeAlloc#)
	DD	@imagerel(ChangeAlloc#+87)
	DD	@imagerel($unwind$ChangeAlloc#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$ChangeAlloc DD @imagerel(ChangeAlloc#+87)
	DD	@imagerel(ChangeAlloc#+807)
	DD	@imagerel($chain$5$ChangeAlloc#)
pdata	ENDS
xdata	SEGMENT
$chain$6$ChangeAlloc DD 021H
	DD	@imagerel(ChangeAlloc#)
	DD	@imagerel(ChangeAlloc#+87)
	DD	@imagerel($unwind$ChangeAlloc#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$ChangeAlloc DD @imagerel(ChangeAlloc#+807)
	DD	@imagerel(ChangeAlloc#+837)
	DD	@imagerel($chain$6$ChangeAlloc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
old$ = 128
size$ = 136
who$ = 144
hdl$ = 152
fn$ = 160
name$ = 168
ChangeAlloc PROC NEAR

; 540  : {

	sub	rsp, 120				; 00000078H
	mov	QWORD PTR [rsp+112], rbx
	mov	QWORD PTR [rsp+104], rbp
	mov	QWORD PTR [rsp+88], rdi
	mov	QWORD PTR [rsp+80], r12
	mov	QWORD PTR [rsp+72], r13

; 541  :     entry_ptr   tr;
; 542  :     void *      new_block;
; 543  :     size_t      old_size;
; 544  : 
; 545  :     if( fn == (void *) _TRMEM_NO_ROUTINE ) {

	mov	r13, QWORD PTR fn$[rsp]
	test	r13, r13
	mov	rbx, r9
	mov	r12, r8
	mov	rbp, rdx
	mov	rdi, rcx
	jne	SHORT $LN17@ChangeAllo

; 546  :         trPrt( hdl, MSG_NO_ROUTINE, name );

	mov	r8, QWORD PTR name$[rsp]
	lea	rdx, OFFSET FLAT:MSG_NO_ROUTINE
	mov	rcx, r9
	call	trPrt

; 547  :         return( NULL );

	xor	eax, eax
	jmp	$LN18@ChangeAllo
$LN17@ChangeAllo:

; 548  :     }
; 549  : 
; 550  :     if( size == 0 ) {

	test	rdx, rdx
	mov	QWORD PTR [rsp+96], rsi
	jne	$LN16@ChangeAllo

; 551  :         if( hdl->flags & _TRMEM_REALLOC_SIZE_0 ) {

	test	BYTE PTR [r9+72], 2
	mov	rbp, QWORD PTR name$[rsp]
	je	SHORT $LN15@ChangeAllo

; 552  :             trPrt( hdl, MSG_SIZE_ZERO, name, who );

	mov	r9, r8
	lea	rdx, OFFSET FLAT:MSG_SIZE_ZERO
	mov	rcx, rbx
	mov	r8, rbp
	call	trPrt
$LN15@ChangeAllo:

; 553  :         }
; 554  :         if( old == NULL ) {

	test	rdi, rdi
	jne	SHORT $LN14@ChangeAllo

; 555  :             if( hdl->flags & _TRMEM_REALLOC_NULL ) {

	test	BYTE PTR [rbx+72], 4
	je	SHORT $LN13@ChangeAllo

; 556  :                 trPrt( hdl, MSG_NULL_PTR, name, who );

	lea	rdx, OFFSET FLAT:MSG_NULL_PTR
	mov	r9, r12
	mov	r8, rbp
	mov	rcx, rbx
	call	trPrt
$LN13@ChangeAllo:

; 557  :             }
; 558  :             return( fn( NULL, 0 ) );

	xor	edx, edx
	xor	ecx, ecx
	call	r13
	jmp	$LN69@ChangeAllo
$LN14@ChangeAllo:

; 559  :         }
; 560  : 
; 561  :         /* old != NULL */
; 562  :         tr = removeFromList( old, hdl );

	cmp	QWORD PTR [rbx], 0
	mov	rcx, rbx
	je	SHORT $LN65@ChangeAllo
	npad	5
$LL22@ChangeAllo:
	mov	rax, QWORD PTR [rcx]
	cmp	QWORD PTR [rax+8], rdi
	je	SHORT $LN61@ChangeAllo
	cmp	QWORD PTR [rax], 0
	mov	rcx, rax
	jne	SHORT $LL22@ChangeAllo
$LN65@ChangeAllo:

; 563  :         if( tr == NULL ) {
; 564  :             trPrt( hdl, MSG_UNOWNED_CHUNK, name, who, old );

	mov	QWORD PTR [rsp+32], rdi
	mov	r9, r12
	mov	r8, rbp
$LN70@ChangeAllo:
	lea	rdx, OFFSET FLAT:MSG_UNOWNED_CHUNK
	mov	rcx, rbx
	call	trPrt

; 565  :             return( NULL );

	xor	eax, eax
	jmp	$LN69@ChangeAllo
$LN61@ChangeAllo:

; 559  :         }
; 560  : 
; 561  :         /* old != NULL */
; 562  :         tr = removeFromList( old, hdl );

	mov	rsi, rax
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 566  :         }
; 567  :         isValidChunk( tr, name, who, hdl );

	mov	rcx, QWORD PTR [rsi+8]
	mov	rdx, QWORD PTR [rsi+16]
	mov	rax, rcx
	xor	rax, rdx
	xor	rax, QWORD PTR [rsi+24]
	xor	rax, rsi
	cmp	BYTE PTR [rcx+rax], 165			; 000000a5H
	je	SHORT $LN25@ChangeAllo
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], rdx
	mov	QWORD PTR [rsp+32], rcx
	lea	rdx, OFFSET FLAT:MSG_OVERRUN_ALLOCATION
	mov	r9, r12
	mov	r8, rbp
	mov	rcx, rbx
	call	trPrt
$LN25@ChangeAllo:

; 568  :         size = getSize( tr );

	mov	r8, QWORD PTR [rsi+16]

; 569  :         hdl->mem_used -= size;
; 570  :         MEMSET( old, FREED_BYTE, size + 1 );

	mov	edx, 189				; 000000bdH
	mov	rcx, rdi
	xor	r8, QWORD PTR [rsi+24]
	xor	r8, QWORD PTR [rsi+8]
	xor	r8, rsi
	sub	DWORD PTR [rbx+8], r8d
	inc	r8
	call	memset

; 571  :         freeEntry( tr, hdl );

	mov	rcx, rsi
	call	QWORD PTR [rbx+32]

; 572  :         return( fn( old, 0 ) );

	xor	edx, edx
	mov	rcx, rdi
	call	r13
	jmp	$LN69@ChangeAllo
$LN16@ChangeAllo:

; 573  :     }
; 574  : 
; 575  :     /* size != 0 */
; 576  :     if( old == NULL ) {

	test	rcx, rcx
	jne	$LN11@ChangeAllo

; 577  :         if( hdl->flags & _TRMEM_REALLOC_NULL ) {

	test	BYTE PTR [r9+72], 4
	je	SHORT $LN10@ChangeAllo

; 578  :             trPrt( hdl, MSG_NULL_PTR, name, who );

	mov	r9, r8
	mov	r8, QWORD PTR name$[rsp]
	lea	rdx, OFFSET FLAT:MSG_NULL_PTR
	mov	rcx, rbx
	call	trPrt
$LN10@ChangeAllo:

; 579  :         }
; 580  :         new_block = fn( NULL, size + 1 );

	lea	rdx, QWORD PTR [rbp+1]
	xor	ecx, ecx
	call	r13

; 581  :         if( new_block != NULL ) {

	test	rax, rax
	mov	rdi, rax
	je	SHORT $LN7@ChangeAllo

; 582  :             MEMSET( new_block, ALLOC_BYTE, size + 1 );

	lea	r8, QWORD PTR [rbp+1]
	mov	edx, 165				; 000000a5H
	mov	rcx, rax
	call	memset

; 583  :             tr = allocEntry( hdl );

	mov	ecx, 40					; 00000028H
	call	QWORD PTR [rbx+24]
	test	rax, rax
	mov	r11, rax
	jne	SHORT $LN68@ChangeAllo
	test	BYTE PTR [rbx+72], 16
	je	SHORT $LN39@ChangeAllo
	lea	rdx, OFFSET FLAT:MSG_OUT_OF_MEMORY
	mov	rcx, rbx
	call	trPrt

; 584  :             if( tr != NULL ) {

	jmp	SHORT $LN39@ChangeAllo
$LN68@ChangeAllo:

; 585  :                 tr->mem = new_block;

	mov	QWORD PTR [rax+8], rdi

; 586  :                 tr->who = who;

	mov	QWORD PTR [rax+16], r12

; 587  :                 setSize( tr, size );

	xor	rax, rdi
	xor	rax, rbp
	xor	rax, r12
	mov	QWORD PTR [r11+24], rax

; 588  :                 addToList( tr, hdl );

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [r11], rax
	mov	QWORD PTR [rbx], r11
$LN39@ChangeAllo:

; 589  :             }
; 590  :             hdl->mem_used += size;

	add	DWORD PTR [rbx+8], ebp
	mov	eax, DWORD PTR [rbx+8]

; 591  :             if( hdl->mem_used > hdl->max_mem ) {

	cmp	eax, DWORD PTR [rbx+12]
	jbe	SHORT $LN7@ChangeAllo

; 592  :                 hdl->max_mem = hdl->mem_used;

	mov	DWORD PTR [rbx+12], eax
$LN7@ChangeAllo:

; 593  :             }
; 594  :         }
; 595  :         return( new_block );

	mov	rax, rdi
	jmp	$LN69@ChangeAllo
$LN11@ChangeAllo:

; 596  :     }
; 597  : 
; 598  :     /* old != NULL && size != 0 */
; 599  :     tr = removeFromList( old, hdl );

	cmp	QWORD PTR [r9], 0
	mov	rcx, rbx
	je	SHORT $LN66@ChangeAllo
$LL43@ChangeAllo:
	mov	rax, QWORD PTR [rcx]
	cmp	QWORD PTR [rax+8], rdi
	je	SHORT $LN62@ChangeAllo
	cmp	QWORD PTR [rax], 0
	mov	rcx, rax
	jne	SHORT $LL43@ChangeAllo
$LN66@ChangeAllo:

; 600  :     if( tr == NULL ) {
; 601  :         trPrt( hdl, MSG_UNOWNED_CHUNK, name, who, old );

	mov	r9, r8
	mov	r8, QWORD PTR name$[rsp]
	mov	QWORD PTR [rsp+32], rdi

; 602  :         return( NULL );

	jmp	$LN70@ChangeAllo
$LN62@ChangeAllo:

; 596  :     }
; 597  : 
; 598  :     /* old != NULL && size != 0 */
; 599  :     tr = removeFromList( old, hdl );

	mov	rsi, rax
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 603  :     }
; 604  :     if( !isValidChunk( tr, name, who, hdl ) ) {

	mov	rcx, QWORD PTR [rsi+8]
	mov	rax, QWORD PTR [rsi+24]
	mov	rdx, QWORD PTR [rsi+16]
	xor	rax, rcx
	xor	rax, rdx
	xor	rax, rsi
	cmp	BYTE PTR [rcx+rax], 165			; 000000a5H
	je	SHORT $LN5@ChangeAllo
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], rdx
	mov	r9, r8
	mov	r8, QWORD PTR name$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	lea	rdx, OFFSET FLAT:MSG_OVERRUN_ALLOCATION
	mov	rcx, rbx
	call	trPrt
	xor	eax, eax
	jmp	$LN69@ChangeAllo
$LN5@ChangeAllo:

; 605  :         return( NULL );
; 606  :     }
; 607  :     new_block = fn( old, size + 1 );

	lea	rdx, QWORD PTR [rbp+1]
	mov	rcx, rdi
	call	r13

; 608  :     if( new_block == NULL ) {

	test	rax, rax
	mov	r13, rax
	jne	SHORT $LN4@ChangeAllo

; 609  :         addToList( tr, hdl );   /* put back on list without change */

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rsi], rax
	mov	QWORD PTR [rbx], rsi
	xor	eax, eax
	jmp	SHORT $LN69@ChangeAllo
$LN4@ChangeAllo:

; 610  :         return( new_block );
; 611  :     }
; 612  :     old_size = getSize( tr );

	mov	rdi, QWORD PTR [rsi+24]
	xor	rdi, QWORD PTR [rsi+8]
	xor	rdi, QWORD PTR [rsi+16]
	xor	rdi, rsi

; 613  :     if( size > old_size ) {

	cmp	rbp, rdi
	jbe	SHORT $LN3@ChangeAllo

; 614  :         MEMSET(_PtrAdd( new_block, old_size ), ALLOC_BYTE, size + 1 - old_size);

	mov	r8, rbp
	lea	rcx, QWORD PTR [rdi+rax]
	mov	edx, 165				; 000000a5H
	sub	r8, rdi
	inc	r8
	call	memset

; 615  :     } else {

	jmp	SHORT $LN2@ChangeAllo
$LN3@ChangeAllo:

; 616  :         *(unsigned char *)_PtrAdd( new_block, size ) = ALLOC_BYTE;

	mov	BYTE PTR [rax+rbp], 165			; 000000a5H
$LN2@ChangeAllo:

; 617  :     }
; 618  :     hdl->mem_used -= old_size;
; 619  :     hdl->mem_used += size;

	mov	eax, ebp
	sub	eax, edi
	add	DWORD PTR [rbx+8], eax
	mov	eax, DWORD PTR [rbx+8]

; 620  :     if( hdl->mem_used > hdl->max_mem ) {

	cmp	eax, DWORD PTR [rbx+12]
	jbe	SHORT $LN1@ChangeAllo

; 621  :         hdl->max_mem = hdl->mem_used;

	mov	DWORD PTR [rbx+12], eax
$LN1@ChangeAllo:

; 622  :     }
; 623  :     tr->mem = new_block;

	mov	QWORD PTR [rsi+8], r13

; 624  :     tr->who = who;

	mov	QWORD PTR [rsi+16], r12

; 625  :     setSize( tr, size );

	mov	rax, rsi
	xor	rax, r13
	xor	rax, rbp
	xor	rax, r12
	mov	QWORD PTR [rsi+24], rax

; 626  :     addToList( tr, hdl );

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rsi], rax
	mov	QWORD PTR [rbx], rsi

; 627  :     return( new_block );

	mov	rax, r13
$LN69@ChangeAllo:
	mov	rsi, QWORD PTR [rsp+96]
$LN18@ChangeAllo:
	mov	r13, QWORD PTR [rsp+72]
	mov	r12, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+112]

; 628  : }

	add	rsp, 120				; 00000078H
	ret	0
ChangeAlloc ENDP
_TEXT	ENDS
PUBLIC	_trmem_realloc
xdata	SEGMENT
$unwind$_trmem_realloc DD 010401H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$_trmem_realloc DD @imagerel($LN3#)
	DD	@imagerel($LN3#+35)
	DD	@imagerel($unwind$_trmem_realloc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
old$ = 64
size$ = 72
who$ = 80
hdl$ = 88
_trmem_realloc PROC NEAR

; 632  : {

$LN3:
	sub	rsp, 56					; 00000038H

; 633  :     return( ChangeAlloc( old, size, who, hdl, hdl->realloc, "Realloc" ) );

	lea	rax, OFFSET FLAT:$SG2181
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR [r9+40]
	mov	QWORD PTR [rsp+32], rax
	call	ChangeAlloc

; 634  : }

	add	rsp, 56					; 00000038H
	ret	0
_trmem_realloc ENDP
_TEXT	ENDS
PUBLIC	_trmem_expand
xdata	SEGMENT
$unwind$_trmem_expand DD 010401H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$_trmem_expand DD @imagerel($LN3#)
	DD	@imagerel($LN3#+35)
	DD	@imagerel($unwind$_trmem_expand#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
old$ = 64
size$ = 72
who$ = 80
hdl$ = 88
_trmem_expand PROC NEAR

; 638  : {

$LN3:
	sub	rsp, 56					; 00000038H

; 639  :     return( ChangeAlloc( old, size, who, hdl, hdl->expand, "Expand" ) );

	lea	rax, OFFSET FLAT:$SG2191
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR [r9+48]
	mov	QWORD PTR [rsp+32], rax
	call	ChangeAlloc

; 640  : }

	add	rsp, 56					; 00000038H
	ret	0
_trmem_expand ENDP
_TEXT	ENDS
PUBLIC	_trmem_strdup
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$_trmem_strdup DD 071601H
	DD	097416H
	DD	08640eH
	DD	073409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$_trmem_strdup DD @imagerel($LN5#)
	DD	@imagerel($LN5#+94)
	DD	@imagerel($unwind$_trmem_strdup#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
str$ = 48
who$ = 56
hdl$ = 64
_trmem_strdup PROC NEAR

; 644  : {

$LN5:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, rcx
	mov	QWORD PTR [rsp+72], rdi

; 645  :     char    *mem;
; 646  :     size_t  len;
; 647  : 
; 648  :     len = strlen( str ) + 1;

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rsi
	repne scasb
	not	rcx
	lea	rbx, QWORD PTR [rcx-1]

; 649  :     mem = _trmem_alloc( len, who, hdl );

	call	_trmem_alloc

; 650  :     if( mem )

	test	rax, rax
	mov	rdi, rax
	je	SHORT $LN1@trmem_strd

; 651  :         memcpy( mem, str, len );

	lea	r8, QWORD PTR [rbx+1]
	mov	rdx, rsi
	mov	rcx, rax
	call	memcpy

; 652  :     return( mem );

	mov	rax, rdi
$LN1@trmem_strd:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 653  : }

	add	rsp, 40					; 00000028H
	ret	0
_trmem_strdup ENDP
_TEXT	ENDS
PUBLIC	_trmem_chk_range
xdata	SEGMENT
$unwind$_trmem_chk_range DD 020601H
	DD	030027206H
xdata	ENDS
pdata	SEGMENT
$pdata$_trmem_chk_range DD @imagerel($LN22#)
	DD	@imagerel($LN22#+267)
	DD	@imagerel($unwind$_trmem_chk_range#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
start$ = 80
len$ = 88
who$ = 96
hdl$ = 104
_trmem_chk_range PROC NEAR

; 658  : {

$LN22:
	push	rbx
	sub	rsp, 64					; 00000040H
	mov	rbx, r9
	mov	r9, rdx
	mov	rdx, rcx

; 659  :     entry_ptr   tr;
; 660  :     void        *end;
; 661  :     void        *end_of_mem;
; 662  : 
; 663  :     tr = hdl->alloc_list;

	mov	r10, QWORD PTR [rbx]

; 664  :     for(;;) {
; 665  :         if( tr == 0 ) {

	test	r10, r10
	je	SHORT $LN19@trmem_chk_
	npad	9
$LL5@trmem_chk_:

; 669  :         }
; 670  :         end_of_mem = _PtrAdd( tr->mem, getSize( tr ) );

	mov	rax, QWORD PTR [r10+8]
	mov	r11, QWORD PTR [r10+24]
	xor	r11, QWORD PTR [r10+16]
	xor	r11, rax
	xor	r11, r10
	add	r11, rax

; 671  :         if( _PtrCmp( start, >=, tr->mem ) &&
; 672  :             _PtrCmp( start, < , end_of_mem ) ) break;

	cmp	rcx, rax
	jb	SHORT $LN2@trmem_chk_
	cmp	rcx, r11
	jb	SHORT $LN20@trmem_chk_
$LN2@trmem_chk_:

; 673  :         tr = tr->next;

	mov	r10, QWORD PTR [r10]
	test	r10, r10
	jne	SHORT $LL5@trmem_chk_
$LN19@trmem_chk_:

; 666  :             trPrt( hdl, MSG_NOT_IN_ALLOCATION, "ChkRange", who,
; 667  :                 start );

	mov	r9, r8
	mov	QWORD PTR [rsp+32], rcx
	lea	rdx, OFFSET FLAT:MSG_NOT_IN_ALLOCATION
	lea	r8, OFFSET FLAT:$SG2219
	mov	rcx, rbx
	call	trPrt

; 668  :             return( 0 );

	xor	eax, eax

; 682  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN20@trmem_chk_:

; 674  :     }
; 675  :     end = _PtrAdd( start, len );

	lea	rax, QWORD PTR [rcx+r9]

; 676  :     if( _PtrCmp( end, >, end_of_mem ) ) {
; 677  :         trPrt( hdl, MSG_OVERRUN_2, "ChkRange", who,
; 678  :             start, len, tr->mem, getSize( tr ) );

	mov	rcx, QWORD PTR [r10+8]
	cmp	rax, r11
	mov	rax, QWORD PTR [r10+24]
	jbe	SHORT $LN1@trmem_chk_
	xor	rax, QWORD PTR [r10+16]
	xor	rax, rcx
	xor	rax, r10
	mov	QWORD PTR [rsp+56], rax
	mov	QWORD PTR [rsp+48], rcx
	mov	QWORD PTR [rsp+40], r9
	mov	QWORD PTR [rsp+32], rdx
	mov	r9, r8
	lea	r8, OFFSET FLAT:$SG2232
	lea	rdx, OFFSET FLAT:MSG_OVERRUN_2
	mov	rcx, rbx
	call	trPrt

; 679  :         return( 0 );

	xor	eax, eax

; 682  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN1@trmem_chk_:

; 680  :     }
; 681  :     return( isValidChunk( tr, "ChkRange", who, hdl ) );

	mov	rdx, QWORD PTR [r10+16]
	xor	rax, rcx
	xor	rax, rdx
	xor	rax, r10
	cmp	BYTE PTR [rcx+rax], 165			; 000000a5H
	je	SHORT $LN12@trmem_chk_
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], rdx
	mov	r9, r8
	mov	QWORD PTR [rsp+32], rcx
	lea	rdx, OFFSET FLAT:MSG_OVERRUN_ALLOCATION
	lea	r8, OFFSET FLAT:$SG2233
	mov	rcx, rbx
	call	trPrt
	xor	eax, eax

; 682  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0

; 680  :     }
; 681  :     return( isValidChunk( tr, "ChkRange", who, hdl ) );

$LN12@trmem_chk_:
	mov	eax, 1

; 682  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
_trmem_chk_range ENDP
_TEXT	ENDS
PUBLIC	_trmem_prt_usage
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
hdl$ = 8
_trmem_prt_usage PROC NEAR

; 687  :     trPrt( hdl, MSG_PRT_USAGE, hdl->mem_used, hdl->max_mem );

	mov	r9d, DWORD PTR [rcx+12]
	mov	r8d, DWORD PTR [rcx+8]
	lea	rdx, OFFSET FLAT:MSG_PRT_USAGE

; 688  : }

	jmp	trPrt
_trmem_prt_usage ENDP
_TEXT	ENDS
PUBLIC	_trmem_prt_list
xdata	SEGMENT
$unwind$_trmem_prt_list DD 073e01H
	DD	0d743eH
	DD	0c6411H
	DD	0b3409H
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$_trmem_prt_list DD @imagerel($LN13#)
	DD	@imagerel($LN13#+208)
	DD	@imagerel($unwind$_trmem_prt_list#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
hdl$ = 80
_trmem_prt_list PROC NEAR

; 692  : {

$LN13:
	sub	rsp, 72					; 00000048H
	mov	QWORD PTR [rsp+88], rbx

; 693  :     entry_ptr   tr;
; 694  :     unsigned    chunks;
; 695  :     size_t      size;
; 696  : 
; 697  :     tr = hdl->alloc_list;

	mov	rbx, QWORD PTR [rcx]
	mov	QWORD PTR [rsp+96], rsi

; 698  :     if( tr == 0 ) return( 0 );

	test	rbx, rbx
	mov	rsi, rcx
	jne	SHORT $LN5@trmem_prt_
	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [rsp+88]

; 719  : }

	add	rsp, 72					; 00000048H
	ret	0
$LN5@trmem_prt_:

; 699  :     _trmem_prt_usage( hdl );

	mov	r9d, DWORD PTR [rcx+12]
	mov	r8d, DWORD PTR [rcx+8]
	lea	rdx, OFFSET FLAT:MSG_PRT_USAGE
	mov	QWORD PTR [rsp+104], rdi
	call	trPrt

; 700  :     trPrt( hdl, MSG_PRT_LIST_1 );

	lea	rdx, OFFSET FLAT:MSG_PRT_LIST_1
	mov	rcx, rsi
	call	trPrt

; 701  :     trPrt( hdl, MSG_PRT_LIST_2 );

	lea	rdx, OFFSET FLAT:MSG_PRT_LIST_2
	mov	rcx, rsi
	call	trPrt

; 702  :     chunks = 0;

	xor	edi, edi
	npad	13
$LL4@trmem_prt_:

; 703  :     do {
; 704  :         size = getSize( tr );

	mov	r8, QWORD PTR [rbx+16]
	mov	rcx, QWORD PTR [rbx+24]
	xor	rcx, r8
	xor	rcx, rbx
	xor	rcx, QWORD PTR [rbx+8]

; 705  :         if( chunks < 20 ) {

	cmp	edi, 20
	jae	SHORT $LN1@trmem_prt_

; 706  :             trPrt( hdl
; 707  :                  , MSG_PRT_LIST_3
; 708  :                  , tr->who
; 709  :                  , tr->mem
; 710  :                  , size
; 711  :                  , tr->when
; 712  :                  , tr->mem
; 713  :                  , size );

	mov	r9, QWORD PTR [rbx+8]
	mov	eax, DWORD PTR [rbx+32]
	mov	QWORD PTR [rsp+56], rcx
	mov	QWORD PTR [rsp+48], r9
	mov	DWORD PTR [rsp+40], eax
	mov	QWORD PTR [rsp+32], rcx
	lea	rdx, OFFSET FLAT:MSG_PRT_LIST_3
	mov	rcx, rsi
	call	trPrt
$LN1@trmem_prt_:

; 714  :         }
; 715  :         ++chunks;
; 716  :         tr = tr->next;

	mov	rbx, QWORD PTR [rbx]
	inc	edi

; 717  :     } while( tr );

	test	rbx, rbx
	jne	SHORT $LL4@trmem_prt_
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [rsp+88]

; 718  :     return( chunks );

	mov	eax, edi
	mov	rdi, QWORD PTR [rsp+104]

; 719  : }

	add	rsp, 72					; 00000048H
	ret	0
_trmem_prt_list ENDP
_TEXT	ENDS
PUBLIC	_trmem_msize
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
mem$ = 8
hdl$ = 16
_trmem_msize PROC NEAR

; 722  : /************************************************/
; 723  :     return( getSize( findOnList( mem, hdl ) ) );

	mov	r8, QWORD PTR [rdx]
	test	r8, r8
	je	SHORT $LN4@trmem_msiz
$LL5@trmem_msiz:
	cmp	QWORD PTR [r8+8], rcx
	je	SHORT $LN6@trmem_msiz
	mov	r8, QWORD PTR [r8]
	test	r8, r8
	jne	SHORT $LL5@trmem_msiz
$LN4@trmem_msiz:
	xor	r8d, r8d
$LN6@trmem_msiz:
	mov	rax, QWORD PTR [r8+24]
	xor	rax, QWORD PTR [r8+16]
	xor	rax, QWORD PTR [r8+8]
	xor	rax, r8

; 724  : }

	ret	0
_trmem_msize ENDP
_TEXT	ENDS
PUBLIC	_trmem_get_current_usage
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
hdl$ = 8
_trmem_get_current_usage PROC NEAR

; 727  : /********************************************************/
; 728  :     return hdl->mem_used;

	mov	eax, DWORD PTR [rcx+8]

; 729  : }

	ret	0
_trmem_get_current_usage ENDP
_TEXT	ENDS
PUBLIC	_trmem_get_peak_usage
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
hdl$ = 8
_trmem_get_peak_usage PROC NEAR

; 732  : /*****************************************************/
; 733  :     return hdl->max_mem;

	mov	eax, DWORD PTR [rcx+12]

; 734  : }

	ret	0
_trmem_get_peak_usage ENDP
_TEXT	ENDS
PUBLIC	_trmem_guess_who
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
p$ = 8
_trmem_guess_who PROC NEAR

; 740  :     return( (_trmem_who)*((void **)p-1) );

	mov	rax, QWORD PTR [rcx-8]

; 741  : }

	ret	0
_trmem_guess_who ENDP
_TEXT	ENDS
PUBLIC	_trmem_whoami
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_trmem_whoami PROC NEAR

; 749  :     return 0;

	xor	eax, eax

; 750  : }

	ret	0
_trmem_whoami ENDP
_TEXT	ENDS
EXTRN	fwrite:NEAR
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
fh$ = 8
buf$ = 16
size$ = 24
memLine	PROC NEAR

; 765  : {

	mov	rax, rdx

; 766  :     //fwrite( "***",1, 3, stderr );
; 767  :     //fwrite( buf, 1, size, stderr );
; 768  :     fwrite( buf, 1, size, fh );

	mov	r9, rcx
	mov	r8d, r8d
	mov	rcx, rax
	mov	edx, 1

; 769  : }

	jmp	fwrite
memLine	ENDP
_TEXT	ENDS
PUBLIC	tm_Init
EXTRN	_errno:NEAR
EXTRN	exit:NEAR
EXTRN	printf:NEAR
EXTRN	free:NEAR
EXTRN	malloc:NEAR
EXTRN	fopen:NEAR
xdata	SEGMENT
$unwind$tm_Init DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$tm_Init DD @imagerel($LN10#)
	DD	@imagerel($LN10#+210)
	DD	@imagerel($unwind$tm_Init#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
tm_Init	PROC NEAR

; 773  : {

$LN10:
	push	rbx
	sub	rsp, 32					; 00000020H

; 774  :     if ( FileTrmem = fopen( TRMEM_LOGFN, "w" ) ) {

	lea	rdx, OFFSET FLAT:$SG2281
	lea	rcx, OFFSET FLAT:$SG2282
	call	fopen
	test	rax, rax
	mov	rbx, rax
	mov	QWORD PTR FileTrmem, rax
	je	$LN3@tm_Init

; 775  :         //hTrmem = _trmem_open( malloc, free, realloc, _expand, memFile, memLine,
; 776  :         hTrmem = _trmem_open( malloc, free, _TRMEM_NO_REALLOC, _TRMEM_NO_REALLOC, FileTrmem, memLine,
; 777  :                   _TRMEM_ALLOC_SIZE_0 | _TRMEM_FREE_NULL | _TRMEM_OUT_OF_MEMORY | _TRMEM_CLOSE_CHECK_FREE );

	mov	ecx, 88					; 00000058H
	call	malloc
	test	rax, rax
	mov	r11, rax
	je	SHORT $LN7@tm_Init
$LN6@tm_Init:
	lea	rax, OFFSET FLAT:malloc
	lea	rcx, OFFSET FLAT:memLine
	mov	QWORD PTR [r11+56], rbx
	mov	QWORD PTR [r11+24], rax
	lea	rax, OFFSET FLAT:free
	mov	QWORD PTR [r11+64], rcx
	mov	QWORD PTR [r11+32], rax
	xor	eax, eax
	mov	DWORD PTR [r11+72], 57			; 00000039H
	mov	QWORD PTR [r11+40], rax
	mov	QWORD PTR [r11+48], rax
	mov	QWORD PTR [r11], rax
	mov	DWORD PTR [r11+8], eax
	mov	DWORD PTR [r11+12], eax
	mov	QWORD PTR [r11+80], rax
	mov	DWORD PTR [r11+16], eax
	mov	rax, r11
$LN7@tm_Init:

; 778  :         if( hTrmem == NULL ) {

	test	rax, rax
	mov	QWORD PTR hTrmem, rax
	jne	SHORT $LN1@tm_Init

; 779  :             printf("tm_Init: _trmem_open() failed\n" );

	lea	rcx, OFFSET FLAT:$SG2287
	call	printf

; 780  :             exit( EXIT_FAILURE );

	mov	ecx, 1
	call	exit
	int	3
$LN3@tm_Init:

; 781  :         }
; 782  :     } else {
; 783  :         printf("tm_Init: fopen(\"" TRMEM_LOGFN "\") failed [%u]\n", errno );

	call	_errno
	lea	rcx, OFFSET FLAT:$SG2289
	mov	edx, DWORD PTR [rax]
	call	printf

; 784  :         exit( EXIT_FAILURE );

	mov	ecx, 1
	call	exit
	int	3
$LN1@tm_Init:

; 785  :     }
; 786  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN9@tm_Init:
tm_Init	ENDP
_TEXT	ENDS
PUBLIC	_trmem_validate_all
xdata	SEGMENT
$unwind$_trmem_validate_all DD 051101H
	DD	0d7411H
	DD	0c3409H
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$_trmem_validate_all DD @imagerel($LN15#)
	DD	@imagerel($LN15#+127)
	DD	@imagerel($unwind$_trmem_validate_all#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
hdl$ = 80
_trmem_validate_all PROC NEAR

; 378  : {

$LN15:
	sub	rsp, 72					; 00000048H
	mov	QWORD PTR [rsp+96], rbx

; 379  :     entry_ptr   walk;
; 380  :     int result = 1;
; 381  : 
; 382  :     walk = hdl->alloc_list;

	mov	rbx, QWORD PTR [rcx]
	mov	QWORD PTR [rsp+104], rdi

; 383  :     while( walk ) {

	test	rbx, rbx
	mov	rdi, rcx
	mov	edx, 1
	je	SHORT $LN14@trmem_vali@2
	npad	2
$LL3@trmem_vali@2:

; 384  :         //printf("trmem_validate_all: item=%p, next=%p, mem=%p\n", walk, walk->next, walk->mem );
; 385  :         if( !isValidChunk( walk, "Validate", 0, hdl ) ) {

	mov	r8, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rbx+24]
	mov	rcx, QWORD PTR [rbx+16]
	xor	rax, r8
	xor	rax, rcx
	xor	rax, rbx
	cmp	BYTE PTR [r8+rax], 165			; 000000a5H
	je	SHORT $LN1@trmem_vali@2
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], rcx
	mov	QWORD PTR [rsp+32], r8
	lea	r8, OFFSET FLAT:$SG2022
	lea	rdx, OFFSET FLAT:MSG_OVERRUN_ALLOCATION
	xor	r9d, r9d
	mov	rcx, rdi
	call	trPrt

; 386  :             result = 0;

	xor	edx, edx
$LN1@trmem_vali@2:

; 387  :         }
; 388  :         walk = walk->next;

	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL3@trmem_vali@2
$LN14@trmem_vali@2:
	mov	rdi, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+96]

; 389  :     }
; 390  :     return result;

	mov	eax, edx

; 391  : }

	add	rsp, 72					; 00000048H
	ret	0
_trmem_validate_all ENDP
_TEXT	ENDS
PUBLIC	_trmem_close
xdata	SEGMENT
$unwind$_trmem_close DD 091e01H
	DD	09d41eH
	DD	0f7413H
	DD	0e640eH
	DD	0c3409H
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$_trmem_close DD @imagerel($LN39#)
	DD	@imagerel($LN39#+55)
	DD	@imagerel($unwind$_trmem_close#)
pdata	ENDS
xdata	SEGMENT
$chain$5$_trmem_close DD 040a21H
	DD	0ac40aH
	DD	0d5405H
	DD	@imagerel($LN39#)
	DD	@imagerel($LN39#+55)
	DD	@imagerel($unwind$_trmem_close#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$_trmem_close DD @imagerel($LN39#+55)
	DD	@imagerel($LN39#+331)
	DD	@imagerel($chain$5$_trmem_close#)
pdata	ENDS
xdata	SEGMENT
$chain$6$_trmem_close DD 021H
	DD	@imagerel($LN39#)
	DD	@imagerel($LN39#+55)
	DD	@imagerel($unwind$_trmem_close#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$_trmem_close DD @imagerel($LN39#+331)
	DD	@imagerel($LN39#+420)
	DD	@imagerel($chain$6$_trmem_close#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
hdl$ = 96
_trmem_close PROC NEAR

; 395  : {

$LN39:
	sub	rsp, 88					; 00000058H
	mov	QWORD PTR [rsp+96], rbx
	mov	QWORD PTR [rsp+112], rsi
	mov	QWORD PTR [rsp+120], rdi

; 396  :     uint        chunks;
; 397  :     uint_32     mem_used;
; 398  :     entry_ptr   walk;
; 399  :     entry_ptr   next;
; 400  : 
; 401  :     chunks = 0;

	xor	esi, esi

; 402  :     if( hdl->flags & _TRMEM_CLOSE_CHECK_FREE ) {

	test	BYTE PTR [rcx+72], 32			; 00000020H
	mov	QWORD PTR [rsp+72], r13
	mov	rdi, rcx
	je	$LN7@trmem_clos

; 403  :         mem_used = hdl->mem_used;
; 404  :         walk = hdl->alloc_list;

	mov	rbx, QWORD PTR [rcx]
	mov	r13d, DWORD PTR [rcx+8]

; 405  :         while( walk ) {

	test	rbx, rbx
	je	$LN1@trmem_clos
	mov	QWORD PTR [rsp+104], rbp
	mov	QWORD PTR [rsp+80], r12
$LL6@trmem_clos:

; 406  :             //printf("trmem_close: item=%p, next=%p, mem=%p\n", walk, walk->next, walk->mem );
; 407  :             next = walk->next;

	mov	r12, QWORD PTR [rbx]

; 408  :             ++chunks;
; 409  :             _trmem_free( walk->mem, _TRMEM_NO_ROUTINE, hdl );

	mov	rbx, QWORD PTR [rbx+8]
	inc	esi
	test	rbx, rbx
	jne	SHORT $LN12@trmem_clos
	test	BYTE PTR [rdi+72], 8
	je	SHORT $LN11@trmem_clos
	lea	r8, OFFSET FLAT:$SG2111
	lea	rdx, OFFSET FLAT:MSG_NULL_PTR
	xor	r9d, r9d
	mov	rcx, rdi
	call	trPrt
$LN11@trmem_clos:
	xor	ecx, ecx
	call	QWORD PTR [rdi+32]
	jmp	$LN13@trmem_clos
$LN12@trmem_clos:
	cmp	QWORD PTR [rdi], 0
	mov	rcx, rdi
	je	SHORT $LN38@trmem_clos
$LL17@trmem_clos:
	mov	rax, QWORD PTR [rcx]
	cmp	QWORD PTR [rax+8], rbx
	je	SHORT $LN34@trmem_clos
	cmp	QWORD PTR [rax], 0
	mov	rcx, rax
	jne	SHORT $LL17@trmem_clos
$LN38@trmem_clos:
	lea	r8, OFFSET FLAT:$SG2114
	lea	rdx, OFFSET FLAT:MSG_UNOWNED_CHUNK
	xor	r9d, r9d
	mov	rcx, rdi
	mov	QWORD PTR [rsp+32], rbx
	call	trPrt
	jmp	$LN13@trmem_clos
$LN34@trmem_clos:
	mov	rbp, rax
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
	mov	rcx, QWORD PTR [rbp+8]
	mov	rax, QWORD PTR [rbp+24]
	mov	rdx, QWORD PTR [rbp+16]
	xor	rax, rcx
	xor	rax, rdx
	xor	rax, rbp
	cmp	BYTE PTR [rcx+rax], 165			; 000000a5H
	je	SHORT $LN20@trmem_clos
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], rdx
	mov	QWORD PTR [rsp+32], rcx
	lea	rdx, OFFSET FLAT:MSG_OVERRUN_ALLOCATION
	lea	r8, OFFSET FLAT:$SG2115
	xor	r9d, r9d
	mov	rcx, rdi
	call	trPrt
$LN20@trmem_clos:
	mov	r8, QWORD PTR [rbp+24]
	mov	edx, 189				; 000000bdH
	mov	rcx, rbx
	xor	r8, QWORD PTR [rbp+8]
	xor	r8, QWORD PTR [rbp+16]
	xor	r8, rbp
	sub	DWORD PTR [rdi+8], r8d
	inc	r8
	call	memset
	mov	rcx, rbp
	call	QWORD PTR [rdi+32]
	mov	rcx, rbx
	call	QWORD PTR [rdi+32]
$LN13@trmem_clos:
	test	r12, r12

; 410  :             walk = next;

	mov	rbx, r12
	jne	$LL6@trmem_clos

; 411  :         }
; 412  :         if( chunks ) {

	test	esi, esi
	mov	r12, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+104]
	je	SHORT $LN1@trmem_clos

; 413  :             trPrt( hdl, MSG_CHUNK_BYTE_UNFREED, chunks, mem_used );

	lea	rdx, OFFSET FLAT:MSG_CHUNK_BYTE_UNFREED
	mov	r9d, r13d
	mov	r8d, esi
	mov	rcx, rdi
	call	trPrt

; 414  :         }
; 415  :     } else {

	jmp	SHORT $LN1@trmem_clos
$LN7@trmem_clos:

; 416  :         walk = hdl->alloc_list;

	mov	rcx, QWORD PTR [rcx]

; 417  :         while( walk ) {

	test	rcx, rcx
	je	SHORT $LN1@trmem_clos
	npad	6
$LL2@trmem_clos:

; 418  :             next = walk->next;

	mov	rbx, QWORD PTR [rcx]

; 419  :             ++chunks;

	inc	esi

; 420  :             freeEntry( walk, hdl );

	call	QWORD PTR [rdi+32]
	test	rbx, rbx

; 421  :             walk = next;

	mov	rcx, rbx
	jne	SHORT $LL2@trmem_clos
$LN1@trmem_clos:

; 422  :         }
; 423  :     }
; 424  :     hdl->free( hdl );

	mov	rcx, rdi
	mov	rax, QWORD PTR [rdi+32]
	call	rax
	mov	r13, QWORD PTR [rsp+72]
	mov	rdi, QWORD PTR [rsp+120]
	mov	rbx, QWORD PTR [rsp+96]

; 425  :     return( chunks );

	mov	eax, esi
	mov	rsi, QWORD PTR [rsp+112]

; 426  : }

	add	rsp, 88					; 00000058H
	ret	0
_trmem_close ENDP
_TEXT	ENDS
PUBLIC	tm_Fini
EXTRN	fclose:NEAR
xdata	SEGMENT
$unwind$tm_Fini DD 050e01H
	DD	0c640eH
	DD	0b3409H
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$tm_Fini DD @imagerel($LN15#)
	DD	@imagerel($LN15#+51)
	DD	@imagerel($unwind$tm_Fini#)
pdata	ENDS
xdata	SEGMENT
$chain$2$tm_Fini DD 020521H
	DD	0d7405H
	DD	@imagerel($LN15#)
	DD	@imagerel($LN15#+51)
	DD	@imagerel($unwind$tm_Fini#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$tm_Fini DD @imagerel($LN15#+51)
	DD	@imagerel($LN15#+182)
	DD	@imagerel($chain$2$tm_Fini#)
pdata	ENDS
xdata	SEGMENT
$chain$3$tm_Fini DD 021H
	DD	@imagerel($LN15#)
	DD	@imagerel($LN15#+51)
	DD	@imagerel($unwind$tm_Fini#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$tm_Fini DD @imagerel($LN15#+182)
	DD	@imagerel($LN15#+216)
	DD	@imagerel($chain$3$tm_Fini#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
tm_Fini	PROC NEAR

; 790  : {

$LN15:
	sub	rsp, 72					; 00000048H
	mov	QWORD PTR [rsp+88], rbx
	mov	QWORD PTR [rsp+96], rsi

; 791  :     /* if tm_Fini() is called, both hTrmem & memFile are != NULL */
; 792  :     _trmem_prt_list( hTrmem );

	mov	rsi, QWORD PTR hTrmem
	mov	rbx, QWORD PTR [rsi]
	test	rbx, rbx
	je	$LN4@tm_Fini
	mov	r9d, DWORD PTR [rsi+12]
	mov	r8d, DWORD PTR [rsi+8]
	lea	rdx, OFFSET FLAT:MSG_PRT_USAGE
	mov	rcx, rsi
	mov	QWORD PTR [rsp+104], rdi
	call	trPrt
	lea	rdx, OFFSET FLAT:MSG_PRT_LIST_1
	mov	rcx, rsi
	call	trPrt
	lea	rdx, OFFSET FLAT:MSG_PRT_LIST_2
	mov	rcx, rsi
	call	trPrt
	xor	edi, edi
	npad	3
$LL6@tm_Fini:
	mov	r8, QWORD PTR [rbx+16]
	mov	rcx, QWORD PTR [rbx+24]
	xor	rcx, r8
	xor	rcx, rbx
	xor	rcx, QWORD PTR [rbx+8]
	cmp	edi, 20
	jae	SHORT $LN3@tm_Fini
	mov	r9, QWORD PTR [rbx+8]
	mov	eax, DWORD PTR [rbx+32]
	mov	QWORD PTR [rsp+56], rcx
	mov	QWORD PTR [rsp+48], r9
	mov	DWORD PTR [rsp+40], eax
	mov	QWORD PTR [rsp+32], rcx
	lea	rdx, OFFSET FLAT:MSG_PRT_LIST_3
	mov	rcx, rsi
	call	trPrt
$LN3@tm_Fini:
	mov	rbx, QWORD PTR [rbx]
	inc	edi
	test	rbx, rbx
	jne	SHORT $LL6@tm_Fini
	mov	rsi, QWORD PTR hTrmem
	mov	rdi, QWORD PTR [rsp+104]
$LN4@tm_Fini:

; 793  :     _trmem_close( hTrmem );

	mov	rcx, rsi
	call	_trmem_close

; 794  :     fclose( FileTrmem );

	mov	rcx, QWORD PTR FileTrmem
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [rsp+88]

; 795  : }

	add	rsp, 72					; 00000048H
	jmp	fclose
tm_Fini	ENDP
_TEXT	ENDS
END
