; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	stackreg
_BSS	SEGMENT
$SG7468	DB	01H DUP (?)
	ALIGN	4

$SG6818	DB	01H DUP (?)
	ALIGN	4

$SG6466	DB	01H DUP (?)
	ALIGN	4

$SG6326	DB	01H DUP (?)
	ALIGN	4

$SG6287	DB	01H DUP (?)
	ALIGN	4

$SG6281	DB	01H DUP (?)
	ALIGN	4

$SG6226	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	XYZMMsize:DWORD
COMM	decoflags:BYTE
COMM	ProcStatus:DWORD
COMM	CurrProcLine:DWORD
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	procidx:DWORD
COMM	ZEROLOCALS:BYTE
COMM	StackAdjHigh:DWORD
COMM	StackAdj:DWORD
COMM	sym_ReservedStack:QWORD
COMM	CurrProc:QWORD
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
ms32_regs16 DD	09H
	DD	0bH
	DD	0cH
	ORG $+4
ms32_regs32 DD	012H
	DD	013H
ms32_maxreg DD	03H
	DD	02H
watc_regs8 DD	01H
	DD	03H
	DD	04H
	DD	02H
watc_regs16 DD	09H
	DD	0bH
	DD	0cH
	DD	0aH
watc_regs32 DD	011H
	DD	013H
	DD	014H
	DD	012H
watc_regs_qw DD	09H
	DD	0cH
	DD	0aH
	DD	0bH
ms64_regs DD	074H
	DD	075H
	DD	07bH
	DD	07cH
win64_nvgpr DW	0f0e8H
	ORG $+2
win64_nvxmm DW	0ffc0H
	ORG $+2
fastcall_tab DQ	FLAT:ms32_pcheck
	DQ	FLAT:ms32_return
	DQ	FLAT:watc_pcheck
	DQ	FLAT:watc_return
	DQ	FLAT:ms64_pcheck
	DQ	FLAT:ms64_return
vectorcall_tab DQ FLAT:ms32_pcheck
	DQ	FLAT:ms32_return
	DQ	FLAT:watc_pcheck
	DQ	FLAT:watc_return
	DQ	FLAT:ms64_pcheck
	DQ	FLAT:ms64_return
stackreg DD	0dH
	DD	015H
	DD	077H
CONST	ENDS
_DATA	SEGMENT
$SG5992	DB	'sub %r, %d', 00H
	ORG $+1
$SG5993	DB	'%r %d', 00H
_DATA	ENDS
CONST	SEGMENT
	ORG $+4
fmtstk0	DQ	FLAT:$SG5992
	DQ	FLAT:$SG5993
CONST	ENDS
_DATA	SEGMENT
	ORG $+6
$SG5995	DB	'sub %r, %d + %s', 00H
$SG5996	DB	'%r %d + %s', 00H
_DATA	ENDS
CONST	SEGMENT
fmtstk1	DQ	FLAT:$SG5995
	DQ	FLAT:$SG5996
CONST	ENDS
_DATA	SEGMENT
	ORG $+1
$SG6039	DB	'::', 00H
	ORG $+1
$SG6042	DB	'%s::%s', 00H
	ORG $+1
$SG6052	DB	'%d%c', 00H
	ORG $+3
$SG6070	DB	'%d%c', 00H
	ORG $+3
$SG6400	DB	'PRIVATE', 00H
$SG6405	DB	'PUBLIC', 00H
	ORG $+1
$SG6408	DB	'EXPORT', 00H
	ORG $+1
$SG6423	DB	'FORCEFRAME', 00H
	ORG $+1
$SG6426	DB	'LOADDS', 00H
	ORG $+1
$SG6446	DB	'USES', 00H
	ORG $+3
$SG6533	DB	'@Line', 00H
	ORG $+6
$SG6534	DB	'@ProcLine', 00H
	ORG $+2
$SG6610	DB	'.xdata', 00H
	ORG $+1
$SG6621	DB	'%s %r', 00H
	ORG $+6
$SG6623	DB	'%s %r align(%u) flat read ''DATA''', 00H
	ORG $+7
$SG6624	DB	'$xdatasym label near', 00H
	ORG $+3
$SG6627	DB	'db %ut + (0%xh shl 3), %ut, %ut, 0%xh + (0%xh shl 4)', 00H
	ORG $+3
$SG6630	DB	'dw', 00H
	ORG $+5
$SG6634	DB	'%s 0%xh', 00H
$SG6635	DB	',', 00H
	ORG $+2
$SG6638	DB	'dw', 00H
	ORG $+1
$SG6639	DB	'%r 4', 00H
	ORG $+3
$SG6641	DB	'dd %r %s', 00H
	ORG $+3
$SG6642	DB	'%r 8', 00H
	ORG $+3
$SG6643	DB	'%s %r', 00H
	ORG $+2
$SG6645	DB	'.pdata', 00H
	ORG $+5
$SG6647	DB	'.pdata$%04u', 00H
$SG6649	DB	'%s %r', 00H
	ORG $+6
$SG6651	DB	'%s %r align(%u) flat read ''DATA''', 00H
	ORG $+7
$SG6652	DB	'dd %r %s, %r %s+0%xh, %r $xdatasym+0%xh', 00H
$SG6653	DB	'%s %r', 00H
	ORG $+2
$SG6703	DB	'@ProcLine', 00H
	ORG $+2
$SG6745	DB	'CODE', 00H
	ORG $+7
$SG6812	DB	'option prologue:none', 0aH, 00H
	ORG $+2
$SG6819	DB	' (%s, 0%XH, 0%XH, 0%XH, <<%s>>, <%s>)', 00H
	ORG $+2
$SG6842	DB	'%s qword ptr[%r+%u], %r', 00H
$SG6845	DB	'%s dword ptr[%r+%u], %r', 00H
$SG6851	DB	'mov [%r+%u], %r', 00H
$SG6853	DB	'mov [%r+%u], %r', 00H
$SG6860	DB	'%s [%r+%u], %r', 00H
	ORG $+1
$SG6863	DB	'mov [%r+%u], %r', 00H
$SG6865	DB	'mov [%r+%u], %r', 00H
$SG6872	DB	'%s [%r+%u], %r', 00H
	ORG $+1
$SG6874	DB	'mov [%r+%u], %r', 00H
$SG6876	DB	'mov [%r+%u], %r', 00H
$SG6937	DB	'mov [%r+%u], %r', 00H
$SG6938	DB	'%r %r, %u', 00H
	ORG $+6
$SG6973	DB	'push %r', 00H
$SG6974	DB	'%r %r', 00H
	ORG $+2
$SG6975	DB	'mov %r, %r', 00H
	ORG $+5
$SG6976	DB	'%r %r, 0', 00H
	ORG $+7
$SG6988	DB	'push %r', 00H
$SG6990	DB	'%r %r', 00H
	ORG $+2
$SG7001	DB	'push %r', 00H
$SG7003	DB	'%r %r', 00H
	ORG $+2
$SG7013	DB	'sub %r, %u', 00H
	ORG $+5
$SG7030	DB	'mov %r, %u', 00H
	ORG $+1
$SG7031	DB	'dec %r', 00H
	ORG $+5
$SG7032	DB	'mov byte ptr [%r + %r], 0', 00H
	ORG $+6
$SG7033	DB	'dw 0F875h', 00H
	ORG $+6
$SG7035	DB	'push %r', 00H
$SG7036	DB	'push %r', 00H
$SG7037	DB	'xor %r, %r', 00H
	ORG $+5
$SG7038	DB	'mov %r, %u', 00H
	ORG $+1
$SG7039	DB	'cld', 00H
$SG7040	DB	'lea %r, [%r+16]', 00H
$SG7041	DB	'rep stosb', 00H
	ORG $+2
$SG7042	DB	'pop %r', 00H
	ORG $+1
$SG7043	DB	'pop %r', 00H
	ORG $+5
$SG7054	DB	'%s [%r+%u+%s], %r', 00H
	ORG $+6
$SG7055	DB	'%r %r, %u+%s', 00H
	ORG $+3
$SG7058	DB	'%s [%r+%u+%s], %r', 00H
	ORG $+6
$SG7059	DB	'%r %r, %u+%s', 00H
	ORG $+3
$SG7063	DB	'%s [%r+%u], %r', 00H
	ORG $+1
$SG7064	DB	'%r %r, %u', 00H
	ORG $+6
$SG7067	DB	'%s [%r+%u], %r', 00H
	ORG $+1
$SG7068	DB	'%r %r, %u', 00H
	ORG $+6
$SG7078	DB	'lea %r,[%r + %d]', 00H
	ORG $+7
$SG7080	DB	'mov [%r + %d], %r', 00H
	ORG $+6
$SG7094	DB	'mov [%r + %d], %r', 00H
	ORG $+6
$SG7119	DB	'%s dword ptr [rsp+%d],%r', 00H
	ORG $+7
$SG7128	DB	'%s qword ptr [rsp+%d],%r', 00H
	ORG $+7
$SG7131	DB	'%s oword ptr [rsp+%d],%r', 00H
	ORG $+7
$SG7139	DB	'%s oword ptr [rsp+%d],%r', 00H
	ORG $+7
$SG7142	DB	'vmovups ymmword ptr [rsp+%d],%r', 00H
$SG7150	DB	'vmovups ymmword ptr [rsp+%d],%r', 00H
$SG7151	DB	'%r', 00H
	ORG $+5
$SG7170	DB	'push %r', 00H
$SG7171	DB	'mov %r, %r', 00H
	ORG $+5
$SG7177	DB	'push %r', 00H
$SG7179	DB	'sub %r, %d + %s', 00H
$SG7184	DB	'add %r, %d', 00H
	ORG $+5
$SG7186	DB	'sub %r, %d', 00H
	ORG $+5
$SG7188	DB	'push %r', 00H
$SG7189	DB	'mov %r, %s', 00H
	ORG $+5
$SG7190	DB	'mov %r, %r', 00H
	ORG $+5
$SG7195	DB	'push %r', 00H
$SG7345	DB	'pop %r', 00H
	ORG $+1
$SG7352	DB	'pop %r', 00H
	ORG $+1
$SG7376	DB	'%s %r, [%r + %u + %s]', 00H
	ORG $+2
$SG7378	DB	'%s %r, [%r + %u + %s]', 00H
	ORG $+2
$SG7381	DB	'%s %r, [%r + %u]', 00H
	ORG $+7
$SG7383	DB	'%s %r, [%r + %u]', 00H
	ORG $+7
$SG7388	DB	'add %r, %d + %s', 00H
$SG7391	DB	'add %r, %d', 00H
	ORG $+5
$SG7407	DB	'mov %r, [%r+%u]', 00H
$SG7412	DB	'pop %r', 00H
	ORG $+1
$SG7422	DB	'add %r, %d + %s', 00H
$SG7424	DB	'pop %r', 00H
	ORG $+1
$SG7430	DB	'leave', 00H
	ORG $+2
$SG7436	DB	'add %r, %d', 00H
	ORG $+5
$SG7438	DB	'mov %r, %r', 00H
	ORG $+1
$SG7439	DB	'pop %r', 00H
	ORG $+5
$SG7469	DB	'%s, 0%XH, 0%XH, 0%XH, <<%s>>, <%s>', 00H
	ORG $+5
$SG7471	DB	'option epilogue:none', 0aH, 00H
	ORG $+2
$SG7504	DB	'%d%c', 00H
	ORG $+3
$SG7508	DB	'%d%c', 00H
_DATA	ENDS
EXTRN	LclAlloc:NEAR
EXTRN	sprintf:NEAR
EXTRN	GetResWName:NEAR
EXTRN	__ImageBase:BYTE
EXTRN	SizeFromMemtype:NEAR
EXTRN	GetSymOfssize:NEAR
_BSS	SEGMENT
	ALIGN	4

?regist@?1??watc_pcheck@@9@9 DB 020H DUP (?)		; `watc_pcheck'::`2'::regist
?regname@?1??watc_pcheck@@9@9 DB 040H DUP (?)		; `watc_pcheck'::`2'::regname
_BSS	ENDS
xdata	SEGMENT
$unwind$watc_pcheck DD 091d01H
	DD	06d41dH
	DD	07c418H
	DD	087413H
	DD	09640eH
	DD	0a209H
xdata	ENDS
pdata	SEGMENT
$pdata$watc_pcheck DD @imagerel(watc_pcheck#)
	DD	@imagerel(watc_pcheck#+92)
	DD	@imagerel($unwind$watc_pcheck#)
pdata	ENDS
xdata	SEGMENT
$chain$4$watc_pcheck DD 020521H
	DD	0a5405H
	DD	@imagerel(watc_pcheck#)
	DD	@imagerel(watc_pcheck#+92)
	DD	@imagerel($unwind$watc_pcheck#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$watc_pcheck DD @imagerel(watc_pcheck#+92)
	DD	@imagerel(watc_pcheck#+220)
	DD	@imagerel($chain$4$watc_pcheck#)
pdata	ENDS
xdata	SEGMENT
$chain$5$watc_pcheck DD 020521H
	DD	0f3405H
	DD	@imagerel(watc_pcheck#+92)
	DD	@imagerel(watc_pcheck#+220)
	DD	@imagerel($chain$4$watc_pcheck#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$watc_pcheck DD @imagerel(watc_pcheck#+220)
	DD	@imagerel(watc_pcheck#+324)
	DD	@imagerel($chain$5$watc_pcheck#)
pdata	ENDS
xdata	SEGMENT
$chain$7$watc_pcheck DD 040a21H
	DD	04f40aH
	DD	05e405H
	DD	@imagerel(watc_pcheck#+220)
	DD	@imagerel(watc_pcheck#+324)
	DD	@imagerel($chain$5$watc_pcheck#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$watc_pcheck DD @imagerel(watc_pcheck#+324)
	DD	@imagerel(watc_pcheck#+474)
	DD	@imagerel($chain$7$watc_pcheck#)
pdata	ENDS
xdata	SEGMENT
$chain$8$watc_pcheck DD 021H
	DD	@imagerel(watc_pcheck#+220)
	DD	@imagerel(watc_pcheck#+324)
	DD	@imagerel($chain$5$watc_pcheck#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$watc_pcheck DD @imagerel(watc_pcheck#+474)
	DD	@imagerel(watc_pcheck#+746)
	DD	@imagerel($chain$8$watc_pcheck#)
pdata	ENDS
xdata	SEGMENT
$chain$9$watc_pcheck DD 021H
	DD	@imagerel(watc_pcheck#+92)
	DD	@imagerel(watc_pcheck#+220)
	DD	@imagerel($chain$4$watc_pcheck#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$watc_pcheck DD @imagerel(watc_pcheck#+746)
	DD	@imagerel(watc_pcheck#+751)
	DD	@imagerel($chain$9$watc_pcheck#)
pdata	ENDS
xdata	SEGMENT
$chain$10$watc_pcheck DD 021H
	DD	@imagerel(watc_pcheck#)
	DD	@imagerel(watc_pcheck#+92)
	DD	@imagerel($unwind$watc_pcheck#)
xdata	ENDS
pdata	SEGMENT
$pdata$10$watc_pcheck DD @imagerel(watc_pcheck#+751)
	DD	@imagerel(watc_pcheck#+776)
	DD	@imagerel($chain$10$watc_pcheck#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\proc.c
pdata	ENDS
_TEXT	SEGMENT
proc$ = 96
paranode$ = 104
used$ = 112
watc_pcheck PROC NEAR

; 215  : {

	mov	QWORD PTR [rsp+24], r8
	sub	rsp, 88					; 00000058H
	mov	QWORD PTR [rsp+72], rsi
	mov	QWORD PTR [rsp+64], rdi
	mov	QWORD PTR [rsp+56], r12
	mov	QWORD PTR [rsp+48], r13
	mov	r12, rdx
	mov	rdi, rcx
	mov	r13, r8

; 216  :     static char regname[64];
; 217  :     static char regist[32];
; 218  :     int newflg;
; 219  :     int shift;
; 220  :     int firstreg;
; 221  :     uint_8 Ofssize = GetSymOfssize( &proc->sym );

	call	GetSymOfssize

; 222  :     int size = SizeFromMemtype( paranode->sym.mem_type, paranode->sym.Ofssize, paranode->sym.type );

	movzx	edx, BYTE PTR [r12+52]
	mov	r8, QWORD PTR [r12+88]
	mov	ecx, DWORD PTR [r12+44]
	mov	esi, eax
	call	SizeFromMemtype

; 223  : 
; 224  :     /* v2.05: VARARG procs don't have register params */
; 225  :     if ( proc->e.procinfo->has_vararg )

	mov	rcx, QWORD PTR [rdi+104]
	test	BYTE PTR [rcx+128], 1
	mov	r11d, eax
	je	SHORT $LN27@watc_pchec

; 226  :         return( 0 );

	xor	eax, eax
	jmp	$LN28@watc_pchec
$LN27@watc_pchec:

; 227  : 
; 228  :     if ( size != 1 && size != 2 && size != 4 && size != 8 )

	cmp	eax, 1
	mov	QWORD PTR [rsp+80], rbp
	je	SHORT $LN26@watc_pchec
	cmp	eax, 2
	je	SHORT $LN26@watc_pchec
	cmp	eax, 4
	je	SHORT $LN26@watc_pchec
	cmp	eax, 8
	je	SHORT $LN37@watc_pchec
$LN36@watc_pchec:

; 229  :         return( 0 );

	xor	eax, eax
	jmp	$LN39@watc_pchec
$LN26@watc_pchec:

; 230  : 
; 231  :     /* v2.05: rewritten. The old code didn't allow to "fill holes" */
; 232  :     if ( size == 8 ) {

	cmp	eax, 8
	jne	SHORT $LN25@watc_pchec
$LN37@watc_pchec:

; 233  :         newflg = Ofssize ? 3 : 15;

	mov	eax, 3
	test	sil, sil
	mov	ebp, 15
	cmovne	ebp, eax

; 234  :         shift = Ofssize ? 2 : 4;

	mov	eax, 2
	test	sil, sil
	mov	ecx, 4
	cmovne	ecx, eax
	jmp	SHORT $LN22@watc_pchec
$LN25@watc_pchec:

; 235  :     } else if ( size == 4 && Ofssize == USE16 ) {

	cmp	eax, 4
	jne	SHORT $LN23@watc_pchec
	test	sil, sil
	jne	SHORT $LN23@watc_pchec

; 236  :         newflg = 3;

	lea	ebp, QWORD PTR [rax-1]

; 237  :         shift = 2;

	lea	ecx, QWORD PTR [rax-2]

; 238  :     } else {

	jmp	SHORT $LN22@watc_pchec
$LN23@watc_pchec:

; 239  :         newflg = 1;

	mov	ebp, 1

; 240  :         shift = 1;

	mov	ecx, ebp
$LN22@watc_pchec:

; 241  :     }
; 242  : 
; 243  :     /* scan if there's a free register (pair/quadrupel) */
; 244  :     for ( firstreg = 0; firstreg < 4 && (newflg & *used ); newflg <<= shift, firstreg += shift );

	mov	eax, DWORD PTR [r13]
	xor	edx, edx
	npad	1
$LL21@watc_pchec:
	test	eax, ebp
	je	SHORT $LN19@watc_pchec
	add	edx, ecx
	shl	ebp, cl
	cmp	edx, 4
	jl	SHORT $LL21@watc_pchec

; 229  :         return( 0 );

	xor	eax, eax
	jmp	$LN39@watc_pchec
$LN19@watc_pchec:

; 245  :     if ( firstreg >= 4 ) /* exit if nothing is free */

	cmp	edx, 4

; 246  :         return( 0 );

	jge	SHORT $LN36@watc_pchec

; 247  : 
; 248  :     paranode->sym.state = SYM_TMACRO;
; 249  :     switch ( size ) {

	dec	r11d
	mov	QWORD PTR [rsp+120], rbx
	mov	DWORD PTR [r12+40], 10
	lea	rbx, OFFSET FLAT:?regname@?1??watc_pcheck@@9@9
	je	$LN15@watc_pchec
	dec	r11d
	je	$LN14@watc_pchec
	sub	r11d, 2
	je	$LN13@watc_pchec
	cmp	r11d, 4
	jne	$LN5@watc_pchec

; 264  :     case 8:
; 265  :         if ( Ofssize ) {

	test	sil, sil
	je	SHORT $LN9@watc_pchec

; 266  :             paranode->sym.regist[0] = watc_regs32[firstreg];

	movsxd	rcx, edx
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	eax, WORD PTR watc_regs32[rdx+rcx*4]
	mov	WORD PTR [r12+56], ax

; 267  :             paranode->sym.regist[1] = watc_regs32[firstreg+1];

	movzx	eax, WORD PTR watc_regs32[rdx+rcx*4+4]
	mov	WORD PTR [r12+58], ax

; 268  :         } else {

	jmp	$LN5@watc_pchec
$LN9@watc_pchec:
	mov	QWORD PTR [rsp+40], r14
	mov	QWORD PTR [rsp+32], r15

; 269  :             /* the AX:BX:CX:DX sequence is for 16-bit only.
; 270  :              * fixme: no support for codeview debug info yet;
; 271  :              * the S_REGISTER record supports max 2 registers only.
; 272  :              */
; 273  :             for( firstreg = 0, regname[0] = NULLC; firstreg < 4; firstreg++ ) {

	mov	BYTE PTR ?regname@?1??watc_pcheck@@9@9, 0
	lea	r15, OFFSET FLAT:watc_regs_qw+16
	lea	rsi, OFFSET FLAT:watc_regs_qw
	lea	r14, OFFSET FLAT:$SG6039
	lea	r13, OFFSET FLAT:watc_regs_qw+12
$LL7@watc_pchec:

; 274  :                 GetResWName( watc_regs_qw[firstreg], regname + strlen( regname ) );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	lea	rdx, QWORD PTR [rcx-1]
	mov	ecx, DWORD PTR [rsi]
	add	rdx, rbx
	call	GetResWName

; 275  :                 if ( firstreg != 3 )

	cmp	rsi, r13
	je	SHORT $LN6@watc_pchec

; 276  :                     strcat( regname, "::");

	xor	eax, eax
	mov	rdi, rbx
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	11
$LL38@watc_pchec:
	movzx	eax, BYTE PTR [r14+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL38@watc_pchec
$LN6@watc_pchec:

; 269  :             /* the AX:BX:CX:DX sequence is for 16-bit only.
; 270  :              * fixme: no support for codeview debug info yet;
; 271  :              * the S_REGISTER record supports max 2 registers only.
; 272  :              */
; 273  :             for( firstreg = 0, regname[0] = NULLC; firstreg < 4; firstreg++ ) {

	add	rsi, 4
	cmp	rsi, r15
	jl	SHORT $LL7@watc_pchec
	mov	r13, QWORD PTR used$[rsp]
	mov	r15, QWORD PTR [rsp+32]
	mov	r14, QWORD PTR [rsp+40]
	jmp	SHORT $LN5@watc_pchec
$LN13@watc_pchec:

; 256  :     case 4:
; 257  :         if ( Ofssize ) {

	test	sil, sil
	je	SHORT $LN12@watc_pchec

; 258  :             paranode->sym.regist[0] = watc_regs32[firstreg];

	movsxd	rax, edx
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	eax, WORD PTR watc_regs32[rdx+rax*4]
	mov	WORD PTR [r12+56], ax

; 259  :         } else {

	jmp	SHORT $LN5@watc_pchec
$LN12@watc_pchec:

; 260  :             paranode->sym.regist[0] = watc_regs16[firstreg];

	movsxd	rcx, edx
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	eax, WORD PTR watc_regs16[rdx+rcx*4]
	mov	WORD PTR [r12+56], ax

; 261  :             paranode->sym.regist[1] = watc_regs16[firstreg+1];

	movzx	eax, WORD PTR watc_regs16[rdx+rcx*4+4]
	mov	WORD PTR [r12+58], ax

; 262  :         }
; 263  :         break;

	jmp	SHORT $LN5@watc_pchec
$LN14@watc_pchec:

; 252  :         break;
; 253  :     case 2:
; 254  :         paranode->sym.regist[0] = watc_regs16[firstreg];

	movsxd	rax, edx
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	eax, WORD PTR watc_regs16[rdx+rax*4]
	mov	WORD PTR [r12+56], ax

; 255  :         break;

	jmp	SHORT $LN5@watc_pchec
$LN15@watc_pchec:

; 250  :     case 1:
; 251  :         paranode->sym.regist[0] = watc_regs8[firstreg];

	movsxd	rax, edx
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	eax, WORD PTR watc_regs8[rdx+rax*4]
	mov	WORD PTR [r12+56], ax
$LN5@watc_pchec:

; 277  :             }
; 278  :         }
; 279  :     }
; 280  :     if ( paranode->sym.regist[1] ) {

	cmp	WORD PTR [r12+58], 0
	je	SHORT $LN3@watc_pchec

; 281  :         sprintf( regname, "%s::%s",
; 282  :                 GetResWName( paranode->sym.regist[1], regist ),
; 283  :                 GetResWName( paranode->sym.regist[0], NULL ) );

	movzx	ecx, WORD PTR [r12+56]
	xor	edx, edx
	call	GetResWName
	movzx	ecx, WORD PTR [r12+58]
	lea	rdx, OFFSET FLAT:?regist@?1??watc_pcheck@@9@9
	mov	rdi, rax
	call	GetResWName
	lea	rdx, OFFSET FLAT:$SG6042
	mov	r9, rdi
	mov	rcx, rbx
	mov	r8, rax
	call	sprintf
	jmp	SHORT $LN1@watc_pchec
$LN3@watc_pchec:

; 284  :     } else if ( paranode->sym.regist[0] ) {

	movzx	eax, WORD PTR [r12+56]
	test	ax, ax
	je	SHORT $LN1@watc_pchec

; 285  :         GetResWName( paranode->sym.regist[0], regname );

	movzx	ecx, ax
	mov	rdx, rbx
	call	GetResWName
$LN1@watc_pchec:

; 286  :     }
; 287  :     *used |= newflg;

	or	DWORD PTR [r13], ebp

; 288  :     paranode->sym.string_ptr = LclAlloc( strlen( regname ) + 1 );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	call	LclAlloc
	mov	QWORD PTR [r12+16], rax
	npad	6
$LL30@watc_pchec:

; 289  :     strcpy( paranode->sym.string_ptr, regname );

	movzx	ecx, BYTE PTR [rbx]
	inc	rax
	inc	rbx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL30@watc_pchec
	mov	rbx, QWORD PTR [rsp+120]

; 290  :     DebugMsg(("watc_pcheck(%s.%s): size=%u ptr=%u far=%u reg=%s\n", proc->sym.name, paranode->sym.name, size, paranode->sym.is_ptr, paranode->sym.isfar, regname ));
; 291  :     return( 1 );

	mov	eax, 1
$LN39@watc_pchec:
	mov	rbp, QWORD PTR [rsp+80]
$LN28@watc_pchec:
	mov	r13, QWORD PTR [rsp+48]
	mov	r12, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]

; 292  : }

	add	rsp, 88					; 00000058H
	ret	0
watc_pcheck ENDP
_TEXT	ENDS
EXTRN	ModuleInfo:BYTE
xdata	SEGMENT
$unwind$watc_return DD 020601H
	DD	070023206H
xdata	ENDS
pdata	SEGMENT
$pdata$watc_return DD @imagerel(watc_return#)
	DD	@imagerel(watc_return#+101)
	DD	@imagerel($unwind$watc_return#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
proc$ = 48
buffer$ = 56
watc_return PROC NEAR

; 296  : {

	push	rdi
	sub	rsp, 32					; 00000020H

; 297  :     int value;
; 298  :     value = 4 * CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406

; 299  :     if( proc->e.procinfo->has_vararg == FALSE && proc->e.procinfo->parasize > value )

	mov	rcx, QWORD PTR [rcx+104]
	shl	eax, 2
	test	BYTE PTR [rcx+128], 1
	jne	SHORT $LN1@watc_retur
	mov	r8d, DWORD PTR [rcx+32]
	cmp	r8d, eax
	jbe	SHORT $LN1@watc_retur

; 300  :         sprintf( buffer + strlen( buffer ), "%d%c", proc->e.procinfo->parasize - value, ModuleInfo.radix != 10 ? 't' : NULLC );

	xor	r9d, r9d
	cmp	BYTE PTR ModuleInfo+396, 10
	mov	rdi, rdx
	mov	ecx, 116				; 00000074H
	cmovne	r9d, ecx
	sub	r8d, eax
	xor	eax, eax
	mov	rcx, -1
	repne scasb
	not	rcx
	dec	rcx
	add	rcx, rdx
	lea	rdx, OFFSET FLAT:$SG6052
	call	sprintf
$LN1@watc_retur:

; 301  :     return;
; 302  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
watc_return ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$ms32_pcheck DD 051101H
	DD	0a6411H
	DD	0f3409H
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$ms32_pcheck DD @imagerel(ms32_pcheck#)
	DD	@imagerel(ms32_pcheck#+158)
	DD	@imagerel($unwind$ms32_pcheck#)
pdata	ENDS
xdata	SEGMENT
$chain$2$ms32_pcheck DD 020521H
	DD	097405H
	DD	@imagerel(ms32_pcheck#)
	DD	@imagerel(ms32_pcheck#+158)
	DD	@imagerel($unwind$ms32_pcheck#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$ms32_pcheck DD @imagerel(ms32_pcheck#+158)
	DD	@imagerel(ms32_pcheck#+208)
	DD	@imagerel($chain$2$ms32_pcheck#)
pdata	ENDS
xdata	SEGMENT
$chain$3$ms32_pcheck DD 021H
	DD	@imagerel(ms32_pcheck#)
	DD	@imagerel(ms32_pcheck#+158)
	DD	@imagerel($unwind$ms32_pcheck#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$ms32_pcheck DD @imagerel(ms32_pcheck#+208)
	DD	@imagerel(ms32_pcheck#+263)
	DD	@imagerel($chain$3$ms32_pcheck#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
regname$ = 32
proc$ = 96
paranode$ = 104
used$ = 112
ms32_pcheck PROC NEAR

; 314  : {

	sub	rsp, 88					; 00000058H
	mov	QWORD PTR [rsp+120], rbx
	mov	rbx, r8
	mov	QWORD PTR [rsp+80], rsi
	mov	rsi, rdx

; 315  :     char regname[32];
; 316  :     int size = SizeFromMemtype( paranode->sym.mem_type, paranode->sym.Ofssize, paranode->sym.type );

	movzx	edx, BYTE PTR [rdx+52]
	mov	r8, QWORD PTR [rsi+88]
	mov	ecx, DWORD PTR [rsi+44]
	call	SizeFromMemtype

; 317  : 
; 318  :     /* v2.07: 16-bit has 3 register params (AX,DX,BX) */
; 319  :     //if ( size > CurrWordSize || *used >= 2 )
; 320  :     if ( size > CurrWordSize || *used >= ms32_maxreg[ModuleInfo.Ofssize] )

	movzx	ecx, BYTE PTR ModuleInfo+406
	cmp	eax, ecx
	jg	$LN1@ms32_pchec
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR ms32_maxreg[rdx+rax*4]
	cmp	DWORD PTR [rbx], eax
	jge	$LN1@ms32_pchec

; 322  :     paranode->sym.state = SYM_TMACRO;

	mov	DWORD PTR [rsi+40], 10

; 323  :     /* v2.10: for codeview debug info, store the register index in the symbol */
; 324  :     paranode->sym.regist[0] = ModuleInfo.Ofssize ? ms32_regs32[*used] : ms32_regs16[*used];

	cmp	BYTE PTR ModuleInfo+404, 0
	je	SHORT $LN5@ms32_pchec
	movsxd	rax, DWORD PTR [rbx]
	mov	ecx, DWORD PTR ms32_regs32[rdx+rax*4]
	jmp	SHORT $LN6@ms32_pchec
$LN5@ms32_pchec:
	movsxd	rax, DWORD PTR [rbx]
	mov	ecx, DWORD PTR ms32_regs16[rdx+rax*4]
$LN6@ms32_pchec:
	mov	WORD PTR [rsi+56], cx

; 325  :     GetResWName( ModuleInfo.Ofssize ? ms32_regs32[*used] : ms32_regs16[*used], regname );

	cmp	BYTE PTR ModuleInfo+404, 0
	je	SHORT $LN7@ms32_pchec
	movsxd	rax, DWORD PTR [rbx]
	mov	ecx, DWORD PTR ms32_regs32[rdx+rax*4]
	jmp	SHORT $LN8@ms32_pchec
$LN7@ms32_pchec:
	movsxd	rax, DWORD PTR [rbx]
	mov	ecx, DWORD PTR ms32_regs16[rdx+rax*4]
$LN8@ms32_pchec:
	lea	rdx, QWORD PTR regname$[rsp]
	mov	QWORD PTR [rsp+72], rdi
	call	GetResWName

; 326  :     paranode->sym.string_ptr = LclAlloc( strlen( regname ) + 1 );

	xor	eax, eax
	lea	rdi, QWORD PTR regname$[rsp]
	mov	rcx, -1
	repne scasb
	not	rcx
	call	LclAlloc
	mov	rdi, QWORD PTR [rsp+72]

; 327  :     strcpy( paranode->sym.string_ptr, regname );

	lea	rdx, QWORD PTR regname$[rsp]
	mov	QWORD PTR [rsi+16], rax
	npad	2
$LL9@ms32_pchec:
	movzx	ecx, BYTE PTR [rdx]
	inc	rax
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL9@ms32_pchec

; 328  :     (*used)++;

	inc	DWORD PTR [rbx]

; 329  :     return( 1 );

	mov	eax, 1
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+120]

; 330  : }

	add	rsp, 88					; 00000058H
	ret	0
$LN1@ms32_pchec:
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+120]

; 321  :         return( 0 );

	xor	eax, eax

; 330  : }

	add	rsp, 88					; 00000058H
	ret	0
ms32_pcheck ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$ms32_return DD 020601H
	DD	070023206H
xdata	ENDS
pdata	SEGMENT
$pdata$ms32_return DD @imagerel(ms32_return#)
	DD	@imagerel(ms32_return#+115)
	DD	@imagerel($unwind$ms32_return#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
proc$ = 48
buffer$ = 56
ms32_return PROC NEAR

; 334  : {

	push	rdi
	sub	rsp, 32					; 00000020H

; 335  :     /* v2.07: changed */
; 336  :     //if( proc->e.procinfo->parasize > ( 2 * CurrWordSize ) )
; 337  :     //    sprintf( buffer + strlen( buffer ), "%d%c", proc->e.procinfo->parasize - (2 * CurrWordSize), ModuleInfo.radix != 10 ? 't' : NULLC );
; 338  :     if( proc->e.procinfo->parasize > ( ms32_maxreg[ModuleInfo.Ofssize] * CurrWordSize ) )

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	r10, rdx
	mov	rdx, rcx
	movzx	ecx, BYTE PTR ModuleInfo+404
	lea	rdi, OFFSET FLAT:ms32_maxreg
	mov	ecx, DWORD PTR [rdi+rcx*4]
	imul	ecx, eax
	mov	rax, QWORD PTR [rdx+104]
	mov	r8d, DWORD PTR [rax+32]
	cmp	r8d, ecx
	jbe	SHORT $LN1@ms32_retur

; 339  :         sprintf( buffer + strlen( buffer ), "%d%c", proc->e.procinfo->parasize - ( ms32_maxreg[ModuleInfo.Ofssize] * CurrWordSize), ModuleInfo.radix != 10 ? 't' : NULLC );

	mov	eax, 116				; 00000074H
	xor	r9d, r9d
	cmp	BYTE PTR ModuleInfo+396, 10
	cmovne	r9d, eax
	sub	r8d, ecx
	mov	rdi, r10
	xor	eax, eax
	mov	rcx, -1
	lea	rdx, OFFSET FLAT:$SG6070
	repne scasb
	not	rcx
	dec	rcx
	add	rcx, r10
	call	sprintf
$LN1@ms32_retur:

; 340  :     return;
; 341  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
ms32_return ENDP
; Function compile flags: /Ogtpy
proc$ = 8
paranode$ = 16
used$ = 24
ms64_pcheck PROC NEAR

; 359  :     /* since the parameter names refer the stack-backup locations,
; 360  :      * there's nothing to do here!
; 361  :      * That is, if a parameter's size is > 8, it has to be changed
; 362  :      * to a pointer. This is to be done yet.
; 363  :      */
; 364  :     return( 0 );

	xor	eax, eax

; 365  : }

	ret	0
ms64_pcheck ENDP
; Function compile flags: /Ogtpy
proc$ = 8
buffer$ = 16
ms64_return PROC NEAR

; 370  :     /* nothing to do, the caller cleans the stack */
; 371  :     return;
; 372  : }

	ret	0
ms64_return ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$pushitem DD 050e01H
	DD	09740eH
	DD	083409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$pushitem DD @imagerel(pushitem#)
	DD	@imagerel(pushitem#+58)
	DD	@imagerel($unwind$pushitem#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
stk$ = 48
elmt$ = 56
pushitem PROC NEAR

; 377  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx

; 378  :     void      **stack = stk;
; 379  :     struct qnode *node;
; 380  : 
; 381  :     node = LclAlloc( sizeof( struct qnode ));

	mov	ecx, 16
	mov	rbx, rdx
	call	LclAlloc

; 382  :     node->next = *stack;

	mov	r8, QWORD PTR [rdi]

; 383  :     node->elmt = elmt;

	mov	QWORD PTR [rax+8], rbx
	mov	rbx, QWORD PTR [rsp+64]
	mov	QWORD PTR [rax], r8

; 384  :     *stack = node;

	mov	QWORD PTR [rdi], rax
	mov	rdi, QWORD PTR [rsp+72]

; 385  : }

	add	rsp, 40					; 00000028H
	ret	0
pushitem ENDP
; Function compile flags: /Ogtpy
stk$ = 8
popitem	PROC NEAR

; 390  :     void        **stack = stk;
; 391  :     struct qnode *node;
; 392  :     void        *elmt;
; 393  : 
; 394  :     node = (struct qnode *)(*stack);

	mov	rax, QWORD PTR [rcx]

; 395  :     *stack = node->next;

	mov	rdx, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rdx

; 396  :     elmt = (void *)node->elmt;
; 397  :     LclFree( node );
; 398  :     return( elmt );

	mov	rax, QWORD PTR [rax+8]

; 399  : }

	ret	0
popitem	ENDP
_TEXT	ENDS
EXTRN	SymGetLocal:NEAR
EXTRN	Parse_Pass:DWORD
_BSS	SEGMENT
	ALIGN	8

ProcStack DQ	01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$push_proc DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$push_proc DD @imagerel(push_proc#)
	DD	@imagerel(push_proc#+60)
	DD	@imagerel($unwind$push_proc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
proc$ = 48
push_proc PROC NEAR

; 418  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 419  :     if ( Parse_Pass == PASS_1 ) /* get the locals stored so far */

	cmp	DWORD PTR Parse_Pass, 0
	mov	rbx, rcx
	jne	SHORT $LN1@push_proc

; 420  :         SymGetLocal( (struct asym *)proc );

	call	SymGetLocal
$LN1@push_proc:

; 421  :     pushitem( &ProcStack, proc );

	mov	ecx, 16
	call	LclAlloc
	mov	rdx, QWORD PTR ProcStack
	mov	QWORD PTR [rax], rdx
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR ProcStack, rax

; 422  :     return;
; 423  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
push_proc ENDP
; Function compile flags: /Ogtpy
pop_proc PROC NEAR

; 428  :     if( ProcStack == NULL )

	mov	rax, QWORD PTR ProcStack
	test	rax, rax
	jne	SHORT $LN1@pop_proc

; 431  : }

	ret	0
$LN1@pop_proc:

; 429  :         return( NULL );
; 430  :     return( (struct dsym *)popitem( &ProcStack ) );

	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR ProcStack, rcx
	mov	rax, QWORD PTR [rax+8]

; 431  : }

	ret	0
pop_proc ENDP
_TEXT	ENDS
PUBLIC	LocalDir
EXTRN	EmitErr:NEAR
EXTRN	GetQualifiedType:NEAR
EXTRN	EmitError:NEAR
EXTRN	EvalOperand:NEAR
EXTRN	SymLCreate:NEAR
EXTRN	SpecialTable:BYTE
xdata	SEGMENT
$unwind$LocalDir DD 041901H
	DD	0197419H
	DD	01b010eH
xdata	ENDS
pdata	SEGMENT
$pdata$LocalDir DD @imagerel($LN58#)
	DD	@imagerel($LN58#+76)
	DD	@imagerel($unwind$LocalDir#)
pdata	ENDS
xdata	SEGMENT
$chain$3$LocalDir DD 065721H
	DD	01e3457H
	DD	01f5445H
	DD	01a6408H
	DD	@imagerel($LN58#)
	DD	@imagerel($LN58#+76)
	DD	@imagerel($unwind$LocalDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$LocalDir DD @imagerel($LN58#+76)
	DD	@imagerel($LN58#+827)
	DD	@imagerel($chain$3$LocalDir#)
pdata	ENDS
xdata	SEGMENT
$chain$5$LocalDir DD 060021H
	DD	01a6400H
	DD	01f5400H
	DD	01e3400H
	DD	@imagerel($LN58#)
	DD	@imagerel($LN58#+76)
	DD	@imagerel($unwind$LocalDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$LocalDir DD @imagerel($LN58#+827)
	DD	@imagerel($LN58#+882)
	DD	@imagerel($chain$5$LocalDir#)
pdata	ENDS
xdata	SEGMENT
$chain$6$LocalDir DD 021H
	DD	@imagerel($LN58#)
	DD	@imagerel($LN58#+76)
	DD	@imagerel($unwind$LocalDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$LocalDir DD @imagerel($LN58#+882)
	DD	@imagerel($LN58#+908)
	DD	@imagerel($chain$6$LocalDir#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
ti$ = 48
opndx$6150 = 80
i$ = 224
tokenarray$ = 232
LocalDir PROC NEAR

; 443  : {

$LN58:
	mov	DWORD PTR [rsp+8], ecx
	mov	r11, rsp
	sub	rsp, 216				; 000000d8H

; 444  :     char        *name;
; 445  :     struct dsym *local;
; 446  :     struct dsym *curr;
; 447  :     struct proc_info *info;
; 448  :     //int         size;
; 449  :     //int         idx;
; 450  :     struct qualified_type ti;
; 451  : 
; 452  :     if ( Parse_Pass != PASS_1 ) /* everything is done in pass 1 */

	cmp	DWORD PTR Parse_Pass, 0
	mov	QWORD PTR [r11-16], rdi
	mov	r8d, ecx
	mov	rdi, rdx
	je	SHORT $LN39@LocalDir

; 453  :         return( NOT_ERROR );

	xor	eax, eax
	mov	rdi, QWORD PTR [r11-16]

; 600  : }

	add	rsp, 216				; 000000d8H
	ret	0
$LN39@LocalDir:

; 454  : 
; 455  :     DebugMsg1(("LocalDir(%u) entry\n", i));
; 456  : 
; 457  :     if( !( ProcStatus & PRST_PROLOGUE_NOT_DONE ) || CurrProc == NULL ) {

	test	BYTE PTR ProcStatus, -128		; ffffffffffffff80H
	je	$LN37@LocalDir
	mov	rax, QWORD PTR CurrProc
	test	rax, rax
	je	$LN37@LocalDir
	mov	QWORD PTR [rsp+208], rsi

; 459  :     }
; 460  :     info = CurrProc->e.procinfo;

	mov	rsi, QWORD PTR [rax+104]

; 461  : #if STACKBASESUPP
; 462  :     /* ensure the fpo bit is set - it's too late to set it in write_prologue().
; 463  :      * Note that the fpo bit is set only IF there are locals or arguments.
; 464  :      * fixme: what if pass > 1?
; 465  :      */
; 466  :     if ( GetRegNo( info->basereg ) == 4 ) {

	movzx	eax, WORD PTR [rsi+130]
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rax, OFFSET FLAT:SpecialTable+10
	cmp	BYTE PTR [rax+rcx*4], 4
	jne	SHORT $LN36@LocalDir

; 467  :         info->fpo = TRUE;

	or	BYTE PTR [rsi+128], 128			; 00000080H

; 468  :         ProcStatus |= PRST_FPO;

	or	DWORD PTR ProcStatus, 4
	mov	r8d, DWORD PTR i$[rsp]
$LN36@LocalDir:

; 469  :     }
; 470  : #endif
; 471  : 
; 472  :     i++; /* go past LOCAL */

	inc	r8d
	mov	QWORD PTR [rsp+248], rbp
	xor	ebp, ebp
	mov	DWORD PTR i$[rsp], r8d
	mov	QWORD PTR [rsp+240], rbx
$LL35@LocalDir:

; 473  : 
; 474  :     do  {
; 475  :         if( tokenarray[i].token != T_ID ) {

	movsxd	rdx, r8d
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rdi], 8
	jne	$LN46@LocalDir

; 477  :         }
; 478  :         name = tokenarray[i].string_ptr;

	mov	rdx, QWORD PTR [rdx+rdi+8]

; 479  : 
; 480  :         DebugMsg1(("LocalDir: item=%s\n", tokenarray[i].tokpos ));
; 481  : 
; 482  :         ti.symtype = NULL;
; 483  :         ti.is_ptr = 0;
; 484  :         ti.ptr_memtype = MT_EMPTY;
; 485  :         if ( SIZE_DATAPTR & ( 1 << ModuleInfo.model ) )

	mov	ecx, DWORD PTR ModuleInfo+360
	mov	eax, 1
	shl	al, cl

; 486  :             ti.is_far = TRUE;
; 487  :         else
; 488  :             ti.is_far = FALSE;
; 489  :         ti.Ofssize = ModuleInfo.Ofssize;
; 490  : 
; 491  : #if 0
; 492  :         /* since v1.95 a local hash table is used. No need to search the
; 493  :          * symbol before SymLCreate() is called. SymLCreate() will display
; 494  :          * an error if the symbol is already defined.
; 495  :          */
; 496  :         if ((local = (struct dsym *)SymSearch( name )) && local->sym.state != SYM_UNDEFINED ) {
; 497  :             return( EmitErr( SYMBOL_ALREADY_DEFINED, name ) );
; 498  :         }
; 499  : #endif
; 500  :         local = (struct dsym *)SymLCreate( name );

	mov	rcx, rdx
	mov	QWORD PTR ti$[rsp+8], rbp
	test	al, 104					; 00000068H
	movzx	eax, BYTE PTR ModuleInfo+404
	mov	BYTE PTR ti$[rsp+20], bpl
	mov	DWORD PTR ti$[rsp+24], 192		; 000000c0H
	setne	BYTE PTR ti$[rsp+21]
	mov	BYTE PTR ti$[rsp+22], al
	call	SymLCreate

; 501  :         if( !local ) { /* if it failed, an error msg has been written already */

	test	rax, rax
	mov	rbx, rax
	je	$LN48@LocalDir

; 504  :         }
; 505  :         if (ModuleInfo.win64_flags & W64F_SMART) local->sym.isparam = FALSE; //clear isparam var, added  by habran

	test	BYTE PTR ModuleInfo+413, 8
	je	SHORT $LN28@LocalDir
	and	BYTE PTR [rax+49], 127			; 0000007fH
$LN28@LocalDir:

; 506  :         local->sym.state = SYM_STACK;
; 507  :         local->sym.isdefined = TRUE;

	or	BYTE PTR [rax+48], 2
	mov	DWORD PTR [rax+40], 5

; 508  :         local->sym.total_length = 1; /* v2.04: added */

	mov	DWORD PTR [rax+72], 1

; 509  :         switch ( ti.Ofssize ) {

	cmp	BYTE PTR ti$[rsp+22], bpl
	je	SHORT $LN25@LocalDir

; 513  :             break;
; 514  : #if AMD64_SUPPORT
; 515  :             /* v2.08: default type for locals in 64-bit is still DWORD (at least in Win64) */
; 516  :             //case USE64: local->sym.mem_type = MT_QWORD; break;
; 517  :             //ti.size = sizeof( uint_64 );
; 518  : #endif
; 519  :         default: 
; 520  :             local->sym.mem_type = MT_DWORD;

	mov	DWORD PTR [rax+44], 3

; 521  :             ti.size = sizeof( uint_32 );

	mov	DWORD PTR ti$[rsp], 4

; 522  :             break;

	jmp	SHORT $LN26@LocalDir
$LN25@LocalDir:

; 510  :         case USE16:
; 511  :             local->sym.mem_type = MT_WORD;

	mov	DWORD PTR [rax+44], 1

; 512  :             ti.size = sizeof( uint_16 );

	mov	DWORD PTR ti$[rsp], 2
$LN26@LocalDir:

; 523  :         }
; 524  : 
; 525  :         i++; /* go past name */

	mov	ecx, DWORD PTR i$[rsp]
	inc	ecx

; 526  : 
; 527  :         /* get the optional index factor: local name[xx]:... */
; 528  :         if( tokenarray[i].token == T_OP_SQ_BRACKET ) {

	movsxd	rax, ecx
	mov	DWORD PTR i$[rsp], ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 91			; 0000005bH
	jne	$LN14@LocalDir

; 529  :             int j;
; 530  :             struct expr opndx;
; 531  :             i++; /* go past '[' */
; 532  :             /* scan for comma or colon. this isn't really necessary,
; 533  :              * but will prevent the expression evaluator from emitting
; 534  :              * confusing error messages.
; 535  :              */
; 536  :             for ( j = i; j < Token_Count; j++ )

	mov	r8d, DWORD PTR ModuleInfo+496
	inc	ecx
	cmp	ecx, r8d
	mov	DWORD PTR i$[rsp], ecx
	movsxd	rax, ecx
	jge	SHORT $LN54@LocalDir
	shl	rax, 5
	add	rax, rdi
$LL22@LocalDir:

; 537  :                 if ( tokenarray[j].token == T_COMMA ||
; 538  :                     tokenarray[j].token == T_COLON)

	movzx	edx, BYTE PTR [rax]
	cmp	dl, 44					; 0000002cH
	je	SHORT $LN54@LocalDir
	cmp	dl, 58					; 0000003aH
	je	SHORT $LN54@LocalDir
	inc	ecx
	add	rax, 32					; 00000020H
	cmp	ecx, r8d
	jl	SHORT $LL22@LocalDir
$LN54@LocalDir:

; 539  :                     break;
; 540  :             if ( ERROR == EvalOperand( &i, tokenarray, j, &opndx, 0 ) )

	mov	r8d, ecx
	lea	r9, QWORD PTR opndx$6150[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rdi
	mov	BYTE PTR [rsp+32], bpl
	call	EvalOperand
	cmp	eax, -1
	je	$LN48@LocalDir

; 541  :                 return( ERROR );
; 542  :             if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$6150[rsp+60], ebp
	je	SHORT $LN53@LocalDir

; 543  :                 EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 544  :                 opndx.value = 1;

	mov	r11d, 1
	mov	DWORD PTR opndx$6150[rsp], r11d
	jmp	SHORT $LN16@LocalDir
$LN53@LocalDir:
	mov	r11d, DWORD PTR opndx$6150[rsp]
$LN16@LocalDir:

; 545  :             }
; 546  :             /* zero is allowed as value! */
; 547  :             local->sym.total_length = opndx.value;
; 548  :             local->sym.isarray = TRUE;

	or	BYTE PTR [rbx+49], 2
	mov	DWORD PTR [rbx+72], r11d

; 549  :             if( tokenarray[i].token == T_CL_SQ_BRACKET ) {

	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 93			; 0000005dH
	jne	SHORT $LN15@LocalDir

; 550  :                 i++; /* go past ']' */

	inc	ecx
	mov	DWORD PTR i$[rsp], ecx

; 551  :             } else {

	jmp	SHORT $LN14@LocalDir
$LN15@LocalDir:

; 552  :                 EmitError( EXPECTED_CL_SQ_BRACKET );

	mov	ecx, 111				; 0000006fH
	call	EmitError
	mov	ecx, DWORD PTR i$[rsp]
$LN14@LocalDir:

; 553  :             }
; 554  :         }
; 555  : 
; 556  :         /* get the optional type: local name[xx]:type  */
; 557  :         if( tokenarray[i].token == T_COLON ) {

	movsxd	rax, ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 58			; 0000003aH
	jne	SHORT $LN10@LocalDir

; 558  :             i++;

	inc	ecx

; 559  : 
; 560  :             if ( GetQualifiedType( &i, tokenarray, &ti ) == ERROR )

	lea	r8, QWORD PTR ti$[rsp]
	mov	rdx, rdi
	mov	DWORD PTR i$[rsp], ecx
	lea	rcx, QWORD PTR i$[rsp]
	call	GetQualifiedType
	cmp	eax, -1
	je	$LN48@LocalDir

; 561  :                 return( ERROR );
; 562  : 
; 563  :             local->sym.mem_type = ti.mem_type;

	mov	eax, DWORD PTR ti$[rsp+16]
	mov	DWORD PTR [rbx+44], eax

; 564  :             if ( ti.mem_type == MT_TYPE ) {

	cmp	DWORD PTR ti$[rsp+16], 196		; 000000c4H
	jne	SHORT $LN11@LocalDir

; 565  :                 local->sym.type = ti.symtype;

	mov	rax, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rbx+88], rax

; 566  :             } else {

	jmp	SHORT $LN10@LocalDir
$LN11@LocalDir:

; 567  :                 local->sym.target_type = ti.symtype;

	mov	rax, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rbx+56], rax
$LN10@LocalDir:

; 568  :             }
; 569  :             DebugMsg1(("LocalDir: memtype=%X, type=%s, size=%u*%u\n",
; 570  :                        local->sym.mem_type,
; 571  :                        ti.symtype ? ti.symtype->name : "NULL",
; 572  :                        ti.size, local->sym.total_length ));
; 573  :         }
; 574  :         local->sym.is_ptr  = ti.is_ptr;

	movzx	eax, BYTE PTR ti$[rsp+20]
	mov	BYTE PTR [rbx+53], al

; 575  :         local->sym.isfar   = ti.is_far;

	movzx	eax, BYTE PTR ti$[rsp+21]
	shl	al, 4
	xor	al, BYTE PTR [rbx+55]
	and	al, 16
	xor	BYTE PTR [rbx+55], al

; 576  :         local->sym.Ofssize = ti.Ofssize;

	movzx	eax, BYTE PTR ti$[rsp+22]
	mov	BYTE PTR [rbx+52], al

; 577  :         local->sym.ptr_memtype = ti.ptr_memtype;

	movzx	eax, BYTE PTR ti$[rsp+24]
	mov	BYTE PTR [rbx+54], al

; 578  :         local->sym.total_size = ti.size * local->sym.total_length;

	mov	eax, DWORD PTR [rbx+72]
	imul	eax, DWORD PTR ti$[rsp]
	mov	DWORD PTR [rbx+64], eax

; 579  : 
; 580  :         /* v2.12: address calculation is now done in SetLocalOffsets() */
; 581  : 
; 582  :         if( info->locallist == NULL ) {

	mov	rcx, QWORD PTR [rsi+16]
	test	rcx, rcx
	jne	SHORT $LN9@LocalDir

; 583  :             info->locallist = local;

	mov	QWORD PTR [rsi+16], rbx

; 584  :         } else {

	jmp	SHORT $LN8@LocalDir
$LN9@LocalDir:

; 585  :             for( curr = info->locallist; curr->nextlocal ; curr = curr->nextlocal );

	mov	rax, QWORD PTR [rcx+120]
	test	rax, rax
	je	SHORT $LN5@LocalDir
$LL7@LocalDir:
	mov	rcx, rax
	mov	rax, QWORD PTR [rax+120]
	test	rax, rax
	jne	SHORT $LL7@LocalDir
$LN5@LocalDir:

; 586  :             curr->nextlocal = local;

	mov	QWORD PTR [rcx+120], rbx
$LN8@LocalDir:

; 587  :         }
; 588  : 
; 589  :         if ( tokenarray[i].token != T_FINAL )

	movsxd	r8, DWORD PTR i$[rsp]
	mov	edx, DWORD PTR ModuleInfo+496
	mov	rax, r8
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+rdi]
	test	cl, cl
	je	SHORT $LN34@LocalDir

; 590  :             if ( tokenarray[i].token == T_COMMA ) {

	cmp	cl, 44					; 0000002cH
	jne	SHORT $LN3@LocalDir

; 591  :                 if ( (i + 1) < Token_Count )

	lea	eax, DWORD PTR [r8+1]
	cmp	eax, edx
	cmovl	r8d, eax
	mov	DWORD PTR i$[rsp], r8d
$LN34@LocalDir:

; 595  :             }
; 596  : 
; 597  :     } while ( i < Token_Count );

	cmp	r8d, edx
	jl	$LL35@LocalDir

; 598  : 
; 599  :     return( NOT_ERROR );

	xor	eax, eax
$LN57@LocalDir:
	mov	rbx, QWORD PTR [rsp+240]
	mov	rbp, QWORD PTR [rsp+248]
	mov	rsi, QWORD PTR [rsp+208]
	mov	rdi, QWORD PTR [rsp+200]

; 600  : }

	add	rsp, 216				; 000000d8H
	ret	0
$LN46@LocalDir:

; 476  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, r8d
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+8]
	call	EmitErr
	jmp	SHORT $LN57@LocalDir
$LN48@LocalDir:

; 502  :             DebugMsg(("LocalDir: SymLCreate( %s ) failed\n", name ));
; 503  :             return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN57@LocalDir
$LN3@LocalDir:

; 592  :                     i++;
; 593  :             } else {
; 594  :                 return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	mov	rdx, r8
	mov	ecx, 39					; 00000027H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+24]
	call	EmitErr
	jmp	SHORT $LN57@LocalDir
$LN37@LocalDir:

; 458  :         return( EmitError( PROC_MACRO_MUST_PRECEDE_LOCAL ) );

	mov	ecx, 92					; 0000005cH
	call	EmitError
	mov	rdi, QWORD PTR [rsp+200]

; 600  : }

	add	rsp, 216				; 000000d8H
	ret	0
LocalDir ENDP
_TEXT	ENDS
PUBLIC	UpdateStackBase
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
sym$ = 8
opnd$ = 16
UpdateStackBase PROC NEAR

; 609  :     if ( opnd ) {

	test	rdx, rdx
	je	SHORT $LN4@UpdateStac

; 610  :         StackAdj = opnd->uvalue;

	mov	r8d, DWORD PTR [rdx]
	mov	DWORD PTR StackAdj, r8d

; 611  :         StackAdjHigh = opnd->hvalue;

	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR StackAdjHigh, eax

; 612  :     }
; 613  :     sym->value = StackAdj;

	mov	DWORD PTR [rcx+16], r8d

; 614  :     sym->value3264 = StackAdjHigh;

	mov	eax, DWORD PTR StackAdjHigh
	mov	DWORD PTR [rcx+64], eax

; 615  : }

	ret	0
$LN4@UpdateStac:

; 612  :     }
; 613  :     sym->value = StackAdj;

	mov	eax, DWORD PTR StackAdj
	mov	DWORD PTR [rcx+16], eax

; 614  :     sym->value3264 = StackAdjHigh;

	mov	eax, DWORD PTR StackAdjHigh
	mov	DWORD PTR [rcx+64], eax

; 615  : }

	ret	0
UpdateStackBase ENDP
_TEXT	ENDS
PUBLIC	UpdateProcStatus
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
sym$ = 8
opnd$ = 16
UpdateProcStatus PROC NEAR

; 622  :     sym->value = ( CurrProc ? ProcStatus : 0 );

	xor	eax, eax
	cmp	QWORD PTR CurrProc, rax
	cmovne	eax, DWORD PTR ProcStatus
	mov	DWORD PTR [rcx+16], eax

; 623  : }

	ret	0
UpdateProcStatus ENDP
_TEXT	ENDS
EXTRN	SymAlloc:NEAR
EXTRN	SymAddLocal:NEAR
EXTRN	SymFind:NEAR
xdata	SEGMENT
$unwind$ParseParams DD 012ba01H
	DD	0bf4baH
	DD	0ce4b3H
	DD	0dd4aeH
	DD	01064a6H
	DD	012349eH
	DD	0ec426H
	DD	0f7420H
	DD	011541cH
	DD	0130118H
xdata	ENDS
pdata	SEGMENT
$pdata$ParseParams DD @imagerel(ParseParams#)
	DD	@imagerel(ParseParams#+2358)
	DD	@imagerel($unwind$ParseParams#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
fcint$ = 32
$T7752 = 40
ti$ = 48
init_done$1$ = 160
proc$ = 160
i$ = 168
tokenarray$ = 176
IsPROC$ = 184
ParseParams PROC NEAR

; 633  : {

	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	rax, rsp
	sub	rsp, 152				; 00000098H
	mov	QWORD PTR [rax-16], rbp
	mov	QWORD PTR [rax-32], rdi

; 634  :     char            *name;
; 635  :     struct asym     *sym;
; 636  :     int             cntParam;
; 637  :     int             offset = 0;
; 638  :     //int             rcnt = 0;
; 639  :     int             fcint = 0;

	xor	edi, edi
	mov	QWORD PTR [rax-40], r12
	mov	DWORD PTR [rax-120], edi

; 640  :     struct qualified_type ti;
; 641  :     bool            is_vararg;
; 642  :     bool            init_done;
; 643  :     struct dsym     *paranode;
; 644  :     struct dsym     *paracurr;
; 645  :     int             curr;
; 646  : 	int             paracount = 0;
; 647  : 	int             tmp = 0;
; 648  : 
; 649  :     /*
; 650  :      * find "first" parameter ( that is, the first to be pushed in INVOKE ).
; 651  :      */
; 652  :     if (proc->sym.langtype == LANG_C ||
; 653  :         proc->sym.langtype == LANG_SYSCALL ||
; 654  : #if AMD64_SUPPORT
; 655  :         ( proc->sym.langtype == LANG_FASTCALL && ModuleInfo.Ofssize != USE64 ) ||
; 656  :         ( proc->sym.langtype == LANG_VECTORCALL && ModuleInfo.Ofssize != USE64 ) ||
; 657  : #else
; 658  :         proc->sym.langtype == LANG_FASTCALL ||
; 659  :         proc->sym.langtype == LANG_VECTORCALL ||
; 660  : #endif
; 661  :         proc->sym.langtype == LANG_STDCALL)

	mov	eax, DWORD PTR [rcx+84]
	cmp	eax, 1
	movzx	r11d, r9b
	movsxd	r10, edx
	mov	r9, r8
	mov	rbp, rcx
	je	SHORT $LN119@ParseParam
	cmp	eax, 2
	je	SHORT $LN119@ParseParam
	cmp	eax, 7
	jne	SHORT $LN118@ParseParam
	cmp	BYTE PTR ModuleInfo+404, 2
	jne	SHORT $LN119@ParseParam
$LN118@ParseParam:
	cmp	eax, 8
	jne	SHORT $LN117@ParseParam
	cmp	BYTE PTR ModuleInfo+404, 2
	jne	SHORT $LN119@ParseParam
$LN117@ParseParam:
	cmp	eax, 3
	je	SHORT $LN119@ParseParam

; 663  :     else
; 664  :         paracurr = proc->e.procinfo->paralist;

	mov	rax, QWORD PTR [rcx+104]
	mov	r12, QWORD PTR [rax+8]
	jmp	SHORT $LN161@ParseParam
$LN119@ParseParam:

; 662  :         for ( paracurr = proc->e.procinfo->paralist; paracurr && paracurr->nextparam; paracurr = paracurr->nextparam );

	mov	rax, QWORD PTR [rcx+104]
	mov	r12, QWORD PTR [rax+8]
	test	r12, r12
	je	SHORT $LN161@ParseParam
	npad	5
$LL116@ParseParam:
	mov	rax, QWORD PTR [r12+120]
	test	rax, rax
	je	SHORT $LN161@ParseParam
	test	rax, rax
	mov	r12, rax
	jne	SHORT $LL116@ParseParam
$LN161@ParseParam:

; 665  : 
; 666  :     /* v2.11: proc_info.init_done has been removed, sym.isproc flag is used instead */
; 667  :     init_done = proc->sym.isproc;

	movzx	eax, BYTE PTR [rcx+49]
	mov	QWORD PTR [rsp+144], rbx
	mov	QWORD PTR [rsp+128], rsi
	shr	al, 3
	mov	QWORD PTR [rsp+104], r13
	mov	QWORD PTR [rsp+96], r14
	and	al, 1
	mov	QWORD PTR [rsp+88], r15

; 668  :     //if (proc->sym.langtype == 8)__debugbreak();
; 669  :     for( cntParam = 0 ; tokenarray[i].token != T_FINAL ; cntParam++ ) {

	mov	QWORD PTR $T7752[rsp], rdi
	mov	BYTE PTR init_done$1$[rsp], al
	mov	rax, r10
	mov	r15d, edi
	shl	rax, 5
	lea	rcx, QWORD PTR [rax+r8]
	movzx	eax, BYTE PTR [rax+r8]
	test	al, al
	je	$LN160@ParseParam
	mov	r8d, 3
$LL112@ParseParam:

; 670  : 
; 671  :         if ( tokenarray[i].token == T_ID ) {

	cmp	al, 8
	jne	SHORT $LN109@ParseParam

; 672  :             name = tokenarray[i++].string_ptr;

	mov	r14, QWORD PTR [rcx+8]
	inc	r10d
	mov	DWORD PTR i$[rsp], r10d
	jmp	SHORT $LN105@ParseParam
$LN109@ParseParam:

; 673  :         } else if ( IsPROC == FALSE && tokenarray[i].token == T_COLON ) {

	test	r11b, r11b
	jne	$LN107@ParseParam
	cmp	al, 58					; 0000003aH
	jne	$LN107@ParseParam

; 674  :             if ( paracurr )

	test	r12, r12
	je	SHORT $LN106@ParseParam

; 675  :                 name = paracurr->sym.name;

	mov	r14, QWORD PTR [r12+8]

; 676  :             else

	jmp	SHORT $LN105@ParseParam
$LN106@ParseParam:

; 677  :                 name = "";

	lea	r14, OFFSET FLAT:$SG6226
$LN105@ParseParam:

; 683  :         }
; 684  : 
; 685  :         ti.symtype = NULL;
; 686  :         ti.is_ptr = 0;
; 687  :         ti.ptr_memtype = MT_EMPTY;
; 688  :         /* v2.02: init is_far depending on memory model */
; 689  :         //ti.is_far = FALSE;
; 690  :         if ( SIZE_DATAPTR & ( 1 << ModuleInfo.model ) )

	mov	ecx, DWORD PTR ModuleInfo+360

; 691  :             ti.is_far = TRUE;
; 692  :         else
; 693  :             ti.is_far = FALSE;
; 694  :         ti.Ofssize = ModuleInfo.Ofssize;

	movzx	r13d, BYTE PTR ModuleInfo+404
	mov	eax, 1
	shl	al, cl
	mov	QWORD PTR ti$[rsp+8], rdi
	mov	BYTE PTR ti$[rsp+20], dil
	test	al, 104					; 00000068H

; 695  :         ti.size = CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	DWORD PTR ti$[rsp+24], 192		; 000000c0H
	mov	DWORD PTR ti$[rsp], eax
	setne	BYTE PTR ti$[rsp+21]

; 696  : 
; 697  :         is_vararg = FALSE;
; 698  : 
; 699  :         /* read colon. It's optional for PROC.
; 700  :          * Masm also allows a missing colon for PROTO - if there's
; 701  :          * just one parameter. Probably a Masm bug.
; 702  :          * HJWasm always require a colon for PROTO.
; 703  :          */
; 704  :         if( tokenarray[i].token != T_COLON ) {

	movsxd	rax, r10d
	shl	rax, 5
	mov	BYTE PTR ti$[rsp+22], r13b
	xor	sil, sil
	cmp	BYTE PTR [rax+r9], 58			; 0000003aH
	je	SHORT $LN101@ParseParam

; 705  :             if ( IsPROC == FALSE ) {

	test	r11b, r11b
	je	$LN143@ParseParam

; 707  :             }
; 708  :             switch ( ti.Ofssize ) {

	mov	ebx, 1
	test	r13b, r13b
	cmovne	ebx, r8d
	mov	DWORD PTR ti$[rsp+16], ebx

; 709  :             case USE16:
; 710  :                 ti.mem_type = MT_WORD; break;
; 711  : #if AMD64_SUPPORT
; 712  :                 /* v2.08: default size for arguments is DWORD in 64-bit ( Win64 ) */
; 713  :                 //case USE64: ti.mem_type = MT_QWORD; break;
; 714  : #endif
; 715  :             default:
; 716  :                 ti.mem_type = MT_DWORD; break;
; 717  :             }
; 718  :         } else {

	jmp	$LN87@ParseParam
$LN101@ParseParam:

; 719  :             i++;

	inc	r10d

; 720  :             if (( tokenarray[i].token == T_RES_ID ) && ( tokenarray[i].tokval == T_VARARG )) {

	movsxd	rax, r10d
	mov	DWORD PTR i$[rsp], r10d
	shl	rax, 5
	cmp	BYTE PTR [rax+r9], 7
	jne	SHORT $LN94@ParseParam
	cmp	DWORD PTR [rax+r9+16], 262		; 00000106H
	jne	SHORT $LN94@ParseParam

; 721  :                 switch( proc->sym.langtype ) {

	mov	ecx, DWORD PTR [rbp+84]
	test	ecx, ecx
	je	$LN91@ParseParam
	cmp	ecx, 2
	jle	SHORT $LN92@ParseParam
	cmp	ecx, 6
	jle	$LN91@ParseParam
$LN92@ParseParam:

; 728  :                 }
; 729  :                 /* v2.05: added check */
; 730  :                 if ( tokenarray[i+1].token != T_FINAL )

	cmp	BYTE PTR [rax+r9+32], dil
	je	SHORT $LN90@ParseParam

; 731  :                     EmitError( VARARG_PARAMETER_MUST_BE_LAST );

	mov	ecx, 147				; 00000093H
	call	EmitError

; 732  :                 else

	mov	r10d, DWORD PTR i$[rsp]
	mov	r13b, BYTE PTR ti$[rsp+22]
	jmp	SHORT $LN89@ParseParam
$LN90@ParseParam:

; 733  :                     is_vararg = TRUE;

	mov	sil, 1
$LN89@ParseParam:

; 734  :                 ti.mem_type = MT_EMPTY;

	mov	ebx, 192				; 000000c0H

; 735  :                 ti.size = 0;
; 736  :                 i++;

	inc	r10d
	mov	DWORD PTR ti$[rsp], edi
	mov	DWORD PTR ti$[rsp+16], ebx
	mov	DWORD PTR i$[rsp], r10d

; 737  :             } else {

	jmp	SHORT $LN87@ParseParam
$LN94@ParseParam:

; 738  :                 if ( GetQualifiedType( &i, tokenarray, &ti ) == ERROR )

	lea	r8, QWORD PTR ti$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, r9
	call	GetQualifiedType
	cmp	eax, -1
	je	$LN147@ParseParam
	mov	r10d, DWORD PTR i$[rsp]
	mov	r13b, BYTE PTR ti$[rsp+22]
	mov	ebx, DWORD PTR ti$[rsp+16]
$LN87@ParseParam:

; 739  :                     return( ERROR );
; 740  :             }
; 741  :         }
; 742  : 
; 743  :         /* check if parameter name is defined already */
; 744  :         if (( IsPROC ) && ( sym = SymSearch( name ) ) && sym->state != SYM_UNDEFINED ) {

	mov	al, BYTE PTR IsPROC$[rsp]
	test	al, al
	je	SHORT $LN86@ParseParam
	mov	rcx, r14
	call	SymFind
	test	rax, rax
	je	SHORT $LN159@ParseParam
	cmp	DWORD PTR [rax+40], edi
	jne	$LN145@ParseParam
$LN159@ParseParam:
	mov	r10d, DWORD PTR i$[rsp]
	mov	r13b, BYTE PTR ti$[rsp+22]
	mov	ebx, DWORD PTR ti$[rsp+16]
	mov	al, BYTE PTR IsPROC$[rsp]
$LN86@ParseParam:

; 747  :         }
; 748  : 
; 749  :         /* redefinition? */
; 750  :         if ( paracurr ) {

	test	r12, r12
	je	$LN85@ParseParam

; 751  : #if 0 /* was active till v2.04 */
; 752  :             int newsize = ti.size;
; 753  :             int oldsize;
; 754  :             /* check size only (so UINT <-> DWORD wont cause an error) */
; 755  :             if ( paracurr->sym.type )
; 756  :                 oldsize = paracurr->sym.total_size;
; 757  :             else if ( paracurr->sym.mem_type == MT_EMPTY )
; 758  :                 oldsize = 0;
; 759  :             else if ( paracurr->sym.mem_type == MT_PTR )
; 760  :                 oldsize = SizeFromMemtype( paracurr->sym.isfar ? MT_FAR : MT_NEAR, paracurr->sym.Ofssize, NULL );
; 761  :             else
; 762  :                 oldsize = SizeFromMemtype( paracurr->sym.mem_type, paracurr->sym.Ofssize, paracurr->sym.type );
; 763  :             if ( oldsize != newsize ) {
; 764  :                 DebugMsg(("ParseParams: old memtype=%u, new memtype=%u\n", paracurr->sym.mem_type, ti.mem_type));
; 765  :                 EmitErr( CONFLICTING_PARAMETER_DEFINITION, name );
; 766  :                 //return( ERROR );
; 767  :             }
; 768  :             /* the parameter type used in PROC has highest priority! */
; 769  :             if ( IsPROC ) {
; 770  :                 if ( ti.symtype ) {
; 771  :                     paracurr->sym.type = ti.symtype;
; 772  :                     paracurr->sym.mem_type = MT_TYPE;
; 773  :                 } else
; 774  :                     paracurr->sym.mem_type = ti.mem_type;
; 775  :             }
; 776  : #else
; 777  :             struct asym *to;
; 778  :             struct asym *tn;
; 779  :             char oo;
; 780  :             char on;
; 781  :             for( tn = ti.symtype; tn && tn->type; tn = tn->type );

	mov	r8, QWORD PTR ti$[rsp+8]
	test	r8, r8
	je	SHORT $LN162@ParseParam
$LL84@ParseParam:
	mov	rax, QWORD PTR [r8+88]
	test	rax, rax
	je	SHORT $LN162@ParseParam
	test	rax, rax
	mov	r8, rax
	jne	SHORT $LL84@ParseParam
$LN162@ParseParam:

; 782  :             /* v2.12: don't assume pointer type if mem_type is != MT_TYPE!
; 783  :              * regression test proc9.asm.
; 784  :              */
; 785  :             //to = ( paracurr->sym.mem_type == MT_TYPE ) ? paracurr->sym.type : paracurr->sym.target_type;
; 786  :             if ( paracurr->sym.mem_type == MT_TYPE )

	mov	esi, DWORD PTR [r12+44]
	cmp	esi, 196				; 000000c4H
	jne	SHORT $LN81@ParseParam

; 787  :                 to = paracurr->sym.type;

	mov	rdx, QWORD PTR [r12+88]
$LN124@ParseParam:

; 790  :             for( ; to && to->type; to = to->type );

	test	rdx, rdx
	je	SHORT $LN163@ParseParam
	npad	6
$LL79@ParseParam:
	mov	rax, QWORD PTR [rdx+88]
	test	rax, rax
	je	SHORT $LN163@ParseParam
	test	rax, rax
	mov	rdx, rax
	jne	SHORT $LL79@ParseParam
$LN163@ParseParam:

; 791  :             oo = ( paracurr->sym.Ofssize != USE_EMPTY ) ? paracurr->sym.Ofssize : ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR [r12+52]
	movzx	ecx, BYTE PTR ModuleInfo+404
	cmp	al, 254					; 000000feH
	mov	r9d, ecx

; 792  :             on = ( ti.Ofssize != USE_EMPTY ) ? ti.Ofssize : ModuleInfo.Ofssize;

	mov	r11d, ecx
	cmovne	r9d, eax
	cmp	r13b, 254				; 000000feH
	movzx	eax, r13b
	cmovne	r11d, eax

; 793  :             if ( ti.mem_type != paracurr->sym.mem_type ||
; 794  :                 ( ti.mem_type == MT_TYPE && tn != to ) ||
; 795  :                 ( ti.mem_type == MT_PTR &&
; 796  :                  ( ti.is_far != paracurr->sym.isfar ||
; 797  :                   on != oo ||
; 798  :                   ti.ptr_memtype != paracurr->sym.ptr_memtype ||
; 799  :                   tn != to ))) {

	cmp	ebx, esi
	jne	SHORT $LN73@ParseParam
	cmp	ebx, 196				; 000000c4H
	jne	SHORT $LN74@ParseParam
	cmp	r8, rdx
	jne	SHORT $LN73@ParseParam
	jmp	SHORT $LN76@ParseParam
$LN81@ParseParam:

; 788  :             else
; 789  :                 to = ( paracurr->sym.mem_type == MT_PTR ? paracurr->sym.target_type : NULL );

	cmp	esi, 195				; 000000c3H
	jne	SHORT $LN123@ParseParam
	mov	rdx, QWORD PTR [r12+56]
	jmp	SHORT $LN124@ParseParam
$LN123@ParseParam:
	mov	rdx, rdi

; 790  :             for( ; to && to->type; to = to->type );

	jmp	SHORT $LN163@ParseParam
$LN74@ParseParam:

; 793  :             if ( ti.mem_type != paracurr->sym.mem_type ||
; 794  :                 ( ti.mem_type == MT_TYPE && tn != to ) ||
; 795  :                 ( ti.mem_type == MT_PTR &&
; 796  :                  ( ti.is_far != paracurr->sym.isfar ||
; 797  :                   on != oo ||
; 798  :                   ti.ptr_memtype != paracurr->sym.ptr_memtype ||
; 799  :                   tn != to ))) {

	cmp	ebx, 195				; 000000c3H
	jne	SHORT $LN76@ParseParam
	movzx	eax, BYTE PTR [r12+55]
	shr	al, 4
	and	al, 1
	cmp	BYTE PTR ti$[rsp+21], al
	jne	SHORT $LN73@ParseParam
	cmp	r11b, r9b
	jne	SHORT $LN73@ParseParam
	movzx	eax, BYTE PTR [r12+54]
	cmp	DWORD PTR ti$[rsp+24], eax
	jne	SHORT $LN73@ParseParam
	cmp	r8, rdx
	je	SHORT $LN76@ParseParam
$LN73@ParseParam:

; 800  :                 DebugMsg(("ParseParams: old-new memtype=%X-%X type=%X(%s)-%X(%s) far=%u-%u ind=%u-%u ofss=%d-%d pmt=%X-%X\n",
; 801  :                           paracurr->sym.mem_type, ti.mem_type, 
; 802  :                           (paracurr->sym.mem_type == MT_TYPE) ? paracurr->sym.type : paracurr->sym.target_type,
; 803  :                           (paracurr->sym.mem_type == MT_TYPE) ? paracurr->sym.type->name : paracurr->sym.target_type ? paracurr->sym.target_type->name : "",
; 804  :                           ti.symtype, ti.symtype ? ti.symtype->name : "",
; 805  :                           paracurr->sym.isfar, ti.is_far,
; 806  :                           paracurr->sym.is_ptr, ti.is_ptr,
; 807  :                           paracurr->sym.Ofssize, ti.Ofssize,
; 808  :                           paracurr->sym.ptr_memtype, ti.ptr_memtype ));
; 809  :                 EmitErr( CONFLICTING_PARAMETER_DEFINITION, name );

	mov	rdx, r14
	mov	ecx, 137				; 00000089H
	call	EmitErr
	mov	r10d, DWORD PTR i$[rsp]
	mov	r13b, BYTE PTR ti$[rsp+22]
$LN76@ParseParam:

; 810  :                 //return( ERROR );
; 811  :             }
; 812  : #endif
; 813  :             if ( IsPROC ) {

	cmp	BYTE PTR IsPROC$[rsp], dil
	je	SHORT $LN72@ParseParam

; 814  :                 DebugMsg1(("ParseParams: calling SymAddLocal(%s, %s)\n", paracurr->sym.name, name ));
; 815  :                 /* it has been checked already that the name isn't found - SymAddLocal() shouldn't fail */
; 816  :                 SymAddLocal( &paracurr->sym, name );

	mov	rdx, r14
	mov	rcx, r12
	call	SymAddLocal
	mov	r10d, DWORD PTR i$[rsp]
	mov	r13b, BYTE PTR ti$[rsp+22]
$LN72@ParseParam:

; 817  :             }
; 818  :             /* set paracurr to next parameter */
; 819  :             if ( proc->sym.langtype == LANG_C ||
; 820  :                 proc->sym.langtype == LANG_SYSCALL ||
; 821  : #if AMD64_SUPPORT
; 822  :                 ( proc->sym.langtype == LANG_FASTCALL && ti.Ofssize != USE64 ) ||
; 823  :                 ( proc->sym.langtype == LANG_VECTORCALL && ti.Ofssize != USE64) ||
; 824  : #else
; 825  :                 proc->sym.langtype == LANG_FASTCALL ||
; 826  : #endif
; 827  :                 proc->sym.langtype == LANG_STDCALL) {

	mov	eax, DWORD PTR [rbp+84]
	cmp	eax, 1
	je	SHORT $LN70@ParseParam
	cmp	eax, 2
	je	SHORT $LN70@ParseParam
	cmp	eax, 7
	jne	SHORT $LN69@ParseParam
	cmp	r13b, 2
	jne	SHORT $LN70@ParseParam
$LN69@ParseParam:
	cmp	eax, 8
	jne	SHORT $LN68@ParseParam
	cmp	r13b, 2
	jne	SHORT $LN70@ParseParam
$LN68@ParseParam:
	cmp	eax, 3
	je	SHORT $LN70@ParseParam

; 833  :             } else
; 834  :                 paracurr = paracurr->nextparam;

	mov	r12, QWORD PTR [r12+120]
	jmp	$LN44@ParseParam
$LN70@ParseParam:

; 828  :                 struct dsym *l;
; 829  :                 for (l = proc->e.procinfo->paralist;
; 830  :                      l && ( l->nextparam != paracurr );
; 831  :                      l = l->nextparam );

	mov	rax, QWORD PTR [rbp+104]
	mov	rcx, QWORD PTR [rax+8]
	test	rcx, rcx
	je	SHORT $LN164@ParseParam
$LL67@ParseParam:
	mov	rax, QWORD PTR [rcx+120]
	cmp	rax, r12
	je	SHORT $LN164@ParseParam
	test	rax, rax
	mov	rcx, rax
	jne	SHORT $LL67@ParseParam
$LN164@ParseParam:

; 832  :                 paracurr = l;

	mov	r12, rcx

; 835  : 
; 836  :         //} else if ( proc->e.procinfo->init_done == TRUE ) {
; 837  :         } else if ( init_done == TRUE ) {

	jmp	$LN44@ParseParam
$LN85@ParseParam:
	cmp	BYTE PTR init_done$1$[rsp], 1
	je	$LN146@ParseParam

; 841  :         } else {
; 842  :             if ( IsPROC ) {

	test	al, al
	je	SHORT $LN60@ParseParam

; 843  :                 paranode = (struct dsym *)SymLCreate( name );

	mov	rcx, r14
	call	SymLCreate
	mov	rbx, rax

; 844  :             } else

	jmp	SHORT $LN59@ParseParam
$LN60@ParseParam:

; 845  :                 paranode = (struct dsym *)SymAlloc( "" );/* for PROTO, no param name needed */

	lea	rcx, OFFSET FLAT:$SG6287
	call	SymAlloc
	mov	rbx, rax
$LN59@ParseParam:

; 846  : 
; 847  :             if( paranode == NULL ) { /* error msg has been displayed already */

	test	rbx, rbx
	je	$LN147@ParseParam

; 850  :             }
; 851  :             paranode->sym.isdefined = TRUE;

	or	BYTE PTR [rbx+48], 2

; 852  :             paranode->sym.mem_type = ti.mem_type;

	mov	eax, DWORD PTR ti$[rsp+16]
	mov	DWORD PTR [rbx+44], eax

; 853  :             if ( ti.mem_type == MT_TYPE ) {

	cmp	DWORD PTR ti$[rsp+16], 196		; 000000c4H
	jne	SHORT $LN57@ParseParam

; 854  :                 paranode->sym.type = ti.symtype;

	mov	rax, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rbx+88], rax

; 855  :                 /* this is where vectors are intercepted  and writen to the proc */
; 856  :                 if (proc->sym.langtype == LANG_VECTORCALL){

	cmp	DWORD PTR [rbp+84], 8
	jne	$LN53@ParseParam

; 857  :                     proc->e.procinfo->vecregsize[cntParam] = ti.symtype->max_mbr_size;

	mov	rax, QWORD PTR ti$[rsp+8]
	mov	rdx, QWORD PTR [rbp+104]
	mov	r8, QWORD PTR $T7752[rsp]
	movzx	ecx, BYTE PTR [rax+56]
	mov	BYTE PTR [r8+rdx+62], cl

; 858  :                     proc->e.procinfo->vecregs[cntParam] = ti.size / ti.symtype->max_mbr_size;

	mov	rcx, QWORD PTR ti$[rsp+8]
	mov	eax, DWORD PTR ti$[rsp]
	xor	edx, edx
	div	DWORD PTR [rcx+56]
	mov	rcx, QWORD PTR [rbp+104]
	mov	BYTE PTR [r8+rcx+56], al

; 859  :                     proc->e.procinfo->vsize += ti.size;

	mov	eax, DWORD PTR ti$[rsp]
	mov	rcx, QWORD PTR [rbp+104]
	add	DWORD PTR [rcx+44], eax

; 860  :                     ti.size = MT_QWORD;

	mov	DWORD PTR ti$[rsp], 7

; 861  :                   }
; 862  :             } else {

	jmp	SHORT $LN53@ParseParam
$LN57@ParseParam:

; 863  :                 paranode->sym.target_type = ti.symtype;

	mov	rax, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rbx+56], rax

; 864  :                     /* this is where vectors are intercepted  and writen to the proc */
; 865  :                     if (proc->sym.langtype == LANG_VECTORCALL){

	cmp	DWORD PTR [rbp+84], 8
	jne	SHORT $LN53@ParseParam

; 866  :                       if (ti.mem_type == MT_REAL4 || ti.mem_type == MT_REAL8 ||
; 867  :                         ti.mem_type == MT_OWORD || ti.mem_type == MT_YMMWORD) {

	mov	eax, DWORD PTR ti$[rsp+16]
	cmp	eax, 35					; 00000023H
	je	SHORT $LN52@ParseParam
	cmp	eax, 39					; 00000027H
	je	SHORT $LN52@ParseParam
	cmp	eax, 15
	je	SHORT $LN52@ParseParam
	cmp	eax, 31
	jne	SHORT $LN53@ParseParam
$LN52@ParseParam:

; 868  :                         proc->e.procinfo->vecregsize[cntParam] = ti.size;

	mov	rcx, QWORD PTR [rbp+104]
	movzx	eax, BYTE PTR ti$[rsp]
	mov	rdx, QWORD PTR $T7752[rsp]
	mov	BYTE PTR [rdx+rcx+62], al

; 869  :                         proc->e.procinfo->vecregs[cntParam] = 1;

	mov	rax, QWORD PTR [rbp+104]
	mov	BYTE PTR [rdx+rax+56], 1

; 870  :                         if (ti.size >= 16) proc->e.procinfo->vsize += ti.size;

	mov	ecx, DWORD PTR ti$[rsp]
	cmp	ecx, 16
	jl	SHORT $LN51@ParseParam
	mov	rax, QWORD PTR [rbp+104]
	add	DWORD PTR [rax+44], ecx
$LN51@ParseParam:

; 871  :                         ti.size = MT_QWORD;

	mov	DWORD PTR ti$[rsp], 7
$LN53@ParseParam:

; 872  :                       }
; 873  :                  }
; 874  :             }
; 875  : 
; 876  :             /* v2.05: moved BEFORE fastcall_tab() */
; 877  :             paranode->sym.isfar   = ti.is_far;

	movzx	eax, BYTE PTR ti$[rsp+21]

; 878  :             paranode->sym.Ofssize = ti.Ofssize;
; 879  :             paranode->sym.is_ptr  = ti.is_ptr;
; 880  :             paranode->sym.ptr_memtype = ti.ptr_memtype;
; 881  :             paranode->sym.is_vararg = is_vararg;

	shl	sil, 5
	shl	al, 4
	xor	al, BYTE PTR [rbx+55]
	and	al, 16
	xor	BYTE PTR [rbx+55], al
	movzx	eax, BYTE PTR ti$[rsp+22]
	xor	sil, BYTE PTR [rbx+55]
	mov	BYTE PTR [rbx+52], al
	movzx	eax, BYTE PTR ti$[rsp+20]
	and	sil, 32					; 00000020H
	mov	BYTE PTR [rbx+53], al
	movzx	eax, BYTE PTR ti$[rsp+24]
	xor	BYTE PTR [rbx+55], sil
	mov	BYTE PTR [rbx+54], al

; 882  :             if ( proc->sym.langtype == LANG_FASTCALL &&
; 883  :                 fastcall_tab[ModuleInfo.fctype].paramcheck( proc, paranode, &fcint ) ) {

	cmp	DWORD PTR [rbp+84], 7
	jne	SHORT $LN165@ParseParam
	movsxd	rax, DWORD PTR ModuleInfo+376
	lea	rsi, OFFSET FLAT:__ImageBase
	lea	r8, QWORD PTR fcint$[rsp]
	add	rax, rax
	mov	rdx, rbx
	mov	rcx, rbp
	call	QWORD PTR fastcall_tab[rsi+rax*8]
	test	eax, eax
	jne	SHORT $LN47@ParseParam
	jmp	SHORT $LN50@ParseParam
$LN165@ParseParam:

; 665  : 
; 666  :     /* v2.11: proc_info.init_done has been removed, sym.isproc flag is used instead */
; 667  :     init_done = proc->sym.isproc;

	lea	rsi, OFFSET FLAT:__ImageBase
$LN50@ParseParam:

; 884  :             }
; 885  :             else if ( proc->sym.langtype == LANG_VECTORCALL &&
; 886  :                 vectorcall_tab[ModuleInfo.fctype].paramcheck( proc, paranode, &fcint ) ) {

	cmp	DWORD PTR [rbp+84], 8
	jne	SHORT $LN48@ParseParam
	movsxd	rax, DWORD PTR ModuleInfo+376
	lea	r8, QWORD PTR fcint$[rsp]
	mov	rdx, rbx
	add	rax, rax
	mov	rcx, rbp
	call	QWORD PTR vectorcall_tab[rsi+rax*8]
	test	eax, eax
	jne	SHORT $LN47@ParseParam
$LN48@ParseParam:

; 887  :             } 
; 888  :             else {
; 889  :                 paranode->sym.state = SYM_STACK;

	mov	DWORD PTR [rbx+40], 5
$LN47@ParseParam:

; 890  :             }
; 891  : 
; 892  :             paranode->sym.total_length = 1; /* v2.04: added */
; 893  :             paranode->sym.total_size = ti.size;
; 894  : 
; 895  :             if( paranode->sym.is_vararg == FALSE )

	test	BYTE PTR [rbx+55], 32			; 00000020H
	mov	DWORD PTR [rbx+72], 1
	mov	eax, DWORD PTR ti$[rsp]
	mov	DWORD PTR [rbx+64], eax
	jne	SHORT $LN46@ParseParam

; 896  :                 /* v2.11: CurrWordSize does reflect the default parameter size only for PROCs.
; 897  :                  * For PROTOs and TYPEs use member seg_ofssize.
; 898  :                  */
; 899  :                 //proc->e.procinfo->parasize += ROUND_UP( ti.size, CurrWordSize );
; 900  :                 proc->e.procinfo->parasize += ROUND_UP( ti.size, IsPROC ? CurrWordSize : ( 2 << proc->sym.seg_ofssize ) );

	cmp	BYTE PTR IsPROC$[rsp], dil
	je	SHORT $LN129@ParseParam
	movzx	r8d, BYTE PTR ModuleInfo+406
	mov	r9d, r8d
	jmp	SHORT $LN132@ParseParam
$LN129@ParseParam:
	mov	al, BYTE PTR [rbp+55]
	mov	r8d, 2
	and	eax, 3
	movzx	ecx, al
	shl	r8d, cl
	mov	r9d, r8d
$LN132@ParseParam:
	mov	eax, DWORD PTR ti$[rsp]
	mov	rdx, QWORD PTR [rbp+104]
	lea	ecx, DWORD PTR [r8+rax-1]
	lea	eax, DWORD PTR [r9-1]
	not	eax
	and	ecx, eax
	add	DWORD PTR [rdx+32], ecx
$LN46@ParseParam:

; 901  : 
; 902  :             /* v2.05: the PROC's vararg flag has been set already */
; 903  :             //proc->e.procinfo->is_vararg |= paranode->sym.is_vararg;
; 904  : 
; 905  :             /* Parameters usually are stored in "push" order.
; 906  :              * However, for Win64, it's better to store them
; 907  :              * the "natural" way from left to right, since the
; 908  :              * arguments aren't "pushed".
; 909  :              */
; 910  : 
; 911  :             switch( proc->sym.langtype ) {

	mov	eax, DWORD PTR [rbp+84]
	cmp	eax, 4
	jl	SHORT $LN34@ParseParam
	cmp	eax, 6
	jle	SHORT $left_to_right$6307
	cmp	eax, 8
	jg	SHORT $LN34@ParseParam

; 929  :             case LANG_FASTCALL:
; 930  :             case LANG_VECTORCALL:
; 931  : #if AMD64_SUPPORT
; 932  :                 if ( ti.Ofssize == USE64 )

	movzx	eax, BYTE PTR ti$[rsp+22]
	cmp	al, 2
	je	SHORT $left_to_right$6307

; 933  :                     goto left_to_right;
; 934  : #endif
; 935  :                 /* v2.07: MS fastcall 16-bit is PASCAL! */
; 936  :                 if ( ti.Ofssize == USE16 && ModuleInfo.fctype == FCT_MSC )

	test	al, al
	jne	SHORT $LN34@ParseParam
	cmp	DWORD PTR ModuleInfo+376, edi
	jne	SHORT $LN34@ParseParam
$left_to_right$6307:

; 912  :             case LANG_BASIC:
; 913  :             case LANG_FORTRAN:
; 914  :             case LANG_PASCAL:
; 915  :             left_to_right:
; 916  :                 paranode->nextparam = NULL;

	mov	QWORD PTR [rbx+120], rdi

; 917  :                 if( proc->e.procinfo->paralist == NULL ) {

	mov	rax, QWORD PTR [rbp+104]
	mov	rcx, QWORD PTR [rax+8]
	test	rcx, rcx
	jne	SHORT $LN42@ParseParam

; 918  :                     proc->e.procinfo->paralist = paranode;

	mov	QWORD PTR [rax+8], rbx

; 919  :                 } else {

	mov	r10d, DWORD PTR i$[rsp]
	jmp	SHORT $LN44@ParseParam
$LN42@ParseParam:

; 921  :                         if( paracurr->nextparam == NULL ) {

	mov	rax, QWORD PTR [rcx+120]
	test	rax, rax
	je	SHORT $LN142@ParseParam
	npad	2
$LL40@ParseParam:

; 920  :                     for( paracurr = proc->e.procinfo->paralist;; paracurr = paracurr->nextparam ) {

	mov	rcx, rax

; 921  :                         if( paracurr->nextparam == NULL ) {

	mov	rax, QWORD PTR [rax+120]
	test	rax, rax
	jne	SHORT $LL40@ParseParam
$LN142@ParseParam:

; 922  :                             break;
; 923  :                         }
; 924  :                     }
; 925  :                     paracurr->nextparam = paranode;

	mov	QWORD PTR [rcx+120], rbx

; 926  :                     paracurr = NULL;
; 927  :                 }
; 928  :                 break;

	mov	r10d, DWORD PTR i$[rsp]
	mov	r12, rdi
	jmp	SHORT $LN44@ParseParam
$LN34@ParseParam:

; 937  :                     goto left_to_right;
; 938  :             default:
; 939  :                 paranode->nextparam = proc->e.procinfo->paralist;

	mov	rax, QWORD PTR [rbp+104]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rbx+120], rcx

; 940  :                 proc->e.procinfo->paralist = paranode;

	mov	rax, QWORD PTR [rbp+104]
	mov	QWORD PTR [rax+8], rbx
	mov	r10d, DWORD PTR i$[rsp]
$LN44@ParseParam:

; 941  :                 break;
; 942  :             }
; 943  :         }
; 944  :         if ( tokenarray[i].token != T_FINAL ) {

	mov	r9, QWORD PTR tokenarray$[rsp]
	movsxd	rax, r10d
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+r9]
	test	cl, cl
	je	SHORT $LN111@ParseParam

; 945  :             if( tokenarray[i].token != T_COMMA ) {

	cmp	cl, 44					; 0000002cH
	jne	$LN148@ParseParam

; 948  :             }
; 949  :             i++;    /* go past comma */

	inc	r10d
	mov	DWORD PTR i$[rsp], r10d
$LN111@ParseParam:
	inc	QWORD PTR $T7752[rsp]
	mov	r11b, BYTE PTR IsPROC$[rsp]
	movsxd	rax, r10d
	shl	rax, 5
	inc	r15d
	mov	r8d, 3
	lea	rcx, QWORD PTR [rax+r9]
	mov	al, BYTE PTR [rax+r9]
	test	al, al
	jne	$LL112@ParseParam
$LN160@ParseParam:

; 950  :         }
; 951  :     } /* end for */
; 952  :     //if (proc->sym.langtype == LANG_VECTORCALL)__debugbreak();
; 953  :     //if ( proc->e.procinfo->init_done == TRUE ) {
; 954  :     if ( init_done == TRUE ) {

	cmp	BYTE PTR init_done$1$[rsp], 1
	jne	$LN29@ParseParam

; 955  :         if ( paracurr ) {

	test	r12, r12
	je	$LN29@ParseParam

; 956  :             /* first definition has more parameters than second */
; 957  :             DebugMsg(("ParseParams: a param is left over, cntParam=%u\n", cntParam));
; 958  :             return( EmitErr( CONFLICTING_PARAMETER_DEFINITION, "" ) );

	lea	rdx, OFFSET FLAT:$SG6326
	mov	ecx, 137				; 00000089H
	call	EmitErr
	jmp	$LN121@ParseParam
$LN143@ParseParam:

; 706  :                 return( EmitError( COLON_EXPECTED ) );

	mov	ecx, 84					; 00000054H
	call	EmitError
	jmp	$LN121@ParseParam
$LN91@ParseParam:

; 722  :                 case LANG_NONE:
; 723  :                 case LANG_BASIC:
; 724  :                 case LANG_FORTRAN:
; 725  :                 case LANG_PASCAL:
; 726  :                 case LANG_STDCALL:
; 727  :                     return( EmitError( VARARG_REQUIRES_C_CALLING_CONVENTION ) );

	mov	ecx, 94					; 0000005eH
	call	EmitError
	jmp	$LN121@ParseParam
$LN145@ParseParam:

; 745  :             DebugMsg(("ParseParams: %s defined already, state=%u, local=%u\n", sym->name, sym->state, sym->scoped ));
; 746  :             return( EmitErr( SYMBOL_REDEFINITION, name ) );

	mov	rdx, r14
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN121@ParseParam
$LN146@ParseParam:

; 838  :             /* second definition has more parameters than first */
; 839  :             DebugMsg(("ParseParams: different param count\n"));
; 840  :             return( EmitErr( CONFLICTING_PARAMETER_DEFINITION, "" ) );

	lea	rdx, OFFSET FLAT:$SG6281
	mov	ecx, 137				; 00000089H
	call	EmitErr
	jmp	$LN121@ParseParam
$LN147@ParseParam:

; 848  :                 DebugMsg(("ParseParams: SymLCreate(%s) failed\n", name ));
; 849  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN121@ParseParam
$LN148@ParseParam:

; 946  :                 DebugMsg(("ParseParams: error, cntParam=%u, found %s\n", cntParam, tokenarray[i].tokpos ));
; 947  :                 return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	movsxd	rdx, r10d
	mov	ecx, 39					; 00000027H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r9+24]
	call	EmitErr
	jmp	$LN121@ParseParam
$LN107@ParseParam:

; 678  :         } else {
; 679  :             
; 680  : 			/* PROC needs a parameter name, PROTO accepts <void> also */
; 681  :             DebugMsg(("ParseParams: name missing/invalid for parameter %u, i=%u\n", cntParam+1, i));
; 682  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, r10d
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r9+8]
	call	EmitErr
	jmp	$LN121@ParseParam
$LN29@ParseParam:

; 959  :         }
; 960  :     }
; 961  : 
; 962  :     if ( IsPROC ) {

	test	r11b, r11b
	je	$LN6@ParseParam

; 963  :         /* calc starting offset for parameters,
; 964  :          * offset from [E|R]BP : return addr + old [E|R]BP
; 965  :          * NEAR: 2 * wordsize, FAR: 3 * wordsize
; 966  :          *         NEAR  FAR
; 967  :          *-------------------------
; 968  :          * USE16   +4    +6
; 969  :          * USE32   +8    +12
; 970  :          * USE64   +16   +24
; 971  :          * without frame pointer:
; 972  :          * USE16   +2    +4
; 973  :          * USE32   +4    +8
; 974  :          * USE64   +8    +16
; 975  :          */
; 976  : 		if (proc->e.procinfo->fpo || (proc->e.procinfo->parasize == 0 && proc->e.procinfo->locallist == NULL) && proc->e.procinfo->basereg == T_RSP)

	mov	r8, QWORD PTR [rbp+104]
	test	BYTE PTR [r8+128], 128			; 00000080H
	jne	$LN26@ParseParam
	cmp	DWORD PTR [r8+32], edi
	jne	SHORT $LN27@ParseParam
	cmp	QWORD PTR [r8+16], rdi
	jne	SHORT $LN27@ParseParam
	cmp	WORD PTR [r8+130], 119			; 00000077H
	je	$LN26@ParseParam
$LN27@ParseParam:

; 978  : 		// Compensate for the stack-frame setup of RBP including the push rbp, which moves the parameters out by 8.
; 979  : 		else if (proc->e.procinfo->basereg == T_RBP && (ModuleInfo.win64_flags & W64F_AUTOSTACKSP) && (ModuleInfo.win64_flags & W64F_SAVEREGPARAMS))

	movzx	ecx, WORD PTR [r8+130]
	movzx	eax, BYTE PTR ModuleInfo+413
	cmp	cx, 120					; 00000078H
	jne	SHORT $LN24@ParseParam
	test	al, 2
	je	SHORT $LN24@ParseParam
	test	al, 1
	je	SHORT $LN24@ParseParam

; 980  : 		{
; 981  : 			offset = ((2 + (proc->sym.mem_type == MT_FAR ? 1 : 0)) * CurrWordSize);

	cmp	DWORD PTR [rbp+44], 130			; 00000082H
	movzx	eax, BYTE PTR ModuleInfo+406
	sete	dil
	add	edi, 2
	imul	edi, eax
	jmp	SHORT $LN19@ParseParam
$LN24@ParseParam:

; 982  : 			//if( (proc->e.procinfo->locallist != 0) || !(proc->e.procinfo->localsize) )
; 983  : 			//{
; 984  : 				//offset += 8;
; 985  : 			//}
; 986  : 		}
; 987  : 		else if (proc->e.procinfo->basereg == T_RBP && !(ModuleInfo.win64_flags & W64F_AUTOSTACKSP) && (ModuleInfo.win64_flags & W64F_SAVEREGPARAMS))

	cmp	cx, 120					; 00000078H
	jne	SHORT $LN22@ParseParam
	test	al, 2
	jne	SHORT $LN22@ParseParam
	test	al, 1
	je	SHORT $LN22@ParseParam

; 988  : 		{
; 989  : 			// USES will push registers, so reduce offset by number of pushes.
; 990  : 			/*offset = ((2 + (proc->sym.mem_type == MT_FAR ? 1 : 0)) * CurrWordSize);
; 991  : 			if ((proc->e.procinfo->locallist != 0) || !(proc->e.procinfo->localsize))
; 992  : 			{
; 993  : 				offset += 8;
; 994  : 			}
; 995  : 			paranode = proc->e.procinfo->paralist;
; 996  : 			while (paranode != NULL)
; 997  : 			{
; 998  : 				paracount++;
; 999  : 				paranode = paranode->nextparam;
; 1000 : 			}
; 1001 : 			// 4 parameters can go to homespace.. so pushes-(4-paracount)
; 1002 : 			tmp = 0;
; 1003 : 			if (paracount <= 4)
; 1004 : 			{
; 1005 : 				tmp = 4 - paracount;
; 1006 : 			}
; 1007 : 			if (proc->e.procinfo->regslist && *(proc->e.procinfo->regslist) > tmp)
; 1008 : 				offset -= (((int)*(proc->e.procinfo->regslist) - tmp) * CurrWordSize);*/
; 1009 : 			offset = ((2 + (proc->sym.mem_type == MT_FAR ? 1 : 0)) * CurrWordSize);

	cmp	DWORD PTR [rbp+44], 130			; 00000082H
	movzx	eax, BYTE PTR ModuleInfo+406
	sete	dil
	add	edi, 2
	imul	edi, eax
	jmp	SHORT $LN19@ParseParam
$LN22@ParseParam:

; 1010 : 		}
; 1011 : 		else if (proc->e.procinfo->basereg == T_RBP)

	cmp	cx, 120					; 00000078H
	jne	SHORT $LN20@ParseParam

; 1012 : 			offset = ((2 + (proc->sym.mem_type == MT_FAR ? 1 : 0)) * CurrWordSize);

	cmp	DWORD PTR [rbp+44], 130			; 00000082H
	movzx	eax, BYTE PTR ModuleInfo+406
	sete	dil
	add	edi, 2
	imul	edi, eax

; 1013 : 		else

	jmp	SHORT $LN19@ParseParam
$LN20@ParseParam:

; 1014 : 			offset = ((2 + (proc->sym.mem_type == MT_FAR ? 1 : 0)) * CurrWordSize);

	cmp	DWORD PTR [rbp+44], 130			; 00000082H
	movzx	eax, BYTE PTR ModuleInfo+406
	sete	dil
	add	edi, 2
	imul	edi, eax
	jmp	SHORT $LN19@ParseParam
$LN26@ParseParam:

; 977  : 			offset = ((2 + (proc->sym.mem_type == MT_FAR ? 1 : 0)) * CurrWordSize);

	cmp	DWORD PTR [rbp+44], 130			; 00000082H
	movzx	eax, BYTE PTR ModuleInfo+406
	sete	dil
	add	edi, 2
	imul	edi, eax
$LN19@ParseParam:

; 1015 : 
; 1016 :         /* now calculate the [E|R]BP offsets */
; 1017 : 
; 1018 : #if AMD64_SUPPORT
; 1019 :         if ( ModuleInfo.Ofssize == USE64)  {

	cmp	BYTE PTR ModuleInfo+404, 2
	jne	SHORT $LN18@ParseParam

; 1020 :           if (proc->sym.langtype == LANG_FASTCALL || proc->sym.langtype == LANG_VECTORCALL ){

	mov	eax, DWORD PTR [rbp+84]
	cmp	eax, 7
	je	SHORT $LN16@ParseParam
	cmp	eax, 8
	jne	$LN6@ParseParam
$LN16@ParseParam:

; 1021 :             for (paranode = proc->e.procinfo->paralist; paranode; paranode = paranode->nextparam)

	mov	r8, QWORD PTR [r8+8]
	test	r8, r8
	je	$LN6@ParseParam
$LL15@ParseParam:

; 1022 :               if (paranode->sym.state == SYM_TMACRO) /* register param */

	cmp	DWORD PTR [r8+40], 10
	je	SHORT $LN14@ParseParam

; 1023 :                 ;
; 1024 :               else {
; 1025 :                 paranode->sym.offset = offset;

	mov	DWORD PTR [r8+16], edi

; 1026 :                 proc->e.procinfo->stackparam = TRUE;

	mov	rax, QWORD PTR [rbp+104]
	or	BYTE PTR [rax+128], 32			; 00000020H

; 1027 :                 offset += ROUND_UP(paranode->sym.total_size, CurrWordSize);

	movzx	ecx, BYTE PTR ModuleInfo+406
	mov	eax, DWORD PTR [r8+64]
	lea	edx, DWORD PTR [rax+rcx-1]
	lea	eax, DWORD PTR [rcx-1]
	not	eax
	and	edx, eax
	add	edi, edx

; 1028 :                 /* set isparam var for W64F_HABRAN */
; 1029 : 				if (ModuleInfo.win64_flags & W64F_SMART) paranode->sym.isparam = TRUE;

	test	BYTE PTR ModuleInfo+413, 8
	je	SHORT $LN14@ParseParam
	or	BYTE PTR [r8+49], 128			; 00000080H
$LN14@ParseParam:

; 1021 :             for (paranode = proc->e.procinfo->paralist; paranode; paranode = paranode->nextparam)

	mov	r8, QWORD PTR [r8+120]
	test	r8, r8
	jne	SHORT $LL15@ParseParam

; 1030 :                 //if (ModuleInfo.win64_flags & W64F_HABRAN) paranode->sym.isparam = TRUE;
; 1031 :               }
; 1032 :           }
; 1033 :         } else

	jmp	SHORT $LN6@ParseParam
$LN18@ParseParam:

; 1034 : #endif
; 1035 :         for ( ; cntParam; cntParam-- ) {

	test	r15d, r15d
	je	SHORT $LN6@ParseParam
	npad	1
$LL8@ParseParam:

; 1036 :             for ( curr = 1, paranode = proc->e.procinfo->paralist; curr < cntParam;paranode = paranode->nextparam, curr++ );

	cmp	r15d, 1
	mov	rax, QWORD PTR [rbp+104]
	mov	rdx, QWORD PTR [rax+8]
	jle	SHORT $LN3@ParseParam
	lea	ecx, DWORD PTR [r15-1]
$LL5@ParseParam:
	dec	rcx
	mov	rdx, QWORD PTR [rdx+120]
	jne	SHORT $LL5@ParseParam
$LN3@ParseParam:

; 1037 :             DebugMsg1(("ParseParams: parm=%s, ofs=%u, size=%d\n", paranode->sym.name, offset, paranode->sym.total_size));
; 1038 :             if ( paranode->sym.state == SYM_TMACRO ) /* register param? */

	cmp	DWORD PTR [rdx+40], 10
	je	SHORT $LN7@ParseParam

; 1039 :                 ;
; 1040 :             else {
; 1041 :                 paranode->sym.offset = offset;

	mov	DWORD PTR [rdx+16], edi

; 1042 :                 proc->e.procinfo->stackparam = TRUE;

	mov	rax, QWORD PTR [rbp+104]
	or	BYTE PTR [rax+128], 32			; 00000020H

; 1043 :                 offset += ROUND_UP( paranode->sym.total_size, CurrWordSize );

	mov	eax, DWORD PTR [rdx+64]
	movzx	ecx, BYTE PTR ModuleInfo+406
	lea	edx, DWORD PTR [rax+rcx-1]
	lea	eax, DWORD PTR [rcx-1]
	not	eax
	and	edx, eax
	add	edi, edx
$LN7@ParseParam:

; 1034 : #endif
; 1035 :         for ( ; cntParam; cntParam-- ) {

	dec	r15d
	jne	SHORT $LL8@ParseParam
$LN6@ParseParam:

; 1044 :             }
; 1045 :         }
; 1046 :     }
; 1047 :     return ( NOT_ERROR );

	xor	eax, eax
$LN121@ParseParam:
	mov	r15, QWORD PTR [rsp+88]
	mov	r14, QWORD PTR [rsp+96]
	mov	r13, QWORD PTR [rsp+104]
	mov	r12, QWORD PTR [rsp+112]
	mov	rdi, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+128]
	mov	rbp, QWORD PTR [rsp+136]
	mov	rbx, QWORD PTR [rsp+144]

; 1048 : }

	add	rsp, 152				; 00000098H
	ret	0
ParseParams ENDP
_TEXT	ENDS
PUBLIC	ParseProc
EXTRN	SizeFromRegister:NEAR
EXTRN	sym_add_table:NEAR
EXTRN	SymTables:BYTE
EXTRN	SymCreate:NEAR
EXTRN	EmitWarn:NEAR
EXTRN	Tokenize:NEAR
EXTRN	SkipSavedState:NEAR
EXTRN	_stricmp:NEAR
EXTRN	GetLangType:NEAR
EXTRN	Options:BYTE
xdata	SEGMENT
$unwind$ParseProc DD 0d3a01H
	DD	05f43aH
	DD	06e42bH
	DD	07d421H
	DD	09741cH
	DD	0a6417H
	DD	0c3412H
	DD	0c20dH
xdata	ENDS
pdata	SEGMENT
$pdata$ParseProc DD @imagerel($LN108#)
	DD	@imagerel($LN108#+281)
	DD	@imagerel($unwind$ParseProc#)
pdata	ENDS
xdata	SEGMENT
$chain$7$ParseProc DD 040a21H
	DD	08c40aH
	DD	0b5405H
	DD	@imagerel($LN108#)
	DD	@imagerel($LN108#+281)
	DD	@imagerel($unwind$ParseProc#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$ParseProc DD @imagerel($LN108#+281)
	DD	@imagerel($LN108#+2087)
	DD	@imagerel($chain$7$ParseProc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
proc$ = 112
i$ = 120
tokenarray$ = 128
IsPROC$ = 136
langtype$ = 144
ParseProc PROC NEAR

; 1069 : {

$LN108:
	mov	BYTE PTR [rsp+32], r9b
	mov	DWORD PTR [rsp+16], edx
	sub	rsp, 104				; 00000068H
	mov	QWORD PTR [rsp+96], rbx
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+72], rdi
	mov	QWORD PTR [rsp+56], r13

; 1070 :     char            *token;
; 1071 :     uint_16         *regist;
; 1072 :     //int             type;
; 1073 :     //enum lang_type  langtype;
; 1074 :     enum memtype    newmemtype;
; 1075 :     uint_8          newofssize;
; 1076 :     uint_8          oldofssize;
; 1077 : #if FASTPASS
; 1078 :     bool            oldpublic = proc->sym.ispublic;

	movzx	r13d, BYTE PTR [rcx+48]
	mov	QWORD PTR [rsp+48], r14

; 1079 : #endif
; 1080 : 
; 1081 :     /* set some default values */
; 1082 : 
; 1083 :     if ( IsPROC ) {

	xor	r14d, r14d
	shr	r13b, 7
	test	r9b, r9b
	mov	QWORD PTR [rsp+40], r15
	mov	rdi, r8
	mov	rbx, rcx
	movzx	r15d, r9b
	lea	rsi, OFFSET FLAT:SpecialTable
	je	$LN75@ParseProc

; 1084 :         proc->e.procinfo->isexport = ModuleInfo.procs_export;

	mov	eax, DWORD PTR ModuleInfo+408
	mov	rdx, QWORD PTR [rcx+104]
	shr	eax, 4
	shl	al, 2
	xor	al, BYTE PTR [rdx+128]
	and	al, 4
	xor	BYTE PTR [rdx+128], al

; 1085 :         /* don't overwrite a PUBLIC directive for this symbol! */
; 1086 :         if ( ModuleInfo.procs_private == FALSE )

	test	BYTE PTR ModuleInfo+408, 8
	jne	SHORT $LN79@ParseProc

; 1087 :             proc->sym.ispublic = TRUE;

	or	BYTE PTR [rcx+48], 128			; 00000080H
$LN79@ParseProc:

; 1088 : 
; 1089 :         /* set type of epilog code */
; 1090 : #if STACKBASESUPP
; 1091 :         /* v2.11: if base register isn't [E|R]BP, don't use LEAVE! */
; 1092 :         if ( GetRegNo( proc->e.procinfo->basereg ) != 5 ) {

	mov	rdx, QWORD PTR [rcx+104]
	movzx	eax, WORD PTR [rdx+130]
	lea	rcx, QWORD PTR [rax+rax*2]
	cmp	BYTE PTR [rsi+rcx*4+10], 5
	je	SHORT $LN78@ParseProc

; 1093 :             proc->e.procinfo->pe_type = 0;

	and	BYTE PTR [rdx+128], 253			; 000000fdH

; 1094 :         } else

	jmp	SHORT $LN75@ParseProc
$LN78@ParseProc:

; 1095 : #endif
; 1096 :         if ( Options.masm_compat_gencode ) {

	cmp	BYTE PTR Options+137, r14b
	je	SHORT $LN76@ParseProc

; 1097 :             /* v2.07: Masm uses LEAVE if
; 1098 :              * - current code is 32-bit/64-bit or
; 1099 :              * - cpu is .286 or .586+ */
; 1100 :             //proc->e.procinfo->pe_type = ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_286 );
; 1101 :             proc->e.procinfo->pe_type = ( ModuleInfo.Ofssize > USE16 ||
; 1102 :                                          ( ModuleInfo.curr_cpu & P_CPU_MASK ) == P_286 ||
; 1103 :                                          ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_586 ) ? 1 : 0;

	cmp	BYTE PTR ModuleInfo+404, r14b
	ja	SHORT $LN83@ParseProc
	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 32					; 00000020H
	je	SHORT $LN83@ParseProc
	cmp	eax, 80					; 00000050H
	jge	SHORT $LN83@ParseProc
	mov	eax, r14d
	jmp	SHORT $LN84@ParseProc
$LN83@ParseProc:
	mov	eax, 1
$LN84@ParseProc:
	and	BYTE PTR [rdx+128], 253			; 000000fdH
	and	al, 1
	add	al, al
	or	BYTE PTR [rdx+128], al

; 1104 :         } else {

	jmp	SHORT $LN75@ParseProc
$LN76@ParseProc:

; 1105 :             /* use LEAVE for 286, 386 (and x64) */
; 1106 :             proc->e.procinfo->pe_type = ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) == P_286 ||
; 1107 : #if AMD64_SUPPORT
; 1108 :                                          ( ModuleInfo.curr_cpu & P_CPU_MASK ) == P_64 ||
; 1109 : #endif
; 1110 :                                          ( ModuleInfo.curr_cpu & P_CPU_MASK ) == P_386 ) ? 1 : 0;

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 32					; 00000020H
	je	SHORT $LN85@ParseProc
	cmp	eax, 112				; 00000070H
	je	SHORT $LN85@ParseProc
	cmp	eax, 48					; 00000030H
	je	SHORT $LN85@ParseProc
	mov	eax, r14d
	jmp	SHORT $LN86@ParseProc
$LN85@ParseProc:
	mov	eax, 1
$LN86@ParseProc:
	and	BYTE PTR [rdx+128], 253			; 000000fdH
	and	al, 1
	add	al, al
	or	BYTE PTR [rdx+128], al
$LN75@ParseProc:

; 1111 :         }
; 1112 :     }
; 1113 : 
; 1114 : #if MANGLERSUPP
; 1115 :     /* OW name mangling */
; 1116 :     if( tokenarray[i].token == T_STRING && IsPROC ) {
; 1117 :         /* SetMangler() will ignore LANG_NONE */
; 1118 :         SetMangler( &proc->sym, LANG_NONE, tokenarray[i].string_ptr );
; 1119 :         i++;
; 1120 :     }
; 1121 : #endif
; 1122 : 
; 1123 :     /* 1. attribute is <distance> */
; 1124 :     if ( tokenarray[i].token == T_STYPE &&
; 1125 :         tokenarray[i].tokval >= T_NEAR && tokenarray[i].tokval <= T_FAR32 ) {

	movsxd	rax, DWORD PTR i$[rsp]
	mov	QWORD PTR [rsp+88], rbp
	mov	QWORD PTR [rsp+64], r12
	shl	rax, 5
	cmp	BYTE PTR [rax+r8], 6
	jne	$LN74@ParseProc
	mov	ecx, DWORD PTR [rax+r8+16]
	cmp	ecx, 221				; 000000ddH
	jb	SHORT $LN74@ParseProc
	cmp	ecx, 226				; 000000e2H
	ja	SHORT $LN74@ParseProc

; 1126 :         uint_8 Ofssize = GetSflagsSp( tokenarray[i].tokval );
; 1127 :         /* v2.06: SimpleType is obsolete */
; 1128 :         /* v2.05: FindStdType() is obsolete */
; 1129 :         //type = tokenarray[i].bytval;
; 1130 :         //type = FindStdType(tokenarray[i].value);
; 1131 :         if ( IsPROC ) {

	test	r15b, r15b
	lea	rcx, QWORD PTR [rcx+rcx*2]
	movzx	r12d, BYTE PTR [rsi+rcx*4+4]
	je	SHORT $LN98@ParseProc

; 1132 :             if ( ( ModuleInfo.Ofssize >= USE32 && Ofssize == USE16 ) ||
; 1133 :                 ( ModuleInfo.Ofssize == USE16 && Ofssize == USE32 ) ) {

	movzx	edx, BYTE PTR ModuleInfo+404
	cmp	dl, 1
	jb	SHORT $LN70@ParseProc
	test	r12b, r12b
	je	SHORT $LN71@ParseProc
$LN70@ParseProc:
	test	dl, dl
	jne	SHORT $LN72@ParseProc
	cmp	r12b, 1
	jne	SHORT $LN72@ParseProc
$LN71@ParseProc:

; 1134 :                 EmitError( DISTANCE_INVALID );

	mov	ecx, 171				; 000000abH
	call	EmitError
	mov	dl, BYTE PTR ModuleInfo+404
	jmp	SHORT $LN72@ParseProc
$LN98@ParseProc:
	mov	dl, BYTE PTR ModuleInfo+404
$LN72@ParseProc:

; 1135 :             }
; 1136 :         }
; 1137 :         newmemtype = GetMemtypeSp( tokenarray[i].tokval );

	movsxd	rax, DWORD PTR i$[rsp]

; 1138 :         newofssize = (( Ofssize != USE_EMPTY ) ? Ofssize : ModuleInfo.Ofssize );

	movzx	ebp, dl
	shl	rax, 5
	cmp	r12b, 254				; 000000feH
	mov	eax, DWORD PTR [rax+rdi+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	eax, r12b
	movzx	esi, BYTE PTR [rsi+rcx*4+10]
	cmovne	ebp, eax

; 1139 :         i++;

	inc	DWORD PTR i$[rsp]

; 1140 :     } else {

	jmp	SHORT $LN69@ParseProc
$LN74@ParseProc:

; 1141 :         newmemtype = ( ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ) ? MT_FAR : MT_NEAR );

	mov	ecx, DWORD PTR ModuleInfo+360

; 1142 :         newofssize = ModuleInfo.Ofssize;

	mov	bpl, BYTE PTR ModuleInfo+404
	mov	esi, r14d
	mov	eax, 1
	shl	eax, cl
	test	al, 112					; 00000070H
	setne	sil
	add	esi, 129				; 00000081H
$LN69@ParseProc:

; 1143 :     }
; 1144 : 
; 1145 :     /* v2.11: GetSymOfssize() cannot handle SYM_TYPE correctly */
; 1146 :     if ( proc->sym.state == SYM_TYPE )

	cmp	DWORD PTR [rbx+40], 7
	jne	SHORT $LN68@ParseProc

; 1147 :         oldofssize = proc->sym.seg_ofssize;

	mov	al, BYTE PTR [rbx+55]
	and	al, 3

; 1148 :     else

	jmp	SHORT $LN67@ParseProc
$LN68@ParseProc:

; 1149 :         oldofssize = GetSymOfssize( &proc->sym );

	mov	rcx, rbx
	call	GetSymOfssize
$LN67@ParseProc:

; 1150 : 
; 1151 :     /* did the distance attribute change? */
; 1152 :     if ( proc->sym.mem_type != MT_EMPTY &&
; 1153 :         ( proc->sym.mem_type != newmemtype ||
; 1154 :          oldofssize != newofssize ) ) {

	mov	ecx, DWORD PTR [rbx+44]
	cmp	ecx, 192				; 000000c0H
	je	SHORT $LN66@ParseProc
	cmp	ecx, esi
	jne	SHORT $LN65@ParseProc
	cmp	al, bpl
	je	SHORT $LN66@ParseProc
$LN65@ParseProc:

; 1155 :         DebugMsg(("ParseProc: error, memtype changed, old-new memtype=%X-%X, ofssize=%X-%X\n", proc->sym.mem_type, newmemtype, proc->sym.Ofssize, newofssize));
; 1156 :         if ( proc->sym.mem_type == MT_NEAR || proc->sym.mem_type == MT_FAR )

	cmp	ecx, 129				; 00000081H
	je	SHORT $LN63@ParseProc
	cmp	ecx, 130				; 00000082H
	je	SHORT $LN63@ParseProc

; 1158 :         else {
; 1159 :             return( EmitErr( SYMBOL_REDEFINITION, proc->sym.name ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 143				; 0000008fH
	jmp	$LN106@ParseProc
$LN63@ParseProc:

; 1157 :             EmitError( PROC_AND_PROTO_CALLING_CONV_CONFLICT );

	mov	ecx, 138				; 0000008aH
	call	EmitError

; 1160 :         }
; 1161 :     } else {

	jmp	SHORT $LN60@ParseProc
$LN66@ParseProc:

; 1162 :         proc->sym.mem_type = newmemtype;
; 1163 :         if ( IsPROC == FALSE )

	test	r15b, r15b
	mov	DWORD PTR [rbx+44], esi
	jne	SHORT $LN60@ParseProc

; 1164 :             proc->sym.seg_ofssize = newofssize;

	and	BYTE PTR [rbx+55], 252			; 000000fcH
	and	bpl, 3
	or	BYTE PTR [rbx+55], bpl
$LN60@ParseProc:

; 1165 :     }
; 1166 : 
; 1167 :     /* 2. attribute is <langtype> */
; 1168 :     /* v2.09: the default language value is now a function argument. This is because
; 1169 :      * EXTERN[DEF] allows to set the language attribute by:
; 1170 :      * EXTERN[DEF] <langtype> <name> PROTO ...
; 1171 :      * ( see CreateProto() in extern.c )
; 1172 :      */
; 1173 :     //langtype = ModuleInfo.langtype; /* set the default value */
; 1174 :     GetLangType( &i, tokenarray, &langtype ); /* optionally overwrite the value */

	lea	r8, QWORD PTR langtype$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rdi
	call	GetLangType

; 1175 :     
; 1176 : 	/* John Hankinson: 2016-02-10 Allows Linux64 to utilise Win64 ABI */
; 1177 : 	//#if AMD64_SUPPORT
; 1178 : 	//if (Options.output_format == OFORMAT_ELF)
; 1179 : 	//	langtype = LANG_FASTCALL;
; 1180 : 	//#endif
; 1181 : 
; 1182 : 	/* has language changed? */
; 1183 :     if ( proc->sym.langtype != LANG_NONE && proc->sym.langtype != langtype ) {

	mov	edx, DWORD PTR [rbx+84]
	mov	eax, DWORD PTR langtype$[rsp]
	test	edx, edx
	je	SHORT $LN59@ParseProc
	cmp	edx, eax
	je	SHORT $LN59@ParseProc

; 1184 :         DebugMsg(("ParseProc: error, language changed, %u - %u\n", proc->sym.langtype, langtype ));
; 1185 :         EmitError( PROC_AND_PROTO_CALLING_CONV_CONFLICT );

	mov	ecx, 138				; 0000008aH
	call	EmitError

; 1186 :     } else

	jmp	SHORT $LN58@ParseProc
$LN59@ParseProc:

; 1187 :         proc->sym.langtype = langtype;

	mov	DWORD PTR [rbx+84], eax
$LN58@ParseProc:

; 1188 : 
; 1189 : 	/* John Hankinson: 2016-02-10 Allows Linux64 to utilise Win64 ABI */
; 1190 : 	//#if AMD64_SUPPORT
; 1191 : 	//if (proc->sym.langtype == LANG_NONE && Options.output_format == OFORMAT_ELF)
; 1192 : 	//{
; 1193 : 	//	proc->sym.langtype = LANG_FASTCALL;
; 1194 : 	//}
; 1195 : 	//#endif
; 1196 : 
; 1197 :     /* 3. attribute is <visibility> */
; 1198 :     /* note that reserved word PUBLIC is a directive! */
; 1199 :     /* PROTO does NOT accept PUBLIC! However,
; 1200 :      * PROTO accepts PRIVATE and EXPORT, but these attributes are just ignored!
; 1201 :      */
; 1202 : 
; 1203 :     if ( tokenarray[i].token == T_ID || tokenarray[i].token == T_DIRECTIVE ) {

	movsxd	rdx, DWORD PTR i$[rsp]
	mov	rax, rdx
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+rdi]
	cmp	cl, 8
	je	SHORT $LN56@ParseProc
	cmp	cl, 3
	jne	$LN101@ParseProc
$LN56@ParseProc:

; 1204 :         token = tokenarray[i].string_ptr;

	mov	rsi, QWORD PTR [rax+rdi+8]

; 1205 :         if ( _stricmp( token, "PRIVATE") == 0 ) {

	lea	rdx, OFFSET FLAT:$SG6400
	mov	rcx, rsi
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN55@ParseProc

; 1206 :             if ( IsPROC ) { /* v2.11: ignore PRIVATE for PROTO */

	test	r15b, r15b
	je	SHORT $LN54@ParseProc

; 1207 :                 proc->sym.ispublic = FALSE;

	and	BYTE PTR [rbx+48], 123			; 0000007bH

; 1208 : #if FASTPASS
; 1209 :                 /* error if there was a PUBLIC directive! */
; 1210 :                 proc->sym.scoped = TRUE;

	or	BYTE PTR [rbx+48], 4

; 1211 :                 if ( oldpublic ) {

	test	r13b, r13b
	je	SHORT $LN53@ParseProc

; 1212 :                     SkipSavedState(); /* do a full pass-2 scan */

	call	SkipSavedState
$LN53@ParseProc:

; 1213 :                 }
; 1214 : #endif
; 1215 :                 proc->e.procinfo->isexport = FALSE;

	mov	rax, QWORD PTR [rbx+104]
	and	BYTE PTR [rax+128], 251			; 000000fbH
$LN54@ParseProc:

; 1216 :             }
; 1217 :             i++;

	mov	edx, DWORD PTR i$[rsp]
	inc	edx
	mov	DWORD PTR i$[rsp], edx
	jmp	$LN101@ParseProc
$LN55@ParseProc:

; 1218 :         } else if ( IsPROC && (_stricmp(token, "PUBLIC") == 0 ) ) {

	test	r15b, r15b
	je	SHORT $LN51@ParseProc
	lea	rdx, OFFSET FLAT:$SG6405
	mov	rcx, rsi
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN51@ParseProc

; 1219 :             proc->sym.ispublic = TRUE;

	or	BYTE PTR [rbx+48], 128			; 00000080H

; 1220 :             proc->e.procinfo->isexport = FALSE;

	mov	rax, QWORD PTR [rbx+104]
	and	BYTE PTR [rax+128], 251			; 000000fbH

; 1221 :             i++;

	mov	edx, DWORD PTR i$[rsp]
	inc	edx
	mov	DWORD PTR i$[rsp], edx
	jmp	SHORT $LN101@ParseProc
$LN51@ParseProc:

; 1222 :         } else if ( _stricmp(token, "EXPORT") == 0 ) {

	lea	rdx, OFFSET FLAT:$SG6408
	mov	rcx, rsi
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN100@ParseProc

; 1223 :             DebugMsg1(("ParseProc(%s): EXPORT detected\n", proc->sym.name ));
; 1224 :             if ( IsPROC ) { /* v2.11: ignore EXPORT for PROTO */

	test	r15b, r15b
	je	SHORT $LN99@ParseProc

; 1225 :                 proc->sym.ispublic = TRUE;

	or	BYTE PTR [rbx+48], 128			; 00000080H

; 1226 :                 proc->e.procinfo->isexport = TRUE;

	mov	rax, QWORD PTR [rbx+104]
	or	BYTE PTR [rax+128], 4

; 1227 :                 /* v2.11: no export for 16-bit near */
; 1228 :                 if ( ModuleInfo.Ofssize == USE16 && proc->sym.mem_type == MT_NEAR )

	cmp	BYTE PTR ModuleInfo+404, r14b
	jne	SHORT $LN99@ParseProc
	cmp	DWORD PTR [rbx+44], 129			; 00000081H
	jne	SHORT $LN99@ParseProc

; 1229 :                     EmitErr( EXPORT_MUST_BE_FAR, proc->sym.name );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 277				; 00000115H
	call	EmitErr
$LN99@ParseProc:

; 1230 :             }
; 1231 :             i++;

	mov	edx, DWORD PTR i$[rsp]
	inc	edx
	mov	DWORD PTR i$[rsp], edx
	jmp	SHORT $LN101@ParseProc
$LN100@ParseProc:
	mov	edx, DWORD PTR i$[rsp]
$LN101@ParseProc:

; 1232 :         }
; 1233 :     }
; 1234 : 
; 1235 :     /* 4. attribute is <prologuearg>, for PROC only.
; 1236 :      * it must be enclosed in <>
; 1237 :      */
; 1238 :     if ( IsPROC && tokenarray[i].token == T_STRING && tokenarray[i].string_delim == '<' ) {

	test	r15b, r15b
	je	$LN103@ParseProc
	movsxd	rcx, edx
	shl	rcx, 5
	cmp	BYTE PTR [rcx+rdi], 9
	jne	$LN103@ParseProc
	cmp	BYTE PTR [rcx+rdi+1], 60		; 0000003cH
	jne	$LN103@ParseProc

; 1239 :         int idx = Token_Count + 1;

	mov	eax, DWORD PTR ModuleInfo+496
	lea	r13d, DWORD PTR [rax+1]

; 1240 :         int max;
; 1241 :         if ( ModuleInfo.prologuemode == PEM_NONE )

	movzx	eax, BYTE PTR ModuleInfo+424
	cmp	al, 2
	je	$LN39@ParseProc

; 1242 :             ; /* no prologue at all */
; 1243 :         else if ( ModuleInfo.prologuemode == PEM_MACRO ) {

	cmp	al, 1
	jne	SHORT $LN43@ParseProc

; 1244 :             proc->e.procinfo->prologuearg = LclAlloc( tokenarray[i].stringlen + 1 );

	mov	ecx, DWORD PTR [rcx+rdi+16]
	inc	ecx
	call	LclAlloc
	mov	rcx, QWORD PTR [rbx+104]
	mov	QWORD PTR [rcx+48], rax

; 1245 :             strcpy( proc->e.procinfo->prologuearg, tokenarray[i].string_ptr );

	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	mov	rcx, QWORD PTR [rax+rdi+8]
	mov	rax, QWORD PTR [rbx+104]
	mov	rdx, QWORD PTR [rax+48]
	npad	1
$LL89@ParseProc:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL89@ParseProc

; 1246 :         } else {

	mov	edx, DWORD PTR i$[rsp]
	jmp	$LN39@ParseProc
$LN43@ParseProc:

; 1247 :             /* check the argument. The default prologue
; 1248 :              understands FORCEFRAME and LOADDS only
; 1249 :              */
; 1250 :             max = Tokenize( tokenarray[i].string_ptr, idx, tokenarray, TOK_RESCAN );

	mov	rcx, QWORD PTR [rcx+rdi+8]
	mov	r9d, 1
	mov	r8, rdi
	mov	edx, r13d
	movsxd	r12, r13d
	call	Tokenize
	movsxd	r15, eax

; 1251 :             for ( ; idx < max; idx++ ) {

	cmp	r12, r15
	jge	$LN102@ParseProc
	lea	rbp, QWORD PTR [r12+2]
	mov	rsi, r12
	shl	rsi, 5
	shl	rbp, 5
	add	rsi, rdi
	add	rbp, rdi
$LL41@ParseProc:

; 1252 :                 if ( tokenarray[idx].token == T_ID ) {

	cmp	BYTE PTR [rsi], 8
	jne	$LN38@ParseProc

; 1253 :                     if ( _stricmp( tokenarray[idx].string_ptr, "FORCEFRAME") == 0 ) {

	mov	rcx, QWORD PTR [rsi+8]
	lea	rdx, OFFSET FLAT:$SG6423
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN37@ParseProc

; 1254 :                         proc->e.procinfo->forceframe = TRUE;

	mov	rax, QWORD PTR [rbx+104]
	or	BYTE PTR [rax+128], 8
	jmp	SHORT $LN33@ParseProc
$LN37@ParseProc:

; 1255 : #if AMD64_SUPPORT
; 1256 :                     } else if ( ModuleInfo.Ofssize != USE64 && (_stricmp( tokenarray[idx].string_ptr, "LOADDS") == 0 ) ) {

	cmp	BYTE PTR ModuleInfo+404, 2
	je	SHORT $LN35@ParseProc
	mov	rcx, QWORD PTR [rsi+8]
	lea	rdx, OFFSET FLAT:$SG6426
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN35@ParseProc

; 1257 : #else
; 1258 :                     } else if ( _stricmp( tokenarray[idx].string_ptr, "LOADDS") == 0 ) {
; 1259 : #endif
; 1260 :                         if ( ModuleInfo.model == MODEL_FLAT ) {

	cmp	DWORD PTR ModuleInfo+360, 7
	jne	SHORT $LN34@ParseProc

; 1261 :                             EmitWarn( 2, LOADDS_IGNORED_IN_FLAT_MODEL );

	lea	ecx, QWORD PTR [rax+2]
	mov	edx, 226				; 000000e2H
	call	EmitWarn

; 1262 :                         } else

	jmp	SHORT $LN33@ParseProc
$LN34@ParseProc:

; 1263 :                             proc->e.procinfo->loadds = TRUE;

	mov	rax, QWORD PTR [rbx+104]
	or	BYTE PTR [rax+128], 16
$LN33@ParseProc:

; 1266 :                     }
; 1267 :                     if ( tokenarray[idx+1].token == T_COMMA && tokenarray[idx+2].token != T_FINAL)

	cmp	BYTE PTR [rsi+32], 44			; 0000002cH
	jne	SHORT $LN40@ParseProc
	cmp	BYTE PTR [rbp], r14b
	je	SHORT $LN40@ParseProc

; 1268 :                         idx++;

	inc	r13d
	inc	r12
	add	rsi, 32					; 00000020H
	add	rbp, 32					; 00000020H
$LN40@ParseProc:
	inc	r12
	inc	r13d
	add	rsi, 32					; 00000020H
	add	rbp, 32					; 00000020H
	cmp	r12, r15
	jl	$LL41@ParseProc
	mov	edx, DWORD PTR i$[rsp]
	mov	r15b, BYTE PTR IsPROC$[rsp]
	jmp	SHORT $LN39@ParseProc
$LN35@ParseProc:

; 1264 :                     } else {
; 1265 :                         return( EmitErr( UNKNOWN_DEFAULT_PROLOGUE_ARGUMENT, tokenarray[idx].string_ptr ) );

	movsxd	rdx, r13d
	mov	ecx, 225				; 000000e1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+8]
	jmp	$LN106@ParseProc
$LN38@ParseProc:

; 1269 :                 } else {
; 1270 :                     return( EmitErr( SYNTAX_ERROR_EX, tokenarray[idx].string_ptr ) );

	movsxd	rdx, r13d
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+8]
	jmp	$LN107@ParseProc
$LN102@ParseProc:
	mov	edx, DWORD PTR i$[rsp]
	mov	r15b, BYTE PTR IsPROC$[rsp]
$LN39@ParseProc:

; 1271 :                 }
; 1272 :             }
; 1273 :         }
; 1274 :         i++;

	inc	edx
	mov	DWORD PTR i$[rsp], edx
$LN103@ParseProc:

; 1275 :     }
; 1276 : 
; 1277 : #if AMD64_SUPPORT
; 1278 :     /* check for optional FRAME[:exc_proc] */
; 1279 :     if ( ModuleInfo.Ofssize == USE64 &&
; 1280 :         IsPROC &&
; 1281 :         tokenarray[i].token == T_RES_ID &&
; 1282 :         tokenarray[i].tokval == T_FRAME ) {

	cmp	BYTE PTR ModuleInfo+404, 2
	jne	$LN29@ParseProc
	test	r15b, r15b
	je	$LN29@ParseProc
	movsxd	rax, edx
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 7
	jne	$LN29@ParseProc
	cmp	DWORD PTR [rax+rdi+16], 263		; 00000107H
	jne	$LN29@ParseProc

; 1283 : 		/* v2.05: don't accept FRAME for ELF  - 2016-02-10 John Hankinson allowed ELF64 to use FRAME/Win64 ABI */
; 1284 : 		if (Options.output_format != OFORMAT_COFF && Options.output_format != OFORMAT_ELF && Options.output_format != OFORMAT_BIN
; 1285 : #if PE_SUPPORT
; 1286 :             && ModuleInfo.sub_format != SFORMAT_PE
; 1287 : #endif
; 1288 :            ) {

	mov	eax, DWORD PTR Options+156
	cmp	eax, 2
	je	SHORT $LN28@ParseProc
	cmp	eax, 3
	je	SHORT $LN28@ParseProc
	test	eax, eax
	je	SHORT $LN28@ParseProc
	cmp	DWORD PTR ModuleInfo+372, 2
	je	SHORT $LN28@ParseProc

; 1289 :             return( EmitErr( NOT_SUPPORTED_WITH_CURR_FORMAT, GetResWName( T_FRAME, NULL ) ) );

	xor	edx, edx
	mov	ecx, 263				; 00000107H
	call	GetResWName
	mov	ecx, 224				; 000000e0H
	mov	rdx, rax
	jmp	$LN106@ParseProc
$LN28@ParseProc:

; 1290 :         }
; 1291 :         i++;

	inc	edx

; 1292 :         if( tokenarray[i].token == T_COLON ) {

	movsxd	rax, edx
	mov	DWORD PTR i$[rsp], edx
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 58			; 0000003aH
	jne	$LN27@ParseProc

; 1293 :             struct asym *sym;
; 1294 :             i++;

	inc	edx

; 1295 :             if ( tokenarray[i].token != T_ID ) {

	movsxd	rcx, edx
	mov	DWORD PTR i$[rsp], edx
	shl	rcx, 5
	cmp	BYTE PTR [rcx+rdi], 8

; 1296 :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	jne	$LN9@ParseProc

; 1297 :             }
; 1298 :             sym = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rcx+rdi+8]
	call	SymFind

; 1299 :             if ( sym == NULL ) {

	test	rax, rax
	mov	rsi, rax
	jne	SHORT $LN25@ParseProc

; 1300 :                 sym = SymCreate( tokenarray[i].string_ptr );

	movsxd	rcx, DWORD PTR i$[rsp]
	shl	rcx, 5
	mov	rcx, QWORD PTR [rcx+rdi+8]
	call	SymCreate

; 1301 :                 sym->state = SYM_UNDEFINED;
; 1302 :                 sym->used = TRUE;
; 1303 :                 sym_add_table( &SymTables[TAB_UNDEF], (struct dsym *)sym ); /* add UNDEFINED */

	lea	rcx, OFFSET FLAT:SymTables
	or	BYTE PTR [rax+48], 1
	mov	rdx, rax
	mov	rsi, rax
	mov	DWORD PTR [rax+40], r14d
	call	sym_add_table
$LN23@ParseProc:

; 1308 :             }
; 1309 :             proc->e.procinfo->exc_handler = sym;

	mov	rax, QWORD PTR [rbx+104]
	mov	QWORD PTR [rax+88], rsi

; 1310 :             i++;

	inc	DWORD PTR i$[rsp]

; 1311 :         } else

	jmp	SHORT $LN22@ParseProc
$LN25@ParseProc:

; 1304 :             } else if ( sym->state != SYM_UNDEFINED &&
; 1305 :                        sym->state != SYM_INTERNAL &&
; 1306 :                        sym->state != SYM_EXTERNAL ) {

	mov	eax, DWORD PTR [rax+40]
	test	eax, eax
	je	SHORT $LN23@ParseProc
	cmp	eax, 1
	je	SHORT $LN23@ParseProc
	cmp	eax, 2
	je	SHORT $LN23@ParseProc

; 1307 :                 return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rsi+8]
	mov	ecx, 143				; 0000008fH
	jmp	$LN106@ParseProc
$LN27@ParseProc:

; 1312 :             proc->e.procinfo->exc_handler = NULL;

	mov	rax, QWORD PTR [rbx+104]
	mov	QWORD PTR [rax+88], r14
$LN22@ParseProc:

; 1313 :         proc->e.procinfo->isframe = TRUE;

	mov	rax, QWORD PTR [rbx+104]
	or	BYTE PTR [rax+128], 64			; 00000040H
	mov	edx, DWORD PTR i$[rsp]
$LN29@ParseProc:

; 1314 :     }
; 1315 : #endif
; 1316 :     /* check for USES */
; 1317 :     if ( tokenarray[i].token == T_ID && _stricmp( tokenarray[i].string_ptr, "USES" ) == 0 ) {

	movsxd	rcx, edx
	shl	rcx, 5
	cmp	BYTE PTR [rcx+rdi], 8
	jne	$LN12@ParseProc
	mov	rcx, QWORD PTR [rcx+rdi+8]
	lea	rdx, OFFSET FLAT:$SG6446
	call	_stricmp
	test	eax, eax
	jne	$LN105@ParseProc

; 1318 :         int cnt;
; 1319 :         int j;
; 1320 :         if ( !IsPROC ) {/* not for PROTO! */

	test	r15b, r15b
	jne	SHORT $LN20@ParseProc

; 1321 :             DebugMsg(("ParseProc: USES found in PROTO\n"));
; 1322 :             EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	movsxd	rdx, DWORD PTR i$[rsp]
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+8]
	call	EmitErr
$LN20@ParseProc:

; 1323 :         }
; 1324 :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax

; 1325 :         /* count register names which follow */
; 1326 :         for ( cnt = 0, j = i; tokenarray[j].token == T_REG; j++, cnt++ );

	movsxd	rdx, eax
	mov	DWORD PTR i$[rsp], eax
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rdi], 2
	jne	SHORT $LN97@ParseProc

; 1323 :         }
; 1324 :         i++;

	lea	rax, QWORD PTR [rdx+rdi]
$LL19@ParseProc:

; 1325 :         /* count register names which follow */
; 1326 :         for ( cnt = 0, j = i; tokenarray[j].token == T_REG; j++, cnt++ );

	add	rax, 32					; 00000020H
	inc	r14d
	cmp	BYTE PTR [rax], 2
	je	SHORT $LL19@ParseProc

; 1327 : 
; 1328 :         if ( cnt == 0 ) {

	test	r14d, r14d
	jne	SHORT $LN16@ParseProc
$LN97@ParseProc:

; 1329 :             DebugMsg(("ParseProc: no registers for regslist\n"));
; 1330 :             EmitErr( SYNTAX_ERROR_EX, tokenarray[i-1].tokpos );

	mov	rdx, QWORD PTR [rdx+rdi-8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 1331 :         } else {

	mov	edx, DWORD PTR i$[rsp]
	jmp	$LN12@ParseProc
$LN16@ParseProc:

; 1332 :             regist = LclAlloc( (cnt + 1) * sizeof( uint_16 ) );

	lea	eax, DWORD PTR [r14+1]
	movsxd	rcx, eax
	add	rcx, rcx
	call	LclAlloc

; 1333 :             proc->e.procinfo->regslist = regist;

	mov	rcx, QWORD PTR [rbx+104]
	mov	QWORD PTR [rcx], rax

; 1334 :             *regist++ = cnt;

	mov	WORD PTR [rax], r14w

; 1335 :             /* read in registers */
; 1336 :             for( ; tokenarray[i].token == T_REG; i++ ) {

	movsxd	rdx, DWORD PTR i$[rsp]
	lea	rsi, QWORD PTR [rax+2]
	mov	rax, rdx
	shl	rax, 5
	add	rax, rdi
	cmp	BYTE PTR [rax], 2
	jne	SHORT $LN12@ParseProc
	npad	1
$LL14@ParseProc:

; 1337 :                 if ( SizeFromRegister( tokenarray[i].tokval ) == 1 ) {

	mov	ecx, DWORD PTR [rax+16]
	call	SizeFromRegister
	cmp	eax, 1
	jne	SHORT $LN11@ParseProc

; 1338 :                     EmitError( INVALID_USE_OF_REGISTER );

	mov	ecx, 170				; 000000aaH
	call	EmitError
$LN11@ParseProc:

; 1339 :                 }
; 1340 :                 *regist++ = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR i$[rsp]
	add	rsi, 2
	shl	rax, 5
	movzx	eax, WORD PTR [rax+rdi+16]
	mov	WORD PTR [rsi-2], ax
	mov	edx, DWORD PTR i$[rsp]
	inc	edx
	movsxd	rax, edx
	mov	DWORD PTR i$[rsp], edx
	shl	rax, 5
	add	rax, rdi
	cmp	BYTE PTR [rax], 2
	je	SHORT $LL14@ParseProc

; 1335 :             /* read in registers */
; 1336 :             for( ; tokenarray[i].token == T_REG; i++ ) {

	jmp	SHORT $LN12@ParseProc
$LN105@ParseProc:

; 1331 :         } else {

	mov	edx, DWORD PTR i$[rsp]
$LN12@ParseProc:

; 1341 :             }
; 1342 :         }
; 1343 :     }
; 1344 : 
; 1345 :     /* the parameters must follow */
; 1346 :     if ( tokenarray[i].token == T_STYPE || tokenarray[i].token == T_RES_ID || tokenarray[i].token == T_DIRECTIVE ) {

	movsxd	rcx, edx
	shl	rcx, 5
	movzx	eax, BYTE PTR [rcx+rdi]
	cmp	al, 6
	je	$LN9@ParseProc
	cmp	al, 7
	je	$LN9@ParseProc
	cmp	al, 3
	je	$LN9@ParseProc

; 1348 :     }
; 1349 : 
; 1350 :     /* skip optional comma */
; 1351 :     if ( tokenarray[i].token == T_COMMA )

	cmp	al, 44					; 0000002cH
	jne	SHORT $LN8@ParseProc

; 1352 :         i++;

	inc	edx
	mov	DWORD PTR i$[rsp], edx
$LN8@ParseProc:

; 1353 : 
; 1354 :     DebugMsg1(("ParseProc(%s): i=%u, Token_Count=%u, CurrWordSize=%u\n", proc->sym.name, i, Token_Count, CurrWordSize ));
; 1355 : 
; 1356 :     if( i >= Token_Count ) {

	cmp	edx, DWORD PTR ModuleInfo+496
	jl	SHORT $LN7@ParseProc

; 1357 :         /* procedure has no parameters at all */
; 1358 :         if ( proc->e.procinfo->paralist != NULL )

	mov	rax, QWORD PTR [rbx+104]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN1@ParseProc

; 1359 :             EmitErr( CONFLICTING_PARAMETER_DEFINITION, "" );

	lea	rdx, OFFSET FLAT:$SG6466
	mov	ecx, 137				; 00000089H
	call	EmitErr

; 1371 :             /* do proceed if the parameter scan returns an error */
; 1372 :             ;//return( ERROR );
; 1373 :     }
; 1374 : 
; 1375 :     /* v2.11: isdefined and isproc now set here */
; 1376 :     proc->sym.isdefined = TRUE;

	or	BYTE PTR [rbx+48], 2

; 1377 :     proc->sym.isproc = TRUE;

	or	BYTE PTR [rbx+49], 8

; 1378 :     //proc->e.procinfo->init_done = TRUE;
; 1379 :     DebugMsg1(("ParseProc(%s): memtype=%Xh parasize=%u\n", proc->sym.name, proc->sym.mem_type, proc->e.procinfo->parasize));
; 1380 : 
; 1381 :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN81@ParseProc
$LN7@ParseProc:

; 1360 :     } else if( proc->sym.langtype == LANG_NONE ) {

	cmp	DWORD PTR [rbx+84], 0
	jne	SHORT $LN4@ParseProc

; 1361 :         EmitError( LANG_MUST_BE_SPECIFIED );

	mov	ecx, 91					; 0000005bH
	call	EmitError

; 1371 :             /* do proceed if the parameter scan returns an error */
; 1372 :             ;//return( ERROR );
; 1373 :     }
; 1374 : 
; 1375 :     /* v2.11: isdefined and isproc now set here */
; 1376 :     proc->sym.isdefined = TRUE;

	or	BYTE PTR [rbx+48], 2

; 1377 :     proc->sym.isproc = TRUE;

	or	BYTE PTR [rbx+49], 8

; 1378 :     //proc->e.procinfo->init_done = TRUE;
; 1379 :     DebugMsg1(("ParseProc(%s): memtype=%Xh parasize=%u\n", proc->sym.name, proc->sym.mem_type, proc->e.procinfo->parasize));
; 1380 : 
; 1381 :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN81@ParseProc
$LN4@ParseProc:

; 1362 :     } else {
; 1363 :         /* v2.05: set PROC's vararg flag BEFORE params are scanned! */
; 1364 :         if ( tokenarray[Token_Count - 1].token == T_RES_ID &&
; 1365 :             tokenarray[Token_Count - 1].tokval == T_VARARG )

	movsxd	rax, DWORD PTR ModuleInfo+496
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi-32], 7
	jne	SHORT $LN2@ParseProc
	cmp	DWORD PTR [rax+rdi-16], 262		; 00000106H
	jne	SHORT $LN2@ParseProc

; 1366 :             proc->e.procinfo->has_vararg = TRUE;

	mov	rax, QWORD PTR [rbx+104]
	or	BYTE PTR [rax+128], 1
	mov	edx, DWORD PTR i$[rsp]
$LN2@ParseProc:

; 1367 :         /* v2.04: removed, comma is checked above already */
; 1368 :         //if( tokenarray[i].token == T_COMMA )
; 1369 :         //    i++;
; 1370 :         if ( ERROR == ParseParams( proc, i, tokenarray, IsPROC ) )

	movzx	r9d, r15b
	mov	r8, rdi
	mov	rcx, rbx
	call	ParseParams
$LN1@ParseProc:

; 1371 :             /* do proceed if the parameter scan returns an error */
; 1372 :             ;//return( ERROR );
; 1373 :     }
; 1374 : 
; 1375 :     /* v2.11: isdefined and isproc now set here */
; 1376 :     proc->sym.isdefined = TRUE;

	or	BYTE PTR [rbx+48], 2

; 1377 :     proc->sym.isproc = TRUE;

	or	BYTE PTR [rbx+49], 8

; 1378 :     //proc->e.procinfo->init_done = TRUE;
; 1379 :     DebugMsg1(("ParseProc(%s): memtype=%Xh parasize=%u\n", proc->sym.name, proc->sym.mem_type, proc->e.procinfo->parasize));
; 1380 : 
; 1381 :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN81@ParseProc
$LN9@ParseProc:

; 1347 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rcx+rdi+8]
$LN107@ParseProc:
	mov	ecx, 209				; 000000d1H
$LN106@ParseProc:
	call	EmitErr
$LN81@ParseProc:
	mov	r15, QWORD PTR [rsp+40]
	mov	r14, QWORD PTR [rsp+48]
	mov	r13, QWORD PTR [rsp+56]
	mov	r12, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+96]

; 1382 : }

	add	rsp, 104				; 00000068H
	ret	0
ParseProc ENDP
_TEXT	ENDS
PUBLIC	CreateProc
EXTRN	get_curr_srcfile:NEAR
EXTRN	sym_remove_table:NEAR
xdata	SEGMENT
$unwind$CreateProc DD 071601H
	DD	097416H
	DD	086411H
	DD	07340cH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$CreateProc DD @imagerel($LN21#)
	DD	@imagerel($LN21#+299)
	DD	@imagerel($unwind$CreateProc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
name$ = 56
state$ = 64
CreateProc PROC NEAR

; 1398 : {

$LN21:
	sub	rsp, 40					; 00000028H

; 1399 :     if ( sym == NULL )

	test	rcx, rcx
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	mov	rbx, rcx
	lea	rsi, OFFSET FLAT:SymTables+16
	mov	edi, r8d
	jne	SHORT $LN11@CreateProc

; 1400 :         sym = ( *name ? SymCreate( name ) : SymAlloc( name ) );

	cmp	BYTE PTR [rdx], cl
	je	SHORT $LN14@CreateProc
	mov	rcx, rdx
	call	SymCreate
	mov	rbx, rax
	jmp	SHORT $LN10@CreateProc
$LN14@CreateProc:
	mov	rcx, rdx
	call	SymAlloc
	mov	rbx, rax

; 1401 :     else

	jmp	SHORT $LN10@CreateProc
$LN11@CreateProc:

; 1402 :         sym_remove_table( ( sym->state == SYM_UNDEFINED ) ? &SymTables[TAB_UNDEF] : &SymTables[TAB_EXT], (struct dsym *)sym );

	cmp	DWORD PTR [rbx+40], 0
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rbx
	cmovne	rcx, rsi
	call	sym_remove_table
$LN10@CreateProc:

; 1403 : 
; 1404 :     if ( sym ) {

	test	rbx, rbx
	je	$LN20@CreateProc

; 1405 :         struct proc_info *info;
; 1406 :         sym->state = state;
; 1407 :         if ( state != SYM_INTERNAL ) {

	cmp	edi, 1
	mov	DWORD PTR [rbx+40], edi
	je	SHORT $LN8@CreateProc

; 1408 :             sym->seg_ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR [rbx+55]
	xor	al, BYTE PTR ModuleInfo+404
	and	al, 3
	xor	BYTE PTR [rbx+55], al
$LN8@CreateProc:

; 1409 :         }
; 1410 :         info = LclAlloc( sizeof( struct proc_info ) );

	mov	ecx, 136				; 00000088H
	call	LclAlloc

; 1411 :         ((struct dsym *)sym)->e.procinfo = info;
; 1412 :         info->regslist = NULL;

	xor	edx, edx
	mov	QWORD PTR [rbx+104], rax
	mov	QWORD PTR [rax], rdx

; 1413 :         info->paralist = NULL;

	mov	QWORD PTR [rax+8], rdx

; 1414 :         info->locallist = NULL;

	mov	QWORD PTR [rax+16], rdx

; 1415 :         info->labellist = NULL;

	mov	QWORD PTR [rax+24], rdx

; 1416 :         info->parasize = 0;

	mov	DWORD PTR [rax+32], edx

; 1417 :         info->localsize = 0;

	mov	DWORD PTR [rax+36], edx

; 1418 :         info->prologuearg = NULL;

	mov	QWORD PTR [rax+48], rdx

; 1419 :         info->flags = 0;

	mov	BYTE PTR [rax+128], dl

; 1420 :         switch ( sym->state ) {

	mov	edx, DWORD PTR [rbx+40]
	dec	edx
	je	SHORT $LN5@CreateProc
	dec	edx
	jne	SHORT $LN20@CreateProc

; 1435 :             }
; 1436 :             break;
; 1437 :         case SYM_EXTERNAL:
; 1438 :             sym->weak = TRUE;

	or	BYTE PTR [rbx+55], 8

; 1439 :             sym_add_table( &SymTables[TAB_EXT], (struct dsym *)sym );

	mov	rdx, rbx
	mov	rcx, rsi
	call	sym_add_table

; 1440 :             break;

	jmp	SHORT $LN20@CreateProc
$LN5@CreateProc:

; 1421 :         case SYM_INTERNAL:
; 1422 :             /* v2.04: don't use sym_add_table() and thus
; 1423 :              * free the <next> member field!
; 1424 :              */
; 1425 :             if ( SymTables[TAB_PROC].head == NULL )

	cmp	QWORD PTR SymTables+64, 0
	jne	SHORT $LN4@CreateProc

; 1426 :                 SymTables[TAB_PROC].head = (struct dsym *)sym;

	mov	QWORD PTR SymTables+64, rbx

; 1427 :             else {

	jmp	SHORT $LN3@CreateProc
$LN4@CreateProc:

; 1428 :                 SymTables[TAB_PROC].tail->nextproc = (struct dsym *)sym;

	mov	rax, QWORD PTR SymTables+72
	mov	QWORD PTR [rax+120], rbx
$LN3@CreateProc:

; 1429 :             }
; 1430 :             SymTables[TAB_PROC].tail = (struct dsym *)sym;
; 1431 :             procidx++;

	inc	DWORD PTR procidx

; 1432 :             if ( Options.line_numbers ) {

	cmp	BYTE PTR Options+1, 0
	mov	QWORD PTR SymTables+72, rbx
	je	SHORT $LN20@CreateProc

; 1433 :                 sym->debuginfo = LclAlloc( sizeof( struct debug_info ) );

	mov	ecx, 24
	call	LclAlloc
	mov	QWORD PTR [rbx+72], rax

; 1434 :                 sym->debuginfo->file = get_curr_srcfile();

	call	get_curr_srcfile
	mov	rcx, QWORD PTR [rbx+72]
	mov	WORD PTR [rcx+14], ax
$LN20@CreateProc:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]

; 1441 :         }
; 1442 :     }
; 1443 :     return( sym );

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]

; 1444 : }

	add	rsp, 40					; 00000028H
	ret	0
CreateProc ENDP
_TEXT	ENDS
PUBLIC	DeleteProc
EXTRN	SymFree:NEAR
xdata	SEGMENT
$unwind$DeleteProc DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$DeleteProc DD @imagerel($LN11#)
	DD	@imagerel($LN11#+55)
	DD	@imagerel($unwind$DeleteProc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
proc$ = 48
DeleteProc PROC NEAR

; 1450 : {

$LN11:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1451 :     struct dsym *curr;
; 1452 :     struct dsym *next;
; 1453 : 
; 1454 :     DebugMsg(("DeleteProc(%s) enter\n", proc->sym.name ));
; 1455 :     if ( proc->sym.state == SYM_INTERNAL ) {

	cmp	DWORD PTR [rcx+40], 1
	jne	SHORT $LN4@DeleteProc

; 1456 : 
; 1457 :         /* delete all local symbols ( params, locals, labels ) */
; 1458 :         for( curr = proc->e.procinfo->labellist; curr; ) {

	mov	rax, QWORD PTR [rcx+104]
	mov	rcx, QWORD PTR [rax+24]
	test	rcx, rcx
	je	SHORT $LN4@DeleteProc
	npad	7
$LL5@DeleteProc:

; 1459 :             next = curr->e.nextll;

	mov	rbx, QWORD PTR [rcx+104]

; 1460 :             DebugMsg(("DeleteProc(%s): free %s [next=%p]\n", proc->sym.name, curr->sym.name, curr->next ));
; 1461 :             SymFree( &curr->sym );

	call	SymFree
	test	rbx, rbx

; 1462 :             curr = next;

	mov	rcx, rbx
	jne	SHORT $LL5@DeleteProc
$LN4@DeleteProc:

; 1463 :         }
; 1464 : 
; 1465 :         if ( proc->e.procinfo->regslist )
; 1466 :             LclFree( proc->e.procinfo->regslist );
; 1467 : 
; 1468 :         if ( proc->e.procinfo->prologuearg )
; 1469 :             LclFree( proc->e.procinfo->prologuearg );
; 1470 : 
; 1471 :         if ( Options.line_numbers && proc->sym.state == SYM_INTERNAL )
; 1472 :             LclFree( proc->sym.debuginfo );
; 1473 : #if FASTMEM==0 || defined(DEBUG_OUT)
; 1474 :     } else {
; 1475 :         /* PROTOs have just a parameter list, usually without names */
; 1476 :         for( curr = proc->e.procinfo->paralist; curr; ) {
; 1477 :             next = curr->nextparam;
; 1478 :             DebugMsg(("DeleteProc(%s): free %p (%s) [next=%p]\n", proc->sym.name, curr, curr->sym.name, curr->next ));
; 1479 :             SymFree( &curr->sym );
; 1480 :             curr = next;
; 1481 :         }
; 1482 : #endif
; 1483 :     }
; 1484 :     LclFree( proc->e.procinfo );
; 1485 :     return;
; 1486 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
DeleteProc ENDP
_TEXT	ENDS
PUBLIC	ProcDir
EXTRN	BackPatch:NEAR
EXTRN	AddLinnumDataRef:NEAR
EXTRN	GetLineNumber:NEAR
EXTRN	LstWrite:NEAR
EXTRN	GetCurrOffset:NEAR
EXTRN	SymSetLocal:NEAR
EXTRN	AddPublicData:NEAR
EXTRN	sym_ext2int:NEAR
EXTRN	SymClearLocal:NEAR
EXTRN	SetSymSegOfs:NEAR
EXTRN	AlignCurrOffset:NEAR
_BSS	SEGMENT
unw_info DD	01H DUP (?)
endprolog_found DB 01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$ProcDir DD 099d01H
	DD	0a649dH
	DD	06c41dH
	DD	0b740eH
	DD	083409H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$ProcDir DD @imagerel($LN38#)
	DD	@imagerel($LN38#+243)
	DD	@imagerel($unwind$ProcDir#)
pdata	ENDS
xdata	SEGMENT
$chain$4$ProcDir DD 020521H
	DD	095405H
	DD	@imagerel($LN38#)
	DD	@imagerel($LN38#+243)
	DD	@imagerel($unwind$ProcDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$ProcDir DD @imagerel($LN38#+243)
	DD	@imagerel($LN38#+363)
	DD	@imagerel($chain$4$ProcDir#)
pdata	ENDS
xdata	SEGMENT
$chain$5$ProcDir DD 021H
	DD	@imagerel($LN38#)
	DD	@imagerel($LN38#+243)
	DD	@imagerel($unwind$ProcDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$ProcDir DD @imagerel($LN38#+363)
	DD	@imagerel($LN38#+381)
	DD	@imagerel($chain$5$ProcDir#)
pdata	ENDS
xdata	SEGMENT
$chain$6$ProcDir DD 020021H
	DD	095400H
	DD	@imagerel($LN38#)
	DD	@imagerel($LN38#+243)
	DD	@imagerel($unwind$ProcDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$ProcDir DD @imagerel($LN38#+381)
	DD	@imagerel($LN38#+1007)
	DD	@imagerel($chain$6$ProcDir#)
pdata	ENDS
xdata	SEGMENT
$chain$7$ProcDir DD 021H
	DD	@imagerel($LN38#)
	DD	@imagerel($LN38#+243)
	DD	@imagerel($unwind$ProcDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$ProcDir DD @imagerel($LN38#+1007)
	DD	@imagerel($LN38#+1032)
	DD	@imagerel($chain$7$ProcDir#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 64
tokenarray$ = 72
ProcDir	PROC NEAR

; 1492 : {

$LN38:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+88], rdi
	movsxd	rdi, ecx

; 1493 :     struct asym         *sym;
; 1494 :     unsigned int        ofs;
; 1495 :     char                *name;
; 1496 :     bool                oldpubstate;
; 1497 :     bool                is_global;
; 1498 : 	struct asym*        cline;
; 1499 : 	struct asym*        procline;
; 1500 : 
; 1501 : 	/* Store the current source code line relating to the PROC */
; 1502 : 	cline = SymFind("@Line");

	lea	rcx, OFFSET FLAT:$SG6533
	mov	QWORD PTR [rsp+48], r12
	mov	r12, rdx
	call	SymFind

; 1503 : 	procline = SymFind("@ProcLine");

	lea	rcx, OFFSET FLAT:$SG6534
	mov	rbx, rax
	call	SymFind

; 1504 : 	procline->value = cline->value;
; 1505 : 
; 1506 :     DebugMsg1(("ProcDir enter, curr ofs=%X\n", GetCurrOffset() ));
; 1507 :     if( i != 1 ) {

	cmp	edi, 1
	mov	r8d, DWORD PTR [rbx+16]
	mov	DWORD PTR [rax+16], r8d
	je	SHORT $LN29@ProcDir

; 1508 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, rdi
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r12+8]
	mov	r12, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+64]

; 1688 : }

	add	rsp, 56					; 00000038H
	jmp	EmitErr
$LN29@ProcDir:

; 1509 :     }
; 1510 :     /* v2.04b: check was missing */
; 1511 :     if( CurrSeg == NULL ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	jne	SHORT $LN28@ProcDir

; 1512 :         return( EmitError( MUST_BE_IN_SEGMENT_BLOCK ) );

	mov	ecx, 82					; 00000052H
	mov	r12, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+64]

; 1688 : }

	add	rsp, 56					; 00000038H
	jmp	EmitError
$LN28@ProcDir:

; 1513 :     }
; 1514 : 
; 1515 :     name = tokenarray[0].string_ptr;
; 1516 : 
; 1517 :     if( CurrProc != NULL ) {

	mov	rcx, QWORD PTR CurrProc
	mov	QWORD PTR [rsp+80], rsi
	mov	rsi, QWORD PTR [r12+8]
	test	rcx, rcx
	je	SHORT $LN27@ProcDir

; 1518 : 
; 1519 :         /* this is not needed for HJWasm, but Masm will reject nested
; 1520 :          * procs if there are params, locals or used registers.
; 1521 :          */
; 1522 :         if ( CurrProc->e.procinfo->paralist ||
; 1523 : #if AMD64_SUPPORT
; 1524 :             CurrProc->e.procinfo->isframe ||
; 1525 : #endif
; 1526 :             CurrProc->e.procinfo->locallist ||
; 1527 :             CurrProc->e.procinfo->regslist ) {

	mov	rax, QWORD PTR [rcx+104]
	cmp	QWORD PTR [rax+8], 0
	jne	$LN25@ProcDir
	test	BYTE PTR [rax+128], 64			; 00000040H
	jne	$LN25@ProcDir
	cmp	QWORD PTR [rax+16], 0
	jne	$LN25@ProcDir
	cmp	QWORD PTR [rax], 0
	jne	$LN25@ProcDir

; 1529 :         }
; 1530 :         /* nested procs ... push currproc on a stack */
; 1531 :         push_proc( CurrProc );

	call	push_proc
$LN27@ProcDir:

; 1532 :     }
; 1533 : 
; 1534 : 
; 1535 :     if ( ModuleInfo.procalign ) {

	movzx	eax, BYTE PTR ModuleInfo+399
	test	al, al
	je	SHORT $LN24@ProcDir

; 1536 :         AlignCurrOffset( ModuleInfo.procalign );

	movzx	ecx, al
	call	AlignCurrOffset
$LN24@ProcDir:

; 1537 :     }
; 1538 : 
; 1539 :     i++; /* go past PROC */
; 1540 : 
; 1541 :     sym = SymSearch( name );

	mov	rcx, rsi
	mov	QWORD PTR [rsp+72], rbp
	call	SymFind

; 1542 : 
; 1543 :     if( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	rbx, rax
	jne	$LN23@ProcDir

; 1544 : 
; 1545 :         oldpubstate = sym ? sym->ispublic : FALSE;

	test	rax, rax
	je	SHORT $LN32@ProcDir
	movzx	edi, BYTE PTR [rax+48]

; 1546 :         if( sym == NULL || sym->state == SYM_UNDEFINED ) {

	mov	eax, DWORD PTR [rax+40]
	shr	dil, 7
	test	eax, eax
	je	SHORT $LN21@ProcDir

; 1549 :         } else if ( sym->state == SYM_EXTERNAL && sym->weak == TRUE ) {

	cmp	eax, 2
	jne	$LN19@ProcDir
	test	BYTE PTR [rbx+55], 8
	je	$LN19@ProcDir

; 1550 :             /* PROTO or EXTERNDEF item */
; 1551 :             is_global = TRUE;
; 1552 :             if ( sym->isproc == TRUE  ) {

	test	BYTE PTR [rbx+49], 8
	mov	bpl, 1
	je	$LN18@ProcDir

; 1553 :                 /* don't create the procinfo extension; it exists already */
; 1554 :                 procidx++; /* v2.04: added */

	inc	DWORD PTR procidx

; 1555 :                 if ( Options.line_numbers ) {

	cmp	BYTE PTR Options+1, 0
	je	SHORT $LN15@ProcDir

; 1556 :                     sym->debuginfo = LclAlloc( sizeof( struct debug_info ) );

	lea	ecx, QWORD PTR [rax+22]
	call	LclAlloc
	mov	QWORD PTR [rbx+72], rax

; 1557 :                     sym->debuginfo->file = get_curr_srcfile();

	call	get_curr_srcfile
	mov	rcx, QWORD PTR [rbx+72]
	mov	WORD PTR [rcx+14], ax

; 1558 :                 }
; 1559 :             } else {

	jmp	SHORT $LN15@ProcDir
$LN25@ProcDir:

; 1528 :             return( EmitErr( CANNOT_NEST_PROCEDURES, name ) );

	mov	rdx, rsi
	mov	ecx, 93					; 0000005dH
	call	EmitErr
	jmp	$LN36@ProcDir
$LN32@ProcDir:

; 1544 : 
; 1545 :         oldpubstate = sym ? sym->ispublic : FALSE;

	xor	dil, dil
$LN21@ProcDir:

; 1547 :             sym = CreateProc( sym, name, SYM_INTERNAL );

	mov	r8d, 1
	mov	rdx, rsi
	mov	rcx, rbx
	call	CreateProc

; 1548 :             is_global = FALSE;

	xor	bpl, bpl
	mov	rbx, rax
$LN15@ProcDir:

; 1574 :         }
; 1575 :         SetSymSegOfs( sym );

	mov	rcx, rbx
	call	SetSymSegOfs

; 1576 : 
; 1577 :         SymClearLocal();

	call	SymClearLocal

; 1578 : 
; 1579 : #if STACKBASESUPP
; 1580 :         /* v2.11: added. Note that fpo flag is only set if there ARE params! */
; 1581 :         ((struct dsym *)sym)->e.procinfo->basereg = ModuleInfo.basereg[ModuleInfo.Ofssize];

	mov	rcx, QWORD PTR [rbx+104]
	movzx	r11d, BYTE PTR ModuleInfo+404
	lea	rsi, OFFSET FLAT:__ImageBase

; 1582 : #endif
; 1583 :         /* CurrProc must be set, it's used inside SymFind() and SymLCreate()! */
; 1584 :         CurrProc = (struct dsym *)sym;
; 1585 :         if( ParseProc( (struct dsym *)sym, i, tokenarray, TRUE, ModuleInfo.langtype ) == ERROR ) {

	mov	r9b, 1
	movzx	eax, WORD PTR ModuleInfo[rsi+r11*4+500]
	mov	r8, r12
	mov	edx, 2
	mov	WORD PTR [rcx+130], ax
	mov	eax, DWORD PTR ModuleInfo+364
	mov	rcx, rbx
	mov	DWORD PTR [rsp+32], eax
	mov	QWORD PTR CurrProc, rbx
	call	ParseProc
	cmp	eax, -1
	jne	SHORT $LN14@ProcDir

; 1586 :             CurrProc = NULL;

	xor	edi, edi
	mov	QWORD PTR CurrProc, rdi

; 1587 :             return( ERROR );

	jmp	$LN37@ProcDir
$LN18@ProcDir:

; 1560 :                 /* it's a simple EXTERNDEF. Create a PROC item!
; 1561 :                  * this will be SYM_INTERNAL */
; 1562 :                 /* v2.03: don't call dir_free(), it'll clear field Ofssize */
; 1563 :                 //dir_free( (struct dsym *)sym );
; 1564 :                 sym = CreateProc( sym, name, SYM_INTERNAL );

	mov	r8d, 1
	mov	rdx, rsi
	mov	rcx, rbx
	call	CreateProc
	mov	rbx, rax

; 1565 :             }
; 1566 :         } else {

	jmp	SHORT $LN15@ProcDir
$LN19@ProcDir:

; 1567 :             /* Masm won't reject a redefinition if "certain" parameters
; 1568 :              * won't change. However, in a lot of cases one gets "internal assembler error".
; 1569 :              * Hence this "feature" isn't active in hjwasm.
; 1570 :              */
; 1571 :             //} else if ( sym->state != SYM_INTERNAL || sym->isproc != TRUE ||
; 1572 :             //           sym->offset != GetCurrOffset() || sym->segment != &CurrSeg->sym ) {
; 1573 :             return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN37@ProcDir
$LN14@ProcDir:

; 1588 :         }
; 1589 :         /* v2.04: added */
; 1590 :         if ( is_global && Options.masm8_proc_visibility )

	test	bpl, bpl
	je	SHORT $LN13@ProcDir
	cmp	BYTE PTR Options+138, 0
	je	SHORT $LN13@ProcDir

; 1591 :             sym->ispublic = TRUE;

	or	BYTE PTR [rbx+48], 128			; 00000080H
$LN13@ProcDir:

; 1592 : 
; 1593 :         /* if there was a PROTO (or EXTERNDEF name:PROTO ...),
; 1594 :          * change symbol to SYM_INTERNAL!
; 1595 :          */
; 1596 :         if ( sym->state == SYM_EXTERNAL && sym->isproc == TRUE ) {

	cmp	DWORD PTR [rbx+40], 2
	jne	SHORT $LN12@ProcDir
	test	BYTE PTR [rbx+49], 8
	je	SHORT $LN12@ProcDir

; 1597 :             sym_ext2int( sym );

	mov	rcx, rbx
	call	sym_ext2int

; 1598 :             /* v2.11: added ( may be better to call CreateProc() - currently not possible ) */
; 1599 :             if ( SymTables[TAB_PROC].head == NULL )

	cmp	QWORD PTR SymTables+64, 0
	jne	SHORT $LN11@ProcDir

; 1600 :                 SymTables[TAB_PROC].head = (struct dsym *)sym;

	mov	QWORD PTR SymTables+64, rbx

; 1601 :             else {

	jmp	SHORT $LN10@ProcDir
$LN11@ProcDir:

; 1602 :                 SymTables[TAB_PROC].tail->nextproc = (struct dsym *)sym;

	mov	rax, QWORD PTR SymTables+72
	mov	QWORD PTR [rax+120], rbx
$LN10@ProcDir:

; 1603 :             }
; 1604 :             SymTables[TAB_PROC].tail = (struct dsym *)sym;

	mov	QWORD PTR SymTables+72, rbx
$LN12@ProcDir:

; 1605 :         }
; 1606 : 
; 1607 :         /* v2.11: sym->isproc is set inside ParseProc() */
; 1608 :         //sym->isproc = TRUE;
; 1609 : #if STACKBASESUPP
; 1610 :         /* v2.11: Note that fpo flag is only set if there ARE params ( or locals )! */
; 1611 :         if ( CurrProc->e.procinfo->paralist && GetRegNo( CurrProc->e.procinfo->basereg ) == 4 )

	mov	rdx, QWORD PTR CurrProc
	mov	rax, QWORD PTR [rdx+104]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN9@ProcDir
	movzx	eax, WORD PTR [rax+130]
	lea	rcx, QWORD PTR [rax+rax*2]
	cmp	BYTE PTR SpecialTable[rsi+rcx*4+10], 4
	jne	SHORT $LN9@ProcDir

; 1612 :             CurrProc->e.procinfo->fpo = TRUE;

	mov	rax, QWORD PTR [rdx+104]
	or	BYTE PTR [rax+128], 128			; 00000080H
$LN9@ProcDir:

; 1613 : #endif
; 1614 :         if( sym->ispublic == TRUE && oldpubstate == FALSE )

	test	BYTE PTR [rbx+48], 128			; 00000080H
	je	SHORT $LN8@ProcDir
	test	dil, dil
	jne	SHORT $LN8@ProcDir

; 1615 :             AddPublicData( sym );

	mov	rcx, rbx
	call	AddPublicData
$LN8@ProcDir:

; 1616 : 
; 1617 :         /* v2.04: add the proc to the list of labels attached to curr segment.
; 1618 :          * this allows to reduce the number of passes (see fixup.c)
; 1619 :          */
; 1620 :         ((struct dsym *)sym)->next = (struct dsym *)CurrSeg->e.seginfo->label_list;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rcx+32]
	mov	QWORD PTR [rbx+112], rax

; 1621 :         CurrSeg->e.seginfo->label_list = sym;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	mov	QWORD PTR [rcx+32], rbx

; 1622 : 
; 1623 :     } else {

	jmp	SHORT $LN5@ProcDir
$LN23@ProcDir:

; 1624 :         /**/myassert( sym != NULL );
; 1625 : 
; 1626 :         procidx++;

	inc	DWORD PTR procidx

; 1627 :         sym->isdefined = TRUE;

	or	BYTE PTR [rax+48], 2

; 1628 : 
; 1629 :         SymSetLocal( sym );

	mov	rcx, rax
	call	SymSetLocal

; 1630 : 
; 1631 :         /* it's necessary to check for a phase error here
; 1632 :          as it is done in LabelCreate() and data_dir()!
; 1633 :          */
; 1634 :         ofs = GetCurrOffset();

	call	GetCurrOffset

; 1635 : 
; 1636 :         if ( ofs != sym->offset) {

	cmp	eax, DWORD PTR [rbx+16]
	je	SHORT $LN6@ProcDir

; 1637 :             DebugMsg(("ProcDir(%s): %spass %u, old ofs=%" I32_SPEC "X, new ofs=%" I32_SPEC "X\n",
; 1638 :                     sym->name,
; 1639 :                     ModuleInfo.PhaseError ? "" : "phase error ",
; 1640 :                     Parse_Pass+1, sym->offset, ofs ));
; 1641 :             sym->offset = ofs;

	mov	DWORD PTR [rbx+16], eax

; 1642 :             ModuleInfo.PhaseError = TRUE;

	mov	BYTE PTR ModuleInfo+422, 1
$LN6@ProcDir:

; 1643 :         }
; 1644 :         CurrProc = (struct dsym *)sym;

	mov	QWORD PTR CurrProc, rbx

; 1645 : #if AMD64_SUPPORT
; 1646 :         /* check if the exception handler set by FRAME is defined */
; 1647 :         if ( CurrProc->e.procinfo->isframe &&
; 1648 :             CurrProc->e.procinfo->exc_handler &&
; 1649 :             CurrProc->e.procinfo->exc_handler->state == SYM_UNDEFINED ) {

	mov	rdx, QWORD PTR [rbx+104]
	test	BYTE PTR [rdx+128], 64			; 00000040H
	je	SHORT $LN5@ProcDir
	mov	rdx, QWORD PTR [rdx+88]
	test	rdx, rdx
	je	SHORT $LN5@ProcDir
	cmp	DWORD PTR [rdx+40], 0
	jne	SHORT $LN5@ProcDir

; 1650 :             EmitErr( SYMBOL_NOT_DEFINED, CurrProc->e.procinfo->exc_handler->name );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 102				; 00000066H
	call	EmitErr
$LN5@ProcDir:

; 1651 :         }
; 1652 : #endif
; 1653 :     }
; 1654 : 
; 1655 :     /* v2.11: init @ProcStatus - prologue not written yet, optionally set FPO flag */
; 1656 : #if STACKBASESUPP
; 1657 :     ProcStatus = PRST_PROLOGUE_NOT_DONE | ( CurrProc->e.procinfo->fpo ? PRST_FPO : 0 );

	mov	rdx, QWORD PTR CurrProc

; 1658 :     StackAdj = 0;  /* init @StackBase to 0 */

	xor	edi, edi
	mov	rax, QWORD PTR [rdx+104]
	mov	cl, BYTE PTR [rax+128]
	mov	DWORD PTR StackAdj, edi

; 1659 :     StackAdjHigh = 0;

	mov	DWORD PTR StackAdjHigh, edi
	shr	ecx, 5
	and	ecx, 4
	bts	ecx, 7
	mov	DWORD PTR ProcStatus, ecx

; 1660 : #else
; 1661 :     ProcStatus = PRST_PROLOGUE_NOT_DONE;
; 1662 : #endif
; 1663 : 
; 1664 : #if AMD64_SUPPORT
; 1665 :     if ( CurrProc->e.procinfo->isframe ) {

	mov	rax, QWORD PTR [rdx+104]
	test	BYTE PTR [rax+128], 64			; 00000040H
	je	SHORT $LN3@ProcDir

; 1666 :         endprolog_found = FALSE;
; 1667 :         /* v2.11: clear all fields */
; 1668 :         memset( &unw_info, 0, sizeof( unw_info ) );

	xor	eax, eax
	mov	BYTE PTR endprolog_found, dil
	mov	DWORD PTR unw_info, eax

; 1669 :         if ( CurrProc->e.procinfo->exc_handler )

	mov	rax, QWORD PTR [rdx+104]
	cmp	QWORD PTR [rax+88], rdi
	je	SHORT $LN3@ProcDir

; 1670 :             unw_info.Flags = UNW_FLAG_FHANDLER;

	movzx	eax, BYTE PTR unw_info
	and	al, 7
	or	al, 24
	mov	BYTE PTR unw_info, al
$LN3@ProcDir:

; 1671 :     }
; 1672 : #endif
; 1673 : 
; 1674 :     sym->asmpass = Parse_Pass;

	movzx	eax, BYTE PTR Parse_Pass
	mov	BYTE PTR [rbx+54], al

; 1675 :     if ( ModuleInfo.list )

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN2@ProcDir

; 1676 :         LstWrite( LSTTYPE_LABEL, 0, NULL );

	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+7]
	call	LstWrite
$LN2@ProcDir:

; 1677 : 
; 1678 :     if( Options.line_numbers ) {

	cmp	BYTE PTR Options+1, dil
	je	SHORT $LN1@ProcDir

; 1679 : #if COFF_SUPPORT
; 1680 :         AddLinnumDataRef( get_curr_srcfile(), Options.output_format == OFORMAT_COFF ? 0 : GetLineNumber() );

	cmp	DWORD PTR Options+156, 2
	je	SHORT $LN35@ProcDir
	call	GetLineNumber
	mov	edi, eax
$LN35@ProcDir:
	call	get_curr_srcfile
	mov	edx, edi
	mov	ecx, eax
	call	AddLinnumDataRef
$LN1@ProcDir:

; 1681 : #else
; 1682 :         AddLinnumDataRef( get_curr_srcfile(), GetLineNumber() );
; 1683 : #endif
; 1684 :     }
; 1685 : 
; 1686 :     BackPatch( sym );

	mov	rcx, rbx
	call	BackPatch

; 1687 :     return( NOT_ERROR );

	xor	eax, eax
$LN37@ProcDir:
	mov	rbp, QWORD PTR [rsp+72]
$LN36@ProcDir:
	mov	rsi, QWORD PTR [rsp+80]
	mov	r12, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+64]

; 1688 : }

	add	rsp, 56					; 00000038H
	ret	0
ProcDir	ENDP
_TEXT	ENDS
PUBLIC	CopyPrototype
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$CopyPrototype DD 074101H
	DD	075441H
	DD	086412H
	DD	06340dH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$CopyPrototype DD @imagerel($LN16#)
	DD	@imagerel($LN16#+138)
	DD	@imagerel($unwind$CopyPrototype#)
pdata	ENDS
xdata	SEGMENT
$chain$3$CopyPrototype DD 020521H
	DD	097405H
	DD	@imagerel($LN16#)
	DD	@imagerel($LN16#+138)
	DD	@imagerel($unwind$CopyPrototype#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$CopyPrototype DD @imagerel($LN16#+138)
	DD	@imagerel($LN16#+238)
	DD	@imagerel($chain$3$CopyPrototype#)
pdata	ENDS
xdata	SEGMENT
$chain$4$CopyPrototype DD 021H
	DD	@imagerel($LN16#)
	DD	@imagerel($LN16#+138)
	DD	@imagerel($unwind$CopyPrototype#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$CopyPrototype DD @imagerel($LN16#+238)
	DD	@imagerel($LN16#+260)
	DD	@imagerel($chain$4$CopyPrototype#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
proc$ = 48
src$ = 56
CopyPrototype PROC NEAR

; 1692 : {

$LN16:
	sub	rsp, 40					; 00000028H

; 1693 :     struct dsym *curr;
; 1694 :     struct dsym *newl;
; 1695 :     struct dsym *oldl;
; 1696 : 
; 1697 :     if ( src->sym.isproc == FALSE )

	test	BYTE PTR [rdx+49], 8
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, rcx
	mov	rbx, rdx
	jne	SHORT $LN9@CopyProtot

; 1698 :         return( ERROR );

	mov	eax, -1
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]

; 1725 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN9@CopyProtot:

; 1699 :     memcpy(proc->e.procinfo, src->e.procinfo, sizeof( struct proc_info ) );

	mov	rdx, QWORD PTR [rdx+104]
	mov	rcx, QWORD PTR [rcx+104]
	mov	r8d, 136				; 00000088H
	mov	QWORD PTR [rsp+56], rbp
	call	memcpy

; 1700 :     proc->sym.mem_type = src->sym.mem_type;

	mov	r11d, DWORD PTR [rbx+44]
	mov	DWORD PTR [rsi+44], r11d

; 1701 :     proc->sym.langtype = src->sym.langtype;

	mov	eax, DWORD PTR [rbx+84]

; 1702 : #if MANGLERSUPP
; 1703 :     proc->sym.mangler  = src->sym.mangler;
; 1704 : #endif
; 1705 :     proc->sym.ispublic   = src->sym.ispublic;
; 1706 :     /* we use the PROTO part, not the TYPE part */
; 1707 :     //dir->sym.seg_ofssize = src->sym.Ofssize;
; 1708 :     proc->sym.seg_ofssize = src->sym.seg_ofssize;
; 1709 :     proc->sym.isproc = TRUE;
; 1710 :     proc->e.procinfo->paralist = NULL;

	xor	ebp, ebp
	mov	DWORD PTR [rsi+84], eax
	movzx	eax, BYTE PTR [rbx+48]
	xor	al, BYTE PTR [rsi+48]
	and	al, 127					; 0000007fH
	xor	al, BYTE PTR [rbx+48]
	mov	BYTE PTR [rsi+48], al
	movzx	eax, BYTE PTR [rbx+55]
	or	BYTE PTR [rsi+49], 8
	xor	al, BYTE PTR [rsi+55]
	and	al, 3
	xor	BYTE PTR [rsi+55], al
	mov	rax, QWORD PTR [rsi+104]
	mov	QWORD PTR [rax+8], rbp

; 1711 :     for ( curr = src->e.procinfo->paralist; curr; curr = curr->nextparam ) {

	mov	rax, QWORD PTR [rbx+104]
	mov	rbx, QWORD PTR [rax+8]
	test	rbx, rbx
	je	SHORT $LN6@CopyProtot
	mov	QWORD PTR [rsp+72], rdi
	npad	1
$LL8@CopyProtot:

; 1712 :         newl = LclAlloc( sizeof( struct dsym ) );

	mov	ecx, 128				; 00000080H
	call	LclAlloc

; 1713 :         memcpy( newl, curr, sizeof( struct dsym ) );

	mov	rdx, rbx
	mov	r8d, 128				; 00000080H
	mov	rcx, rax
	mov	rdi, rax
	call	memcpy

; 1714 :         newl->nextparam = NULL;

	mov	QWORD PTR [rdi+120], rbp

; 1715 :         if ( proc->e.procinfo->paralist == NULL)

	mov	rax, QWORD PTR [rsi+104]
	mov	rcx, QWORD PTR [rax+8]
	test	rcx, rcx
	jne	SHORT $LN5@CopyProtot

; 1716 :             proc->e.procinfo->paralist = newl;

	mov	QWORD PTR [rax+8], rdi

; 1717 :         else {

	jmp	SHORT $LN7@CopyProtot
$LN5@CopyProtot:

; 1718 :             for ( oldl = proc->e.procinfo->paralist; oldl->nextparam; oldl = oldl->nextparam );

	mov	rax, QWORD PTR [rcx+120]
	test	rax, rax
	je	SHORT $LN1@CopyProtot
	npad	2
$LL3@CopyProtot:
	mov	rcx, rax
	mov	rax, QWORD PTR [rax+120]
	test	rax, rax
	jne	SHORT $LL3@CopyProtot
$LN1@CopyProtot:

; 1719 :             oldl->nextparam = newl;

	mov	QWORD PTR [rcx+120], rdi
$LN7@CopyProtot:

; 1711 :     for ( curr = src->e.procinfo->paralist; curr; curr = curr->nextparam ) {

	mov	rbx, QWORD PTR [rbx+120]
	test	rbx, rbx
	jne	SHORT $LL8@CopyProtot
	mov	rdi, QWORD PTR [rsp+72]
$LN6@CopyProtot:
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]

; 1720 :         }
; 1721 :     }
; 1722 :     DebugMsg1(("CopyPrototype(%s,src=%s): ofssize=%u\n",
; 1723 :                proc->sym.name, src->sym.name, src->sym.seg_ofssize ));
; 1724 :     return( NOT_ERROR );

	xor	eax, eax

; 1725 : }

	add	rsp, 40					; 00000028H
	ret	0
CopyPrototype ENDP
_TEXT	ENDS
EXTRN	RunLineQueue:NEAR
EXTRN	GetSegIdx:NEAR
EXTRN	SimGetSegName:NEAR
EXTRN	AddLineQueue:NEAR
EXTRN	AddLineQueueX:NEAR
_BSS	SEGMENT
	ALIGN	4

unw_code DW	0102H DUP (?)
unw_segs_defined DB 01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$WriteSEHData DD 041501H
	DD	01d5415H
	DD	01b0107H
xdata	ENDS
pdata	SEGMENT
$pdata$WriteSEHData DD @imagerel(WriteSEHData#)
	DD	@imagerel(WriteSEHData#+150)
	DD	@imagerel($unwind$WriteSEHData#)
pdata	ENDS
xdata	SEGMENT
$chain$2$WriteSEHData DD 044b21H
	DD	01f744bH
	DD	01ac408H
	DD	@imagerel(WriteSEHData#)
	DD	@imagerel(WriteSEHData#+150)
	DD	@imagerel($unwind$WriteSEHData#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$WriteSEHData DD @imagerel(WriteSEHData#+150)
	DD	@imagerel(WriteSEHData#+271)
	DD	@imagerel($chain$2$WriteSEHData#)
pdata	ENDS
xdata	SEGMENT
$chain$3$WriteSEHData DD 020821H
	DD	01c3408H
	DD	@imagerel(WriteSEHData#+150)
	DD	@imagerel(WriteSEHData#+271)
	DD	@imagerel($chain$2$WriteSEHData#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$WriteSEHData DD @imagerel(WriteSEHData#+271)
	DD	@imagerel(WriteSEHData#+307)
	DD	@imagerel($chain$3$WriteSEHData#)
pdata	ENDS
xdata	SEGMENT
$chain$4$WriteSEHData DD 020821H
	DD	01e6408H
	DD	@imagerel(WriteSEHData#+271)
	DD	@imagerel(WriteSEHData#+307)
	DD	@imagerel($chain$3$WriteSEHData#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$WriteSEHData DD @imagerel(WriteSEHData#+307)
	DD	@imagerel(WriteSEHData#+440)
	DD	@imagerel($chain$4$WriteSEHData#)
pdata	ENDS
xdata	SEGMENT
$chain$5$WriteSEHData DD 021H
	DD	@imagerel(WriteSEHData#+271)
	DD	@imagerel(WriteSEHData#+307)
	DD	@imagerel($chain$3$WriteSEHData#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$WriteSEHData DD @imagerel(WriteSEHData#+440)
	DD	@imagerel(WriteSEHData#+448)
	DD	@imagerel($chain$5$WriteSEHData#)
pdata	ENDS
xdata	SEGMENT
$chain$6$WriteSEHData DD 021H
	DD	@imagerel(WriteSEHData#+150)
	DD	@imagerel(WriteSEHData#+271)
	DD	@imagerel($chain$2$WriteSEHData#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$WriteSEHData DD @imagerel(WriteSEHData#+448)
	DD	@imagerel(WriteSEHData#+841)
	DD	@imagerel($chain$6$WriteSEHData#)
pdata	ENDS
xdata	SEGMENT
$chain$7$WriteSEHData DD 021H
	DD	@imagerel(WriteSEHData#)
	DD	@imagerel(WriteSEHData#+150)
	DD	@imagerel($unwind$WriteSEHData#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$WriteSEHData DD @imagerel(WriteSEHData#+841)
	DD	@imagerel(WriteSEHData#+857)
	DD	@imagerel($chain$7$WriteSEHData#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
segnamebuff$ = 64
buffer$ = 80
proc$ = 224
WriteSEHData PROC NEAR

; 1733 : {

	sub	rsp, 216				; 000000d8H

; 1734 :     struct dsym *xdata;
; 1735 :     char *segname = ".xdata";
; 1736 :     int i;
; 1737 :     int simplespec;
; 1738 :     uint_8 olddotname;
; 1739 :     uint_32 xdataofs = 0;
; 1740 :     char segnamebuff[12];
; 1741 :     char buffer[128];
; 1742 : 
; 1743 : 	/* 2016-02-10 John Hankinson - Don't bother writing SEH data for ELF64 Win64 ABI hack or hjwasm flat mode */
; 1744 : 	if (Options.output_format == OFORMAT_ELF || Options.output_format == OFORMAT_BIN)

	mov	eax, DWORD PTR Options+156
	mov	QWORD PTR [rsp+232], rbp
	mov	rbp, rcx
	cmp	eax, 3
	je	$LN16@WriteSEHDa
	test	eax, eax
	je	$LN16@WriteSEHDa

; 1745 : 	return;
; 1746 : 
; 1747 :     if ( endprolog_found == FALSE ) {

	cmp	BYTE PTR endprolog_found, 0
	jne	SHORT $LN15@WriteSEHDa

; 1748 :         EmitErr( MISSING_ENDPROLOG, proc->sym.name );

	mov	rdx, QWORD PTR [rcx+8]
	mov	ecx, 260				; 00000104H
	call	EmitErr
$LN15@WriteSEHDa:

; 1749 :     }
; 1750 :     if ( unw_segs_defined )

	cmp	BYTE PTR unw_segs_defined, 0
	je	SHORT $LN14@WriteSEHDa

; 1751 :         AddLineQueueX("%s %r", segname, T_SEGMENT );

	lea	rdx, OFFSET FLAT:$SG6610
	lea	rcx, OFFSET FLAT:$SG6621
	mov	r8d, 441				; 000001b9H
	call	AddLineQueueX

; 1752 :     else {

	jmp	SHORT $LN13@WriteSEHDa
$LN14@WriteSEHDa:

; 1753 :         AddLineQueueX("%s %r align(%u) flat read 'DATA'", segname, T_SEGMENT, 8 );

	lea	rdx, OFFSET FLAT:$SG6610
	lea	rcx, OFFSET FLAT:$SG6623
	mov	r9d, 8
	mov	r8d, 441				; 000001b9H
	call	AddLineQueueX

; 1754 :         AddLineQueue("$xdatasym label near");

	lea	rcx, OFFSET FLAT:$SG6624
	call	AddLineQueue
$LN13@WriteSEHDa:

; 1755 :     }
; 1756 :     xdataofs = 0;
; 1757 :     xdata = (struct dsym *)SymSearch( segname );

	lea	rcx, OFFSET FLAT:$SG6610
	mov	QWORD PTR [rsp+208], r12
	xor	r12d, r12d
	call	SymFind

; 1758 :     if ( xdata ) {

	test	rax, rax
	je	SHORT $LN12@WriteSEHDa

; 1759 :         /* v2.11: changed offset to max_offset.
; 1760 :          * However, value structinfo.current_loc might even be better.
; 1761 :          */
; 1762 :         xdataofs = xdata->sym.max_offset;

	mov	r12d, DWORD PTR [rax+64]
$LN12@WriteSEHDa:

; 1763 :     }
; 1764 : 
; 1765 :     /* write the .xdata stuff (a UNWIND_INFO entry )
; 1766 :      * v2.11: 't'-suffix added to ensure the values are correct if radix is != 10.
; 1767 :      */
; 1768 :     AddLineQueueX( "db %ut + (0%xh shl 3), %ut, %ut, 0%xh + (0%xh shl 4)",
; 1769 :             UNW_VERSION, unw_info.Flags, unw_info.SizeOfProlog,
; 1770 :             unw_info.CountOfCodes, unw_info.FrameRegister, unw_info.FrameOffset );

	movzx	edx, BYTE PTR unw_info+3
	movzx	r8d, BYTE PTR unw_info
	movzx	eax, BYTE PTR unw_info+2
	movzx	r9d, BYTE PTR unw_info+1
	mov	ecx, edx
	and	edx, 15
	shr	ecx, 4
	shr	r8d, 3
	mov	QWORD PTR [rsp+248], rdi
	mov	DWORD PTR [rsp+48], ecx
	mov	DWORD PTR [rsp+40], edx
	lea	rcx, OFFSET FLAT:$SG6627
	mov	edx, 1
	mov	DWORD PTR [rsp+32], eax
	call	AddLineQueueX

; 1771 :     if ( unw_info.CountOfCodes ) {

	movzx	edx, BYTE PTR unw_info+2
	test	dl, dl
	je	$LN8@WriteSEHDa

; 1772 :         char *pfx = "dw";
; 1773 :         buffer[0] = NULLC;
; 1774 :         /* write the codes from right to left */
; 1775 :         for ( i = unw_info.CountOfCodes; i ; i-- ) {

	test	dl, dl
	mov	QWORD PTR [rsp+224], rbx
	lea	r8, OFFSET FLAT:$SG6630
	movzx	ebx, dl
	mov	BYTE PTR buffer$[rsp], 0
	je	$LN24@WriteSEHDa
	lea	rax, OFFSET FLAT:unw_code
	mov	QWORD PTR [rsp+240], rsi
	lea	rsi, QWORD PTR [rax+rbx*2-2]
$LL10@WriteSEHDa:

; 1776 :             /* v2.11: use field FrameOffset */
; 1777 :             //sprintf( buffer + strlen( buffer ), "%s 0%xh", pfx, unw_code[i-1] );
; 1778 :             sprintf( buffer + strlen( buffer ), "%s 0%xh", pfx, unw_code[i-1].FrameOffset );

	movzx	r9d, WORD PTR [rsi]
	xor	eax, eax
	lea	rdi, QWORD PTR buffer$[rsp]
	mov	rcx, -1
	lea	rdx, OFFSET FLAT:$SG6634
	repne scasb
	not	rcx
	lea	rcx, QWORD PTR buffer$[rsp+rcx-1]
	call	sprintf

; 1779 :             pfx = ",";
; 1780 :             if ( i == 1 || strlen( buffer ) > 72 ) {

	cmp	rbx, 1
	lea	r8, OFFSET FLAT:$SG6635
	je	SHORT $LN6@WriteSEHDa
	xor	eax, eax
	lea	rdi, QWORD PTR buffer$[rsp]
	mov	rcx, -1
	repne scasb
	not	rcx
	dec	rcx
	cmp	rcx, 72					; 00000048H
	jbe	SHORT $LN9@WriteSEHDa
$LN6@WriteSEHDa:

; 1781 :                 AddLineQueue( buffer );

	lea	rcx, QWORD PTR buffer$[rsp]
	call	AddLineQueue

; 1782 :                 buffer[0] = NULLC;

	mov	BYTE PTR buffer$[rsp], 0

; 1783 :                 pfx = "dw";

	lea	r8, OFFSET FLAT:$SG6638
$LN9@WriteSEHDa:
	sub	rsi, 2
	dec	rbx
	jne	SHORT $LL10@WriteSEHDa
	mov	rsi, QWORD PTR [rsp+240]
$LN24@WriteSEHDa:
	mov	rbx, QWORD PTR [rsp+224]
$LN8@WriteSEHDa:

; 1784 :             }
; 1785 :         }
; 1786 :     }
; 1787 :     /* make sure the unwind codes array has an even number of entries */
; 1788 :     AddLineQueueX( "%r 4", T_ALIGN );

	lea	rcx, OFFSET FLAT:$SG6639
	mov	edx, 439				; 000001b7H
	call	AddLineQueueX

; 1789 : 
; 1790 :     if ( proc->e.procinfo->exc_handler ) {

	mov	rdx, QWORD PTR [rbp+104]
	mov	r8, QWORD PTR [rdx+88]
	test	r8, r8
	je	SHORT $LN5@WriteSEHDa

; 1791 :         AddLineQueueX( "dd %r %s", T_IMAGEREL, proc->e.procinfo->exc_handler->name );

	mov	r8, QWORD PTR [r8+8]
	lea	rcx, OFFSET FLAT:$SG6641
	mov	edx, 233				; 000000e9H
	call	AddLineQueueX

; 1792 :         AddLineQueueX( "%r 8", T_ALIGN );

	lea	rcx, OFFSET FLAT:$SG6642
	mov	edx, 439				; 000001b7H
	call	AddLineQueueX
$LN5@WriteSEHDa:

; 1793 :     }
; 1794 :     AddLineQueueX( "%s %r", segname, T_ENDS );

	lea	rdx, OFFSET FLAT:$SG6610
	lea	rcx, OFFSET FLAT:$SG6643
	mov	r8d, 442				; 000001baH
	call	AddLineQueueX

; 1795 : 
; 1796 :     /* v2.07: ensure that .pdata items are sorted */
; 1797 :     if ( 0 == strcmp( SimGetSegName( SIM_CODE ), proc->sym.segment->name ) ) {

	mov	rdi, QWORD PTR [rbp+32]
	xor	ecx, ecx
	call	SimGetSegName
	mov	rdi, QWORD PTR [rdi+8]
	sub	rdi, rax
	npad	1
$LL22@WriteSEHDa:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+rdi]
	sub	edx, ecx
	jne	SHORT $LN23@WriteSEHDa
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL22@WriteSEHDa
$LN23@WriteSEHDa:
	test	edx, edx
	jne	SHORT $LN4@WriteSEHDa

; 1798 :         segname = ".pdata";
; 1799 :         simplespec = ( unw_segs_defined & 1 );

	mov	al, BYTE PTR unw_segs_defined
	lea	rdi, OFFSET FLAT:$SG6645

; 1800 :         unw_segs_defined = 3;

	mov	BYTE PTR unw_segs_defined, 3
	and	eax, 1

; 1806 :     }
; 1807 : 
; 1808 :     if ( simplespec )

	test	eax, eax
	je	SHORT $LN2@WriteSEHDa

; 1809 :         AddLineQueueX( "%s %r", segname, T_SEGMENT );

	lea	rcx, OFFSET FLAT:$SG6649
	mov	r8d, 441				; 000001b9H
	mov	rdx, rdi
	call	AddLineQueueX

; 1810 :     else

	jmp	SHORT $LN1@WriteSEHDa
$LN4@WriteSEHDa:

; 1801 :     } else {
; 1802 :         segname = segnamebuff;
; 1803 :         sprintf( segname, ".pdata$%04u", GetSegIdx( proc->sym.segment ) );

	mov	rcx, QWORD PTR [rbp+32]
	lea	rdi, QWORD PTR segnamebuff$[rsp]
	call	GetSegIdx
	lea	rdx, OFFSET FLAT:$SG6647
	lea	rcx, QWORD PTR segnamebuff$[rsp]
	mov	r8d, eax
	call	sprintf

; 1804 :         simplespec = 0;
; 1805 :         unw_segs_defined |= 2;

	or	BYTE PTR unw_segs_defined, 2
$LN2@WriteSEHDa:

; 1811 :         AddLineQueueX( "%s %r align(%u) flat read 'DATA'", segname, T_SEGMENT, 4 );

	lea	rcx, OFFSET FLAT:$SG6651
	mov	r9d, 4
	mov	r8d, 441				; 000001b9H
	mov	rdx, rdi
	call	AddLineQueueX
$LN1@WriteSEHDa:

; 1812 :     /* write the .pdata stuff ( type IMAGE_RUNTIME_FUNCTION_ENTRY )*/
; 1813 :     AddLineQueueX( "dd %r %s, %r %s+0%xh, %r $xdatasym+0%xh",
; 1814 :                   T_IMAGEREL, proc->sym.name,
; 1815 :                   T_IMAGEREL, proc->sym.name, proc->sym.total_size,
; 1816 :                   T_IMAGEREL, xdataofs );

	mov	eax, DWORD PTR [rbp+64]
	mov	r8, QWORD PTR [rbp+8]
	mov	DWORD PTR [rsp+56], r12d
	mov	edx, 233				; 000000e9H
	mov	DWORD PTR [rsp+48], 233			; 000000e9H
	mov	DWORD PTR [rsp+40], eax
	lea	rcx, OFFSET FLAT:$SG6652
	mov	r9d, edx
	mov	QWORD PTR [rsp+32], r8
	call	AddLineQueueX

; 1817 :     AddLineQueueX("%s %r", segname, T_ENDS );

	lea	rcx, OFFSET FLAT:$SG6653
	mov	r8d, 442				; 000001baH
	mov	rdx, rdi
	call	AddLineQueueX

; 1818 :     olddotname = ModuleInfo.dotname;

	mov	edx, DWORD PTR ModuleInfo+408
	mov	edi, edx

; 1819 :     ModuleInfo.dotname = TRUE; /* set OPTION DOTNAME because .pdata and .xdata */

	or	edx, 32					; 00000020H
	shr	edi, 5
	mov	DWORD PTR ModuleInfo+408, edx
	and	dil, 1

; 1820 :     RunLineQueue();

	call	RunLineQueue

; 1821 :     ModuleInfo.dotname = olddotname;

	mov	eax, DWORD PTR ModuleInfo+408
	mov	r12, QWORD PTR [rsp+208]
	movzx	edx, dil
	mov	rdi, QWORD PTR [rsp+248]
	shl	edx, 5
	xor	edx, eax
	and	edx, 32					; 00000020H
	xor	eax, edx
	mov	DWORD PTR ModuleInfo+408, eax
$LN16@WriteSEHDa:
	mov	rbp, QWORD PTR [rsp+232]

; 1822 :     return;
; 1823 : }

	add	rsp, 216				; 000000d8H
	ret	0
WriteSEHData ENDP
_TEXT	ENDS
PUBLIC	ExcFrameDirective
EXTRN	EmitConstError:NEAR
xdata	SEGMENT
$unwind$ExcFrameDirective DD 061601H
	DD	014e416H
	DD	0177412H
	DD	019010eH
xdata	ENDS
pdata	SEGMENT
$pdata$ExcFrameDirective DD @imagerel($LN74#)
	DD	@imagerel($LN74#+155)
	DD	@imagerel($unwind$ExcFrameDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$6$ExcFrameDirective DD 0a3b21H
	DD	015d43bH
	DD	016c42bH
	DD	0186418H
	DD	01d5410H
	DD	01c3408H
	DD	@imagerel($LN74#)
	DD	@imagerel($LN74#+155)
	DD	@imagerel($unwind$ExcFrameDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$ExcFrameDirective DD @imagerel($LN74#+155)
	DD	@imagerel($LN74#+379)
	DD	@imagerel($chain$6$ExcFrameDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$7$ExcFrameDirective DD 021H
	DD	@imagerel($LN74#)
	DD	@imagerel($LN74#+155)
	DD	@imagerel($unwind$ExcFrameDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$ExcFrameDirective DD @imagerel($LN74#+379)
	DD	@imagerel($LN74#+403)
	DD	@imagerel($chain$7$ExcFrameDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$8$ExcFrameDirective DD 0a0021H
	DD	015d400H
	DD	016c400H
	DD	0186400H
	DD	01d5400H
	DD	01c3400H
	DD	@imagerel($LN74#)
	DD	@imagerel($LN74#+155)
	DD	@imagerel($unwind$ExcFrameDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$ExcFrameDirective DD @imagerel($LN74#+403)
	DD	@imagerel($LN74#+1742)
	DD	@imagerel($chain$8$ExcFrameDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$9$ExcFrameDirective DD 021H
	DD	@imagerel($LN74#)
	DD	@imagerel($LN74#+155)
	DD	@imagerel($unwind$ExcFrameDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$ExcFrameDirective DD @imagerel($LN74#+1742)
	DD	@imagerel($LN74#+1760)
	DD	@imagerel($chain$9$ExcFrameDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$10$ExcFrameDirective DD 0a0021H
	DD	015d400H
	DD	016c400H
	DD	0186400H
	DD	01d5400H
	DD	01c3400H
	DD	@imagerel($LN74#)
	DD	@imagerel($LN74#+155)
	DD	@imagerel($unwind$ExcFrameDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$10$ExcFrameDirective DD @imagerel($LN74#+1760)
	DD	@imagerel($LN74#+1792)
	DD	@imagerel($chain$10$ExcFrameDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
opndx$ = 48
i$ = 208
tokenarray$ = 216
ExcFrameDirective PROC NEAR

; 1948 : {

$LN74:
	mov	DWORD PTR [rsp+8], ecx
	mov	rax, rsp
	sub	rsp, 200				; 000000c8H
	mov	QWORD PTR [rax-16], rdi
	mov	QWORD PTR [rax-40], r14

; 1949 :     struct expr opndx;
; 1950 :     int token;
; 1951 :     unsigned int size;
; 1952 :     uint_8 oldcodes = unw_info.CountOfCodes;
; 1953 :     uint_8 reg;
; 1954 :     uint_8 ofs;
; 1955 :     UNWIND_CODE *puc;
; 1956 : 
; 1957 :     DebugMsg1(("ExcFrameDirective(%s) enter\n", tokenarray[i].string_ptr ));
; 1958 :     /* v2.05: accept directives for windows only */
; 1959 : 	if (Options.output_format != OFORMAT_COFF && Options.output_format != OFORMAT_ELF && Options.output_format != OFORMAT_BIN /* John Hankinson 2016-02-10 Added elf win64 hack */
; 1960 : #if PE_SUPPORT
; 1961 :         && ModuleInfo.sub_format != SFORMAT_PE
; 1962 : #endif
; 1963 :        ) {

	mov	eax, DWORD PTR Options+156
	cmp	eax, 2
	movzx	r14d, BYTE PTR unw_info+2
	mov	rdi, rdx
	je	SHORT $LN55@ExcFrameDi
	cmp	eax, 3
	je	SHORT $LN55@ExcFrameDi
	test	eax, eax
	je	SHORT $LN55@ExcFrameDi
	cmp	DWORD PTR ModuleInfo+372, 2
	je	SHORT $LN55@ExcFrameDi

; 1964 :         return( EmitErr( NOT_SUPPORTED_WITH_CURR_FORMAT, GetResWName( tokenarray[i].tokval, NULL ) ) );

	movsxd	rax, ecx
	xor	edx, edx
	shl	rax, 5
	mov	ecx, DWORD PTR [rax+rdi+16]
	call	GetResWName
	mov	ecx, 224				; 000000e0H
	mov	rdx, rax
	call	EmitErr
	jmp	$LN56@ExcFrameDi
$LN55@ExcFrameDi:

; 1965 :     }
; 1966 :     if ( CurrProc == NULL || endprolog_found == TRUE ) {

	mov	rax, QWORD PTR CurrProc
	test	rax, rax
	je	$LN53@ExcFrameDi
	cmp	BYTE PTR endprolog_found, 1
	je	$LN53@ExcFrameDi

; 1968 :     }
; 1969 :     if ( CurrProc->e.procinfo->isframe == FALSE ) {

	mov	rax, QWORD PTR [rax+104]
	test	BYTE PTR [rax+128], 64			; 00000040H
	jne	SHORT $LN52@ExcFrameDi

; 1970 :         return( EmitError( MISSING_FRAME_IN_PROC ) );

	mov	ecx, 256				; 00000100H
	call	EmitError
	jmp	$LN56@ExcFrameDi
$LN52@ExcFrameDi:
	mov	QWORD PTR [rsp+224], rbx
	mov	QWORD PTR [rsp+232], rbp
	mov	QWORD PTR [rsp+192], rsi

; 1971 :     }
; 1972 : 
; 1973 :     puc = &unw_code[unw_info.CountOfCodes];

	movzx	eax, r14b
	lea	rsi, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [rsp+176], r12
	lea	rbx, QWORD PTR unw_code[rsi+rax*2]
	mov	QWORD PTR [rsp+168], r13

; 1974 : 
; 1975 :     ofs = GetCurrOffset() - CurrProc->sym.offset;

	call	GetCurrOffset

; 1976 :     token = tokenarray[i].tokval;

	movsxd	r8, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR CurrProc
	mov	r13d, eax
	sub	r13b, BYTE PTR [rcx+16]
	mov	rcx, r8

; 1977 :     i++;

	inc	r8d
	shl	rcx, 5
	mov	r12d, DWORD PTR [rcx+rdi+16]
	mov	DWORD PTR i$[rsp], r8d

; 1978 : 
; 1979 :     /* note: since the codes will be written from "right to left",
; 1980 :      * the opcode item has to be written last!
; 1981 :      */
; 1982 : 
; 1983 :     switch ( token ) {

	lea	ecx, DWORD PTR [r12-414]
	cmp	ecx, 7
	ja	$LN63@ExcFrameDi
	movsxd	rcx, ecx
	mov	eax, DWORD PTR $LN60@ExcFrameDi[rsi+rcx*4]
	add	rax, rsi
	jmp	rax
$LN49@ExcFrameDi:

; 1984 :     case T_DOT_ALLOCSTACK: /* syntax: .ALLOCSTACK size */
; 1985 :         if ( ERROR == EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) )

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rdi
	mov	BYTE PTR [rsp+32], 0
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN48@ExcFrameDi
$LN69@ExcFrameDi:

; 1986 :             return( ERROR );

	mov	eax, -1
$LN68@ExcFrameDi:
	mov	r12, QWORD PTR [rsp+176]
	mov	rsi, QWORD PTR [rsp+192]
	mov	rbp, QWORD PTR [rsp+232]
	mov	rbx, QWORD PTR [rsp+224]
	mov	r13, QWORD PTR [rsp+168]
$LN56@ExcFrameDi:
	mov	r14, QWORD PTR [rsp+160]
	mov	rdi, QWORD PTR [rsp+184]

; 2218 : }

	add	rsp, 200				; 000000c8H
	ret	0
$LN48@ExcFrameDi:

; 1987 :         if ( opndx.kind == EXPR_ADDR && opndx.sym->state == SYM_UNDEFINED ) /* v2.11: allow forward references */

	mov	eax, DWORD PTR opndx$[rsp+60]
	cmp	eax, 1
	jne	SHORT $LN47@ExcFrameDi
	mov	rax, QWORD PTR opndx$[rsp+80]
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN58@ExcFrameDi
$LN45@ExcFrameDi:

; 1991 :         }
; 1992 :         /* v2.11: check added */
; 1993 :         if ( opndx.hvalue ) {

	cmp	DWORD PTR opndx$[rsp+4], 0
	je	SHORT $LN44@ExcFrameDi
$LN70@ExcFrameDi:

; 1994 :             return( EmitConstError( &opndx ) );

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError
	jmp	SHORT $LN68@ExcFrameDi
$LN47@ExcFrameDi:

; 1988 :              ;
; 1989 :         else if ( opndx.kind != EXPR_CONST ) {

	test	eax, eax
	je	SHORT $LN45@ExcFrameDi
$LN58@ExcFrameDi:

; 1990 :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	SHORT $LN68@ExcFrameDi
$LN44@ExcFrameDi:

; 1995 :         }
; 1996 :         if ( opndx.uvalue == 0 ) {

	mov	eax, DWORD PTR opndx$[rsp]
	test	eax, eax
	jne	SHORT $LN43@ExcFrameDi

; 1997 :             return( EmitError( NONZERO_VALUE_EXPECTED ) );

	mov	ecx, 258				; 00000102H
	call	EmitError
	jmp	$LN68@ExcFrameDi
$LN43@ExcFrameDi:

; 1998 :         }
; 1999 :         if ( opndx.value & 7 ) {

	test	al, 7
	je	SHORT $LN42@ExcFrameDi
$LN71@ExcFrameDi:

; 2000 :             return( EmitError( BAD_ALIGNMENT_FOR_OFFSET_IN_UNWIND_CODE ) );

	mov	ecx, 257				; 00000101H
	call	EmitError
	jmp	$LN68@ExcFrameDi
$LN42@ExcFrameDi:

; 2001 :         }
; 2002 :         //opndx.value -= 8; /* v2.11: subtract 8 only for UWOP_ALLOC_SMALL! */
; 2003 :         if ( opndx.uvalue > 16*8 ) {

	cmp	eax, 128				; 00000080H
	jbe	$LN41@ExcFrameDi

; 2004 :             if ( opndx.uvalue >= 65536*8 ) {

	cmp	eax, 524288				; 00080000H
	jb	SHORT $LN40@ExcFrameDi

; 2005 :                 /* allocation size 512k - 4G-8 */
; 2006 :                 /* v2.11: value is stored UNSCALED in 2 WORDs! */
; 2007 :                 puc->FrameOffset = ( opndx.uvalue >> 16 );
; 2008 :                 puc++;
; 2009 :                 puc->FrameOffset = opndx.uvalue & 0xFFFF;
; 2010 :                 puc++;
; 2011 :                 unw_info.CountOfCodes += 2;
; 2012 :                 puc->OpInfo = 1;
; 2013 :                 DebugMsg1(("ExcFrameDirective: UWOP_ALLOC_LARGE, operation info 1, size=%Xh\n", opndx.value ));
; 2014 :             } else {
; 2015 :                 /* allocation size 128+8 - 512k-8 */
; 2016 :                 puc->FrameOffset = ( opndx.uvalue >> 3 );
; 2017 :                 puc++;
; 2018 :                 unw_info.CountOfCodes++;
; 2019 :                 puc->OpInfo = 0;
; 2020 :                 DebugMsg1(("ExcFrameDirective: UWOP_ALLOC_LARGE, operation info 0, size=%Xh\n", opndx.value ));
; 2021 :             }
; 2022 :             puc->UnwindOp = UWOP_ALLOC_LARGE;
; 2023 :         } else {
; 2024 :             /* allocation size 8-128 bytes */
; 2025 :             puc->UnwindOp = UWOP_ALLOC_SMALL;
; 2026 :             /* v2.11: subtract 8 only for UWOP_ALLOC_SMALL! */
; 2027 :             //puc->OpInfo = ( opndx.value >> 3 );
; 2028 :             puc->OpInfo = ( (opndx.uvalue - 8 ) >> 3 );
; 2029 :             DebugMsg1(("ExcFrameDirective: UWOP_ALLOC_SMALL, size=%Xh\n", opndx.value ));
; 2030 :         }
; 2031 :         puc->CodeOffset = ofs;
; 2032 :         unw_info.CountOfCodes++;
; 2033 :         break;

	mov	r8d, DWORD PTR i$[rsp]
	add	rbx, 4
	shr	eax, 16
	mov	WORD PTR [rbx-4], ax
	movzx	eax, WORD PTR opndx$[rsp]
	mov	WORD PTR [rbx-2], ax
	and	BYTE PTR [rbx+1], 15
	or	BYTE PTR [rbx+1], 16
	and	BYTE PTR [rbx+1], 241			; 000000f1H
	movzx	eax, BYTE PTR unw_info+2
	or	BYTE PTR [rbx+1], 1
	add	al, 2
	mov	BYTE PTR [rbx], r13b
	inc	al
	mov	BYTE PTR unw_info+2, al
	jmp	$LN11@ExcFrameDi
$LN40@ExcFrameDi:
	mov	r8d, DWORD PTR i$[rsp]
	add	rbx, 2
	shr	eax, 3
	mov	WORD PTR [rbx-2], ax
	and	BYTE PTR [rbx+1], 15
	and	BYTE PTR [rbx+1], 241			; 000000f1H
	mov	al, BYTE PTR unw_info+2
	or	BYTE PTR [rbx+1], 1
	mov	BYTE PTR [rbx], r13b
	inc	al
	inc	al
	mov	BYTE PTR unw_info+2, al
	jmp	$LN11@ExcFrameDi
$LN41@ExcFrameDi:
	mov	r8d, DWORD PTR i$[rsp]
	add	eax, -8					; fffffff8H
	shr	eax, 3
	shl	al, 4
	or	al, 2
	mov	BYTE PTR [rbx+1], al
	mov	al, BYTE PTR unw_info+2
	mov	BYTE PTR [rbx], r13b
	inc	al
	mov	BYTE PTR unw_info+2, al
	jmp	$LN11@ExcFrameDi
$LN37@ExcFrameDi:

; 2034 :     case T_DOT_ENDPROLOG: /* syntax: .ENDPROLOG */
; 2035 :         opndx.value = GetCurrOffset() - CurrProc->sym.offset;

	call	GetCurrOffset
	mov	rcx, QWORD PTR CurrProc
	sub	eax, DWORD PTR [rcx+16]

; 2036 :         if ( opndx.uvalue > 255 ) {

	cmp	eax, 255				; 000000ffH
	mov	DWORD PTR opndx$[rsp], eax
	jbe	SHORT $LN36@ExcFrameDi

; 2037 :             return( EmitError( SIZE_OF_PROLOG_TOO_BIG ) );

	mov	ecx, 259				; 00000103H
	call	EmitError
	jmp	$LN68@ExcFrameDi
$LN36@ExcFrameDi:

; 2038 :         }
; 2039 :         unw_info.SizeOfProlog = (uint_8)opndx.uvalue;

	movzx	eax, BYTE PTR opndx$[rsp]

; 2040 :         endprolog_found = TRUE;
; 2041 :         break;

	mov	r8d, DWORD PTR i$[rsp]
	mov	BYTE PTR endprolog_found, 1
	mov	BYTE PTR unw_info+1, al
	mov	al, BYTE PTR unw_info+2
	jmp	$LN11@ExcFrameDi
$LN35@ExcFrameDi:

; 2042 :     case T_DOT_PUSHFRAME: /* syntax: .PUSHFRAME [code] */
; 2043 :         puc->CodeOffset = ofs;
; 2044 :         puc->UnwindOp = UWOP_PUSH_MACHFRAME;
; 2045 :         puc->OpInfo = 0;
; 2046 :         if ( tokenarray[i].token == T_ID && (_stricmp( tokenarray[i].string_ptr, "CODE") == 0 ) ) {

	movsxd	rcx, r8d
	mov	BYTE PTR [rbx], r13b
	mov	BYTE PTR [rbx+1], 10
	shl	rcx, 5
	cmp	BYTE PTR [rcx+rdi], 8
	jne	SHORT $LN34@ExcFrameDi
	mov	rcx, QWORD PTR [rcx+rdi+8]
	lea	rdx, OFFSET FLAT:$SG6745
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN61@ExcFrameDi

; 2047 :             puc->OpInfo = 1;
; 2048 :             i++;

	mov	r8d, DWORD PTR i$[rsp]

; 2049 :         }
; 2050 :         unw_info.CountOfCodes++;

	mov	al, BYTE PTR unw_info+2
	and	BYTE PTR [rbx+1], 15
	or	BYTE PTR [rbx+1], 16
	inc	r8d
	inc	al
	mov	BYTE PTR unw_info+2, al
	mov	DWORD PTR i$[rsp], r8d

; 2051 :         break;

	jmp	$LN11@ExcFrameDi
$LN61@ExcFrameDi:

; 2047 :             puc->OpInfo = 1;
; 2048 :             i++;

	mov	r8d, DWORD PTR i$[rsp]
$LN34@ExcFrameDi:

; 2049 :         }
; 2050 :         unw_info.CountOfCodes++;

	mov	al, BYTE PTR unw_info+2
	inc	al
	mov	BYTE PTR unw_info+2, al

; 2051 :         break;

	jmp	$LN11@ExcFrameDi
$LN33@ExcFrameDi:

; 2052 :     case T_DOT_PUSHREG: /* syntax: .PUSHREG r64 */
; 2053 :         if ( tokenarray[i].token != T_REG || !( GetValueSp( tokenarray[i].tokval ) & OP_R64 ) ) {

	movsxd	r9, r8d
	shl	r9, 5
	cmp	BYTE PTR [r9+rdi], 2
	jne	SHORT $LN31@ExcFrameDi
	mov	eax, DWORD PTR [r9+rdi+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	test	BYTE PTR SpecialTable[rsi+rcx*4], 8
	je	SHORT $LN31@ExcFrameDi

; 2055 :         }
; 2056 :         puc->CodeOffset = ofs;
; 2057 :         puc->UnwindOp = UWOP_PUSH_NONVOL;

	and	BYTE PTR [rbx+1], 240			; 000000f0H
	movzx	edx, BYTE PTR [rbx+1]
	mov	BYTE PTR [rbx], r13b

; 2058 :         puc->OpInfo = GetRegNo( tokenarray[i].tokval );

	mov	eax, DWORD PTR [r9+rdi+16]
	and	dl, 15
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR SpecialTable[rsi+rcx*4+10]
	shl	al, 4
	or	al, dl
	mov	BYTE PTR [rbx+1], al

; 2059 :         unw_info.CountOfCodes++;

	mov	al, BYTE PTR unw_info+2
	inc	al

; 2060 :         i++;

	inc	r8d
	mov	DWORD PTR i$[rsp], r8d
	mov	BYTE PTR unw_info+2, al

; 2061 :         break;

	jmp	$LN11@ExcFrameDi
$LN31@ExcFrameDi:

; 2054 :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [r9+rdi+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN68@ExcFrameDi
$LN30@ExcFrameDi:

; 2062 :     case T_DOT_SAVEREG:    /* syntax: .SAVEREG r64, offset       */
; 2063 :     case T_DOT_SAVEXMM128: /* syntax: .SAVEXMM128 xmmreg, offset */
; 2064 :     case T_DOT_SAVEYMM256: /* syntax: .SAVEYMM256 ymmreg, offset */
; 2065 : #if EVEXSUPP
; 2066 :     case T_DOT_SAVEZMM512: /* syntax: .SAVEXMM512 zmmreg, offset */
; 2067 : #endif
; 2068 :     case T_DOT_SETFRAME:   /* syntax: .SETFRAME r64, offset      */
; 2069 :         if ( tokenarray[i].token != T_REG ) {

	movsxd	rdx, r8d
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rdi], 2

; 2070 :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	jne	SHORT $LN72@ExcFrameDi

; 2071 :         }
; 2072 :         if ( token == T_DOT_SAVEXMM128 ) {

	cmp	r12d, 419				; 000001a3H
	jne	SHORT $LN28@ExcFrameDi

; 2073 :             if ( !( GetValueSp( tokenarray[i].tokval ) & OP_XMM ) ) {

	mov	eax, DWORD PTR [rdx+rdi+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	shl	rcx, 2
	test	BYTE PTR SpecialTable[rcx+rsi], 32	; 00000020H
$LN73@ExcFrameDi:
	jne	SHORT $LN22@ExcFrameDi
$LN72@ExcFrameDi:

; 2074 :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+rdi+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN68@ExcFrameDi
$LN28@ExcFrameDi:

; 2075 :             }
; 2076 :         } 
; 2077 :         else if (token == T_DOT_SAVEYMM256) {

	cmp	r12d, 420				; 000001a4H
	jne	SHORT $LN25@ExcFrameDi

; 2078 :           if (!(GetValueSp(tokenarray[i].tokval) & OP_YMM)) {

	mov	eax, DWORD PTR [rdx+rdi+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	shl	rcx, 2
	test	BYTE PTR SpecialTable[rcx+rsi], 128	; 00000080H

; 2079 :             return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].string_ptr));

	jmp	SHORT $LN73@ExcFrameDi
$LN25@ExcFrameDi:

; 2080 :           }
; 2081 :         }
; 2082 : #if EVEXSUPP
; 2083 :         else if (token == T_DOT_SAVEZMM512) {
; 2084 :           if (!(GetValueSp(tokenarray[i].tokval) & OP_ZMM)) {
; 2085 :             return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].string_ptr));
; 2086 :           }
; 2087 :         }
; 2088 : #endif
; 2089 :         else {
; 2090 :             if ( !( GetValueSp( tokenarray[i].tokval ) & OP_R64 ) ) {

	mov	eax, DWORD PTR [rdx+rdi+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	shl	rcx, 2
	test	BYTE PTR SpecialTable[rcx+rsi], 8

; 2091 :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	jmp	SHORT $LN73@ExcFrameDi
$LN22@ExcFrameDi:

; 2092 :             }
; 2093 :         }
; 2094 :         reg = GetRegNo( tokenarray[i].tokval );
; 2095 :         // here is the problem
; 2096 :         if ( token == T_DOT_SAVEREG || token == T_DOT_SAVEXMM128 || token == T_DOT_SAVEYMM256
; 2097 : #if EVEXSUPP
; 2098 :           || token == T_DOT_SAVEZMM512
; 2099 : #endif   
; 2100 :           )

	cmp	r12d, 418				; 000001a2H
	movzx	ebp, BYTE PTR SpecialTable[rcx+rsi+10]
	je	SHORT $LN20@ExcFrameDi
	cmp	r12d, 419				; 000001a3H
	je	SHORT $LN20@ExcFrameDi
	cmp	r12d, 420				; 000001a4H
	je	SHORT $LN20@ExcFrameDi

; 2102 :         else
; 2103 :             size = 16;

	mov	esi, 16
	jmp	SHORT $LN19@ExcFrameDi
$LN20@ExcFrameDi:

; 2101 :             size = 8;

	mov	esi, 8
$LN19@ExcFrameDi:

; 2104 : 
; 2105 :         i++;

	inc	r8d

; 2106 :         if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rdx, r8d
	mov	DWORD PTR i$[rsp], r8d
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rdi], 44			; 0000002cH

; 2107 :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	jne	$LN72@ExcFrameDi

; 2108 :         }
; 2109 :         i++;

	inc	r8d

; 2110 :         if ( ERROR == EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) )

	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	DWORD PTR i$[rsp], r8d
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, rdi
	mov	BYTE PTR [rsp+32], 0
	call	EvalOperand
	cmp	eax, -1

; 2111 :             return( ERROR );

	je	$LN69@ExcFrameDi

; 2112 :         if ( opndx.kind == EXPR_ADDR && opndx.sym->state == SYM_UNDEFINED ) /* v2.11: allow forward references */

	mov	eax, DWORD PTR opndx$[rsp+60]
	cmp	eax, 1
	jne	SHORT $LN16@ExcFrameDi
	mov	rax, QWORD PTR opndx$[rsp+80]
	cmp	DWORD PTR [rax+40], 0
	je	SHORT $LN14@ExcFrameDi
	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	$LN68@ExcFrameDi
$LN16@ExcFrameDi:

; 2113 :              ;
; 2114 :         else if ( opndx.kind != EXPR_CONST ) {

	test	eax, eax

; 2115 :             return( EmitError( CONSTANT_EXPECTED ) );

	jne	$LN58@ExcFrameDi
$LN14@ExcFrameDi:

; 2116 :         }
; 2117 :         if ( opndx.value & (size - 1) ) {

	mov	ecx, DWORD PTR opndx$[rsp]
	lea	eax, DWORD PTR [rsi-1]
	test	eax, ecx

; 2118 :             return( EmitError( BAD_ALIGNMENT_FOR_OFFSET_IN_UNWIND_CODE ) );

	jne	$LN71@ExcFrameDi

; 2119 :         }
; 2120 :         switch ( token ) {

	cmp	r12d, 418				; 000001a2H
	je	$LN10@ExcFrameDi
	cmp	r12d, 418				; 000001a2H
	jle	$LN62@ExcFrameDi
	cmp	r12d, 420				; 000001a4H
	jle	SHORT $LN7@ExcFrameDi
	cmp	r12d, 421				; 000001a5H
	jne	$LN62@ExcFrameDi

; 2157 :         //case T_DOT_SAVEYMM256:
; 2158 :         //    if ( opndx.value > 65536 * size ) {
; 2159 :         //        puc->FrameOffset = ( opndx.value >> 20 );
; 2160 :         //        puc++;
; 2161 :         //        puc->FrameOffset = ( opndx.value >> 4 );
; 2162 :         //        puc++;
; 2163 :         //        puc->UnwindOp = UWOP_SAVE_YMM256_FAR;
; 2164 :         //        unw_info.CountOfCodes += 3;
; 2165 :         //    } else {
; 2166 :         //        puc->FrameOffset = ( opndx.value >> 4 );
; 2167 :         //        puc++;
; 2168 :         //        puc->UnwindOp = UWOP_SAVE_YMM256;
; 2169 :         //        unw_info.CountOfCodes += 2;
; 2170 :         //    }
; 2171 :         //    puc->CodeOffset = ofs;
; 2172 :         //    puc->OpInfo = reg;
; 2173 :         //    break;
; 2174 : #if EVEXSUPP
; 2175 :         case T_DOT_SAVEZMM512:
; 2176 :             if ( opndx.value > 65536 * size ) {
; 2177 :                 puc->FrameOffset = ( opndx.value >> 20 );
; 2178 :                 puc++;
; 2179 :                 puc->FrameOffset = ( opndx.value >> 4 );
; 2180 :                 puc++;
; 2181 :                 puc->UnwindOp = UWOP_SAVE_ZMM512_FAR;
; 2182 :                 unw_info.CountOfCodes += 3;
; 2183 :             } else {
; 2184 :                 puc->FrameOffset = ( opndx.value >> 4 );
; 2185 :                 puc++;
; 2186 :                 puc->UnwindOp = UWOP_SAVE_ZMM512;
; 2187 :                 unw_info.CountOfCodes += 2;
; 2188 :             }
; 2189 :             puc->CodeOffset = ofs;
; 2190 :             puc->OpInfo = reg;
; 2191 :             break;
; 2192 : #endif
; 2193 : 
; 2194 :         case T_DOT_SETFRAME:
; 2195 :             if ( opndx.uvalue > 240 ) {

	cmp	ecx, 240				; 000000f0H

; 2196 :                 return( EmitConstError( &opndx ) );

	ja	$LN70@ExcFrameDi

; 2197 :             }
; 2198 :             unw_info.FrameRegister = reg;
; 2199 :             unw_info.FrameOffset = ( opndx.uvalue >> 4 );
; 2200 :             puc->CodeOffset = ofs;
; 2201 :             puc->UnwindOp = UWOP_SET_FPREG;
; 2202 :             //puc->OpInfo = ( opndx.uvalue >> 4 );
; 2203 :             puc->OpInfo = reg;
; 2204 :             unw_info.CountOfCodes++;
; 2205 :             break;

	mov	r8d, DWORD PTR i$[rsp]
	movzx	eax, bpl
	and	cl, 240					; 000000f0H
	and	al, 15
	shl	bpl, 4
	mov	BYTE PTR [rbx], r13b
	or	cl, al
	mov	al, BYTE PTR unw_info+2
	or	bpl, 3
	inc	al
	mov	BYTE PTR unw_info+3, cl
	mov	BYTE PTR [rbx+1], bpl
	mov	BYTE PTR unw_info+2, al
	jmp	$LN11@ExcFrameDi
$LN7@ExcFrameDi:

; 2138 :             break;
; 2139 :         case T_DOT_SAVEXMM128:
; 2140 :         case T_DOT_SAVEYMM256:
; 2141 :             if ( opndx.value > 65536 * size ) {

	shl	esi, 16
	cmp	ecx, esi
	jbe	SHORT $LN6@ExcFrameDi

; 2142 :                 puc->FrameOffset = ( opndx.value >> 20 );
; 2143 :                 puc++;
; 2144 :                 puc->FrameOffset = ( opndx.value >> 4 );
; 2145 :                 puc++;

	add	rbx, 4
	mov	eax, ecx
	sar	ecx, 4
	sar	eax, 20
	mov	WORD PTR [rbx-4], ax

; 2146 :                 puc->UnwindOp = UWOP_SAVE_XMM128_FAR;
; 2147 :                 unw_info.CountOfCodes += 3;

	mov	al, BYTE PTR unw_info+2
	mov	WORD PTR [rbx-2], cx
	and	BYTE PTR [rbx+1], 249			; 000000f9H
	or	BYTE PTR [rbx+1], 9
	add	al, 3
	mov	BYTE PTR unw_info+2, al

; 2148 :             } else {

	jmp	SHORT $LN5@ExcFrameDi
$LN6@ExcFrameDi:

; 2149 :                 puc->FrameOffset = ( opndx.value >> 4 );
; 2150 :                 puc++;
; 2151 :                 puc->UnwindOp = UWOP_SAVE_XMM128;
; 2152 :                 unw_info.CountOfCodes += 2;

	mov	al, BYTE PTR unw_info+2
	add	rbx, 2
	sar	ecx, 4
	mov	WORD PTR [rbx-2], cx
	and	BYTE PTR [rbx+1], 248			; 000000f8H
	or	BYTE PTR [rbx+1], 8
	add	al, 2
	mov	BYTE PTR unw_info+2, al
$LN5@ExcFrameDi:

; 2153 :             }
; 2154 :             puc->CodeOffset = ofs;
; 2155 :             puc->OpInfo = reg;

	and	BYTE PTR [rbx+1], 15

; 2156 :             break;

	mov	r8d, DWORD PTR i$[rsp]
	shl	bpl, 4
	or	BYTE PTR [rbx+1], bpl
	mov	BYTE PTR [rbx], r13b
	jmp	$LN11@ExcFrameDi
$LN10@ExcFrameDi:

; 2121 :         case T_DOT_SAVEREG:
; 2122 :             puc->OpInfo = reg;

	and	BYTE PTR [rbx+1], 15
	shl	bpl, 4

; 2123 :             if ( opndx.value > 65536 * size ) {

	shl	esi, 16
	or	BYTE PTR [rbx+1], bpl
	cmp	ecx, esi
	jbe	SHORT $LN9@ExcFrameDi

; 2135 :             }
; 2136 :             puc->CodeOffset = ofs;
; 2137 :             puc->OpInfo = reg;

	mov	r8d, DWORD PTR i$[rsp]
	add	rbx, 4
	mov	eax, ecx
	sar	eax, 19
	sar	ecx, 3
	mov	WORD PTR [rbx-4], ax
	mov	al, BYTE PTR unw_info+2
	mov	WORD PTR [rbx-2], cx
	and	BYTE PTR [rbx+1], 245			; 000000f5H
	or	BYTE PTR [rbx+1], 5
	and	BYTE PTR [rbx+1], 15
	add	al, 3
	or	BYTE PTR [rbx+1], bpl
	mov	BYTE PTR [rbx], r13b
	mov	BYTE PTR unw_info+2, al
	jmp	SHORT $LN11@ExcFrameDi
$LN9@ExcFrameDi:

; 2124 :                 puc->FrameOffset = ( opndx.value >> 19 );
; 2125 :                 puc++;
; 2126 :                 puc->FrameOffset = ( opndx.value >> 3 );
; 2127 :                 puc++;
; 2128 :                 puc->UnwindOp = UWOP_SAVE_NONVOL_FAR;
; 2129 :                 unw_info.CountOfCodes += 3;
; 2130 :             } else {
; 2131 :                 puc->FrameOffset = ( opndx.value >> 3 );
; 2132 :                 puc++;
; 2133 :                 puc->UnwindOp = UWOP_SAVE_NONVOL;
; 2134 :                 unw_info.CountOfCodes += 2;

	mov	al, BYTE PTR unw_info+2

; 2135 :             }
; 2136 :             puc->CodeOffset = ofs;
; 2137 :             puc->OpInfo = reg;

	mov	r8d, DWORD PTR i$[rsp]
	add	rbx, 2
	sar	ecx, 3
	add	al, 2
	mov	WORD PTR [rbx-2], cx
	and	BYTE PTR [rbx+1], 244			; 000000f4H
	or	BYTE PTR [rbx+1], 4
	and	BYTE PTR [rbx+1], 15
	or	BYTE PTR [rbx+1], bpl
	mov	BYTE PTR unw_info+2, al
	mov	BYTE PTR [rbx], r13b
	jmp	SHORT $LN11@ExcFrameDi
$LN62@ExcFrameDi:

; 2197 :             }
; 2198 :             unw_info.FrameRegister = reg;
; 2199 :             unw_info.FrameOffset = ( opndx.uvalue >> 4 );
; 2200 :             puc->CodeOffset = ofs;
; 2201 :             puc->UnwindOp = UWOP_SET_FPREG;
; 2202 :             //puc->OpInfo = ( opndx.uvalue >> 4 );
; 2203 :             puc->OpInfo = reg;
; 2204 :             unw_info.CountOfCodes++;
; 2205 :             break;

	mov	r8d, DWORD PTR i$[rsp]
	mov	al, BYTE PTR unw_info+2
	jmp	SHORT $LN11@ExcFrameDi
$LN63@ExcFrameDi:

; 2040 :         endprolog_found = TRUE;
; 2041 :         break;

	mov	al, BYTE PTR unw_info+2
$LN11@ExcFrameDi:

; 2206 :         }
; 2207 :         break;
; 2208 :     }
; 2209 :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, r8d
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rdi], 0

; 2210 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	jne	$LN72@ExcFrameDi

; 2211 :     }
; 2212 :     /* v2.11: check if the table of codes has been exceeded */
; 2213 :     if ( oldcodes > unw_info.CountOfCodes ) {

	cmp	r14b, al
	jbe	SHORT $LN1@ExcFrameDi

; 2214 :         return( EmitErr( TOO_MANY_UNWIND_CODES_IN_FRAME_PROC ) );

	mov	ecx, 210				; 000000d2H
	call	EmitErr
	jmp	$LN68@ExcFrameDi
$LN1@ExcFrameDi:

; 2215 :     }
; 2216 :     DebugMsg1(("ExcFrameDirective() exit, ok\n" ));
; 2217 :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN68@ExcFrameDi
$LN53@ExcFrameDi:

; 1967 :         return( EmitError( ENDPROLOG_FOUND_BEFORE_EH_DIRECTIVES ) );

	mov	ecx, 255				; 000000ffH
	call	EmitError
	jmp	$LN56@ExcFrameDi
	npad	3
$LN60@ExcFrameDi:

; 2218 : }

	DD	$LN49@ExcFrameDi
	DD	$LN37@ExcFrameDi
	DD	$LN35@ExcFrameDi
	DD	$LN33@ExcFrameDi
	DD	$LN30@ExcFrameDi
	DD	$LN30@ExcFrameDi
	DD	$LN30@ExcFrameDi
	DD	$LN30@ExcFrameDi
ExcFrameDirective ENDP
_TEXT	ENDS
EXTRN	atoi:NEAR
EXTRN	RunMacro:NEAR
EXTRN	printf:NEAR
EXTRN	UseSavedState:BYTE
xdata	SEGMENT
$unwind$write_userdef_prologue DD 062001H
	DD	09bf420H
	DD	09ec41cH
	DD	09f010aH
xdata	ENDS
pdata	SEGMENT
$pdata$write_userdef_prologue DD @imagerel(write_userdef_prologue#)
	DD	@imagerel(write_userdef_prologue#+59)
	DD	@imagerel($unwind$write_userdef_prologue#)
pdata	ENDS
xdata	SEGMENT
$chain$4$write_userdef_prologue DD 064b21H
	DD	09ce44bH
	DD	09dd415H
	DD	0a37408H
	DD	@imagerel(write_userdef_prologue#)
	DD	@imagerel(write_userdef_prologue#+59)
	DD	@imagerel($unwind$write_userdef_prologue#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$write_userdef_prologue DD @imagerel(write_userdef_prologue#+59)
	DD	@imagerel(write_userdef_prologue#+236)
	DD	@imagerel($chain$4$write_userdef_prologue#)
pdata	ENDS
xdata	SEGMENT
$chain$6$write_userdef_prologue DD 041021H
	DD	0a15410H
	DD	0a03408H
	DD	@imagerel(write_userdef_prologue#+59)
	DD	@imagerel(write_userdef_prologue#+236)
	DD	@imagerel($chain$4$write_userdef_prologue#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$write_userdef_prologue DD @imagerel(write_userdef_prologue#+236)
	DD	@imagerel(write_userdef_prologue#+266)
	DD	@imagerel($chain$6$write_userdef_prologue#)
pdata	ENDS
xdata	SEGMENT
$chain$7$write_userdef_prologue DD 020821H
	DD	0a26408H
	DD	@imagerel(write_userdef_prologue#+236)
	DD	@imagerel(write_userdef_prologue#+266)
	DD	@imagerel($chain$6$write_userdef_prologue#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$write_userdef_prologue DD @imagerel(write_userdef_prologue#+266)
	DD	@imagerel(write_userdef_prologue#+350)
	DD	@imagerel($chain$7$write_userdef_prologue#)
pdata	ENDS
xdata	SEGMENT
$chain$8$write_userdef_prologue DD 021H
	DD	@imagerel(write_userdef_prologue#+236)
	DD	@imagerel(write_userdef_prologue#+266)
	DD	@imagerel($chain$6$write_userdef_prologue#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$write_userdef_prologue DD @imagerel(write_userdef_prologue#+350)
	DD	@imagerel(write_userdef_prologue#+544)
	DD	@imagerel($chain$8$write_userdef_prologue#)
pdata	ENDS
xdata	SEGMENT
$chain$9$write_userdef_prologue DD 021H
	DD	@imagerel(write_userdef_prologue#+59)
	DD	@imagerel(write_userdef_prologue#+236)
	DD	@imagerel($chain$4$write_userdef_prologue#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$write_userdef_prologue DD @imagerel(write_userdef_prologue#+544)
	DD	@imagerel(write_userdef_prologue#+626)
	DD	@imagerel($chain$9$write_userdef_prologue#)
pdata	ENDS
xdata	SEGMENT
$chain$10$write_userdef_prologue DD 021H
	DD	@imagerel(write_userdef_prologue#)
	DD	@imagerel(write_userdef_prologue#+59)
	DD	@imagerel($unwind$write_userdef_prologue#)
xdata	ENDS
pdata	SEGMENT
$pdata$10$write_userdef_prologue DD @imagerel(write_userdef_prologue#+626)
	DD	@imagerel(write_userdef_prologue#+650)
	DD	@imagerel($chain$10$write_userdef_prologue#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
is_exitm$ = 64
reglst$ = 80
buffer$ = 208
tokenarray$ = 1280
write_userdef_prologue PROC NEAR

; 2236 : {

	mov	rax, rsp
	sub	rsp, 1272				; 000004f8H

; 2237 :     int                 len;
; 2238 :     int                 i;
; 2239 :     struct proc_info    *info;
; 2240 :     char                *p;
; 2241 :     bool                is_exitm;
; 2242 :     struct dsym         *dir;
; 2243 :     //int                 align = CurrWordSize;
; 2244 :     int                 flags = CurrProc->sym.langtype; /* set bits 0-2 */
; 2245 :     uint_16             *regs;
; 2246 :     char                reglst[128];
; 2247 :     char                buffer[MAX_LINE_LEN];
; 2248 : 	struct asym         *cline;
; 2249 : 	int                 curline;
; 2250 : 
; 2251 : #if FASTPASS
; 2252 :     if ( Parse_Pass > PASS_1 && UseSavedState )

	cmp	DWORD PTR Parse_Pass, 0
	mov	rdx, QWORD PTR CurrProc
	mov	QWORD PTR [rax-8], r12
	mov	QWORD PTR [rax-32], r15
	mov	eax, DWORD PTR [rdx+84]
	mov	r15, rcx
	mov	r12d, eax
	jbe	SHORT $LN16@write_user
	cmp	BYTE PTR UseSavedState, 0
	je	SHORT $LN16@write_user

; 2253 :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN17@write_user
$LN16@write_user:
	mov	QWORD PTR [rsp+1304], rdi

; 2254 : #endif
; 2255 : 
; 2256 :     info = CurrProc->e.procinfo;
; 2257 :     /* v2.11: now done in write_prologue() */
; 2258 :     //info->localsize = ROUND_UP( info->localsize, CurrWordSize );
; 2259 : #if AMD64_SUPPORT
; 2260 :     /* to be compatible with ML64, translate FASTCALL to 0 (not 7) */
; 2261 :     if ( CurrProc->sym.langtype == LANG_FASTCALL && ModuleInfo.fctype == FCT_WIN64 )

	xor	edi, edi
	cmp	eax, 7
	mov	QWORD PTR [rsp+1256], r13
	mov	r13, QWORD PTR [rdx+104]
	jne	SHORT $LN15@write_user
	cmp	DWORD PTR ModuleInfo+376, 2
	cmove	r12d, edi
$LN15@write_user:

; 2262 :         flags = 0;
; 2263 : #endif
; 2264 :     /* set bit 4 if the caller restores (E)SP */
; 2265 :     if ( CurrProc->sym.langtype == LANG_C ||
; 2266 :         CurrProc->sym.langtype == LANG_SYSCALL ||
; 2267 :         CurrProc->sym.langtype == LANG_FASTCALL )

	cmp	eax, 1
	je	SHORT $LN13@write_user
	cmp	eax, 2
	je	SHORT $LN13@write_user
	cmp	eax, 7
	jne	SHORT $LN14@write_user
$LN13@write_user:

; 2268 :         flags |= 0x10;

	or	r12d, 16
$LN14@write_user:

; 2269 : 
; 2270 :     /* set bit 5 if proc is far */
; 2271 :     /* set bit 6 if proc is private */
; 2272 :     /* v2.11: set bit 7 if proc is export */
; 2273 :     flags |= ( CurrProc->sym.mem_type == MT_FAR ? 0x20 : 0 );
; 2274 :     flags |= ( CurrProc->sym.ispublic ? 0 : 0x40 );
; 2275 :     flags |= ( info->isexport ? 0x80 : 0 );

	mov	cl, BYTE PTR [rdx+48]
	mov	al, BYTE PTR [r13+128]
	mov	QWORD PTR [rsp+1248], r14
	not	cl
	and	eax, 4
	shr	ecx, 1
	shl	eax, 5
	and	ecx, 64					; 00000040H
	or	ecx, eax
	cmp	DWORD PTR [rdx+44], 130			; 00000082H
	mov	eax, edi
	mov	edi, 32					; 00000020H
	cmove	eax, edi
	or	ecx, eax
	or	r12d, ecx

; 2276 : 
; 2277 :     dir = (struct dsym *)SymSearch( ModuleInfo.proc_prologue );

	mov	rcx, QWORD PTR ModuleInfo+320
	call	SymFind

; 2278 :     if ( dir == NULL || dir->sym.state != SYM_MACRO || dir->sym.isfunc != TRUE ) {

	test	rax, rax
	mov	r14, rax
	je	$LN11@write_user
	cmp	DWORD PTR [rax+40], 9
	jne	$LN11@write_user
	test	BYTE PTR [rax+52], 2
	je	$LN11@write_user

; 2280 :     }
; 2281 : 
; 2282 :     /* if -EP is on, emit "prologue: none" */
; 2283 :     if ( Options.preprocessor_stdout )

	cmp	BYTE PTR Options+134, 0
	je	SHORT $LN10@write_user

; 2284 :         printf( "option prologue:none\n" );

	lea	rcx, OFFSET FLAT:$SG6812
	call	printf
$LN10@write_user:
	mov	QWORD PTR [rsp+1280], rbx
	mov	QWORD PTR [rsp+1288], rbp

; 2285 : 
; 2286 :     p = reglst;
; 2287 :     if ( info->regslist ) {

	mov	rbp, QWORD PTR [r13]
	test	rbp, rbp
	lea	rbx, QWORD PTR reglst$[rsp]
	je	SHORT $LN6@write_user
	mov	QWORD PTR [rsp+1296], rsi

; 2288 :         regs = info->regslist;
; 2289 :         for ( len = *regs++; len; len--, regs++ ) {

	movzx	esi, WORD PTR [rbp]
	add	rbp, 2
	test	esi, esi
	je	SHORT $LN28@write_user
	npad	2
$LL8@write_user:

; 2290 :             GetResWName( *regs, p );

	movzx	ecx, WORD PTR [rbp]
	mov	rdx, rbx
	call	GetResWName

; 2291 :             p += strlen( p );

	xor	eax, eax
	mov	rdi, rbx
	mov	rcx, -1
	repne scasb
	not	rcx
	dec	rcx
	add	rbx, rcx

; 2292 :             if ( len > 1 )

	cmp	esi, 1
	jle	SHORT $LN7@write_user

; 2293 :                 *p++ = ',';

	mov	BYTE PTR [rbx], 44			; 0000002cH
	inc	rbx
$LN7@write_user:
	add	rbp, 2
	dec	esi
	jne	SHORT $LL8@write_user
$LN28@write_user:
	mov	rsi, QWORD PTR [rsp+1296]
$LN6@write_user:

; 2294 :         }
; 2295 :     }
; 2296 :     *p = NULLC;

	mov	BYTE PTR [rbx], 0

; 2297 : 
; 2298 :     /* v2.07: make this work with radix != 10 */
; 2299 :     /* leave a space at pos 0 of buffer, because the buffer is used for
; 2300 :      * both macro arguments and EXITM return value.
; 2301 :      */
; 2302 :     sprintf( buffer," (%s, 0%XH, 0%XH, 0%XH, <<%s>>, <%s>)",
; 2303 :              CurrProc->sym.name, flags, info->parasize, info->localsize,
; 2304 :             reglst, info->prologuearg ? info->prologuearg : "" );

	mov	rax, QWORD PTR [r13+48]
	mov	r8, QWORD PTR CurrProc
	mov	r8, QWORD PTR [r8+8]
	test	rax, rax
	lea	rcx, OFFSET FLAT:$SG6818
	cmovne	rcx, rax
	lea	rax, QWORD PTR reglst$[rsp]
	lea	rdx, OFFSET FLAT:$SG6819
	mov	QWORD PTR [rsp+56], rcx
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR [r13+36]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR [r13+32]
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	r9d, r12d
	mov	DWORD PTR [rsp+32], eax
	call	sprintf

; 2305 :     i = Token_Count + 1;

	mov	edi, DWORD PTR ModuleInfo+496

; 2306 :     Token_Count = Tokenize( buffer, i, tokenarray, TOK_RESCAN );

	lea	rcx, QWORD PTR buffer$[rsp]
	lea	edx, DWORD PTR [rdi+1]
	mov	r9d, 1
	mov	r8, r15
	call	Tokenize

; 2307 : 
; 2308 :     RunMacro( dir, i, tokenarray, buffer, 0, &is_exitm );

	lea	r9, QWORD PTR buffer$[rsp]
	lea	edx, DWORD PTR [rdi+1]
	mov	DWORD PTR ModuleInfo+496, eax
	lea	rax, QWORD PTR is_exitm$[rsp]
	mov	r8, r15
	mov	QWORD PTR [rsp+40], rax
	mov	rcx, r14
	mov	DWORD PTR [rsp+32], 0
	call	RunMacro

; 2309 :     Token_Count = i - 1;
; 2310 :     DebugMsg(("write_userdef_prologue: macro %s returned >%s<\n", ModuleInfo.proc_prologue, buffer ));
; 2311 : 
; 2312 :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	rbp, QWORD PTR [rsp+1288]
	mov	rbx, QWORD PTR [rsp+1280]
	mov	DWORD PTR ModuleInfo+496, edi
	jne	SHORT $LN1@write_user

; 2313 :         struct dsym *curr;
; 2314 :         len = atoi( buffer ) - info->localsize;

	lea	rcx, QWORD PTR buffer$[rsp]
	call	atoi

; 2315 :         for ( curr = info->locallist; curr; curr = curr->nextlocal ) {

	mov	rcx, QWORD PTR [r13+16]
	sub	eax, DWORD PTR [r13+36]
	test	rcx, rcx
	je	SHORT $LN1@write_user
	npad	6
$LL3@write_user:

; 2316 :             curr->sym.offset -= len;

	sub	DWORD PTR [rcx+16], eax
	mov	rcx, QWORD PTR [rcx+120]
	test	rcx, rcx
	jne	SHORT $LL3@write_user
$LN1@write_user:

; 2317 :         }
; 2318 :     }
; 2319 : 	
; 2320 :     return ( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN27@write_user
$LN11@write_user:

; 2279 :         return( EmitError( PROLOGUE_MUST_BE_MACRO_FUNC ) );

	mov	ecx, 156				; 0000009cH
	call	EmitError
$LN27@write_user:
	mov	r14, QWORD PTR [rsp+1248]
	mov	rdi, QWORD PTR [rsp+1304]
	mov	r13, QWORD PTR [rsp+1256]
$LN17@write_user:
	mov	r15, QWORD PTR [rsp+1240]
	mov	r12, QWORD PTR [rsp+1264]

; 2321 : }

	add	rsp, 1272				; 000004f8H
	ret	0
write_userdef_prologue ENDP
_TEXT	ENDS
EXTRN	MOVE_SIMD_QWORD:QWORD
EXTRN	MOVE_SINGLE:QWORD
EXTRN	MOVE_DOUBLE:QWORD
xdata	SEGMENT
$unwind$win64_SaveRegParams DD 0d2901H
	DD	07d429H
	DD	08c424H
	DD	0d741fH
	DD	0c641aH
	DD	0b5415H
	DD	0a3410H
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$win64_SaveRegParams DD @imagerel(win64_SaveRegParams#)
	DD	@imagerel(win64_SaveRegParams#+807)
	DD	@imagerel($unwind$win64_SaveRegParams#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
info$ = 80
win64_SaveRegParams PROC NEAR

; 2328 : {

	sub	rsp, 72					; 00000048H

; 2329 : 	int i;
; 2330 : 	struct dsym *param;
; 2331 : 	if (ModuleInfo.win64_flags & W64F_SMART) {

	test	BYTE PTR ModuleInfo+413, 8
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+88], rbp
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+104], rdi
	mov	QWORD PTR [rsp+64], r12
	mov	QWORD PTR [rsp+56], r13
	mov	rsi, rcx
	je	$LN34@win64_Save

; 2332 : 		int			   cnt;
; 2333 : 		uint_16        *regist;
; 2334 : 		info->home_taken = 0;
; 2335 : 		memset(info->home_used, 0, 6);

	xor	eax, eax
	lea	r12, QWORD PTR [rcx+116]
	xor	r13d, r13d
	mov	DWORD PTR [rcx+108], r13d
	mov	DWORD PTR [r12], eax
	mov	WORD PTR [r12+4], ax

; 2336 : 		if (info->regslist)
; 2337 : 			regist = info->regslist;
; 2338 : 		if (CurrProc->sym.langtype == LANG_VECTORCALL) {

	mov	rax, QWORD PTR CurrProc
	cmp	DWORD PTR [rax+84], 8
	jne	$LN32@win64_Save

; 2339 : 			for (i = 0, param = info->paralist; param && (i < 6); i++) {

	mov	rdi, QWORD PTR [rcx+8]
	test	rdi, rdi
	je	$LN43@win64_Save
	mov	ebx, 8
	lea	rbp, OFFSET FLAT:ms64_regs
$LL31@win64_Save:
	cmp	ebx, 56					; 00000038H
	jge	$LN43@win64_Save

; 2340 : 				/* v2.05: save XMMx if type is float/double */
; 2341 : 				if (param->sym.is_vararg == FALSE) {

	test	BYTE PTR [rdi+55], 32			; 00000020H
	jne	$LN28@win64_Save

; 2342 : 					if ((param->sym.mem_type & MT_FLOAT) && param->sym.used) {  // added  && param->sym.used

	mov	eax, DWORD PTR [rdi+44]
	test	al, 32					; 00000020H
	je	SHORT $LN27@win64_Save
	test	BYTE PTR [rdi+48], 1
	je	SHORT $LN27@win64_Save

; 2343 : 						if (param->sym.mem_type == MT_REAL8)

	cmp	eax, 39					; 00000027H
	jne	SHORT $LN26@win64_Save

; 2344 : 							AddLineQueueX("%s qword ptr[%r+%u], %r", MOVE_DOUBLE, T_RSP, 8 + i * 8, T_XMM0 + i);

	mov	rdx, QWORD PTR MOVE_DOUBLE
	lea	eax, DWORD PTR [r13+40]
	lea	rcx, OFFSET FLAT:$SG6842
	mov	r9d, ebx
	mov	r8d, 119				; 00000077H
	mov	DWORD PTR [rsp+32], eax
	call	AddLineQueueX

; 2347 : 						info->home_used[i] = 1;

	mov	BYTE PTR [r12], 1

; 2348 : 						++info->home_taken;

	inc	DWORD PTR [rsi+108]

; 2365 : 							}
; 2366 : 						}
; 2367 : 					}
; 2368 : 					param = param->nextparam;

	mov	rdi, QWORD PTR [rdi+120]

; 2369 : 				}
; 2370 : 				else { /* v2.09: else branch added */

	jmp	$LN30@win64_Save
$LN26@win64_Save:

; 2345 : 						else if (param->sym.mem_type == MT_REAL4)

	cmp	eax, 35					; 00000023H
	jne	SHORT $LN24@win64_Save

; 2346 : 							AddLineQueueX("%s dword ptr[%r+%u], %r", MOVE_SINGLE, T_RSP, 8 + i * 8, T_XMM0 + i);

	mov	rdx, QWORD PTR MOVE_SINGLE
	lea	eax, DWORD PTR [r13+40]
	lea	rcx, OFFSET FLAT:$SG6845
	mov	r9d, ebx
	mov	r8d, 119				; 00000077H
	mov	DWORD PTR [rsp+32], eax
	call	AddLineQueueX
$LN24@win64_Save:

; 2347 : 						info->home_used[i] = 1;

	mov	BYTE PTR [r12], 1

; 2348 : 						++info->home_taken;

	inc	DWORD PTR [rsi+108]

; 2365 : 							}
; 2366 : 						}
; 2367 : 					}
; 2368 : 					param = param->nextparam;

	mov	rdi, QWORD PTR [rdi+120]

; 2369 : 				}
; 2370 : 				else { /* v2.09: else branch added */

	jmp	SHORT $LN30@win64_Save
$LN27@win64_Save:

; 2349 : 					}
; 2350 : 					else if ((param->sym.mem_type == MT_TYPE) && param->sym.used) 

	cmp	eax, 196				; 000000c4H
	jne	SHORT $LN22@win64_Save
	test	BYTE PTR [rdi+48], 1
	je	SHORT $LN22@win64_Save

; 2351 : 					{
; 2352 : //						if(info->vecregs[i] == 0)
; 2353 : 	//						AddLineQueueX("mov [%r+%u], %r", T_RSP, 8 + i * 8, ms64_regs[i]);
; 2354 : 						info->home_used[i] = 1;

	mov	BYTE PTR [r12], 1

; 2355 : 						++info->home_taken;

	inc	DWORD PTR [rsi+108]

; 2356 : 						info->vecused = TRUE;

	mov	BYTE PTR [rsi+80], 1

; 2365 : 							}
; 2366 : 						}
; 2367 : 					}
; 2368 : 					param = param->nextparam;

	mov	rdi, QWORD PTR [rdi+120]

; 2369 : 				}
; 2370 : 				else { /* v2.09: else branch added */

	jmp	SHORT $LN30@win64_Save
$LN22@win64_Save:

; 2357 : 					}
; 2358 : 					else {
; 2359 : 						if (((param->sym.mem_type != MT_TYPE) && param->sym.used) &&
; 2360 : 							(param->sym.mem_type <= MT_QWORD) && param->sym.used) {   //here as well   

	cmp	eax, 196				; 000000c4H
	je	SHORT $LN19@win64_Save
	test	BYTE PTR [rdi+48], 1
	je	SHORT $LN19@win64_Save
	cmp	eax, 7
	jg	SHORT $LN19@win64_Save

; 2361 : 							if (i < 4) {

	cmp	ebx, 40					; 00000028H
	jge	SHORT $LN19@win64_Save

; 2362 : 								AddLineQueueX("mov [%r+%u], %r", T_RSP, 8 + i * 8, ms64_regs[i]);

	mov	r9d, DWORD PTR [rbp]
	lea	rcx, OFFSET FLAT:$SG6851
	mov	r8d, ebx
	mov	edx, 119				; 00000077H
	call	AddLineQueueX

; 2363 : 								info->home_used[i] = 1;

	mov	BYTE PTR [r12], 1

; 2364 : 								++info->home_taken;

	inc	DWORD PTR [rsi+108]
$LN19@win64_Save:

; 2365 : 							}
; 2366 : 						}
; 2367 : 					}
; 2368 : 					param = param->nextparam;

	mov	rdi, QWORD PTR [rdi+120]

; 2369 : 				}
; 2370 : 				else { /* v2.09: else branch added */

	jmp	SHORT $LN30@win64_Save
$LN28@win64_Save:

; 2371 : 					AddLineQueueX("mov [%r+%u], %r", T_RSP, 8 + i * 8, ms64_regs[i]);

	mov	r9d, DWORD PTR [rbp]
	lea	rcx, OFFSET FLAT:$SG6853
	mov	r8d, ebx
	mov	edx, 119				; 00000077H
	call	AddLineQueueX

; 2372 : 					info->home_used[i] = 1;

	mov	BYTE PTR [r12], 1

; 2373 : 					++info->home_taken;

	inc	DWORD PTR [rsi+108]
$LN30@win64_Save:
	inc	r13d
	add	ebx, 8
	add	rbp, 4
	inc	r12
	test	rdi, rdi
	jne	$LL31@win64_Save

; 2374 : 				}
; 2375 : 			}
; 2376 : 		}
; 2377 : 		else {

	jmp	$LN43@win64_Save
$LN32@win64_Save:

; 2378 : 			for (i = 0, param = info->paralist; param && (i < 4); i++) {

	mov	rdi, QWORD PTR [rcx+8]
	test	rdi, rdi
	je	$LN43@win64_Save
	mov	ebx, 8
	lea	rbp, OFFSET FLAT:ms64_regs
$LL16@win64_Save:
	cmp	ebx, 40					; 00000028H
	jge	$LN43@win64_Save

; 2379 : 				/* v2.05: save XMMx if type is float/double */
; 2380 : 				if (param->sym.is_vararg == FALSE) {

	test	BYTE PTR [rdi+55], 32			; 00000020H
	jne	SHORT $LN13@win64_Save

; 2381 : 					if ((param->sym.mem_type & MT_FLOAT) && param->sym.used) {  // added  && param->sym.used

	test	BYTE PTR [rdi+44], 32			; 00000020H
	je	SHORT $LN12@win64_Save
	test	BYTE PTR [rdi+48], 1
	je	SHORT $LN12@win64_Save

; 2382 : 						AddLineQueueX("%s [%r+%u], %r", MOVE_SIMD_QWORD, T_RSP, 8 + i * 8, T_XMM0 + i);

	mov	rdx, QWORD PTR MOVE_SIMD_QWORD
	lea	eax, DWORD PTR [r13+40]
	lea	rcx, OFFSET FLAT:$SG6860
	mov	r9d, ebx
	mov	r8d, 119				; 00000077H
	mov	DWORD PTR [rsp+32], eax
	call	AddLineQueueX

; 2383 : 						info->home_used[i] = 1;

	mov	BYTE PTR [r12], 1

; 2384 : 						++info->home_taken;

	inc	DWORD PTR [rsi+108]

; 2391 : 						}
; 2392 : 					}
; 2393 : 					param = param->nextparam;

	mov	rdi, QWORD PTR [rdi+120]

; 2394 : 				}
; 2395 : 				else { /* v2.09: else branch added */

	jmp	SHORT $LN15@win64_Save
$LN12@win64_Save:

; 2385 : 					}
; 2386 : 					else {
; 2387 : 						if (param->sym.used) {                                    //here as well 

	test	BYTE PTR [rdi+48], 1
	je	SHORT $LN10@win64_Save

; 2388 : 							AddLineQueueX("mov [%r+%u], %r", T_RSP, 8 + i * 8, ms64_regs[i]);

	mov	r9d, DWORD PTR [rbp]
	lea	rcx, OFFSET FLAT:$SG6863
	mov	r8d, ebx
	mov	edx, 119				; 00000077H
	call	AddLineQueueX

; 2389 : 							info->home_used[i] = 1;

	mov	BYTE PTR [r12], 1

; 2390 : 							++info->home_taken;

	inc	DWORD PTR [rsi+108]
$LN10@win64_Save:

; 2391 : 						}
; 2392 : 					}
; 2393 : 					param = param->nextparam;

	mov	rdi, QWORD PTR [rdi+120]

; 2394 : 				}
; 2395 : 				else { /* v2.09: else branch added */

	jmp	SHORT $LN15@win64_Save
$LN13@win64_Save:

; 2396 : 					AddLineQueueX("mov [%r+%u], %r", T_RSP, 8 + i * 8, ms64_regs[i]);

	mov	r9d, DWORD PTR [rbp]
	lea	rcx, OFFSET FLAT:$SG6865
	mov	r8d, ebx
	mov	edx, 119				; 00000077H
	call	AddLineQueueX

; 2397 : 					info->home_used[i] = 1;

	mov	BYTE PTR [r12], 1

; 2398 : 					++info->home_taken;

	inc	DWORD PTR [rsi+108]
$LN15@win64_Save:
	inc	r13d
	add	ebx, 8
	add	rbp, 4
	inc	r12
	test	rdi, rdi
	jne	$LL16@win64_Save

; 2399 : 				}
; 2400 : 			}
; 2401 : 		}
; 2402 : 	}
; 2403 : 	else {

	jmp	$LN43@win64_Save
$LN34@win64_Save:

; 2404 : 		for (i = 0, param = info->paralist; param && (i < 4); i++) {

	mov	rdi, QWORD PTR [rcx+8]
	xor	r13d, r13d
	test	rdi, rdi
	je	$LN43@win64_Save
	mov	ebx, 8
	lea	rbp, OFFSET FLAT:ms64_regs
$LL7@win64_Save:
	cmp	ebx, 40					; 00000028H
	jge	SHORT $LN43@win64_Save

; 2405 : 			/* v2.05: save XMMx if type is float/double */
; 2406 : 			if (param->sym.is_vararg == FALSE) {

	test	BYTE PTR [rdi+55], 32			; 00000020H
	jne	SHORT $LN4@win64_Save

; 2407 : 				if (param->sym.mem_type & MT_FLOAT)

	test	BYTE PTR [rdi+44], 32			; 00000020H
	je	SHORT $LN3@win64_Save

; 2408 : 					AddLineQueueX("%s [%r+%u], %r", MOVE_SIMD_QWORD, T_RSP, 8 + i * 8, T_XMM0 + i);

	mov	rdx, QWORD PTR MOVE_SIMD_QWORD
	lea	eax, DWORD PTR [r13+40]
	lea	rcx, OFFSET FLAT:$SG6872
	mov	r9d, ebx
	mov	r8d, 119				; 00000077H
	mov	DWORD PTR [rsp+32], eax
	call	AddLineQueueX

; 2411 : 				param = param->nextparam;

	mov	rdi, QWORD PTR [rdi+120]

; 2412 : 			}
; 2413 : 			else { /* v2.09: else branch added */

	jmp	SHORT $LN6@win64_Save
$LN3@win64_Save:

; 2409 : 				else
; 2410 : 					AddLineQueueX("mov [%r+%u], %r", T_RSP, 8 + i * 8, ms64_regs[i]);

	mov	r9d, DWORD PTR [rbp]
	lea	rcx, OFFSET FLAT:$SG6874
	mov	r8d, ebx
	mov	edx, 119				; 00000077H
	call	AddLineQueueX

; 2411 : 				param = param->nextparam;

	mov	rdi, QWORD PTR [rdi+120]

; 2412 : 			}
; 2413 : 			else { /* v2.09: else branch added */

	jmp	SHORT $LN6@win64_Save
$LN4@win64_Save:

; 2414 : 				AddLineQueueX("mov [%r+%u], %r", T_RSP, 8 + i * 8, ms64_regs[i]);

	mov	r9d, DWORD PTR [rbp]
	lea	rcx, OFFSET FLAT:$SG6876
	mov	r8d, ebx
	mov	edx, 119				; 00000077H
	call	AddLineQueueX
$LN6@win64_Save:
	inc	r13d
	add	ebx, 8
	add	rbp, 4
	test	rdi, rdi
	jne	SHORT $LL7@win64_Save
$LN43@win64_Save:
	mov	r13, QWORD PTR [rsp+56]
	mov	r12, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]

; 2415 : 			}
; 2416 : 		}
; 2417 : 	}
; 2418 : 	return;
; 2419 : }

	add	rsp, 72					; 00000048H
	ret	0
win64_SaveRegParams ENDP
_TEXT	ENDS
EXTRN	memset:NEAR
xdata	SEGMENT
$unwind$win64_StoreRegHome DD 051101H
	DD	06c411H
	DD	08340cH
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$win64_StoreRegHome DD @imagerel(win64_StoreRegHome#)
	DD	@imagerel(win64_StoreRegHome#+47)
	DD	@imagerel($unwind$win64_StoreRegHome#)
pdata	ENDS
xdata	SEGMENT
$chain$2$win64_StoreRegHome DD 020521H
	DD	05d405H
	DD	@imagerel(win64_StoreRegHome#)
	DD	@imagerel(win64_StoreRegHome#+47)
	DD	@imagerel($unwind$win64_StoreRegHome#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$win64_StoreRegHome DD @imagerel(win64_StoreRegHome#+47)
	DD	@imagerel(win64_StoreRegHome#+393)
	DD	@imagerel($chain$2$win64_StoreRegHome#)
pdata	ENDS
xdata	SEGMENT
$chain$5$win64_StoreRegHome DD 060f21H
	DD	0b740fH
	DD	0a640aH
	DD	095405H
	DD	@imagerel(win64_StoreRegHome#+47)
	DD	@imagerel(win64_StoreRegHome#+393)
	DD	@imagerel($chain$2$win64_StoreRegHome#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$win64_StoreRegHome DD @imagerel(win64_StoreRegHome#+393)
	DD	@imagerel(win64_StoreRegHome#+559)
	DD	@imagerel($chain$5$win64_StoreRegHome#)
pdata	ENDS
xdata	SEGMENT
$chain$6$win64_StoreRegHome DD 021H
	DD	@imagerel(win64_StoreRegHome#)
	DD	@imagerel(win64_StoreRegHome#+47)
	DD	@imagerel($unwind$win64_StoreRegHome#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$win64_StoreRegHome DD @imagerel(win64_StoreRegHome#+559)
	DD	@imagerel(win64_StoreRegHome#+574)
	DD	@imagerel($chain$6$win64_StoreRegHome#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
info$ = 64
win64_StoreRegHome PROC NEAR

; 2424 : {

	sub	rsp, 56					; 00000038H

; 2425 :   int			       i = 0;
; 2426 :   int			       cnt;
; 2427 :   int            grcount = 0;
; 2428 :   int			       sizestd = 0;
; 2429 :   int            freeshadow = 4;
; 2430 :   uint_16        *regist;
; 2431 :   info->stored_reg = 0;
; 2432 :   if (info->regslist) {

	mov	r8, QWORD PTR [rcx]
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+48], r12
	xor	r12d, r12d
	test	r8, r8
	mov	rbx, rcx
	mov	edx, r12d
	mov	DWORD PTR [rcx+100], r12d
	je	$LN7@win64_Stor

; 2433 :     for (regist = info->regslist, cnt = *regist++; cnt; cnt--, regist++, i++) {

	movzx	r9d, WORD PTR [r8]
	add	r8, 2
	mov	QWORD PTR [rsp+40], r13
	test	r9d, r9d
	lea	r13, OFFSET FLAT:SpecialTable
	je	SHORT $LN48@win64_Stor
$LL50@win64_Stor:

; 2434 :       if ((GetValueSp(*regist) & OP_YMM)||(GetValueSp(*regist) & OP_XMM)
; 2435 : #if EVEXSUPP    
; 2436 :                   || ( GetValueSp( *regist ) & OP_ZMM )
; 2437 : #endif
; 2438 :         )continue;

	movzx	eax, WORD PTR [r8]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	eax, DWORD PTR [r13+rcx*4]
	test	al, al
	js	SHORT $LN49@win64_Stor
	test	al, 32					; 00000020H
	jne	SHORT $LN49@win64_Stor

; 2439 :       else ++grcount;                                       //find how many general registers to save

	inc	edx
$LN49@win64_Stor:

; 2433 :     for (regist = info->regslist, cnt = *regist++; cnt; cnt--, regist++, i++) {

	add	r8, 2
	dec	r9d
	jne	SHORT $LL50@win64_Stor
$LN48@win64_Stor:

; 2440 :     }
; 2441 :     //for (i = 0, freeshadow = 0; i<4; i++){                  
; 2442 :     //  if (info->home_used[i] == 0) ++freeshadow;
; 2443 :     //}
; 2444 :     freeshadow -= info->home_taken;                         //find out how many free shadows

	mov	r8d, 4
	mov	eax, r8d
	sub	eax, DWORD PTR [rbx+108]

; 2445 :     if (freeshadow){                                        //skip if all shadow spaces are taken  

	je	$LN14@win64_Stor

; 2446 :       if (grcount == 1) memset(info->home_used, 1, 4);      //1 register only? don't store it, push it to prevent 'sub rsp,...8'

	cmp	edx, 1
	jne	SHORT $LN43@win64_Stor
	mov	rax, 72340172838076673			; 0101010101010101H
	mov	DWORD PTR [rbx+116], eax
	jmp	$LN14@win64_Stor
$LN43@win64_Stor:

; 2447 :       else if (grcount == 2 && freeshadow >= 2){            //store only one egister, another push to prevent 'sub rsp,...8'

	cmp	edx, 2
	jne	SHORT $LN41@win64_Stor
	cmp	eax, edx
	jl	$LN14@win64_Stor

; 2448 :         for (i = 0; i<4; i++){

	mov	ecx, r12d
	mov	rax, r12
	npad	4
$LL40@win64_Stor:

; 2449 :           if (info->home_used[i] == 0) break;               //we need only one space   

	cmp	BYTE PTR [rbx+rax+116], r12b
	je	SHORT $LN62@win64_Stor
	inc	rax
	inc	ecx
	cmp	rax, r8
	jl	SHORT $LL40@win64_Stor
$LN62@win64_Stor:

; 2450 :         }
; 2451 :         for (++i; i<4; i++)                                 //the rest of free spaces render as taken

	lea	eax, DWORD PTR [rcx+1]
	movsxd	rdx, eax
	cmp	rdx, r8
	jge	$LN14@win64_Stor
	lea	rcx, QWORD PTR [rdx+rbx+116]
	sub	r8, rdx
	mov	dl, 1
	call	memset

; 2452 :           info->home_used[i] = 1;
; 2453 :       }
; 2454 :       else if (grcount == 3){                               //3 registers?

	jmp	$LN14@win64_Stor
$LN41@win64_Stor:
	cmp	edx, 3
	jne	SHORT $LN32@win64_Stor

; 2455 :         if (freeshadow == 1) memset(info->home_used, 1, 4); //if only 1 free shadow, don't store it, push them

	cmp	eax, 1
	jne	SHORT $LN31@win64_Stor
	mov	rax, 72340172838076673			; 0101010101010101H
	mov	DWORD PTR [rbx+116], eax

; 2456 :         if (freeshadow >= 3){                               //enen if there is enough space we will store only two

	jmp	$LN14@win64_Stor
$LN31@win64_Stor:
	cmp	eax, 3
	jl	$LN14@win64_Stor

; 2457 :           for (i = 0; i<4; i++){                            //the third one we will push to keep uneven stack 

	mov	eax, r12d
	mov	rcx, r12
	npad	1
$LL29@win64_Stor:

; 2458 :             if (info->home_used[i] == 0) break;             //found first availible

	cmp	BYTE PTR [rbx+rcx+116], r12b
	je	SHORT $LN63@win64_Stor
	inc	rcx
	inc	eax
	cmp	rcx, r8
	jl	SHORT $LL29@win64_Stor
$LN63@win64_Stor:

; 2459 :           }
; 2460 :           for (++i; i<4; i++){

	inc	eax
	movsxd	rcx, eax
	cmp	rcx, r8
	jge	SHORT $LN74@win64_Stor
	npad	5
$LL25@win64_Stor:

; 2461 :             if (info->home_used[i] == 0) break;            //found second availible

	cmp	BYTE PTR [rbx+rcx+116], r12b
	je	SHORT $LN74@win64_Stor
	inc	rcx
	inc	eax
	cmp	rcx, r8
	jl	SHORT $LL25@win64_Stor
$LN74@win64_Stor:

; 2462 :           }
; 2463 :           for (++i; i<4; i++)

	inc	eax
	movsxd	rdx, eax
	cmp	rdx, r8
	jge	SHORT $LN14@win64_Stor
	lea	rcx, QWORD PTR [rdx+rbx+116]
	sub	r8, rdx
	mov	dl, 1
	call	memset

; 2464 :             info->home_used[i] = 1;                        //render the rest of the shadow spaces as taken
; 2465 :         }

	jmp	SHORT $LN14@win64_Stor
$LN32@win64_Stor:

; 2466 :       }
; 2467 :       else if (grcount == 4 && freeshadow == 4){          //easy case

	cmp	edx, r8d
	jne	SHORT $LN17@win64_Stor
	cmp	eax, r8d
	jne	SHORT $LN14@win64_Stor

; 2468 :         info->home_used[3] = 1;                           //render the last shadow spaces as taken

	mov	BYTE PTR [rbx+119], 1
	jmp	SHORT $LN14@win64_Stor
$LN17@win64_Stor:

; 2469 :       }                                                   //remember the first space is 0 than 1, 2 and 3 follow 
; 2470 :       else if (grcount > 4){                              //if more registars than spaces

	cmp	edx, r8d
	jle	SHORT $LN14@win64_Stor

; 2471 :         freeshadow = grcount - freeshadow;                //find out how many we can store

	sub	edx, eax

; 2472 :         if (!(freeshadow & 1)){                           //if it is even number

	test	dl, 1
	jne	SHORT $LN14@win64_Stor

; 2473 :           for (i = 0; i<4; i++){                          //than we have to disable one space

	mov	ecx, r12d
	mov	rax, r12
	npad	2
$LL13@win64_Stor:

; 2474 :             if (info->home_used[i] == 0) break;           //find the first free space 

	cmp	BYTE PTR [rbx+rax+116], r12b
	je	SHORT $LN65@win64_Stor
	inc	rax
	inc	ecx
	cmp	rax, r8
	jl	SHORT $LL13@win64_Stor
$LN65@win64_Stor:

; 2475 :           }
; 2476 :           info->home_used[i] = 1;                         //and render it as taken

	movsxd	rax, ecx
	mov	BYTE PTR [rax+rbx+116], 1
$LN14@win64_Stor:
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+88], rdi

; 2477 :         }
; 2478 :       }
; 2479 :     }
; 2480 :     for (i = 0, regist = info->regslist, cnt = *regist++; cnt; cnt--, regist++, i++) {

	mov	rdi, QWORD PTR [rbx]
	mov	rbp, r12
	movzx	esi, WORD PTR [rdi]
	add	rdi, 2
	test	esi, esi
	je	SHORT $LN78@win64_Stor
	npad	7
$LL9@win64_Stor:

; 2481 :       if ((GetValueSp(*regist) & OP_YMM)||(GetValueSp(*regist) & OP_XMM)
; 2482 : #if EVEXSUPP    
; 2483 :                   || ( GetValueSp( *regist ) & OP_ZMM )
; 2484 : #endif
; 2485 :         )continue;

	movzx	edx, WORD PTR [rdi]
	lea	rax, QWORD PTR [rdx+rdx*2]
	mov	ecx, DWORD PTR [r13+rax*4]
	test	cl, cl
	js	SHORT $LN8@win64_Stor
	test	cl, 32					; 00000020H
	jne	SHORT $LN8@win64_Stor

; 2486 :       else {
; 2487 :         sizestd += 8;

	add	r12d, 8

; 2488 :         if (i < 4)

	cmp	rbp, 4
	jge	SHORT $LN8@win64_Stor

; 2489 :         {
; 2490 :           if (info->home_used[i] == 0){

	cmp	BYTE PTR [rbx+rbp+116], 0
	jne	SHORT $LN2@win64_Stor

; 2491 :             AddLineQueueX("mov [%r+%u], %r", T_RSP, NUMQUAL sizestd, *regist);

	mov	r9d, edx
	lea	rcx, OFFSET FLAT:$SG6937
	mov	r8d, r12d
	mov	edx, 119				; 00000077H
	call	AddLineQueueX

; 2492 :             AddLineQueueX("%r %r, %u", T_DOT_SAVEREG, *regist, NUMQUAL sizestd);

	movzx	r8d, WORD PTR [rdi]
	lea	rcx, OFFSET FLAT:$SG6938
	mov	r9d, r12d
	mov	edx, 418				; 000001a2H
	call	AddLineQueueX

; 2493 :             info->stored_reg++;

	inc	DWORD PTR [rbx+100]

; 2494 :           }
; 2495 :           else {

	jmp	SHORT $LN8@win64_Stor
$LN2@win64_Stor:

; 2496 :             cnt++; regist--;

	inc	esi
	sub	rdi, 2
$LN8@win64_Stor:
	add	rdi, 2
	inc	rbp
	dec	esi
	jne	SHORT $LL9@win64_Stor
$LN78@win64_Stor:
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+72]
	mov	r13, QWORD PTR [rsp+40]
$LN7@win64_Stor:
	mov	r12, QWORD PTR [rsp+48]
	mov	rbx, QWORD PTR [rsp+64]

; 2497 :           }
; 2498 :         }
; 2499 :       }
; 2500 :     }/* end for */
; 2501 :   }
; 2502 :   return;
; 2503 : }

	add	rsp, 56					; 00000038H
	ret	0
win64_StoreRegHome ENDP
_TEXT	ENDS
EXTRN	MOVE_UNALIGNED_FLOAT:QWORD
EXTRN	MOVE_UNALIGNED_INT:QWORD
EXTRN	MOVE_ALIGNED_INT:QWORD
xdata	SEGMENT
$unwind$write_win64_default_prologue DD 0b6001H
	DD	0bf460H
	DD	0ce41aH
	DD	0ec413H
	DD	012640fH
	DD	010340bH
	DD	0e207H
xdata	ENDS
pdata	SEGMENT
$pdata$write_win64_default_prologue DD @imagerel(write_win64_default_prologue#)
	DD	@imagerel(write_win64_default_prologue#+299)
	DD	@imagerel($unwind$write_win64_default_prologue#)
pdata	ENDS
xdata	SEGMENT
$chain$7$write_win64_default_prologue DD 061521H
	DD	0dd415H
	DD	0137410H
	DD	0115408H
	DD	@imagerel(write_win64_default_prologue#)
	DD	@imagerel(write_win64_default_prologue#+299)
	DD	@imagerel($unwind$write_win64_default_prologue#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$write_win64_default_prologue DD @imagerel(write_win64_default_prologue#+299)
	DD	@imagerel(write_win64_default_prologue#+3059)
	DD	@imagerel($chain$7$write_win64_default_prologue#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
m$1$ = 48
resstack$1$ = 48
pushed$1$ = 52
tv1328 = 56
vsize$1$ = 56
xyused$ = 64
info$ = 128
write_win64_default_prologue PROC NEAR

; 2509 : {

	mov	rax, rsp
	sub	rsp, 120				; 00000078H
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax-8], r12

; 2510 :     uint_16             *regist;
; 2511 :     const char * const  *ppfmt;
; 2512 :     struct    dsym      *param;
; 2513 :     int                 cntxmm;
; 2514 :     unsigned char xyused[6];  /* flags for used sse registers in vectorcall */
; 2515 :     unsigned char       xreg;
; 2516 :     unsigned char       xsize;
; 2517 :     unsigned char       xmmflag = 1;
; 2518 :     unsigned char       ymmflag = 0;
; 2519 : #if EVEXSUPP
; 2520 :     unsigned char       zmmflag = 0;
; 2521 : #endif
; 2522 :     int                 vsize = 0;

	xor	r12d, r12d
	mov	QWORD PTR [rax-24], r14
	xor	r14b, r14b

; 2523 :     int                 vectstart = 0;
; 2524 :     int                 n;
; 2525 :     int                 m;
; 2526 :     int                 i;
; 2527 :     int                 j;
; 2528 :     int                 cnt;
; 2529 :     int                 homestart;
; 2530 :     int                 stackSize;
; 2531 :     int                 resstack = ( ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) ? sym_ReservedStack->value : 0 );

	test	BYTE PTR ModuleInfo+413, 2
	mov	DWORD PTR vsize$1$[rsp], r12d
	mov	rbx, rcx
	je	SHORT $LN137@write_win6
	mov	rax, QWORD PTR sym_ReservedStack
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR resstack$1$[rsp], eax
	jmp	SHORT $LN138@write_win6
$LN137@write_win6:
	mov	DWORD PTR resstack$1$[rsp], r12d
$LN138@write_win6:

; 2532 : 	struct dsym     *paranode;
; 2533 : 	int pushed = 0;
; 2534 : 	
; 2535 : 	if (Parse_Pass == PASS_1)

	cmp	DWORD PTR Parse_Pass, r12d
	mov	DWORD PTR pushed$1$[rsp], r12d
	jne	SHORT $LN134@write_win6

; 2536 : 	{
; 2537 : 		info->vsize = 0;

	mov	DWORD PTR [rcx+44], r12d

; 2538 : 		info->xmmsize = 0;

	mov	DWORD PTR [rcx+112], r12d
$LN134@write_win6:

; 2539 : 	}
; 2540 : 
; 2541 :     DebugMsg1(("write_win64_default_prologue enter\n"));
; 2542 :     memset(xyused, 0, 6);

	xor	eax, eax
	mov	QWORD PTR [rsp+88], r15

; 2543 :     info->vecused = 0;
; 2544 :     XYZMMsize = 16;

	mov	r15d, 16
	mov	BYTE PTR [rcx+80], al
	mov	DWORD PTR xyused$[rsp], eax
	mov	WORD PTR xyused$[rsp+4], ax

; 2545 :     if ( ModuleInfo.win64_flags & W64F_SAVEREGPARAMS )

	movzx	eax, BYTE PTR ModuleInfo+413
	mov	DWORD PTR XYZMMsize, r15d
	test	al, 1
	je	SHORT $LN133@write_win6

; 2546 :         win64_SaveRegParams( info );

	call	win64_SaveRegParams
	mov	al, BYTE PTR ModuleInfo+413
$LN133@write_win6:

; 2547 :     if (ModuleInfo.win64_flags & W64F_SMART) 

	test	al, 8
	je	SHORT $LN132@write_win6

; 2548 :       win64_StoreRegHome(info);

	mov	rcx, rbx
	call	win64_StoreRegHome
$LN132@write_win6:

; 2549 : 
; 2550 : 	/*
; 2551 :      * PUSH RBP
; 2552 :      * .PUSHREG RBP
; 2553 :      * MOV RBP, RSP
; 2554 :      * .SETFRAME RBP, 0
; 2555 :      */
; 2556 : 
; 2557 : #if STACKBASESUPP
; 2558 : 	 
; 2559 : 	info->pushed_reg = 0; /*count of pushed registers */
; 2560 : 
; 2561 : 	 /* info->locallist tells whether there are local variables ( info->localsize doesn't! ) */
; 2562 : 	if (info->regslist != 0)

	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rbx+104], r12d
	test	rax, rax
	je	SHORT $LN131@write_win6

; 2563 : 		pushed = *(info->regslist);

	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR pushed$1$[rsp], eax
$LN131@write_win6:

; 2564 : 
; 2565 :     if ( info->fpo || ( info->parasize == 0 && info->locallist == NULL ) ) {

	test	BYTE PTR [rbx+128], 128			; 00000080H
	jne	SHORT $LN129@write_win6
	cmp	DWORD PTR [rbx+32], r12d
	jne	SHORT $LN130@write_win6
	cmp	QWORD PTR [rbx+16], r12
	je	SHORT $LN129@write_win6
$LN130@write_win6:

; 2566 :         DebugMsg1(("write_win64_default_prologue: no frame register needed\n"));
; 2567 :         //sizestd += 8; /* v2.12: obsolete */
; 2568 : 		// If we're using RBP as the base/frame register and no frame was required, we need to sub RSP,8 to ensure the
; 2569 : 		// stack pointer remains aligned 16.
; 2570 : 		//if ( info->basereg != T_RSP && ( ( pushed>0 && (pushed & 1) == 1 ) || pushed==0 ) )
; 2571 : 		//{
; 2572 : 		//	AddLineQueueX("sub %r, %u", T_RSP, CurrWordSize);
; 2573 : 		//	pushed = 100;
; 2574 : 		//}
; 2575 : 	} 
; 2576 : 	else 
; 2577 : 	{
; 2578 :         AddLineQueueX( "push %r", info->basereg );

	movzx	edx, WORD PTR [rbx+130]
	lea	rcx, OFFSET FLAT:$SG6973
	call	AddLineQueueX

; 2579 :         AddLineQueueX( "%r %r", T_DOT_PUSHREG, info->basereg );

	movzx	r8d, WORD PTR [rbx+130]
	lea	rcx, OFFSET FLAT:$SG6974
	mov	edx, 417				; 000001a1H
	call	AddLineQueueX

; 2580 :         AddLineQueueX( "mov %r, %r", info->basereg, T_RSP );

	movzx	edx, WORD PTR [rbx+130]
	lea	rcx, OFFSET FLAT:$SG6975
	mov	r8d, 119				; 00000077H
	call	AddLineQueueX

; 2581 :         AddLineQueueX( "%r %r, 0", T_DOT_SETFRAME, info->basereg );

	movzx	r8d, WORD PTR [rbx+130]
	lea	rcx, OFFSET FLAT:$SG6976
	mov	edx, 421				; 000001a5H
	call	AddLineQueueX

; 2582 : 		info->pushed_reg += 1;

	inc	DWORD PTR [rbx+104]
$LN129@write_win6:

; 2583 :     }
; 2584 : #else
; 2585 :     AddLineQueueX( "push %r", basereg[USE64] );
; 2586 :     AddLineQueueX( "%r %r", T_DOT_PUSHREG, basereg[USE64] );
; 2587 :     AddLineQueueX( "mov %r, %r", basereg[USE64], T_RSP );
; 2588 :     AddLineQueueX( "%r %r, 0", T_DOT_SETFRAME, basereg[USE64] );
; 2589 : 	info->pushed_reg += 1;
; 2590 : #endif
; 2591 : 	//info->pushed_reg = 0; /*count of pushed registers */
; 2592 : 	if (ModuleInfo.win64_flags & W64F_SMART)

	test	BYTE PTR ModuleInfo+413, 8
	mov	QWORD PTR [rsp+136], rbp
	mov	QWORD PTR [rsp+152], rdi
	mov	QWORD PTR [rsp+104], r13
	lea	rdx, OFFSET FLAT:__ImageBase
	je	$LN127@write_win6

; 2593 : 	{
; 2594 :       cntxmm = 0;
; 2595 :       if (info->regslist) {

	mov	rbp, QWORD PTR [rbx]
	mov	edi, r12d
	test	rbp, rbp
	je	$LN175@write_win6

; 2596 :         n = 0;

	mov	r13d, r12d

; 2597 :         regist = info->regslist;
; 2598 :         for (cnt = *regist++; cnt; cnt--, regist++) {

	movzx	r12d, WORD PTR [rbp]
	add	rbp, 2
	test	r12d, r12d
	je	$LN175@write_win6
$LL125@write_win6:

; 2599 :           if (GetValueSp(*regist) & OP_XMM){

	movzx	eax, WORD PTR [rbp]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	eax, DWORD PTR SpecialTable[rdx+rcx*4]
	test	al, 32					; 00000020H
	je	SHORT $LN122@write_win6

; 2600 :             cntxmm += 1;

	inc	edi
	jmp	SHORT $LN124@write_win6
$LN122@write_win6:

; 2601 :           }
; 2602 :           else if (GetValueSp(*regist) & OP_YMM){

	test	al, al
	jns	SHORT $LN120@write_win6

; 2603 :             cntxmm += 1;

	inc	edi

; 2604 :             ymmflag = 1;

	mov	r14b, 1

; 2605 :           }
; 2606 : #if EVEXSUPP    
; 2607 :           else if (GetValueSp(*regist) & OP_ZMM){
; 2608 :             cntxmm += 1;
; 2609 :             zmmflag = 1;
; 2610 :           }
; 2611 : #endif
; 2612 :           else {

	jmp	SHORT $LN124@write_win6
$LN120@write_win6:

; 2613 :             if (n < info->stored_reg) n++;

	cmp	r13d, DWORD PTR [rbx+100]
	jge	SHORT $LN118@write_win6
	inc	r13d

; 2614 :             else{

	jmp	SHORT $LN124@write_win6
$LN118@write_win6:

; 2615 :               info->pushed_reg += 1;

	inc	DWORD PTR [rbx+104]

; 2616 :               AddLineQueueX("push %r", *regist);

	movzx	edx, WORD PTR [rbp]
	lea	rcx, OFFSET FLAT:$SG6988
	call	AddLineQueueX

; 2617 :               if ((1 << GetRegNo(*regist)) & win64_nvgpr) {

	movzx	r11d, WORD PTR [rbp]
	lea	rdx, OFFSET FLAT:__ImageBase
	lea	rax, QWORD PTR [r11+r11*2]
	movzx	ecx, BYTE PTR SpecialTable[rdx+rax*4+10]
	mov	eax, 1
	shl	eax, cl
	test	eax, 61672				; 0000f0e8H
	je	SHORT $LN124@write_win6

; 2618 :                 AddLineQueueX("%r %r", T_DOT_PUSHREG, *regist);

	lea	rcx, OFFSET FLAT:$SG6990
	mov	r8d, r11d
	mov	edx, 417				; 000001a1H
	call	AddLineQueueX
	lea	rdx, OFFSET FLAT:__ImageBase
$LN124@write_win6:
	add	rbp, 2
	dec	r12d
	jne	$LL125@write_win6

; 2619 :               }
; 2620 :             }
; 2621 :           }
; 2622 :         } /* end for */
; 2623 :       }
; 2624 :     }
; 2625 :     else{

	jmp	$LN111@write_win6
$LN127@write_win6:

; 2626 :       /* after the "push rbp", the stack is xmmword aligned */
; 2627 :       /* Push the registers */
; 2628 :       cntxmm = 0;
; 2629 :       if (info->regslist) {

	mov	rbp, QWORD PTR [rbx]
	mov	edi, r12d
	test	rbp, rbp
	je	$LN175@write_win6

; 2630 :         int cnt;
; 2631 :         regist = info->regslist;
; 2632 :         for (cnt = *regist++; cnt; cnt--, regist++) {

	movzx	r12d, WORD PTR [rbp]
	add	rbp, 2
	test	r12d, r12d
	je	$LN175@write_win6
	npad	11
$LL113@write_win6:

; 2633 :           if (GetValueSp(*regist) & OP_XMM)

	movzx	eax, WORD PTR [rbp]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	eax, DWORD PTR SpecialTable[rdx+rcx*4]
	test	al, 32					; 00000020H
	je	SHORT $LN110@write_win6

; 2634 :             cntxmm += 1;

	inc	edi
	jmp	SHORT $LN112@write_win6
$LN110@write_win6:

; 2635 :           else if (GetValueSp(*regist) & OP_YMM){

	test	al, al
	jns	SHORT $LN108@write_win6

; 2636 :             cntxmm += 1;

	inc	edi

; 2637 :             ymmflag = 1;

	mov	r14b, 1

; 2638 :           }
; 2639 : #if EVEXSUPP    
; 2640 :           else if (GetValueSp(*regist) & OP_ZMM){
; 2641 :             cntxmm += 1;
; 2642 :             zmmflag = 1;
; 2643 :           }
; 2644 : #endif
; 2645 :           else {

	jmp	SHORT $LN112@write_win6
$LN108@write_win6:

; 2646 : 			info->pushed_reg += 1;

	inc	DWORD PTR [rbx+104]

; 2647 :             AddLineQueueX("push %r", *regist);

	movzx	edx, WORD PTR [rbp]
	lea	rcx, OFFSET FLAT:$SG7001
	call	AddLineQueueX

; 2648 :             if ((1 << GetRegNo(*regist)) & win64_nvgpr) {

	movzx	r11d, WORD PTR [rbp]
	lea	rdx, OFFSET FLAT:__ImageBase
	lea	rax, QWORD PTR [r11+r11*2]
	movzx	ecx, BYTE PTR SpecialTable[rdx+rax*4+10]
	mov	eax, 1
	shl	eax, cl
	test	eax, 61672				; 0000f0e8H
	je	SHORT $LN112@write_win6

; 2649 :               AddLineQueueX("%r %r", T_DOT_PUSHREG, *regist);

	lea	rcx, OFFSET FLAT:$SG7003
	mov	r8d, r11d
	mov	edx, 417				; 000001a1H
	call	AddLineQueueX
	lea	rdx, OFFSET FLAT:__ImageBase
$LN112@write_win6:
	add	rbp, 2
	dec	r12d
	jne	SHORT $LL113@write_win6
$LN111@write_win6:

; 2650 :             }
; 2651 :           }
; 2652 :         } /* end for */
; 2653 :       }
; 2654 :     }
; 2655 : #if EVEXSUPP   
; 2656 :     if (zmmflag) XYZMMsize = 64;
; 2657 :     else
; 2658 : #endif
; 2659 :     if (ymmflag) XYZMMsize = 32;

	test	r14b, r14b
	je	SHORT $LN175@write_win6
	mov	r15d, 32				; 00000020H
	mov	DWORD PTR XYZMMsize, r15d
	jmp	SHORT $LN104@write_win6
$LN175@write_win6:

; 2660 :     else XYZMMsize = 16;

	mov	DWORD PTR XYZMMsize, r15d
$LN104@write_win6:

; 2661 :     /* v2.11: now done in write_prologue() */
; 2662 : 	if (ModuleInfo.win64_flags & W64F_HABRAN){

	test	BYTE PTR ModuleInfo+413, 11
	je	SHORT $LN103@write_win6

; 2663 :       if (Parse_Pass && sym_ReservedStack->hasinvoke == 0) resstack = 0;

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN179@write_win6
	mov	rax, QWORD PTR sym_ReservedStack
	mov	ecx, DWORD PTR resstack$1$[rsp]
	cmp	DWORD PTR [rax+24], 0
	mov	eax, 0
	cmove	ecx, eax
	mov	DWORD PTR resstack$1$[rsp], ecx
	jmp	SHORT $LN102@write_win6
$LN179@write_win6:
	mov	ecx, DWORD PTR resstack$1$[rsp]
	xor	eax, eax
$LN102@write_win6:

; 2664 :       if (!(info->locallist) && !(resstack)) info->localsize = 0;

	cmp	QWORD PTR [rbx+16], 0
	jne	SHORT $LN101@write_win6
	test	ecx, ecx
	jne	SHORT $LN101@write_win6
	mov	DWORD PTR [rbx+36], eax
	mov	r15d, DWORD PTR XYZMMsize
$LN101@write_win6:

; 2665 :       if ((info->localsize == 0) && (cntxmm)){

	cmp	DWORD PTR [rbx+36], 0
	jne	SHORT $LN176@write_win6
	test	edi, edi
	je	SHORT $LN176@write_win6

; 2666 :         CurrProc->e.procinfo->xmmsize = cntxmm * XYZMMsize;

	mov	rax, QWORD PTR CurrProc
	imul	r15d, edi
	mov	rcx, QWORD PTR [rax+104]
	mov	DWORD PTR [rcx+112], r15d

; 2667 :         if ((info->pushed_reg & 1) == 0)

	test	BYTE PTR [rbx+104], 1
	jne	SHORT $LN176@write_win6

; 2668 :         info->localsize = 8;

	mov	DWORD PTR [rbx+36], 8

; 2669 :       }
; 2670 :     }
; 2671 : 	else {

	jmp	SHORT $LN176@write_win6
$LN103@write_win6:

; 2672 : 		if (pushed != 100 && (info->locallist == 0) && (info->localsize)) 

	cmp	DWORD PTR pushed$1$[rsp], 100		; 00000064H
	je	SHORT $LN176@write_win6
	cmp	QWORD PTR [rbx+16], 0
	jne	SHORT $LN176@write_win6
	mov	r8d, DWORD PTR [rbx+36]
	test	r8d, r8d
	je	SHORT $LN176@write_win6

; 2673 : 		{
; 2674 : 			AddLineQueueX("sub %r, %u", T_RSP, info->localsize);

	lea	rcx, OFFSET FLAT:$SG7013
	mov	edx, 119				; 00000077H
	call	AddLineQueueX
$LN176@write_win6:

; 2675 : 		}
; 2676 : 	}
; 2677 :     if ( (info->locallist + resstack) || info->vecused || CurrProc->e.procinfo->xmmsize )  {

	movsxd	rdx, DWORD PTR resstack$1$[rsp]
	mov	rax, rdx
	mov	r13, rdx
	shl	rax, 7
	add	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN95@write_win6
	cmp	BYTE PTR [rbx+80], al
	jne	SHORT $LN95@write_win6
	mov	rax, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [rax+104]
	cmp	DWORD PTR [rcx+112], 0
	je	$LN178@write_win6
$LN95@write_win6:

; 2678 :         DebugMsg1(("write_win64_default_prologue: localsize=%u resstack=%u\n", info->localsize, resstack ));
; 2679 :         if (ModuleInfo.win64_flags & W64F_SMART){

	test	BYTE PTR ModuleInfo+413, 8
	je	SHORT $LN90@write_win6

; 2680 :           if (((info->pushed_reg & 1) && (info->localsize & 0xF)) ||
; 2681 :             ((!(info->pushed_reg & 1)) && (!(info->localsize & 0xF))) && (!(info->pushed_reg & 1)) && (!(cntxmm)))

	mov	ecx, DWORD PTR [rbx+104]
	and	ecx, 1
	je	SHORT $LN91@write_win6
	mov	eax, DWORD PTR [rbx+36]
	test	al, 15
	jne	SHORT $LN92@write_win6
$LN91@write_win6:
	test	ecx, ecx
	jne	SHORT $LN90@write_win6
	mov	eax, DWORD PTR [rbx+36]
	test	al, 15
	jne	SHORT $LN90@write_win6
	test	edi, edi
	jne	SHORT $LN90@write_win6
$LN92@write_win6:

; 2682 : 		  {
; 2683 :             info->localsize += 8;

	add	eax, 8
	mov	DWORD PTR [rbx+36], eax
$LN90@write_win6:

; 2684 :             if (CurrProc->sym.langtype == LANG_VECTORCALL){
; 2685 :               vectstart = 0;
; 2686 :             }
; 2687 :           }
; 2688 :         }
; 2689 :           /*
; 2690 :          * SUB  RSP, localsize
; 2691 :          * .ALLOCSTACK localsize
; 2692 :          */
; 2693 :         
; 2694 :         ppfmt = ( resstack ? fmtstk1 : fmtstk0 );
; 2695 : #if STACKPROBE
; 2696 : 		if (info->localsize + resstack > 0x1000) {
; 2697 : 			AddLineQueueX(*(ppfmt + 2), T_RAX, NUMQUAL info->localsize, sym_ReservedStack->name);
; 2698 : 			AddLineQueue("externdef __chkstk:PROC");
; 2699 : 			AddLineQueue("call __chkstk");
; 2700 : 			AddLineQueueX("mov %r, %r", T_RSP, T_RAX);
; 2701 : 		}
; 2702 : 		else
; 2703 : #endif
; 2704 : 			stackSize = info->localsize + info->vsize + info->xmmsize;

	mov	ebp, DWORD PTR [rbx+44]
	test	edx, edx
	lea	rax, OFFSET FLAT:fmtstk1
	lea	r12, OFFSET FLAT:fmtstk0
	cmovne	r12, rax
	add	ebp, DWORD PTR [rbx+36]
	add	ebp, DWORD PTR [rbx+112]

; 2705 : 			if ((stackSize & 7) != 0) stackSize = (stackSize + 7)&(-8);

	test	bpl, 7
	je	SHORT $LN89@write_win6
	add	ebp, 7
	and	ebp, -8
$LN89@write_win6:

; 2706 : 		
; 2707 : 			AddLineQueueX(*(ppfmt + 0), T_RSP, NUMQUAL stackSize, sym_ReservedStack->name);

	mov	r9, QWORD PTR sym_ReservedStack
	mov	rcx, QWORD PTR [r12]
	mov	r8d, ebp
	mov	r9, QWORD PTR [r9+8]
	mov	edx, 119				; 00000077H
	call	AddLineQueueX

; 2708 : 			AddLineQueueX(*(ppfmt + 1), T_DOT_ALLOCSTACK, NUMQUAL stackSize, sym_ReservedStack->name);

	mov	r9, QWORD PTR sym_ReservedStack
	mov	rcx, QWORD PTR [r12+8]
	mov	r9, QWORD PTR [r9+8]
	mov	r8d, ebp
	mov	edx, 414				; 0000019eH
	call	AddLineQueueX

; 2709 : 
; 2710 : 			/* Force proc parameters down by 8 if we use the sub rsp. */
; 2711 : 			if (info->NoSub == 0)

	cmp	BYTE PTR [rbx+132], 0
	jne	SHORT $LN87@write_win6

; 2712 : 			{
; 2713 : 				if (info->basereg == T_RBP && (ModuleInfo.win64_flags & W64F_AUTOSTACKSP) && (ModuleInfo.win64_flags & W64F_SAVEREGPARAMS))

	cmp	WORD PTR [rbx+130], 120			; 00000078H
	jne	SHORT $LN87@write_win6
	movzx	eax, BYTE PTR ModuleInfo+413
	test	al, 2
	je	SHORT $LN87@write_win6
	test	al, 1
	je	SHORT $LN87@write_win6

; 2714 : 				{
; 2715 : 					paranode = info->paralist;

	mov	rax, QWORD PTR [rbx+8]

; 2716 : 					while (paranode != NULL)

	test	rax, rax
	je	SHORT $LN85@write_win6
$LL86@write_win6:

; 2717 : 					{
; 2718 : 						paranode->sym.offset -= 8;

	add	DWORD PTR [rax+16], -8

; 2719 : 						paranode = paranode->nextparam;

	mov	rax, QWORD PTR [rax+120]
	test	rax, rax
	jne	SHORT $LL86@write_win6
$LN85@write_win6:

; 2720 : 					}
; 2721 : 					info->NoSub = 1;

	mov	BYTE PTR [rbx+132], 1
$LN87@write_win6:

; 2722 : 				}
; 2723 : 			}
; 2724 : 
; 2725 : 		    /* Handle ZEROLOCALS option */
; 2726 : 		    if (ZEROLOCALS && info->localsize) 

	cmp	BYTE PTR ZEROLOCALS, 0
	je	$LN82@write_win6
	mov	r8d, DWORD PTR [rbx+36]
	test	r8d, r8d
	je	$LN82@write_win6

; 2727 : 		    {
; 2728 : 			    if (info->localsize <= 128) 

	cmp	r8d, 128				; 00000080H
	ja	SHORT $LN83@write_win6

; 2729 : 			    {
; 2730 : 				    AddLineQueueX("mov %r, %u", T_EAX, info->localsize);

	lea	rcx, OFFSET FLAT:$SG7030
	mov	edx, 17
	call	AddLineQueueX

; 2731 : 				    AddLineQueueX("dec %r", T_EAX);

	lea	rcx, OFFSET FLAT:$SG7031
	mov	edx, 17
	call	AddLineQueueX

; 2732 : 				    AddLineQueueX("mov byte ptr [%r + %r], 0", T_RSP, T_RAX);

	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG7032
	lea	r8d, QWORD PTR [rdx-4]
	call	AddLineQueueX

; 2733 : 				    AddLineQueueX("dw 0F875h");

	lea	rcx, OFFSET FLAT:$SG7033
	call	AddLineQueueX

; 2734 : 			    }
; 2735 : 			    else

	jmp	$LN82@write_win6
$LN83@write_win6:

; 2736 : 			    {
; 2737 : 				    AddLineQueueX("push %r", T_RDI);

	lea	rcx, OFFSET FLAT:$SG7035
	mov	edx, 122				; 0000007aH
	call	AddLineQueueX

; 2738 : 				    AddLineQueueX("push %r", T_RCX);

	lea	rcx, OFFSET FLAT:$SG7036
	mov	edx, 116				; 00000074H
	call	AddLineQueueX

; 2739 : 				    AddLineQueueX("xor %r, %r", T_EAX, T_EAX);

	mov	edx, 17
	lea	rcx, OFFSET FLAT:$SG7037
	mov	r8d, edx
	call	AddLineQueueX

; 2740 : 				    AddLineQueueX("mov %r, %u", T_ECX, info->localsize);

	mov	r8d, DWORD PTR [rbx+36]
	lea	rcx, OFFSET FLAT:$SG7038
	mov	edx, 18
	call	AddLineQueueX

; 2741 : 				    AddLineQueueX("cld");

	lea	rcx, OFFSET FLAT:$SG7039
	call	AddLineQueueX

; 2742 : 				    AddLineQueueX("lea %r, [%r+16]", T_RDI, T_RSP);

	mov	edx, 122				; 0000007aH
	lea	rcx, OFFSET FLAT:$SG7040
	lea	r8d, QWORD PTR [rdx-3]
	call	AddLineQueueX

; 2743 : 				    AddLineQueueX("rep stosb");

	lea	rcx, OFFSET FLAT:$SG7041
	call	AddLineQueueX

; 2744 : 				    AddLineQueueX("pop %r", T_RCX);

	lea	rcx, OFFSET FLAT:$SG7042
	mov	edx, 116				; 00000074H
	call	AddLineQueueX

; 2745 : 				    AddLineQueueX("pop %r", T_RDI);

	lea	rcx, OFFSET FLAT:$SG7043
	mov	edx, 122				; 0000007aH
	call	AddLineQueueX
$LN82@write_win6:

; 2746 : 			    }
; 2747 : 		    }
; 2748 :         /* save xmm registers */
; 2749 :         if ( cntxmm ) {

	test	edi, edi
	je	$LN180@write_win6

; 2750 :             int cnt;
; 2751 :             regist = info->regslist;

	mov	rdi, QWORD PTR [rbx]

; 2752 :             //if (info->locallist)
; 2753 :             //  i = (info->localsize - cntxmm * XYZMMsize) & ~(16 - 1);
; 2754 :             //else
; 2755 :             //  i = info->localsize  & ~(16 - 1);
; 2756 :             i = 0;       //firs location is right at the [rsp] which is aligned to 16  ; HJWasm 2.21

	xor	ecx, ecx

; 2757 :             for( cnt = *regist++; cnt; cnt--, regist++ ) {

	movzx	r12d, WORD PTR [rdi]
	add	rdi, 2
	mov	ebp, ecx
	test	r12d, r12d
	je	$LN78@write_win6
	lea	rsi, OFFSET FLAT:__ImageBase
$LL80@write_win6:

; 2758 :                 if (( GetValueSp( *regist ) & OP_XMM )||( GetValueSp( *regist ) & OP_YMM )
; 2759 : #if EVEXSUPP    
; 2760 :                   || ( GetValueSp( *regist ) & OP_ZMM )
; 2761 : #endif
; 2762 :                 ){

	movzx	r9d, WORD PTR [rdi]
	lea	rax, QWORD PTR [r9+r9*2]
	mov	edx, DWORD PTR SpecialTable[rsi+rax*4]
	mov	r8d, edx
	and	r8d, 32					; 00000020H
	jne	SHORT $LN76@write_win6
	test	dl, dl
	jns	$LN79@write_win6
$LN76@write_win6:

; 2763 :                     if ( resstack ) {

	test	r13, r13
	je	$LN75@write_win6

; 2764 :                         if ( ( 1 << GetRegNo( *regist ) ) & win64_nvxmm )  {

	movzx	ecx, BYTE PTR SpecialTable[rsi+rax*4+10]
	mov	eax, 1
	shl	eax, cl
	test	eax, 65472				; 0000ffc0H
	je	$LN79@write_win6

; 2765 :                           if (GetValueSp(*regist) & OP_XMM){

	test	r8d, r8d
	je	SHORT $LN73@write_win6

; 2766 :                             AddLineQueueX( "%s [%r+%u+%s], %r", MOVE_ALIGNED_INT, T_RSP, NUMQUAL i, sym_ReservedStack->name, *regist );

	mov	rax, QWORD PTR sym_ReservedStack
	mov	rdx, QWORD PTR MOVE_ALIGNED_INT
	mov	DWORD PTR [rsp+40], r9d
	mov	rcx, QWORD PTR [rax+8]
	mov	r9d, ebp
	mov	r8d, 119				; 00000077H
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, OFFSET FLAT:$SG7054
	call	AddLineQueueX

; 2767 :                             AddLineQueueX("%r %r, %u+%s", T_DOT_SAVEXMM128, *regist, NUMQUAL i, sym_ReservedStack->name);

	mov	rax, QWORD PTR sym_ReservedStack
	movzx	r8d, WORD PTR [rdi]
	mov	rcx, QWORD PTR [rax+8]
	mov	r9d, ebp
	mov	edx, 419				; 000001a3H
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, OFFSET FLAT:$SG7055
	call	AddLineQueueX

; 2768 :                             i += XYZMMsize;

	add	ebp, DWORD PTR XYZMMsize
	jmp	$LN79@write_win6
$LN73@write_win6:

; 2769 :                           }
; 2770 :                           else if (GetValueSp(*regist) & OP_YMM){

	test	dl, dl
	jns	$LN79@write_win6

; 2771 :                             AddLineQueueX( "%s [%r+%u+%s], %r", MOVE_UNALIGNED_INT, T_RSP, NUMQUAL i, sym_ReservedStack->name, *regist );

	mov	rax, QWORD PTR sym_ReservedStack
	mov	rdx, QWORD PTR MOVE_UNALIGNED_INT
	mov	DWORD PTR [rsp+40], r9d
	mov	rcx, QWORD PTR [rax+8]
	mov	r9d, ebp
	mov	r8d, 119				; 00000077H
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, OFFSET FLAT:$SG7058
	call	AddLineQueueX

; 2772 :                             AddLineQueueX("%r %r, %u+%s", T_DOT_SAVEYMM256, *regist, NUMQUAL i, sym_ReservedStack->name);

	mov	rax, QWORD PTR sym_ReservedStack
	movzx	r8d, WORD PTR [rdi]
	mov	rcx, QWORD PTR [rax+8]
	mov	r9d, ebp
	mov	edx, 420				; 000001a4H
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, OFFSET FLAT:$SG7059
	call	AddLineQueueX

; 2773 :                             i += XYZMMsize;

	add	ebp, DWORD PTR XYZMMsize

; 2774 :                           }
; 2775 : #if EVEXSUPP    
; 2776 :                           else (GetValueSp(*regist) & OP_ZMM){
; 2777 :                             AddLineQueueX( "%s [%r+%u+%s], %r", MOVE_UNALIGNED_INT, T_RSP, NUMQUAL i, sym_ReservedStack->name, *regist );
; 2778 :                             AddLineQueueX("%r %r, %u+%s", T_DOT_SAVEZMM512, *regist, NUMQUAL i, sym_ReservedStack->name);
; 2779 :                             i += XYZMMsize;
; 2780 :                           }
; 2781 : #endif
; 2782 :                         }
; 2783 :                     } else {

	jmp	$LN79@write_win6
$LN75@write_win6:

; 2784 :                         if ( ( 1 << GetRegNo( *regist ) ) & win64_nvxmm )  {

	movzx	ecx, BYTE PTR SpecialTable[rsi+rax*4+10]
	mov	eax, 1
	shl	eax, cl
	test	eax, 65472				; 0000ffc0H
	je	$LN79@write_win6

; 2785 :                           if (GetValueSp(*regist) & OP_XMM){

	test	r8d, r8d
	je	SHORT $LN68@write_win6

; 2786 :                             AddLineQueueX("%s [%r+%u], %r", MOVE_ALIGNED_INT, T_RSP, NUMQUAL i, *regist);

	mov	rdx, QWORD PTR MOVE_ALIGNED_INT
	mov	DWORD PTR [rsp+32], r9d
	lea	rcx, OFFSET FLAT:$SG7063
	mov	r9d, ebp
	mov	r8d, 119				; 00000077H
	call	AddLineQueueX

; 2787 :                             AddLineQueueX("%r %r, %u", T_DOT_SAVEXMM128, *regist, NUMQUAL i);

	movzx	r8d, WORD PTR [rdi]
	lea	rcx, OFFSET FLAT:$SG7064
	mov	r9d, ebp
	mov	edx, 419				; 000001a3H
	call	AddLineQueueX

; 2788 :                             i += XYZMMsize;

	add	ebp, DWORD PTR XYZMMsize
	jmp	SHORT $LN79@write_win6
$LN68@write_win6:

; 2789 :                           }
; 2790 :                           else if (GetValueSp(*regist) & OP_YMM){

	test	dl, dl
	jns	SHORT $LN79@write_win6

; 2791 :                             AddLineQueueX("%s [%r+%u], %r", MOVE_UNALIGNED_INT, T_RSP, NUMQUAL i, *regist);

	mov	rdx, QWORD PTR MOVE_UNALIGNED_INT
	mov	DWORD PTR [rsp+32], r9d
	lea	rcx, OFFSET FLAT:$SG7067
	mov	r9d, ebp
	mov	r8d, 119				; 00000077H
	call	AddLineQueueX

; 2792 :                             AddLineQueueX("%r %r, %u", T_DOT_SAVEYMM256, *regist, NUMQUAL i);

	movzx	r8d, WORD PTR [rdi]
	lea	rcx, OFFSET FLAT:$SG7068
	mov	r9d, ebp
	mov	edx, 420				; 000001a4H
	call	AddLineQueueX

; 2793 :                             i += XYZMMsize;

	add	ebp, DWORD PTR XYZMMsize
$LN79@write_win6:
	add	rdi, 2
	dec	r12d
	jne	$LL80@write_win6

; 2853 :               }
; 2854 :               for (n = 0, m = 0; n < 6; n++){

	xor	ecx, ecx
	jmp	SHORT $LN78@write_win6
$LN180@write_win6:
	xor	ecx, ecx
$LN78@write_win6:

; 2794 :                           }
; 2795 : #if EVEXSUPP    
; 2796 :                           else (GetValueSp(*regist) & OP_ZMM){
; 2797 :                             AddLineQueueX( "%s [%r+%u+%s], %r", MOVE_UNALIGNED_INT, T_RSP, NUMQUAL i, *regist );
; 2798 :                             AddLineQueueX("%r %r, %u+%s", T_DOT_SAVEZMM512, *regist, NUMQUAL i);
; 2799 :                             i += XYZMMsize;
; 2800 :                           }
; 2801 : #endif
; 2802 :                         }
; 2803 :                     }
; 2804 :                 }
; 2805 :             }
; 2806 :         }
; 2807 :     /* For VECTORCALL save vectors in the space provided */
; 2808 :         if (CurrProc->sym.langtype == LANG_VECTORCALL){

	mov	rax, QWORD PTR CurrProc
	cmp	DWORD PTR [rax+84], 8
	jne	$LN178@write_win6

; 2809 :           vectstart = info->localsize  + info->xmmsize & ~(16 - 1);

	mov	r14d, DWORD PTR [rbx+36]
	add	r14d, DWORD PTR [rbx+112]
	and	r14d, -16

; 2810 :           if (info->vecused){

	cmp	BYTE PTR [rbx+80], 0
	je	$LN178@write_win6

; 2811 :             if (info->vecregs){

	lea	r12, QWORD PTR [rbx+56]
	test	r12, r12
	je	$LN178@write_win6
	mov	esi, DWORD PTR resstack$1$[rsp]

; 2812 :               for (n = 0, m = 0, xsize = 0; n < 6; n++){

	mov	r13d, ecx
	xor	r15b, r15b
	mov	rdi, rcx
$LL62@write_win6:

; 2813 :                 xreg = info->vecregs[n];

	movzx	ebp, BYTE PTR [rdi+r12]

; 2814 :                 if (xreg == 1 && info->vecregsize[n] < 16)

	cmp	bpl, 1
	jne	SHORT $LN59@write_win6
	cmp	BYTE PTR [rdi+rbx+62], 16
	jb	$LN61@write_win6

; 2815 :                   continue;//REAL4, FLOAT and REAL8 are stored in homespace
; 2816 :                 else if (xreg)

	jmp	SHORT $LN172@write_win6
$LN59@write_win6:
	test	bpl, bpl
	je	SHORT $LN57@write_win6
$LN172@write_win6:

; 2817 : 				{  
; 2818 :                   AddLineQueueX("lea %r,[%r + %d]", T_RAX,T_RSP,vectstart  + xsize );

	mov	edx, 115				; 00000073H
	movzx	r9d, r15b
	lea	rcx, OFFSET FLAT:$SG7078
	lea	r8d, QWORD PTR [rdx+4]
	add	r9d, r14d
	call	AddLineQueueX

; 2819 :                   stackSize = info->localsize + resstack + info->vsize + info->xmmsize + 8 + info->pushed_reg * 8  + n * 8;

	mov	r11d, DWORD PTR [rbx+104]
	mov	eax, DWORD PTR [rbx+44]
	lea	ecx, DWORD PTR [r13+r11]
	lea	r8d, DWORD PTR [rax+rcx*8+8]
	add	r8d, DWORD PTR [rbx+36]
	add	r8d, esi
	add	r8d, DWORD PTR [rbx+112]

; 2820 :                   if ((stackSize & 7) != 0) stackSize = (stackSize + 7)&(-8);

	test	r8b, 7
	je	SHORT $LN56@write_win6
	add	r8d, 7
	and	r8d, -8
$LN56@write_win6:

; 2821 :                   AddLineQueueX("mov [%r + %d], %r", T_RSP, stackSize, T_RAX);

	mov	edx, 119				; 00000077H
	lea	rcx, OFFSET FLAT:$SG7080
	lea	r9d, QWORD PTR [rdx-4]
	call	AddLineQueueX

; 2822 :                   xsize += info->vecregsize[n] * xreg;

	movzx	eax, bpl
	imul	BYTE PTR [rdi+rbx+62]
	add	r15b, al
	jmp	$LN61@write_win6
$LN57@write_win6:

; 2823 :                 }
; 2824 : 				else if (info->vregs[n] != 0 && xreg == 0 && n < 4) /* JPH */

	cmp	BYTE PTR [rdi+rbx+68], 0
	je	$LN61@write_win6
	cmp	rdi, 4
	jge	$LN61@write_win6

; 2827 : 					int j = 0;
; 2828 : 					for (j = 0; j < n; j++)

	test	r13d, r13d
	mov	rax, QWORD PTR [rbx+8]
	jle	SHORT $LN51@write_win6

; 2825 : 				{
; 2826 : 					struct dsym *pp = info->paralist;

	mov	ecx, r13d
	npad	7
$LL53@write_win6:

; 2829 : 					{
; 2830 : 						if(pp) pp = pp->nextparam;

	test	rax, rax
	je	SHORT $LN52@write_win6
	mov	rax, QWORD PTR [rax+120]
$LN52@write_win6:

; 2827 : 					int j = 0;
; 2828 : 					for (j = 0; j < n; j++)

	dec	rcx
	jne	SHORT $LL53@write_win6
$LN51@write_win6:

; 2831 : 					}
; 2832 : 					if (pp)

	test	rax, rax
	je	SHORT $LN61@write_win6

; 2833 : 					{
; 2834 : 							if (pp->sym.ttype)

	mov	rax, QWORD PTR [rax+88]
	test	rax, rax
	je	SHORT $LN61@write_win6

; 2835 : 							{
; 2836 : 								if (pp->sym.ttype->e.structinfo->isHFA == 1 || pp->sym.ttype->e.structinfo->isHVA == 1 || pp->sym.ttype->e.structinfo->stype == MM128 || pp->sym.ttype->e.structinfo->stype == MM256)

	mov	rax, QWORD PTR [rax+104]
	cmp	BYTE PTR [rax+22], 1
	je	SHORT $LN46@write_win6
	cmp	BYTE PTR [rax+21], 1
	je	SHORT $LN46@write_win6
	mov	ecx, DWORD PTR [rax+16]
	cmp	ecx, 1
	je	SHORT $LN46@write_win6
	cmp	ecx, 2
	jne	SHORT $LN61@write_win6
$LN46@write_win6:

; 2837 : 								{
; 2838 : 									stackSize = info->localsize + resstack + info->vsize + info->xmmsize + 8 + info->pushed_reg * 8 + n * 8;

	mov	eax, DWORD PTR [rbx+104]
	lea	ecx, DWORD PTR [r13+rax]
	mov	eax, DWORD PTR [rbx+44]
	lea	r8d, DWORD PTR [rax+rcx*8+8]
	add	r8d, DWORD PTR [rbx+36]
	add	r8d, esi
	add	r8d, DWORD PTR [rbx+112]

; 2839 : 									if ((stackSize & 7) != 0) stackSize = (stackSize + 7)&(-8);

	test	r8b, 7
	je	SHORT $LN45@write_win6
	add	r8d, 7
	and	r8d, -8
$LN45@write_win6:

; 2840 : 									AddLineQueueX("mov [%r + %d], %r", T_RSP, stackSize, ms64_regs[n]);

	lea	rax, OFFSET FLAT:__ImageBase
	lea	rcx, OFFSET FLAT:$SG7094
	mov	edx, 119				; 00000077H
	mov	r9d, DWORD PTR ms64_regs[rax+rdi*4]
	call	AddLineQueueX
$LN61@write_win6:
	inc	rdi
	inc	r13d
	cmp	rdi, 6
	jl	$LL62@write_win6
	mov	esi, DWORD PTR vsize$1$[rsp]

; 2850 :                 if (info->vecregs[i] == 1) xyused[i] = 1;

	lea	rax, QWORD PTR xyused$[rsp]
	mov	edx, 6
$LL44@write_win6:
	movzx	ecx, BYTE PTR [r12]
	cmp	cl, 1
	jne	SHORT $LN41@write_win6
	mov	BYTE PTR [rax], cl
	jmp	SHORT $LN43@write_win6
$LN41@write_win6:

; 2851 :                 else if ((info->vecregs[i] >= 1) && (xyused[i] != 1))

	cmp	cl, 1
	jb	SHORT $LN43@write_win6
	cmp	BYTE PTR [rax], 1
	je	SHORT $LN43@write_win6

; 2852 :                   xyused[i] = 0;

	mov	BYTE PTR [rax], sil
$LN43@write_win6:

; 2841 : 									//xsize += 8;
; 2842 : 									xsize += info->vecregsize[n] * xreg;
; 2843 : 								}
; 2844 : 							}
; 2845 : 					}
; 2846 : 				}
; 2847 :               }
; 2848 :               /* set available registers to zero including the ones that are greater than 1 */
; 2849 :               for (i = 0; i < 6; i++){

	inc	r12
	inc	rax
	dec	rdx
	jne	SHORT $LL44@write_win6

; 2853 :               }
; 2854 :               for (n = 0, m = 0; n < 6; n++){

	xor	r9d, r9d
	mov	rax, -62				; ffffffffffffffc2H
	lea	r13, QWORD PTR xyused$[rsp]
	sub	rax, rbx
	lea	r15d, QWORD PTR [rdx+40]
	lea	r12, QWORD PTR [rbx+62]
	mov	QWORD PTR tv1328[rsp], rax
	mov	r8d, r9d
	npad	8
$LL38@write_win6:

; 2855 :                 xreg = info->vecregs[n];       // it can be 0, 1, 2 or 4 eg: 0, 4, 0, 2, 0, 0

	movzx	eax, BYTE PTR [r12-6]

; 2856 :                 xsize = info->vecregsize[n];   // xmm = 16, ymm = 32 or zmm = 64

	movzx	edx, BYTE PTR [r12]

; 2857 :                 m += xreg;

	add	r8d, eax
	mov	rcx, rax

; 2858 :                 if (m > 6) break;              // max 6 AVX registers

	cmp	r8d, 6
	mov	DWORD PTR m$1$[rsp], r8d
	jg	$LN178@write_win6

; 2859 :                 if (xreg == 1 && info->vecregsize[n] < 16)

	cmp	al, 1
	jne	SHORT $LN34@write_win6
	cmp	dl, 16
	jb	$LN37@write_win6

; 2860 :                   continue;                    //REAL4, FLOAT and REAL8 are stored in homespace
; 2861 :                 else if (xreg){

	jmp	SHORT $LN174@write_win6
$LN34@write_win6:
	test	al, al
	je	$LN37@write_win6
$LN174@write_win6:

; 2862 :                   switch (xsize){

	cmp	dl, 4
	je	$LN29@write_win6
	cmp	dl, 8
	je	$LN23@write_win6
	cmp	dl, 16
	je	$LN16@write_win6
	cmp	dl, 32					; 00000020H
	jne	$LN37@write_win6

; 2911 :                   case 32:
; 2912 :                     if (xreg == 1){

	cmp	al, 1
	jne	SHORT $LN7@write_win6

; 2913 :                         AddLineQueueX("vmovups ymmword ptr [rsp+%d],%r",vsize + vectstart  , T_YMM0 + n);

	lea	r8d, DWORD PTR [r15+16]
	lea	edx, DWORD PTR [r14+rsi]
	lea	rcx, OFFSET FLAT:$SG7142
	call	AddLineQueueX

; 2914 :                       xyused[n] = 1;
; 2915 :                       vsize += 32;
; 2916 :                     }
; 2917 :                     else{

	mov	r8d, DWORD PTR m$1$[rsp]
	add	esi, 32					; 00000020H
	xor	r9d, r9d
	mov	BYTE PTR [r13], 1
	jmp	$LN37@write_win6
$LN7@write_win6:

; 2918 :                       for (i = 0, j = 0; i < xreg; i++){

	test	ecx, ecx
	mov	edi, r9d
	mov	rbx, r9
	jle	$LN37@write_win6
	lea	rax, QWORD PTR xyused$[rsp]
	mov	rbp, rcx
	npad	2
$LL5@write_win6:

; 2919 :                         while (xyused[j] != 0) j++;

	cmp	BYTE PTR [rax], 0
	je	SHORT $LN1@write_win6
	npad	11
$LL2@write_win6:
	inc	rbx
	inc	edi
	cmp	BYTE PTR xyused$[rsp+rbx], 0
	jne	SHORT $LL2@write_win6
$LN1@write_win6:

; 2920 :                           AddLineQueueX("vmovups ymmword ptr [rsp+%d],%r",vsize + vectstart , T_YMM0 + j);

	lea	r8d, DWORD PTR [rdi+56]
	lea	edx, DWORD PTR [r14+rsi]
	lea	rcx, OFFSET FLAT:$SG7150
	call	AddLineQueueX

; 2921 :                         xyused[j] = 1;

	lea	rax, QWORD PTR xyused$[rsp+rbx]

; 2922 :                         vsize += 32;

	add	esi, 32					; 00000020H
	dec	rbp
	mov	BYTE PTR [rax], 1
	jne	SHORT $LL5@write_win6

; 2923 :                       }
; 2924 :                     }
; 2925 :                     break;

	mov	r8d, DWORD PTR m$1$[rsp]
	xor	r9d, r9d
	jmp	$LN37@write_win6
$LN16@write_win6:

; 2896 :                   case 16:
; 2897 :                     if (xreg == 1){

	cmp	al, 1
	jne	SHORT $LN15@write_win6

; 2898 :                         AddLineQueueX("%s oword ptr [rsp+%d],%r", MOVE_UNALIGNED_FLOAT, vsize + vectstart , T_XMM0 + n);

	mov	rdx, QWORD PTR MOVE_UNALIGNED_FLOAT
	lea	r8d, DWORD PTR [r14+rsi]
	lea	rcx, OFFSET FLAT:$SG7131
	mov	r9d, r15d
	call	AddLineQueueX

; 2899 :                       xyused[n] = 1;
; 2900 :                       vsize += 16;
; 2901 :                     }
; 2902 :                     else{

	mov	r8d, DWORD PTR m$1$[rsp]
	add	esi, 16
	xor	r9d, r9d
	mov	BYTE PTR [r13], 1
	jmp	$LN37@write_win6
$LN15@write_win6:

; 2903 :                       for (i = 0, j = 0; i < xreg; i++){

	test	ecx, ecx
	mov	edi, r9d
	mov	rbx, r9
	jle	$LN37@write_win6
	lea	rax, QWORD PTR xyused$[rsp]
	mov	rbp, rcx
$LL13@write_win6:

; 2904 :                         while (xyused[j] != 0) j++;

	cmp	BYTE PTR [rax], 0
	je	SHORT $LN9@write_win6
	npad	5
$LL10@write_win6:
	inc	rbx
	inc	edi
	cmp	BYTE PTR xyused$[rsp+rbx], 0
	jne	SHORT $LL10@write_win6
$LN9@write_win6:

; 2905 :                           AddLineQueueX("%s oword ptr [rsp+%d],%r", MOVE_UNALIGNED_FLOAT, vsize + vectstart , T_XMM0 + j);

	mov	rdx, QWORD PTR MOVE_UNALIGNED_FLOAT
	lea	r9d, DWORD PTR [rdi+40]
	lea	r8d, DWORD PTR [r14+rsi]
	lea	rcx, OFFSET FLAT:$SG7139
	call	AddLineQueueX

; 2906 :                         xyused[j] = 1;

	lea	rax, QWORD PTR xyused$[rsp+rbx]

; 2907 :                         vsize += 16;

	add	esi, 16
	dec	rbp
	mov	BYTE PTR [rax], 1
	jne	SHORT $LL13@write_win6

; 2908 :                       }
; 2909 :                     }
; 2910 :                     break;

	mov	r8d, DWORD PTR m$1$[rsp]
	xor	r9d, r9d
	jmp	$LN37@write_win6
$LN23@write_win6:

; 2875 :                           }
; 2876 :                         //}
; 2877 :                       break;
; 2878 :                     case 8:
; 2879 :                       if (xreg <= 3){

	cmp	al, 3
	ja	$LN37@write_win6

; 2880 :                         for (i = 0, j = 0; i < xreg; i++){

	test	ecx, ecx
	mov	edi, r9d
	mov	rbx, r9
	jle	$LN37@write_win6
	lea	rax, QWORD PTR xyused$[rsp]
	mov	rbp, rcx
$LL21@write_win6:

; 2881 :                           while (xyused[j] != 0) j++;

	cmp	BYTE PTR [rax], 0
	je	SHORT $LN17@write_win6
	npad	9
$LL18@write_win6:
	inc	rbx
	inc	edi
	cmp	BYTE PTR xyused$[rsp+rbx], 0
	jne	SHORT $LL18@write_win6
$LN17@write_win6:

; 2882 :                           AddLineQueueX("%s qword ptr [rsp+%d],%r", MOVE_DOUBLE, vsize + vectstart, T_XMM0 + j);

	mov	rdx, QWORD PTR MOVE_DOUBLE
	lea	r9d, DWORD PTR [rdi+40]
	lea	r8d, DWORD PTR [r14+rsi]
	lea	rcx, OFFSET FLAT:$SG7128
	call	AddLineQueueX

; 2883 :                           xyused[j] = 1;

	lea	rax, QWORD PTR xyused$[rsp+rbx]

; 2884 :                           vsize += 8;

	add	esi, 8
	dec	rbp
	mov	BYTE PTR [rax], 1
	jne	SHORT $LL21@write_win6

; 2885 :                           }
; 2886 :                         }
; 2887 :                       /* this can only happen if there is 8 real8 */
; 2888 : #if EVEXSUPP
; 2889 :                       else {
; 2890 :                         AddLineQueueX("vmovups ymmword ptr [rsp+%d],%r",vsize + vectstart , T_YMM0 + n);
; 2891 :                         vsize += 64;
; 2892 :                         xyused[n] = 1;
; 2893 :                     }
; 2894 : #endif
; 2895 :                     break;

	mov	r8d, DWORD PTR m$1$[rsp]
	xor	r9d, r9d
	jmp	SHORT $LN37@write_win6
$LN29@write_win6:

; 2863 :                     case 4:
; 2864 :                       //if (xreg == 2){
; 2865 :                       //  /* this can only happen if there is 2 real4 */
; 2866 :                       //  AddLineQueueX("vmovsd qword ptr [rsp+%d],%r", vsize + vectstart, T_XMM0 + n);
; 2867 :                       //  vsize += 8;
; 2868 :                       //  }
; 2869 :                       //else{
; 2870 :                         for (i = 0, j = 0; i < xreg; i++){

	test	ecx, ecx
	mov	edi, r9d
	mov	rbx, r9
	jle	SHORT $LN37@write_win6
	lea	rax, QWORD PTR xyused$[rsp]
	mov	rbp, rcx
$LL28@write_win6:

; 2871 :                           while (xyused[j] != 0) j++;

	cmp	BYTE PTR [rax], 0
	je	SHORT $LN24@write_win6
	npad	8
$LL25@write_win6:
	inc	rbx
	inc	edi
	cmp	BYTE PTR xyused$[rsp+rbx], 0
	jne	SHORT $LL25@write_win6
$LN24@write_win6:

; 2872 :                           AddLineQueueX("%s dword ptr [rsp+%d],%r", MOVE_SINGLE, vsize + vectstart, T_XMM0 + j);

	mov	rdx, QWORD PTR MOVE_SINGLE
	lea	r9d, DWORD PTR [rdi+40]
	lea	r8d, DWORD PTR [r14+rsi]
	lea	rcx, OFFSET FLAT:$SG7119
	call	AddLineQueueX

; 2873 :                           xyused[j] = 1;

	lea	rax, QWORD PTR xyused$[rsp+rbx]

; 2874 :                           vsize += 4;

	add	esi, 4
	dec	rbp
	mov	BYTE PTR [rax], 1
	jne	SHORT $LL28@write_win6
	mov	r8d, DWORD PTR m$1$[rsp]
	xor	r9d, r9d
$LN37@write_win6:
	mov	rax, QWORD PTR tv1328[rsp]
	inc	r12
	inc	r15d
	add	rax, r12
	inc	r13
	cmp	rax, 6
	jl	$LL38@write_win6
$LN178@write_win6:

; 2926 : #if EVEXSUPP 
; 2927 :                   case 64: 
; 2928 :                     if (xreg == 1){
; 2929 :                         AddLineQueueX("vmovups zmmword ptr [rsp+%d],%r",vsize + vectstart + xsize, T_ZMM0 + n);
; 2930 :                       xyused[n] = 1;
; 2931 :                       vsize += 64;
; 2932 :                     }
; 2933 :                     else{
; 2934 :                       for (i=0,j=0; i < xreg; i++){
; 2935 :                         while (xyused[j] != 0) j++;
; 2936 :                           AddLineQueueX("vmovups zmmword ptr [rsp+%d],%r", vsize + vectstart + xsize, T_ZMM0 + j);
; 2937 :                         xyused[j] = 1;
; 2938 :                         vsize += 64;
; 2939 :                       }
; 2940 :                     }
; 2941 :                     break;
; 2942 : #endif
; 2943 :                   }
; 2944 :                 }
; 2945 :               }
; 2946 :             }
; 2947 :           }
; 2948 :         }
; 2949 :     }
; 2950 :     AddLineQueueX( "%r", T_DOT_ENDPROLOG );

	lea	rcx, OFFSET FLAT:$SG7151
	mov	edx, 415				; 0000019fH
	mov	r15, QWORD PTR [rsp+88]
	mov	r14, QWORD PTR [rsp+96]
	mov	r13, QWORD PTR [rsp+104]
	mov	r12, QWORD PTR [rsp+112]
	mov	rdi, QWORD PTR [rsp+152]
	mov	rsi, QWORD PTR [rsp+144]
	mov	rbp, QWORD PTR [rsp+136]
	mov	rbx, QWORD PTR [rsp+128]

; 2951 : 
; 2952 :     /* v2.11: linequeue is now run in write_default_prologue() */
; 2953 :     return;
; 2954 : }

	add	rsp, 120				; 00000078H
	jmp	AddLineQueueX
write_win64_default_prologue ENDP
_TEXT	ENDS
EXTRN	LineStoreCurr:QWORD
EXTRN	list_pos:DWORD
EXTRN	szDgroup:BYTE
xdata	SEGMENT
$unwind$write_default_prologue DD 051501H
	DD	086415H
	DD	063410H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$write_default_prologue DD @imagerel(write_default_prologue#)
	DD	@imagerel(write_default_prologue#+152)
	DD	@imagerel($unwind$write_default_prologue#)
pdata	ENDS
xdata	SEGMENT
$chain$2$write_default_prologue DD 020521H
	DD	097405H
	DD	@imagerel(write_default_prologue#)
	DD	@imagerel(write_default_prologue#+152)
	DD	@imagerel($unwind$write_default_prologue#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$write_default_prologue DD @imagerel(write_default_prologue#+152)
	DD	@imagerel(write_default_prologue#+200)
	DD	@imagerel($chain$2$write_default_prologue#)
pdata	ENDS
xdata	SEGMENT
$chain$3$write_default_prologue DD 020521H
	DD	075405H
	DD	@imagerel(write_default_prologue#+152)
	DD	@imagerel(write_default_prologue#+200)
	DD	@imagerel($chain$2$write_default_prologue#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$write_default_prologue DD @imagerel(write_default_prologue#+200)
	DD	@imagerel(write_default_prologue#+471)
	DD	@imagerel($chain$3$write_default_prologue#)
pdata	ENDS
xdata	SEGMENT
$chain$4$write_default_prologue DD 021H
	DD	@imagerel(write_default_prologue#+152)
	DD	@imagerel(write_default_prologue#+200)
	DD	@imagerel($chain$2$write_default_prologue#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$write_default_prologue DD @imagerel(write_default_prologue#+471)
	DD	@imagerel(write_default_prologue#+604)
	DD	@imagerel($chain$4$write_default_prologue#)
pdata	ENDS
xdata	SEGMENT
$chain$5$write_default_prologue DD 021H
	DD	@imagerel(write_default_prologue#)
	DD	@imagerel(write_default_prologue#+152)
	DD	@imagerel($unwind$write_default_prologue#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$write_default_prologue DD @imagerel(write_default_prologue#+604)
	DD	@imagerel(write_default_prologue#+738)
	DD	@imagerel($chain$5$write_default_prologue#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
write_default_prologue PROC NEAR

; 2980 : {

	sub	rsp, 40					; 00000028H

; 2981 :     struct proc_info    *info;
; 2982 :     uint_16             *regist;
; 2983 :     uint_8              oldlinenumbers;
; 2984 :     int                 cnt;
; 2985 : #if AMD64_SUPPORT
; 2986 :     int                 resstack = 0;
; 2987 : #endif
; 2988 : 
; 2989 :     info = CurrProc->e.procinfo;

	mov	r8, QWORD PTR CurrProc
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, QWORD PTR [r8+104]
	xor	ebx, ebx

; 2990 : 
; 2991 : #if AMD64_SUPPORT
; 2992 :     if ( info->isframe ) {

	movzx	edx, BYTE PTR [rsi+128]
	test	dl, 64					; 00000040H
	je	SHORT $LN27@write_defa

; 2993 :         //DebugMsg(("write_default_prologue: isframe\n"));
; 2994 :         if ( ModuleInfo.frame_auto ) {

	bt	DWORD PTR ModuleInfo+408, 18
	jae	$LN1@write_defa

; 2995 :             write_win64_default_prologue( info );

	mov	rcx, rsi
	call	write_win64_default_prologue

; 2996 :             /* v2.11: line queue is now run here */
; 2997 :             goto runqueue;

	jmp	$runqueue$7162
$LN27@write_defa:

; 2998 :         }
; 2999 :         return( NOT_ERROR );
; 3000 :     }
; 3001 :     if ( ModuleInfo.Ofssize == USE64 && ModuleInfo.fctype == FCT_WIN64 && ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) )

	movzx	ecx, BYTE PTR ModuleInfo+404
	movzx	r10d, BYTE PTR ModuleInfo+413
	mov	r9d, DWORD PTR ModuleInfo+376
	cmp	cl, 2
	jne	SHORT $LN25@write_defa
	cmp	r9d, 2
	jne	SHORT $LN25@write_defa
	test	r10b, cl
	je	SHORT $LN25@write_defa

; 3002 :         resstack = sym_ReservedStack->value;

	mov	rax, QWORD PTR sym_ReservedStack
	mov	ebx, DWORD PTR [rax+16]
$LN25@write_defa:

; 3003 : #endif
; 3004 :     /* default processing. if no params/locals are defined, continue */
; 3005 :     if( info->forceframe == FALSE &&
; 3006 :        info->localsize == 0 &&
; 3007 :        info->stackparam == FALSE &&
; 3008 :        info->has_vararg == FALSE &&
; 3009 : #if AMD64_SUPPORT
; 3010 :        resstack == 0 &&
; 3011 : #endif
; 3012 :        info->regslist == NULL )

	test	dl, 8
	jne	SHORT $LN24@write_defa
	cmp	DWORD PTR [rsi+36], 0
	jne	SHORT $LN24@write_defa
	test	dl, 32					; 00000020H
	jne	SHORT $LN24@write_defa
	test	dl, 1
	jne	SHORT $LN24@write_defa
	test	ebx, ebx
	jne	SHORT $LN24@write_defa
	cmp	QWORD PTR [rsi], 0

; 3013 :         return( NOT_ERROR );

	je	$LN1@write_defa
$LN24@write_defa:

; 3014 : 
; 3015 :     /* v2.11: now done in write_prologue() */
; 3016 :     //info->localsize = ROUND_UP( info->localsize, CurrWordSize );
; 3017 :     regist = info->regslist;
; 3018 : 
; 3019 : #if AMD64_SUPPORT
; 3020 :     /* initialize shadow space for register params */
; 3021 :     if ( ModuleInfo.Ofssize == USE64 &&
; 3022 :         CurrProc->sym.langtype == LANG_FASTCALL &&
; 3023 :         ModuleInfo.fctype == FCT_WIN64 &&
; 3024 :         ( ModuleInfo.win64_flags & W64F_SAVEREGPARAMS ) )

	cmp	cl, 2
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, QWORD PTR [rsi]
	jne	SHORT $LN23@write_defa
	cmp	DWORD PTR [r8+84], 7
	jne	SHORT $LN23@write_defa
	cmp	r9d, 2
	jne	SHORT $LN23@write_defa
	test	r10b, 1
	je	SHORT $LN23@write_defa

; 3025 :         win64_SaveRegParams( info );

	mov	rcx, rsi
	call	win64_SaveRegParams
	mov	cl, BYTE PTR ModuleInfo+404
$LN23@write_defa:

; 3026 : #endif
; 3027 :     if( info->locallist || info->stackparam || info->has_vararg || info->forceframe ) {

	cmp	QWORD PTR [rsi+16], 0
	mov	QWORD PTR [rsp+56], rbp
	lea	rbp, OFFSET FLAT:stackreg
	jne	SHORT $LN21@write_defa
	movzx	eax, BYTE PTR [rsi+128]
	test	al, 32					; 00000020H
	jne	SHORT $LN21@write_defa
	test	al, 1
	jne	SHORT $LN21@write_defa
	test	al, 8
	je	SHORT $LN20@write_defa
$LN21@write_defa:

; 3028 : 
; 3029 :         /* write 80386 prolog code
; 3030 :          * PUSH [E|R]BP
; 3031 :          * MOV  [E|R]BP, [E|R]SP
; 3032 :          * SUB  [E|R]SP, localsize
; 3033 :          */
; 3034 : #if STACKBASESUPP
; 3035 :         if ( !info->fpo ) {

	test	BYTE PTR [rsi+128], 128			; 00000080H
	jne	SHORT $LN20@write_defa

; 3036 :             AddLineQueueX( "push %r", info->basereg );

	movzx	edx, WORD PTR [rsi+130]
	lea	rcx, OFFSET FLAT:$SG7170
	call	AddLineQueueX

; 3037 :             AddLineQueueX( "mov %r, %r", info->basereg, stackreg[ModuleInfo.Ofssize] );

	movzx	r11d, BYTE PTR ModuleInfo+404
	movzx	edx, WORD PTR [rsi+130]
	mov	r8d, DWORD PTR [rbp+r11*4]
	lea	rcx, OFFSET FLAT:$SG7171
	call	AddLineQueueX
	mov	cl, BYTE PTR ModuleInfo+404
$LN20@write_defa:

; 3038 :         }
; 3039 : #else
; 3040 :         AddLineQueueX( "push %r", basereg[ModuleInfo.Ofssize] );
; 3041 :         AddLineQueueX( "mov %r, %r", basereg[ModuleInfo.Ofssize], stackreg[ModuleInfo.Ofssize] );
; 3042 : #endif
; 3043 :     }
; 3044 : #if AMD64_SUPPORT
; 3045 :     if( resstack ) {

	test	ebx, ebx
	je	SHORT $LN19@write_defa

; 3046 :         /* in this case, push the USES registers BEFORE the stack space is reserved */
; 3047 :         if ( regist ) {

	test	rdi, rdi
	je	SHORT $LN18@write_defa

; 3048 :             for( cnt = *regist++; cnt; cnt--, regist++ )

	movzx	ebx, WORD PTR [rdi]
	add	rdi, 2
	test	ebx, ebx
	je	SHORT $LN15@write_defa
	npad	1
$LL17@write_defa:

; 3049 :                 AddLineQueueX( "push %r", *regist );

	movzx	edx, WORD PTR [rdi]
	lea	rcx, OFFSET FLAT:$SG7177
	call	AddLineQueueX
	add	rdi, 2
	dec	ebx
	jne	SHORT $LL17@write_defa

; 3048 :             for( cnt = *regist++; cnt; cnt--, regist++ )

	mov	cl, BYTE PTR ModuleInfo+404
$LN15@write_defa:

; 3050 :             regist = NULL;

	xor	edi, edi
$LN18@write_defa:

; 3051 :         }
; 3052 :         /* if no framepointer was pushed, add 8 to align stack on OWORD.
; 3053 :          * v2.12: obsolete, localsize contains correct value in this case.
; 3054 :          */
; 3055 :         //if( !(info->localsize || info->stackparam || info->has_vararg || info->forceframe ))
; 3056 :         //    AddLineQueueX( "sub %r, 8 + %s", stackreg[ModuleInfo.Ofssize], sym_ReservedStack->name );
; 3057 :         //else
; 3058 :         AddLineQueueX( "sub %r, %d + %s", stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize, sym_ReservedStack->name );

	mov	r9, QWORD PTR sym_ReservedStack
	mov	r8d, DWORD PTR [rsi+36]
	movzx	eax, cl
	mov	edx, DWORD PTR [rbp+rax*4]
	mov	r9, QWORD PTR [r9+8]
	lea	rcx, OFFSET FLAT:$SG7179
	call	AddLineQueueX

; 3059 :     } else

	jmp	SHORT $LN10@write_defa
$LN19@write_defa:

; 3060 : #endif
; 3061 :     if( info->localsize  ) {

	mov	r8d, DWORD PTR [rsi+36]
	test	r8d, r8d
	je	SHORT $LN10@write_defa

; 3062 :         /* using ADD and the 2-complement has one advantage:
; 3063 :          * it will generate short instructions up to a size of 128.
; 3064 :          * with SUB, short instructions work up to 127 only.
; 3065 :          */
; 3066 :         if ( Options.masm_compat_gencode || info->localsize == 128 )

	cmp	BYTE PTR Options+137, 0
	jne	SHORT $LN11@write_defa
	cmp	r8d, 128				; 00000080H
	je	SHORT $LN11@write_defa

; 3068 :         else
; 3069 :             AddLineQueueX( "sub %r, %d", stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize );

	movzx	eax, cl
	lea	rcx, OFFSET FLAT:$SG7186
	mov	edx, DWORD PTR [rbp+rax*4]
	call	AddLineQueueX
	jmp	SHORT $LN10@write_defa
$LN11@write_defa:

; 3067 :             AddLineQueueX( "add %r, %d", stackreg[ModuleInfo.Ofssize], NUMQUAL - info->localsize );

	movzx	eax, cl
	lea	rcx, OFFSET FLAT:$SG7184
	neg	r8d
	mov	edx, DWORD PTR [rbp+rax*4]
	call	AddLineQueueX
$LN10@write_defa:

; 3070 :     }
; 3071 : 
; 3072 :     if ( info->loadds ) {

	test	BYTE PTR [rsi+128], 16
	mov	rbp, QWORD PTR [rsp+56]
	je	SHORT $LN9@write_defa

; 3073 :         AddLineQueueX( "push %r", T_DS );

	lea	rcx, OFFSET FLAT:$SG7188
	mov	edx, 28
	call	AddLineQueueX

; 3074 :         AddLineQueueX( "mov %r, %s", T_AX, szDgroup );

	mov	ebx, 9
	lea	r8, OFFSET FLAT:szDgroup
	lea	rcx, OFFSET FLAT:$SG7189
	mov	edx, ebx
	call	AddLineQueueX

; 3075 :         AddLineQueueX( "mov %r, %r", T_DS, ModuleInfo.Ofssize ? T_EAX : T_AX );

	cmp	BYTE PTR ModuleInfo+404, 0
	mov	eax, 17
	cmovne	ebx, eax
	lea	edx, QWORD PTR [rax+11]
	lea	rcx, OFFSET FLAT:$SG7190
	mov	r8d, ebx
	call	AddLineQueueX
$LN9@write_defa:

; 3076 :     }
; 3077 : 
; 3078 :     /* Push the GPR registers of the USES clause */
; 3079 :     if ( regist ) {

	test	rdi, rdi
	je	SHORT $LN34@write_defa

; 3080 :         for( cnt = *regist++; cnt; cnt--, regist++ ) {

	movzx	ebx, WORD PTR [rdi]
	add	rdi, 2
	test	ebx, ebx
	je	SHORT $LN34@write_defa
	npad	13
$LL7@write_defa:

; 3081 :             AddLineQueueX( "push %r", *regist );

	movzx	edx, WORD PTR [rdi]
	lea	rcx, OFFSET FLAT:$SG7195
	call	AddLineQueueX
	add	rdi, 2
	dec	ebx
	jne	SHORT $LL7@write_defa
$LN34@write_defa:
	mov	rdi, QWORD PTR [rsp+72]
$runqueue$7162:

; 3082 :         }
; 3083 :     }
; 3084 : 
; 3085 : #if AMD64_SUPPORT
; 3086 : runqueue:
; 3087 : #endif
; 3088 : 
; 3089 : #if FASTPASS
; 3090 :     /* special case: generated code runs BEFORE the line.*/
; 3091 :     if ( ModuleInfo.list && UseSavedState )

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN2@write_defa
	cmp	BYTE PTR UseSavedState, 0
	je	SHORT $LN2@write_defa

; 3092 :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN3@write_defa

; 3093 :             info->prolog_list_pos = list_pos;

	mov	eax, DWORD PTR list_pos
	mov	DWORD PTR [rsi+124], eax

; 3094 :         else

	jmp	SHORT $LN2@write_defa
$LN3@write_defa:

; 3095 :             list_pos = info->prolog_list_pos;

	mov	eax, DWORD PTR [rsi+124]
	mov	DWORD PTR list_pos, eax
$LN2@write_defa:

; 3096 : #endif
; 3097 :     /* line number debug info also needs special treatment
; 3098 :      * because current line number is the first true src line
; 3099 :      * IN the proc.
; 3100 :      */
; 3101 :     oldlinenumbers = Options.line_numbers;

	movzx	ebx, BYTE PTR Options+1

; 3102 :     Options.line_numbers = FALSE; /* temporarily disable line numbers */

	mov	BYTE PTR Options+1, 0

; 3103 :     RunLineQueue();

	call	RunLineQueue

; 3104 :     Options.line_numbers = oldlinenumbers;
; 3105 : 
; 3106 : #if FASTPASS
; 3107 :     if ( ModuleInfo.list && UseSavedState && (Parse_Pass > PASS_1))

	bt	DWORD PTR ModuleInfo+408, 12
	mov	BYTE PTR Options+1, bl
	jae	SHORT $LN1@write_defa
	cmp	BYTE PTR UseSavedState, 0
	je	SHORT $LN1@write_defa
	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN1@write_defa

; 3108 :          LineStoreCurr->list_pos = list_pos;

	mov	rax, QWORD PTR LineStoreCurr
	mov	ecx, DWORD PTR list_pos
	mov	DWORD PTR [rax+12], ecx
$LN1@write_defa:
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]

; 3109 : #endif
; 3110 : 
; 3111 :     return( NOT_ERROR );

	xor	eax, eax

; 3112 : }

	add	rsp, 40					; 00000028H
	ret	0
write_default_prologue ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SetLocalOffsetsJwasm DD 01H
xdata	ENDS
pdata	SEGMENT
$pdata$SetLocalOffsetsJwasm DD @imagerel(SetLocalOffsetsJwasm#)
	DD	@imagerel(SetLocalOffsetsJwasm#+7)
	DD	@imagerel($unwind$SetLocalOffsetsJwasm#)
pdata	ENDS
xdata	SEGMENT
$chain$2$SetLocalOffsetsJwasm DD 062b21H
	DD	04742bH
	DD	036411H
	DD	013405H
	DD	@imagerel(SetLocalOffsetsJwasm#)
	DD	@imagerel(SetLocalOffsetsJwasm#+7)
	DD	@imagerel($unwind$SetLocalOffsetsJwasm#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$SetLocalOffsetsJwasm DD @imagerel(SetLocalOffsetsJwasm#+7)
	DD	@imagerel(SetLocalOffsetsJwasm#+111)
	DD	@imagerel($chain$2$SetLocalOffsetsJwasm#)
pdata	ENDS
xdata	SEGMENT
$chain$3$SetLocalOffsetsJwasm DD 020521H
	DD	025405H
	DD	@imagerel(SetLocalOffsetsJwasm#+7)
	DD	@imagerel(SetLocalOffsetsJwasm#+111)
	DD	@imagerel($chain$2$SetLocalOffsetsJwasm#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$SetLocalOffsetsJwasm DD @imagerel(SetLocalOffsetsJwasm#+111)
	DD	@imagerel(SetLocalOffsetsJwasm#+164)
	DD	@imagerel($chain$3$SetLocalOffsetsJwasm#)
pdata	ENDS
xdata	SEGMENT
$chain$4$SetLocalOffsetsJwasm DD 021H
	DD	@imagerel(SetLocalOffsetsJwasm#+7)
	DD	@imagerel(SetLocalOffsetsJwasm#+111)
	DD	@imagerel($chain$2$SetLocalOffsetsJwasm#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$SetLocalOffsetsJwasm DD @imagerel(SetLocalOffsetsJwasm#+164)
	DD	@imagerel(SetLocalOffsetsJwasm#+210)
	DD	@imagerel($chain$4$SetLocalOffsetsJwasm#)
pdata	ENDS
xdata	SEGMENT
$chain$5$SetLocalOffsetsJwasm DD 040021H
	DD	047400H
	DD	036400H
	DD	@imagerel(SetLocalOffsetsJwasm#)
	DD	@imagerel(SetLocalOffsetsJwasm#+7)
	DD	@imagerel($unwind$SetLocalOffsetsJwasm#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$SetLocalOffsetsJwasm DD @imagerel(SetLocalOffsetsJwasm#+210)
	DD	@imagerel(SetLocalOffsetsJwasm#+331)
	DD	@imagerel($chain$5$SetLocalOffsetsJwasm#)
pdata	ENDS
xdata	SEGMENT
$chain$6$SetLocalOffsetsJwasm DD 020021H
	DD	036400H
	DD	@imagerel(SetLocalOffsetsJwasm#)
	DD	@imagerel(SetLocalOffsetsJwasm#+7)
	DD	@imagerel($unwind$SetLocalOffsetsJwasm#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$SetLocalOffsetsJwasm DD @imagerel(SetLocalOffsetsJwasm#+331)
	DD	@imagerel(SetLocalOffsetsJwasm#+469)
	DD	@imagerel($chain$6$SetLocalOffsetsJwasm#)
pdata	ENDS
xdata	SEGMENT
$chain$7$SetLocalOffsetsJwasm DD 021H
	DD	@imagerel(SetLocalOffsetsJwasm#)
	DD	@imagerel(SetLocalOffsetsJwasm#+7)
	DD	@imagerel($unwind$SetLocalOffsetsJwasm#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$SetLocalOffsetsJwasm DD @imagerel(SetLocalOffsetsJwasm#+469)
	DD	@imagerel(SetLocalOffsetsJwasm#+480)
	DD	@imagerel($chain$7$SetLocalOffsetsJwasm#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
info$ = 8
SetLocalOffsetsJwasm PROC NEAR

; 3128 : 	struct dsym *curr;
; 3129 : #if AMD64_SUPPORT || STACKBASESUPP
; 3130 : 	int         cntxmm = 0;
; 3131 : 	int         cntstd = 0;
; 3132 : 	int         start = 0;
; 3133 : #endif
; 3134 : #if AMD64_SUPPORT
; 3135 : 	int         rspalign = FALSE;
; 3136 : #endif
; 3137 : 	int         align = CurrWordSize;
; 3138 : 
; 3139 : #if AMD64_SUPPORT
; 3140 : 	if (info->isframe || (ModuleInfo.fctype == FCT_WIN64 && (ModuleInfo.win64_flags & W64F_AUTOSTACKSP))) {

	movzx	eax, BYTE PTR ModuleInfo+413
	mov	QWORD PTR [rsp+8], rbx
	movzx	ebx, BYTE PTR ModuleInfo+406
	mov	QWORD PTR [rsp+24], rsi
	mov	r8, rcx
	movzx	ecx, BYTE PTR [rcx+128]
	xor	r10d, r10d
	xor	r11d, r11d
	xor	esi, esi
	test	cl, 64					; 00000040H
	mov	QWORD PTR [rsp+32], rdi
	mov	edi, ebx
	jne	SHORT $LN29@SetLocalOf
	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN28@SetLocalOf
	test	al, 2
	je	SHORT $LN28@SetLocalOf
$LN29@SetLocalOf:

; 3141 : 		rspalign = TRUE;
; 3142 : 		if (ModuleInfo.win64_flags & W64F_STACKALIGN16)

	test	al, 4
	mov	eax, 16
	mov	esi, 1
	cmovne	edi, eax
$LN28@SetLocalOf:

; 3143 : 			align = 16;
; 3144 : 	}
; 3145 : #endif
; 3146 : #if AMD64_SUPPORT || STACKBASESUPP
; 3147 : 	/* in 64-bit, if the FRAME attribute is set, the space for the registers
; 3148 : 	* saved by the USES clause is located ABOVE the local variables!
; 3149 : 	* v2.09: if stack space is to be reserved for INVOKE ( option WIN64:2 ),
; 3150 : 	* the registers are also saved ABOVE the local variables.
; 3151 : 	*/
; 3152 : 	if (
; 3153 : #if STACKBASESUPP
; 3154 : 		info->fpo
; 3155 : #endif
; 3156 : #if AMD64_SUPPORT
; 3157 : 		|| rspalign
; 3158 : #endif
; 3159 : 		) {

	test	cl, cl
	js	SHORT $LN26@SetLocalOf
	test	esi, esi
	je	SHORT $LN43@SetLocalOf
$LN26@SetLocalOf:

; 3160 : 		/* count registers to be saved ABOVE local variables.
; 3161 : 		* v2.06: the list may contain xmm registers, which have size 16!
; 3162 : 		*/
; 3163 : 		if (info->regslist) {

	mov	rdx, QWORD PTR [r8]
	test	rdx, rdx
	je	SHORT $LN22@SetLocalOf

; 3164 : 			int         cnt;
; 3165 : 			uint_16     *regs;
; 3166 : 			for (regs = info->regslist, cnt = *regs++; cnt; cnt--, regs++)

	movzx	r9d, WORD PTR [rdx]
	add	rdx, 2
	test	r9d, r9d
	je	SHORT $LN22@SetLocalOf
	mov	QWORD PTR [rsp+16], rbp
	lea	rbp, OFFSET FLAT:SpecialTable
	npad	5
$LL24@SetLocalOf:

; 3167 : 				if (GetValueSp(*regs) & OP_XMM)

	movzx	eax, WORD PTR [rdx]
	lea	rcx, QWORD PTR [rax+rax*2]
	test	BYTE PTR [rbp+rcx*4], 32		; 00000020H
	je	SHORT $LN21@SetLocalOf

; 3168 : 					cntxmm++;

	inc	r10d

; 3169 : 				else

	jmp	SHORT $LN23@SetLocalOf
$LN21@SetLocalOf:

; 3170 : 					cntstd++;

	inc	r11d
$LN23@SetLocalOf:

; 3164 : 			int         cnt;
; 3165 : 			uint_16     *regs;
; 3166 : 			for (regs = info->regslist, cnt = *regs++; cnt; cnt--, regs++)

	add	rdx, 2
	dec	r9d
	jne	SHORT $LL24@SetLocalOf
	mov	rbp, QWORD PTR [rsp+16]
$LN22@SetLocalOf:

; 3171 : 		}
; 3172 : 		/* in case there's no frame register, adjust start offset. */
; 3173 : 		//if ((info->fpo || (info->parasize == 0 && info->locallist == NULL)))
; 3174 : 			//start = CurrWordSize;
; 3175 : #if AMD64_SUPPORT
; 3176 : 		if (rspalign) {

	test	esi, esi
	je	SHORT $LN43@SetLocalOf

; 3177 : 			info->localsize = start + cntstd * CurrWordSize;

	imul	ebx, r11d

; 3178 : 			if (cntxmm) {

	test	r10d, r10d
	mov	DWORD PTR [r8+36], ebx
	je	SHORT $LN43@SetLocalOf

; 3179 : 				info->localsize += 16 * cntxmm;

	add	r10d, r10d

; 3180 : 				info->localsize = ROUND_UP(info->localsize, 16);

	lea	eax, DWORD PTR [rbx+r10*8+15]
	and	eax, -16				; fffffff0H
	mov	DWORD PTR [r8+36], eax
$LN43@SetLocalOf:

; 3181 : 			}
; 3182 : 		}
; 3183 : #endif
; 3184 : 		DebugMsg1(("SetLocalOffsets(%s): cntxmm=%u cntstd=%u start=%u align=%u localsize=%u\n", CurrProc->sym.name, cntxmm, cntstd, start, align, info->localsize));
; 3185 : 	}
; 3186 : #endif
; 3187 : 
; 3188 : 	/* scan the locals list and set member sym.offset */
; 3189 : 	for (curr = info->locallist; curr; curr = curr->nextlocal) {

	mov	r9, QWORD PTR [r8+16]
	mov	rbx, QWORD PTR [rsp+8]
	test	r9, r9
	je	SHORT $LN15@SetLocalOf
$LL17@SetLocalOf:

; 3190 : 		uint_32 itemsize = (curr->sym.total_size == 0 ? 0 : curr->sym.total_size / curr->sym.total_length);

	mov	ecx, DWORD PTR [r9+64]
	test	ecx, ecx
	jne	SHORT $LN33@SetLocalOf
	xor	eax, eax
	jmp	SHORT $LN34@SetLocalOf
$LN33@SetLocalOf:
	xor	edx, edx
	mov	eax, ecx
	div	DWORD PTR [r9+72]
$LN34@SetLocalOf:

; 3191 : 		info->localsize += curr->sym.total_size;

	add	DWORD PTR [r8+36], ecx

; 3192 : 		if (itemsize > align)

	cmp	eax, edi
	mov	ecx, DWORD PTR [r8+36]
	jbe	SHORT $LN14@SetLocalOf

; 3193 : 			info->localsize = ROUND_UP(info->localsize, align);

	lea	eax, DWORD PTR [rdi-1]
	lea	ecx, DWORD PTR [rcx+rdi-1]
	not	eax
	and	ecx, eax
	mov	DWORD PTR [r8+36], ecx
	jmp	SHORT $LN12@SetLocalOf
$LN14@SetLocalOf:

; 3194 : 		else if (itemsize) /* v2.04: skip if size == 0 */

	test	eax, eax
	je	SHORT $LN12@SetLocalOf

; 3195 : 			info->localsize = ROUND_UP(info->localsize, itemsize);

	lea	ecx, DWORD PTR [rcx+rax-1]
	dec	eax
	not	eax
	and	ecx, eax
	mov	DWORD PTR [r8+36], ecx
$LN12@SetLocalOf:

; 3196 : 		curr->sym.offset = -info->localsize;

	mov	eax, DWORD PTR [r8+36]
	neg	eax
	mov	DWORD PTR [r9+16], eax
	mov	r9, QWORD PTR [r9+120]
	test	r9, r9
	jne	SHORT $LL17@SetLocalOf
$LN15@SetLocalOf:

; 3197 : 		DebugMsg1(("SetLocalOffsets(%s): offset of %s (size=%u) set to %d\n", CurrProc->sym.name, curr->sym.name, curr->sym.total_size, curr->sym.offset));
; 3198 : 	}
; 3199 : 
; 3200 : 	/* v2.11: localsize must be rounded before offset adjustment if fpo */
; 3201 : 	info->localsize = ROUND_UP(info->localsize, CurrWordSize);

	movzx	ecx, BYTE PTR ModuleInfo+406
	mov	eax, DWORD PTR [r8+36]
	mov	rdi, QWORD PTR [rsp+32]
	lea	edx, DWORD PTR [rcx+rax-1]
	lea	eax, DWORD PTR [rcx-1]
	not	eax
	and	edx, eax

; 3202 : #if AMD64_SUPPORT
; 3203 : 	/* RSP 16-byte alignment? */
; 3204 : 	if (rspalign) {

	test	esi, esi
	mov	DWORD PTR [r8+36], edx
	je	SHORT $LN11@SetLocalOf

; 3205 : 		info->localsize = ROUND_UP(info->localsize, 16);

	lea	eax, DWORD PTR [rdx+15]
	and	eax, -16				; fffffff0H
	mov	DWORD PTR [r8+36], eax
$LN11@SetLocalOf:

; 3206 : 	}
; 3207 : #endif
; 3208 : 
; 3209 : 	DebugMsg1(("SetLocalOffsets(%s): localsize=%u after processing locals\n", CurrProc->sym.name, info->localsize));
; 3210 : 
; 3211 : #if STACKBASESUPP
; 3212 : 	/* v2.11: recalculate offsets for params and locals if there's no frame pointer.
; 3213 : 	* Problem in 64-bit: option win64:2 triggers the "stack space reservation" feature -
; 3214 : 	* but the final value of this space is known at the procedure's END only.
; 3215 : 	* Hence in this case the values calculated below are "preliminary".
; 3216 : 	*/
; 3217 : 	if (info->fpo) {

	test	BYTE PTR [r8+128], 128			; 00000080H
	je	SHORT $LN2@SetLocalOf

; 3218 : 		unsigned localadj;
; 3219 : 		unsigned paramadj;
; 3220 : #if AMD64_SUPPORT
; 3221 : 		if (rspalign) {

	test	esi, esi
	je	SHORT $LN9@SetLocalOf

; 3222 : 			localadj = info->localsize;

	mov	r9d, DWORD PTR [r8+36]

; 3223 : 			paramadj = info->localsize - CurrWordSize - start;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	edx, r9d
	sub	edx, eax

; 3224 : 		}
; 3225 : 		else {

	jmp	SHORT $LN8@SetLocalOf
$LN9@SetLocalOf:

; 3226 : #endif
; 3227 : 			localadj = info->localsize + cntstd * CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	ecx, DWORD PTR [r8+36]

; 3228 : 			paramadj = info->localsize + cntstd * CurrWordSize - CurrWordSize;

	lea	edx, DWORD PTR [r11-1]
	mov	r9d, eax
	imul	edx, eax
	imul	r9d, r11d
	add	r9d, ecx
	add	edx, ecx
$LN8@SetLocalOf:

; 3229 : #if AMD64_SUPPORT
; 3230 : 		}
; 3231 : #endif
; 3232 : 		DebugMsg1(("SetLocalOffsets(%s): FPO, adjusting offsets\n", CurrProc->sym.name));
; 3233 : 		/* subtract CurrWordSize value for params, since no space is required to save the frame pointer value */
; 3234 : 		for (curr = info->locallist; curr; curr = curr->nextlocal) {

	mov	rax, QWORD PTR [r8+16]
	test	rax, rax
	je	SHORT $LN5@SetLocalOf
	npad	4
$LL7@SetLocalOf:

; 3235 : 			DebugMsg1(("SetLocalOffsets(%s): FPO, offset for %s %4d -> %4d\n", CurrProc->sym.name, curr->sym.name, curr->sym.offset, curr->sym.offset + localadj));
; 3236 : 			curr->sym.offset += localadj;

	add	DWORD PTR [rax+16], r9d
	mov	rax, QWORD PTR [rax+120]
	test	rax, rax
	jne	SHORT $LL7@SetLocalOf
$LN5@SetLocalOf:

; 3237 : 		}
; 3238 : 		for (curr = info->paralist; curr; curr = curr->nextparam) {

	mov	rax, QWORD PTR [r8+8]
	test	rax, rax
	je	SHORT $LN2@SetLocalOf
	npad	10
$LL4@SetLocalOf:

; 3239 : 			DebugMsg1(("SetLocalOffsets(%s): FPO, offset for %s %4d -> %4d\n", CurrProc->sym.name, curr->sym.name, curr->sym.offset, curr->sym.offset + paramadj));
; 3240 : 			curr->sym.offset += paramadj;

	add	DWORD PTR [rax+16], edx
	mov	rax, QWORD PTR [rax+120]
	test	rax, rax
	jne	SHORT $LL4@SetLocalOf
$LN2@SetLocalOf:

; 3241 : 		}
; 3242 : 	}
; 3243 : #endif
; 3244 : 
; 3245 : #if AMD64_SUPPORT
; 3246 : 	/* v2.12: if the space used for register saves has been added to localsize,
; 3247 : 	* the part that covers "pushed" GPRs has to be subtracted now, before prologue code is generated.
; 3248 : 	*/
; 3249 : 	if (rspalign) {

	test	esi, esi
	mov	rsi, QWORD PTR [rsp+24]
	je	SHORT $LN1@SetLocalOf

; 3250 : 		info->localsize -= cntstd * 8 + start;

	imul	r11d, -8				; fffffff8H
	add	DWORD PTR [r8+36], r11d
$LN1@SetLocalOf:

; 3251 : 		DebugMsg1(("SetLocalOffsets(%s): final localsize=%u\n", CurrProc->sym.name, info->localsize));
; 3252 : 	}
; 3253 : #endif
; 3254 : }

	ret	0
SetLocalOffsetsJwasm ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SetLocalOffsets DD 092b01H
	DD	0d742bH
	DD	0c6413H
	DD	0b540eH
	DD	0a3409H
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetLocalOffsets DD @imagerel(SetLocalOffsets#)
	DD	@imagerel(SetLocalOffsets#+75)
	DD	@imagerel($unwind$SetLocalOffsets#)
pdata	ENDS
xdata	SEGMENT
$chain$5$SetLocalOffsets DD 042a21H
	DD	07d42aH
	DD	08c405H
	DD	@imagerel(SetLocalOffsets#)
	DD	@imagerel(SetLocalOffsets#+75)
	DD	@imagerel($unwind$SetLocalOffsets#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$SetLocalOffsets DD @imagerel(SetLocalOffsets#+75)
	DD	@imagerel(SetLocalOffsets#+227)
	DD	@imagerel($chain$5$SetLocalOffsets#)
pdata	ENDS
xdata	SEGMENT
$chain$6$SetLocalOffsets DD 020021H
	DD	07d400H
	DD	@imagerel(SetLocalOffsets#)
	DD	@imagerel(SetLocalOffsets#+75)
	DD	@imagerel($unwind$SetLocalOffsets#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$SetLocalOffsets DD @imagerel(SetLocalOffsets#+227)
	DD	@imagerel(SetLocalOffsets#+368)
	DD	@imagerel($chain$6$SetLocalOffsets#)
pdata	ENDS
xdata	SEGMENT
$chain$7$SetLocalOffsets DD 021H
	DD	@imagerel(SetLocalOffsets#)
	DD	@imagerel(SetLocalOffsets#+75)
	DD	@imagerel($unwind$SetLocalOffsets#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$SetLocalOffsets DD @imagerel(SetLocalOffsets#+368)
	DD	@imagerel(SetLocalOffsets#+801)
	DD	@imagerel($chain$7$SetLocalOffsets#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
paramadj$7308 = 32
info$ = 80
SetLocalOffsets PROC NEAR

; 3259 : {

	sub	rsp, 72					; 00000048H
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+88], rbp
	mov	QWORD PTR [rsp+96], rsi

; 3260 :     struct dsym *curr;
; 3261 : #if AMD64_SUPPORT || STACKBASESUPP
; 3262 :     int         cntxmm = 0;
; 3263 :     int         cntstd = 0;
; 3264 :     int         start = 0;

	xor	esi, esi
	xor	r11d, r11d
	xor	ebx, ebx

; 3265 :     uint_16             *regist;
; 3266 :     int                 cnt;
; 3267 : 
; 3268 : #endif
; 3269 : #if AMD64_SUPPORT
; 3270 :     unsigned char       xmmflag = 1;
; 3271 :     unsigned char       ymmflag = 0;

	xor	r10b, r10b

; 3272 :     int         rspalign = FALSE;

	xor	ebp, ebp

; 3273 : #endif
; 3274 :     int         align = CurrWordSize;
; 3275 : #if EVEXSUPP
; 3276 :     unsigned char       zmmflag = 0;
; 3277 : #endif
; 3278 :     //if ( Parse_Pass != PASS_1 ) /* everything is done in pass 1 */
; 3279 :     //    return;
; 3280 : 
; 3281 : 	if (!(ModuleInfo.win64_flags & W64F_SMART))

	test	BYTE PTR ModuleInfo+413, 8
	mov	QWORD PTR [rsp+104], rdi
	movzx	edi, BYTE PTR ModuleInfo+406
	mov	r8, rcx
	jne	SHORT $LN57@SetLocalOf@2

; 3282 : 	{
; 3283 : 		SetLocalOffsetsJwasm(info);

	call	SetLocalOffsetsJwasm

; 3284 : 		return;

	jmp	$LN1@SetLocalOf@2
$LN57@SetLocalOf@2:

; 3285 : 	}
; 3286 : 
; 3287 : #if AMD64_SUPPORT
; 3288 :     regist = info->regslist;
; 3289 :     if ( info->isframe || ( ModuleInfo.fctype == FCT_WIN64 && ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) ) ) {

	test	BYTE PTR [rcx+128], 64			; 00000040H
	mov	rdx, QWORD PTR [rcx]
	mov	QWORD PTR [rsp+64], r12
	mov	r12d, 1
	jne	SHORT $LN55@SetLocalOf@2
	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN56@SetLocalOf@2
	test	BYTE PTR ModuleInfo+413, 2
	je	SHORT $LN56@SetLocalOf@2
$LN55@SetLocalOf@2:

; 3290 :         rspalign = TRUE;

	mov	ebp, r12d
$LN56@SetLocalOf@2:

; 3291 : //        if ( ModuleInfo.win64_flags & W64F_STACKALIGN16 )
; 3292 :   //          align = 16;
; 3293 :     }
; 3294 : #endif
; 3295 : #if AMD64_SUPPORT || STACKBASESUPP
; 3296 :     /* in 64-bit, if the FRAME attribute is set, the space for the registers
; 3297 :      * saved by the USES clause is located ABOVE the local variables!
; 3298 :      * v2.09: if stack space is to be reserved for INVOKE ( option WIN64:2 ),
; 3299 :      * the registers are also saved ABOVE the local variables.
; 3300 :      */
; 3301 :     if (info->regslist){

	test	rdx, rdx
	mov	QWORD PTR [rsp+56], r13
	lea	r13, OFFSET FLAT:SpecialTable
	je	SHORT $LN47@SetLocalOf@2

; 3302 :       for (cnt = *regist++; cnt; cnt--, regist++) {

	movzx	r9d, WORD PTR [rdx]
	add	rdx, 2
	test	r9d, r9d
	je	SHORT $LN47@SetLocalOf@2
	npad	5
$LL53@SetLocalOf@2:

; 3303 :         if (GetValueSp(*regist) & OP_XMM)

	movzx	eax, WORD PTR [rdx]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	eax, DWORD PTR [r13+rcx*4]
	test	al, 32					; 00000020H
	jne	SHORT $LN52@SetLocalOf@2

; 3304 :           xmmflag = 1;
; 3305 :         else if (GetValueSp(*regist) & OP_YMM){

	test	al, 128					; 00000080H
	movzx	r10d, r10b
	cmovne	r10d, r12d
$LN52@SetLocalOf@2:
	add	rdx, 2
	dec	r9d
	jne	SHORT $LL53@SetLocalOf@2

; 3306 :           ymmflag = 1;
; 3307 :         }
; 3308 : #if EVEXSUPP    
; 3309 :         else if (GetValueSp(*regist) & OP_ZMM){
; 3310 :           zmmflag = 1;
; 3311 :         }
; 3312 : #endif
; 3313 :       }
; 3314 :     }
; 3315 :     if (ymmflag) XYZMMsize = 32;

	test	r10b, r10b
	je	SHORT $LN47@SetLocalOf@2
	mov	r10d, 32				; 00000020H
	mov	DWORD PTR XYZMMsize, r10d
	jmp	SHORT $LN46@SetLocalOf@2
$LN47@SetLocalOf@2:

; 3316 :     else XYZMMsize = 16;

	mov	r10d, 16
	mov	DWORD PTR XYZMMsize, r10d
$LN46@SetLocalOf@2:

; 3317 : 
; 3318 :     if (
; 3319 : #if STACKBASESUPP
; 3320 :         info->fpo
; 3321 : #endif
; 3322 : #if AMD64_SUPPORT
; 3323 :         || rspalign
; 3324 : #endif
; 3325 :        ) {

	test	BYTE PTR [r8+128], 128			; 00000080H
	mov	r12, QWORD PTR [rsp+64]
	jne	SHORT $LN44@SetLocalOf@2
	test	ebp, ebp
	je	SHORT $LN33@SetLocalOf@2
$LN44@SetLocalOf@2:

; 3326 :         /* count registers to be saved ABOVE local variables.
; 3327 :          * v2.06: the list may contain xmm registers, which have size 16!
; 3328 :          */
; 3329 :         if ( info->regslist ) {

	mov	rdx, QWORD PTR [r8]
	test	rdx, rdx
	je	SHORT $LN40@SetLocalOf@2

; 3330 :             int         cnt;
; 3331 :             uint_16     *regs;
; 3332 :             for( regs = info->regslist, cnt = *regs++; cnt; cnt--, regs++ )

	movzx	r9d, WORD PTR [rdx]
	add	rdx, 2
	test	r9d, r9d
	je	SHORT $LN40@SetLocalOf@2
	npad	4
$LL42@SetLocalOf@2:

; 3333 :                 if (( GetValueSp( *regs ) & OP_XMM )||( GetValueSp( *regs ) & OP_YMM )
; 3334 : #if EVEXSUPP    
; 3335 :                   || ( GetValueSp( *regs ) & OP_ZMM )
; 3336 : #endif
; 3337 :                 )cntxmm++;

	movzx	eax, WORD PTR [rdx]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	eax, DWORD PTR [r13+rcx*4]
	test	al, 32					; 00000020H
	jne	SHORT $LN38@SetLocalOf@2
	test	al, al
	js	SHORT $LN38@SetLocalOf@2

; 3338 :                 else
; 3339 :                   cntstd++;

	inc	ebx
	jmp	SHORT $LN41@SetLocalOf@2
$LN38@SetLocalOf@2:

; 3333 :                 if (( GetValueSp( *regs ) & OP_XMM )||( GetValueSp( *regs ) & OP_YMM )
; 3334 : #if EVEXSUPP    
; 3335 :                   || ( GetValueSp( *regs ) & OP_ZMM )
; 3336 : #endif
; 3337 :                 )cntxmm++;

	inc	r11d
$LN41@SetLocalOf@2:

; 3330 :             int         cnt;
; 3331 :             uint_16     *regs;
; 3332 :             for( regs = info->regslist, cnt = *regs++; cnt; cnt--, regs++ )

	add	rdx, 2
	dec	r9d
	jne	SHORT $LL42@SetLocalOf@2
$LN40@SetLocalOf@2:

; 3340 :         }        
; 3341 :         /* in case there's no frame register, adjust start offset. */
; 3342 :         if ( info->parasize == 0 && info->locallist == NULL  )

	cmp	DWORD PTR [r8+32], esi
	jne	SHORT $LN36@SetLocalOf@2
	cmp	QWORD PTR [r8+16], rsi
	cmove	esi, edi
$LN36@SetLocalOf@2:

; 3343 :             start = CurrWordSize;
; 3344 :         if (info->fpo && !(ModuleInfo.win64_flags & W64F_SMART)) start = CurrWordSize;
; 3345 : #if AMD64_SUPPORT
; 3346 :         if (ModuleInfo.win64_flags & W64F_SMART){
; 3347 :           //info->localsize += start; //TOREMOVE?
; 3348 :           cntstd = info->pushed_reg;
; 3349 :           if (rspalign && cntxmm) {

	test	ebp, ebp
	mov	ebx, DWORD PTR [r8+104]
	je	SHORT $LN33@SetLocalOf@2
	test	r11d, r11d
	je	SHORT $LN33@SetLocalOf@2

; 3350 :               if (!(cntstd & 1)) info->localsize += 8;

	test	bl, 1
	jne	SHORT $LN32@SetLocalOf@2
	add	DWORD PTR [r8+36], 8
	mov	r10d, DWORD PTR XYZMMsize
$LN32@SetLocalOf@2:

; 3351 :               info->localsize += XYZMMsize * cntxmm;

	imul	r10d, r11d
	add	DWORD PTR [r8+36], r10d
$LN33@SetLocalOf@2:

; 3352 :               }
; 3353 :            }
; 3354 :         else 
; 3355 :         {
; 3356 :           if (rspalign) {
; 3357 :             info->localsize = start + cntstd * CurrWordSize;
; 3358 :             if (cntxmm) {
; 3359 :               info->localsize += XYZMMsize * cntxmm;
; 3360 :               info->localsize = ROUND_UP(info->localsize, 16);
; 3361 :             }
; 3362 :           }
; 3363 :         }
; 3364 : #endif
; 3365 :         DebugMsg1(("SetLocalOffsets(%s): cntxmm=%u cntstd=%u start=%u align=%u localsize=%u\n", CurrProc->sym.name, cntxmm, cntstd, start, align, info->localsize ));
; 3366 :     }
; 3367 : #endif
; 3368 : 
; 3369 :     /* scan the locals list and set member sym.offset */
; 3370 :     for( curr = info->locallist; curr; curr = curr->nextlocal ) {

	mov	r9, QWORD PTR [r8+16]
	mov	r13, QWORD PTR [rsp+56]

; 3384 :            if (!(cntstd & 1) && cntxmm )

	movsxd	r11, r11d
	test	r9, r9
	je	$LN26@SetLocalOf@2
	npad	4
$LL28@SetLocalOf@2:

; 3371 :         uint_32 itemsize = ( curr->sym.total_size == 0 ? 0 : curr->sym.total_size / curr->sym.total_length );

	mov	r10d, DWORD PTR [r9+64]
	test	r10d, r10d
	jne	SHORT $LN60@SetLocalOf@2
	xor	edx, edx
	jmp	SHORT $LN61@SetLocalOf@2
$LN60@SetLocalOf@2:
	xor	edx, edx
	mov	eax, r10d
	div	DWORD PTR [r9+72]
	mov	edx, eax
$LN61@SetLocalOf@2:

; 3372 :         if (ModuleInfo.win64_flags & W64F_SMART){

	test	BYTE PTR ModuleInfo+413, 8
	je	SHORT $LN25@SetLocalOf@2

; 3373 :           int n = 0;

	xor	ecx, ecx

; 3374 :           if (curr->sym.isarray) n = curr->sym.total_size & 0x7;

	test	BYTE PTR [r9+49], 2
	je	SHORT $LN24@SetLocalOf@2
	mov	ecx, r10d
	and	ecx, 7
$LN24@SetLocalOf@2:

; 3375 :           curr->sym.offset = info->localsize + n; //that works

	add	ecx, DWORD PTR [r8+36]
	mov	DWORD PTR [r9+16], ecx
$LN25@SetLocalOf@2:

; 3376 :         }
; 3377 :         info->localsize += curr->sym.total_size;

	add	DWORD PTR [r8+36], r10d

; 3378 :         if ( itemsize > align )

	cmp	edx, edi
	mov	eax, DWORD PTR [r8+36]
	jbe	SHORT $LN23@SetLocalOf@2

; 3379 :             info->localsize = ROUND_UP( info->localsize, align );

	lea	ecx, DWORD PTR [rax+rdi-1]
	lea	eax, DWORD PTR [rdi-1]
	not	eax
	and	ecx, eax
	mov	DWORD PTR [r8+36], ecx
	jmp	SHORT $LN21@SetLocalOf@2
$LN23@SetLocalOf@2:

; 3380 :         else if ( itemsize ) /* v2.04: skip if size == 0 */

	test	edx, edx
	je	SHORT $LN21@SetLocalOf@2

; 3381 :            info->localsize = ROUND_UP( info->localsize, itemsize );

	lea	ecx, DWORD PTR [rax+rdx-1]
	lea	eax, DWORD PTR [rdx-1]
	not	eax
	and	ecx, eax
	mov	DWORD PTR [r8+36], ecx
$LN21@SetLocalOf@2:

; 3382 :         /* HJWasm 2.21 fix 16 nyte alignment */
; 3383 :         if (ModuleInfo.win64_flags & W64F_SMART){

	test	BYTE PTR ModuleInfo+413, 8
	je	SHORT $LN20@SetLocalOf@2

; 3384 :            if (!(cntstd & 1) && cntxmm )

	test	bl, 1
	jne	SHORT $LN27@SetLocalOf@2
	test	r11, r11
	je	SHORT $LN27@SetLocalOf@2

; 3385 :            curr->sym.offset -= 8;   //here is the fix

	add	DWORD PTR [r9+16], -8

; 3386 :           }
; 3387 :         else

	jmp	SHORT $LN27@SetLocalOf@2
$LN20@SetLocalOf@2:

; 3388 :            curr->sym.offset = - info->localsize;

	mov	eax, DWORD PTR [r8+36]
	neg	eax
	mov	DWORD PTR [r9+16], eax
$LN27@SetLocalOf@2:
	mov	r9, QWORD PTR [r9+120]
	test	r9, r9
	jne	$LL28@SetLocalOf@2
$LN26@SetLocalOf@2:

; 3389 :         DebugMsg1(("SetLocalOffsets(%s): offset of %s (size=%u) set to %d\n", CurrProc->sym.name, curr->sym.name, curr->sym.total_size, curr->sym.offset));
; 3390 :     }
; 3391 : 
; 3392 :     /* v2.11: localsize must be rounded before offset adjustment if fpo */
; 3393 :     if (!(ModuleInfo.win64_flags & W64F_SMART))

	test	BYTE PTR ModuleInfo+413, 8
	jne	SHORT $LN17@SetLocalOf@2

; 3394 :     info->localsize = ROUND_UP( info->localsize, CurrWordSize );

	movzx	ecx, BYTE PTR ModuleInfo+406
	mov	eax, DWORD PTR [r8+36]
	lea	edx, DWORD PTR [rcx+rax-1]
	lea	eax, DWORD PTR [rcx-1]
	not	eax
	and	edx, eax
	mov	DWORD PTR [r8+36], edx
$LN17@SetLocalOf@2:

; 3395 : #if AMD64_SUPPORT
; 3396 :     /* RSP 16-byte alignment? */
; 3397 :     if ( rspalign ) {

	test	ebp, ebp
	je	SHORT $LN14@SetLocalOf@2

; 3398 :       if (ModuleInfo.win64_flags & W64F_SMART)info->localsize = ROUND_UP(info->localsize, 8);

	test	BYTE PTR ModuleInfo+413, 8
	je	SHORT $LN15@SetLocalOf@2
	mov	eax, DWORD PTR [r8+36]
	add	eax, 7
	and	eax, -8					; fffffff8H
	mov	DWORD PTR [r8+36], eax
	jmp	SHORT $LN14@SetLocalOf@2
$LN15@SetLocalOf@2:

; 3399 :       else  info->localsize = ROUND_UP( info->localsize, 16 );

	mov	eax, DWORD PTR [r8+36]
	add	eax, 15
	and	eax, -16				; fffffff0H
	mov	DWORD PTR [r8+36], eax
$LN14@SetLocalOf@2:

; 3400 :     }
; 3401 : #endif
; 3402 : 
; 3403 :     DebugMsg1(("SetLocalOffsets(%s): localsize=%u after processing locals\n", CurrProc->sym.name, info->localsize ));
; 3404 : 
; 3405 : #if STACKBASESUPP
; 3406 :     /* v2.11: recalculate offsets for params and locals if there's no frame pointer.
; 3407 :      * Problem in 64-bit: option win64:2 triggers the "stack space reservation" feature -
; 3408 :      * but the final value of this space is known at the procedure's END only.
; 3409 :      * Hence in this case the values calculated below are "preliminary".
; 3410 :      */
; 3411 :     if (info->fpo) {

	test	BYTE PTR [r8+128], 128			; 00000080H
	je	$LN3@SetLocalOf@2

; 3412 :       unsigned localadj;
; 3413 :       unsigned paramadj;
; 3414 : #if AMD64_SUPPORT
; 3415 :       if (rspalign) {

	test	ebp, ebp
	je	SHORT $LN12@SetLocalOf@2

; 3416 :         localadj = info->localsize;
; 3417 :         if (!(ModuleInfo.win64_flags & W64F_SMART))

	test	BYTE PTR ModuleInfo+413, 8
	mov	r9d, DWORD PTR [r8+36]
	jne	SHORT $LN72@SetLocalOf@2

; 3418 :           paramadj = info->localsize - CurrWordSize - start;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	edx, r9d
	sub	edx, eax
	sub	edx, esi

; 3419 :       }
; 3420 :       else 

	jmp	SHORT $LN10@SetLocalOf@2
$LN12@SetLocalOf@2:

; 3421 :       {
; 3422 : #endif
; 3423 :         localadj = info->localsize + cntstd * CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406
	mov	ecx, DWORD PTR [r8+36]

; 3424 :         paramadj = info->localsize + cntstd * CurrWordSize - CurrWordSize;

	lea	edx, DWORD PTR [rbx-1]
	mov	r9d, eax
	imul	edx, eax
	imul	r9d, ebx
	add	r9d, ecx
	add	edx, ecx
	jmp	SHORT $LN10@SetLocalOf@2
$LN72@SetLocalOf@2:
	mov	edx, DWORD PTR paramadj$7308[rsp]
$LN10@SetLocalOf@2:

; 3425 : #if AMD64_SUPPORT
; 3426 :       }
; 3427 : #endif
; 3428 :       if (!(ModuleInfo.win64_flags & W64F_SMART)){

	test	BYTE PTR ModuleInfo+413, 8
	jne	SHORT $LN3@SetLocalOf@2

; 3429 :         DebugMsg1(("SetLocalOffsets(%s): FPO, adjusting offsets\n", CurrProc->sym.name));
; 3430 :         /* subtract CurrWordSize value for params, since no space is required to save the frame pointer value */
; 3431 :         for (curr = info->locallist; curr; curr = curr->nextlocal) {

	mov	rax, QWORD PTR [r8+16]
	test	rax, rax
	je	SHORT $LN6@SetLocalOf@2
	npad	5
$LL8@SetLocalOf@2:

; 3432 :           DebugMsg1(("SetLocalOffsets(%s): FPO, offset for %s %4d -> %4d\n", CurrProc->sym.name, curr->sym.name, curr->sym.offset, curr->sym.offset + localadj));
; 3433 :           curr->sym.offset += localadj;

	add	DWORD PTR [rax+16], r9d
	mov	rax, QWORD PTR [rax+120]
	test	rax, rax
	jne	SHORT $LL8@SetLocalOf@2
$LN6@SetLocalOf@2:

; 3434 :         }
; 3435 :         for (curr = info->paralist; curr; curr = curr->nextparam) {

	mov	rax, QWORD PTR [r8+8]
	test	rax, rax
	je	SHORT $LN3@SetLocalOf@2
	npad	10
$LL5@SetLocalOf@2:

; 3436 :           DebugMsg1(("SetLocalOffsets(%s): FPO, offset for %s %4d -> %4d\n", CurrProc->sym.name, curr->sym.name, curr->sym.offset, curr->sym.offset + paramadj));
; 3437 :           curr->sym.offset += paramadj;

	add	DWORD PTR [rax+16], edx
	mov	rax, QWORD PTR [rax+120]
	test	rax, rax
	jne	SHORT $LL5@SetLocalOf@2
$LN3@SetLocalOf@2:

; 3438 :         }
; 3439 :       }
; 3440 :     }
; 3441 : #endif
; 3442 : 
; 3443 : #if AMD64_SUPPORT
; 3444 :     /* v2.12: if the space used for register saves has been added to localsize,
; 3445 :      * the part that covers "pushed" GPRs has to be subtracted now, before prologue code is generated.
; 3446 :      */
; 3447 :     if (!(ModuleInfo.win64_flags & W64F_SMART)){

	test	BYTE PTR ModuleInfo+413, 8
	jne	SHORT $LN1@SetLocalOf@2

; 3448 :       if (rspalign) {

	test	ebp, ebp
	je	SHORT $LN1@SetLocalOf@2

; 3449 :         info->localsize -= cntstd * 8 + start;

	neg	esi
	lea	eax, DWORD PTR [rbx*8]
	sub	esi, eax
	add	DWORD PTR [r8+36], esi
$LN1@SetLocalOf@2:
	mov	rdi, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]

; 3450 :         DebugMsg1(("SetLocalOffsets(%s): final localsize=%u\n", CurrProc->sym.name, info->localsize));
; 3451 :       }
; 3452 :     }
; 3453 : #endif
; 3454 : }

	add	rsp, 72					; 00000048H
	ret	0
SetLocalOffsets ENDP
_TEXT	ENDS
PUBLIC	write_prologue
xdata	SEGMENT
$unwind$write_prologue DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$write_prologue DD @imagerel($LN13#)
	DD	@imagerel($LN13#+207)
	DD	@imagerel($unwind$write_prologue#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
tokenarray$ = 48
write_prologue PROC NEAR

; 3458 : {

$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H

; 3459 :     /* reset @ProcStatus flag */
; 3460 :     ProcStatus &= ~PRST_PROLOGUE_NOT_DONE;

	btr	DWORD PTR ProcStatus, 7

; 3461 : 
; 3462 : #if AMD64_SUPPORT
; 3463 :     if ( ModuleInfo.fctype == FCT_WIN64 && ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) ) {

	cmp	DWORD PTR ModuleInfo+376, 2
	mov	rbx, rcx
	jne	SHORT $LN6@write_prol
	test	BYTE PTR ModuleInfo+413, 2
	je	SHORT $LN6@write_prol

; 3464 :         /* in pass one init reserved stack with 4*8 to force stack frame creation */
; 3465 :         sym_ReservedStack->value = ( Parse_Pass == PASS_1 ? 4 * sizeof( uint_64 ) : CurrProc->e.procinfo->ReservedStack );

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN10@write_prol
	mov	edx, 32					; 00000020H
	jmp	SHORT $LN11@write_prol
$LN10@write_prol:
	mov	rax, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [rax+104]
	movsxd	rdx, DWORD PTR [rcx+96]
$LN11@write_prol:
	mov	rax, QWORD PTR sym_ReservedStack
	mov	DWORD PTR [rax+16], edx

; 3466 : 		if (Parse_Pass == PASS_1)

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN12@write_prol

; 3467 : 		{
; 3468 : 			sym_ReservedStack->value = 0;

	mov	rax, QWORD PTR sym_ReservedStack
	xor	ecx, ecx
	mov	DWORD PTR [rax+16], ecx

; 3469 : 			sym_ReservedStack->hasinvoke = 0;

	mov	rax, QWORD PTR sym_ReservedStack
	mov	DWORD PTR [rax+24], ecx
$LN6@write_prol:

; 3470 : 		}
; 3471 :     }
; 3472 : 
; 3473 : #endif
; 3474 :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN12@write_prol

; 3475 :         /* v2.12: calculation of offsets of local variables is done delayed now */
; 3476 :         SetLocalOffsets( CurrProc->e.procinfo );

	mov	rcx, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [rcx+104]
	call	SetLocalOffsets
$LN12@write_prol:

; 3477 :     }
; 3478 :     ProcStatus |= PRST_INSIDE_PROLOGUE;
; 3479 :     /* there are 3 cases:
; 3480 :      * option prologue:NONE           proc_prologue == NULL
; 3481 :      * option prologue:default        *proc_prologue == NULLC
; 3482 :      * option prologue:usermacro      *proc_prologue != NULLC
; 3483 :      */
; 3484 :     if ( ModuleInfo.prologuemode == PEM_DEFAULT ) {

	movzx	eax, BYTE PTR ModuleInfo+424
	or	DWORD PTR ProcStatus, 1
	test	al, al
	jne	SHORT $LN4@write_prol

; 3485 :         DebugMsg1(("write_prologue(%s): default prologue\n", CurrProc->sym.name ));
; 3486 :         write_default_prologue();

	call	write_default_prologue
	jmp	SHORT $LN1@write_prol
$LN4@write_prol:

; 3487 :     } else if ( ModuleInfo.prologuemode == PEM_NONE ) {

	cmp	al, 2
	je	SHORT $LN1@write_prol

; 3488 :         DebugMsg1(("write_prologue(%s): prologue is NULL\n", CurrProc->sym.name  ));
; 3489 :     } else {
; 3490 :         DebugMsg1(("write_prologue(%s): userdefined prologue %s\n", CurrProc->sym.name , ModuleInfo.proc_prologue ));
; 3491 :         write_userdef_prologue( tokenarray );

	mov	rcx, rbx
	call	write_userdef_prologue
$LN1@write_prol:

; 3492 :     }
; 3493 :     ProcStatus &= ~PRST_INSIDE_PROLOGUE;

	and	DWORD PTR ProcStatus, -2

; 3494 :     /* v2.10: for debug info, calculate prologue size */
; 3495 :     CurrProc->e.procinfo->size_prolog = GetCurrOffset() - CurrProc->sym.offset;

	call	GetCurrOffset
	mov	rcx, QWORD PTR CurrProc
	sub	al, BYTE PTR [rcx+16]
	mov	rcx, QWORD PTR [rcx+104]
	mov	BYTE PTR [rcx+129], al

; 3496 :     return;
; 3497 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
write_prologue ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$pop_register DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$pop_register DD @imagerel(pop_register#)
	DD	@imagerel(pop_register#+20)
	DD	@imagerel($unwind$pop_register#)
pdata	ENDS
xdata	SEGMENT
$chain$2$pop_register DD 061221H
	DD	097412H
	DD	08640dH
	DD	073405H
	DD	@imagerel(pop_register#)
	DD	@imagerel(pop_register#+20)
	DD	@imagerel($unwind$pop_register#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$pop_register DD @imagerel(pop_register#+20)
	DD	@imagerel(pop_register#+145)
	DD	@imagerel($chain$2$pop_register#)
pdata	ENDS
xdata	SEGMENT
$chain$4$pop_register DD 060021H
	DD	097400H
	DD	086400H
	DD	073400H
	DD	@imagerel(pop_register#)
	DD	@imagerel(pop_register#+20)
	DD	@imagerel($unwind$pop_register#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$pop_register DD @imagerel(pop_register#+145)
	DD	@imagerel(pop_register#+216)
	DD	@imagerel($chain$4$pop_register#)
pdata	ENDS
xdata	SEGMENT
$chain$5$pop_register DD 021H
	DD	@imagerel(pop_register#)
	DD	@imagerel(pop_register#+20)
	DD	@imagerel($unwind$pop_register#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$pop_register DD @imagerel(pop_register#+216)
	DD	@imagerel(pop_register#+221)
	DD	@imagerel($chain$5$pop_register#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
regist$ = 48
pop_register PROC NEAR

; 3502 : {

	sub	rsp, 40					; 00000028H

; 3503 :     int cnt;
; 3504 :     if( regist == NULL )

	test	rcx, rcx
	je	$LN3@pop_regist

; 3505 :         return;
; 3506 :     cnt = *regist;
; 3507 :     regist += cnt;
; 3508 :     if (ModuleInfo.win64_flags & W64F_SMART)

	test	BYTE PTR ModuleInfo+413, 8
	mov	QWORD PTR [rsp+56], rbx
	movzx	ebx, WORD PTR [rcx]
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	lea	rdi, QWORD PTR [rcx+rbx*2]
	je	SHORT $LN12@pop_regist

; 3509 :     {
; 3510 :       for (cnt = CurrProc->e.procinfo->pushed_reg; cnt; cnt--, regist--) {

	mov	rax, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [rax+104]
	mov	ebx, DWORD PTR [rcx+104]
	test	ebx, ebx
	je	$LN22@pop_regist
	lea	rsi, OFFSET FLAT:SpecialTable
	npad	7
$LL11@pop_regist:

; 3511 :         /* don't "pop" xmm registers */
; 3512 :                 if (( GetValueSp( *regist ) & OP_XMM )||( GetValueSp( *regist ) & OP_YMM )
; 3513 : #if EVEXSUPP    
; 3514 :                   || ( GetValueSp( *regist ) & OP_ZMM )
; 3515 : #endif
; 3516 :                 )

	movzx	ecx, WORD PTR [rdi]
	lea	rax, QWORD PTR [rcx+rcx*2]
	mov	edx, DWORD PTR [rsi+rax*4]
	test	dl, 32					; 00000020H
	jne	SHORT $LN7@pop_regist
	test	dl, dl
	js	SHORT $LN7@pop_regist

; 3519 :           continue;
; 3520 :         }
; 3521 :         AddLineQueueX("pop %r", *regist);

	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG7345
	call	AddLineQueueX

; 3522 :       }

	jmp	SHORT $LN10@pop_regist
$LN7@pop_regist:

; 3517 : {
; 3518 :           cnt++;

	inc	ebx
$LN10@pop_regist:

; 3509 :     {
; 3510 :       for (cnt = CurrProc->e.procinfo->pushed_reg; cnt; cnt--, regist--) {

	sub	rdi, 2
	dec	ebx
	jne	SHORT $LL11@pop_regist
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+72]

; 3533 :       }
; 3534 :     }
; 3535 : 
; 3536 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN12@pop_regist:

; 3523 :     }
; 3524 :     else {
; 3525 :       for (; cnt; cnt--, regist--) {

	test	ebx, ebx
	je	SHORT $LN22@pop_regist
	lea	rsi, OFFSET FLAT:SpecialTable
	npad	4
$LL5@pop_regist:

; 3526 :         /* don't "pop" xmm registers */
; 3527 :                 if (( GetValueSp( *regist ) & OP_XMM )||( GetValueSp( *regist ) & OP_YMM )
; 3528 : #if EVEXSUPP    
; 3529 :                   || ( GetValueSp( *regist ) & OP_ZMM )
; 3530 : #endif
; 3531 :                 )continue;

	movzx	ecx, WORD PTR [rdi]
	lea	rax, QWORD PTR [rcx+rcx*2]
	mov	edx, DWORD PTR [rsi+rax*4]
	test	dl, 32					; 00000020H
	jne	SHORT $LN4@pop_regist
	test	dl, dl
	js	SHORT $LN4@pop_regist

; 3532 :         AddLineQueueX("pop %r", *regist);

	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG7352
	call	AddLineQueueX
$LN4@pop_regist:
	sub	rdi, 2
	dec	ebx
	jne	SHORT $LL5@pop_regist
$LN22@pop_regist:
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+72]
$LN3@pop_regist:

; 3533 :       }
; 3534 :     }
; 3535 : 
; 3536 : }

	add	rsp, 40					; 00000028H
	ret	0
pop_register ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$write_win64_default_epilogue DD 010401H
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$write_win64_default_epilogue DD @imagerel(write_win64_default_epilogue#)
	DD	@imagerel(write_win64_default_epilogue#+4)
	DD	@imagerel($unwind$write_win64_default_epilogue#)
pdata	ENDS
xdata	SEGMENT
$chain$5$write_win64_default_epilogue DD 0c2621H
	DD	07d426H
	DD	08c41cH
	DD	0d7417H
	DD	0c6412H
	DD	0b540dH
	DD	0a3405H
	DD	@imagerel(write_win64_default_epilogue#)
	DD	@imagerel(write_win64_default_epilogue#+4)
	DD	@imagerel($unwind$write_win64_default_epilogue#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$write_win64_default_epilogue DD @imagerel(write_win64_default_epilogue#+4)
	DD	@imagerel(write_win64_default_epilogue#+906)
	DD	@imagerel($chain$5$write_win64_default_epilogue#)
pdata	ENDS
xdata	SEGMENT
$chain$6$write_win64_default_epilogue DD 020021H
	DD	08c400H
	DD	@imagerel(write_win64_default_epilogue#)
	DD	@imagerel(write_win64_default_epilogue#+4)
	DD	@imagerel($unwind$write_win64_default_epilogue#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$write_win64_default_epilogue DD @imagerel(write_win64_default_epilogue#+906)
	DD	@imagerel(write_win64_default_epilogue#+946)
	DD	@imagerel($chain$6$write_win64_default_epilogue#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
info$ = 80
write_win64_default_epilogue PROC NEAR

; 3545 : {

	sub	rsp, 72					; 00000048H
	mov	QWORD PTR [rsp+80], rbx

; 3546 :   int anysize;
; 3547 :   int stackSize;
; 3548 : 
; 3549 : #if STACKBASESUPP
; 3550 :     /* v2.12: obsolete */
; 3551 :     //if ( GetRegNo( info->basereg ) == 4 || ( info->parasize == 0 && info->locallist == NULL ) )
; 3552 :     //    sizestd = 8;
; 3553 : #endif
; 3554 :     /* restore non-volatile xmm registers */
; 3555 :     if ( info->regslist ) {

	mov	rbx, QWORD PTR [rcx]
	mov	QWORD PTR [rsp+88], rbp
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+104], rdi
	mov	QWORD PTR [rsp+64], r12
	xor	ebp, ebp
	test	rbx, rbx
	mov	QWORD PTR [rsp+56], r13
	mov	r12, rcx
	lea	r13, OFFSET FLAT:__ImageBase
	je	$LN29@write_win6@2

; 3556 :         uint_16 *regs;
; 3557 :         int cnt;
; 3558 :         int i;
; 3559 :         
; 3560 : 
; 3561 :         /* v2.12: space for xmm saves is now included in localsize
; 3562 :          * so first thing to do is to count the xmm regs that were saved
; 3563 :          */
; 3564 :         for( regs = info->regslist, cnt = *regs++, i = 0; cnt; cnt--, regs++ )

	movzx	r8d, WORD PTR [rbx]
	lea	rdx, QWORD PTR [rbx+2]
	mov	r9d, ebp
	test	r8d, r8d
	je	$LN29@write_win6@2
	npad	2
$LL37@write_win6@2:

; 3565 :                 if (( GetValueSp( *regs ) & OP_XMM )||( GetValueSp( *regs ) & OP_YMM )
; 3566 : #if EVEXSUPP    
; 3567 :                   || ( GetValueSp( *regs ) & OP_ZMM )
; 3568 : #endif
; 3569 :                 )i++;

	movzx	eax, WORD PTR [rdx]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	eax, DWORD PTR SpecialTable[r13+rcx*4]
	test	al, 32					; 00000020H
	jne	SHORT $LN33@write_win6@2
	test	al, al
	jns	SHORT $LN36@write_win6@2
$LN33@write_win6@2:
	inc	r9d
$LN36@write_win6@2:

; 3556 :         uint_16 *regs;
; 3557 :         int cnt;
; 3558 :         int i;
; 3559 :         
; 3560 : 
; 3561 :         /* v2.12: space for xmm saves is now included in localsize
; 3562 :          * so first thing to do is to count the xmm regs that were saved
; 3563 :          */
; 3564 :         for( regs = info->regslist, cnt = *regs++, i = 0; cnt; cnt--, regs++ )

	add	rdx, 2
	dec	r8d
	jne	SHORT $LL37@write_win6@2

; 3570 : 
; 3571 :         DebugMsg1(("write_win64_default_epilogue(%s): %u xmm registers to restore\n", CurrProc->sym.name , i ));
; 3572 : 
; 3573 :         if ( i ) {

	test	r9d, r9d
	je	$LN29@write_win6@2

; 3574 :             //if (info->locallist)
; 3575 :             //  i = (info->localsize - i * XYZMMsize) & ~(16 - 1);
; 3576 :             //else
; 3577 :             //i = ( info->localsize) & ~(16-1);
; 3578 :             i = 0;       //firs location is right at the [rsp] which is aligned to 16 ; HJWasm 2.21
; 3579 :             for( regs = info->regslist, cnt = *regs++; cnt; cnt--, regs++ ) {

	movzx	esi, WORD PTR [rbx]
	add	rbx, 2
	mov	edi, ebp
	test	esi, esi
	je	$LN29@write_win6@2
	npad	3
$LL31@write_win6@2:

; 3580 :                 if (( GetValueSp( *regs ) & OP_XMM )||( GetValueSp( *regs ) & OP_YMM )
; 3581 : #if EVEXSUPP    
; 3582 :                   || ( GetValueSp( *regs ) & OP_ZMM )
; 3583 : #endif
; 3584 :                 ){

	movzx	r8d, WORD PTR [rbx]
	lea	rax, QWORD PTR [r8+r8*2]
	mov	ecx, DWORD PTR SpecialTable[r13+rax*4]
	mov	eax, ecx
	and	eax, 32					; 00000020H
	jne	SHORT $LN27@write_win6@2
	test	cl, cl
	jns	$LN30@write_win6@2
$LN27@write_win6@2:

; 3585 :                     DebugMsg1(("write_win64_default_epilogue(%s): restore %s, offset=%d\n", CurrProc->sym.name , GetResWName( *regs, NULL ), i ));
; 3586 :                     //AddLineQueueX( "movdqa %r, [%r+%u]", *regist, stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize + sizexmm );
; 3587 :                     /* v2.11: use @ReservedStack only if option win64:2 is set */
; 3588 :                     if (ModuleInfo.win64_flags & W64F_AUTOSTACKSP)

	test	BYTE PTR ModuleInfo+413, 2
	je	SHORT $LN26@write_win6@2

; 3589 : 					{
; 3590 : 						if(GetValueSp(*regs) & OP_XMM)

	test	eax, eax
	je	SHORT $LN25@write_win6@2

; 3591 : 							AddLineQueueX("%s %r, [%r + %u + %s]", MOVE_ALIGNED_INT, *regs, stackreg[ModuleInfo.Ofssize], NUMQUAL i, sym_ReservedStack->name);

	movzx	edx, BYTE PTR ModuleInfo+404
	mov	rax, QWORD PTR sym_ReservedStack
	mov	rcx, QWORD PTR [rax+8]
	mov	r9d, DWORD PTR stackreg[r13+rdx*4]
	mov	rdx, QWORD PTR MOVE_ALIGNED_INT
	mov	QWORD PTR [rsp+40], rcx
	lea	rcx, OFFSET FLAT:$SG7376
	mov	DWORD PTR [rsp+32], edi
	call	AddLineQueueX

; 3592 : 						else

	jmp	$LN21@write_win6@2
$LN25@write_win6@2:

; 3593 : 							AddLineQueueX("%s %r, [%r + %u + %s]", MOVE_ALIGNED_INT, *regs, stackreg[ModuleInfo.Ofssize], NUMQUAL i, sym_ReservedStack->name);

	movzx	edx, BYTE PTR ModuleInfo+404
	mov	rax, QWORD PTR sym_ReservedStack
	mov	rcx, QWORD PTR [rax+8]
	mov	r9d, DWORD PTR stackreg[r13+rdx*4]
	mov	rdx, QWORD PTR MOVE_ALIGNED_INT
	mov	QWORD PTR [rsp+40], rcx
	lea	rcx, OFFSET FLAT:$SG7378
	mov	DWORD PTR [rsp+32], edi
	call	AddLineQueueX

; 3594 :                     }
; 3595 :                     else

	jmp	SHORT $LN21@write_win6@2
$LN26@write_win6@2:

; 3596 : 					{
; 3597 : 						if (GetValueSp(*regs) & OP_XMM)

	test	eax, eax
	je	SHORT $LN22@write_win6@2

; 3598 : 							AddLineQueueX("%s %r, [%r + %u]", MOVE_ALIGNED_INT, *regs, stackreg[ModuleInfo.Ofssize], NUMQUAL i );

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	rdx, QWORD PTR MOVE_ALIGNED_INT
	lea	rcx, OFFSET FLAT:$SG7381
	mov	r9d, DWORD PTR stackreg[r13+rax*4]
	mov	DWORD PTR [rsp+32], edi
	call	AddLineQueueX

; 3599 : 						else

	jmp	SHORT $LN21@write_win6@2
$LN22@write_win6@2:

; 3600 : 							AddLineQueueX("%s %r, [%r + %u]", MOVE_ALIGNED_INT, *regs, stackreg[ModuleInfo.Ofssize], NUMQUAL i);

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	rdx, QWORD PTR MOVE_ALIGNED_INT
	lea	rcx, OFFSET FLAT:$SG7383
	mov	r9d, DWORD PTR stackreg[r13+rax*4]
	mov	DWORD PTR [rsp+32], edi
	call	AddLineQueueX
$LN21@write_win6@2:

; 3601 :                     }
; 3602 :                     i += XYZMMsize;

	add	edi, DWORD PTR XYZMMsize
$LN30@write_win6@2:

; 3574 :             //if (info->locallist)
; 3575 :             //  i = (info->localsize - i * XYZMMsize) & ~(16 - 1);
; 3576 :             //else
; 3577 :             //i = ( info->localsize) & ~(16-1);
; 3578 :             i = 0;       //firs location is right at the [rsp] which is aligned to 16 ; HJWasm 2.21
; 3579 :             for( regs = info->regslist, cnt = *regs++; cnt; cnt--, regs++ ) {

	add	rbx, 2
	dec	esi
	jne	$LL31@write_win6@2
$LN29@write_win6@2:

; 3603 :                 }
; 3604 :             }
; 3605 :         }
; 3606 :     }
; 3607 : 
; 3608 :     if (ModuleInfo.fctype == FCT_WIN64 && (ModuleInfo.win64_flags & W64F_AUTOSTACKSP)){

	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN20@write_win6@2
	test	BYTE PTR ModuleInfo+413, 2
	je	SHORT $LN20@write_win6@2

; 3609 :       //if (ModuleInfo.win64_flags & W64F_SMART){
; 3610 :         anysize = info->localsize + sym_ReservedStack->value + info->xmmsize;

	mov	r9, QWORD PTR sym_ReservedStack
	mov	edx, DWORD PTR [r12+36]
	mov	ecx, DWORD PTR [r12+112]
	mov	eax, DWORD PTR [r9+16]
	add	eax, edx
	add	eax, ecx

; 3611 :         if (info->vecused) anysize += info->vsize;

	cmp	BYTE PTR [r12+80], bpl
	je	SHORT $LN19@write_win6@2
	add	eax, DWORD PTR [r12+44]
$LN19@write_win6@2:

; 3612 : 		if (anysize)

	test	eax, eax
	je	SHORT $LN15@write_win6@2

; 3613 : 		{
; 3614 : 			stackSize = info->localsize + info->vsize + info->xmmsize;

	mov	r8d, DWORD PTR [r12+44]
	add	r8d, edx
	add	r8d, ecx

; 3615 : 			if ((stackSize & 7) != 0) stackSize = (stackSize + 7)&(-8);

	test	r8b, 7
	je	SHORT $LN17@write_win6@2
	add	r8d, 7
	and	r8d, -8
$LN17@write_win6@2:

; 3616 : 			AddLineQueueX("add %r, %d + %s", stackreg[ModuleInfo.Ofssize], NUMQUAL stackSize, sym_ReservedStack->name);

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	r9, QWORD PTR [r9+8]
	lea	rcx, OFFSET FLAT:$SG7388
	mov	edx, DWORD PTR stackreg[r13+rax*4]
	call	AddLineQueueX

; 3617 : 		}

	jmp	SHORT $LN15@write_win6@2
$LN20@write_win6@2:

; 3618 :       //}
; 3619 :         //else if (info->localsize + info->xmmsize > 0)
; 3620 :           //AddLineQueueX("add %r, %d + %s", stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize + info->xmmsize, sym_ReservedStack->name);
; 3621 :     }
; 3622 : 	else if (info->localsize > 0)

	mov	r8d, DWORD PTR [r12+36]
	test	r8d, r8d
	je	SHORT $LN15@write_win6@2

; 3623 : 	{
; 3624 : 		stackSize = info->localsize;
; 3625 : 		AddLineQueueX("add %r, %d", stackreg[ModuleInfo.Ofssize], stackSize);

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:$SG7391
	mov	edx, DWORD PTR stackreg[r13+rax*4]
	call	AddLineQueueX
$LN15@write_win6@2:

; 3626 : 	}
; 3627 : 	pop_register(CurrProc->e.procinfo->regslist); //make sure we pop before correcting RSP.

	mov	rax, QWORD PTR CurrProc
	mov	rdx, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR [rdx]
	test	rcx, rcx
	je	$LN43@write_win6@2
	test	BYTE PTR ModuleInfo+413, 8
	movzx	ebx, WORD PTR [rcx]
	lea	rdi, QWORD PTR [rcx+rbx*2]
	mov	rax, rbx
	je	SHORT $LN52@write_win6@2
	mov	ebx, DWORD PTR [rdx+104]
	test	ebx, ebx
	je	SHORT $LN43@write_win6@2
	npad	2
$LL51@write_win6@2:
	movzx	ecx, WORD PTR [rdi]
	lea	rax, QWORD PTR [rcx+rcx*2]
	mov	edx, DWORD PTR SpecialTable[r13+rax*4]
	test	dl, 32					; 00000020H
	jne	SHORT $LN47@write_win6@2
	test	dl, dl
	js	SHORT $LN47@write_win6@2
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG7345
	call	AddLineQueueX
	jmp	SHORT $LN50@write_win6@2
$LN47@write_win6@2:
	inc	ebx
$LN50@write_win6@2:
	sub	rdi, 2
	dec	ebx
	jne	SHORT $LL51@write_win6@2
	jmp	SHORT $LN43@write_win6@2
$LN52@write_win6@2:
	test	ebx, ebx
	je	SHORT $LN43@write_win6@2
	npad	8
$LL45@write_win6@2:
	movzx	ecx, WORD PTR [rdi]
	lea	rax, QWORD PTR [rcx+rcx*2]
	mov	edx, DWORD PTR SpecialTable[r13+rax*4]
	test	dl, 32					; 00000020H
	jne	SHORT $LN44@write_win6@2
	test	dl, dl
	js	SHORT $LN44@write_win6@2
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG7352
	call	AddLineQueueX
$LN44@write_win6@2:
	sub	rdi, 2
	dec	ebx
	jne	SHORT $LL45@write_win6@2
$LN43@write_win6@2:

; 3628 : 
; 3629 : 	/* 
; 3630 : 	If we are using RBP as the base frame register but no frame was created
; 3631 : 	(IE: there was no push rbp, then we did a sub rsp,8 so we need to reverse it.
; 3632 : 	*/
; 3633 : 	//if (info->fpo || (info->parasize == 0 && info->locallist == NULL)) {
; 3634 : 		//if (info->basereg != T_RSP && ((info->pushed_reg>0 && info->pushed_reg % 2 == 0) || info->pushed_reg == 0))
; 3635 : 		//{
; 3636 : 			//AddLineQueueX("add %r, %u", T_RSP, CurrWordSize);
; 3637 : 		//}
; 3638 : 	//}
; 3639 : 
; 3640 : 
; 3641 : #if STACKBASESUPP
; 3642 :     if (ModuleInfo.win64_flags & W64F_SMART){

	movzx	eax, BYTE PTR ModuleInfo+413
	test	al, 8
	je	$LN9@write_win6@2

; 3643 :       /* restore non-volatile registers from shadow space */
; 3644 :       if (info->regslist) {

	mov	rbx, QWORD PTR [r12]
	test	rbx, rbx
	je	SHORT $LN9@write_win6@2

; 3645 :         uint_16 *regist = info->regslist;
; 3646 :         int cnt;
; 3647 :         if (ModuleInfo.win64_flags){

	test	al, al
	je	SHORT $LN9@write_win6@2

; 3648 :           int i = 0;
; 3649 :           int gprzize = 0;
; 3650 :           for (cnt = *regist++; cnt; cnt--, regist++)

	movzx	edi, WORD PTR [rbx]
	add	rbx, 2
	mov	rsi, rbp
	test	edi, edi
	je	SHORT $LN9@write_win6@2
	npad	8
$LL11@write_win6@2:

; 3651 :           {
; 3652 :                 if (( GetValueSp( *regist ) & OP_XMM )||( GetValueSp( *regist ) & OP_YMM )
; 3653 : #if EVEXSUPP    
; 3654 :                   || ( GetValueSp( *regist ) & OP_ZMM )
; 3655 : #endif
; 3656 :                 ) continue;

	movzx	edx, WORD PTR [rbx]
	lea	rax, QWORD PTR [rdx+rdx*2]
	mov	ecx, DWORD PTR SpecialTable[r13+rax*4]
	test	cl, 32					; 00000020H
	jne	SHORT $LN10@write_win6@2
	test	cl, cl
	js	SHORT $LN10@write_win6@2

; 3657 :             else {
; 3658 :               gprzize += 8;

	add	ebp, 8

; 3659 :               if (gprzize <= 0x20)

	cmp	ebp, 32					; 00000020H
	jg	SHORT $LN10@write_win6@2

; 3660 :               {
; 3661 :                 if (info->home_used[i] == 0){

	cmp	BYTE PTR [rsi+r12+116], 0
	jne	SHORT $LN4@write_win6@2

; 3662 :                   AddLineQueueX("mov %r, [%r+%u]", *regist, stackreg[ModuleInfo.Ofssize], NUMQUAL gprzize);

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:$SG7407
	mov	r9d, ebp
	mov	r8d, DWORD PTR stackreg[r13+rax*4]
	call	AddLineQueueX

; 3663 :                 }
; 3664 :                 else {

	jmp	SHORT $LN3@write_win6@2
$LN4@write_win6@2:

; 3665 :                   cnt++; regist--;

	inc	edi
	sub	rbx, 2
$LN3@write_win6@2:

; 3666 :                 }
; 3667 :                 i++;

	inc	rsi
$LN10@write_win6@2:

; 3648 :           int i = 0;
; 3649 :           int gprzize = 0;
; 3650 :           for (cnt = *regist++; cnt; cnt--, regist++)

	add	rbx, 2
	dec	edi
	jne	SHORT $LL11@write_win6@2
$LN9@write_win6@2:

; 3668 :               }
; 3669 :             }
; 3670 :           }
; 3671 :         }
; 3672 :       }
; 3673 :     }
; 3674 :     //if ( !info->fpo )
; 3675 :     if ( GetRegNo( info->basereg ) != 4 && ( info->parasize != 0 || info->locallist != NULL ) )

	movzx	ecx, WORD PTR [r12+130]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]
	lea	rax, QWORD PTR [rcx+rcx*2]
	cmp	BYTE PTR SpecialTable[r13+rax*4+10], 4
	mov	r13, QWORD PTR [rsp+56]
	je	SHORT $LN2@write_win6@2
	cmp	DWORD PTR [r12+32], 0
	jne	SHORT $LN1@write_win6@2
	cmp	QWORD PTR [r12+16], 0
	je	SHORT $LN2@write_win6@2
$LN1@write_win6@2:

; 3676 :         AddLineQueueX( "pop %r", info->basereg );

	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG7412
	call	AddLineQueueX
$LN2@write_win6@2:
	mov	r12, QWORD PTR [rsp+64]

; 3677 : #else
; 3678 :     AddLineQueueX( "pop %r", basereg[ModuleInfo.Ofssize] );
; 3679 : #endif
; 3680 : 
; 3681 :     return;
; 3682 : }

	add	rsp, 72					; 00000048H
	ret	0
write_win64_default_epilogue ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$write_default_epilogue DD 051501H
	DD	097415H
	DD	083410H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$write_default_epilogue DD @imagerel(write_default_epilogue#)
	DD	@imagerel(write_default_epilogue#+442)
	DD	@imagerel($unwind$write_default_epilogue#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
write_default_epilogue PROC NEAR

; 3745 : {

	sub	rsp, 40					; 00000028H

; 3746 :     struct proc_info   *info;
; 3747 : #if AMD64_SUPPORT
; 3748 :     int resstack = 0;
; 3749 : #endif
; 3750 : 
; 3751 :     info = CurrProc->e.procinfo;

	mov	rcx, QWORD PTR CurrProc
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	mov	rbx, QWORD PTR [rcx+104]
	xor	edi, edi

; 3752 : 
; 3753 : #if AMD64_SUPPORT
; 3754 :     if ( info->isframe ) {

	test	BYTE PTR [rbx+128], 64			; 00000040H
	je	SHORT $LN15@write_defa@2

; 3755 :         if ( ModuleInfo.frame_auto )

	bt	DWORD PTR ModuleInfo+408, 18
	jae	$LN6@write_defa@2

; 3756 :             write_win64_default_epilogue( info );

	mov	rcx, rbx
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 3824 : #else
; 3825 :         AddLineQueueX( "pop %r", basereg[ModuleInfo.Ofssize] );
; 3826 : #endif
; 3827 :     }
; 3828 : }

	add	rsp, 40					; 00000028H
	jmp	write_win64_default_epilogue
$LN15@write_defa@2:

; 3757 :         return;
; 3758 :     }
; 3759 :     if ( ModuleInfo.Ofssize == USE64 && ModuleInfo.fctype == FCT_WIN64 && ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) ) {

	cmp	BYTE PTR ModuleInfo+404, 2
	jne	SHORT $LN12@write_defa@2
	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN12@write_defa@2
	test	BYTE PTR ModuleInfo+413, 2
	je	SHORT $LN12@write_defa@2

; 3760 :         resstack  = sym_ReservedStack->value;

	mov	r9, QWORD PTR sym_ReservedStack
	mov	edi, DWORD PTR [r9+16]

; 3761 :         /* if no framepointer was pushed, add 8 to align stack on OWORD
; 3762 :          * v2.12: obsolete; localsize contains correct value.
; 3763 :          */
; 3764 :         //if( !(info->localsize || info->stackparam || info->has_vararg || info->forceframe ))
; 3765 :         //    AddLineQueueX( "add %r, 8 + %s", stackreg[ModuleInfo.Ofssize], sym_ReservedStack->name );
; 3766 :         //else
; 3767 :         if(resstack)

	test	edi, edi
	je	SHORT $LN12@write_defa@2

; 3768 : 			AddLineQueueX( "add %r, %d + %s", stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize, sym_ReservedStack->name );

	mov	r9, QWORD PTR [r9+8]
	mov	r8d, DWORD PTR [rbx+36]
	lea	rcx, OFFSET FLAT:$SG7422
	mov	edx, 119				; 00000077H
	call	AddLineQueueX
	mov	rcx, QWORD PTR CurrProc
$LN12@write_defa@2:

; 3769 :     }
; 3770 : #endif
; 3771 : 
; 3772 :     /* Pop the registers */
; 3773 :     pop_register( CurrProc->e.procinfo->regslist );

	mov	rcx, QWORD PTR [rcx+104]
	mov	rcx, QWORD PTR [rcx]
	call	pop_register

; 3774 : 
; 3775 :     if ( info->loadds ) {

	test	BYTE PTR [rbx+128], 16
	je	SHORT $LN11@write_defa@2

; 3776 :         AddLineQueueX( "pop %r", T_DS );

	lea	rcx, OFFSET FLAT:$SG7424
	mov	edx, 28
	call	AddLineQueueX
$LN11@write_defa@2:

; 3777 :     }
; 3778 : 
; 3779 :     if( ( info->locallist == NULL ) &&
; 3780 :        info->stackparam == FALSE &&
; 3781 :        info->has_vararg == FALSE &&
; 3782 : #if AMD64_SUPPORT
; 3783 :        resstack == 0 &&
; 3784 : #endif
; 3785 :        info->forceframe == FALSE )

	mov	rcx, QWORD PTR [rbx+16]
	test	rcx, rcx
	jne	SHORT $LN10@write_defa@2
	movzx	eax, BYTE PTR [rbx+128]
	test	al, 32					; 00000020H
	jne	SHORT $LN10@write_defa@2
	test	al, 1
	jne	SHORT $LN10@write_defa@2
	test	edi, edi
	jne	SHORT $LN10@write_defa@2
	test	al, 8
	je	$LN6@write_defa@2
$LN10@write_defa@2:

; 3786 :         return;
; 3787 : 
; 3788 :     /* restore registers e/sp and e/bp.
; 3789 :      * emit either "leave" or "mov e/sp,e/bp, pop e/bp".
; 3790 :      */
; 3791 : #if AMD64_SUPPORT
; 3792 :     if( !(info->locallist || info->stackparam || info->has_vararg || info->forceframe ))

	test	rcx, rcx
	jne	SHORT $LN9@write_defa@2
	movzx	eax, BYTE PTR [rbx+128]
	test	al, 32					; 00000020H
	jne	SHORT $LN9@write_defa@2
	test	al, 1
	jne	SHORT $LN9@write_defa@2
	test	al, 8
	je	$LN6@write_defa@2
$LN9@write_defa@2:

; 3793 :         ;
; 3794 :     else
; 3795 : #endif
; 3796 :     if( info->pe_type ) {

	movzx	eax, BYTE PTR [rbx+128]
	test	al, 2
	je	SHORT $LN7@write_defa@2

; 3797 :         AddLineQueue( "leave" );

	lea	rcx, OFFSET FLAT:$SG7430
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 3824 : #else
; 3825 :         AddLineQueueX( "pop %r", basereg[ModuleInfo.Ofssize] );
; 3826 : #endif
; 3827 :     }
; 3828 : }

	add	rsp, 40					; 00000028H
	jmp	AddLineQueue
$LN7@write_defa@2:

; 3798 :     } else  {
; 3799 : #if STACKBASESUPP
; 3800 :         if ( info->fpo ) {

	test	al, al
	jns	SHORT $LN5@write_defa@2

; 3801 : #if AMD64_SUPPORT
; 3802 :             if ( ModuleInfo.Ofssize == USE64 && ModuleInfo.fctype == FCT_WIN64 && ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) )

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	al, 2
	jne	SHORT $LN4@write_defa@2
	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN4@write_defa@2
	test	BYTE PTR ModuleInfo+413, al
	jne	SHORT $LN6@write_defa@2
$LN4@write_defa@2:

; 3803 :                 ;
; 3804 :             else
; 3805 : #endif
; 3806 :             if ( info->localsize )

	mov	r8d, DWORD PTR [rbx+36]
	test	r8d, r8d
	je	SHORT $LN6@write_defa@2

; 3807 :                 AddLineQueueX( "add %r, %d", stackreg[ModuleInfo.Ofssize], NUMQUAL info->localsize );

	lea	rcx, OFFSET FLAT:stackreg
	movzx	eax, al
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG7436
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 3824 : #else
; 3825 :         AddLineQueueX( "pop %r", basereg[ModuleInfo.Ofssize] );
; 3826 : #endif
; 3827 :     }
; 3828 : }

	add	rsp, 40					; 00000028H
	jmp	AddLineQueueX
$LN5@write_defa@2:

; 3808 :             return;
; 3809 :         }
; 3810 : #endif
; 3811 :         /*
; 3812 :          MOV [E|R]SP, [E|R]BP
; 3813 :          POP [E|R]BP
; 3814 :          */
; 3815 :         if( info->localsize != 0 ) {

	cmp	DWORD PTR [rbx+36], 0
	je	SHORT $LN1@write_defa@2

; 3816 : #if STACKBASESUPP
; 3817 :             AddLineQueueX( "mov %r, %r", stackreg[ModuleInfo.Ofssize], info->basereg );

	movzx	eax, BYTE PTR ModuleInfo+404
	movzx	r8d, WORD PTR [rbx+130]
	lea	rcx, OFFSET FLAT:stackreg
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG7438
	call	AddLineQueueX
$LN1@write_defa@2:

; 3818 : #else
; 3819 :             AddLineQueueX( "mov %r, %r", stackreg[ModuleInfo.Ofssize], basereg[ModuleInfo.Ofssize] );
; 3820 : #endif
; 3821 :         }
; 3822 : #if STACKBASESUPP
; 3823 :         AddLineQueueX( "pop %r", info->basereg );

	movzx	edx, WORD PTR [rbx+130]
	lea	rcx, OFFSET FLAT:$SG7439
	call	AddLineQueueX
$LN6@write_defa@2:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 3824 : #else
; 3825 :         AddLineQueueX( "pop %r", basereg[ModuleInfo.Ofssize] );
; 3826 : #endif
; 3827 :     }
; 3828 : }

	add	rsp, 40					; 00000028H
	ret	0
write_default_epilogue ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$write_userdef_epilogue DD 0a1a01H
	DD	09bf41aH
	DD	09dd416H
	DD	09ec412H
	DD	0a3740eH
	DD	09f010aH
xdata	ENDS
pdata	SEGMENT
$pdata$write_userdef_epilogue DD @imagerel(write_userdef_epilogue#)
	DD	@imagerel(write_userdef_epilogue#+94)
	DD	@imagerel($unwind$write_userdef_epilogue#)
pdata	ENDS
xdata	SEGMENT
$chain$4$write_userdef_epilogue DD 020821H
	DD	0a26408H
	DD	@imagerel(write_userdef_epilogue#)
	DD	@imagerel(write_userdef_epilogue#+94)
	DD	@imagerel($unwind$write_userdef_epilogue#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$write_userdef_epilogue DD @imagerel(write_userdef_epilogue#+94)
	DD	@imagerel(write_userdef_epilogue#+107)
	DD	@imagerel($chain$4$write_userdef_epilogue#)
pdata	ENDS
xdata	SEGMENT
$chain$6$write_userdef_epilogue DD 044c21H
	DD	0a0344cH
	DD	09ce408H
	DD	@imagerel(write_userdef_epilogue#+94)
	DD	@imagerel(write_userdef_epilogue#+107)
	DD	@imagerel($chain$4$write_userdef_epilogue#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$write_userdef_epilogue DD @imagerel(write_userdef_epilogue#+107)
	DD	@imagerel(write_userdef_epilogue#+239)
	DD	@imagerel($chain$6$write_userdef_epilogue#)
pdata	ENDS
xdata	SEGMENT
$chain$7$write_userdef_epilogue DD 020821H
	DD	0a15408H
	DD	@imagerel(write_userdef_epilogue#+107)
	DD	@imagerel(write_userdef_epilogue#+239)
	DD	@imagerel($chain$6$write_userdef_epilogue#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$write_userdef_epilogue DD @imagerel(write_userdef_epilogue#+239)
	DD	@imagerel(write_userdef_epilogue#+322)
	DD	@imagerel($chain$7$write_userdef_epilogue#)
pdata	ENDS
xdata	SEGMENT
$chain$8$write_userdef_epilogue DD 021H
	DD	@imagerel(write_userdef_epilogue#+107)
	DD	@imagerel(write_userdef_epilogue#+239)
	DD	@imagerel($chain$6$write_userdef_epilogue#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$write_userdef_epilogue DD @imagerel(write_userdef_epilogue#+322)
	DD	@imagerel(write_userdef_epilogue#+464)
	DD	@imagerel($chain$8$write_userdef_epilogue#)
pdata	ENDS
xdata	SEGMENT
$chain$9$write_userdef_epilogue DD 021H
	DD	@imagerel(write_userdef_epilogue#+94)
	DD	@imagerel(write_userdef_epilogue#+107)
	DD	@imagerel($chain$4$write_userdef_epilogue#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$write_userdef_epilogue DD @imagerel(write_userdef_epilogue#+464)
	DD	@imagerel(write_userdef_epilogue#+525)
	DD	@imagerel($chain$9$write_userdef_epilogue#)
pdata	ENDS
xdata	SEGMENT
$chain$10$write_userdef_epilogue DD 021H
	DD	@imagerel(write_userdef_epilogue#)
	DD	@imagerel(write_userdef_epilogue#+94)
	DD	@imagerel($unwind$write_userdef_epilogue#)
xdata	ENDS
pdata	SEGMENT
$pdata$10$write_userdef_epilogue DD @imagerel(write_userdef_epilogue#+525)
	DD	@imagerel(write_userdef_epilogue#+582)
	DD	@imagerel($chain$10$write_userdef_epilogue#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
is_exitm$ = 64
reglst$ = 80
buffer$ = 208
flag_iret$ = 1280
tokenarray$ = 1288
write_userdef_epilogue PROC NEAR

; 3835 : {

	mov	rax, rsp
	sub	rsp, 1272				; 000004f8H
	mov	QWORD PTR [rax+32], rdi
	mov	QWORD PTR [rax-8], r12
	mov	QWORD PTR [rax-16], r13
	mov	QWORD PTR [rax-32], r15

; 3836 :     uint_16 *regs;
; 3837 :     int i;
; 3838 :     char *p;
; 3839 :     bool is_exitm;
; 3840 :     struct proc_info   *info;
; 3841 :     int flags = CurrProc->sym.langtype; /* set bits 0-2 */

	mov	rax, QWORD PTR CurrProc
	movzx	edi, cl

; 3842 :     struct dsym *dir;
; 3843 :     char reglst[128];
; 3844 :     char buffer[MAX_LINE_LEN]; /* stores string for RunMacro() */
; 3845 : 
; 3846 :     dir = (struct dsym *)SymSearch( ModuleInfo.proc_epilogue );

	mov	rcx, QWORD PTR ModuleInfo+328
	mov	r12d, DWORD PTR [rax+84]
	mov	r15, rdx
	call	SymFind

; 3847 :     if (dir == NULL ||
; 3848 :         dir->sym.state != SYM_MACRO ||
; 3849 :         dir->sym.isfunc == TRUE ) {

	test	rax, rax
	mov	r13, rax
	je	$LN10@write_user@2
	cmp	DWORD PTR [rax+40], 9
	jne	$LN10@write_user@2
	test	BYTE PTR [rax+52], 2
	jne	$LN10@write_user@2

; 3851 :     }
; 3852 : 
; 3853 :     info = CurrProc->e.procinfo;

	mov	rdx, QWORD PTR CurrProc
	mov	QWORD PTR [rsp+1296], rsi

; 3854 : 
; 3855 : #if AMD64_SUPPORT
; 3856 :     /* to be compatible with ML64, translate FASTCALL to 0 (not 7) */
; 3857 :     if ( CurrProc->sym.langtype == LANG_FASTCALL && ModuleInfo.fctype == FCT_WIN64 )

	xor	esi, esi
	mov	ecx, DWORD PTR [rdx+84]
	mov	QWORD PTR [rsp+1248], r14
	mov	r14, QWORD PTR [rdx+104]
	cmp	ecx, 7
	jne	SHORT $LN9@write_user@2
	cmp	DWORD PTR ModuleInfo+376, 2
	cmove	r12d, esi
$LN9@write_user@2:

; 3858 :         flags = 0;
; 3859 : #endif
; 3860 :     if ( CurrProc->sym.langtype == LANG_C ||
; 3861 :          CurrProc->sym.langtype == LANG_SYSCALL ||
; 3862 :          CurrProc->sym.langtype == LANG_FASTCALL)

	cmp	ecx, 1
	je	SHORT $LN7@write_user@2
	cmp	ecx, 2
	je	SHORT $LN7@write_user@2
	cmp	ecx, 7
	jne	SHORT $LN8@write_user@2
$LN7@write_user@2:

; 3863 :         flags |= 0x10;

	or	r12d, 16
$LN8@write_user@2:

; 3864 : 
; 3865 :     flags |= ( CurrProc->sym.mem_type == MT_FAR ? 0x20 : 0 );
; 3866 :     flags |= ( CurrProc->sym.ispublic ? 0 : 0x40 );
; 3867 :     /* v2.11: set bit 7, the export flag */
; 3868 :     flags |= ( info->isexport ? 0x80 : 0 );
; 3869 :     flags |= flag_iret ? 0x100 : 0;  /* bit 8: 1 if IRET    */

	mov	cl, BYTE PTR [rdx+48]
	mov	al, BYTE PTR [r14+128]
	mov	r8d, 32					; 00000020H
	and	eax, 4
	not	cl
	mov	QWORD PTR [rsp+1280], rbx
	shr	ecx, 1
	shl	eax, 5

; 3870 : 
; 3871 :     p = reglst;

	lea	rbx, QWORD PTR reglst$[rsp]
	and	ecx, 64					; 00000040H
	or	ecx, eax
	cmp	DWORD PTR [rdx+44], 130			; 00000082H
	mov	eax, esi
	cmove	eax, r8d
	or	ecx, eax
	neg	dil
	sbb	eax, eax
	and	eax, 256				; 00000100H
	or	ecx, eax
	or	r12d, ecx

; 3872 :     if ( info->regslist ) {

	mov	rcx, QWORD PTR [r14]
	test	rcx, rcx
	je	SHORT $LN3@write_user@2

; 3873 :         int cnt = *info->regslist;

	movzx	esi, WORD PTR [rcx]
	mov	QWORD PTR [rsp+1288], rbp

; 3874 :         regs = info->regslist + cnt;
; 3875 :         for ( ; cnt; regs--, cnt-- ) {

	test	esi, esi
	lea	rbp, QWORD PTR [rcx+rsi*2]
	je	SHORT $LN18@write_user@2
	npad	1
$LL5@write_user@2:

; 3876 :             GetResWName( *regs, p );

	movzx	ecx, WORD PTR [rbp]
	mov	rdx, rbx
	call	GetResWName

; 3877 :             p += strlen( p );

	xor	eax, eax
	mov	rdi, rbx
	mov	rcx, -1
	repne scasb
	not	rcx
	dec	rcx
	add	rbx, rcx

; 3878 :             if ( cnt != 1 )

	cmp	esi, 1
	je	SHORT $LN4@write_user@2

; 3879 :                 *p++ = ',';

	mov	BYTE PTR [rbx], 44			; 0000002cH
	inc	rbx
$LN4@write_user@2:
	sub	rbp, 2
	dec	esi
	jne	SHORT $LL5@write_user@2

; 3851 :     }
; 3852 : 
; 3853 :     info = CurrProc->e.procinfo;

	jmp	SHORT $LN19@write_user@2
$LN18@write_user@2:
	xor	esi, esi
$LN19@write_user@2:
	mov	rbp, QWORD PTR [rsp+1288]
$LN3@write_user@2:

; 3880 :         }
; 3881 :     }
; 3882 :     *p = NULLC;

	mov	BYTE PTR [rbx], 0

; 3883 :     //strcat( reglst, ">" );
; 3884 : 
; 3885 :     /* v2.07: make the numeric arguments more Masm-compatible */
; 3886 :     //sprintf( buffer,"%s %s, %02XH, %02XH, %02XH, <<%s>>, <%s>", ModuleInfo.proc_epilogue,
; 3887 :     sprintf( buffer,"%s, 0%XH, 0%XH, 0%XH, <<%s>>, <%s>",
; 3888 :             CurrProc->sym.name, flags, info->parasize, info->localsize,
; 3889 :             reglst, info->prologuearg ? info->prologuearg : "" );

	mov	rax, QWORD PTR [r14+48]
	mov	r8, QWORD PTR CurrProc
	mov	r8, QWORD PTR [r8+8]
	test	rax, rax
	lea	rcx, OFFSET FLAT:$SG7468
	cmovne	rcx, rax
	lea	rax, QWORD PTR reglst$[rsp]
	lea	rdx, OFFSET FLAT:$SG7469
	mov	QWORD PTR [rsp+56], rcx
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR [r14+36]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR [r14+32]
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	r9d, r12d
	mov	DWORD PTR [rsp+32], eax
	call	sprintf

; 3890 :     i = Token_Count + 1;

	mov	edi, DWORD PTR ModuleInfo+496

; 3891 :     Tokenize( buffer, i, tokenarray, TOK_RESCAN );

	lea	rcx, QWORD PTR buffer$[rsp]
	lea	edx, DWORD PTR [rdi+1]
	mov	r9d, 1
	mov	r8, r15
	call	Tokenize

; 3892 : 
; 3893 :     /* if -EP is on, emit "epilogue: none" */
; 3894 :     if ( Options.preprocessor_stdout )

	cmp	BYTE PTR Options+134, 0
	mov	r14, QWORD PTR [rsp+1248]
	mov	rbx, QWORD PTR [rsp+1280]
	je	SHORT $LN1@write_user@2

; 3895 :         printf( "option epilogue:none\n" );

	lea	rcx, OFFSET FLAT:$SG7471
	call	printf
$LN1@write_user@2:

; 3896 : 
; 3897 :     RunMacro( dir, i, tokenarray, NULL, 0, &is_exitm );

	lea	rax, QWORD PTR is_exitm$[rsp]
	lea	edx, DWORD PTR [rdi+1]
	xor	r9d, r9d
	mov	QWORD PTR [rsp+40], rax
	mov	r8, r15
	mov	rcx, r13
	mov	DWORD PTR [rsp+32], esi
	call	RunMacro
	mov	rsi, QWORD PTR [rsp+1296]

; 3898 : 
; 3899 :     Token_Count = i - 1;

	mov	DWORD PTR ModuleInfo+496, edi

; 3900 :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN12@write_user@2
$LN10@write_user@2:

; 3850 :         return( EmitErr( EPILOGUE_MUST_BE_MACRO_PROC, ModuleInfo.proc_epilogue ) );

	mov	rdx, QWORD PTR ModuleInfo+328
	mov	ecx, 157				; 0000009dH
	call	EmitErr
$LN12@write_user@2:
	mov	r15, QWORD PTR [rsp+1240]
	mov	r13, QWORD PTR [rsp+1256]
	mov	r12, QWORD PTR [rsp+1264]
	mov	rdi, QWORD PTR [rsp+1304]

; 3901 : }

	add	rsp, 1272				; 000004f8H
	ret	0
write_userdef_epilogue ENDP
_TEXT	ENDS
PUBLIC	RetInstr
EXTRN	ParseLine:NEAR
xdata	SEGMENT
$unwind$RetInstr DD 0e2501H
	DD	085d425H
	DD	086c41eH
	DD	08b741aH
	DD	08a6416H
	DD	0895412H
	DD	088340eH
	DD	087010aH
xdata	ENDS
pdata	SEGMENT
$pdata$RetInstr DD @imagerel($LN28#)
	DD	@imagerel($LN28#+631)
	DD	@imagerel($unwind$RetInstr#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buffer$ = 32
i$ = 1088
tokenarray$ = 1096
count$ = 1104
RetInstr PROC NEAR

; 3909 : {

$LN28:
	mov	rax, rsp
	sub	rsp, 1080				; 00000438H
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	QWORD PTR [rax-8], r12
	movsxd	rsi, ecx
	mov	QWORD PTR [rax-16], r13

; 3910 :     struct proc_info   *info;
; 3911 :     bool        is_iret = FALSE;
; 3912 :     char        *p;
; 3913 : #ifdef DEBUG_OUT
; 3914 :     ret_code    rc;
; 3915 : #endif
; 3916 :     char        buffer[MAX_LINE_LEN]; /* stores modified RETN/RETF/IRET instruction */
; 3917 : 
; 3918 :     DebugMsg1(( "RetInstr() enter\n" ));
; 3919 : 
; 3920 : #if AMD64_SUPPORT
; 3921 :     if( tokenarray[i].tokval == T_IRET || tokenarray[i].tokval == T_IRETD || tokenarray[i].tokval == T_IRETQ )

	mov	r12, rsi
	xor	bpl, bpl
	shl	r12, 5
	mov	rbx, rdx
	mov	rdi, rsi
	mov	eax, DWORD PTR [r12+rdx+16]
	mov	r13d, r8d
	cmp	eax, 627				; 00000273H
	je	SHORT $LN20@RetInstr
	cmp	eax, 628				; 00000274H
	je	SHORT $LN20@RetInstr
	cmp	eax, 1217				; 000004c1H
	jne	SHORT $LN21@RetInstr
$LN20@RetInstr:

; 3922 : #else
; 3923 :     if( tokenarray[i].tokval == T_IRET || tokenarray[i].tokval == T_IRETD )
; 3924 : #endif
; 3925 :         is_iret = TRUE;

	mov	bpl, 1
$LN21@RetInstr:

; 3926 : 
; 3927 :     if ( ModuleInfo.epiloguemode == PEM_MACRO ) {

	cmp	BYTE PTR ModuleInfo+425, 1
	jne	SHORT $LN19@RetInstr

; 3928 : #if FASTPASS
; 3929 :         /* don't run userdefined epilogue macro if pass > 1 */
; 3930 :         if ( UseSavedState ) {

	cmp	BYTE PTR UseSavedState, 0
	je	SHORT $LN18@RetInstr

; 3931 :             if ( Parse_Pass > PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN17@RetInstr

; 3932 :                 DebugMsg(( "RetInstr() exit\n" ));
; 3933 :                 //return( NOT_ERROR );
; 3934 :                 return( ParseLine( tokenarray ) );

	mov	rcx, rdx
	call	ParseLine
	jmp	$LN22@RetInstr
$LN17@RetInstr:

; 3935 :             }
; 3936 :             /* handle the current line as if it is REPLACED by the macro content */
; 3937 :             *(LineStoreCurr->line) = ';';

	mov	rax, QWORD PTR LineStoreCurr
	mov	BYTE PTR [rax+16], 59			; 0000003bH
$LN18@RetInstr:

; 3938 :         }
; 3939 : #endif
; 3940 : #ifdef DEBUG_OUT
; 3941 :         rc = write_userdef_epilogue( is_iret, tokenarray );
; 3942 :         DebugMsg(( "RetInstr() exit\n" ));
; 3943 :         return( rc );
; 3944 : #else
; 3945 :         return( write_userdef_epilogue( is_iret, tokenarray ) );

	movzx	ecx, bpl
	call	write_userdef_epilogue
	jmp	$LN22@RetInstr
$LN19@RetInstr:

; 3946 : #endif
; 3947 :     }
; 3948 : 
; 3949 :     if ( ModuleInfo.list ) {

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN16@RetInstr

; 3950 :         LstWrite( LSTTYPE_DIRECTIVE, GetCurrOffset(), NULL );

	call	GetCurrOffset
	xor	r8d, r8d
	lea	ecx, QWORD PTR [r8+4]
	mov	edx, eax
	call	LstWrite
$LN16@RetInstr:

; 3951 :     }
; 3952 : 
; 3953 :     strcpy( buffer, tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [r12+rbx+8]
	lea	rdx, QWORD PTR buffer$[rsp]
	shl	rdi, 5
	sub	rdx, QWORD PTR [rdi+rbx+8]
	npad	10
$LL24@RetInstr:
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx+rcx-1], al
	jne	SHORT $LL24@RetInstr

; 3954 :     p = buffer + strlen( buffer );

	xor	eax, eax
	lea	rdi, QWORD PTR buffer$[rsp]
	mov	rcx, -1
	repne scasb
	not	rcx
	lea	rdi, QWORD PTR buffer$[rsp+rcx-1]

; 3955 : 
; 3956 :     write_default_epilogue();

	call	write_default_epilogue

; 3957 : 
; 3958 :     info = CurrProc->e.procinfo;
; 3959 : 
; 3960 :     /* skip this part for IRET */
; 3961 :     if( is_iret == FALSE ) {

	test	bpl, bpl
	mov	r11, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [r11+104]
	jne	SHORT $LN13@RetInstr

; 3962 :         if ( CurrProc->sym.mem_type == MT_FAR )

	cmp	DWORD PTR [r11+44], 130			; 00000082H
	jne	SHORT $LN14@RetInstr

; 3963 :             *p++ = 'f';   /* ret -> retf */

	mov	BYTE PTR [rdi], 102			; 00000066H
	inc	rdi

; 3964 :         else

	jmp	SHORT $LN13@RetInstr
$LN14@RetInstr:

; 3965 :             *p++ = 'n';     /* ret -> retn */

	mov	BYTE PTR [rdi], 110			; 0000006eH
	inc	rdi
$LN13@RetInstr:

; 3966 :     }
; 3967 :     i++; /* skip directive */

	inc	esi

; 3968 :     if ( info->parasize || ( count != i ) )

	cmp	DWORD PTR [rcx+32], 0
	jne	SHORT $LN11@RetInstr
	cmp	r13d, esi
	je	SHORT $LN12@RetInstr
$LN11@RetInstr:

; 3969 :         *p++ = ' ';

	mov	BYTE PTR [rdi], 32			; 00000020H
	inc	rdi
$LN12@RetInstr:

; 3970 :     *p = NULLC;
; 3971 :     /* RET without argument? Then calculate the value */
; 3972 :     if( is_iret == FALSE && count == i ) {

	test	bpl, bpl
	mov	BYTE PTR [rdi], 0
	jne	$LN10@RetInstr
	cmp	r13d, esi
	jne	$LN10@RetInstr

; 3973 :         if ( ModuleInfo.epiloguemode != PEM_NONE ) {

	cmp	BYTE PTR ModuleInfo+425, 2
	je	$LN1@RetInstr

; 3974 :             switch( CurrProc->sym.langtype ) {

	mov	eax, DWORD PTR [r11+84]
	cmp	eax, 3
	je	SHORT $LN3@RetInstr
	cmp	eax, 3
	jle	$LN1@RetInstr
	cmp	eax, 6
	jle	SHORT $LN6@RetInstr
	cmp	eax, 7
	jne	$LN1@RetInstr

; 3982 :             case LANG_FASTCALL:
; 3983 :                 fastcall_tab[ModuleInfo.fctype].handlereturn( CurrProc, buffer );

	movsxd	rax, DWORD PTR ModuleInfo+376
	lea	rdi, OFFSET FLAT:fastcall_tab+8
	lea	rdx, QWORD PTR buffer$[rsp]
	add	rax, rax
	mov	rcx, r11
	call	QWORD PTR [rdi+rax*8]

; 3984 :                 break;

	jmp	$LN1@RetInstr
$LN6@RetInstr:

; 3975 :             case LANG_BASIC:
; 3976 :             case LANG_FORTRAN:
; 3977 :             case LANG_PASCAL:
; 3978 :                 if( info->parasize != 0 ) {

	mov	r8d, DWORD PTR [rcx+32]
	test	r8d, r8d
	je	$LN1@RetInstr

; 3979 :                     sprintf( p, "%d%c", info->parasize, ModuleInfo.radix != 10 ? 't' : NULLC );

	xor	r9d, r9d
	cmp	BYTE PTR ModuleInfo+396, 10
	mov	eax, 116				; 00000074H
	lea	rdx, OFFSET FLAT:$SG7504
	mov	rcx, rdi
	cmovne	r9d, eax
	call	sprintf

; 3980 :                 }
; 3981 :                 break;

	jmp	SHORT $LN1@RetInstr
$LN3@RetInstr:

; 3985 :             case LANG_STDCALL:
; 3986 :                 if( !info->has_vararg && info->parasize != 0 ) {

	test	BYTE PTR [rcx+128], 1
	jne	SHORT $LN1@RetInstr
	mov	r8d, DWORD PTR [rcx+32]
	test	r8d, r8d
	je	SHORT $LN1@RetInstr

; 3987 :                     sprintf( p, "%d%c", info->parasize, ModuleInfo.radix != 10 ? 't' : NULLC  );

	xor	r9d, r9d
	cmp	BYTE PTR ModuleInfo+396, 10
	mov	eax, 116				; 00000074H
	lea	rdx, OFFSET FLAT:$SG7508
	mov	rcx, rdi
	cmovne	r9d, eax
	call	sprintf

; 3988 :                 }
; 3989 :                 break;
; 3990 :             }
; 3991 :         }
; 3992 :     } else {

	jmp	SHORT $LN1@RetInstr
$LN10@RetInstr:

; 3993 :         /* v2.04: changed. Now works for both RET nn and IRETx */
; 3994 :         /* v2.06: changed. Now works even if RET has ben "renamed" */
; 3995 :         strcpy( p, tokenarray[i].tokpos );

	movsxd	rcx, esi
	mov	rax, rcx
	shl	rcx, 5
	shl	rax, 5
	sub	rdi, QWORD PTR [rcx+rbx+24]
	mov	rdx, QWORD PTR [rax+rbx+24]
	npad	8
$LL25@RetInstr:
	movzx	eax, BYTE PTR [rdx]
	inc	rdx
	test	al, al
	mov	BYTE PTR [rdi+rdx-1], al
	jne	SHORT $LL25@RetInstr
$LN1@RetInstr:

; 3996 :     }
; 3997 :     AddLineQueue( buffer );

	lea	rcx, QWORD PTR buffer$[rsp]
	call	AddLineQueue

; 3998 :     RunLineQueue();

	call	RunLineQueue

; 3999 : 
; 4000 :     DebugMsg1(( "RetInstr() exit\n" ));
; 4001 : 
; 4002 :     return( NOT_ERROR );

	xor	eax, eax
$LN22@RetInstr:
	mov	r13, QWORD PTR [rsp+1064]
	mov	r12, QWORD PTR [rsp+1072]
	mov	rdi, QWORD PTR [rsp+1112]
	mov	rsi, QWORD PTR [rsp+1104]
	mov	rbp, QWORD PTR [rsp+1096]
	mov	rbx, QWORD PTR [rsp+1088]

; 4003 : }

	add	rsp, 1080				; 00000438H
	ret	0
RetInstr ENDP
_TEXT	ENDS
PUBLIC	ProcInit
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
ProcInit PROC NEAR

; 4010 :     ProcStack = NULL;

	xor	eax, eax

; 4011 :     CurrProc  = NULL;
; 4012 :     procidx = 1;

	mov	DWORD PTR procidx, 1

; 4013 :     ProcStatus = 0;
; 4014 :     /* v2.09: reset prolog and epilog mode */
; 4015 :     ModuleInfo.prologuemode = PEM_DEFAULT;
; 4016 :     ModuleInfo.epiloguemode = PEM_DEFAULT;
; 4017 :     /* v2.06: no forward references in INVOKE if -Zne is set */
; 4018 :     ModuleInfo.invoke_exprparm = ( Options.strict_masm_compat ? EXPF_NOUNDEF : 0 );
; 4019 : #if STACKBASESUPP
; 4020 :     ModuleInfo.basereg[USE16] = T_BP;

	mov	DWORD PTR ModuleInfo+500, 14
	mov	QWORD PTR ProcStack, rax
	mov	QWORD PTR CurrProc, rax
	mov	DWORD PTR ProcStatus, eax
	mov	BYTE PTR ModuleInfo+424, al
	mov	BYTE PTR ModuleInfo+425, al
	movzx	eax, BYTE PTR Options+136
	neg	al

; 4021 :     ModuleInfo.basereg[USE32] = T_EBP;

	mov	DWORD PTR ModuleInfo+504, 22

; 4022 : #if AMD64_SUPPORT
; 4023 :     ModuleInfo.basereg[USE64] = T_RBP;

	mov	DWORD PTR ModuleInfo+508, 120		; 00000078H
	sbb	cl, cl

; 4024 : #endif
; 4025 : #endif
; 4026 : #if AMD64_SUPPORT
; 4027 :     unw_segs_defined = 0;

	mov	BYTE PTR unw_segs_defined, 0
	and	cl, 2
	mov	BYTE PTR ModuleInfo+426, cl

; 4028 : #endif
; 4029 : }

	ret	0
ProcInit ENDP
_TEXT	ENDS
EXTRN	LstSetPosition:NEAR
xdata	SEGMENT
$unwind$ProcFini DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$ProcFini DD @imagerel(ProcFini#)
	DD	@imagerel(ProcFini#+11)
	DD	@imagerel($unwind$ProcFini#)
pdata	ENDS
xdata	SEGMENT
$chain$1$ProcFini DD 044921H
	DD	083449H
	DD	097405H
	DD	@imagerel(ProcFini#)
	DD	@imagerel(ProcFini#+11)
	DD	@imagerel($unwind$ProcFini#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$ProcFini DD @imagerel(ProcFini#+11)
	DD	@imagerel(ProcFini#+364)
	DD	@imagerel($chain$1$ProcFini#)
pdata	ENDS
xdata	SEGMENT
$chain$2$ProcFini DD 020021H
	DD	083400H
	DD	@imagerel(ProcFini#)
	DD	@imagerel(ProcFini#+11)
	DD	@imagerel($unwind$ProcFini#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$ProcFini DD @imagerel(ProcFini#+364)
	DD	@imagerel(ProcFini#+504)
	DD	@imagerel($chain$2$ProcFini#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
proc$ = 48
ProcFini PROC NEAR

; 1834 : {

	sub	rsp, 40					; 00000028H

; 1835 :     struct dsym *curr;
; 1836 :     /* v2.06: emit an error if current segment isn't equal to
; 1837 :      * the one of the matching PROC directive. Close the proc anyway!
; 1838 :      */
; 1839 :     if ( proc->sym.segment == &CurrSeg->sym ) {

	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx
	cmp	QWORD PTR [rcx+32], rax
	jne	SHORT $LN25@ProcFini

; 1840 :         proc->sym.total_size = GetCurrOffset() - proc->sym.offset;

	call	GetCurrOffset
	sub	eax, DWORD PTR [rdi+16]
	mov	DWORD PTR [rdi+64], eax

; 1841 :     } else {

	jmp	SHORT $LN24@ProcFini
$LN25@ProcFini:

; 1842 :         DebugMsg1(("ProcFini(%s): unmatched block nesting error, proc->seg=%s, CurrSeg=%s\n",
; 1843 :                    proc->sym.name, proc->sym.segment->name, CurrSeg ? CurrSeg->sym.name : "NULL" ));
; 1844 :         EmitErr( UNMATCHED_BLOCK_NESTING, proc->sym.name );

	mov	rdx, QWORD PTR [rcx+8]
	mov	ecx, 142				; 0000008eH
	call	EmitErr

; 1845 :         proc->sym.total_size = CurrProc->sym.segment->offset - proc->sym.offset;

	mov	r11, QWORD PTR CurrProc
	mov	rax, QWORD PTR [r11+32]
	mov	ecx, DWORD PTR [rax+16]
	sub	ecx, DWORD PTR [rdi+16]
	mov	DWORD PTR [rdi+64], ecx
$LN24@ProcFini:

; 1846 :     }
; 1847 : 
; 1848 :     /* v2.03: for W3+, check for unused params and locals */
; 1849 :     if ( Options.warning_level > 2 && Parse_Pass == PASS_1 ) {

	cmp	BYTE PTR Options+13, 2
	mov	QWORD PTR [rsp+64], rbx
	jbe	SHORT $LN41@ProcFini
	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN42@ProcFini

; 1850 :         for ( curr = proc->e.procinfo->paralist; curr; curr = curr->nextparam ) {

	mov	rax, QWORD PTR [rdi+104]
	mov	rbx, QWORD PTR [rax+8]
	test	rbx, rbx
	je	SHORT $LN20@ProcFini
$LL22@ProcFini:

; 1851 :             if ( curr->sym.used == FALSE )

	test	BYTE PTR [rbx+48], 1
	jne	SHORT $LN21@ProcFini

; 1852 :                 EmitWarn( 3, PROCEDURE_ARGUMENT_OR_LOCAL_NOT_REFERENCED, curr->sym.name );

	mov	r8, QWORD PTR [rbx+8]
	mov	edx, 266				; 0000010aH
	mov	ecx, 3
	call	EmitWarn
$LN21@ProcFini:
	mov	rbx, QWORD PTR [rbx+120]
	test	rbx, rbx
	jne	SHORT $LL22@ProcFini
$LN20@ProcFini:

; 1853 :         }
; 1854 :         for ( curr = proc->e.procinfo->locallist; curr; curr = curr->nextlocal ) {

	mov	rax, QWORD PTR [rdi+104]
	mov	rbx, QWORD PTR [rax+16]
	test	rbx, rbx
	je	SHORT $LN41@ProcFini
	npad	1
$LL18@ProcFini:

; 1855 :             if ( curr->sym.used == FALSE )

	test	BYTE PTR [rbx+48], 1
	jne	SHORT $LN17@ProcFini

; 1856 :                 EmitWarn( 3, PROCEDURE_ARGUMENT_OR_LOCAL_NOT_REFERENCED, curr->sym.name );

	mov	r8, QWORD PTR [rbx+8]
	mov	edx, 266				; 0000010aH
	mov	ecx, 3
	call	EmitWarn
$LN17@ProcFini:
	mov	rbx, QWORD PTR [rbx+120]
	test	rbx, rbx
	jne	SHORT $LL18@ProcFini
$LN41@ProcFini:

; 1857 :         }
; 1858 :     }
; 1859 : #if AMD64_SUPPORT
; 1860 :     /* save stack space reserved for INVOKE if OPTION WIN64:2 is set */
; 1861 :     if ( Parse_Pass == PASS_1 &&
; 1862 :         ModuleInfo.fctype == FCT_WIN64 &&
; 1863 :         ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN42@ProcFini
	cmp	DWORD PTR ModuleInfo+376, 2
	jne	SHORT $LN42@ProcFini
	test	BYTE PTR ModuleInfo+413, 2
	je	SHORT $LN42@ProcFini

; 1864 : 		proc->e.procinfo->ReservedStack = sym_ReservedStack->value;

	mov	rax, QWORD PTR sym_ReservedStack
	mov	rdx, QWORD PTR [rdi+104]
	mov	ecx, DWORD PTR [rax+16]
	mov	DWORD PTR [rdx+96], ecx

; 1865 :         DebugMsg1(("ProcFini(%s): localsize=%u ReservedStack=%u\n", proc->sym.name, proc->e.procinfo->localsize, proc->e.procinfo->ReservedStack ));
; 1866 : #if STACKBASESUPP
; 1867 :         if ( proc->e.procinfo->fpo ) {

	mov	rdx, QWORD PTR [rdi+104]
	test	BYTE PTR [rdx+128], 128			; 00000080H
	je	SHORT $LN42@ProcFini

; 1868 :             for ( curr = proc->e.procinfo->locallist; curr; curr = curr->nextlocal ) {

	mov	rdx, QWORD PTR [rdx+16]
	test	rdx, rdx
	je	SHORT $LN10@ProcFini
	npad	12
$LL12@ProcFini:

; 1869 :                 DebugMsg1(("ProcFini(%s): FPO, offset for %s %8d -> %8d\n", proc->sym.name, curr->sym.name, curr->sym.offset, curr->sym.offset + proc->e.procinfo->ReservedStack ));
; 1870 :                 curr->sym.offset += proc->e.procinfo->ReservedStack;

	mov	rax, QWORD PTR [rdi+104]
	mov	ecx, DWORD PTR [rax+96]
	add	DWORD PTR [rdx+16], ecx
	mov	rdx, QWORD PTR [rdx+120]
	test	rdx, rdx
	jne	SHORT $LL12@ProcFini
$LN10@ProcFini:

; 1871 :             }
; 1872 :             for ( curr = proc->e.procinfo->paralist; curr; curr = curr->nextparam ) {

	mov	rax, QWORD PTR [rdi+104]
	mov	rdx, QWORD PTR [rax+8]
	test	rdx, rdx
	je	SHORT $LN42@ProcFini
$LL9@ProcFini:

; 1873 :                 DebugMsg1(("ProcFini(%s): FPO, offset for %s %8d -> %8d\n", proc->sym.name, curr->sym.name, curr->sym.offset, curr->sym.offset + proc->e.procinfo->ReservedStack ));
; 1874 :                 curr->sym.offset += proc->e.procinfo->ReservedStack;

	mov	rax, QWORD PTR [rdi+104]
	mov	ecx, DWORD PTR [rax+96]
	add	DWORD PTR [rdx+16], ecx
	mov	rdx, QWORD PTR [rdx+120]
	test	rdx, rdx
	jne	SHORT $LL9@ProcFini
$LN42@ProcFini:

; 1875 :             }
; 1876 :         }
; 1877 : #endif
; 1878 :     }
; 1879 : 
; 1880 :     /* create the .pdata and .xdata stuff */
; 1881 :     if ( proc->e.procinfo->isframe ) {

	mov	rax, QWORD PTR [rdi+104]
	test	BYTE PTR [rax+128], 64			; 00000040H
	je	SHORT $LN6@ProcFini

; 1882 : #if FASTPASS
; 1883 :         LstSetPosition(); /* needed if generated code is done BEFORE the line is listed */

	call	LstSetPosition

; 1884 : #endif
; 1885 :         WriteSEHData( proc );

	mov	rcx, rdi
	call	WriteSEHData
$LN6@ProcFini:

; 1886 :     }
; 1887 : #endif
; 1888 :     if ( ModuleInfo.list )

	bt	DWORD PTR ModuleInfo+408, 12
	mov	rdi, QWORD PTR [rsp+72]
	jae	SHORT $LN5@ProcFini

; 1889 :         LstWrite( LSTTYPE_LABEL, 0, NULL );

	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+7]
	call	LstWrite
$LN5@ProcFini:

; 1890 : 
; 1891 :     /* create the list of locals */
; 1892 :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN4@ProcFini

; 1893 :         /* in case the procedure is empty, init addresses of local variables ( for proper listing ) */
; 1894 :         if( ProcStatus & PRST_PROLOGUE_NOT_DONE )

	test	BYTE PTR ProcStatus, -128		; ffffffffffffff80H
	je	SHORT $LN3@ProcFini

; 1895 :             SetLocalOffsets( CurrProc->e.procinfo );

	mov	rcx, QWORD PTR CurrProc
	mov	rcx, QWORD PTR [rcx+104]
	call	SetLocalOffsets
$LN3@ProcFini:

; 1896 :         SymGetLocal( (struct asym *)CurrProc );

	mov	rcx, QWORD PTR CurrProc
	call	SymGetLocal
$LN4@ProcFini:

; 1897 :     }
; 1898 : 
; 1899 :     CurrProc = pop_proc();

	mov	rcx, QWORD PTR ProcStack
	xor	ebx, ebx
	test	rcx, rcx
	jne	SHORT $LN28@ProcFini
	mov	rcx, rbx
	jmp	SHORT $LN29@ProcFini
$LN28@ProcFini:
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR ProcStack, rax
	mov	rcx, QWORD PTR [rcx+8]
$LN29@ProcFini:

; 1900 :     if ( CurrProc )

	test	rcx, rcx
	mov	QWORD PTR CurrProc, rcx
	je	SHORT $LN2@ProcFini

; 1901 :         SymSetLocal( (struct asym *)CurrProc );  /* restore local symbol table */

	call	SymSetLocal
$LN2@ProcFini:

; 1902 : 
; 1903 :     ProcStatus = 0; /* in case there was an empty PROC/ENDP pair */
; 1904 : 	if(sym_ReservedStack)

	mov	rax, QWORD PTR sym_ReservedStack
	mov	DWORD PTR ProcStatus, ebx
	test	rax, rax
	je	SHORT $LN1@ProcFini

; 1905 : 		sym_ReservedStack->value = 0;

	mov	DWORD PTR [rax+16], ebx
$LN1@ProcFini:
	mov	rbx, QWORD PTR [rsp+64]

; 1906 : }

	add	rsp, 40					; 00000028H
	ret	0
ProcFini ENDP
_TEXT	ENDS
PUBLIC	EndpDir
EXTRN	SymCmpFunc:QWORD
xdata	SEGMENT
$unwind$EndpDir DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$EndpDir DD @imagerel($LN8#)
	DD	@imagerel($LN8#+144)
	DD	@imagerel($unwind$EndpDir#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
EndpDir	PROC NEAR

; 1912 : {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1913 : 	struct asym*        procline;
; 1914 : 
; 1915 : 	DebugMsg1(("EndpDir(%s) enter, curr ofs=% " I32_SPEC "X, CurrProc=%s\n", tokenarray[0].string_ptr, GetCurrOffset(), CurrProc ? CurrProc->sym.name : "NULL" ));
; 1916 :     if( i != 1 || tokenarray[2].token != T_FINAL ) {

	cmp	ecx, 1
	mov	rbx, rdx
	jne	SHORT $LN3@EndpDir
	cmp	BYTE PTR [rdx+64], 0
	jne	SHORT $LN3@EndpDir

; 1918 :     }
; 1919 :     /* v2.10: "+ 1" added to CurrProc->sym.name_size */
; 1920 :     if( CurrProc &&
; 1921 :        ( SymCmpFunc(CurrProc->sym.name, tokenarray[0].string_ptr, CurrProc->sym.name_size + 1 ) == 0 ) ) {

	mov	rcx, QWORD PTR CurrProc
	test	rcx, rcx
	je	SHORT $LN2@EndpDir
	movzx	eax, BYTE PTR [rcx+80]
	mov	rdx, QWORD PTR [rdx+8]
	mov	rcx, QWORD PTR [rcx+8]
	inc	eax
	movsxd	r8, eax
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	jne	SHORT $LN2@EndpDir

; 1922 :      
; 1923 : 		/* Reset the current source code line relating to the PROC */
; 1924 : 		procline = SymFind("@ProcLine");

	lea	rcx, OFFSET FLAT:$SG6703
	call	SymFind

; 1925 : 		procline->value = 0;

	mov	DWORD PTR [rax+16], 0

; 1926 : 
; 1927 : 		ProcFini( CurrProc );

	mov	rcx, QWORD PTR CurrProc
	call	ProcFini

; 1930 :     }
; 1931 :     return( NOT_ERROR );

	xor	eax, eax

; 1932 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@EndpDir:

; 1928 :     } else {
; 1929 :         return( EmitErr( UNMATCHED_BLOCK_NESTING, tokenarray[0].string_ptr ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 142				; 0000008eH

; 1932 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	EmitErr
$LN3@EndpDir:

; 1917 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbx+24]

; 1932 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	EmitErr
EndpDir	ENDP
_TEXT	ENDS
PUBLIC	ProcCheckOpen
xdata	SEGMENT
$unwind$ProcCheckOpen DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$ProcCheckOpen DD @imagerel($LN7#)
	DD	@imagerel($LN7#+59)
	DD	@imagerel($unwind$ProcCheckOpen#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
ProcCheckOpen PROC NEAR

; 2226 : {

$LN7:
	sub	rsp, 40					; 00000028H

; 2227 :     while( CurrProc != NULL ) {

	mov	rax, QWORD PTR CurrProc
	test	rax, rax
	je	SHORT $LN1@ProcCheckO
$LL2@ProcCheckO:

; 2228 :         DebugMsg1(("ProcCheckOpen: unmatched block nesting error, CurrProc=%s\n", CurrProc->sym.name ));
; 2229 :         EmitErr( UNMATCHED_BLOCK_NESTING, CurrProc->sym.name );

	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 142				; 0000008eH
	call	EmitErr

; 2230 :         ProcFini( CurrProc );

	mov	rcx, QWORD PTR CurrProc
	call	ProcFini
	mov	rax, QWORD PTR CurrProc
	test	rax, rax
	jne	SHORT $LL2@ProcCheckO
$LN1@ProcCheckO:

; 2231 :     }
; 2232 : }

	add	rsp, 40					; 00000028H
	ret	0
ProcCheckOpen ENDP
_TEXT	ENDS
END
