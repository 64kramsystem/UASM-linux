; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG5605	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
EXTRN	InstrTable:BYTE
EXTRN	optable_idx:BYTE
EXTRN	OutputByte:NEAR
EXTRN	EmitWarn:NEAR
EXTRN	Parse_Pass:DWORD
xdata	SEGMENT
$unwind$jumpExtend DD 051501H
	DD	097415H
	DD	083410H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$jumpExtend DD @imagerel(jumpExtend#)
	DD	@imagerel(jumpExtend#+179)
	DD	@imagerel($unwind$jumpExtend#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\branch.c
pdata	ENDS
_TEXT	SEGMENT
CodeInfo$ = 48
far_flag$ = 56
jumpExtend PROC NEAR

; 76   : {

	sub	rsp, 40					; 00000028H

; 77   :     //uint_8 opcode;
; 78   :     unsigned next_ins_size;
; 79   : 
; 80   :     if( Parse_Pass == PASS_2 )

	cmp	DWORD PTR Parse_Pass, 1
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx
	mov	ebx, edx
	jne	SHORT $LN5@jumpExtend

; 81   :         EmitWarn( 4, EXTENDING_JUMP );

	mov	edx, 127				; 0000007fH
	lea	ecx, QWORD PTR [rdx-123]
	call	EmitWarn
$LN5@jumpExtend:

; 82   : 
; 83   :     DebugMsg(("jumpExtend(far=%u), pass=%u, curr offset=%X, Ofssize=%u\n", far_flag, Parse_Pass + 1, GetCurrOffset(), CodeInfo->Ofssize ));
; 84   :     if( far_flag ) {

	test	ebx, ebx
	je	SHORT $LN4@jumpExtend

; 85   :         if ( CodeInfo->prefix.opsiz ) {

	test	BYTE PTR [rdi+9], 2
	je	SHORT $LN3@jumpExtend

; 86   :             /* it's 66 EA OOOO SSSS or 66 EA OOOOOOOO SSSS */
; 87   :             next_ins_size = CodeInfo->Ofssize ? 6 : 8;

	cmp	BYTE PTR [rdi+106], 0
	mov	ebx, 8
	mov	eax, 6
	cmovne	ebx, eax

; 88   :         } else {

	jmp	SHORT $LN1@jumpExtend
$LN3@jumpExtend:

; 89   :             /* it's EA OOOOOOOO SSSS or EA OOOO SSSS */
; 90   :             next_ins_size = CodeInfo->Ofssize ? 7 : 5;

	cmp	BYTE PTR [rdi+106], 0
	mov	ebx, 5
	mov	eax, 7
	cmovne	ebx, eax

; 91   :         }
; 92   :     } else {

	jmp	SHORT $LN1@jumpExtend
$LN4@jumpExtend:

; 93   :         /* it's E9 OOOOOOOO or E9 OOOO */
; 94   :         next_ins_size = CodeInfo->Ofssize ? 5 : 3;

	cmp	BYTE PTR [rdi+106], 0
	mov	ebx, 5
	mov	eax, 3
	cmovne	eax, ebx
	mov	ebx, eax
$LN1@jumpExtend:

; 95   :     }
; 96   : 
; 97   :     /* it's ensured that the short jump version is first in InstrTable */
; 98   :     //opcode = InstrTable[optable_idx[CodeInfo->token]].opcode;
; 99   :     //OutputCodeByte( opcode ^ 1 );
; 100  :     /* the negation is achieved by XOR 1 */
; 101  :     OutputCodeByte( CodeInfo->pinstr->opcode ^ 1 );

	mov	rax, QWORD PTR [rdi+16]
	movzx	ecx, BYTE PTR [rax+12]
	xor	cl, 1
	call	OutputByte

; 102  :     OutputCodeByte( next_ins_size );

	movzx	ecx, bl
	call	OutputByte
	mov	rbx, QWORD PTR [rsp+64]

; 103  :     CodeInfo->token = T_JMP;

	mov	DWORD PTR [rdi+24], 456			; 000001c8H

; 104  :     CodeInfo->pinstr = &InstrTable[ IndexFromToken( T_JMP )];

	movzx	eax, WORD PTR optable_idx+2
	lea	rcx, OFFSET FLAT:InstrTable
	imul	rax, 14
	add	rax, rcx
	mov	QWORD PTR [rdi+16], rax
	mov	rdi, QWORD PTR [rsp+72]

; 105  : 
; 106  :     return;
; 107  : }

	add	rsp, 40					; 00000028H
	ret	0
jumpExtend ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$FarCallToNear DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$FarCallToNear DD @imagerel(FarCallToNear#)
	DD	@imagerel(FarCallToNear#+53)
	DD	@imagerel($unwind$FarCallToNear#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
CodeInfo$ = 48
FarCallToNear PROC NEAR

; 114  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 115  :     if( Parse_Pass == PASS_2 )

	cmp	DWORD PTR Parse_Pass, 1
	mov	rbx, rcx
	jne	SHORT $LN1@FarCallToN

; 116  :         EmitWarn( 4, CALL_FAR_TO_NEAR );

	mov	edx, 133				; 00000085H
	mov	ecx, 4
	call	EmitWarn
$LN1@FarCallToN:

; 117  : 
; 118  :     OutputCodeByte( 0x0E ); /* 0x0E is "PUSH CS" opcode */

	mov	cl, 14
	call	OutputByte

; 119  :     CodeInfo->mem_type = MT_NEAR;

	mov	DWORD PTR [rbx+28], 129			; 00000081H

; 120  : 
; 121  :     return;
; 122  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
FarCallToNear ENDP
_TEXT	ENDS
PUBLIC	process_branch
EXTRN	CreateFixup:NEAR
EXTRN	set_frame:NEAR
EXTRN	GetSymOfssize:NEAR
EXTRN	GetOverrideAssume:NEAR
EXTRN	GetCurrOffset:NEAR
EXTRN	ModuleInfo:BYTE
EXTRN	EmitErr:NEAR
EXTRN	SegOverride:QWORD
EXTRN	segm_override:NEAR
EXTRN	EmitError:NEAR
EXTRN	__ImageBase:BYTE
xdata	SEGMENT
$unwind$process_branch DD 0bef01H
	DD	09d4efH
	DD	0e64e8H
	DD	08e423H
	DD	0d5414H
	DD	0c340fH
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$process_branch DD @imagerel($LN157#)
	DD	@imagerel($LN157#+273)
	DD	@imagerel($unwind$process_branch#)
pdata	ENDS
xdata	SEGMENT
$chain$7$process_branch DD 061321H
	DD	07f413H
	DD	0ac40aH
	DD	0f7405H
	DD	@imagerel($LN157#)
	DD	@imagerel($LN157#+273)
	DD	@imagerel($unwind$process_branch#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$process_branch DD @imagerel($LN157#+273)
	DD	@imagerel($LN157#+2332)
	DD	@imagerel($chain$7$process_branch#)
pdata	ENDS
xdata	SEGMENT
$chain$8$process_branch DD 021H
	DD	@imagerel($LN157#)
	DD	@imagerel($LN157#+273)
	DD	@imagerel($unwind$process_branch#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$process_branch DD @imagerel($LN157#+2332)
	DD	@imagerel($LN157#+2362)
	DD	@imagerel($chain$8$process_branch#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
state$1$ = 32
CodeInfo$ = 96
CurrOpnd$ = 104
opndx$ = 112
process_branch PROC NEAR

; 135  : {

$LN157:
	sub	rsp, 88					; 00000058H

; 136  :     int_32              addr;
; 137  :     enum fixup_types    fixup_type;
; 138  :     enum fixup_options  fixup_option;
; 139  :     enum sym_state      state;
; 140  :     struct asym         *sym;
; 141  :     enum memtype        mem_type;
; 142  :     struct dsym         *symseg;
; 143  :     unsigned            opidx = IndexFromToken( CodeInfo->token );
; 144  : 
; 145  :     /* v2.05: just 1 operand possible */
; 146  :     if ( CurrOpnd != OPND1 ) {

	test	edx, edx
	movsxd	rax, DWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+96], rbx
	mov	QWORD PTR [rsp+104], rbp
	mov	rbx, rcx
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [rsp+64], r14
	movzx	r14d, WORD PTR optable_idx[rcx+rax*2-910]
	mov	rbp, r8
	je	SHORT $LN127@process_br

; 147  :         //EmitError( SYNTAX_ERROR ); /* v2.10: error msg changed */
; 148  :         return( EmitError( INVALID_INSTRUCTION_OPERANDS ) );

	mov	ecx, 49					; 00000031H
	mov	r14, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+96]

; 632  : }

	add	rsp, 88					; 00000058H
	jmp	EmitError
$LN127@process_br:

; 149  :     }
; 150  :     if ( opndx->explicit && opndx->instr != T_SHORT )

	test	BYTE PTR [r8+72], 2
	je	SHORT $LN126@process_br
	cmp	DWORD PTR [r8+56], 245			; 000000f5H
	je	SHORT $LN126@process_br

; 151  :         CodeInfo->mem_type = opndx->mem_type;

	mov	eax, DWORD PTR [r8+64]
	mov	DWORD PTR [rbx+28], eax
$LN126@process_br:

; 152  :     /*
; 153  :      * Masm checks overrides for branch instructions with immediate operand!
; 154  :      * Of course, no segment prefix byte is emitted - would be pretty useless.
; 155  :      * It might cause the call/jmp to become FAR, though.
; 156  :      */
; 157  :     if ( opndx->override != NULL ) {

	cmp	QWORD PTR [r8+48], 0
	je	SHORT $LN122@process_br

; 158  :         segm_override( opndx, NULL );

	xor	edx, edx
	mov	rcx, r8
	call	segm_override

; 159  :         DebugMsg(("process_branch(%" I32_SPEC "X): segment override %s\n", GetCurrOffset(), SegOverride ? SegOverride->name : "NULL" ));
; 160  :         if ( SegOverride && opndx->sym && opndx->sym->segment ) {

	mov	r11, QWORD PTR SegOverride
	test	r11, r11
	je	SHORT $LN122@process_br
	mov	rdx, QWORD PTR [rbp+80]
	test	rdx, rdx
	je	SHORT $LN122@process_br
	mov	rax, QWORD PTR [rdx+32]
	test	rax, rax
	je	SHORT $LN122@process_br

; 161  :             if ( SegOverride != opndx->sym->segment &&  SegOverride != ((struct dsym *)opndx->sym->segment)->e.seginfo->group ) {

	cmp	r11, rax
	je	SHORT $LN123@process_br
	mov	rax, QWORD PTR [rax+104]
	cmp	r11, QWORD PTR [rax]
	je	SHORT $LN123@process_br

; 162  :                 return( EmitErr( CANNOT_ACCESS_LABEL_THROUGH_SEGMENT_REGISTERS, opndx->sym ? opndx->sym->name : "" ) );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 89					; 00000059H
	mov	r14, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+96]

; 632  : }

	add	rsp, 88					; 00000058H
	jmp	EmitErr
$LN123@process_br:

; 163  :             }
; 164  :             /* v2.05: switch to far jmp/call */
; 165  :             if ( SegOverride != &CurrSeg->sym && SegOverride != CurrSeg->e.seginfo->group ) {

	mov	rax, QWORD PTR ModuleInfo+432
	cmp	r11, rax
	je	SHORT $LN122@process_br
	mov	rax, QWORD PTR [rax+104]
	cmp	r11, QWORD PTR [rax]
	je	SHORT $LN122@process_br

; 166  :                 DebugMsg(("process_branch(%" I32_SPEC "X): segment override %s caused FAR jmp/call\n", GetCurrOffset(), SegOverride->name ));
; 167  :                 //CodeInfo->isfar = TRUE;
; 168  :                 CodeInfo->mem_type = MT_FAR;

	mov	DWORD PTR [rbx+28], 130			; 00000082H
$LN122@process_br:

; 169  :             }
; 170  :         }
; 171  :     }
; 172  : 
; 173  :     CodeInfo->opnd[OPND1].data32l = opndx->value;

	mov	eax, DWORD PTR [rbp]
	mov	QWORD PTR [rsp+112], rsi

; 174  :     /* v2.06: make sure, that next bytes are cleared (for OP_I48)! */
; 175  :     CodeInfo->opnd[OPND1].data32h = 0;

	xor	esi, esi
	mov	QWORD PTR [rsp+72], r13
	mov	DWORD PTR [rbx+44], esi
	mov	DWORD PTR [rbx+40], eax

; 176  :     sym = opndx->sym;

	mov	r13, QWORD PTR [rbp+80]

; 177  :     if( sym == NULL ) { /* no symbolic label specified? */

	test	r13, r13
	jne	SHORT $LN121@process_br

; 178  :         DebugMsg(("process_branch(%" I32_SPEC "X): sym=NULL, op.memtype=%Xh\n", GetCurrOffset(), opndx->mem_type ));
; 179  : 
; 180  :         /* Masm rejects: "jump dest must specify a label */
; 181  : #if NEEDLABEL
; 182  :         return( EmitError( JUMP_DESTINATION_MUST_SPECIFY_A_LABEL ) );

	mov	ecx, 249				; 000000f9H
	call	EmitError
	jmp	$LN149@process_br
$LN121@process_br:

; 183  : #else
; 184  :         if( IS_JMPCALL( CodeInfo->token ) )
; 185  :             CodeInfo->isfar = TRUE; /* ??? most likely nonsense! */
; 186  : 
; 187  :         if( CodeInfo->opnd[OPND1].data32l > USHRT_MAX )
; 188  :             CodeInfo->opnd[OPND1].type = OP_I32;
; 189  :         else
; 190  :             CodeInfo->opnd_type[OPND1] = OP_I16;
; 191  : 
; 192  :         return( NOT_ERROR );
; 193  : #endif
; 194  :     }
; 195  :     DebugMsg1(("process_branch(%" I32_SPEC "X, %s): opnd.explicit=%u/memtype=%X/Ofssize=%u CI.memtype=%X sym.state=%u/mem_type=%Xh/ofs=%" I32_SPEC "X/seg=%s\n",
; 196  :               GetCurrOffset(), sym->name, opndx->explicit, opndx->mem_type, opndx->Ofssize, CodeInfo->mem_type,
; 197  :               sym->state, sym->mem_type, sym->offset, sym->segment ? sym->segment->name : "NULL" ));
; 198  : 
; 199  :     state = sym->state;

	mov	eax, DWORD PTR [r13+40]
	mov	QWORD PTR [rsp+120], rdi
	mov	QWORD PTR [rsp+80], r12
	mov	DWORD PTR state$1$[rsp], eax
	mov	QWORD PTR [rsp+56], r15

; 200  :     addr = GetCurrOffset(); /* for SYM_UNDEFINED, will force distance to SHORT */

	call	GetCurrOffset

; 201  : 
; 202  :     /* v2.02: if symbol is GLOBAL and it isn't clear yet were
; 203  :      * it's located, then assume it is a forward reference (=SYM_UNDEFINED)!
; 204  :      * This applies to PROTOs and EXTERNDEFs in Pass 1.
; 205  :      */
; 206  :     if ( ( state == SYM_EXTERNAL ) && sym->weak ) {

	mov	ecx, DWORD PTR state$1$[rsp]
	mov	r8, QWORD PTR ModuleInfo+432
	mov	edi, 1
	cmp	ecx, 2
	mov	r12d, eax
	mov	r15d, 262144				; 00040000H
	jne	SHORT $LN120@process_br
	test	BYTE PTR [r13+55], 8
	je	SHORT $LN117@process_br

; 207  :         DebugMsg1(("process_branch(%s): EXTERNDEF assumed forward reference (=SYM_UNDEFINED)\n", sym->name ));
; 208  :         state = SYM_UNDEFINED;

	mov	DWORD PTR state$1$[rsp], esi

; 209  :     }
; 210  : 
; 211  :     /* v2.02: removed SYM_UNDEFINED. Don't check segment of such symbols! */
; 212  : //    if ( state == SYM_UNDEFINED || state == SYM_INTERNAL || state == SYM_EXTERNAL ) {
; 213  :     if ( state == SYM_INTERNAL || state == SYM_EXTERNAL ) {

	jmp	$LN139@process_br
$LN120@process_br:
	cmp	ecx, edi
	je	SHORT $LN136@process_br

; 249  :         }
; 250  :     } else if ( state != SYM_UNDEFINED ) {

	test	ecx, ecx
	je	$LN115@process_br

; 251  :         DebugMsg(("process_branch(%s): error, unexpected symbol state=%u\n", sym->name, sym->state ));
; 252  :         return( EmitErr( JUMP_DESTINATION_MUST_SPECIFY_A_LABEL ) );

	mov	ecx, 249				; 000000f9H
	call	EmitErr
	jmp	$LN152@process_br
$LN136@process_br:

; 214  :         /* v2.04: if the symbol is internal, but wasn't met yet
; 215  :          * in this pass and its offset is < $, don't use current offset
; 216  :          */
; 217  :         if ( state == SYM_INTERNAL &&
; 218  :             sym->asmpass != ( Parse_Pass & 0xFF) &&
; 219  :             sym->offset < addr )

	mov	al, BYTE PTR [r13+54]
	cmp	al, BYTE PTR Parse_Pass
	je	SHORT $LN117@process_br
	cmp	DWORD PTR [r13+16], r12d
	jl	SHORT $LN116@process_br
$LN117@process_br:

; 220  :             ;
; 221  :         else
; 222  :             addr = sym->offset; /* v2.02: init addr, so sym->offset isn't changed */

	mov	r12d, DWORD PTR [r13+16]
$LN116@process_br:

; 223  :         symseg = GetSegm( sym );

	mov	rdx, QWORD PTR [r13+32]

; 224  :         if( symseg == NULL || ( CurrSeg != symseg ) ) {

	test	rdx, rdx
	je	SHORT $LN114@process_br
	cmp	r8, rdx
	je	SHORT $LN115@process_br
$LN114@process_br:

; 225  :             /* if label has a different segment and jump/call is near or short,
; 226  :              report an error */
; 227  :             //if ( ModuleInfo.flatgrp_idx != 0 )
; 228  :             /* v2.09: make sure there's no near jmp/call between 32- and 64-bit */
; 229  :             //if ( ModuleInfo.flat_grp )
; 230  :             if ( ModuleInfo.flat_grp
; 231  : #if AMD64_SUPPORT
; 232  :                 && ( symseg == NULL || symseg->e.seginfo->Ofssize == ModuleInfo.Ofssize )
; 233  : #endif
; 234  :                ) {

	cmp	QWORD PTR ModuleInfo+440, rsi
	je	SHORT $LN113@process_br
	test	rdx, rdx
	je	SHORT $LN107@process_br
	mov	rcx, QWORD PTR [rdx+104]
	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	BYTE PTR [rcx+104], al

; 235  :             } else if ( symseg != NULL && CurrSeg != NULL ) {

	je	SHORT $LN107@process_br
$LN113@process_br:
	test	rdx, rdx
	je	SHORT $LN107@process_br
	test	r8, r8
	je	SHORT $LN107@process_br

; 236  :                 /* if the segments belong to the same group, it's ok */
; 237  :                 if ( symseg->e.seginfo->group != NULL &&
; 238  :                     symseg->e.seginfo->group == CurrSeg->e.seginfo->group )

	mov	rax, QWORD PTR [rdx+104]
	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN109@process_br
	mov	rax, QWORD PTR [r8+104]
	cmp	rcx, QWORD PTR [rax]
	je	SHORT $LN107@process_br
$LN109@process_br:

; 239  :                     ;
; 240  :                 /* v2.05: added SegOverride condition */
; 241  :                 //else if ( opndx->mem_type == MT_NEAR ) {
; 242  :                 else if ( opndx->mem_type == MT_NEAR && SegOverride == NULL ) {

	cmp	DWORD PTR [rbp+64], 129			; 00000081H
	jne	SHORT $LN107@process_br
	cmp	QWORD PTR SegOverride, rsi
	jne	SHORT $LN107@process_br

; 243  :                     DebugMsg(("process_branch: error, opndx.mem_type is MT_NEAR\n" ));
; 244  :                     return( EmitError( CANNOT_HAVE_IMPLICIT_FAR_JUMP_OR_CALL_TO_NEAR_LABEL ) );

	mov	ecx, 169				; 000000a9H
	jmp	$LN156@process_br
$LN107@process_br:

; 245  :                 }
; 246  :             }
; 247  :             /* jumps to another segment are just like to another file */
; 248  :             state = SYM_EXTERNAL;

	mov	r14d, 2

; 253  :     }
; 254  : 
; 255  :     if ( state != SYM_EXTERNAL ) {

	jmp	$LN142@process_br
$LN115@process_br:
	cmp	ecx, 2
	je	$LN146@process_br
$LN139@process_br:

; 256  :         /* v1.94: if a segment override is active,
; 257  :          check if it's matching the assumed value of CS.
; 258  :          If no, assume a FAR call.
; 259  :          */
; 260  :         if ( SegOverride != NULL && CodeInfo->mem_type == MT_EMPTY ) {

	cmp	QWORD PTR SegOverride, rsi
	je	SHORT $LN102@process_br
	cmp	DWORD PTR [rbx+28], 192			; 000000c0H
	jne	SHORT $LN102@process_br

; 261  :             if ( SegOverride != GetOverrideAssume( ASSUME_CS ) ) {

	mov	ecx, edi
	call	GetOverrideAssume
	cmp	QWORD PTR SegOverride, rax
	je	SHORT $LN140@process_br

; 262  :                 CodeInfo->mem_type = MT_FAR;

	mov	DWORD PTR [rbx+28], 130			; 00000082H
	mov	r8, QWORD PTR ModuleInfo+432
	jmp	SHORT $LN102@process_br
$LN140@process_br:
	mov	r8, QWORD PTR ModuleInfo+432
$LN102@process_br:

; 263  :             }
; 264  :         }
; 265  :         if(  ( CodeInfo->mem_type == MT_EMPTY ||
; 266  :               CodeInfo->mem_type == MT_NEAR ) &&
; 267  :            CodeInfo->isfar == FALSE ) {

	mov	eax, DWORD PTR [rbx+28]
	cmp	eax, 192				; 000000c0H
	je	SHORT $LN100@process_br
	cmp	eax, 129				; 00000081H
	jne	$LN144@process_br
$LN100@process_br:
	test	BYTE PTR [rbx+142], 4
	jne	$LN145@process_br

; 268  : 
; 269  :             /* if the label is FAR - or there is a segment override
; 270  :              * which equals assumed value of CS - and there is no type cast,
; 271  :              * then do a "far call optimization".
; 272  :              */
; 273  :             if( CodeInfo->token == T_CALL &&
; 274  :                 CodeInfo->mem_type == MT_EMPTY &&
; 275  :                 ( sym->mem_type == MT_FAR || SegOverride ) ) {

	cmp	DWORD PTR [rbx+24], 455			; 000001c7H
	jne	SHORT $LN99@process_br
	cmp	eax, 192				; 000000c0H
	jne	SHORT $LN99@process_br
	cmp	DWORD PTR [r13+44], 130			; 00000082H
	je	SHORT $LN98@process_br
	cmp	QWORD PTR SegOverride, rsi
	je	SHORT $LN99@process_br
$LN98@process_br:

; 276  :                 DebugMsg1(("process_branch: FAR call optimization applied!\n" ));
; 277  :                 FarCallToNear( CodeInfo ); /* switch mem_type to NEAR */

	mov	rcx, rbx
	call	FarCallToNear
$LN99@process_br:

; 278  :             }
; 279  : 
; 280  :             //addr = sym->offset; /* v2.02: this has been done above */
; 281  :             DebugMsg(("process_branch: step1: addr=%Xh\n", addr ));
; 282  :             addr -= ( GetCurrOffset() + 2 );  /* calculate the displacement */

	call	GetCurrOffset

; 283  :             addr += CodeInfo->opnd[OPND1].data32l;
; 284  :             /*  JCXZ, LOOPW, LOOPEW, LOOPZW, LOOPNEW, LOOPNZW,
; 285  :                JECXZ, LOOPD, LOOPED, LOOPZD, LOOPNED, LOOPNZD? */
; 286  :             if (( CodeInfo->Ofssize && InstrTable[opidx].byte1_info == F_16A ) ||
; 287  :                 ( CodeInfo->Ofssize != USE32 && InstrTable[opidx].byte1_info == F_32A ))

	movzx	r8d, BYTE PTR [rbx+106]
	mov	ecx, -2
	sub	ecx, eax
	add	r12d, ecx
	add	r12d, DWORD PTR [rbx+40]
	test	r8b, r8b
	je	SHORT $LN147@process_br
	mov	rax, r14
	lea	rcx, OFFSET FLAT:__ImageBase
	imul	rax, 14
	cmp	BYTE PTR InstrTable[rax+rcx+1], 3
	je	SHORT $LN96@process_br
	jmp	SHORT $LN95@process_br
$LN147@process_br:

; 201  : 
; 202  :     /* v2.02: if symbol is GLOBAL and it isn't clear yet were
; 203  :      * it's located, then assume it is a forward reference (=SYM_UNDEFINED)!
; 204  :      * This applies to PROTOs and EXTERNDEFs in Pass 1.
; 205  :      */
; 206  :     if ( ( state == SYM_EXTERNAL ) && sym->weak ) {

	lea	rcx, OFFSET FLAT:__ImageBase
$LN95@process_br:

; 283  :             addr += CodeInfo->opnd[OPND1].data32l;
; 284  :             /*  JCXZ, LOOPW, LOOPEW, LOOPZW, LOOPNEW, LOOPNZW,
; 285  :                JECXZ, LOOPD, LOOPED, LOOPZD, LOOPNED, LOOPNZD? */
; 286  :             if (( CodeInfo->Ofssize && InstrTable[opidx].byte1_info == F_16A ) ||
; 287  :                 ( CodeInfo->Ofssize != USE32 && InstrTable[opidx].byte1_info == F_32A ))

	cmp	r8b, dil
	je	SHORT $LN97@process_br
	mov	rax, r14
	imul	rax, 14
	cmp	BYTE PTR InstrTable[rax+rcx+1], 4
	jne	SHORT $LN97@process_br
$LN96@process_br:

; 288  :                 addr--; /* 1 extra byte for ADRSIZ (0x67) */

	dec	r12d
$LN97@process_br:

; 289  : 
; 290  :             /* v2.02: removed */
; 291  :             //if( CodeInfo->token == T_CALL && CodeInfo->mem_type == MT_EMPTY ) {
; 292  :             //    CodeInfo->mem_type = MT_NEAR;
; 293  :             //}
; 294  :             DebugMsg(("process_branch: CI.memtype=%Xh addr=%Xh\n", CodeInfo->mem_type, addr ));
; 295  :             if( CodeInfo->mem_type != MT_NEAR && CodeInfo->token != T_CALL &&
; 296  :                 ( addr >= SCHAR_MIN && addr <= SCHAR_MAX ) ) {

	mov	edx, DWORD PTR [rbx+28]
	cmp	edx, 129				; 00000081H
	je	SHORT $LN94@process_br
	mov	ecx, DWORD PTR [rbx+24]
	cmp	ecx, 455				; 000001c7H
	je	SHORT $LN94@process_br
	lea	eax, DWORD PTR [r12+128]
	cmp	eax, 255				; 000000ffH
	ja	SHORT $LN94@process_br

; 297  :                 CodeInfo->opnd[OPND1].type = OP_I8;

	mov	DWORD PTR [rbx+32], 131072		; 00020000H

; 298  :             } else {

	jmp	$LN80@process_br
$LN94@process_br:

; 299  :                 if ( opndx->instr == T_SHORT || ( IS_XCX_BRANCH( CodeInfo->token ) ) ) {

	cmp	DWORD PTR [rbp+56], 245			; 000000f5H
	je	$LN91@process_br
	mov	ecx, DWORD PTR [rbx+24]
	cmp	ecx, 487				; 000001e7H
	jl	SHORT $LN92@process_br
	cmp	ecx, 504				; 000001f8H
	jle	$LN91@process_br
$LN92@process_br:

; 320  :                 }
; 321  :                 /* near destination */
; 322  :                 /* is there a type coercion? */
; 323  :                 if ( opndx->Ofssize != USE_EMPTY ) {

	movzx	eax, BYTE PTR [rbp+69]
	cmp	al, 254					; 000000feH
	je	SHORT $LN87@process_br

; 324  :                     if ( opndx->Ofssize == USE16 ) {

	test	al, al
	jne	SHORT $LN86@process_br

; 325  :                         CodeInfo->opnd[OPND1].type = OP_I16;

	mov	DWORD PTR [rbx+32], r15d

; 326  :                         addr -= 1; /* 16 bit displacement */

	dec	r12d

; 327  :                     } else {

	jmp	SHORT $LN85@process_br
$LN86@process_br:

; 328  :                         CodeInfo->opnd[OPND1].type = OP_I32;

	mov	DWORD PTR [rbx+32], 524288		; 00080000H

; 329  :                         addr -= 3; /* 32 bit displacement */

	sub	r12d, 3
$LN85@process_br:

; 330  :                     }
; 331  :                     CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, opndx->Ofssize );

	cmp	r8b, BYTE PTR [rbp+69]
	setne	al
	add	al, al
	xor	al, BYTE PTR [rbx+9]
	and	al, 2
	xor	BYTE PTR [rbx+9], al

; 332  :                     if ( CodeInfo->prefix.opsiz )

	test	BYTE PTR [rbx+9], 2
	je	SHORT $LN81@process_br

; 333  :                         addr--;

	dec	r12d

; 334  :                 } else if( CodeInfo->Ofssize > USE16 ) {

	jmp	SHORT $LN81@process_br
$LN87@process_br:
	test	r8b, r8b
	je	SHORT $LN82@process_br

; 335  :                     CodeInfo->opnd[OPND1].type = OP_I32;

	mov	DWORD PTR [rbx+32], 524288		; 00080000H

; 336  :                     addr -= 3; /* 32 bit displacement */

	sub	r12d, 3

; 337  :                 } else {

	jmp	SHORT $LN81@process_br
$LN82@process_br:

; 338  :                     CodeInfo->opnd[OPND1].type = OP_I16;

	mov	DWORD PTR [rbx+32], r15d

; 339  :                     addr -= 1; /* 16 bit displacement */

	dec	r12d
$LN81@process_br:

; 340  :                 }
; 341  :                 if( IS_CONDJMP( CodeInfo->token ) ) {

	cmp	ecx, 457				; 000001c9H
	jl	SHORT $LN80@process_br
	cmp	ecx, 486				; 000001e6H
	jg	SHORT $LN80@process_br

; 342  :                     /* 1 extra byte for opcode ( 0F ) */
; 343  :                     addr--;

	dec	r12d
$LN80@process_br:

; 344  :                 }
; 345  :             }
; 346  : 
; 347  :             /* store the displacement */
; 348  :             CodeInfo->opnd[OPND1].data32l = addr;

	mov	DWORD PTR [rbx+40], r12d

; 349  :             DebugMsg1(("process_branch: displacement=%" I32_SPEC "X opnd_type=%" I32_SPEC "X\n", addr, CodeInfo->opnd[OPND1].type ));
; 350  : 
; 351  :             /* automatic (conditional) jump expansion.
; 352  :              * for 386 and above this is not needed, since there exists
; 353  :              * an extended version of Jcc
; 354  :              */
; 355  :             if( ( ModuleInfo.curr_cpu & P_CPU_MASK) < P_386 && IS_JCC( CodeInfo->token ) ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jge	SHORT $LN76@process_br
	cmp	ecx, 456				; 000001c8H
	jle	SHORT $LN76@process_br
	cmp	ecx, 487				; 000001e7H
	jge	SHORT $LN76@process_br

; 356  :                 /* look into jump extension */
; 357  :                 if( CodeInfo->opnd[OPND1].type != OP_I8 ) {

	cmp	DWORD PTR [rbx+32], 131072		; 00020000H
	je	SHORT $LN76@process_br

; 358  :                     if( CodeInfo->mem_type == MT_EMPTY && ModuleInfo.ljmp == TRUE ) {

	cmp	edx, 192				; 000000c0H
	jne	SHORT $LN77@process_br
	test	BYTE PTR ModuleInfo+408, 64		; 00000040H
	je	SHORT $LN77@process_br

; 359  :                         jumpExtend( CodeInfo, FALSE );

	xor	edx, edx
	mov	rcx, rbx
	call	jumpExtend

; 360  :                         addr -= 1;

	lea	r11d, DWORD PTR [r12-1]

; 361  :                         CodeInfo->opnd[OPND1].data32l = addr;

	mov	DWORD PTR [rbx+40], r11d
$LN76@process_br:

; 368  :                     }
; 369  :                 }
; 370  :             }
; 371  :             /* v2.02: in pass one, write "backpatch" fixup for forward
; 372  :              * references.
; 373  :              */
; 374  :             /* the "if" below needs to be explaind.
; 375  :              * Fixups will be written for forward references in pass one.
; 376  :              * state is SYM_UNDEFINED then. The fixups will be scanned when
; 377  :              * the label is met finally, still in pass one. See backptch.c
; 378  :              * for details.
; 379  :              */
; 380  :             if ( state != SYM_UNDEFINED )

	mov	r14d, DWORD PTR state$1$[rsp]
	test	r14d, r14d
	je	SHORT $LN141@process_br

; 381  :                 return( NOT_ERROR ); /* exit, no fixup is written! */

	xor	eax, eax
	jmp	$LN152@process_br
$LN77@process_br:

; 362  :                         //return( SCRAP_INSTRUCTION );
; 363  :                     //} else if( !PhaseError ) {
; 364  :                     } else {
; 365  :                         DebugMsg(("%u process_branch: CPU < 386 and Jcc distance != SHORT, mem_type=%X, curr_ofs=%X, addr=%d\n", Parse_Pass + 1, CodeInfo->mem_type, GetCurrOffset(), addr ));
; 366  :                         /* v2.11: don't emit "out of range" if OP_I16 was forced by type coercion ( jmp near ptr xxx ) */
; 367  :                         return( EmitErr( CodeInfo->mem_type == MT_EMPTY ? JUMP_OUT_OF_RANGE : JUMP_DISTANCE_NOT_POSSIBLE, addr ) );

	mov	ecx, 50					; 00000032H
$LN153@process_br:
	cmp	edx, 192				; 000000c0H
	mov	eax, 53					; 00000035H
	mov	edx, r12d
	cmove	ecx, eax
	call	EmitErr
	jmp	$LN152@process_br
$LN91@process_br:

; 300  :                     /* v2.06: added */
; 301  :                     if( CodeInfo->token == T_CALL ) {

	cmp	DWORD PTR [rbx+24], 455			; 000001c7H
	jne	SHORT $LN90@process_br
$LN154@process_br:

; 302  :                         return( EmitError( CANNOT_USE_SHORT_WITH_CALL ) );

	mov	ecx, 43					; 0000002bH
	jmp	$LN156@process_br
$LN90@process_br:

; 303  :                     }
; 304  :                     /* v1.96: since HJWasm's backpatch strategy is to move from
; 305  :                      * "smallest" to "largest" distance, an "out of range"
; 306  :                      * error can be detected at any time.
; 307  :                      */
; 308  :                     DebugMsg(("process_branch: jump out of range, mem_type=%Xh addr=%Xh\n", CodeInfo->mem_type, addr ));
; 309  :                     /* v2.06: removed */
; 310  :                     /* v2.03: added */
; 311  :                     //if ( addr >= SCHAR_MIN && addr <= SCHAR_MAX ) {
; 312  :                     //    return( EmitError( ONLY_SHORT_JUMP_DISTANCE_IS_ALLOWED ) );
; 313  :                     //}
; 314  :                     if ( addr < 0 ) {

	test	r12d, r12d
	jns	SHORT $LN89@process_br

; 315  :                         addr -= SCHAR_MIN;

	mov	eax, -128				; ffffffffffffff80H

; 319  :                     return( EmitErr( CodeInfo->mem_type == MT_EMPTY ? JUMP_OUT_OF_RANGE : ONLY_SHORT_JUMP_DISTANCE_IS_ALLOWED, addr ) );

	mov	ecx, 44					; 0000002cH
	sub	eax, r12d
	mov	r12d, eax
	jmp	SHORT $LN153@process_br
$LN89@process_br:

; 316  :                         addr = 0 - addr;
; 317  :                     } else
; 318  :                         addr -= SCHAR_MAX;

	sub	r12d, 127				; 0000007fH

; 319  :                     return( EmitErr( CodeInfo->mem_type == MT_EMPTY ? JUMP_OUT_OF_RANGE : ONLY_SHORT_JUMP_DISTANCE_IS_ALLOWED, addr ) );

	mov	ecx, 44					; 0000002cH
	jmp	SHORT $LN153@process_br
$LN141@process_br:
	mov	r8, QWORD PTR ModuleInfo+432
	jmp	SHORT $LN142@process_br
$LN144@process_br:

; 207  :         DebugMsg1(("process_branch(%s): EXTERNDEF assumed forward reference (=SYM_UNDEFINED)\n", sym->name ));
; 208  :         state = SYM_UNDEFINED;

	mov	r14d, DWORD PTR state$1$[rsp]
	jmp	SHORT $LN142@process_br
$LN145@process_br:
	mov	r14d, DWORD PTR state$1$[rsp]
	jmp	SHORT $LN142@process_br
$LN146@process_br:
	mov	r14d, ecx
$LN142@process_br:

; 382  :         }
; 383  :     }
; 384  : 
; 385  :     DebugMsg1(("process_branch: fixup needed\n" ));
; 386  : 
; 387  :     fixup_option = OPTJ_NONE;
; 388  :     fixup_type = FIX_RELOFF8;
; 389  : 
; 390  :     mem_type = opndx->mem_type;
; 391  : 
; 392  :     /* v2.04: far call optimization possible if destination is in
; 393  :      * another segment of the same group. However, a fixup must be written.
; 394  :      * Masm does NOT optimize if destination is external!
; 395  :      */
; 396  :     if( CodeInfo->token == T_CALL &&
; 397  :        CodeInfo->mem_type == MT_EMPTY &&
; 398  :        ( sym->mem_type == MT_FAR || SegOverride ) ) {

	cmp	DWORD PTR [rbx+24], 455			; 000001c7H
	mov	r12d, DWORD PTR [rbp+64]
	jne	SHORT $LN72@process_br
	cmp	DWORD PTR [rbx+28], 192			; 000000c0H
	jne	SHORT $LN72@process_br
	cmp	DWORD PTR [r13+44], 130			; 00000082H
	je	SHORT $LN73@process_br
	cmp	QWORD PTR SegOverride, rsi
	je	SHORT $LN72@process_br
$LN73@process_br:

; 399  :         symseg = GetSegm( sym );

	mov	rax, QWORD PTR [r13+32]

; 400  :         if ( symseg == CurrSeg ||
; 401  :             ( symseg != NULL && symseg->e.seginfo->group != NULL && symseg->e.seginfo->group == CurrSeg->e.seginfo->group ) ) {

	cmp	rax, r8
	je	SHORT $LN71@process_br
	test	rax, rax
	je	SHORT $LN72@process_br
	mov	rax, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN72@process_br
	mov	rax, QWORD PTR [r8+104]
	cmp	rcx, QWORD PTR [rax]
	jne	SHORT $LN72@process_br
$LN71@process_br:

; 402  :             DebugMsg1(("process_branch: FAR call optimization applied!, seg=%X, CurrSeg=%X, grps=%X/%X\n", symseg, CurrSeg, symseg->e.seginfo->group, CurrSeg->e.seginfo->group ));
; 403  :             FarCallToNear( CodeInfo ); /* switch mem_type to NEAR */

	mov	rcx, rbx
	call	FarCallToNear
$LN72@process_br:

; 404  :         }
; 405  :     }
; 406  :     /* forward ref, or external symbol */
; 407  :     if( CodeInfo->mem_type == MT_EMPTY && mem_type != MT_EMPTY && opndx->instr != T_SHORT ) {

	cmp	DWORD PTR [rbx+28], 192			; 000000c0H
	jne	SHORT $LN63@process_br
	cmp	r12d, 192				; 000000c0H
	je	SHORT $LN63@process_br
	cmp	DWORD PTR [rbp+56], 245			; 000000f5H
	je	SHORT $LN63@process_br

; 408  :         /* MT_PROC is most likely obsolete ( used by TYPEDEF only ) */
; 409  :         /* v2.09: removed */
; 410  :         //if ( mem_type == MT_PROC )
; 411  :         //    mem_type = ( ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ) ? MT_FAR : MT_NEAR );
; 412  :         switch( mem_type ) {

	mov	ecx, r12d
	sub	ecx, 129				; 00000081H
	je	SHORT $LN66@process_br
	dec	ecx
	je	SHORT $LN67@process_br

; 424  :             break;
; 425  :         default:
; 426  :             DebugMsg(("process_branch: unexpected mem_type %Xh\n", mem_type ));
; 427  :             /**/myassert( 0 );
; 428  :             CodeInfo->mem_type = mem_type;

	mov	DWORD PTR [rbx+28], r12d
	jmp	SHORT $LN63@process_br
$LN67@process_br:

; 413  :         case MT_FAR:
; 414  :             if( IS_JMPCALL( CodeInfo->token ) ) {

	mov	eax, DWORD PTR [rbx+24]
	cmp	eax, 455				; 000001c7H
	je	SHORT $LN65@process_br
	cmp	eax, 456				; 000001c8H
	jne	SHORT $LN66@process_br
$LN65@process_br:

; 415  :                 CodeInfo->isfar = TRUE;

	or	BYTE PTR [rbx+142], 4
$LN66@process_br:

; 416  :             }
; 417  :             /* v2.06: commented 2 lines to copy behavior of MT_NEAR */
; 418  :             //CodeInfo->mem_type = mem_type;
; 419  :             //break;
; 420  :         case MT_NEAR:
; 421  :             /* v2.04: 'if' added */
; 422  :             if ( state != SYM_UNDEFINED )

	test	r14d, r14d
	je	SHORT $LN63@process_br

; 423  :                 CodeInfo->mem_type = mem_type;

	mov	DWORD PTR [rbx+28], r12d
$LN63@process_br:

; 429  :         }
; 430  :     }
; 431  : 
; 432  :     /* handle far JMP + CALL? */
; 433  :     if ( IS_JMPCALL( CodeInfo->token ) &&
; 434  :         ( CodeInfo->isfar == TRUE || CodeInfo->mem_type == MT_FAR )) {

	mov	ecx, DWORD PTR [rbx+24]
	cmp	ecx, 455				; 000001c7H
	je	SHORT $LN60@process_br
	cmp	ecx, 456				; 000001c8H
	jne	SHORT $LN61@process_br
$LN60@process_br:
	movzx	eax, BYTE PTR [rbx+142]
	test	al, 4
	jne	$LN59@process_br
	cmp	DWORD PTR [rbx+28], 130			; 00000082H
	je	$LN59@process_br
$LN61@process_br:

; 471  :     }  /* end if FAR JMP/CALL */
; 472  : 
; 473  :     switch( CodeInfo->token ) {

	mov	edx, ecx
	sub	edx, 455				; 000001c7H
	je	$LN46@process_br
	dec	edx
	je	$LN44@process_br

; 523  :             break;
; 524  : #ifdef DEBUG_OUT
; 525  :         default:
; 526  :             DebugMsg(("process_branch: JMP/CALL, unexpected mem_type=%X\n", CodeInfo->mem_type ));
; 527  :             /**/myassert( 0 );
; 528  :             //return( EmitError( INVALID_OPERAND_SIZE ) );
; 529  : #endif
; 530  :         }
; 531  :         /* deactivated because there's no override involved here */
; 532  :         // check_assume( sym, EMPTY );
; 533  :         break;
; 534  :     default: /* JxCXZ, LOOPxx, Jxx */
; 535  :         /* JxCXZ and LOOPxx always require SHORT label */
; 536  :         if ( IS_XCX_BRANCH( CodeInfo->token ) ) {

	cmp	ecx, 487				; 000001e7H
	jl	SHORT $LN29@process_br
	cmp	ecx, 504				; 000001f8H
	jg	SHORT $LN29@process_br

; 537  :             if( CodeInfo->mem_type != MT_EMPTY && opndx->instr != T_SHORT ) {

	cmp	DWORD PTR [rbx+28], 192			; 000000c0H
	je	SHORT $LN28@process_br
	cmp	DWORD PTR [rbp+56], 245			; 000000f5H
	je	SHORT $LN28@process_br
$LN4@process_br:

; 538  :                 return( EmitError( ONLY_SHORT_JUMP_DISTANCE_IS_ALLOWED ) );

	mov	ecx, 44					; 0000002cH
	jmp	$LN156@process_br
$LN28@process_br:

; 539  :             }
; 540  :             CodeInfo->opnd[OPND1].type = OP_I8;

	mov	DWORD PTR [rbx+32], 131072		; 00020000H

; 541  :             fixup_option = OPTJ_EXPLICIT;

	mov	esi, edi

; 542  :             fixup_type = FIX_RELOFF8;
; 543  :             break;

	jmp	$LN39@process_br
$LN29@process_br:

; 544  :         }
; 545  :         /* just Jxx remaining */
; 546  : 
; 547  :         if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	$LN27@process_br

; 548  : 
; 549  :             switch( CodeInfo->mem_type ) {

	mov	ecx, DWORD PTR [rbx+28]
	sub	ecx, 129				; 00000081H
	je	$LN23@process_br
	dec	ecx
	je	SHORT $LN18@process_br
	cmp	ecx, 62					; 0000003eH
	jne	$LN17@process_br

; 550  :             case MT_EMPTY:
; 551  :                 /* forward reference */
; 552  :                 fixup_option = ( opndx->instr == T_SHORT ) ? OPTJ_EXPLICIT : OPTJ_JXX;

	cmp	DWORD PTR [rbp+56], 245			; 000000f5H
	mov	esi, 3

; 553  :                 fixup_type = FIX_RELOFF8;
; 554  :                 CodeInfo->opnd[OPND1].type = OP_I8;

	mov	DWORD PTR [rbx+32], 131072		; 00020000H
	cmove	esi, edi

; 555  :                 break;

	jmp	$LN39@process_br
$LN18@process_br:

; 569  :                 }
; 570  :                 break;
; 571  :             case MT_FAR:
; 572  :                 if ( ModuleInfo.ljmp ) { /* OPTION LJMP set? */

	test	BYTE PTR ModuleInfo+408, 64		; 00000040H
	je	$LN17@process_br

; 573  :                     /* v1.95: explicit flag to be removed! */
; 574  :                     //if ( opndx->explicit && opndx->Ofssize != USE_EMPTY )
; 575  :                     if ( opndx->Ofssize != USE_EMPTY )

	movzx	eax, BYTE PTR [rbp+69]
	cmp	al, 254					; 000000feH
	je	SHORT $LN16@process_br

; 576  :                         CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, opndx->Ofssize );

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], al
	setne	al
	and	al, dil
	add	al, al
	or	BYTE PTR [rbx+9], al

; 577  :                     else

	jmp	SHORT $LN15@process_br
$LN16@process_br:

; 578  :                         CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, GetSymOfssize( sym ));

	mov	rcx, r13
	call	GetSymOfssize
	and	BYTE PTR [rbx+9], 253			; 000000fdH
	movzx	ecx, BYTE PTR [rbx+106]
	cmp	ecx, eax
	setne	al
	and	al, dil
	add	al, al
	or	BYTE PTR [rbx+9], al
$LN15@process_br:

; 579  :                     /* destination is FAR (externdef <dest>:far */
; 580  :                     DebugMsg(("process_branch: JMP/CALL, FAR memtype, jump extension\n" ));
; 581  :                     jumpExtend( CodeInfo, TRUE );

	mov	edx, edi
	mov	rcx, rbx
	call	jumpExtend

; 582  :                     CodeInfo->isfar = TRUE;

	or	BYTE PTR [rbx+142], 4

; 583  :                     if( IS_OPER_32( CodeInfo ) ) {

	cmp	BYTE PTR [rbx+106], sil
	je	SHORT $LN134@process_br
	mov	cl, BYTE PTR [rbx+9]
	shr	ecx, 1
	not	ecx
	and	ecx, edi
	jmp	SHORT $LN135@process_br
$LN134@process_br:
	movzx	eax, BYTE PTR [rbx+9]
	mov	ecx, esi
	and	al, 2
	cmp	al, 2
	sete	cl
$LN135@process_br:
	test	ecx, ecx
	je	SHORT $LN14@process_br

; 584  :                         fixup_type = FIX_PTR32;

	mov	edi, 10

; 585  :                         CodeInfo->opnd[OPND1].type = OP_I48;

	mov	DWORD PTR [rbx+32], 2097152		; 00200000H

; 586  :                     } else {

	jmp	$LN39@process_br
$LN14@process_br:

; 587  :                         fixup_type = FIX_PTR16;

	mov	edi, 9

; 588  :                         CodeInfo->opnd[OPND1].type = OP_I32;

	mov	DWORD PTR [rbx+32], 524288		; 00080000H

; 589  :                     }
; 590  :                     break;

	jmp	$LN39@process_br
$LN17@process_br:

; 591  :                 }
; 592  :                 /* fall through */
; 593  :             default: /* is another memtype possible at all? */
; 594  :                 return( EmitError( ONLY_SHORT_AND_NEAR_JUMP_DISTANCE_IS_ALLOWED ) );

	mov	ecx, 75					; 0000004bH
	jmp	$LN156@process_br
$LN23@process_br:

; 556  :             case MT_NEAR:
; 557  :                 fixup_option = OPTJ_EXPLICIT;
; 558  :                 /* v1.95: explicit flag to be removed! */
; 559  :                 //if ( opndx->explicit && opndx->Ofssize != USE_EMPTY ) {
; 560  :                 if ( opndx->Ofssize != USE_EMPTY ) {

	movzx	eax, BYTE PTR [rbp+69]
	mov	esi, edi
	cmp	al, 254					; 000000feH
	je	SHORT $LN22@process_br

; 561  :                     CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, opndx->Ofssize );

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], al
	setne	al
	and	al, sil
	add	al, al
	or	BYTE PTR [rbx+9], al

; 562  :                     CodeInfo->opnd[OPND1].type = (opndx->Ofssize >= USE32) ? OP_I32 : OP_I16;

	cmp	BYTE PTR [rbp+69], sil
	mov	eax, 524288				; 00080000H
	cmovae	r15d, eax
	mov	DWORD PTR [rbx+32], r15d
	jmp	$LN39@process_br
$LN22@process_br:

; 563  :                 } else if( CodeInfo->Ofssize > USE16 ) {

	cmp	BYTE PTR [rbx+106], 0
	jbe	SHORT $LN20@process_br

; 564  :                     fixup_type = FIX_RELOFF32;
; 565  :                     CodeInfo->opnd[OPND1].type = OP_I32;

	mov	eax, 524288				; 00080000H
	mov	edi, 3
	mov	DWORD PTR [rbx+32], eax

; 566  :                 } else {

	jmp	$LN39@process_br
$LN20@process_br:

; 567  :                     fixup_type = FIX_RELOFF16;

	mov	edi, 2

; 568  :                     CodeInfo->opnd[OPND1].type = OP_I16;

	mov	DWORD PTR [rbx+32], r15d

; 595  :             }
; 596  :         } else {

	jmp	$LN39@process_br
$LN27@process_br:

; 597  :             /* the only mode in 8086, 80186, 80286 is
; 598  :              * Jxx SHORT
; 599  :              * Masm allows "Jxx near" if LJMP is on (default) */
; 600  :             switch( CodeInfo->mem_type ) {

	mov	eax, DWORD PTR [rbx+28]
	cmp	eax, 129				; 00000081H
	jl	$LN4@process_br
	cmp	eax, 130				; 00000082H
	jle	SHORT $LN5@process_br
	cmp	eax, 192				; 000000c0H
	jne	$LN4@process_br

; 601  :             case MT_EMPTY:
; 602  :                 if ( opndx->instr == T_SHORT )

	cmp	DWORD PTR [rbp+56], 245			; 000000f5H

; 603  :                     fixup_option = OPTJ_EXPLICIT;
; 604  :                 else
; 605  :                     fixup_option = OPTJ_EXTEND;
; 606  :                 fixup_type = FIX_RELOFF8;
; 607  :                 CodeInfo->opnd[OPND1].type = OP_I8;

	mov	DWORD PTR [rbx+32], 131072		; 00020000H
	setne	sil
	inc	esi

; 608  :                 break;

	jmp	$LN39@process_br
$LN5@process_br:

; 609  :             case MT_NEAR: /* allow Jxx NEAR if LJMP on */
; 610  :             case MT_FAR:
; 611  :                 if ( ModuleInfo.ljmp ) {

	test	BYTE PTR ModuleInfo+408, 64		; 00000040H
	je	$LN4@process_br

; 612  :                     if ( CodeInfo->mem_type == MT_FAR ) {

	cmp	eax, 130				; 00000082H
	jne	SHORT $LN3@process_br

; 613  :                         jumpExtend( CodeInfo, TRUE );

	mov	edx, edi
	mov	rcx, rbx
	call	jumpExtend

; 614  :                         fixup_type = FIX_PTR16;
; 615  :                         CodeInfo->isfar = TRUE;

	or	BYTE PTR [rbx+142], 4

; 616  :                         CodeInfo->opnd[OPND1].type = OP_I32;

	mov	eax, 524288				; 00080000H
	mov	DWORD PTR [rbx+32], eax
	mov	edi, 9

; 617  :                     } else {

	jmp	$LN39@process_br
$LN3@process_br:

; 618  :                         jumpExtend( CodeInfo, FALSE );

	xor	edx, edx
	mov	rcx, rbx
	call	jumpExtend

; 619  :                         fixup_type = FIX_RELOFF16;

	mov	edi, 2

; 620  :                         CodeInfo->opnd[OPND1].type = OP_I16;

	mov	DWORD PTR [rbx+32], r15d

; 621  :                     }
; 622  :                     break;

	jmp	$LN39@process_br
$LN46@process_br:

; 474  :     case T_CALL:
; 475  :         if( opndx->instr == T_SHORT ) {

	cmp	DWORD PTR [rbp+56], 245			; 000000f5H

; 476  :             return( EmitError( CANNOT_USE_SHORT_WITH_CALL ) );

	je	$LN154@process_br

; 477  :         }
; 478  :         if( CodeInfo->mem_type == MT_EMPTY ) {

	cmp	DWORD PTR [rbx+28], 192			; 000000c0H
	jne	SHORT $LN44@process_br

; 479  :             fixup_option = OPTJ_CALL;
; 480  :             if( CodeInfo->Ofssize > USE16 ) {

	cmp	BYTE PTR [rbx+106], 0
	mov	esi, 4
	jbe	SHORT $LN43@process_br

; 481  :                 fixup_type = FIX_RELOFF32;
; 482  :                 CodeInfo->opnd[OPND1].type = OP_I32;

	mov	eax, 524288				; 00080000H
	lea	edi, QWORD PTR [rsi-1]
	mov	DWORD PTR [rbx+32], eax

; 483  :             } else {

	jmp	$LN39@process_br
$LN43@process_br:

; 484  :                 fixup_type = FIX_RELOFF16;

	mov	edi, 2

; 485  :                 CodeInfo->opnd[OPND1].type = OP_I16;

	mov	DWORD PTR [rbx+32], r15d

; 486  :             }
; 487  :             break;

	jmp	$LN39@process_br
$LN44@process_br:

; 488  :         }
; 489  :         /* fall through */
; 490  :     case T_JMP:
; 491  :         DebugMsg1(("process_branch: JMP/CALL, CodeInfo->memtype=%X\n", CodeInfo->mem_type ));
; 492  :         switch( CodeInfo->mem_type ) {

	mov	ecx, DWORD PTR [rbx+28]
	sub	ecx, 129				; 00000081H
	je	SHORT $LN37@process_br
	cmp	ecx, 63					; 0000003fH
	jne	SHORT $LN39@process_br

; 493  :         case MT_EMPTY:
; 494  :             /* forward reference
; 495  :              * default distance is short, we will expand later if needed
; 496  :              */
; 497  :             CodeInfo->opnd[OPND1].type = OP_I8;

	mov	DWORD PTR [rbx+32], 131072		; 00020000H

; 498  :             fixup_type = FIX_RELOFF8;
; 499  :             fixup_option = (opndx->instr == T_SHORT) ? OPTJ_EXPLICIT : OPTJ_NONE;

	cmp	DWORD PTR [rbp+56], 245			; 000000f5H
	sete	sil

; 500  :             break;

	jmp	SHORT $LN39@process_br
$LN37@process_br:

; 501  :         case MT_NEAR:
; 502  :             fixup_option = OPTJ_EXPLICIT;
; 503  : #if 1 /* v2.11: added, see call5.aso */
; 504  :             if( opndx->Ofssize != USE_EMPTY ) {

	movzx	eax, BYTE PTR [rbp+69]
	mov	esi, edi
	cmp	al, 254					; 000000feH
	je	SHORT $LN36@process_br

; 505  :                 if ( opndx->Ofssize == USE16 ) {

	test	al, al
	jne	SHORT $LN35@process_br

; 506  :                     fixup_type = FIX_RELOFF16;

	mov	edi, 2

; 507  :                     CodeInfo->opnd[OPND1].type = OP_I16;

	mov	DWORD PTR [rbx+32], r15d

; 508  :                 } else {

	jmp	SHORT $LN34@process_br
$LN35@process_br:

; 509  :                     fixup_type = FIX_RELOFF32;
; 510  :                     CodeInfo->opnd[OPND1].type = OP_I32;

	mov	eax, 524288				; 00080000H
	mov	edi, 3
	mov	DWORD PTR [rbx+32], eax
$LN34@process_br:

; 511  :                 }
; 512  :                 CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, opndx->Ofssize );

	movzx	eax, BYTE PTR [rbp+69]
	cmp	BYTE PTR [rbx+106], al
	setne	al
	add	al, al
	xor	al, BYTE PTR [rbx+9]
	and	al, 2
	xor	BYTE PTR [rbx+9], al

; 513  :             } else

	jmp	SHORT $LN31@process_br
$LN36@process_br:

; 514  : #endif
; 515  :             if( CodeInfo->Ofssize > USE16 ) {

	cmp	BYTE PTR [rbx+106], 0
	jbe	SHORT $LN32@process_br

; 516  :                 fixup_type = FIX_RELOFF32;
; 517  :                 CodeInfo->opnd[OPND1].type = OP_I32;

	mov	eax, 524288				; 00080000H
	mov	edi, 3
	mov	DWORD PTR [rbx+32], eax

; 518  :             } else {

	jmp	SHORT $LN31@process_br
$LN32@process_br:

; 519  :                 fixup_type = FIX_RELOFF16;

	mov	edi, 2

; 520  :                 CodeInfo->opnd[OPND1].type = OP_I16;

	mov	DWORD PTR [rbx+32], r15d
$LN31@process_br:

; 521  :             }
; 522  :             set_frame( sym );/* added v1.95 (after change in fixup.c */

	mov	rcx, r13
	call	set_frame
$LN39@process_br:

; 623  :                 }
; 624  :                 /* fall through */
; 625  :             default:
; 626  :                 return( EmitError( ONLY_SHORT_JUMP_DISTANCE_IS_ALLOWED ) );
; 627  :             }
; 628  :         }
; 629  :     } /* end switch (CodeInfo->token) */
; 630  :     CodeInfo->opnd[OPND1].InsFixup = CreateFixup( sym, fixup_type, fixup_option );

	mov	r8d, esi
$LN155@process_br:
	mov	edx, edi
	mov	rcx, r13
	call	CreateFixup
	mov	QWORD PTR [rbx+48], rax

; 631  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN152@process_br
$LN59@process_br:

; 435  :         CodeInfo->isfar = TRUE; /* flag isn't set if explicit is true */
; 436  :         DebugMsg1(("process_branch: FAR call/jmp\n"));
; 437  :         switch( CodeInfo->mem_type ) {

	mov	ecx, DWORD PTR [rbx+28]
	or	al, 4
	sub	ecx, 129				; 00000081H
	mov	BYTE PTR [rbx+142], al
	je	SHORT $LN56@process_br
	dec	ecx
	je	SHORT $LN55@process_br
	cmp	ecx, 62					; 0000003eH
	je	SHORT $LN55@process_br

; 460  :             }
; 461  :             break;
; 462  : #ifdef DEBUG_OUT
; 463  :         default: /* cannot happen */
; 464  :             DebugMsg(("process_branch: JMP/CALL far, unexpected mem_type=%X\n", CodeInfo->mem_type ));
; 465  :             /**/myassert( 0 );
; 466  :             //return( EmitError( INVALID_OPERAND_SIZE ) );
; 467  : #endif
; 468  :         }
; 469  :         CodeInfo->opnd[OPND1].InsFixup = CreateFixup( sym, fixup_type, fixup_option );

	xor	r8d, r8d

; 470  :         return( NOT_ERROR );

	jmp	SHORT $LN155@process_br
$LN56@process_br:

; 438  :         case MT_NEAR:
; 439  :             if( opndx->explicit || opndx->instr == T_SHORT ) {

	test	BYTE PTR [rbp+72], 2
	jne	$LN54@process_br
	cmp	DWORD PTR [rbp+56], 245			; 000000f5H
	je	$LN54@process_br
$LN55@process_br:

; 441  :             }
; 442  :             /* fall through */
; 443  :         case MT_FAR:
; 444  :         case MT_EMPTY:
; 445  :             /* v1.95: explicit flag to be removed! */
; 446  :             //if ( opndx->explicit && opndx->Ofssize != USE_EMPTY )
; 447  :             if ( opndx->Ofssize != USE_EMPTY )

	movzx	eax, BYTE PTR [rbp+69]
	cmp	al, 254					; 000000feH
	je	SHORT $LN52@process_br

; 448  :                 CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, opndx->Ofssize );

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], al
	setne	al
	and	al, dil
	add	al, al
	or	BYTE PTR [rbx+9], al

; 449  :             else

	jmp	SHORT $LN51@process_br
$LN52@process_br:

; 450  :                 CodeInfo->prefix.opsiz = OPSIZE( CodeInfo->Ofssize, GetSymOfssize( sym ) );

	mov	rcx, r13
	call	GetSymOfssize
	and	BYTE PTR [rbx+9], 253			; 000000fdH
	movzx	ecx, BYTE PTR [rbx+106]
	cmp	ecx, eax
	setne	al
	and	al, dil
	add	al, al
	or	BYTE PTR [rbx+9], al
$LN51@process_br:

; 451  : 
; 452  :             /* set fixup frame variables Frame + Frame_Datum */
; 453  :             set_frame( sym );

	mov	rcx, r13
	call	set_frame

; 454  :             if( IS_OPER_32( CodeInfo ) ) {

	cmp	BYTE PTR [rbx+106], sil
	je	SHORT $LN132@process_br
	mov	sil, BYTE PTR [rbx+9]
	shr	esi, 1
	not	esi
	and	esi, edi
	jmp	SHORT $LN133@process_br
$LN132@process_br:
	movzx	eax, BYTE PTR [rbx+9]
	and	al, 2
	cmp	al, 2
	sete	sil
$LN133@process_br:
	test	esi, esi
	je	SHORT $LN50@process_br

; 455  :                 fixup_type = FIX_PTR32;

	mov	edi, 10

; 456  :                 CodeInfo->opnd[OPND1].type = OP_I48;

	mov	DWORD PTR [rbx+32], 2097152		; 00200000H

; 460  :             }
; 461  :             break;
; 462  : #ifdef DEBUG_OUT
; 463  :         default: /* cannot happen */
; 464  :             DebugMsg(("process_branch: JMP/CALL far, unexpected mem_type=%X\n", CodeInfo->mem_type ));
; 465  :             /**/myassert( 0 );
; 466  :             //return( EmitError( INVALID_OPERAND_SIZE ) );
; 467  : #endif
; 468  :         }
; 469  :         CodeInfo->opnd[OPND1].InsFixup = CreateFixup( sym, fixup_type, fixup_option );

	xor	r8d, r8d

; 470  :         return( NOT_ERROR );

	jmp	$LN155@process_br
$LN50@process_br:

; 457  :             } else {
; 458  :                 fixup_type = FIX_PTR16;
; 459  :                 CodeInfo->opnd[OPND1].type = OP_I32;

	mov	eax, 524288				; 00080000H
	mov	edi, 9

; 460  :             }
; 461  :             break;
; 462  : #ifdef DEBUG_OUT
; 463  :         default: /* cannot happen */
; 464  :             DebugMsg(("process_branch: JMP/CALL far, unexpected mem_type=%X\n", CodeInfo->mem_type ));
; 465  :             /**/myassert( 0 );
; 466  :             //return( EmitError( INVALID_OPERAND_SIZE ) );
; 467  : #endif
; 468  :         }
; 469  :         CodeInfo->opnd[OPND1].InsFixup = CreateFixup( sym, fixup_type, fixup_option );

	xor	r8d, r8d
	mov	DWORD PTR [rbx+32], eax

; 470  :         return( NOT_ERROR );

	jmp	$LN155@process_br
$LN54@process_br:

; 440  :                 return( EmitError( CANNOT_USE_SHORT_OR_NEAR ) );

	mov	ecx, 52					; 00000034H
$LN156@process_br:
	call	EmitError
$LN152@process_br:
	mov	rdi, QWORD PTR [rsp+120]
	mov	r12, QWORD PTR [rsp+80]
	mov	r15, QWORD PTR [rsp+56]
$LN149@process_br:
	mov	rsi, QWORD PTR [rsp+112]
	mov	r13, QWORD PTR [rsp+72]
	mov	r14, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+96]

; 632  : }

	add	rsp, 88					; 00000058H
	ret	0
process_branch ENDP
_TEXT	ENDS
END
