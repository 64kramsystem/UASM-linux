; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
PUBLIC	MemInit
_BSS	SEGMENT
currfree DD	01H DUP (?)
	ALIGN	8

pBase	DQ	01H DUP (?)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\memalloc.c
_BSS	ENDS
_TEXT	SEGMENT
MemInit	PROC NEAR

; 152  : #if FASTMEM
; 153  :     pBase = NULL;

	xor	eax, eax
	mov	QWORD PTR pBase, rax

; 154  :     currfree = 0;

	mov	DWORD PTR currfree, eax

; 155  :     DebugCmd( blocks = 0 );
; 156  : #endif
; 157  :     DebugCmd( memstart = memcalls );
; 158  : }

	ret	0
MemInit	ENDP
_TEXT	ENDS
PUBLIC	MemFini
EXTRN	__imp_VirtualFree:NEAR
xdata	SEGMENT
$unwind$MemFini DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$MemFini DD @imagerel($LN7#)
	DD	@imagerel($LN7#+59)
	DD	@imagerel($unwind$MemFini#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
MemFini	PROC NEAR

; 162  : {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H

; 163  : 
; 164  : #if FASTMEM
; 165  : #ifdef DEBUG_OUT
; 166  :     if ( Options.quiet == FALSE )
; 167  :         printf( "memory used: %u kB\n", (blocks * BLKSIZE - currfree) / 1024 );
; 168  : #endif
; 169  :     while ( pBase ) {

	mov	rax, QWORD PTR pBase
	test	rax, rax
	je	SHORT $LN1@MemFini
$LL2@MemFini:

; 170  :         struct linked_list *pNext = pBase->next;

	mov	rbx, QWORD PTR [rax]

; 171  :         BLKFREE( pBase );

	xor	edx, edx
	mov	r8d, 32768				; 00008000H
	mov	rcx, rax
	call	QWORD PTR __imp_VirtualFree
	test	rbx, rbx

; 172  :         pBase = pNext;

	mov	rax, rbx
	mov	QWORD PTR pBase, rbx
	jne	SHORT $LL2@MemFini
$LN1@MemFini:

; 173  :     }
; 174  : #endif
; 175  : #ifdef DEBUG_OUT
; 176  :     if ( memcalls != memstart )
; 177  :         printf("still allocated memory blocks : %u\n", memcalls - memstart );
; 178  : #endif
; 179  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
MemFini	ENDP
_TEXT	ENDS
PUBLIC	LclAlloc
EXTRN	Fatal:NEAR
EXTRN	__imp_VirtualAlloc:NEAR
_BSS	SEGMENT
pCurr	DQ	01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$LclAlloc DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$LclAlloc DD @imagerel($LN6#)
	DD	@imagerel($LN6#+167)
	DD	@imagerel($unwind$LclAlloc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
size$ = 48
LclAlloc PROC NEAR

; 183  : {

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H

; 184  :     void        *ptr;
; 185  : 
; 186  : #if FASTMEM
; 187  :     size = (size + sizeof(void *)-1) & ~(sizeof(void *)-1);

	lea	rbx, QWORD PTR [rcx+7]

; 188  :     if ( currfree < size ) {

	mov	ecx, DWORD PTR currfree
	and	rbx, -8
	cmp	rcx, rbx
	jae	SHORT $LN5@LclAlloc

; 189  :         DebugMsg(("LclAlloc: new block needed, req. size=%Xh > currfree=%Xh\n", size, currfree ));
; 190  :         currfree = ( size <= ( BLKSIZE - sizeof( struct linked_list ) ) ? BLKSIZE - sizeof( struct linked_list ) : size );

	mov	ecx, 524280				; 0007fff8H
	mov	eax, ebx

; 191  :         BLKALLOC( pCurr, currfree + sizeof( struct linked_list ) );

	mov	r8d, 4096				; 00001000H
	cmp	rbx, rcx
	cmovbe	eax, ecx
	xor	ecx, ecx
	mov	edx, eax
	lea	r9d, QWORD PTR [rcx+4]
	mov	DWORD PTR currfree, eax
	add	rdx, 8
	call	QWORD PTR __imp_VirtualAlloc

; 192  :         if ( !pCurr ) {

	test	rax, rax
	mov	r11, rax
	mov	QWORD PTR pCurr, rax
	jne	SHORT $LN1@LclAlloc

; 193  :             currfree = 0;
; 194  :             Fatal( OUT_OF_MEMORY );

	lea	ecx, QWORD PTR [rax+105]
	mov	DWORD PTR currfree, eax
	call	Fatal
	mov	r11, QWORD PTR pCurr
$LN1@LclAlloc:

; 195  :         }
; 196  :         ((struct linked_list *)pCurr)->next = pBase;

	mov	rax, QWORD PTR pBase

; 197  :         pBase = (struct linked_list *)pCurr;
; 198  :         pCurr += sizeof( struct linked_list );

	mov	ecx, DWORD PTR currfree
	mov	QWORD PTR pBase, r11
	mov	QWORD PTR [r11], rax
	add	r11, 8
	jmp	SHORT $LN2@LclAlloc
$LN5@LclAlloc:
	mov	r11, QWORD PTR pCurr
$LN2@LclAlloc:

; 199  :         DebugCmd( blocks++ );
; 200  :     }
; 201  :     ptr = pCurr;

	mov	rax, r11

; 202  :     pCurr += size;

	add	r11, rbx

; 203  :     currfree -= size;

	sub	ecx, ebx
	mov	DWORD PTR currfree, ecx
	mov	QWORD PTR pCurr, r11

; 204  : 
; 205  : #else /* ! FASTMEM */
; 206  : 
; 207  :     ptr = malloc( size );
; 208  : #ifdef TRMEM
; 209  :     DebugMsg1(("LclAlloc(0x%X)=%p cnt=%" I32_SPEC "u\n", size, ptr, ++memcalls ));
; 210  : #endif
; 211  :     if( ptr == NULL ) {
; 212  :         Fatal( OUT_OF_MEMORY );
; 213  :     }
; 214  : #endif
; 215  :     return( ptr );
; 216  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
LclAlloc ENDP
_TEXT	ENDS
PUBLIC	MemAlloc
EXTRN	malloc:NEAR
xdata	SEGMENT
$unwind$MemAlloc DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$MemAlloc DD @imagerel($LN5#)
	DD	@imagerel($LN5#+36)
	DD	@imagerel($unwind$MemAlloc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
size$ = 48
MemAlloc PROC NEAR

; 233  : {

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H

; 234  :     void        *ptr;
; 235  :     ptr = malloc( size );

	call	malloc

; 236  :     DebugMsg1(("MemAlloc(0x%X)=%p cnt=%" I32_SPEC "u\n", size, ptr, ++memcalls ));
; 237  :     if( ptr == NULL ) {

	test	rax, rax
	mov	rbx, rax
	jne	SHORT $LN1@MemAlloc

; 238  :         Fatal( OUT_OF_MEMORY );

	lea	ecx, QWORD PTR [rax+105]
	call	Fatal

; 239  :     }
; 240  :     //memset( ptr, 0xff, size );
; 241  :     return( ptr );

	mov	rax, rbx
$LN1@MemAlloc:

; 242  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
MemAlloc ENDP
_TEXT	ENDS
PUBLIC	MemFree
EXTRN	free:NEAR
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
ptr$ = 8
MemFree	PROC NEAR

; 247  :     DebugMsg1(("MemFree(0x%p) cnt=%" I32_SPEC "u\n", ptr, --memcalls ));
; 248  :     free( ptr );
; 249  :     return;
; 250  : }

	jmp	free
MemFree	ENDP
_TEXT	ENDS
END
