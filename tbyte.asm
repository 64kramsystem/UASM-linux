; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
tab_plus_exp DD	00H
	DD	00H
	DD	0a0000000H
	DW	04002H
	ORG $+2
	DD	00H
	DD	00H
	DD	0c8000000H
	DW	04005H
	ORG $+2
	DD	00H
	DD	00H
	DD	09c400000H
	DW	0400cH
	ORG $+2
	DD	00H
	DD	00H
	DD	0bebc2000H
	DW	04019H
	ORG $+2
	DD	00H
	DD	04000000H
	DD	08e1bc9bfH
	DW	04034H
	ORG $+2
	DD	0f0200000H
	DD	02b70b59dH
	DD	09dc5ada8H
	DW	04069H
	ORG $+2
	DD	03cbf6b71H
	DD	0ffcfa6d5H
	DD	0c2781f49H
	DW	040d3H
	ORG $+2
	DD	0c66f336bH
	DD	080e98cdfH
	DD	093ba47c9H
	DW	041a8H
	ORG $+2
	DD	0ddbb9018H
	DD	09df9de8dH
	DD	0aa7eebfbH
	DW	04351H
	ORG $+2
	DD	0cc655c4bH
	DD	0a60e91c6H
	DD	0e319a0aeH
	DW	046a3H
	ORG $+2
	DD	0650d3d17H
	DD	081750c17H
	DD	0c9767586H
	DW	04d48H
	ORG $+2
	DD	0a74d28b1H
	DD	0c53d5de4H
	DD	09e8b3b5dH
	DW	05a92H
	ORG $+2
	DD	0c94c14f7H
	DD	08a20979aH
	DD	0c4605202H
	DW	07525H
	ORG $+2
tab_minus_exp DD 0cccccccdH
	DD	0ccccccccH
	DD	0ccccccccH
	DW	03ffbH
	ORG $+2
	DD	03d70a3d7H
	DD	070a3d70aH
	DD	0a3d70a3dH
	DW	03ff8H
	ORG $+2
	DD	0d3c36113H
	DD	0e219652bH
	DD	0d1b71758H
	DW	03ff1H
	ORG $+2
	DD	0fdc20d2aH
	DD	08461cefcH
	DD	0abcc7711H
	DW	03fe4H
	ORG $+2
	DD	04c2ebe65H
	DD	0c44de15bH
	DD	0e69594beH
	DW	03fc9H
	ORG $+2
	DD	067de18e7H
	DD	0453994baH
	DD	0cfb11eadH
	DW	03f94H
	ORG $+2
	DD	03f2398ccH
	DD	0a539e9a5H
	DD	0a87fea27H
	DW	03f2aH
	ORG $+2
	DD	0ac7cb3d9H
	DD	064bce4a0H
	DD	0ddd0467cH
	DW	03e55H
	ORG $+2
	DD	0fa911122H
	DD	0637a1939H
	DD	0c0314325H
	DW	03cacH
	ORG $+2
	DD	07132d2e4H
	DD	0db23d21cH
	DD	09049ee32H
	DW	0395aH
	ORG $+2
	DD	087a600a6H
	DD	0da57c0bdH
	DD	0a2a682a5H
	DW	032b5H
	ORG $+2
	DD	04925110fH
	DD	034362de4H
	DD	0ceae534fH
	DW	0256bH
	ORG $+2
	DD	02de37e46H
	DD	0d2ce9fdeH
	DD	0a6dd04c8H
	DW	0ad8H
	ORG $+2
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\tbyte.c
CONST	ENDS
_TEXT	SEGMENT
x$ = 8
cmp_u96_max PROC NEAR

; 111  :     if( x->m32[2] > 0x19999999UL ) {

	mov	eax, DWORD PTR [rcx+8]
	cmp	eax, 429496729				; 19999999H

; 112  :         return( 1 );

	ja	SHORT $LN18@cmp_u96_ma

; 113  :     } else if( x->m32[2] < 0x19999999UL ) {
; 114  :         return( -1 );

	jb	SHORT $LN19@cmp_u96_ma

; 115  :     } else if( x->m32[1] > 0x99999999UL ) {

	mov	eax, DWORD PTR [rcx+4]
	cmp	eax, -1717986919			; 99999999H

; 116  :         return( 1 );

	ja	SHORT $LN18@cmp_u96_ma

; 117  :     } else if( x->m32[1] < 0x99999999UL ) {

	jae	SHORT $LN6@cmp_u96_ma
$LN19@cmp_u96_ma:

; 118  :         return( -1 );

	mov	eax, -1

; 122  :         return( -1 );
; 123  :     } else {
; 124  :         return( 0 );
; 125  :     }
; 126  : }

	ret	0
$LN6@cmp_u96_ma:

; 119  :     } else if( x->m32[0] > 0x99999998UL ) {

	mov	eax, DWORD PTR [rcx]
	cmp	eax, -1717986920			; 99999998H
	jbe	SHORT $LN17@cmp_u96_ma
$LN18@cmp_u96_ma:

; 120  :         return( 1 );

	mov	eax, 1

; 122  :         return( -1 );
; 123  :     } else {
; 124  :         return( 0 );
; 125  :     }
; 126  : }

	ret	0
$LN17@cmp_u96_ma:

; 121  :     } else if( x->m32[0] < 0x99999998UL ) {

	sbb	eax, eax

; 122  :         return( -1 );
; 123  :     } else {
; 124  :         return( 0 );
; 125  :     }
; 126  : }

	ret	0
cmp_u96_max ENDP
; Function compile flags: /Ogtpy
x$ = 8
c$ = 16
add_check_u96_overflow PROC NEAR

; 134  :     uint_64 cy;
; 135  :     int i;
; 136  : 
; 137  :     if( cmp_u96_max( x ) > 0 ) {

	mov	eax, DWORD PTR [rcx+8]
	mov	r9, rcx
	cmp	eax, 429496729				; 19999999H
	ja	SHORT $LN27@add_check_
	jb	SHORT $LN5@add_check_
	mov	eax, DWORD PTR [rcx+4]
	cmp	eax, -1717986919			; 99999999H
	ja	SHORT $LN27@add_check_
	jb	SHORT $LN5@add_check_
	cmp	DWORD PTR [rcx], -1717986920		; 99999998H
	jbe	SHORT $LN5@add_check_
$LN27@add_check_:

; 138  :         return( 1 );

	mov	eax, 1

; 147  :     }
; 148  : }

	ret	0
$LN5@add_check_:

; 139  :     } else {
; 140  :         cy = c;
; 141  :         for( i = 0; i < 3; i++ ) {
; 142  :             cy += (uint_64)x->m32[i] * 10;

	mov	eax, DWORD PTR [rcx]
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	eax, edx
	lea	rdx, QWORD PTR [rax+rcx*2]
	mov	eax, DWORD PTR [r9+4]
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	eax, DWORD PTR [r9+8]

; 143  :             x->m32[i] = cy;

	mov	DWORD PTR [r9], edx

; 144  :             cy >>= 32;

	shr	rdx, 32					; 00000020H
	lea	r8, QWORD PTR [rdx+rcx*2]
	lea	ecx, DWORD PTR [rax+rax*4]

; 145  :         }
; 146  :         return( 0 );

	xor	eax, eax
	mov	DWORD PTR [r9+4], r8d
	add	ecx, ecx
	shr	r8, 32					; 00000020H
	add	r8d, ecx
	mov	DWORD PTR [r9+8], r8d

; 147  :     }
; 148  : }

	ret	0
add_check_u96_overflow ENDP
; Function compile flags: /Ogtpy
x$ = 8
bitsize32 PROC NEAR

; 155  :     int i;
; 156  : 
; 157  :     for( i = 32; i > 0 ; i-- ) {

	mov	eax, 32					; 00000020H
$LL4@bitsize32:

; 158  :         if( x & 0x80000000U ) break;

	bt	ecx, 31
	jb	SHORT $LN10@bitsize32
	dec	eax

; 159  :         x <<= 1;

	add	ecx, ecx
	test	eax, eax
	jg	SHORT $LL4@bitsize32
$LN10@bitsize32:

; 160  :     }
; 161  :     return( i );
; 162  : }

	ret	0
bitsize32 ENDP
; Function compile flags: /Ogtpy
x$ = 8
bitsize64 PROC NEAR

; 169  :     int i;
; 170  : 
; 171  :     for( i = 64; i > 0 ; i-- ) {

	mov	eax, 64					; 00000040H
	mov	rdx, -9223372036854775808		; 8000000000000000H
	npad	1
$LL4@bitsize64:

; 172  :         if( x & MAXUI64BIT ) break;

	test	rcx, rdx
	jne	SHORT $LN10@bitsize64
	dec	eax

; 173  :         x <<= 1;

	add	rcx, rcx
	test	eax, eax
	jg	SHORT $LL4@bitsize64
$LN10@bitsize64:

; 174  :     }
; 175  :     return( i );
; 176  : }

	ret	0
bitsize64 ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$U96LD DD 010201H
	DD	03002H
xdata	ENDS
pdata	SEGMENT
$pdata$U96LD DD	@imagerel(U96LD#)
	DD	@imagerel(U96LD#+239)
	DD	@imagerel($unwind$U96LD#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
op$ = 16
res$ = 24
U96LD	PROC NEAR

; 182  : {

	push	rbx

; 183  :     int bs;
; 184  :     int shft;
; 185  : 
; 186  :     memcpy( res, op, sizeof( union u96 ) );

	mov	eax, DWORD PTR [rcx]

; 187  :     bs = bitsize32( res->m32[2] ) + 64;

	mov	r11d, 32				; 00000020H
	mov	r10, rdx
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rdx+4], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rdx+8], eax
	mov	ecx, eax
	mov	eax, r11d
$LL11@U96LD:
	bt	ecx, 31
	jb	SHORT $LN29@U96LD
	dec	eax
	add	ecx, ecx
	test	eax, eax
	jg	SHORT $LL11@U96LD
$LN29@U96LD:
	add	eax, 64					; 00000040H

; 188  :     if( bs == 64 ) {

	xor	edx, edx
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN5@U96LD

; 189  :         res->m32[2] = res->m32[1];

	mov	eax, DWORD PTR [r10+4]
	mov	DWORD PTR [r10+8], eax

; 190  :         res->m32[1] = res->m32[0];

	mov	eax, DWORD PTR [r10]

; 191  :         res->m32[0] = 0;
; 192  :         bs = bitsize32( res->m32[2] ) + 32;

	mov	ecx, DWORD PTR [r10+8]
	mov	DWORD PTR [r10+4], eax
	mov	DWORD PTR [r10], edx
	mov	eax, r11d
$LL17@U96LD:
	bt	ecx, 31
	jb	SHORT $LN30@U96LD
	dec	eax
	add	ecx, ecx
	test	eax, eax
	jg	SHORT $LL17@U96LD
$LN30@U96LD:
	add	eax, r11d
$LN5@U96LD:

; 193  :     }
; 194  :     if( bs == 32 ) {

	cmp	eax, r11d
	jne	SHORT $LN4@U96LD

; 195  :         res->m32[2] = res->m32[1];

	mov	eax, DWORD PTR [r10+4]
	mov	DWORD PTR [r10+8], eax

; 196  :         res->m32[1] = res->m32[0];

	mov	eax, DWORD PTR [r10]

; 197  :         res->m32[0] = 0;
; 198  :         bs = bitsize32( res->m32[2] );

	mov	ecx, DWORD PTR [r10+8]
	mov	DWORD PTR [r10+4], eax
	mov	DWORD PTR [r10], edx
	mov	eax, r11d
$LL23@U96LD:
	bt	ecx, 31
	jb	SHORT $LN4@U96LD
	dec	eax
	add	ecx, ecx
	test	eax, eax
	jg	SHORT $LL23@U96LD
$LN4@U96LD:

; 199  :     }
; 200  :     if( bs == 0 ) {

	test	eax, eax
	jne	SHORT $LN3@U96LD

; 201  :         res->e = 0;

	mov	WORD PTR [r10+12], dx

; 215  : }

	pop	rbx
	ret	0
$LN3@U96LD:

; 202  :     } else {
; 203  :         res->e = bs - 1 + EXPONENT_BIAS;

	lea	ecx, DWORD PTR [rax+16382]

; 204  :         bs %= 32;

	cdq
	and	edx, 31
	mov	WORD PTR [r10+12], cx
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	mov	ebx, eax

; 205  :         if( bs ) {

	je	SHORT $LN35@U96LD

; 206  :             shft = 32 - bs;
; 207  :             res->m32[2] <<= shft;
; 208  :             res->m32[2] |= res->m32[1] >> bs;

	mov	r9d, DWORD PTR [r10+4]
	mov	r8d, DWORD PTR [r10+8]
	sub	r11d, eax
	mov	ecx, r11d
	mov	edx, r9d
	shl	r8d, cl
	mov	ecx, eax
	shr	edx, cl
	or	r8d, edx

; 209  :             res->m32[1] <<= shft;
; 210  :             res->m32[1] |= res->m32[0] >> bs;

	mov	edx, DWORD PTR [r10]
	mov	eax, edx
	mov	DWORD PTR [r10+8], r8d
	shr	eax, cl
	mov	ecx, r11d
	shl	r9d, cl
	or	eax, r9d

; 211  :             res->m32[0] <<= shft;

	shl	edx, cl
	mov	DWORD PTR [r10], edx
	mov	DWORD PTR [r10+4], eax
$LN35@U96LD:

; 212  :         }
; 213  :     }
; 214  :     return( 0 );

	xor	eax, eax

; 215  : }

	pop	rbx
	ret	0
U96LD	ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$normalize DD 010201H
	DD	03002H
xdata	ENDS
pdata	SEGMENT
$pdata$normalize DD @imagerel(normalize#)
	DD	@imagerel(normalize#+264)
	DD	@imagerel($unwind$normalize#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
res$ = 16
normalize PROC NEAR

; 222  : {

	push	rbx

; 223  :     int shft;
; 224  :     int bs;
; 225  :     int bs1;
; 226  : 
; 227  :     bs = bitsize64( res->m64[2] ) + 128;

	mov	rax, QWORD PTR [rcx+16]
	mov	rbx, rcx
	mov	ecx, 64					; 00000040H
	mov	r11d, ecx
	mov	rdx, -9223372036854775808		; 8000000000000000H
	npad	5
$LL10@normalize:
	test	rax, rdx
	jne	SHORT $LN28@normalize
	dec	r11d
	add	rax, rax
	test	r11d, r11d
	jg	SHORT $LL10@normalize
$LN28@normalize:
	sub	r11d, -128				; ffffffffffffff80H

; 228  :     if( bs == 128 ) {

	xor	r8d, r8d
	cmp	r11d, 128				; 00000080H
	jne	SHORT $LN4@normalize

; 229  :         res->m64[2] = res->m64[1];

	mov	rax, QWORD PTR [rbx+8]

; 230  :         res->m64[1] = res->m64[0];
; 231  :         res->m64[0] = 0;
; 232  :         bs = bitsize64( res->m64[2] ) + 64;

	mov	r11d, ecx
	mov	QWORD PTR [rbx+16], rax
	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rbx], r8
	mov	QWORD PTR [rbx+8], rax
	mov	rax, QWORD PTR [rbx+16]
	npad	7
$LL16@normalize:
	test	rax, rdx
	jne	SHORT $LN29@normalize
	dec	r11d
	add	rax, rax
	test	r11d, r11d
	jg	SHORT $LL16@normalize
$LN29@normalize:
	add	r11d, ecx
$LN4@normalize:

; 233  :     }
; 234  :     if( bs == 64 ) {

	cmp	r11d, ecx
	jne	SHORT $LN3@normalize

; 235  :         res->m64[2] = res->m64[1];

	mov	rax, QWORD PTR [rbx+8]

; 236  :         res->m64[1] = res->m64[0];
; 237  :         res->m64[0] = 0;
; 238  :         bs = bitsize64( res->m64[2] );

	mov	r11d, ecx
	mov	QWORD PTR [rbx+16], rax
	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rbx], r8
	mov	QWORD PTR [rbx+8], rax
	mov	rax, QWORD PTR [rbx+16]
$LL22@normalize:
	test	rax, rdx
	jne	SHORT $LN3@normalize
	dec	r11d
	add	rax, rax
	test	r11d, r11d
	jg	SHORT $LL22@normalize
$LN3@normalize:

; 239  :     }
; 240  :     if( bs == 0 ) {

	test	r11d, r11d
	jne	SHORT $LN2@normalize

; 241  :         return( 0 );

	xor	eax, eax

; 253  : }

	pop	rbx
	ret	0
$LN2@normalize:

; 242  :     }
; 243  :     bs1 = bs % 64;

	mov	eax, r11d
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	and	eax, 63					; 0000003fH
	sub	eax, edx

; 244  :     if ( bs1 ) {

	je	SHORT $LN1@normalize

; 245  :         shft = 64 - bs1;
; 246  :         res->m64[2] <<= shft;
; 247  :         res->m64[2] |= res->m64[1] >> bs1;

	mov	r9, QWORD PTR [rbx+8]
	sub	ecx, eax
	movsxd	r8, eax
	mov	rax, QWORD PTR [rbx+16]
	movsxd	r10, ecx
	mov	rdx, r9
	mov	rcx, r8
	shr	rdx, cl
	mov	rcx, r10
	shl	rax, cl

; 248  :         res->m64[1] <<= shft;
; 249  :         res->m64[1] |= res->m64[0] >> bs1;

	mov	rcx, r8
	or	rdx, rax
	mov	QWORD PTR [rbx+16], rdx
	mov	rdx, QWORD PTR [rbx]
	mov	rax, rdx
	shr	rax, cl
	mov	rcx, r10
	shl	r9, cl
	or	rax, r9

; 250  :         res->m64[0] <<= shft;

	shl	rdx, cl
	mov	QWORD PTR [rbx], rdx
	mov	QWORD PTR [rbx+8], rax
$LN1@normalize:

; 251  :     }
; 252  :     return( bs - 192 );

	lea	eax, DWORD PTR [r11-192]

; 253  : }

	pop	rbx
	ret	0
normalize ENDP
; Function compile flags: /Ogtpy
res$ = 8
x$ = 16
pos$ = 24
add192	PROC NEAR

; 259  : {

	mov	r9, rcx

; 260  :     uint_64 cy;
; 261  :     int i;
; 262  : 
; 263  :     cy = (uint_32)x;
; 264  :     for( i = pos; i < 6; i++ ) {

	movsxd	rcx, r8d
	mov	r10d, edx
	cmp	rcx, 6
	jge	SHORT $LN4@add192
	npad	1
$LL6@add192:

; 265  :         cy += res->m32[i];

	mov	eax, DWORD PTR [r9+rcx*4]
	inc	rcx
	add	r10, rax

; 266  :         res->m32[i] = cy;

	mov	DWORD PTR [r9+rcx*4-4], r10d

; 267  :         cy >>= 32;

	shr	r10, 32					; 00000020H
	cmp	rcx, 6
	jl	SHORT $LL6@add192
$LN4@add192:

; 268  :     }
; 269  :     cy = x >> 32;
; 270  :     for( i = pos + 1; i < 6; i++ ) {

	lea	eax, DWORD PTR [r8+1]
	shr	rdx, 32					; 00000020H
	movsxd	rcx, eax
	cmp	rcx, 6
	jge	SHORT $LN13@add192
	npad	6
$LL3@add192:

; 271  :         cy += res->m32[i];

	mov	eax, DWORD PTR [r9+rcx*4]
	inc	rcx
	add	rdx, rax

; 272  :         res->m32[i] = cy;

	mov	DWORD PTR [r9+rcx*4-4], edx

; 273  :         cy >>= 32;

	shr	rdx, 32					; 00000020H
	cmp	rcx, 6
	jl	SHORT $LL3@add192
$LN13@add192:

; 274  :     }
; 275  :     return( 0 );

	xor	eax, eax

; 276  : }

	ret	0
add192	ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$multiply DD 031901H
	DD	0f3419H
	DD	0a20cH
xdata	ENDS
pdata	SEGMENT
$pdata$multiply DD @imagerel(multiply#)
	DD	@imagerel(multiply#+30)
	DD	@imagerel($unwind$multiply#)
pdata	ENDS
xdata	SEGMENT
$chain$7$multiply DD 0e4821H
	DD	04f448H
	DD	05e438H
	DD	06d41aH
	DD	07c412H
	DD	08740eH
	DD	09640aH
	DD	0a5404H
	DD	@imagerel(multiply#)
	DD	@imagerel(multiply#+30)
	DD	@imagerel($unwind$multiply#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$multiply DD @imagerel(multiply#+30)
	DD	@imagerel(multiply#+709)
	DD	@imagerel($chain$7$multiply#)
pdata	ENDS
xdata	SEGMENT
$chain$8$multiply DD 060021H
	DD	04f400H
	DD	087400H
	DD	096400H
	DD	@imagerel(multiply#)
	DD	@imagerel(multiply#+30)
	DD	@imagerel($unwind$multiply#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$multiply DD @imagerel(multiply#+709)
	DD	@imagerel(multiply#+998)
	DD	@imagerel($chain$8$multiply#)
pdata	ENDS
xdata	SEGMENT
$chain$9$multiply DD 040021H
	DD	04f400H
	DD	087400H
	DD	@imagerel(multiply#)
	DD	@imagerel(multiply#+30)
	DD	@imagerel($unwind$multiply#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$multiply DD @imagerel(multiply#+998)
	DD	@imagerel(multiply#+1118)
	DD	@imagerel($chain$9$multiply#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
r1$ = 0
exp$1$ = 96
op1$ = 96
cy$3$ = 104
op2$ = 104
res$ = 112
multiply PROC NEAR

; 283  : {

	mov	QWORD PTR [rsp+24], r8
	mov	r11, rsp
	sub	rsp, 88					; 00000058H

; 284  :     uint_64 x1;
; 285  :     union u192 r1;
; 286  :     int_32 exp;
; 287  : 
; 288  :     exp = (int_32)(op1->e & 0x7fff) + (int_32)(op2->e & 0x7fff) - EXPONENT_BIAS + 1;

	mov	r9w, WORD PTR [rcx+12]
	mov	ax, WORD PTR [rdx+12]
	mov	QWORD PTR [r11+32], rbx
	and	eax, 32767				; 00007fffH
	mov	QWORD PTR [r11-8], rbp

; 289  :     r1.m64[0] = (uint_64)(op1->m32[0]) * (uint_64)(op2->m32[0]);

	mov	ebp, DWORD PTR [rdx]
	mov	QWORD PTR [r11-16], rsi
	mov	QWORD PTR [r11-24], rdi
	mov	QWORD PTR [r11-32], r12

; 290  :     r1.m64[1] = (uint_64)(op1->m32[1]) * (uint_64)(op2->m32[1]);
; 291  :     r1.m64[2] = (uint_64)(op1->m32[2]) * (uint_64)(op2->m32[2]);

	mov	r12d, DWORD PTR [rdx+8]
	mov	QWORD PTR [r11-40], r13
	mov	r13, rcx
	mov	esi, DWORD PTR [r13]
	mov	ebx, DWORD PTR [r13+4]
	and	r9d, 32767				; 00007fffH
	lea	ecx, DWORD PTR [r9+rax-16382]
	mov	QWORD PTR [r11-48], r14
	mov	r14d, DWORD PTR [rdx+4]
	mov	DWORD PTR exp$1$[rsp], ecx
	mov	ecx, DWORD PTR [r13+8]
	mov	QWORD PTR [r11-56], r15
	mov	QWORD PTR cy$3$[rsp], rcx
	mov	rax, rbp

; 292  :     x1 = (uint_64)(op1->m32[1]) * (uint_64)(op2->m32[0]);
; 293  :     add192( &r1, x1, 1 );
; 294  :     x1 = (uint_64)(op1->m32[0]) * (uint_64)(op2->m32[1]);

	mov	rdi, r14
	imul	rax, rsi
	mov	QWORD PTR r1$[rsp], rax
	mov	rax, r14
	imul	rdi, rsi
	imul	rax, rbx
	imul	rbx, rbp
	mov	QWORD PTR [r11-80], rax
	mov	rax, r12
	imul	rax, rcx
	mov	QWORD PTR [r11-72], rax
	mov	r11d, DWORD PTR [r11-84]
	mov	r15d, DWORD PTR r1$[rsp+20]
	mov	eax, ebx
	shr	rbx, 32					; 00000020H
	add	r11, rax
	mov	eax, DWORD PTR r1$[rsp+8]
	mov	rcx, r11
	shr	rcx, 32					; 00000020H
	add	rcx, rax
	mov	eax, DWORD PTR r1$[rsp+12]
	mov	rdx, rcx
	shr	rdx, 32					; 00000020H
	add	rdx, rax
	mov	eax, DWORD PTR r1$[rsp+16]
	mov	r8, rdx
	shr	r8, 32					; 00000020H
	add	r8, rax
	mov	rax, r8
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	eax, ecx
	add	rbx, rax
	mov	eax, edx
	mov	r9, rbx
	shr	r9, 32					; 00000020H
	add	r9, rax
	mov	eax, r8d

; 295  :     add192( &r1, x1, 1 );

	mov	r8d, r11d
	mov	r10, r9
	shr	r10, 32					; 00000020H
	add	r10, rax
	mov	rax, r10
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	eax, edi
	add	r8, rax
	mov	eax, ebx
	mov	DWORD PTR r1$[rsp+4], r8d
	shr	r8, 32					; 00000020H
	add	r8, rax
	mov	eax, r9d
	mov	rcx, r8
	shr	rcx, 32					; 00000020H
	add	rcx, rax
	mov	eax, r10d
	mov	rdx, rcx
	shr	rdx, 32					; 00000020H
	add	rdx, rax
	shr	rdi, 32					; 00000020H

; 296  :     x1 = (uint_64)(op1->m32[0]) * (uint_64)(op2->m32[2]);

	mov	rbx, r12
	mov	rax, rdx
	shr	rax, 32					; 00000020H
	imul	rbx, rsi

; 297  :     add192( &r1, x1, 2 );

	mov	r10d, ebx
	add	r15d, eax
	mov	eax, r8d
	shr	rbx, 32					; 00000020H
	add	rdi, rax
	mov	eax, ecx
	mov	r8, rdi
	shr	r8, 32					; 00000020H
	add	r8, rax
	mov	eax, edx
	mov	r9, r8
	shr	r9, 32					; 00000020H
	add	r9, rax
	mov	rax, r9
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	eax, edi

; 298  :     x1 = (uint_64)(op1->m32[2]) * (uint_64)(op2->m32[0]);

	mov	rdi, QWORD PTR cy$3$[rsp]
	add	r10, rax
	mov	eax, r8d
	mov	r11, rdi
	mov	rcx, r10
	shr	rcx, 32					; 00000020H
	add	rcx, rax
	mov	eax, r9d

; 299  :     add192( &r1, x1, 2 );
; 300  :     x1 = (uint_64)(op1->m32[1]) * (uint_64)(op2->m32[2]);

	mov	r9d, DWORD PTR [r13+4]
	imul	r11, rbp
	mov	rdx, rcx
	shr	rdx, 32					; 00000020H
	add	rdx, rax
	imul	r9, r12
	mov	rax, rdx
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	eax, ecx
	add	rbx, rax
	mov	eax, edx
	mov	edx, r11d
	mov	r8, rbx
	shr	r11, 32					; 00000020H
	shr	r8, 32					; 00000020H
	add	r8, rax
	mov	rax, r8
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	eax, r10d
	add	rdx, rax
	mov	eax, ebx
	mov	DWORD PTR r1$[rsp+8], edx
	shr	rdx, 32					; 00000020H
	add	rdx, rax
	mov	eax, r8d

; 301  :     add192( &r1, x1, 3 );

	mov	r8d, r9d
	mov	rcx, rdx
	shr	rcx, 32					; 00000020H
	add	rcx, rax
	mov	rax, rcx
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	eax, edx
	add	r11, rax
	mov	eax, ecx
	mov	rdx, r11
	shr	rdx, 32					; 00000020H
	add	rdx, rax
	mov	rax, rdx
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	eax, r11d
	add	r8, rax
	mov	eax, edx
	mov	rcx, r8
	shr	rcx, 32					; 00000020H
	add	rcx, rax
	mov	rax, rcx
	mov	r13, QWORD PTR [rsp+48]
	mov	r12, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+80]

; 302  :     x1 = (uint_64)(op1->m32[2]) * (uint_64)(op2->m32[1]);

	imul	rdi, r14
	mov	r14, QWORD PTR [rsp+40]
	shr	rax, 32					; 00000020H
	shr	r9, 32					; 00000020H
	add	r15d, eax
	mov	eax, ecx

; 303  :     add192( &r1, x1, 3 );

	mov	ebx, edi
	add	r9, rax
	shr	rdi, 32					; 00000020H

; 304  :     exp += normalize( &r1 );

	mov	rdx, -9223372036854775808		; 8000000000000000H
	mov	rax, r9
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	eax, r8d
	add	rbx, rax
	mov	eax, r9d
	mov	rcx, rbx
	mov	DWORD PTR r1$[rsp+12], ebx
	shr	rcx, 32					; 00000020H
	add	rcx, rax
	mov	rax, rcx
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	eax, ecx
	mov	ecx, 64					; 00000040H
	add	rdi, rax
	mov	r9d, ecx
	mov	rax, rdi
	mov	DWORD PTR r1$[rsp+16], edi
	mov	QWORD PTR cy$3$[rsp], rdi
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	DWORD PTR r1$[rsp+20], r15d
	mov	r11, QWORD PTR r1$[rsp+16]
	mov	rax, r11
$LL63@multiply:
	test	rax, rdx
	jne	SHORT $LN103@multiply
	dec	r9d
	add	rax, rax
	test	r9d, r9d
	jg	SHORT $LL63@multiply
$LN103@multiply:
	sub	r9d, -128				; ffffffffffffff80H
	cmp	r9d, 128				; 00000080H
	jne	SHORT $LN170@multiply
	mov	r11, QWORD PTR r1$[rsp+8]
	mov	r10, QWORD PTR r1$[rsp]
	xor	esi, esi
	mov	QWORD PTR r1$[rsp+16], r11
	mov	QWORD PTR r1$[rsp+8], r10
	mov	rax, r11
	mov	r9d, ecx
	npad	3
$LL69@multiply:
	test	rax, rdx
	jne	SHORT $LN104@multiply
	dec	r9d
	add	rax, rax
	test	r9d, r9d
	jg	SHORT $LL69@multiply
$LN104@multiply:
	mov	edi, DWORD PTR r1$[rsp+16]
	mov	r15d, DWORD PTR r1$[rsp+20]
	mov	ebx, DWORD PTR r1$[rsp+12]
	mov	QWORD PTR cy$3$[rsp], rdi
	add	r9d, ecx
	jmp	SHORT $LN57@multiply
$LN170@multiply:
	mov	r10, QWORD PTR r1$[rsp+8]
	mov	rsi, QWORD PTR r1$[rsp]
$LN57@multiply:
	cmp	r9d, ecx
	jne	SHORT $LN56@multiply
	mov	r11, r10
	mov	QWORD PTR r1$[rsp+16], r10
	mov	QWORD PTR r1$[rsp+8], rsi
	mov	r10, rsi
	mov	r9d, ecx
	mov	rax, r11
	xor	esi, esi
	npad	3
$LL75@multiply:
	test	rax, rdx
	jne	SHORT $LN105@multiply
	dec	r9d
	add	rax, rax
	test	r9d, r9d
	jg	SHORT $LL75@multiply
$LN105@multiply:
	mov	edi, DWORD PTR r1$[rsp+16]
	mov	r15d, DWORD PTR r1$[rsp+20]
	mov	ebx, DWORD PTR r1$[rsp+12]
	mov	QWORD PTR cy$3$[rsp], rdi
$LN56@multiply:
	test	r9d, r9d
	je	SHORT $LN58@multiply
$LN55@multiply:
	mov	eax, r9d
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	and	eax, 63					; 0000003fH
	sub	eax, edx
	je	SHORT $LN54@multiply
	sub	ecx, eax
	movsxd	r8, eax
	mov	rax, r10
	movsxd	rdx, ecx
	mov	rcx, rdx
	shl	r11, cl
	mov	rcx, r8
	shr	rax, cl
	mov	rcx, rdx
	or	r11, rax
	shl	r10, cl
	mov	rcx, r8
	shr	rsi, cl
	mov	edi, r11d
	mov	QWORD PTR r1$[rsp+16], r11
	mov	r15d, DWORD PTR r1$[rsp+20]
	or	r10, rsi
	mov	QWORD PTR cy$3$[rsp], rdi
	mov	QWORD PTR r1$[rsp+8], r10
	mov	ebx, DWORD PTR r1$[rsp+12]
$LN54@multiply:
	add	r9d, -192				; ffffffffffffff40H
$LN58@multiply:
	mov	edx, DWORD PTR exp$1$[rsp]
	mov	rsi, QWORD PTR [rsp+72]
	add	edx, r9d

; 305  :     /* round result */
; 306  :     if( r1.m32[2] & 0x80000000U ) {

	bt	DWORD PTR r1$[rsp+8], 31
	jae	SHORT $LN171@multiply

; 307  :         if( r1.m32[5] == 0xffffffffU && r1.m32[4] == 0xffffffffU && r1.m32[3] == 0xffffffffU ) {

	shr	r11, 32					; 00000020H
	cmp	r11d, -1				; ffffffffH
	jne	SHORT $LN2@multiply
	cmp	edi, r11d
	jne	SHORT $LN2@multiply
	shr	r10, 32					; 00000020H
	cmp	r10d, r11d
	jne	SHORT $LN2@multiply

; 308  :             r1.m32[3] = 0;

	xor	ebx, ebx

; 309  :             r1.m32[4] = 0;

	xor	ecx, ecx

; 310  :             r1.m32[5] = 0x80000000U;

	mov	r15d, -2147483648			; 80000000H

; 311  :             exp++;

	inc	edx

; 312  :         } else {

	jmp	SHORT $LN168@multiply
$LN2@multiply:

; 313  :             x1 = 1L;
; 314  :             add192( &r1, x1, 3 );

	mov	ecx, ebx
	mov	eax, edi
	inc	rcx
	mov	ebx, ecx
	shr	rcx, 32					; 00000020H
	add	rcx, rax
	mov	rax, rcx
	shr	rax, 32					; 00000020H
	add	r15d, eax
	mov	eax, ecx
	shr	rax, 32					; 00000020H
	add	r15d, eax
	jmp	SHORT $LN168@multiply
$LN171@multiply:

; 290  :     r1.m64[1] = (uint_64)(op1->m32[1]) * (uint_64)(op2->m32[1]);
; 291  :     r1.m64[2] = (uint_64)(op1->m32[2]) * (uint_64)(op2->m32[2]);

	mov	rcx, QWORD PTR cy$3$[rsp]
$LN168@multiply:

; 315  :         }
; 316  :     }
; 317  :     res->m32[0] = r1.m32[3];

	mov	rax, QWORD PTR res$[rsp]
	mov	rdi, QWORD PTR [rsp+64]
	mov	DWORD PTR [rax], ebx
	mov	rbx, QWORD PTR [rsp+120]

; 318  :     res->m32[1] = r1.m32[4];
; 319  :     res->m32[2] = r1.m32[5];

	mov	DWORD PTR [rax+8], r15d
	mov	r15, QWORD PTR [rsp+32]
	mov	DWORD PTR [rax+4], ecx

; 320  :     res->e = exp;

	mov	WORD PTR [rax+12], dx

; 321  :     return( 0 );

	xor	eax, eax

; 322  : }

	add	rsp, 88					; 00000058H
	ret	0
multiply ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$TB_create DD 010401H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$TB_create DD @imagerel(TB_create#)
	DD	@imagerel(TB_create#+6)
	DD	@imagerel($unwind$TB_create#)
pdata	ENDS
xdata	SEGMENT
$chain$2$TB_create DD 060f21H
	DD	0b740fH
	DD	0a640aH
	DD	095405H
	DD	@imagerel(TB_create#)
	DD	@imagerel(TB_create#+6)
	DD	@imagerel($unwind$TB_create#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$TB_create DD @imagerel(TB_create#+6)
	DD	@imagerel(TB_create#+53)
	DD	@imagerel($chain$2$TB_create#)
pdata	ENDS
xdata	SEGMENT
$chain$4$TB_create DD 044121H
	DD	083441H
	DD	06c405H
	DD	@imagerel(TB_create#+6)
	DD	@imagerel(TB_create#+53)
	DD	@imagerel($chain$2$TB_create#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$TB_create DD @imagerel(TB_create#+53)
	DD	@imagerel(TB_create#+338)
	DD	@imagerel($chain$4$TB_create#)
pdata	ENDS
xdata	SEGMENT
$chain$5$TB_create DD 020021H
	DD	083400H
	DD	@imagerel(TB_create#+6)
	DD	@imagerel(TB_create#+53)
	DD	@imagerel($chain$2$TB_create#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$TB_create DD @imagerel(TB_create#+338)
	DD	@imagerel(TB_create#+430)
	DD	@imagerel($chain$5$TB_create#)
pdata	ENDS
xdata	SEGMENT
$chain$6$TB_create DD 020021H
	DD	0a6400H
	DD	@imagerel(TB_create#)
	DD	@imagerel(TB_create#+6)
	DD	@imagerel($unwind$TB_create#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$TB_create DD @imagerel(TB_create#+430)
	DD	@imagerel(TB_create#+486)
	DD	@imagerel($chain$6$TB_create#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
res$ = 32
value$ = 64
exponent$ = 72
ld$ = 80
TB_create PROC NEAR

; 329  : {

	sub	rsp, 56					; 00000038H

; 330  :     const struct ELD *tabExp;
; 331  :     int i;
; 332  :     struct ELD res;
; 333  : 
; 334  :     if( exponent < 0 ) {

	test	edx, edx
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+88], rdi
	mov	rsi, r8
	mov	edi, edx
	jns	SHORT $LN11@TB_create

; 335  :         exponent = -exponent;

	neg	edi

; 336  :         tabExp = tab_minus_exp;

	lea	rbp, OFFSET FLAT:tab_minus_exp

; 337  :     } else {

	jmp	SHORT $LN10@TB_create
$LN11@TB_create:

; 338  :         tabExp = tab_plus_exp;

	lea	rbp, OFFSET FLAT:tab_plus_exp
$LN10@TB_create:

; 339  :     }
; 340  :     U96LD(value, &res);

	mov	eax, DWORD PTR [rcx]
	lea	rdx, QWORD PTR res$[rsp]
	mov	QWORD PTR [rsp+48], r12
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	r12d, 32				; 00000020H
	mov	DWORD PTR [rdx+4], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rdx+8], eax
	mov	r8d, DWORD PTR res$[rsp+8]
	mov	eax, r12d
	mov	ecx, r8d
	npad	7
$LL24@TB_create:
	bt	ecx, 31
	jb	SHORT $LN43@TB_create
	dec	eax
	add	ecx, ecx
	test	eax, eax
	jg	SHORT $LL24@TB_create
$LN43@TB_create:
	add	eax, 64					; 00000040H
	mov	QWORD PTR [rsp+64], rbx
	xor	ebx, ebx
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN52@TB_create
	mov	r8d, DWORD PTR res$[rsp+4]
	mov	r9d, DWORD PTR res$[rsp]
	mov	r10d, ebx
	mov	DWORD PTR res$[rsp], ebx
	mov	eax, r12d
	mov	DWORD PTR res$[rsp+8], r8d
	mov	DWORD PTR res$[rsp+4], r9d
	mov	ecx, r8d
	npad	2
$LL30@TB_create:
	bt	ecx, 31
	jb	SHORT $LN44@TB_create
	dec	eax
	add	ecx, ecx
	test	eax, eax
	jg	SHORT $LL30@TB_create
$LN44@TB_create:
	add	eax, r12d
	jmp	SHORT $LN18@TB_create
$LN52@TB_create:
	mov	r9d, DWORD PTR res$[rsp+4]
	mov	r10d, DWORD PTR res$[rsp]
$LN18@TB_create:
	cmp	eax, r12d
	jne	SHORT $LN45@TB_create
	mov	r8d, r9d
	mov	DWORD PTR res$[rsp+8], r9d
	mov	DWORD PTR res$[rsp+4], r10d
	mov	r9d, r10d
	mov	DWORD PTR res$[rsp], ebx
	mov	eax, r12d
	mov	ecx, r8d
	mov	r10d, ebx
	npad	1
$LL36@TB_create:
	bt	ecx, 31
	jb	SHORT $LN45@TB_create
	dec	eax
	add	ecx, ecx
	test	eax, eax
	jg	SHORT $LL36@TB_create
$LN45@TB_create:
	test	eax, eax
	jne	SHORT $LN16@TB_create
	mov	WORD PTR res$[rsp+12], bx
	jmp	SHORT $LN53@TB_create
$LN16@TB_create:
	lea	ecx, DWORD PTR [rax+16382]
	cdq
	and	edx, 31
	mov	WORD PTR res$[rsp+12], cx
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	mov	r11d, eax
	je	SHORT $LN53@TB_create
	sub	r12d, eax
	mov	edx, r9d
	mov	ecx, r12d
	shl	r8d, cl
	mov	ecx, eax
	mov	eax, r10d
	shr	edx, cl
	mov	ecx, r12d
	shl	r9d, cl
	mov	ecx, r11d
	or	r8d, edx
	shr	eax, cl
	mov	ecx, r12d
	mov	DWORD PTR res$[rsp+8], r8d
	or	r9d, eax
	shl	r10d, cl
	mov	DWORD PTR res$[rsp], r10d
	mov	DWORD PTR res$[rsp+4], r9d
$LN53@TB_create:
	mov	r12, QWORD PTR [rsp+48]
$LL14@TB_create:

; 341  :     for( i = 0; i < MAX_EXP_INDEX; i++ ) {
; 342  :         if ( exponent & 1 ) {

	test	dil, 1
	je	SHORT $LN6@TB_create

; 343  :             multiply(&res, tabExp + i, &res);

	movsxd	rdx, ebx
	lea	r8, QWORD PTR res$[rsp]
	lea	rcx, QWORD PTR res$[rsp]
	shl	rdx, 4
	add	rdx, rbp
	call	multiply
$LN6@TB_create:

; 344  :         }
; 345  :         exponent >>= 1;

	sar	edi, 1

; 346  :         if( exponent == 0 ) break;

	je	SHORT $LN46@TB_create
	inc	ebx
	cmp	ebx, 13
	jl	SHORT $LL14@TB_create
$LN46@TB_create:

; 347  :     }
; 348  :     if( exponent != 0 ) {
; 349  :         /* exponent overflow */
; 350  :     }
; 351  :     ld->e = res.e;
; 352  :     ld->m = res.m32[1] + ((uint_64)res.m32[2] << 32) ;

	mov	ecx, DWORD PTR res$[rsp+8]
	mov	eax, DWORD PTR res$[rsp+4]
	movzx	edx, WORD PTR res$[rsp+12]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]
	shl	rcx, 32					; 00000020H
	mov	WORD PTR [rsi+8], dx
	add	rax, rcx

; 353  :     /* round result */
; 354  :     if( res.m32[0] & 0x80000000U ) {

	bt	DWORD PTR res$[rsp], 31
	mov	QWORD PTR [rsi], rax
	jae	SHORT $LN51@TB_create

; 355  :         if( ld->m == MAXUI64 ) {

	cmp	rax, -1
	jne	SHORT $LN2@TB_create

; 356  :             ld->m = MAXUI64BIT;

	mov	rax, -9223372036854775808		; 8000000000000000H

; 357  :             ld->e++;

	inc	dx

; 358  :         } else {
; 359  :             ld->m++;

	mov	QWORD PTR [rsi], rax

; 360  :         }
; 361  :     }
; 362  :     return( 0 );

	xor	eax, eax
	mov	WORD PTR [rsi+8], dx
	mov	rsi, QWORD PTR [rsp+80]

; 363  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN2@TB_create:

; 358  :         } else {
; 359  :             ld->m++;

	inc	rax
	mov	QWORD PTR [rsi], rax
$LN51@TB_create:

; 360  :         }
; 361  :     }
; 362  :     return( 0 );

	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+80]

; 363  : }

	add	rsp, 56					; 00000038H
	ret	0
TB_create ENDP
_TEXT	ENDS
PUBLIC	strtotb
EXTRN	isspace:NEAR
xdata	SEGMENT
$unwind$strtotb DD 031001H
	DD	0133410H
	DD	0e20cH
xdata	ENDS
pdata	SEGMENT
$pdata$strtotb DD @imagerel($LN105#)
	DD	@imagerel($LN105#+16)
	DD	@imagerel($unwind$strtotb#)
pdata	ENDS
xdata	SEGMENT
$chain$5$strtotb DD 0a8921H
	DD	0bc489H
	DD	0e547fH
	DD	09e40cH
	DD	0c7408H
	DD	0d6404H
	DD	@imagerel($LN105#)
	DD	@imagerel($LN105#+16)
	DD	@imagerel($unwind$strtotb#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$strtotb DD @imagerel($LN105#+16)
	DD	@imagerel($LN105#+155)
	DD	@imagerel($chain$5$strtotb#)
pdata	ENDS
xdata	SEGMENT
$chain$7$strtotb DD 041721H
	DD	08f417H
	DD	0ad405H
	DD	@imagerel($LN105#+16)
	DD	@imagerel($LN105#+155)
	DD	@imagerel($chain$5$strtotb#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$strtotb DD @imagerel($LN105#+155)
	DD	@imagerel($LN105#+476)
	DD	@imagerel($chain$7$strtotb#)
pdata	ENDS
xdata	SEGMENT
$chain$8$strtotb DD 020021H
	DD	08f400H
	DD	@imagerel($LN105#+16)
	DD	@imagerel($LN105#+155)
	DD	@imagerel($chain$5$strtotb#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$strtotb DD @imagerel($LN105#+476)
	DD	@imagerel($LN105#+727)
	DD	@imagerel($chain$8$strtotb#)
pdata	ENDS
xdata	SEGMENT
$chain$9$strtotb DD 020021H
	DD	09e400H
	DD	@imagerel($LN105#)
	DD	@imagerel($LN105#+16)
	DD	@imagerel($unwind$strtotb#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$strtotb DD @imagerel($LN105#+727)
	DD	@imagerel($LN105#+776)
	DD	@imagerel($chain$9$strtotb#)
pdata	ENDS
xdata	SEGMENT
$chain$10$strtotb DD 0c0021H
	DD	08f400H
	DD	09e400H
	DD	0bc400H
	DD	0c7400H
	DD	0d6400H
	DD	0e5400H
	DD	@imagerel($LN105#)
	DD	@imagerel($LN105#+16)
	DD	@imagerel($unwind$strtotb#)
xdata	ENDS
pdata	SEGMENT
$pdata$10$strtotb DD @imagerel($LN105#+776)
	DD	@imagerel($LN105#+781)
	DD	@imagerel($chain$10$strtotb#)
pdata	ENDS
xdata	SEGMENT
$chain$11$strtotb DD 020021H
	DD	09e400H
	DD	@imagerel($LN105#)
	DD	@imagerel($LN105#+16)
	DD	@imagerel($unwind$strtotb#)
xdata	ENDS
pdata	SEGMENT
$pdata$11$strtotb DD @imagerel($LN105#+781)
	DD	@imagerel($LN105#+907)
	DD	@imagerel($chain$11$strtotb#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
value_tmp$ = 32
value$ = 48
exp_sign$1$ = 128
p$ = 128
ld$ = 136
sign$1$ = 144
negative$ = 144
strtotb	PROC NEAR

; 370  : {

$LN105:
	mov	QWORD PTR [rsp+16], rdx
	mov	rax, rsp
	sub	rsp, 120				; 00000078H
	mov	QWORD PTR [rax+32], rbx
	mov	QWORD PTR [rax-16], rsi
	mov	QWORD PTR [rax-24], rdi
	mov	QWORD PTR [rax-48], r14

; 371  :     int              sign = +1;

	mov	eax, 1
	mov	rbx, rcx

; 372  :     int              exp_sign = +1;
; 373  :     int_32           exp_value;
; 374  :     int              overflow;
; 375  :     int_32           exp1;
; 376  :     int_32           exponent;
; 377  :     int_32           exponent_tmp;
; 378  :     union u96        value;
; 379  :     union u96        value_tmp;
; 380  : 
; 381  :     while ( isspace( *p ) ) p++;

	movsx	ecx, BYTE PTR [rcx]
	mov	DWORD PTR exp_sign$1$[rsp], eax
	mov	esi, eax
	mov	DWORD PTR sign$1$[rsp], eax
	movzx	edi, r8b
	mov	r14, rdx
	call	isspace
	test	eax, eax
	je	SHORT $LN36@strtotb
	npad	9
$LL37@strtotb:
	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL37@strtotb
$LN36@strtotb:

; 382  :     switch (*p) {

	mov	al, BYTE PTR [rbx]
	cmp	al, 43					; 0000002bH
	je	SHORT $LN32@strtotb
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN31@strtotb

; 383  :     case '-':
; 384  :         sign = -1;

	mov	esi, -1
	mov	DWORD PTR sign$1$[rsp], esi
$LN32@strtotb:

; 385  :     case '+':
; 386  :         p++;

	inc	rbx
$LN31@strtotb:

; 387  :     default :
; 388  :         break;
; 389  :     }
; 390  :     if( negative ) {

	test	dil, dil
	je	SHORT $LN30@strtotb

; 391  :         sign = -sign;

	neg	esi
	mov	DWORD PTR sign$1$[rsp], esi
$LN30@strtotb:

; 392  :     }
; 393  :     memset( &value, 0, sizeof( value ) );
; 394  :     memset( &value_tmp, 0, sizeof( value_tmp ) );
; 395  :     //exponent = 0;
; 396  :     exp1 = 0;
; 397  :     exponent_tmp = 0;
; 398  :     overflow = 0;
; 399  :     while ( (unsigned int)(*p - '0') < 10u ) {

	movsx	edx, BYTE PTR [rbx]
	mov	QWORD PTR [rsp+112], rbp
	xor	edi, edi
	xor	r10d, r10d
	mov	QWORD PTR [rsp+88], r12
	xor	ebp, ebp
	mov	QWORD PTR [rsp+80], r13
	lea	r8d, DWORD PTR [rdx-48]
	mov	QWORD PTR value$[rsp], rdi
	cmp	r8d, 10
	mov	QWORD PTR [rsp+64], r15
	mov	r13d, edi
	mov	DWORD PTR value$[rsp+8], edi
	mov	QWORD PTR value_tmp$[rsp], rbp
	mov	r9d, r10d
	mov	r11d, r10d
	mov	r12d, r10d
	mov	eax, edx
	jae	$LN104@strtotb
	mov	esi, DWORD PTR value_tmp$[rsp+4]
	mov	r15d, ebp
	lea	r14d, QWORD PTR [rdi+1]
	npad	6
$LL29@strtotb:

; 400  :         if( overflow ) {

	test	r12d, r12d
	je	SHORT $LN27@strtotb

; 401  :             exponent_tmp++;

	inc	r11d

; 402  :             exp1++;

	inc	r9d

; 403  :         } else {

	jmp	$LN21@strtotb
$LN27@strtotb:

; 404  :             if( add_check_u96_overflow( &value_tmp, *p - '0' ) ) {

	cmp	ebp, 429496729				; 19999999H
	ja	$LN101@strtotb
	cmp	ebp, 429496729				; 19999999H
	jb	SHORT $LN44@strtotb
	cmp	esi, -1717986919			; 99999999H
	ja	SHORT $LN101@strtotb
	cmp	esi, -1717986919			; 99999999H
	jb	SHORT $LN44@strtotb
	cmp	r15d, -1717986920			; 99999998H
	ja	SHORT $LN101@strtotb
$LN44@strtotb:
	mov	eax, r15d
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	eax, esi
	lea	r15, QWORD PTR [r8+rcx*2]
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, r15
	mov	DWORD PTR value_tmp$[rsp], r15d
	shr	rax, 32					; 00000020H
	lea	rsi, QWORD PTR [rax+rcx*2]
	lea	eax, DWORD PTR [rbp+rbp*4]
	add	eax, eax
	mov	rcx, rsi
	mov	DWORD PTR value_tmp$[rsp+4], esi
	shr	rcx, 32					; 00000020H
	add	ecx, eax

; 408  :             } else if( *p != '0' ) {

	cmp	dl, 48					; 00000030H
	mov	ebp, ecx
	mov	DWORD PTR value_tmp$[rsp+8], ecx
	je	SHORT $LN23@strtotb

; 409  :                 memcpy( &value, &value_tmp, sizeof( value ) );

	lea	rcx, QWORD PTR value_tmp$[rsp]
	lea	rdx, QWORD PTR value$[rsp]

; 410  :                 exp1 = 0;

	mov	r9d, r10d
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rdx+8], eax
	mov	r13d, DWORD PTR value$[rsp+8]
	mov	rdi, QWORD PTR value$[rsp]
	jmp	SHORT $LN21@strtotb
$LN101@strtotb:

; 405  :                 overflow = 1;
; 406  :                 exponent_tmp++;

	inc	r11d
	mov	r12d, r14d

; 407  :                 exp1++;

	inc	r9d
	jmp	SHORT $LN21@strtotb
$LN23@strtotb:

; 411  :             } else if( U96ISNOTZERO(value) ) {

	cmp	DWORD PTR value$[rsp], r10d
	jne	SHORT $LN20@strtotb
	mov	rax, rdi
	shr	rax, 32					; 00000020H
	jne	SHORT $LN20@strtotb
	test	r13d, r13d
	je	SHORT $LN21@strtotb
$LN20@strtotb:

; 412  :                 exp1++;

	inc	r9d
$LN21@strtotb:

; 392  :     }
; 393  :     memset( &value, 0, sizeof( value ) );
; 394  :     memset( &value_tmp, 0, sizeof( value_tmp ) );
; 395  :     //exponent = 0;
; 396  :     exp1 = 0;
; 397  :     exponent_tmp = 0;
; 398  :     overflow = 0;
; 399  :     while ( (unsigned int)(*p - '0') < 10u ) {

	movsx	edx, BYTE PTR [rbx+1]

; 413  :             }
; 414  :         }
; 415  :         p++;

	inc	rbx
	lea	r8d, DWORD PTR [rdx-48]
	mov	eax, edx
	cmp	r8d, 10
	jb	$LL29@strtotb

; 392  :     }
; 393  :     memset( &value, 0, sizeof( value ) );
; 394  :     memset( &value_tmp, 0, sizeof( value_tmp ) );
; 395  :     //exponent = 0;
; 396  :     exp1 = 0;
; 397  :     exponent_tmp = 0;
; 398  :     overflow = 0;
; 399  :     while ( (unsigned int)(*p - '0') < 10u ) {

	mov	r14, QWORD PTR ld$[rsp]
	jmp	SHORT $LN28@strtotb
$LN104@strtotb:
	mov	esi, DWORD PTR value_tmp$[rsp+4]
	mov	r15d, DWORD PTR value_tmp$[rsp]
$LN28@strtotb:

; 416  :     }
; 417  :     exponent = exp1;
; 418  :     if ( *p == '.' ) {

	cmp	BYTE PTR [rbx], 46			; 0000002eH
	mov	r13, QWORD PTR [rsp+80]
	jne	$LN17@strtotb

; 419  :         p++;
; 420  :         while ( (unsigned int)(*p - '0') < 10u ) {

	movsx	edi, BYTE PTR [rbx+1]
	inc	rbx
	lea	edx, DWORD PTR [rdi-48]
	mov	eax, edi
	cmp	edx, 10
	jae	$LN17@strtotb
	mov	r14d, 1
$LL18@strtotb:

; 421  :             if( overflow == 0 ) {

	test	r12d, r12d
	jne	$LN13@strtotb

; 422  :                 if( add_check_u96_overflow( &value_tmp, *p - '0' ) ) {

	cmp	ebp, 429496729				; 19999999H
	ja	$LN103@strtotb
	cmp	ebp, 429496729				; 19999999H
	jb	SHORT $LN65@strtotb
	cmp	esi, -1717986919			; 99999999H
	ja	$LN103@strtotb
	cmp	esi, -1717986919			; 99999999H
	jb	SHORT $LN65@strtotb
	cmp	r15d, -1717986920			; 99999998H
	ja	$LN103@strtotb
$LN65@strtotb:
	mov	eax, r15d

; 425  :                     exponent_tmp--;

	dec	r11d
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	eax, esi
	lea	rdx, QWORD PTR [rdx+rcx*2]
	lea	rcx, QWORD PTR [rax+rax*4]
	lea	eax, DWORD PTR [rbp+rbp*4]
	add	eax, eax
	mov	r15d, edx
	mov	DWORD PTR value_tmp$[rsp], edx
	shr	rdx, 32					; 00000020H
	lea	r8, QWORD PTR [rdx+rcx*2]
	mov	esi, r8d
	mov	DWORD PTR value_tmp$[rsp+4], r8d
	shr	r8, 32					; 00000020H
	add	r8d, eax

; 426  :                     if( *p != '0' ) {

	cmp	dil, 48					; 00000030H
	mov	ebp, r8d
	mov	DWORD PTR value_tmp$[rsp+8], r8d
	je	SHORT $LN13@strtotb

; 427  :                         memcpy( &value, &value_tmp, sizeof( value ) );

	lea	rcx, QWORD PTR value_tmp$[rsp]
	lea	rdx, QWORD PTR value$[rsp]

; 428  :                         exponent = exponent_tmp;

	mov	r9d, r11d
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rdx+8], eax
$LN13@strtotb:
	movsx	edi, BYTE PTR [rbx+1]

; 429  :                     }
; 430  :                 }
; 431  :             }
; 432  :             p++;

	inc	rbx
	lea	edx, DWORD PTR [rdi-48]
	mov	eax, edi
	cmp	edx, 10
	jb	$LL18@strtotb
	mov	r14, QWORD PTR ld$[rsp]
$LN17@strtotb:

; 433  :         }
; 434  :     }
; 435  :     exp_value   = 0;
; 436  :     if ( (*p | 0x20) == 'e' ) {

	movzx	eax, BYTE PTR [rbx]
	mov	r15, QWORD PTR [rsp+64]
	mov	r12, QWORD PTR [rsp+88]
	mov	rdi, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+112]
	or	al, 32					; 00000020H
	cmp	al, 101					; 00000065H
	jne	$LN2@strtotb

; 437  :         switch ( *++p ) {

	mov	al, BYTE PTR [rbx+1]
	inc	rbx
	cmp	al, 43					; 0000002bH
	je	SHORT $LN8@strtotb
	cmp	al, 45					; 0000002dH
	je	SHORT $LN9@strtotb
	cmp	al, 47					; 0000002fH
	jle	SHORT $LN6@strtotb
	cmp	al, 57					; 00000039H
	jle	SHORT $LN87@strtotb
$LN6@strtotb:

; 441  :             break;
; 442  :         case '0':
; 443  :         case '1':
; 444  :         case '2':
; 445  :         case '3':
; 446  :         case '4':
; 447  :         case '5':
; 448  :         case '6':
; 449  :         case '7':
; 450  :         case '8':
; 451  :         case '9':
; 452  :             break;
; 453  :         default :
; 454  :             ld->m = 0;
; 455  :             ld->e = 0;
; 456  :             SET_SIGN( ld, sign );

	cmp	DWORD PTR sign$1$[rsp], r10d
	mov	QWORD PTR [r14], r10
	mov	WORD PTR [r14+8], r10w
	jge	SHORT $LN1@strtotb
	mov	WORD PTR [r14+8], 32768			; 00008000H

; 457  :             return( ld );

	jmp	SHORT $LN1@strtotb
$LN103@strtotb:

; 423  :                     overflow = 1;

	mov	r12d, r14d

; 424  :                 } else {

	jmp	SHORT $LN13@strtotb
$LN9@strtotb:

; 438  :         case '-':
; 439  :             exp_sign = -1;

	mov	DWORD PTR exp_sign$1$[rsp], -1
$LN8@strtotb:

; 440  :         case '+': p++;

	inc	rbx
$LN87@strtotb:

; 458  :         }
; 459  :         while ( (unsigned int)(*p - '0') < 10u )

	movsx	ecx, BYTE PTR [rbx]
	lea	eax, DWORD PTR [rcx-48]
	cmp	eax, 10
	jae	SHORT $LN3@strtotb
	npad	10
$LL4@strtotb:

; 460  :             exp_value = 10 * exp_value + (*p++ - '0');

	lea	eax, DWORD PTR [r10+r10*4]
	inc	rbx
	lea	r10d, DWORD PTR [rcx+rax*2-48]
	movsx	ecx, BYTE PTR [rbx]
	lea	eax, DWORD PTR [rcx-48]
	cmp	eax, 10
	jb	SHORT $LL4@strtotb
$LN3@strtotb:

; 461  :         if( exp_sign < 0 )

	cmp	DWORD PTR exp_sign$1$[rsp], 0
	jge	SHORT $LN2@strtotb

; 462  :             exp_value = -exp_value;

	neg	r10d
$LN2@strtotb:

; 463  :     }
; 464  :     exp_value += exponent;

	lea	edx, DWORD PTR [r10+r9]

; 465  :     TB_create( &value, exp_value, ld );

	lea	rcx, QWORD PTR value$[rsp]
	mov	r8, r14
	call	TB_create

; 466  :     SET_SIGN( ld, sign );

	cmp	DWORD PTR sign$1$[rsp], 0
	jge	SHORT $LN1@strtotb
	or	WORD PTR [r14+8], 32768			; 00008000H
$LN1@strtotb:
	mov	rbx, QWORD PTR [rsp+152]

; 467  :     return( ld );

	mov	rax, r14
	mov	r14, QWORD PTR [rsp+72]

; 468  : }

	add	rsp, 120				; 00000078H
	ret	0
strtotb	ENDP
_TEXT	ENDS
END
