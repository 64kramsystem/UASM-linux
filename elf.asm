; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
$SG5711	DB	'.shstrtab', 00H
	ORG $+6
$SG5712	DB	'.symtab', 00H
$SG5713	DB	'.strtab', 00H
_DATA	ENDS
CONST	SEGMENT
internal_segparms DQ FLAT:$SG5711
	DD	03H
	ORG $+4
	DQ	FLAT:$SG5712
	DD	02H
	ORG $+4
	DQ	FLAT:$SG5713
	DD	03H
	ORG $+4
CONST	ENDS
_DATA	SEGMENT
$SG5735	DB	'_TEXT', 00H
	ORG $+2
$SG5736	DB	'.text', 00H
	ORG $+2
$SG5737	DB	'_DATA', 00H
	ORG $+2
$SG5738	DB	'.data', 00H
	ORG $+2
$SG5739	DB	'CONST', 00H
	ORG $+2
$SG5740	DB	'.rodata', 00H
$SG5741	DB	'_BSS', 00H
	ORG $+3
$SG5742	DB	'.bss', 00H
_DATA	ENDS
CONST	SEGMENT
cst	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG5735
	DQ	FLAT:$SG5736
	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG5737
	DQ	FLAT:$SG5738
	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG5739
	DQ	FLAT:$SG5740
	DB	04H
	DB	00H
	ORG $+6
	DQ	FLAT:$SG5741
	DQ	FLAT:$SG5742
CONST	ENDS
_DATA	SEGMENT
	ORG $+3
$SG5943	DB	'.rela', 00H
	ORG $+2
$SG5944	DB	'.rel', 00H
	ORG $+3
$SG5986	DB	'CONST', 00H
	ORG $+2
$SG6035	DB	'CONST', 00H
	ORG $+2
$SG6154	DB	07fH, 'ELF', 00H
	ORG $+3
$SG6159	DB	07fH, 'ELF', 00H
_DATA	ENDS
EXTRN	memcmp:NEAR
xdata	SEGMENT
$unwind$ElfConvertSectionName DD 0f3601H
	DD	0b5436H
	DD	06e423H
	DD	07d41fH
	DD	08c41bH
	DD	0d7417H
	DD	0c640fH
	DD	0a340bH
	DD	08207H
xdata	ENDS
pdata	SEGMENT
$pdata$ElfConvertSectionName DD @imagerel(ElfConvertSectionName#)
	DD	@imagerel(ElfConvertSectionName#+279)
	DD	@imagerel($unwind$ElfConvertSectionName#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\elf.c
pdata	ENDS
_TEXT	SEGMENT
sym$ = 80
buffer$ = 88
ElfConvertSectionName PROC NEAR

; 148  : {

	mov	rax, rsp
	sub	rsp, 72					; 00000048H
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	rsi, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+32], rdi
	mov	QWORD PTR [rax-8], r12
	mov	QWORD PTR [rax-16], r13
	mov	QWORD PTR [rax-24], r14

; 149  :     int i;
; 150  : 
; 151  :     for ( i = 0; i < sizeof( cst ) / sizeof( cst[0] ); i++ ) {

	lea	r14, OFFSET FLAT:cst
	mov	r12, rdx
	mov	r13, rcx
	xor	edi, edi
	mov	QWORD PTR [rax+16], rbp
	mov	rbx, r14
	npad	7
$LL7@ElfConvert:

; 152  :         if ( memcmp( sym->name, cst[i].src, cst[i].len ) == 0 ) {

	movzx	ebp, BYTE PTR [rbx]
	mov	rdx, QWORD PTR [rbx+8]
	mov	r9d, 1
	mov	rcx, rsi
	mov	r8, rbp
	mov	DWORD PTR [rsp+32], 1
	call	memcmp
	test	eax, eax
	jne	SHORT $LN6@ElfConvert

; 153  :             if ( sym->name[cst[i].len] == NULLC )

	movzx	eax, BYTE PTR [rsi+rbp]
	test	al, al
	je	SHORT $LN13@ElfConvert

; 155  :             else if ( ( cst[i].flags & CSF_GRPCHK )  && sym->name[cst[i].len] == '$' ) {

	test	BYTE PTR [rbx+1], 1
	je	SHORT $LN6@ElfConvert
	cmp	al, 36					; 00000024H
	je	SHORT $LN14@ElfConvert
$LN6@ElfConvert:

; 149  :     int i;
; 150  : 
; 151  :     for ( i = 0; i < sizeof( cst ) / sizeof( cst[0] ); i++ ) {

	inc	edi
	add	rbx, 24
	cmp	edi, 4
	jb	SHORT $LL7@ElfConvert

; 159  :             }
; 160  :         }
; 161  :     }
; 162  :     return( sym->name );

	mov	rax, rsi
$LN8@ElfConvert:
	mov	r14, QWORD PTR [rsp+48]
	mov	r13, QWORD PTR [rsp+56]
	mov	r12, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]

; 163  : }

	add	rsp, 72					; 00000048H
	ret	0
$LN13@ElfConvert:

; 154  :                 return( (char *)cst[i].dst );

	movsxd	rax, edi
	lea	rax, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR [r14+rax*8+16]
	jmp	SHORT $LN8@ElfConvert
$LN14@ElfConvert:

; 156  :                 strcpy( buffer, cst[i].dst );

	movsxd	rax, edi
	mov	rdx, r12
	lea	rdi, QWORD PTR [rax+rax*2]
	mov	rcx, QWORD PTR [r14+rdi*8+16]
	npad	7
$LL10@ElfConvert:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL10@ElfConvert

; 157  :                 strcat( buffer, sym->name+cst[i].len );

	movzx	edx, BYTE PTR [r14+rdi*8]
	xor	eax, eax
	mov	rcx, -1
	add	rdx, QWORD PTR [r13+8]
	mov	rdi, r12
	repne scasb
	xor	ecx, ecx
	npad	7
$LL16@ElfConvert:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL16@ElfConvert

; 158  :                 return( buffer );

	mov	rax, r12
	jmp	$LN8@ElfConvert
ElfConvertSectionName ENDP
_TEXT	ENDS
EXTRN	SymTables:BYTE
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
get_num_reloc_sections PROC NEAR

; 170  :     struct dsym    *curr;
; 171  :     int num = 0;
; 172  : 
; 173  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rdx, QWORD PTR SymTables+32
	xor	eax, eax
	test	rdx, rdx
	je	SHORT $LN9@get_num_re
	npad	2
$LL4@get_num_re:

; 174  :         if ( curr->e.seginfo->FixupList.head )

	mov	rcx, QWORD PTR [rdx+104]
	cmp	QWORD PTR [rcx+40], 0
	je	SHORT $LN3@get_num_re

; 175  :             num++;

	inc	eax
$LN3@get_num_re:

; 170  :     struct dsym    *curr;
; 171  :     int num = 0;
; 172  : 
; 173  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rdx, QWORD PTR [rdx+112]
	test	rdx, rdx
	jne	SHORT $LL4@get_num_re
$LN9@get_num_re:

; 176  :     }
; 177  :     return( num );
; 178  : }

	ret	0
get_num_reloc_sections ENDP
_TEXT	ENDS
EXTRN	ModuleInfo:BYTE
EXTRN	Mangle:NEAR
EXTRN	GetSegIdx:NEAR
EXTRN	LclAlloc:NEAR
EXTRN	memset:NEAR
xdata	SEGMENT
$unwind$set_symtab32 DD 0ca901H
	DD	024c4a9H
	DD	029741dH
	DD	0286419H
	DD	0275412H
	DD	026340eH
	DD	025010aH
xdata	ENDS
pdata	SEGMENT
$pdata$set_symtab32 DD @imagerel(set_symtab32#)
	DD	@imagerel(set_symtab32#+600)
	DD	@imagerel($unwind$set_symtab32#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buffer$ = 32
em$ = 304
entries$ = 312
localshead$ = 320
set_symtab32 PROC NEAR

; 184  : {

	mov	rax, rsp
	sub	rsp, 296				; 00000128H
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp

; 185  :     uint_32   strsize = 1;
; 186  :     uint_32   len;
; 187  :     uint_8    stt;
; 188  :     struct dsym   *curr;
; 189  :     struct asym   *sym;
; 190  :     struct localname *localscurr;
; 191  :     struct qnode  *q;
; 192  :     Elf32_Sym *p32;
; 193  :     char      buffer[MAX_ID_LEN + MANGLE_BYTES + 1];
; 194  : 
; 195  :     em->internal_segs[SYMTAB_IDX].size = entries * sizeof( Elf32_Sym );

	shl	edx, 4
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	rdi, rcx
	mov	ecx, edx
	mov	rbp, r8
	mov	DWORD PTR [rdi+40], ecx

; 196  :     em->internal_segs[SYMTAB_IDX].data = LclAlloc( em->internal_segs[SYMTAB_IDX].size );

	call	LclAlloc

; 197  :     memset( em->internal_segs[SYMTAB_IDX].data, 0, em->internal_segs[SYMTAB_IDX].size );

	mov	r8d, DWORD PTR [rdi+40]
	mov	rcx, rax
	xor	edx, edx
	mov	QWORD PTR [rdi+48], rax
	call	memset

; 198  : 
; 199  :     p32 = (Elf32_Sym *)em->internal_segs[SYMTAB_IDX].data;
; 200  : 
; 201  :     p32++; /* skip NULL entry */

	mov	rbx, QWORD PTR [rdi+48]

; 202  : 
; 203  :     /* 1. make file entry */
; 204  :     p32->st_name = strsize;  /* symbol's name in string table */
; 205  :     strsize += strlen( em->srcname ) + 1;

	xor	eax, eax
	mov	DWORD PTR [rbx+16], 1
	mov	rdi, QWORD PTR [rdi+8]
	mov	rcx, -1
	repne scasb

; 206  :     p32->st_value = 0;

	mov	DWORD PTR [rbx+20], eax

; 207  :     p32->st_size = 0;

	mov	DWORD PTR [rbx+24], eax

; 208  :     p32->st_info = ELF32_ST_INFO( STB_LOCAL, STT_FILE ); /* symbol's type and binding info */

	mov	BYTE PTR [rbx+28], 4

; 209  :     p32->st_shndx = SHN_ABS; /* section index */

	mov	WORD PTR [rbx+30], 65521		; 0000fff1H

; 210  :     p32++;
; 211  : 
; 212  :     /* 2. make section entries */
; 213  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rdi, QWORD PTR SymTables+32
	not	rcx
	add	rbx, 32					; 00000020H
	test	rdi, rdi
	lea	esi, QWORD PTR [rcx+1]
	je	SHORT $LN23@set_symtab
$LL25@set_symtab:

; 214  :         //p32->st_name = ?;  /* name isn't set */
; 215  :         p32->st_info = ELF32_ST_INFO( STB_LOCAL, STT_SECTION );

	mov	BYTE PTR [rbx+12], 3

; 216  :         p32->st_shndx = GetSegIdx( curr->sym.segment );

	mov	rcx, QWORD PTR [rdi+32]
	call	GetSegIdx

; 217  :         p32++;

	add	rbx, 16
	mov	WORD PTR [rbx-2], ax
	mov	rdi, QWORD PTR [rdi+112]
	test	rdi, rdi
	jne	SHORT $LL25@set_symtab
$LN23@set_symtab:

; 218  :     }
; 219  : 
; 220  :     /* 3. locals */
; 221  : 
; 222  :     for ( localscurr = localshead ; localscurr ; localscurr = localscurr->next ) {

	test	rbp, rbp
	mov	QWORD PTR [rsp+288], r12
	je	SHORT $LN20@set_symtab
	npad	5
$LL22@set_symtab:

; 223  :         len = Mangle( localscurr->sym, buffer );

	mov	rcx, QWORD PTR [rbp+8]
	lea	rdx, QWORD PTR buffer$[rsp]
	call	Mangle

; 224  :         p32->st_name = strsize;

	mov	DWORD PTR [rbx], esi

; 225  :         curr = (struct dsym *)localscurr->sym->segment;

	mov	rcx, QWORD PTR [rbp+8]
	mov	rdi, QWORD PTR [rcx+32]
	mov	r12d, eax

; 226  :         if ( curr && curr->e.seginfo->segtype != SEGTYPE_CODE )

	test	rdi, rdi
	je	SHORT $LN19@set_symtab
	mov	rcx, QWORD PTR [rdi+104]
	cmp	DWORD PTR [rcx+72], 1
	je	SHORT $LN19@set_symtab

; 227  :             stt = STT_OBJECT;

	mov	cl, 1

; 228  :         else

	jmp	SHORT $LN18@set_symtab
$LN19@set_symtab:

; 229  :             stt = STT_FUNC;

	mov	cl, 2
$LN18@set_symtab:

; 230  :         p32->st_info = ELF32_ST_INFO( STB_LOCAL, stt );

	and	cl, 15

; 231  :         p32->st_value = localscurr->sym->offset;
; 232  : #if 1 /* v2.07: changed - to make MT_ABS obsolete */
; 233  :         if ( curr )

	test	rdi, rdi
	mov	BYTE PTR [rbx+12], cl
	mov	rax, QWORD PTR [rbp+8]
	mov	edx, DWORD PTR [rax+16]
	mov	DWORD PTR [rbx+4], edx
	je	SHORT $LN17@set_symtab

; 234  :             p32->st_shndx = GetSegIdx( &curr->sym );

	mov	rcx, rdi
	call	GetSegIdx
	mov	WORD PTR [rbx+14], ax

; 235  :         else

	jmp	SHORT $LN16@set_symtab
$LN17@set_symtab:

; 236  :             p32->st_shndx = SHN_ABS;

	mov	WORD PTR [rbx+14], 65521		; 0000fff1H
$LN16@set_symtab:

; 218  :     }
; 219  : 
; 220  :     /* 3. locals */
; 221  : 
; 222  :     for ( localscurr = localshead ; localscurr ; localscurr = localscurr->next ) {

	mov	rbp, QWORD PTR [rbp]

; 237  : #else
; 238  :         if ( localscurr->sym->mem_type == MT_ABS )
; 239  :             p32->st_shndx = SHN_ABS;
; 240  :         else
; 241  :             p32->st_shndx = GetSegIdx( &curr->sym );
; 242  : #endif
; 243  :         strsize += len + 1;
; 244  :         DebugMsg(("set_symtab32, LOCAL: symbol %s, value=%X\n", buffer, p32->st_value));
; 245  :         p32++;

	add	rbx, 16
	lea	esi, DWORD PTR [rsi+r12+1]
	test	rbp, rbp
	jne	SHORT $LL22@set_symtab
$LN20@set_symtab:

; 246  :     }
; 247  : 
; 248  :     /* 4. externals + communals (+ protos [since v2.01]) */
; 249  : 
; 250  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	rdi, QWORD PTR SymTables+16
	test	rdi, rdi
	je	SHORT $LN13@set_symtab
$LL15@set_symtab:

; 251  :         /* skip "weak" (=unused) externdefs */
; 252  :         if ( curr->sym.iscomm == FALSE && curr->sym.weak == TRUE )

	movzx	eax, BYTE PTR [rdi+55]
	test	al, 4
	jne	SHORT $LN12@set_symtab
	test	al, 8
	jne	SHORT $LN14@set_symtab
$LN12@set_symtab:

; 253  :             continue;
; 254  :         len = Mangle( &curr->sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rdi
	call	Mangle

; 255  : 
; 256  :         p32->st_name = strsize;

	mov	DWORD PTR [rbx], esi

; 257  : 
; 258  :         /* for COMMUNALs, store their size in the Value field */
; 259  :         if ( curr->sym.iscomm == TRUE ) {

	movzx	ecx, BYTE PTR [rdi+55]
	shr	cl, 2
	mov	r11d, eax
	and	cl, 1
	je	SHORT $LN11@set_symtab

; 260  :             p32->st_info = ELF32_ST_INFO( STB_GLOBAL, STT_COMMON );

	mov	BYTE PTR [rbx+12], 21

; 261  :             p32->st_value = curr->sym.total_size;

	mov	ecx, DWORD PTR [rdi+64]

; 262  :             p32->st_shndx = SHN_COMMON;

	mov	WORD PTR [rbx+14], 65522		; 0000fff2H
	mov	DWORD PTR [rbx+4], ecx

; 263  :         } else {

	jmp	SHORT $LN10@set_symtab
$LN11@set_symtab:

; 264  : #if OWELFIMPORT
; 265  :             p32->st_info = ( IsWeak( curr->sym ) ? ELF32_ST_INFO( STB_WEAK, STT_IMPORT ) : ELF32_ST_INFO( STB_GLOBAL, STT_IMPORT ) );
; 266  : #else
; 267  :             /* todo: set STT_FUNC for prototypes/code labels??? */
; 268  :             p32->st_info = ( IsWeak( curr->sym ) ? ELF32_ST_INFO( STB_WEAK, STT_NOTYPE ) : ELF32_ST_INFO( STB_GLOBAL, STT_NOTYPE ) );

	test	cl, cl
	jne	SHORT $LN28@set_symtab
	cmp	QWORD PTR [rdi+72], 0
	je	SHORT $LN28@set_symtab
	mov	eax, 32					; 00000020H
	jmp	SHORT $LN29@set_symtab
$LN28@set_symtab:
	mov	eax, 16
$LN29@set_symtab:
	mov	BYTE PTR [rbx+12], al

; 269  : #endif
; 270  :             p32->st_value = curr->sym.offset; /* is always 0 */

	mov	eax, DWORD PTR [rdi+16]

; 271  :             p32->st_shndx = SHN_UNDEF;

	mov	WORD PTR [rbx+14], 0
	mov	DWORD PTR [rbx+4], eax
$LN10@set_symtab:

; 272  :         }
; 273  : 
; 274  :         strsize += len + 1;

	lea	esi, DWORD PTR [rsi+r11+1]

; 275  :         DebugMsg(("set_symtab32, EXTERNAL: symbol %s, info=%X, shndx=%X, value=%X\n", buffer, p32->st_info, p32->st_shndx, p32->st_value));
; 276  :         p32++;

	add	rbx, 16
$LN14@set_symtab:
	mov	rdi, QWORD PTR [rdi+112]
	test	rdi, rdi
	jne	SHORT $LL15@set_symtab
$LN13@set_symtab:

; 277  :     }
; 278  : 
; 279  : #if ELFALIAS
; 280  :     /* 5. aliases */
; 281  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {
; 282  :         len = Mangle( &curr->sym, buffer );
; 283  : 
; 284  :         p32->st_name = strsize;
; 285  : 
; 286  : #if OWELFIMPORT
; 287  :         p32->st_info = ELF32_ST_INFO( STB_WEAK, STT_IMPORT );
; 288  : #else
; 289  :         p32->st_info = ELF32_ST_INFO( STB_WEAK, STT_NOTYPE );
; 290  : #endif
; 291  :         p32->st_value = 0; /* is always 0 */
; 292  :         p32->st_shndx = SHN_UNDEF;
; 293  : 
; 294  :         strsize += len + 1;
; 295  :         DebugMsg(("set_symtab32, ALIAS: symbol %s, value=%X\n", buffer, p32->st_value));
; 296  :         p32++;
; 297  :     }
; 298  : #endif
; 299  : 
; 300  :     /* 6. PUBLIC entries */
; 301  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	rdi, QWORD PTR ModuleInfo+16
	test	rdi, rdi
	je	SHORT $LN38@set_symtab
	npad	9
$LL9@set_symtab:

; 302  :         sym = q->sym;

	mov	rbp, QWORD PTR [rdi+8]

; 303  :         len = Mangle( sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rbp
	call	Mangle

; 304  : 
; 305  :         curr = (struct dsym *)sym->segment;

	mov	rdx, QWORD PTR [rbp+32]

; 306  :         if ( curr && curr->e.seginfo->segtype != SEGTYPE_CODE )

	test	rdx, rdx
	mov	r12d, eax
	je	SHORT $LN6@set_symtab
	mov	rcx, QWORD PTR [rdx+104]
	cmp	DWORD PTR [rcx+72], 1
	je	SHORT $LN6@set_symtab

; 307  :             stt = STT_OBJECT;

	mov	cl, 1

; 308  :         else

	jmp	SHORT $LN5@set_symtab
$LN6@set_symtab:

; 309  :             stt = STT_FUNC;

	mov	cl, 2
$LN5@set_symtab:

; 310  : 
; 311  :         p32->st_name = strsize;
; 312  :         p32->st_info = ELF32_ST_INFO( STB_GLOBAL, stt );

	and	cl, 15
	mov	DWORD PTR [rbx], esi
	add	cl, 16
	mov	BYTE PTR [rbx+12], cl

; 313  :         p32->st_value = sym->offset;

	mov	eax, DWORD PTR [rbp+16]
	mov	DWORD PTR [rbx+4], eax

; 314  : #if 1 /* v2.07: changed - to make MT_ABS obsolete */
; 315  :         if ( sym->state == SYM_INTERNAL )

	cmp	DWORD PTR [rbp+40], 1
	jne	SHORT $LN4@set_symtab

; 316  :             if ( curr )

	test	rdx, rdx
	je	SHORT $LN3@set_symtab

; 317  :                 p32->st_shndx = GetSegIdx( &curr->sym );

	mov	rcx, rdx
	call	GetSegIdx
	mov	WORD PTR [rbx+14], ax

; 318  :             else

	jmp	SHORT $LN1@set_symtab
$LN3@set_symtab:

; 319  :                 p32->st_shndx = SHN_ABS;

	mov	WORD PTR [rbx+14], 65521		; 0000fff1H

; 320  :         else

	jmp	SHORT $LN1@set_symtab
$LN4@set_symtab:

; 321  :             p32->st_shndx = SHN_UNDEF;

	mov	WORD PTR [rbx+14], 0
$LN1@set_symtab:

; 277  :     }
; 278  : 
; 279  : #if ELFALIAS
; 280  :     /* 5. aliases */
; 281  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {
; 282  :         len = Mangle( &curr->sym, buffer );
; 283  : 
; 284  :         p32->st_name = strsize;
; 285  : 
; 286  : #if OWELFIMPORT
; 287  :         p32->st_info = ELF32_ST_INFO( STB_WEAK, STT_IMPORT );
; 288  : #else
; 289  :         p32->st_info = ELF32_ST_INFO( STB_WEAK, STT_NOTYPE );
; 290  : #endif
; 291  :         p32->st_value = 0; /* is always 0 */
; 292  :         p32->st_shndx = SHN_UNDEF;
; 293  : 
; 294  :         strsize += len + 1;
; 295  :         DebugMsg(("set_symtab32, ALIAS: symbol %s, value=%X\n", buffer, p32->st_value));
; 296  :         p32++;
; 297  :     }
; 298  : #endif
; 299  : 
; 300  :     /* 6. PUBLIC entries */
; 301  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	rdi, QWORD PTR [rdi]

; 322  : #else
; 323  :         if ( sym->mem_type == MT_ABS )
; 324  :             p32->st_shndx = SHN_ABS;
; 325  :         else if ( curr )
; 326  :             p32->st_shndx = GetSegIdx( &curr->sym );
; 327  :         else
; 328  :             p32->st_shndx = SHN_UNDEF;
; 329  : #endif
; 330  :         strsize += len + 1;
; 331  : 
; 332  :         DebugMsg(("set_symtab32, PUBLIC+LOCAL: symbol %s, value=%X\n", buffer, p32->st_value));
; 333  : 
; 334  :         p32++;

	add	rbx, 16
	lea	esi, DWORD PTR [rsi+r12+1]
	test	rdi, rdi
	jne	SHORT $LL9@set_symtab
$LN38@set_symtab:
	mov	r12, QWORD PTR [rsp+288]
	mov	rdi, QWORD PTR [rsp+328]
	mov	rbp, QWORD PTR [rsp+312]
	mov	rbx, QWORD PTR [rsp+304]

; 335  :     }
; 336  : #if ADDSTARTLABEL
; 337  :     if ( ModuleInfo.g.start_label ) {
; 338  :         len = Mangle( ModuleInfo.g.start_label, buffer );
; 339  :         p32->st_name = strsize;
; 340  :         p32->st_info = ELF32_ST_INFO( STB_ENTRY, STT_FUNC );
; 341  :         p32->st_value = ModuleInfo.g.start_label->offset;
; 342  :         p32->st_shndx = GetSegIdx( ModuleInfo.g.start_label->segment );
; 343  :         strsize += len + 1;
; 344  :         DebugMsg(("set_symtab32, ENTRY: symbol %s, value=%X\n", buffer, p32->st_value));
; 345  :         p32++;
; 346  :     }
; 347  : #endif
; 348  :     return( strsize );

	mov	eax, esi
	mov	rsi, QWORD PTR [rsp+320]

; 349  : }

	add	rsp, 296				; 00000128H
	ret	0
set_symtab32 ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$set_symtab64 DD 0cac01H
	DD	024c4acH
	DD	029741aH
	DD	0286416H
	DD	0275412H
	DD	026340eH
	DD	025010aH
xdata	ENDS
pdata	SEGMENT
$pdata$set_symtab64 DD @imagerel(set_symtab64#)
	DD	@imagerel(set_symtab64#+605)
	DD	@imagerel($unwind$set_symtab64#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buffer$ = 32
em$ = 304
entries$ = 312
localshead$ = 320
set_symtab64 PROC NEAR

; 366  : {

	mov	rax, rsp
	sub	rsp, 296				; 00000128H
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	rdi, rcx

; 367  :     uint_32   strsize = 1;
; 368  :     uint_32   len;
; 369  :     uint_8    stt;
; 370  :     struct dsym   *curr;
; 371  :     struct asym   *sym;
; 372  :     struct localname *localscurr;
; 373  :     struct qnode  *q;
; 374  :     Elf64_Sym *p64;
; 375  :     char      buffer[MAX_ID_LEN + MANGLE_BYTES + 1];
; 376  : 
; 377  :     em->internal_segs[SYMTAB_IDX].size = entries * sizeof( Elf64_Sym );

	lea	ecx, DWORD PTR [rdx+rdx*2]
	shl	ecx, 3
	mov	rbp, r8
	mov	DWORD PTR [rdi+40], ecx

; 378  :     em->internal_segs[SYMTAB_IDX].data = LclAlloc( em->internal_segs[SYMTAB_IDX].size );

	call	LclAlloc

; 379  :     memset( em->internal_segs[SYMTAB_IDX].data, 0, em->internal_segs[SYMTAB_IDX].size );

	mov	r8d, DWORD PTR [rdi+40]
	mov	rcx, rax
	xor	edx, edx
	mov	QWORD PTR [rdi+48], rax
	call	memset

; 380  : 
; 381  :     p64 = (Elf64_Sym *)em->internal_segs[SYMTAB_IDX].data;
; 382  : 
; 383  :     p64++; /* skip NULL entry */

	mov	rbx, QWORD PTR [rdi+48]

; 384  : 
; 385  :     /* 1. make file entry */
; 386  :     p64->st_name = strsize;  /* symbol's name in string table */
; 387  :     strsize += strlen( em->srcname ) + 1;

	xor	eax, eax
	mov	DWORD PTR [rbx+24], 1
	mov	rdi, QWORD PTR [rdi+8]
	mov	rcx, -1
	repne scasb

; 388  :     p64->st_value = 0;

	mov	QWORD PTR [rbx+32], rax

; 389  :     p64->st_size = 0;

	mov	QWORD PTR [rbx+40], rax

; 390  :     p64->st_info = ELF64_ST_INFO( STB_LOCAL, STT_FILE ); /* symbol's type and binding info */

	mov	BYTE PTR [rbx+28], 4

; 391  :     p64->st_shndx = SHN_ABS; /* section index */

	mov	WORD PTR [rbx+30], 65521		; 0000fff1H

; 392  :     p64++;
; 393  : 
; 394  :     /* 2. make section entries */
; 395  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rdi, QWORD PTR SymTables+32
	not	rcx
	add	rbx, 48					; 00000030H
	test	rdi, rdi
	lea	esi, QWORD PTR [rcx+1]
	je	SHORT $LN23@set_symtab@2
$LL25@set_symtab@2:

; 396  :         //p64->st_name = ?;  /* name isn't set */
; 397  :         p64->st_info = ELF64_ST_INFO( STB_LOCAL, STT_SECTION );

	mov	BYTE PTR [rbx+4], 3

; 398  :         p64->st_shndx = GetSegIdx( curr->sym.segment );

	mov	rcx, QWORD PTR [rdi+32]
	call	GetSegIdx

; 399  :         p64++;

	add	rbx, 24
	mov	WORD PTR [rbx-18], ax
	mov	rdi, QWORD PTR [rdi+112]
	test	rdi, rdi
	jne	SHORT $LL25@set_symtab@2
$LN23@set_symtab@2:

; 400  :     }
; 401  : 
; 402  :     /* 3. locals */
; 403  : 
; 404  :     for ( localscurr = localshead ; localscurr ; localscurr = localscurr->next ) {

	test	rbp, rbp
	mov	QWORD PTR [rsp+288], r12
	je	SHORT $LN20@set_symtab@2
	npad	2
$LL22@set_symtab@2:

; 405  :         len = Mangle( localscurr->sym, buffer );

	mov	rcx, QWORD PTR [rbp+8]
	lea	rdx, QWORD PTR buffer$[rsp]
	call	Mangle

; 406  :         p64->st_name = strsize;

	mov	DWORD PTR [rbx], esi

; 407  :         curr = (struct dsym *)localscurr->sym->segment;

	mov	rcx, QWORD PTR [rbp+8]
	mov	rdi, QWORD PTR [rcx+32]
	mov	r12d, eax

; 408  :         if ( curr && curr->e.seginfo->segtype != SEGTYPE_CODE )

	test	rdi, rdi
	je	SHORT $LN19@set_symtab@2
	mov	rcx, QWORD PTR [rdi+104]
	cmp	DWORD PTR [rcx+72], 1
	je	SHORT $LN19@set_symtab@2

; 409  :             stt = STT_OBJECT;

	mov	cl, 1

; 410  :         else

	jmp	SHORT $LN18@set_symtab@2
$LN19@set_symtab@2:

; 411  :             stt = STT_FUNC;

	mov	cl, 2
$LN18@set_symtab@2:

; 412  :         p64->st_info = ELF64_ST_INFO( STB_LOCAL, stt );

	and	cl, 15

; 413  :         p64->st_value = localscurr->sym->offset;
; 414  : #if 1 /* v2.07: changed - to make MT_ABS obsolete */
; 415  :         if ( curr )

	test	rdi, rdi
	mov	BYTE PTR [rbx+4], cl
	mov	rax, QWORD PTR [rbp+8]
	movsxd	rdx, DWORD PTR [rax+16]
	mov	QWORD PTR [rbx+8], rdx
	je	SHORT $LN17@set_symtab@2

; 416  :             p64->st_shndx = GetSegIdx( &curr->sym );

	mov	rcx, rdi
	call	GetSegIdx
	mov	WORD PTR [rbx+6], ax

; 417  :         else

	jmp	SHORT $LN16@set_symtab@2
$LN17@set_symtab@2:

; 418  :             p64->st_shndx = SHN_ABS;

	mov	WORD PTR [rbx+6], 65521			; 0000fff1H
$LN16@set_symtab@2:

; 400  :     }
; 401  : 
; 402  :     /* 3. locals */
; 403  : 
; 404  :     for ( localscurr = localshead ; localscurr ; localscurr = localscurr->next ) {

	mov	rbp, QWORD PTR [rbp]

; 419  : #else
; 420  :         if ( localscurr->sym->mem_type == MT_ABS )
; 421  :             p64->st_shndx = SHN_ABS;
; 422  :         else
; 423  :             p64->st_shndx = GetSegIdx( &curr->sym );
; 424  : #endif
; 425  :         strsize += len + 1;
; 426  :         DebugMsg(("set_symtab64, LOCAL: symbol %s, value=%" I64_SPEC "X\n", buffer, p64->st_value));
; 427  :         p64++;

	add	rbx, 24
	lea	esi, DWORD PTR [rsi+r12+1]
	test	rbp, rbp
	jne	SHORT $LL22@set_symtab@2
$LN20@set_symtab@2:

; 428  :     }
; 429  : 
; 430  :     /* 4. externals + communals ( + protos [since v2.01]) */
; 431  : 
; 432  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	rdi, QWORD PTR SymTables+16
	test	rdi, rdi
	je	SHORT $LN13@set_symtab@2
	npad	7
$LL15@set_symtab@2:

; 433  :         /* skip "weak" (=unused) externdefs */
; 434  :         if ( curr->sym.iscomm == FALSE && curr->sym.weak == TRUE )

	movzx	eax, BYTE PTR [rdi+55]
	test	al, 4
	jne	SHORT $LN12@set_symtab@2
	test	al, 8
	jne	SHORT $LN14@set_symtab@2
$LN12@set_symtab@2:

; 435  :             continue;
; 436  :         len = Mangle( &curr->sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rdi
	call	Mangle

; 437  : 
; 438  :         p64->st_name = strsize;

	mov	DWORD PTR [rbx], esi

; 439  : 
; 440  :         /* for COMMUNALs, store their size in the Value field */
; 441  :         if ( curr->sym.iscomm == TRUE ) {

	movzx	ecx, BYTE PTR [rdi+55]
	shr	cl, 2
	mov	r11d, eax
	and	cl, 1
	je	SHORT $LN11@set_symtab@2

; 442  :             p64->st_info = ELF64_ST_INFO( STB_GLOBAL, STT_COMMON );

	mov	BYTE PTR [rbx+4], 21

; 443  :             p64->st_value = curr->sym.total_size;

	mov	ecx, DWORD PTR [rdi+64]

; 444  :             p64->st_shndx = SHN_COMMON;

	mov	WORD PTR [rbx+6], 65522			; 0000fff2H
	mov	QWORD PTR [rbx+8], rcx

; 445  :         } else {

	jmp	SHORT $LN10@set_symtab@2
$LN11@set_symtab@2:

; 446  : #if OWELFIMPORT
; 447  :             p64->st_info = ( IsWeak( curr->sym ) ? ELF64_ST_INFO( STB_WEAK, STT_IMPORT ) : ELF64_ST_INFO( STB_GLOBAL, STT_IMPORT ) );
; 448  : #else
; 449  :             /* todo: set STT_FUNC for prototypes??? */
; 450  :             p64->st_info = ( IsWeak( curr->sym ) ? ELF64_ST_INFO( STB_WEAK, STT_NOTYPE ) : ELF64_ST_INFO( STB_GLOBAL, STT_NOTYPE ) );

	test	cl, cl
	jne	SHORT $LN28@set_symtab@2
	cmp	QWORD PTR [rdi+72], 0
	je	SHORT $LN28@set_symtab@2
	mov	eax, 32					; 00000020H
	jmp	SHORT $LN29@set_symtab@2
$LN28@set_symtab@2:
	mov	eax, 16
$LN29@set_symtab@2:
	mov	BYTE PTR [rbx+4], al

; 451  : #endif
; 452  :             p64->st_value = curr->sym.offset; /* is always 0 */

	movsxd	rax, DWORD PTR [rdi+16]

; 453  :             p64->st_shndx = SHN_UNDEF;

	mov	WORD PTR [rbx+6], 0
	mov	QWORD PTR [rbx+8], rax
$LN10@set_symtab@2:

; 454  :         }
; 455  : 
; 456  :         strsize += len + 1;

	lea	esi, DWORD PTR [rsi+r11+1]

; 457  :         DebugMsg(("set_symtab64, EXTERNAL: symbol %s, info=%X, shndx=%X, value=%" I64_SPEC "X\n", buffer, p64->st_info, p64->st_shndx, p64->st_value));
; 458  :         p64++;

	add	rbx, 24
$LN14@set_symtab@2:
	mov	rdi, QWORD PTR [rdi+112]
	test	rdi, rdi
	jne	SHORT $LL15@set_symtab@2
$LN13@set_symtab@2:

; 459  :     }
; 460  : 
; 461  : #if ELFALIAS
; 462  :     /* 5. aliases */
; 463  : 
; 464  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {
; 465  :         len = Mangle( &curr->sym, buffer );
; 466  : 
; 467  :         p64->st_name = strsize;
; 468  : 
; 469  : #if OWELFIMPORT
; 470  :         p64->st_info = ELF64_ST_INFO( STB_WEAK, STT_IMPORT );
; 471  : #else
; 472  :         p64->st_info = ELF64_ST_INFO( STB_WEAK, STT_NOTYPE );
; 473  : #endif
; 474  :         p64->st_value = 0; /* is always 0 */
; 475  :         p64->st_shndx = SHN_UNDEF;
; 476  : 
; 477  :         strsize += len + 1;
; 478  :         DebugMsg(("set_symtab64, ALIASES: symbol %s, value=%" I64_SPEC "X\n", buffer, p64->st_value));
; 479  :         p64++;
; 480  :     }
; 481  : #endif
; 482  : 
; 483  :     /* 6. PUBLIC entries */
; 484  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	rdi, QWORD PTR ModuleInfo+16
	test	rdi, rdi
	je	SHORT $LN38@set_symtab@2
$LL9@set_symtab@2:

; 485  :         sym = q->sym;

	mov	rbp, QWORD PTR [rdi+8]

; 486  :         len = Mangle( sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rbp
	call	Mangle

; 487  : 
; 488  :         curr = (struct dsym *)sym->segment;

	mov	rdx, QWORD PTR [rbp+32]

; 489  :         if ( curr && curr->e.seginfo->segtype != SEGTYPE_CODE )

	test	rdx, rdx
	mov	r12d, eax
	je	SHORT $LN6@set_symtab@2
	mov	rcx, QWORD PTR [rdx+104]
	cmp	DWORD PTR [rcx+72], 1
	je	SHORT $LN6@set_symtab@2

; 490  :             stt = STT_OBJECT;

	mov	cl, 1

; 491  :         else

	jmp	SHORT $LN5@set_symtab@2
$LN6@set_symtab@2:

; 492  :             stt = STT_FUNC;

	mov	cl, 2
$LN5@set_symtab@2:

; 493  : 
; 494  :         p64->st_name = strsize;
; 495  :         p64->st_info = ELF64_ST_INFO( STB_GLOBAL, stt );

	and	cl, 15
	mov	DWORD PTR [rbx], esi
	add	cl, 16
	mov	BYTE PTR [rbx+4], cl

; 496  :         p64->st_value = sym->offset;

	movsxd	rax, DWORD PTR [rbp+16]
	mov	QWORD PTR [rbx+8], rax

; 497  : #if 1 /* v2.07: changed - to make MT_ABS obsolete */
; 498  :         if ( sym->state == SYM_INTERNAL )

	cmp	DWORD PTR [rbp+40], 1
	jne	SHORT $LN4@set_symtab@2

; 499  :             if ( curr )

	test	rdx, rdx
	je	SHORT $LN3@set_symtab@2

; 500  :                 p64->st_shndx = GetSegIdx( &curr->sym );

	mov	rcx, rdx
	call	GetSegIdx
	mov	WORD PTR [rbx+6], ax

; 501  :             else

	jmp	SHORT $LN1@set_symtab@2
$LN3@set_symtab@2:

; 502  :                 p64->st_shndx = SHN_ABS;

	mov	WORD PTR [rbx+6], 65521			; 0000fff1H

; 503  :         else

	jmp	SHORT $LN1@set_symtab@2
$LN4@set_symtab@2:

; 504  :             p64->st_shndx = SHN_UNDEF;

	mov	WORD PTR [rbx+6], 0
$LN1@set_symtab@2:

; 459  :     }
; 460  : 
; 461  : #if ELFALIAS
; 462  :     /* 5. aliases */
; 463  : 
; 464  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {
; 465  :         len = Mangle( &curr->sym, buffer );
; 466  : 
; 467  :         p64->st_name = strsize;
; 468  : 
; 469  : #if OWELFIMPORT
; 470  :         p64->st_info = ELF64_ST_INFO( STB_WEAK, STT_IMPORT );
; 471  : #else
; 472  :         p64->st_info = ELF64_ST_INFO( STB_WEAK, STT_NOTYPE );
; 473  : #endif
; 474  :         p64->st_value = 0; /* is always 0 */
; 475  :         p64->st_shndx = SHN_UNDEF;
; 476  : 
; 477  :         strsize += len + 1;
; 478  :         DebugMsg(("set_symtab64, ALIASES: symbol %s, value=%" I64_SPEC "X\n", buffer, p64->st_value));
; 479  :         p64++;
; 480  :     }
; 481  : #endif
; 482  : 
; 483  :     /* 6. PUBLIC entries */
; 484  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	rdi, QWORD PTR [rdi]

; 505  : #else
; 506  :         if ( sym->mem_type == MT_ABS )
; 507  :             p64->st_shndx = SHN_ABS;
; 508  :         else if ( curr )
; 509  :             p64->st_shndx = GetSegIdx( &curr->sym );
; 510  :         else
; 511  :             p64->st_shndx = SHN_UNDEF;
; 512  : #endif
; 513  :         strsize += len + 1;
; 514  : 
; 515  :         DebugMsg(("set_symtab64, PUBLIC+LOCAL: symbol %s, info=%X, shndx=%X, value=%" I64_SPEC "X\n", buffer, p64->st_info, p64->st_shndx, p64->st_value));
; 516  : 
; 517  :         p64++;

	add	rbx, 24
	lea	esi, DWORD PTR [rsi+r12+1]
	test	rdi, rdi
	jne	SHORT $LL9@set_symtab@2
$LN38@set_symtab@2:
	mov	r12, QWORD PTR [rsp+288]
	mov	rdi, QWORD PTR [rsp+328]
	mov	rbp, QWORD PTR [rsp+312]
	mov	rbx, QWORD PTR [rsp+304]

; 518  :     }
; 519  : #if ADDSTARTLABEL
; 520  :     if ( ModuleInfo.g.start_label ) {
; 521  :         len = Mangle( ModuleInfo.g.start_label, buffer );
; 522  :         p64->st_name = strsize;
; 523  :         p64->st_info = ELF64_ST_INFO( STB_ENTRY, STT_FUNC );
; 524  :         p64->st_value = ModuleInfo.g.start_label->offset;
; 525  :         p64->st_shndx = GetSegIdx( ModuleInfo.g.start_label->segment );
; 526  :         strsize += len + 1;
; 527  :         DebugMsg(("set_symtab64, ENTRY: symbol %s, value=%" I64_SPEC "X\n", buffer, p64->st_value));
; 528  :         p64++;
; 529  :     }
; 530  : #endif
; 531  :     return( strsize );

	mov	eax, esi
	mov	rsi, QWORD PTR [rsp+320]

; 532  : }

	add	rsp, 296				; 00000128H
	ret	0
set_symtab64 ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$set_symtab_values DD 030901H
	DD	083409H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$set_symtab_values DD @imagerel(set_symtab_values#)
	DD	@imagerel(set_symtab_values#+9)
	DD	@imagerel($unwind$set_symtab_values#)
pdata	ENDS
xdata	SEGMENT
$chain$5$set_symtab_values DD 0a5621H
	DD	0b7456H
	DD	05d421H
	DD	06c40fH
	DD	0a640aH
	DD	095405H
	DD	@imagerel(set_symtab_values#)
	DD	@imagerel(set_symtab_values#+9)
	DD	@imagerel($unwind$set_symtab_values#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$set_symtab_values DD @imagerel(set_symtab_values#+9)
	DD	@imagerel(set_symtab_values#+276)
	DD	@imagerel($chain$5$set_symtab_values#)
pdata	ENDS
xdata	SEGMENT
$chain$6$set_symtab_values DD 040021H
	DD	06c400H
	DD	0b7400H
	DD	@imagerel(set_symtab_values#)
	DD	@imagerel(set_symtab_values#+9)
	DD	@imagerel($unwind$set_symtab_values#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$set_symtab_values DD @imagerel(set_symtab_values#+276)
	DD	@imagerel(set_symtab_values#+528)
	DD	@imagerel($chain$6$set_symtab_values#)
pdata	ENDS
xdata	SEGMENT
$chain$7$set_symtab_values DD 020021H
	DD	0b7400H
	DD	@imagerel(set_symtab_values#)
	DD	@imagerel(set_symtab_values#+9)
	DD	@imagerel($unwind$set_symtab_values#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$set_symtab_values DD @imagerel(set_symtab_values#+528)
	DD	@imagerel(set_symtab_values#+621)
	DD	@imagerel($chain$7$set_symtab_values#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
em$ = 64
set_symtab_values PROC NEAR

; 540  : {

	sub	rsp, 56					; 00000038H
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+48], r12

; 541  :     uint_32 strsize;
; 542  :     uint_32 entries;
; 543  :     struct dsym *curr;
; 544  :     //struct asym *sym;
; 545  :     struct qnode *q;
; 546  :     char *p2;
; 547  :     struct {
; 548  :         struct localname *head;
; 549  :         struct localname *tail;
; 550  :     } locals = { NULL, NULL };
; 551  :     struct localname *localscurr;
; 552  : 
; 553  :     /* symbol table. there is
; 554  :      - 1 NULL entry,
; 555  :      - 1 entry for the module/file,
; 556  :      - 1 entry for each section and
; 557  :      - n entries for local symbols
; 558  :      - m entries for global symbols
; 559  :      */
; 560  : 
; 561  :     /* symbol table starts with 1 NULL entry + 1 file entry */
; 562  :     em->symindex = 1 + 1;

	mov	DWORD PTR [rcx], 2

; 563  : 
; 564  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next )

	mov	rbp, QWORD PTR SymTables+32
	mov	QWORD PTR [rsp+40], r13
	xor	r13d, r13d
	test	rbp, rbp
	mov	rbx, rcx
	mov	r12, r13
	mov	rsi, r13
	je	SHORT $LN32@set_symtab@3
	npad	5
$LL34@set_symtab@3:

; 565  :         curr->sym.ext_idx = em->symindex++;

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rbp+96], eax
	inc	DWORD PTR [rcx]
	mov	rbp, QWORD PTR [rbp+112]
	test	rbp, rbp
	jne	SHORT $LL34@set_symtab@3

; 563  : 
; 564  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next )

	mov	rbp, QWORD PTR SymTables+32
$LN32@set_symtab@3:

; 566  : 
; 567  :     /* add local symbols to symbol table */
; 568  : 
; 569  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	test	rbp, rbp
	mov	QWORD PTR [rsp+88], rdi
	je	$LN29@set_symtab@3
$LL31@set_symtab@3:

; 570  :         if ( curr->e.seginfo->num_relocs ) {

	mov	rdi, QWORD PTR [rbp+104]
	cmp	DWORD PTR [rdi+64], r13d
	je	SHORT $LN30@set_symtab@3

; 571  :             struct fixup *fix = curr->e.seginfo->FixupList.head;

	mov	rdi, QWORD PTR [rdi+40]

; 572  :             for ( ; fix; fix = fix->nextrlc ) {

	test	rdi, rdi
	je	SHORT $LN30@set_symtab@3
	npad	8
$LL27@set_symtab@3:

; 573  :                 /* if it's not EXTERNAL/PUBLIC, add symbol. */
; 574  :                 /* however, if it's an assembly time variable */
; 575  :                 /* use a raw section reference */
; 576  :                 if ( fix->sym->variable ) {

	mov	rax, QWORD PTR [rdi+56]
	movzx	ecx, BYTE PTR [rax+48]
	test	cl, 64					; 00000040H
	je	SHORT $LN24@set_symtab@3

; 577  :                     fix->sym = fix->segment_var;

	mov	rax, QWORD PTR [rdi+40]
	mov	QWORD PTR [rdi+56], rax

; 578  :                 } else if ( ( fix->sym->state == SYM_INTERNAL ) &&

	jmp	SHORT $LN26@set_symtab@3
$LN24@set_symtab@3:

; 579  :                     fix->sym->included == FALSE &&
; 580  :                     fix->sym->ispublic == FALSE ) {

	cmp	DWORD PTR [rax+40], 1
	jne	SHORT $LN26@set_symtab@3
	test	BYTE PTR [rax+49], 64			; 00000040H
	jne	SHORT $LN26@set_symtab@3
	test	cl, cl
	js	SHORT $LN26@set_symtab@3

; 581  :                     fix->sym->included = TRUE;

	or	BYTE PTR [rax+49], 64			; 00000040H

; 582  :                     localscurr = LclAlloc( sizeof( struct localname ) );

	mov	ecx, 16
	call	LclAlloc

; 583  :                     localscurr->next = NULL;
; 584  :                     localscurr->sym = fix->sym;
; 585  :                     if (locals.tail) {

	test	rsi, rsi
	mov	QWORD PTR [rax], r13
	mov	rcx, QWORD PTR [rdi+56]
	mov	QWORD PTR [rax+8], rcx
	je	SHORT $LN21@set_symtab@3

; 586  :                         locals.tail->next = localscurr;

	mov	QWORD PTR [rsi], rax

; 587  :                         locals.tail = localscurr;

	mov	rsi, rax

; 588  :                     } else {

	jmp	SHORT $LN20@set_symtab@3
$LN21@set_symtab@3:

; 589  :                         locals.head = locals.tail = localscurr;

	mov	rsi, rax
	mov	r12, rax
$LN20@set_symtab@3:

; 590  :                     }
; 591  :                     fix->sym->ext_idx = em->symindex++;

	mov	rcx, QWORD PTR [rdi+56]
	mov	eax, DWORD PTR [rbx]
	mov	DWORD PTR [rcx+96], eax
	inc	DWORD PTR [rbx]
$LN26@set_symtab@3:
	mov	rdi, QWORD PTR [rdi+8]
	test	rdi, rdi
	jne	SHORT $LL27@set_symtab@3
$LN30@set_symtab@3:

; 566  : 
; 567  :     /* add local symbols to symbol table */
; 568  : 
; 569  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbp, QWORD PTR [rbp+112]
	test	rbp, rbp
	jne	$LL31@set_symtab@3
$LN29@set_symtab@3:

; 592  :                 }
; 593  :             }
; 594  :         }
; 595  :     }
; 596  :     DebugMsg(("set_symtab_values: index after sections: %u\n", em->symindex));
; 597  :     em->start_globals = em->symindex;

	mov	eax, DWORD PTR [rbx]
	mov	r13, QWORD PTR [rsp+40]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+72]
	mov	DWORD PTR [rbx+4], eax

; 598  : 
; 599  :     /* count EXTERNs and used EXTERNDEFs (and PROTOs [since v2.01]) */
; 600  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	rcx, QWORD PTR SymTables+16
	test	rcx, rcx
	je	SHORT $LN17@set_symtab@3
$LL19@set_symtab@3:

; 601  :         if ( curr->sym.iscomm == FALSE && curr->sym.weak == TRUE )

	movzx	eax, BYTE PTR [rcx+55]
	test	al, 4
	jne	SHORT $LN16@set_symtab@3
	test	al, 8
	jne	SHORT $LN18@set_symtab@3
$LN16@set_symtab@3:

; 602  :             continue;
; 603  :         curr->sym.ext_idx = em->symindex++;

	mov	eax, DWORD PTR [rbx]
	mov	DWORD PTR [rcx+96], eax
	inc	DWORD PTR [rbx]
$LN18@set_symtab@3:
	mov	rcx, QWORD PTR [rcx+112]
	test	rcx, rcx
	jne	SHORT $LL19@set_symtab@3
$LN17@set_symtab@3:

; 604  :     }
; 605  :     DebugMsg(("set_symtab_values: index after EXTERNALs: %u\n", em->symindex));
; 606  : 
; 607  : #if ELFALIAS
; 608  :     /* count aliases */
; 609  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {
; 610  :         curr->sym.idx = em->symindex++;
; 611  :     }
; 612  :     DebugMsg(("set_symtab_values: index after ALIASES: %u\n", em->symindex));
; 613  : #endif
; 614  : 
; 615  :     /* count publics */
; 616  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	rdx, QWORD PTR ModuleInfo+16
	test	rdx, rdx
	je	SHORT $LN13@set_symtab@3
	npad	4
$LL15@set_symtab@3:

; 617  :         q->sym->ext_idx = em->symindex++;

	mov	rcx, QWORD PTR [rdx+8]
	mov	eax, DWORD PTR [rbx]
	mov	DWORD PTR [rcx+96], eax
	inc	DWORD PTR [rbx]
	mov	rdx, QWORD PTR [rdx]
	test	rdx, rdx
	jne	SHORT $LL15@set_symtab@3
$LN13@set_symtab@3:

; 618  :     }
; 619  :     DebugMsg(("set_symtab_values: index after PUBLICs: %u\n", em->symindex));
; 620  : 
; 621  :     /* size of symbol table is defined */
; 622  :     entries = em->symindex;
; 623  : 
; 624  : #if ADDSTARTLABEL
; 625  :     if ( ModuleInfo.g.start_label )
; 626  :         entries++;
; 627  : #endif
; 628  : 
; 629  : #if AMD64_SUPPORT
; 630  :     if ( ModuleInfo.defOfssize == USE64 )

	cmp	BYTE PTR ModuleInfo+405, 2
	mov	edx, DWORD PTR [rbx]
	jne	SHORT $LN12@set_symtab@3

; 631  :         strsize = set_symtab64( em, entries, locals.head );

	mov	r8, r12
	mov	rcx, rbx
	call	set_symtab64

; 632  :     else

	jmp	SHORT $LN11@set_symtab@3
$LN12@set_symtab@3:

; 633  : #endif
; 634  :         strsize = set_symtab32( em, entries, locals.head );

	mov	r8, r12
	mov	rcx, rbx
	call	set_symtab32
$LN11@set_symtab@3:

; 635  : 
; 636  :     /* generate the string table */
; 637  :     DebugMsg(("set_symtab_values: creating string table, size=%X\n", strsize));
; 638  : 
; 639  :     em->internal_segs[STRTAB_IDX].size = strsize;
; 640  :     em->internal_segs[STRTAB_IDX].data = LclAlloc( strsize );

	mov	ecx, eax
	mov	DWORD PTR [rbx+56], eax
	mov	edi, eax
	call	LclAlloc

; 641  :     memset( em->internal_segs[STRTAB_IDX].data, 0, strsize );

	mov	r8, rdi
	xor	edx, edx
	mov	rcx, rax
	mov	QWORD PTR [rbx+64], rax
	call	memset

; 642  :     p2 = em->internal_segs[STRTAB_IDX].data;

	mov	r11, QWORD PTR [rbx+64]

; 643  :     *p2++ = NULLC;

	mov	BYTE PTR [r11], 0

; 644  : 
; 645  :     strcpy( p2, em->srcname );

	mov	rcx, QWORD PTR [rbx+8]
	lea	rdx, QWORD PTR [r11+1]
	npad	13
$LL37@set_symtab@3:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL37@set_symtab@3

; 646  :     p2 += strlen( p2 ) + 1;

	xor	eax, eax
	lea	rdi, QWORD PTR [r11+1]
	mov	rcx, -1
	repne scasb

; 647  : 
; 648  :     for ( localscurr = locals.head ; localscurr ; localscurr = localscurr->next ) {

	test	r12, r12
	not	rcx
	lea	rdi, QWORD PTR [r11+rcx+1]
	je	SHORT $LN8@set_symtab@3
	npad	4
$LL10@set_symtab@3:

; 649  :         p2 += Mangle( localscurr->sym, p2 ) + 1;

	mov	rcx, QWORD PTR [r12+8]
	mov	rdx, rdi
	call	Mangle
	mov	r12, QWORD PTR [r12]
	inc	eax
	cdqe
	add	rdi, rax
	test	r12, r12
	jne	SHORT $LL10@set_symtab@3
$LN8@set_symtab@3:

; 650  :     }
; 651  : 
; 652  :     for( curr = SymTables[TAB_EXT].head ; curr != NULL ;curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+16
	mov	r12, QWORD PTR [rsp+48]
	test	rbx, rbx
	je	SHORT $LN5@set_symtab@3
	npad	2
$LL7@set_symtab@3:

; 653  :         if ( curr->sym.iscomm == FALSE && curr->sym.weak == TRUE )

	movzx	eax, BYTE PTR [rbx+55]
	test	al, 4
	jne	SHORT $LN4@set_symtab@3
	test	al, 8
	jne	SHORT $LN6@set_symtab@3
$LN4@set_symtab@3:

; 654  :             continue;
; 655  :         p2 += Mangle( &curr->sym, p2 ) + 1;

	mov	rdx, rdi
	mov	rcx, rbx
	call	Mangle
	inc	eax
	cdqe
	add	rdi, rax
$LN6@set_symtab@3:
	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL7@set_symtab@3
$LN5@set_symtab@3:

; 656  :     }
; 657  : 
; 658  : #if ELFALIAS
; 659  :     for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {
; 660  :         p2 += Mangle( &curr->sym, p2 ) + 1;
; 661  :     }
; 662  : #endif
; 663  : 
; 664  :     for ( q = ModuleInfo.g.PubQueue.head; q; q = q->next ) {

	mov	rbx, QWORD PTR ModuleInfo+16
	test	rbx, rbx
	je	SHORT $LN1@set_symtab@3
$LL3@set_symtab@3:

; 665  :         p2 += Mangle( q->sym, p2 ) + 1;

	mov	rcx, QWORD PTR [rbx+8]
	mov	rdx, rdi
	call	Mangle
	mov	rbx, QWORD PTR [rbx]
	inc	eax
	cdqe
	add	rdi, rax
	test	rbx, rbx
	jne	SHORT $LL3@set_symtab@3
$LN1@set_symtab@3:
	mov	rdi, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+64]

; 666  :     }
; 667  : #if ADDSTARTLABEL
; 668  :     if ( ModuleInfo.g.start_label ) {
; 669  :         Mangle( ModuleInfo.g.start_label, p2 );
; 670  :     }
; 671  : #endif
; 672  :     DebugMsg(("set_symtab_values: exit, symindex=%u\n", em->symindex ));
; 673  :     return;
; 674  : }

	add	rsp, 56					; 00000038H
	ret	0
set_symtab_values ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$set_shstrtab_values DD 0123c01H
	DD	026f43cH
	DD	027e432H
	DD	028d427H
	DD	029c423H
	DD	02a741fH
	DD	02f641bH
	DD	02e5417H
	DD	02d3413H
	DD	02b010fH
xdata	ENDS
pdata	SEGMENT
$pdata$set_shstrtab_values DD @imagerel(set_shstrtab_values#)
	DD	@imagerel(set_shstrtab_values#+1376)
	DD	@imagerel($unwind$set_shstrtab_values#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buffer$ = 48
em$ = 352
set_shstrtab_values PROC NEAR

; 686  : {

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, rsp
	sub	rsp, 344				; 00000158H
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rbp
	mov	QWORD PTR [rax+32], rsi
	mov	QWORD PTR [rax-8], rdi
	mov	QWORD PTR [rax-16], r12
	mov	QWORD PTR [rax-24], r13

; 687  :     int         i;
; 688  :     struct dsym *curr;
; 689  :     char        *p;
; 690  :     unsigned int size = 1; /* the first byte at offset 0 is the NULL section name */
; 691  :     char buffer[MAX_ID_LEN+1];
; 692  : 
; 693  :     /* get size of section names defined in the program & relocation sections ) */
; 694  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	r13, QWORD PTR SymTables+32
	mov	QWORD PTR [rax-32], r14
	mov	rbx, rcx
	test	r13, r13
	mov	QWORD PTR [rax-40], r15
	mov	r14d, 1
	lea	r12, OFFSET FLAT:cst
	je	$LN15@set_shstrt
	npad	1
$LL17@set_shstrt:

; 695  :         /* v2.07: ALIAS name defined? */
; 696  :         p = ( curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ElfConvertSectionName( &curr->sym, buffer ) );

	mov	r15, QWORD PTR [r13+104]
	mov	rbp, QWORD PTR [r15+96]
	test	rbp, rbp
	jne	SHORT $LN37@set_shstrt
	mov	rbp, QWORD PTR [r13+8]
	xor	ebx, ebx
	mov	rdi, r12
	xor	esi, esi
	npad	8
$LL36@set_shstrt:
	movzx	r12d, BYTE PTR [rdi]
	mov	rdx, QWORD PTR [rdi+8]
	mov	r9d, 1
	mov	rcx, rbp
	mov	r8, r12
	mov	DWORD PTR [rsp+32], 1
	call	memcmp
	test	eax, eax
	jne	SHORT $LN35@set_shstrt
	movzx	eax, BYTE PTR [r12+rbp]
	test	al, al
	je	$LN75@set_shstrt
	test	BYTE PTR [rdi+1], 1
	je	SHORT $LN35@set_shstrt
	cmp	al, 36					; 00000024H
	je	$LN76@set_shstrt
$LN35@set_shstrt:
	inc	ebx
	inc	rsi
	add	rdi, 24
	cmp	ebx, 4
	jb	SHORT $LL36@set_shstrt
	lea	r12, OFFSET FLAT:cst
$LN37@set_shstrt:

; 697  :         size += strlen( p ) + 1;

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbp
	repne scasb
	not	rcx
	dec	rcx

; 698  :         if ( curr->e.seginfo->FixupList.head )

	cmp	QWORD PTR [r15+40], rax
	lea	r14d, DWORD PTR [r14+rcx+1]
	je	SHORT $LN16@set_shstrt

; 699  :             size += strlen( p ) +
; 700  : #if AMD64_SUPPORT
; 701  :                 (( ModuleInfo.defOfssize == USE64 ) ? sizeof(".rela") : sizeof(".rel"));

	cmp	BYTE PTR ModuleInfo+405, 2
	sete	al
	add	eax, 5
	add	eax, ecx
	add	r14d, eax
$LN16@set_shstrt:
	mov	r13, QWORD PTR [r13+112]
	test	r13, r13
	jne	$LL17@set_shstrt
	mov	rbx, QWORD PTR em$[rsp]
$LN15@set_shstrt:

; 702  : #else
; 703  :                 sizeof(".rel");
; 704  : #endif
; 705  :     }
; 706  :     /* get internal section name sizes */
; 707  :     for ( i = 0; i < NUM_INTSEGS; i++ ) {

	lea	r15, OFFSET FLAT:internal_segparms
	lea	rsi, OFFSET FLAT:internal_segparms+48
	mov	rdx, r15
	npad	4
$LL13@set_shstrt:

; 708  :         size += strlen( internal_segparms[i].name ) + 1;

	mov	rdi, QWORD PTR [rdx]
	xor	eax, eax
	mov	rcx, -1
	repne scasb
	add	rdx, 16
	not	rcx
	add	r14d, ecx
	cmp	rdx, rsi
	jl	SHORT $LL13@set_shstrt

; 709  :     }
; 710  : 
; 711  :     em->internal_segs[SHSTRTAB_IDX].size = size;
; 712  : 
; 713  :     /* size is known, now alloc .shstrtab data buffer and fill it */
; 714  : 
; 715  :     em->internal_segs[SHSTRTAB_IDX].data = LclAlloc( size );

	mov	ecx, r14d
	mov	DWORD PTR [rbx+24], r14d
	call	LclAlloc
	mov	QWORD PTR [rbx+32], rax

; 716  :     p = (char *)em->internal_segs[SHSTRTAB_IDX].data;
; 717  :     *p++ = NULLC; /* NULL section name */

	mov	BYTE PTR [rax], 0

; 718  : 
; 719  :     /* 1. names of program sections */
; 720  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	r14, QWORD PTR SymTables+32
	lea	r13, QWORD PTR [rax+1]
	test	r14, r14
	je	$LL8@set_shstrt
	npad	12
$LL10@set_shstrt:

; 721  :         strcpy( p, curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ElfConvertSectionName( &curr->sym, buffer ) );

	mov	rcx, QWORD PTR [r14+104]
	mov	rdi, QWORD PTR [rcx+96]
	test	rdi, rdi
	jne	SHORT $LN47@set_shstrt
	mov	rdi, QWORD PTR [r14+8]
	xor	esi, esi
	mov	rbx, r12
	xor	ebp, ebp
	npad	8
$LL46@set_shstrt:
	movzx	r12d, BYTE PTR [rbx]
	mov	rdx, QWORD PTR [rbx+8]
	mov	r9d, 1
	mov	rcx, rdi
	mov	r8, r12
	mov	DWORD PTR [rsp+32], 1
	call	memcmp
	test	eax, eax
	jne	SHORT $LN45@set_shstrt
	movzx	eax, BYTE PTR [r12+rdi]
	test	al, al
	je	$LN77@set_shstrt
	test	BYTE PTR [rbx+1], 1
	je	SHORT $LN45@set_shstrt
	cmp	al, 36					; 00000024H
	je	$LN78@set_shstrt
$LN45@set_shstrt:
	inc	esi
	inc	rbp
	add	rbx, 24
	cmp	esi, 4
	jb	SHORT $LL46@set_shstrt
	lea	r12, OFFSET FLAT:cst
$LN47@set_shstrt:
	mov	rcx, r13
	npad	8
$LL24@set_shstrt:
	movzx	eax, BYTE PTR [rdi]
	inc	rcx
	inc	rdi
	test	al, al
	mov	BYTE PTR [rcx-1], al
	jne	SHORT $LL24@set_shstrt
	mov	r14, QWORD PTR [r14+112]

; 722  :         p += strlen( p ) + 1;

	xor	eax, eax
	mov	rdi, r13
	mov	rcx, -1
	repne scasb
	not	rcx
	add	r13, rcx
	test	r14, r14
	jne	$LL10@set_shstrt
	lea	rsi, OFFSET FLAT:internal_segparms+48
	npad	8
$LL8@set_shstrt:

; 723  :     }
; 724  :     /* 2. names of internal sections */
; 725  :     for ( i = 0; i < NUM_INTSEGS; i++ ) {
; 726  :         strcpy( p, internal_segparms[i].name );

	mov	rcx, QWORD PTR [r15]
	mov	rdx, r13
	npad	10
$LL25@set_shstrt:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL25@set_shstrt

; 727  :         p += strlen( p ) + 1;

	xor	eax, eax
	mov	rdi, r13
	mov	rcx, -1
	repne scasb
	add	r15, 16
	not	rcx
	add	r13, rcx
	cmp	r15, rsi
	jl	SHORT $LL8@set_shstrt

; 728  :     }
; 729  :     /* 3. names of "relocation" sections */
; 730  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	r14, QWORD PTR SymTables+32
	test	r14, r14
	je	$LN2@set_shstrt
	lea	r15, OFFSET FLAT:$SG5943
	npad	12
$LL4@set_shstrt:

; 731  :         if ( curr->e.seginfo->FixupList.head ) {

	mov	rax, QWORD PTR [r14+104]
	cmp	QWORD PTR [rax+40], 0
	je	$LN3@set_shstrt

; 732  : #if AMD64_SUPPORT
; 733  :             strcpy( p, (( ModuleInfo.defOfssize == USE64 ) ? ".rela": ".rel") );

	cmp	BYTE PTR ModuleInfo+405, 2
	lea	rcx, OFFSET FLAT:$SG5944
	mov	rdx, r13
	cmove	rcx, r15
	npad	12
$LL26@set_shstrt:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL26@set_shstrt

; 734  : #else
; 735  :             strcpy( p, ".rel" );
; 736  : #endif
; 737  :             p += strlen( p );

	xor	eax, eax
	mov	rdi, r13
	mov	rcx, -1
	repne scasb

; 738  :             strcpy( p, curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ElfConvertSectionName( &curr->sym, buffer ) );

	mov	rax, QWORD PTR [r14+104]
	mov	rdi, QWORD PTR [rax+96]
	not	rcx
	dec	rcx
	add	r13, rcx
	test	rdi, rdi
	jne	$LN54@set_shstrt
	mov	rdi, QWORD PTR [r14+8]
	xor	esi, esi
	mov	rbx, r12
	xor	ebp, ebp
	npad	13
$LL56@set_shstrt:
	movzx	r12d, BYTE PTR [rbx]
	mov	rdx, QWORD PTR [rbx+8]
	mov	r9d, 1
	mov	rcx, rdi
	mov	r8, r12
	mov	DWORD PTR [rsp+32], 1
	call	memcmp
	test	eax, eax
	jne	SHORT $LN55@set_shstrt
	movzx	eax, BYTE PTR [rdi+r12]
	test	al, al
	je	$LN79@set_shstrt
	test	BYTE PTR [rbx+1], 1
	je	SHORT $LN55@set_shstrt
	cmp	al, 36					; 00000024H
	je	$LN80@set_shstrt
$LN55@set_shstrt:
	inc	esi
	inc	rbp
	add	rbx, 24
	cmp	esi, 4
	jb	SHORT $LL56@set_shstrt
	jmp	$LN54@set_shstrt
$LN75@set_shstrt:

; 695  :         /* v2.07: ALIAS name defined? */
; 696  :         p = ( curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ElfConvertSectionName( &curr->sym, buffer ) );

	lea	rax, QWORD PTR [rsi+rsi*2]
	lea	r12, OFFSET FLAT:cst
	mov	rbp, QWORD PTR [r12+rax*8+16]
	jmp	$LN37@set_shstrt
$LN76@set_shstrt:
	lea	rdi, QWORD PTR [rsi+rsi*2]
	lea	r12, OFFSET FLAT:cst
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR [r12+rdi*8+16]
	sub	rdx, rcx
$LL39@set_shstrt:
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx+rcx-1], al
	jne	SHORT $LL39@set_shstrt
	movzx	edx, BYTE PTR [r12+rdi*8]
	xor	eax, eax
	lea	rdi, QWORD PTR buffer$[rsp]
	mov	rcx, -1
	add	rdx, rbp
	repne scasb
	xor	ecx, ecx
	npad	8
$LL91@set_shstrt:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL91@set_shstrt
	lea	rbp, QWORD PTR buffer$[rsp]
	jmp	$LN37@set_shstrt
$LN77@set_shstrt:

; 721  :         strcpy( p, curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ElfConvertSectionName( &curr->sym, buffer ) );

	lea	rax, QWORD PTR [rbp+rbp*2]
	lea	r12, OFFSET FLAT:cst
	mov	rdi, QWORD PTR [r12+rax*8+16]
	jmp	$LN47@set_shstrt
$LN78@set_shstrt:
	lea	r8, QWORD PTR [rbp+rbp*2]
	lea	r12, OFFSET FLAT:cst
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR [r12+r8*8+16]
	sub	rdx, rcx
	npad	8
$LL49@set_shstrt:
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rcx+rdx-1], al
	jne	SHORT $LL49@set_shstrt
	movzx	edx, BYTE PTR [r12+r8*8]
	xor	eax, eax
	mov	rcx, -1
	add	rdx, rdi
	lea	rdi, QWORD PTR buffer$[rsp]
	repne scasb
	xor	ecx, ecx
	npad	8
$LL90@set_shstrt:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL90@set_shstrt
	lea	rdi, QWORD PTR buffer$[rsp]
	jmp	$LN47@set_shstrt
$LN79@set_shstrt:

; 738  :             strcpy( p, curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ElfConvertSectionName( &curr->sym, buffer ) );

	lea	rax, QWORD PTR [rbp+rbp*2]
	lea	r9, OFFSET FLAT:cst
	mov	rdi, QWORD PTR [r9+rax*8+16]
	jmp	SHORT $LN54@set_shstrt
$LN80@set_shstrt:
	lea	r8, QWORD PTR [rbp+rbp*2]
	lea	r9, OFFSET FLAT:cst
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR [r9+r8*8+16]
	sub	rdx, rcx
	npad	11
$LL59@set_shstrt:
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rcx+rdx-1], al
	jne	SHORT $LL59@set_shstrt
	movzx	edx, BYTE PTR [r9+r8*8]
	xor	eax, eax
	mov	rcx, -1
	add	rdx, rdi
	lea	rdi, QWORD PTR buffer$[rsp]
	repne scasb
	xor	ecx, ecx
	npad	8
$LL89@set_shstrt:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL89@set_shstrt
	lea	rdi, QWORD PTR buffer$[rsp]
$LN54@set_shstrt:
	mov	rcx, r13
	npad	9
$LL29@set_shstrt:
	movzx	eax, BYTE PTR [rdi]
	inc	rcx
	inc	rdi
	test	al, al
	mov	BYTE PTR [rcx-1], al
	jne	SHORT $LL29@set_shstrt

; 739  :             p += strlen( p ) + 1;

	xor	eax, eax
	mov	rdi, r13
	mov	rcx, -1
	repne scasb
	not	rcx
	add	r13, rcx
$LN3@set_shstrt:
	mov	r14, QWORD PTR [r14+112]
	lea	r12, OFFSET FLAT:cst
	test	r14, r14
	jne	$LL4@set_shstrt
$LN2@set_shstrt:
	mov	r15, QWORD PTR [rsp+304]
	mov	r14, QWORD PTR [rsp+312]
	mov	r13, QWORD PTR [rsp+320]
	mov	r12, QWORD PTR [rsp+328]
	mov	rdi, QWORD PTR [rsp+336]
	mov	rsi, QWORD PTR [rsp+376]
	mov	rbp, QWORD PTR [rsp+368]
	mov	rbx, QWORD PTR [rsp+360]

; 740  :         }
; 741  :     }
; 742  :     /**/myassert( size == p - (char *)em->internal_segs[SHSTRTAB_IDX].data );
; 743  :     DebugMsg(("set_shstrtab_values: size=%X\n", size));
; 744  :     return;
; 745  : }

	add	rsp, 344				; 00000158H
	ret	0
set_shstrtab_values ENDP
; Function compile flags: /Ogtpy
curr$ = 8
get_relocation_count PROC NEAR

; 750  :     unsigned relocs;
; 751  :     struct fixup *fix;
; 752  : 
; 753  :     for ( relocs = 0, fix = curr->e.seginfo->FixupList.head; fix ; fix = fix->nextrlc, relocs++ );

	mov	rcx, QWORD PTR [rcx+104]
	xor	eax, eax
	mov	rdx, QWORD PTR [rcx+40]
	test	rdx, rdx
	je	SHORT $LN8@get_reloca
	npad	1
$LL3@get_reloca:
	mov	rdx, QWORD PTR [rdx+8]
	inc	eax
	test	rdx, rdx
	jne	SHORT $LL3@get_reloca
$LN8@get_reloca:

; 754  : 
; 755  :     return( relocs );
; 756  : }

	ret	0
get_relocation_count ENDP
; Function compile flags: /Ogtpy
curr$ = 8
Get_Alignment PROC NEAR

; 761  :     if ( curr->e.seginfo->alignment == MAX_SEGALIGNMENT )

	mov	rax, QWORD PTR [rcx+104]
	movzx	ecx, BYTE PTR [rax+106]
	cmp	cl, 255					; 000000ffH
	jne	SHORT $LN1@Get_Alignm

; 762  :         return( 0 );

	xor	eax, eax

; 764  : }

	ret	0
$LN1@Get_Alignm:

; 763  :     return( 1 << curr->e.seginfo->alignment );

	mov	eax, 1
	shl	eax, cl

; 764  : }

	ret	0
Get_Alignment ENDP
_TEXT	ENDS
EXTRN	WriteError:NEAR
EXTRN	fwrite:NEAR
xdata	SEGMENT
$unwind$elf_write_section_table32 DD 071301H
	DD	0dd413H
	DD	0ec40fH
	DD	010340bH
	DD	0e207H
xdata	ENDS
pdata	SEGMENT
$pdata$elf_write_section_table32 DD @imagerel(elf_write_section_table32#)
	DD	@imagerel(elf_write_section_table32#+29)
	DD	@imagerel($unwind$elf_write_section_table32#)
pdata	ENDS
xdata	SEGMENT
$chain$7$elf_write_section_table32 DD 0a7c21H
	DD	0ce47cH
	DD	0137477H
	DD	0126468H
	DD	011545bH
	DD	0bf404H
	DD	@imagerel(elf_write_section_table32#)
	DD	@imagerel(elf_write_section_table32#+29)
	DD	@imagerel($unwind$elf_write_section_table32#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$elf_write_section_table32 DD @imagerel(elf_write_section_table32#+29)
	DD	@imagerel(elf_write_section_table32#+784)
	DD	@imagerel($chain$7$elf_write_section_table32#)
pdata	ENDS
xdata	SEGMENT
$chain$8$elf_write_section_table32 DD 080021H
	DD	0ce400H
	DD	0137400H
	DD	0126400H
	DD	0115400H
	DD	@imagerel(elf_write_section_table32#)
	DD	@imagerel(elf_write_section_table32#+29)
	DD	@imagerel($unwind$elf_write_section_table32#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$elf_write_section_table32 DD @imagerel(elf_write_section_table32#+784)
	DD	@imagerel(elf_write_section_table32#+1054)
	DD	@imagerel($chain$8$elf_write_section_table32#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
shdr32$ = 32
modinfo$ = 128
em$ = 136
fileoffset$ = 144
elf_write_section_table32 PROC NEAR

; 776  : {

	mov	rax, rsp
	sub	rsp, 120				; 00000078H
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax-8], r12
	mov	QWORD PTR [rax-16], r13

; 777  :     int         i;
; 778  :     struct dsym *curr;
; 779  :     uint_8      *p;
; 780  :     //uint_32     fileoffset;
; 781  :     Elf32_Shdr  shdr32;
; 782  : 
; 783  :     DebugMsg(("elf_write_section_table32( fileofs=%X ): enter\n", fileoffset ));
; 784  : 
; 785  :     //fileoffset = sizeof(Elf64_Ehdr) + ehdr->e_shnum * ehdr->e_shentsize;
; 786  :     fileoffset = (fileoffset + 0xF) & ~0xF;

	lea	ebx, DWORD PTR [r8+15]
	mov	r13, rcx

; 787  : 
; 788  :     /* set contents and size of internal .shstrtab section */
; 789  :     set_shstrtab_values( em );

	mov	rcx, rdx
	mov	QWORD PTR [rax-32], r15
	mov	r12, rdx
	and	ebx, -16				; fffffff0H
	call	set_shstrtab_values

; 790  : 
; 791  :     /* write the NULL entry */
; 792  :     memset( &shdr32, 0, sizeof( shdr32) );
; 793  :     if ( fwrite( &shdr32, 1, sizeof(shdr32), CurrFile[OBJ] ) != sizeof(shdr32) ) /* write the empty NULL entry */

	mov	r9, QWORD PTR ModuleInfo+104
	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+40]
	mov	QWORD PTR shdr32$[rsp], rdx
	mov	QWORD PTR shdr32$[rsp+8], rdx
	mov	QWORD PTR shdr32$[rsp+16], rdx
	mov	QWORD PTR shdr32$[rsp+24], rdx
	mov	QWORD PTR shdr32$[rsp+32], rdx
	mov	r15d, 1
	lea	rcx, QWORD PTR shdr32$[rsp]
	mov	rdx, r15
	call	fwrite
	cmp	rax, 40					; 00000028H
	je	SHORT $LN25@elf_write_

; 794  :         WriteError();

	call	WriteError
$LN25@elf_write_:
	mov	QWORD PTR [rsp+136], rbp

; 795  : 
; 796  :     /* use p to scan strings (=section names) of .shstrtab */
; 797  :     p = (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;
; 798  :     p++; /* skip 'name' of NULL entry */

	mov	rbp, QWORD PTR [r12+32]
	mov	QWORD PTR [rsp+144], rsi

; 799  : 
; 800  :     /* write the section headers defined in the module, */
; 801  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rsi, QWORD PTR SymTables+32
	mov	QWORD PTR [rsp+152], rdi
	mov	QWORD PTR [rsp+96], r14
	inc	rbp
	xor	r14d, r14d
	test	rsi, rsi
	je	$LN22@elf_write_
	npad	8
$LL24@elf_write_:

; 802  : 
; 803  :         memset( &shdr32, 0, sizeof(shdr32) );

	xor	eax, eax

; 804  : 
; 805  :         shdr32.sh_name = p - (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;
; 806  :         p += strlen( (char *)p ) + 1;

	mov	rdi, rbp
	mov	rcx, -1
	mov	QWORD PTR shdr32$[rsp], rax
	mov	QWORD PTR shdr32$[rsp+8], rax
	mov	QWORD PTR shdr32$[rsp+16], rax
	mov	QWORD PTR shdr32$[rsp+24], rax
	mov	QWORD PTR shdr32$[rsp+32], rax
	mov	eax, ebp
	sub	eax, DWORD PTR [r12+32]
	mov	DWORD PTR shdr32$[rsp], eax
	xor	eax, eax
	repne scasb
	not	rcx
	add	rbp, rcx

; 807  :         if ( curr->e.seginfo->info == TRUE ) { /* v2.07:added; v2.12: highest priority */

	mov	rcx, QWORD PTR [rsi+104]
	test	BYTE PTR [rcx+107], 2
	je	SHORT $LN21@elf_write_

; 808  :             shdr32.sh_type = SHT_NOTE;

	mov	DWORD PTR shdr32$[rsp+4], 7

; 809  :             shdr32.sh_flags = 0;

	mov	DWORD PTR shdr32$[rsp+8], r14d

; 810  :         } else {

	jmp	SHORT $LN14@elf_write_
$LN21@elf_write_:

; 811  :             shdr32.sh_type = ( curr->e.seginfo->segtype != SEGTYPE_BSS ? SHT_PROGBITS : SHT_NOBITS );

	cmp	DWORD PTR [rcx+72], 3
	mov	eax, 8
	cmovne	eax, r15d
	mov	DWORD PTR shdr32$[rsp+4], eax

; 812  :             if ( curr->e.seginfo->segtype == SEGTYPE_CODE ) {

	mov	rax, QWORD PTR [rsi+104]
	cmp	DWORD PTR [rax+72], r15d
	jne	SHORT $LN19@elf_write_

; 813  :                 shdr32.sh_flags = SHF_EXECINSTR | SHF_ALLOC;

	mov	DWORD PTR shdr32$[rsp+8], 6
	jmp	SHORT $LN14@elf_write_
$LN19@elf_write_:

; 814  :             } else if ( curr->e.seginfo->readonly == TRUE ) {

	test	BYTE PTR [rax+107], r15b
	je	SHORT $LN17@elf_write_

; 815  :                 shdr32.sh_flags = SHF_ALLOC;

	mov	DWORD PTR shdr32$[rsp+8], 2
	jmp	SHORT $LN14@elf_write_
$LN17@elf_write_:

; 816  :             } else if ( curr->e.seginfo->clsym && strcmp( curr->e.seginfo->clsym->name, "CONST" ) == 0 ) {

	mov	rax, QWORD PTR [rax+80]
	test	rax, rax
	je	SHORT $LN15@elf_write_
	mov	rax, QWORD PTR [rax+8]
	lea	rdi, OFFSET FLAT:$SG5986
	sub	rdi, rax
	npad	1
$LL44@elf_write_:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+rdi]
	sub	edx, ecx
	jne	SHORT $LN45@elf_write_
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL44@elf_write_
$LN45@elf_write_:
	test	edx, edx
	jne	SHORT $LN15@elf_write_

; 817  :                 shdr32.sh_flags = SHF_ALLOC; /* v2.07: added */

	mov	DWORD PTR shdr32$[rsp+8], 2

; 818  :             } else {

	jmp	SHORT $LN14@elf_write_
$LN15@elf_write_:

; 819  :                 shdr32.sh_flags = SHF_WRITE | SHF_ALLOC;

	mov	DWORD PTR shdr32$[rsp+8], 3
$LN14@elf_write_:

; 820  :             }
; 821  :         }
; 822  : #if 0
; 823  :         /* todo: translate values in field <characteristics> to
; 824  :          * elf section flags.
; 825  :          */
; 826  :         if ( curr->e.seginfo->characteristics == ??? ) {
; 827  :         }
; 828  : #endif
; 829  :         shdr32.sh_addr = 0;

	mov	DWORD PTR shdr32$[rsp+12], r14d

; 830  :         /* v2.12: the sh_offset field holds the file position, even for SHT_NOBITS */
; 831  :         //if ( shdr32.sh_type != SHT_NOBITS ) {
; 832  :             shdr32.sh_offset = fileoffset; /* start of section in file */

	mov	DWORD PTR shdr32$[rsp+16], ebx

; 833  :             curr->e.seginfo->fileoffset = fileoffset; /* save the offset in the segment */

	mov	rax, QWORD PTR [rsi+104]
	mov	DWORD PTR [rax+56], ebx

; 834  :         //}
; 835  :         /* v2.07: set size for all sections, including .bss */
; 836  :         shdr32.sh_size = curr->sym.max_offset;

	mov	eax, DWORD PTR [rsi+64]

; 837  :         shdr32.sh_link = 0;

	mov	DWORD PTR shdr32$[rsp+24], r14d
	mov	DWORD PTR shdr32$[rsp+20], eax

; 838  :         shdr32.sh_info = 0;

	mov	DWORD PTR shdr32$[rsp+28], r14d

; 839  :         shdr32.sh_addralign = Get_Alignment( curr );

	mov	rax, QWORD PTR [rsi+104]
	cmp	BYTE PTR [rax+106], 255			; 000000ffH
	jne	SHORT $LN28@elf_write_
	mov	eax, r14d
	jmp	SHORT $LN29@elf_write_
$LN28@elf_write_:
	movzx	ecx, BYTE PTR [rax+106]
	mov	eax, r15d
	shl	eax, cl
$LN29@elf_write_:

; 840  :         shdr32.sh_entsize = 0;
; 841  : 
; 842  :         if ( fwrite( &shdr32, 1, sizeof(shdr32), CurrFile[OBJ] ) != sizeof(shdr32) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR shdr32$[rsp]
	mov	r8d, 40					; 00000028H
	mov	rdx, r15
	mov	DWORD PTR shdr32$[rsp+32], eax
	mov	DWORD PTR shdr32$[rsp+36], r14d
	call	fwrite
	cmp	rax, 40					; 00000028H
	je	SHORT $LN13@elf_write_

; 843  :             WriteError();

	call	WriteError
$LN13@elf_write_:

; 844  :         curr->e.seginfo->num_relocs = get_relocation_count( curr );

	mov	rdx, QWORD PTR [rsi+104]
	mov	ecx, r14d
	mov	rax, QWORD PTR [rdx+40]
	test	rax, rax
	je	SHORT $LN31@elf_write_
	npad	1
$LL33@elf_write_:
	mov	rax, QWORD PTR [rax+8]
	inc	ecx
	test	rax, rax
	jne	SHORT $LL33@elf_write_
$LN31@elf_write_:
	mov	DWORD PTR [rdx+64], ecx

; 845  : 
; 846  :         /* v2.12: don't adjust fileoffset for SHT_NOBITS sections.
; 847  :          * it didn't cause fatal damage previously, but made the
; 848  :          * object module unnecessary large.
; 849  :          */
; 850  :         if ( shdr32.sh_type != SHT_NOBITS ) {

	cmp	DWORD PTR shdr32$[rsp+4], 8
	je	SHORT $LN23@elf_write_

; 851  :             fileoffset += shdr32.sh_size;
; 852  :             fileoffset = (fileoffset + 0xF) & ~0xF;

	mov	eax, DWORD PTR shdr32$[rsp+20]
	lea	ebx, DWORD PTR [rax+rbx+15]
	and	ebx, -16				; fffffff0H
$LN23@elf_write_:
	mov	rsi, QWORD PTR [rsi+112]
	test	rsi, rsi
	jne	$LL24@elf_write_
$LN22@elf_write_:

; 853  :         }
; 854  : 
; 855  :         DebugMsg(("elf_write_section_table32(%s): ofs=%X size=%X numrelocs=%u\n", curr->sym.name, shdr32.sh_offset, shdr32.sh_size, curr->e.seginfo->num_relocs));
; 856  :     }
; 857  : 
; 858  :     /* set size and contents of .symtab and .strtab sections */
; 859  :     set_symtab_values( em );

	mov	rcx, r12
	call	set_symtab_values
	mov	rsi, r14
	lea	r15, OFFSET FLAT:internal_segparms+8
	npad	1
$LL11@elf_write_:

; 860  : 
; 861  :     /* write headers of internal sections */
; 862  :     for ( i = 0; i < NUM_INTSEGS; i++ ) {
; 863  :         shdr32.sh_name = p - (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;

	mov	eax, ebp

; 864  :         p += strlen( (char *)p ) + 1;

	mov	rdi, rbp
	mov	rcx, -1
	sub	eax, DWORD PTR [r12+32]
	mov	DWORD PTR shdr32$[rsp], eax
	xor	eax, eax
	repne scasb

; 865  :         shdr32.sh_type = internal_segparms[i].type;
; 866  :         shdr32.sh_flags = 0;

	mov	DWORD PTR shdr32$[rsp+8], r14d

; 867  :         shdr32.sh_offset = fileoffset; /* start of section in file */

	mov	DWORD PTR shdr32$[rsp+16], ebx
	not	rcx
	add	rbp, rcx
	mov	rcx, rsi
	add	rcx, rcx

; 868  :         em->internal_segs[i].fileoffset = fileoffset;
; 869  :         shdr32.sh_size = em->internal_segs[i].size;
; 870  :         /* section .symtab is special */
; 871  :         if ( i == SYMTAB_IDX ) {

	cmp	rsi, 1
	mov	eax, DWORD PTR [r15+rcx*8]
	mov	DWORD PTR [r12+rcx*8+28], ebx
	mov	DWORD PTR shdr32$[rsp+4], eax
	mov	eax, DWORD PTR [r12+rcx*8+24]
	mov	DWORD PTR shdr32$[rsp+20], eax
	jne	SHORT $LN8@elf_write_

; 872  :             shdr32.sh_link = 1 + modinfo->g.num_segs + STRTAB_IDX;

	mov	eax, DWORD PTR [r13+8]

; 873  :             shdr32.sh_info = em->start_globals;
; 874  :             shdr32.sh_addralign = 4;

	mov	DWORD PTR shdr32$[rsp+32], 4

; 875  :             shdr32.sh_entsize = sizeof( Elf32_Sym );

	mov	DWORD PTR shdr32$[rsp+36], 16
	add	eax, 3
	mov	DWORD PTR shdr32$[rsp+24], eax
	mov	eax, DWORD PTR [r12+4]
	mov	DWORD PTR shdr32$[rsp+28], eax

; 876  :         } else {

	jmp	SHORT $LN7@elf_write_
$LN8@elf_write_:

; 877  :             shdr32.sh_link = 0;

	mov	DWORD PTR shdr32$[rsp+24], r14d

; 878  :             shdr32.sh_info = 0;

	mov	DWORD PTR shdr32$[rsp+28], r14d

; 879  :             shdr32.sh_addralign = 1;

	mov	DWORD PTR shdr32$[rsp+32], 1

; 880  :             shdr32.sh_entsize = 0;

	mov	DWORD PTR shdr32$[rsp+36], r14d
$LN7@elf_write_:

; 881  :         }
; 882  :         if ( fwrite( &shdr32, 1, sizeof( shdr32 ), CurrFile[OBJ] ) != sizeof( shdr32 ) )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	edx, 1
	lea	rcx, QWORD PTR shdr32$[rsp]
	lea	r8d, QWORD PTR [rdx+39]
	call	fwrite
	cmp	rax, 40					; 00000028H
	je	SHORT $LN6@elf_write_

; 883  :             WriteError();

	call	WriteError
$LN6@elf_write_:

; 884  : 
; 885  :         fileoffset += shdr32.sh_size;
; 886  :         fileoffset = (fileoffset + 0xF) & ~0xF;

	mov	eax, DWORD PTR shdr32$[rsp+20]
	inc	rsi
	lea	ebx, DWORD PTR [rax+rbx+15]
	and	ebx, -16				; fffffff0H
	cmp	rsi, 3
	jl	$LL11@elf_write_

; 887  :         DebugMsg(("elf_write_section_table32(%s): ofs=%X size=%X\n", internal_segparms[i].name, shdr32.sh_offset, shdr32.sh_size));
; 888  :     }
; 889  : 
; 890  :     /* write headers of reloc sections */
; 891  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rsi, QWORD PTR SymTables+32
	mov	r15, QWORD PTR [rsp+88]
	test	rsi, rsi
	je	$LN46@elf_write_
	npad	7
$LL5@elf_write_:

; 892  :         if ( curr->e.seginfo->FixupList.head == NULL )

	mov	rax, QWORD PTR [rsi+104]
	cmp	QWORD PTR [rax+40], r14
	je	$LN4@elf_write_

; 893  :             continue;
; 894  : 
; 895  :         memset( &shdr32, 0, sizeof( shdr32 ) );

	xor	eax, eax

; 896  : 
; 897  :         shdr32.sh_name = p - (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;
; 898  :         p += strlen( (char *)p ) + 1;

	mov	rdi, rbp
	mov	rcx, -1
	mov	QWORD PTR shdr32$[rsp], rax
	mov	QWORD PTR shdr32$[rsp+8], rax
	mov	QWORD PTR shdr32$[rsp+16], rax
	mov	QWORD PTR shdr32$[rsp+24], rax
	mov	QWORD PTR shdr32$[rsp+32], rax
	mov	eax, ebp
	sub	eax, DWORD PTR [r12+32]
	mov	DWORD PTR shdr32$[rsp], eax
	xor	eax, eax
	repne scasb

; 899  :         shdr32.sh_type = SHT_REL;

	mov	DWORD PTR shdr32$[rsp+4], 9

; 900  :         shdr32.sh_flags = 0;

	mov	DWORD PTR shdr32$[rsp+8], r14d

; 901  :         shdr32.sh_addr = 0;

	mov	DWORD PTR shdr32$[rsp+12], r14d

; 902  :         shdr32.sh_offset = fileoffset; /* start of section in file */

	mov	DWORD PTR shdr32$[rsp+16], ebx

; 903  :         /* save the file offset in the slot reserved for ELF relocs */
; 904  :         curr->e.seginfo->reloc_offset = fileoffset;

	mov	rax, QWORD PTR [rsi+104]
	mov	DWORD PTR [rax+12], ebx

; 905  :         /* size of section in file */
; 906  :         shdr32.sh_size = curr->e.seginfo->num_relocs * sizeof( Elf32_Rel );

	mov	rax, QWORD PTR [rsi+104]
	not	rcx
	add	rbp, rcx
	mov	ecx, DWORD PTR [rax+64]

; 907  :         shdr32.sh_link = 1 + modinfo->g.num_segs + SYMTAB_IDX;

	mov	eax, DWORD PTR [r13+8]
	shl	ecx, 3
	add	eax, 2
	mov	DWORD PTR shdr32$[rsp+24], eax
	mov	DWORD PTR shdr32$[rsp+20], ecx

; 908  :         /* set info to the src section index */
; 909  :         shdr32.sh_info = GetSegIdx( curr->sym.segment );

	mov	rcx, QWORD PTR [rsi+32]
	call	GetSegIdx

; 910  :         shdr32.sh_addralign = 4;
; 911  :         shdr32.sh_entsize = sizeof( Elf32_Rel );
; 912  : 
; 913  :         if ( fwrite( &shdr32, 1, sizeof( shdr32 ), CurrFile[OBJ] ) != sizeof( shdr32 ) )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	edx, 1
	lea	r8d, QWORD PTR [rdx+39]
	lea	rcx, QWORD PTR shdr32$[rsp]
	mov	DWORD PTR shdr32$[rsp+32], 4
	mov	DWORD PTR shdr32$[rsp+28], eax
	mov	DWORD PTR shdr32$[rsp+36], 8
	call	fwrite
	cmp	rax, 40					; 00000028H
	je	SHORT $LN1@elf_write_

; 914  :             WriteError();

	call	WriteError
$LN1@elf_write_:

; 915  : 
; 916  :         fileoffset += shdr32.sh_size;
; 917  :         fileoffset = (fileoffset + 0xF) & ~0xF;

	mov	eax, DWORD PTR shdr32$[rsp+20]
	lea	ebx, DWORD PTR [rax+rbx+15]
	and	ebx, -16				; fffffff0H
$LN4@elf_write_:
	mov	rsi, QWORD PTR [rsi+112]
	test	rsi, rsi
	jne	$LL5@elf_write_
$LN46@elf_write_:
	mov	r14, QWORD PTR [rsp+96]
	mov	r13, QWORD PTR [rsp+104]
	mov	r12, QWORD PTR [rsp+112]
	mov	rdi, QWORD PTR [rsp+152]
	mov	rsi, QWORD PTR [rsp+144]
	mov	rbp, QWORD PTR [rsp+136]
	mov	rbx, QWORD PTR [rsp+128]

; 918  :         DebugMsg(("elf_write_section_table32(%s): relocs, ofs=%X size=%X\n", curr->sym.name, shdr32.sh_offset, shdr32.sh_size));
; 919  : 
; 920  :     }
; 921  :     DebugMsg(("elf_write_section_table32: exit, final fileofs=%X\n", fileoffset ));
; 922  :     return( NOT_ERROR );

	xor	eax, eax

; 923  : }

	add	rsp, 120				; 00000078H
	ret	0
elf_write_section_table32 ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$elf_write_section_table64 DD 081601H
	DD	0fd416H
	DD	010c412H
	DD	012340eH
	DD	011010aH
xdata	ENDS
pdata	SEGMENT
$pdata$elf_write_section_table64 DD @imagerel(elf_write_section_table64#)
	DD	@imagerel(elf_write_section_table64#+32)
	DD	@imagerel($unwind$elf_write_section_table64#)
pdata	ENDS
xdata	SEGMENT
$chain$7$elf_write_section_table64 DD 0a8b21H
	DD	0ee48bH
	DD	0157486H
	DD	0146477H
	DD	013546aH
	DD	0df404H
	DD	@imagerel(elf_write_section_table64#)
	DD	@imagerel(elf_write_section_table64#+32)
	DD	@imagerel($unwind$elf_write_section_table64#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$elf_write_section_table64 DD @imagerel(elf_write_section_table64#+32)
	DD	@imagerel(elf_write_section_table64#+832)
	DD	@imagerel($chain$7$elf_write_section_table64#)
pdata	ENDS
xdata	SEGMENT
$chain$8$elf_write_section_table64 DD 080021H
	DD	0ee400H
	DD	0157400H
	DD	0146400H
	DD	0135400H
	DD	@imagerel(elf_write_section_table64#)
	DD	@imagerel(elf_write_section_table64#+32)
	DD	@imagerel($unwind$elf_write_section_table64#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$elf_write_section_table64 DD @imagerel(elf_write_section_table64#+832)
	DD	@imagerel(elf_write_section_table64#+1134)
	DD	@imagerel($chain$8$elf_write_section_table64#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
shdr64$ = 32
modinfo$ = 144
em$ = 152
fileoffset$ = 160
elf_write_section_table64 PROC NEAR

; 931  : {

	mov	rax, rsp
	sub	rsp, 136				; 00000088H
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax-8], r12
	mov	QWORD PTR [rax-16], r13

; 932  :     int         i;
; 933  :     struct dsym *curr;
; 934  :     uint_8      *p;
; 935  :     //uint_32     fileoffset;
; 936  :     Elf64_Shdr  shdr64;
; 937  : 
; 938  :     DebugMsg(("elf_write_section_table64( fileofs=%X ): enter\n", fileoffset ));
; 939  : 
; 940  :     //fileoffset = sizeof(Elf64_Ehdr) + ehdr->e_shnum * ehdr->e_shentsize;
; 941  :     fileoffset = (fileoffset + 0xF) & ~0xF;

	lea	ebx, DWORD PTR [r8+15]
	mov	r13, rcx

; 942  : 
; 943  :     /* set contents and size of internal .shstrtab section */
; 944  :     set_shstrtab_values( em );

	mov	rcx, rdx
	mov	QWORD PTR [rax-32], r15
	mov	r12, rdx
	and	ebx, -16				; fffffff0H
	call	set_shstrtab_values

; 945  : 
; 946  :     /* write the NULL entry */
; 947  :     memset( &shdr64, 0, sizeof( shdr64) );
; 948  :     if ( fwrite( &shdr64, 1, sizeof(shdr64), CurrFile[OBJ] ) != sizeof(shdr64) ) /* write the empty NULL entry */

	mov	r9, QWORD PTR ModuleInfo+104
	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+64]
	mov	QWORD PTR shdr64$[rsp], rdx
	mov	QWORD PTR shdr64$[rsp+8], rdx
	mov	QWORD PTR shdr64$[rsp+16], rdx
	mov	QWORD PTR shdr64$[rsp+24], rdx
	mov	QWORD PTR shdr64$[rsp+32], rdx
	mov	QWORD PTR shdr64$[rsp+40], rdx
	mov	QWORD PTR shdr64$[rsp+48], rdx
	mov	QWORD PTR shdr64$[rsp+56], rdx
	mov	r15d, 1
	lea	rcx, QWORD PTR shdr64$[rsp]
	mov	rdx, r15
	call	fwrite
	cmp	rax, 64					; 00000040H
	je	SHORT $LN25@elf_write_@2

; 949  :         WriteError();

	call	WriteError
$LN25@elf_write_@2:
	mov	QWORD PTR [rsp+152], rbp

; 950  : 
; 951  :     /* use p to scan strings (=section names) of .shstrtab */
; 952  :     p = (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;
; 953  :     p++; /* skip 'name' of NULL entry */

	mov	rbp, QWORD PTR [r12+32]
	mov	QWORD PTR [rsp+160], rsi

; 954  : 
; 955  :     /* write the section headers defined in the module */
; 956  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rsi, QWORD PTR SymTables+32
	mov	QWORD PTR [rsp+168], rdi
	mov	QWORD PTR [rsp+112], r14
	inc	rbp
	xor	r14d, r14d
	test	rsi, rsi
	je	$LN22@elf_write_@2
	npad	6
$LL24@elf_write_@2:

; 957  : 
; 958  :         memset( &shdr64, 0, sizeof(shdr64) );

	xor	eax, eax

; 959  : 
; 960  :         shdr64.sh_name = p - (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;
; 961  :         p += strlen( (char *)p ) + 1;

	mov	rdi, rbp
	mov	rcx, -1
	mov	QWORD PTR shdr64$[rsp], rax
	mov	QWORD PTR shdr64$[rsp+8], rax
	mov	QWORD PTR shdr64$[rsp+16], rax
	mov	QWORD PTR shdr64$[rsp+24], rax
	mov	QWORD PTR shdr64$[rsp+32], rax
	mov	QWORD PTR shdr64$[rsp+40], rax
	mov	QWORD PTR shdr64$[rsp+48], rax
	mov	QWORD PTR shdr64$[rsp+56], rax
	mov	eax, ebp
	sub	eax, DWORD PTR [r12+32]
	mov	DWORD PTR shdr64$[rsp], eax
	xor	eax, eax
	repne scasb
	not	rcx
	add	rbp, rcx

; 962  :         if ( curr->e.seginfo->info == TRUE ) { /* v2.07:added; v2.12: highest priority */

	mov	rcx, QWORD PTR [rsi+104]
	test	BYTE PTR [rcx+107], 2
	je	SHORT $LN21@elf_write_@2

; 963  :             shdr64.sh_type = SHT_NOTE;

	mov	DWORD PTR shdr64$[rsp+4], 7

; 964  :             shdr64.sh_flags = 0;

	mov	QWORD PTR shdr64$[rsp+8], r14

; 965  :         } else {

	jmp	SHORT $LN14@elf_write_@2
$LN21@elf_write_@2:

; 966  :             shdr64.sh_type = ( curr->e.seginfo->segtype != SEGTYPE_BSS ? SHT_PROGBITS : SHT_NOBITS );

	cmp	DWORD PTR [rcx+72], 3
	mov	eax, 8
	cmovne	eax, r15d
	mov	DWORD PTR shdr64$[rsp+4], eax

; 967  :             if ( curr->e.seginfo->segtype == SEGTYPE_CODE ) {

	mov	rax, QWORD PTR [rsi+104]
	cmp	DWORD PTR [rax+72], r15d
	jne	SHORT $LN19@elf_write_@2

; 968  :                 shdr64.sh_flags = SHF_EXECINSTR | SHF_ALLOC;

	mov	QWORD PTR shdr64$[rsp+8], 6
	jmp	SHORT $LN14@elf_write_@2
$LN19@elf_write_@2:

; 969  :             } else if ( curr->e.seginfo->readonly == TRUE ) {

	test	BYTE PTR [rax+107], r15b
	je	SHORT $LN17@elf_write_@2

; 970  :                 shdr64.sh_flags = SHF_ALLOC;

	mov	QWORD PTR shdr64$[rsp+8], 2
	jmp	SHORT $LN14@elf_write_@2
$LN17@elf_write_@2:

; 971  :             } else if ( curr->e.seginfo->clsym && strcmp( curr->e.seginfo->clsym->name, "CONST" ) == 0 ) {

	mov	rax, QWORD PTR [rax+80]
	test	rax, rax
	je	SHORT $LN15@elf_write_@2
	mov	rax, QWORD PTR [rax+8]
	lea	rdi, OFFSET FLAT:$SG6035
	sub	rdi, rax
$LL44@elf_write_@2:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+rdi]
	sub	edx, ecx
	jne	SHORT $LN45@elf_write_@2
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL44@elf_write_@2
$LN45@elf_write_@2:
	test	edx, edx
	jne	SHORT $LN15@elf_write_@2

; 972  :                 shdr64.sh_flags = SHF_ALLOC; /* v2.07: added */

	mov	QWORD PTR shdr64$[rsp+8], 2

; 973  :             } else {

	jmp	SHORT $LN14@elf_write_@2
$LN15@elf_write_@2:

; 974  :                 shdr64.sh_flags = SHF_WRITE | SHF_ALLOC;

	mov	QWORD PTR shdr64$[rsp+8], 3
$LN14@elf_write_@2:

; 975  :             }
; 976  :         }
; 977  : #if 0
; 978  :         /* todo: translate values in field <characteristics> to
; 979  :          * elf section flags.
; 980  :          */
; 981  :         if ( curr->e.seginfo->characteristics == ??? ) {
; 982  :         }
; 983  : #endif
; 984  :         shdr64.sh_addr = 0;

	mov	QWORD PTR shdr64$[rsp+16], r14

; 985  :         /* v2.12: the sh_offset field holds the file position, even for SHT_NOBITS */
; 986  :         //if ( shdr64.sh_type != SHT_NOBITS ) {
; 987  :             shdr64.sh_offset = fileoffset; /* start of section in file */

	mov	eax, ebx
	mov	QWORD PTR shdr64$[rsp+24], rax

; 988  :             curr->e.seginfo->fileoffset = fileoffset; /* save the offset in the segment */

	mov	rax, QWORD PTR [rsi+104]
	mov	DWORD PTR [rax+56], ebx

; 989  :         //}
; 990  :         /* v2.07: set size for all sections, including .bss */
; 991  :         shdr64.sh_size = curr->sym.max_offset;

	movsxd	rax, DWORD PTR [rsi+64]

; 992  :         shdr64.sh_link = 0;

	mov	DWORD PTR shdr64$[rsp+40], r14d
	mov	QWORD PTR shdr64$[rsp+32], rax

; 993  :         shdr64.sh_info = 0;

	mov	DWORD PTR shdr64$[rsp+44], r14d

; 994  :         shdr64.sh_addralign = Get_Alignment( curr );

	mov	rax, QWORD PTR [rsi+104]
	cmp	BYTE PTR [rax+106], 255			; 000000ffH
	jne	SHORT $LN28@elf_write_@2
	mov	eax, r14d
	jmp	SHORT $LN29@elf_write_@2
$LN28@elf_write_@2:
	movzx	ecx, BYTE PTR [rax+106]
	mov	eax, r15d
	shl	eax, cl
$LN29@elf_write_@2:

; 995  :         shdr64.sh_entsize = 0;
; 996  : 
; 997  :         if ( fwrite( &shdr64, 1, sizeof(shdr64), CurrFile[OBJ] ) != sizeof(shdr64) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	rcx, QWORD PTR shdr64$[rsp]
	mov	r8d, 64					; 00000040H
	mov	rdx, r15
	mov	QWORD PTR shdr64$[rsp+48], rax
	mov	QWORD PTR shdr64$[rsp+56], r14
	call	fwrite
	cmp	rax, 64					; 00000040H
	je	SHORT $LN13@elf_write_@2

; 998  :             WriteError();

	call	WriteError
$LN13@elf_write_@2:

; 999  :         curr->e.seginfo->num_relocs = get_relocation_count( curr );

	mov	rdx, QWORD PTR [rsi+104]
	mov	ecx, r14d
	mov	rax, QWORD PTR [rdx+40]
	test	rax, rax
	je	SHORT $LN31@elf_write_@2
	npad	9
$LL33@elf_write_@2:
	mov	rax, QWORD PTR [rax+8]
	inc	ecx
	test	rax, rax
	jne	SHORT $LL33@elf_write_@2
$LN31@elf_write_@2:
	mov	DWORD PTR [rdx+64], ecx

; 1000 : 
; 1001 :         /* v2.12: don't adjust fileoffset for SHT_NOBITS sections */
; 1002 :         if ( shdr64.sh_type != SHT_NOBITS ) {

	cmp	DWORD PTR shdr64$[rsp+4], 8
	je	SHORT $LN23@elf_write_@2

; 1003 :             fileoffset += shdr64.sh_size;
; 1004 :             fileoffset = (fileoffset + 0xF) & ~0xF;

	mov	eax, DWORD PTR shdr64$[rsp+32]
	lea	ebx, DWORD PTR [rax+rbx+15]
	and	ebx, -16				; fffffff0H
$LN23@elf_write_@2:
	mov	rsi, QWORD PTR [rsi+112]
	test	rsi, rsi
	jne	$LL24@elf_write_@2
$LN22@elf_write_@2:

; 1005 :         }
; 1006 : 
; 1007 :         DebugMsg(("elf_write_section_table64(%s): ofs=%" I64_SPEC "X size=%" I64_SPEC "X numrelocs=%u\n", curr->sym.name, shdr64.sh_offset, shdr64.sh_size, curr->e.seginfo->num_relocs));
; 1008 :     }
; 1009 : 
; 1010 :     /* set size and contents of .symtab and .strtab sections */
; 1011 :     set_symtab_values( em );

	mov	rcx, r12
	call	set_symtab_values
	mov	rsi, r14
	lea	r15, OFFSET FLAT:internal_segparms+8
	npad	1
$LL11@elf_write_@2:

; 1012 : 
; 1013 :     /* write headers of internal sections */
; 1014 :     for ( i = 0; i < NUM_INTSEGS; i++ ) {
; 1015 : 
; 1016 :         shdr64.sh_name = p - (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;

	mov	eax, ebp

; 1017 :         p += strlen( (char *)p ) + 1;

	mov	rdi, rbp
	mov	rcx, -1
	sub	eax, DWORD PTR [r12+32]
	mov	DWORD PTR shdr64$[rsp], eax
	xor	eax, eax
	repne scasb

; 1018 :         shdr64.sh_type = internal_segparms[i].type;
; 1019 :         shdr64.sh_flags = 0;

	mov	QWORD PTR shdr64$[rsp+8], r14
	not	rcx
	add	rbp, rcx
	mov	rcx, rsi
	add	rcx, rcx

; 1020 :         shdr64.sh_offset = fileoffset; /* start of section in file */
; 1021 :         em->internal_segs[i].fileoffset = fileoffset;
; 1022 :         shdr64.sh_size = em->internal_segs[i].size;
; 1023 :         /* section .symtab is special */
; 1024 :         if ( i == SYMTAB_IDX ) {

	cmp	rsi, 1
	mov	eax, DWORD PTR [r15+rcx*8]
	mov	DWORD PTR [r12+rcx*8+28], ebx
	mov	DWORD PTR shdr64$[rsp+4], eax
	mov	eax, ebx
	mov	QWORD PTR shdr64$[rsp+24], rax
	mov	eax, DWORD PTR [r12+rcx*8+24]
	mov	QWORD PTR shdr64$[rsp+32], rax
	jne	SHORT $LN8@elf_write_@2

; 1025 :             shdr64.sh_link = 1 + modinfo->g.num_segs + STRTAB_IDX;

	mov	eax, DWORD PTR [r13+8]

; 1026 :             shdr64.sh_info = em->start_globals;
; 1027 :             shdr64.sh_addralign = 4;

	mov	QWORD PTR shdr64$[rsp+48], 4

; 1028 :             shdr64.sh_entsize = sizeof( Elf64_Sym );

	mov	QWORD PTR shdr64$[rsp+56], 24
	add	eax, 3
	mov	DWORD PTR shdr64$[rsp+40], eax
	mov	eax, DWORD PTR [r12+4]
	mov	DWORD PTR shdr64$[rsp+44], eax

; 1029 :         } else {

	jmp	SHORT $LN7@elf_write_@2
$LN8@elf_write_@2:

; 1030 :             shdr64.sh_link = 0;

	mov	DWORD PTR shdr64$[rsp+40], r14d

; 1031 :             shdr64.sh_info = 0;

	mov	DWORD PTR shdr64$[rsp+44], r14d

; 1032 :             shdr64.sh_addralign = 1;

	mov	QWORD PTR shdr64$[rsp+48], 1

; 1033 :             shdr64.sh_entsize = 0;

	mov	QWORD PTR shdr64$[rsp+56], r14
$LN7@elf_write_@2:

; 1034 :         }
; 1035 :         if ( fwrite( &shdr64, 1, sizeof( shdr64 ), CurrFile[OBJ] ) != sizeof( shdr64 ) )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	edx, 1
	lea	rcx, QWORD PTR shdr64$[rsp]
	lea	r8d, QWORD PTR [rdx+63]
	call	fwrite
	cmp	rax, 64					; 00000040H
	je	SHORT $LN6@elf_write_@2

; 1036 :             WriteError();

	call	WriteError
$LN6@elf_write_@2:

; 1037 : 
; 1038 :         fileoffset += shdr64.sh_size;
; 1039 :         fileoffset = (fileoffset + 0xF) & ~0xF;

	mov	eax, DWORD PTR shdr64$[rsp+32]
	inc	rsi
	lea	ebx, DWORD PTR [rax+rbx+15]
	and	ebx, -16				; fffffff0H
	cmp	rsi, 3
	jl	$LL11@elf_write_@2

; 1040 :         DebugMsg(("elf_write_section_table64(%s): ofs=%" I64_SPEC "X size=%" I64_SPEC "X\n", internal_segparms[i].name, shdr64.sh_offset, shdr64.sh_size));
; 1041 :     }
; 1042 : 
; 1043 :     /* write headers of reloc sections */
; 1044 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rsi, QWORD PTR SymTables+32
	mov	r15, QWORD PTR [rsp+104]
	test	rsi, rsi
	je	$LN46@elf_write_@2
$LL5@elf_write_@2:

; 1045 :         if ( curr->e.seginfo->FixupList.head == NULL )

	mov	rax, QWORD PTR [rsi+104]
	cmp	QWORD PTR [rax+40], r14
	je	$LN4@elf_write_@2

; 1046 :             continue;
; 1047 : 
; 1048 :         memset( &shdr64, 0, sizeof(shdr64) );

	xor	eax, eax

; 1049 : 
; 1050 :         shdr64.sh_name = p - (uint_8 *)em->internal_segs[SHSTRTAB_IDX].data;
; 1051 :         p += strlen( (char *)p ) + 1;

	mov	rdi, rbp
	mov	rcx, -1
	mov	QWORD PTR shdr64$[rsp], rax
	mov	QWORD PTR shdr64$[rsp+8], rax
	mov	QWORD PTR shdr64$[rsp+16], rax
	mov	QWORD PTR shdr64$[rsp+24], rax
	mov	QWORD PTR shdr64$[rsp+32], rax
	mov	QWORD PTR shdr64$[rsp+40], rax
	mov	QWORD PTR shdr64$[rsp+48], rax
	mov	QWORD PTR shdr64$[rsp+56], rax
	mov	eax, ebp
	sub	eax, DWORD PTR [r12+32]
	mov	DWORD PTR shdr64$[rsp], eax
	xor	eax, eax
	repne scasb

; 1052 :         shdr64.sh_type = SHT_RELA; /* v2.05: changed REL to RELA */

	mov	DWORD PTR shdr64$[rsp+4], 4

; 1053 :         shdr64.sh_flags = 0;

	mov	QWORD PTR shdr64$[rsp+8], r14

; 1054 :         shdr64.sh_addr = 0;

	mov	QWORD PTR shdr64$[rsp+16], r14
	not	rcx

; 1055 :         shdr64.sh_offset = fileoffset; /* start of section in file */

	mov	eax, ebx
	mov	QWORD PTR shdr64$[rsp+24], rax

; 1056 :         /* save the file offset in the slot reserved for ELF relocs */
; 1057 :         curr->e.seginfo->reloc_offset = fileoffset;

	mov	rax, QWORD PTR [rsi+104]
	add	rbp, rcx
	mov	DWORD PTR [rax+12], ebx

; 1058 :         /* size of section in file */
; 1059 :         shdr64.sh_size = curr->e.seginfo->num_relocs * sizeof( Elf64_Rela );

	mov	rax, QWORD PTR [rsi+104]
	mov	ecx, DWORD PTR [rax+64]
	lea	rax, QWORD PTR [rcx+rcx*2]
	shl	rax, 3
	mov	QWORD PTR shdr64$[rsp+32], rax

; 1060 :         shdr64.sh_link = 1 + modinfo->g.num_segs + SYMTAB_IDX;

	mov	eax, DWORD PTR [r13+8]
	add	eax, 2
	mov	DWORD PTR shdr64$[rsp+40], eax

; 1061 :         /* set info to the src section index */
; 1062 :         shdr64.sh_info = GetSegIdx( curr->sym.segment );

	mov	rcx, QWORD PTR [rsi+32]
	call	GetSegIdx

; 1063 :         shdr64.sh_addralign = 4;
; 1064 :         shdr64.sh_entsize = sizeof( Elf64_Rela );
; 1065 : 
; 1066 :         if ( fwrite( &shdr64, 1, sizeof( shdr64 ), CurrFile[OBJ] ) != sizeof( shdr64 ) )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	edx, 1
	lea	r8d, QWORD PTR [rdx+63]
	lea	rcx, QWORD PTR shdr64$[rsp]
	mov	QWORD PTR shdr64$[rsp+48], 4
	mov	DWORD PTR shdr64$[rsp+44], eax
	mov	QWORD PTR shdr64$[rsp+56], 24
	call	fwrite
	cmp	rax, 64					; 00000040H
	je	SHORT $LN1@elf_write_@2

; 1067 :             WriteError();

	call	WriteError
$LN1@elf_write_@2:

; 1068 : 
; 1069 :         fileoffset += shdr64.sh_size;
; 1070 :         fileoffset = (fileoffset + 0xF) & ~0xF;

	mov	eax, DWORD PTR shdr64$[rsp+32]
	lea	ebx, DWORD PTR [rax+rbx+15]
	and	ebx, -16				; fffffff0H
$LN4@elf_write_@2:
	mov	rsi, QWORD PTR [rsi+112]
	test	rsi, rsi
	jne	$LL5@elf_write_@2
$LN46@elf_write_@2:
	mov	r14, QWORD PTR [rsp+112]
	mov	r13, QWORD PTR [rsp+120]
	mov	r12, QWORD PTR [rsp+128]
	mov	rdi, QWORD PTR [rsp+168]
	mov	rsi, QWORD PTR [rsp+160]
	mov	rbp, QWORD PTR [rsp+152]
	mov	rbx, QWORD PTR [rsp+144]

; 1071 :         DebugMsg(("elf_write_section_table64(%s): relocs, ofs=%" I64_SPEC "X size=%" I64_SPEC "X\n", curr->sym.name, shdr64.sh_offset, shdr64.sh_size));
; 1072 :     }
; 1073 :     DebugMsg(("elf_write_section_table64: exit, final fileofs=%X\n", fileoffset ));
; 1074 :     return( NOT_ERROR );

	xor	eax, eax

; 1075 : }

	add	rsp, 136				; 00000088H
	ret	0
elf_write_section_table64 ENDP
_TEXT	ENDS
EXTRN	EmitErr:NEAR
EXTRN	__ImageBase:BYTE
xdata	SEGMENT
$unwind$write_relocs32 DD 071b01H
	DD	0c641bH
	DD	0b5412H
	DD	0a340dH
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$write_relocs32 DD @imagerel(write_relocs32#)
	DD	@imagerel(write_relocs32#+42)
	DD	@imagerel($unwind$write_relocs32#)
pdata	ENDS
xdata	SEGMENT
$chain$4$write_relocs32 DD 041121H
	DD	0d7411H
	DD	08c405H
	DD	@imagerel(write_relocs32#)
	DD	@imagerel(write_relocs32#+42)
	DD	@imagerel($unwind$write_relocs32#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$write_relocs32 DD @imagerel(write_relocs32#+42)
	DD	@imagerel(write_relocs32#+297)
	DD	@imagerel($chain$4$write_relocs32#)
pdata	ENDS
xdata	SEGMENT
$chain$5$write_relocs32 DD 021H
	DD	@imagerel(write_relocs32#)
	DD	@imagerel(write_relocs32#+42)
	DD	@imagerel($unwind$write_relocs32#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$write_relocs32 DD @imagerel(write_relocs32#+297)
	DD	@imagerel(write_relocs32#+320)
	DD	@imagerel($chain$5$write_relocs32#)
pdata	ENDS
xdata	SEGMENT
$chain$6$write_relocs32 DD 040021H
	DD	08c400H
	DD	0d7400H
	DD	@imagerel(write_relocs32#)
	DD	@imagerel(write_relocs32#+42)
	DD	@imagerel($unwind$write_relocs32#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$write_relocs32 DD @imagerel(write_relocs32#+320)
	DD	@imagerel(write_relocs32#+368)
	DD	@imagerel($chain$6$write_relocs32#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
reloc32$ = 48
em$ = 80
curr$ = 88
write_relocs32 PROC NEAR

; 1082 : {

	sub	rsp, 72					; 00000048H

; 1083 :     uint_8 elftype;
; 1084 :     struct fixup *fixup;
; 1085 :     Elf32_Rel reloc32;
; 1086 : 
; 1087 :     DebugMsg(("write_relocs32: enter\n"));
; 1088 :     for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rax, QWORD PTR [rdx+104]
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+88], rbp
	mov	rbx, QWORD PTR [rax+40]
	mov	QWORD PTR [rsp+96], rsi
	mov	rbp, rcx
	test	rbx, rbx
	mov	rsi, rdx
	je	$LN14@write_relo
	mov	QWORD PTR [rsp+64], r12
	lea	r12, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [rsp+104], rdi
	npad	5
$LL16@write_relo:

; 1089 :         reloc32.r_offset = fixup->locofs;

	mov	eax, DWORD PTR [rbx+20]
	mov	DWORD PTR reloc32$[rsp], eax

; 1090 :         switch ( fixup->type ) {

	mov	r10d, DWORD PTR [rbx+24]
	lea	eax, DWORD PTR [r10-1]
	cmp	eax, 11
	ja	SHORT $LN4@write_relo
	cdqe
	mov	ecx, DWORD PTR $LN21@write_relo[r12+rax*4]
	add	rcx, r12
	jmp	rcx
$LN11@write_relo:

; 1091 :         case FIX_OFF32:         elftype = R_386_32;             break;

	mov	dil, 1
	jmp	SHORT $LN2@write_relo
$LN10@write_relo:

; 1092 :         case FIX_RELOFF32:      elftype = R_386_PC32;           break;

	mov	dil, 2
	jmp	SHORT $LN2@write_relo
$LN9@write_relo:

; 1093 :         //case FIX_???:         elftype = R_386_GOT32;          break;
; 1094 :         //case FIX_???:         elftype = R_386_PLT32;          break;
; 1095 :         //case FIX_???:         elftype = R_386_COPY;           break;
; 1096 :         //case FIX_???:         elftype = R_386_GLOB_DAT;       break;
; 1097 :         //case FIX_???:         elftype = R_386_JMP_SLOT;       break;
; 1098 :         case FIX_OFF32_IMGREL:  elftype = R_386_RELATIVE;       break;

	mov	dil, 8
	jmp	SHORT $LN2@write_relo
$LN8@write_relo:

; 1099 :         //case FIX_???:         elftype = R_386_GOTOFF;         break;
; 1100 :         //case FIX_???:         elftype = R_386_GOTPC;          break;
; 1101 : #if GNURELOCS
; 1102 :         case FIX_OFF16:    em->extused = TRUE; elftype = R_386_16;   break;

	mov	BYTE PTR [rbp+16], 1
	mov	dil, 20
	jmp	SHORT $LN2@write_relo
$LN7@write_relo:

; 1103 :         case FIX_RELOFF16: em->extused = TRUE; elftype = R_386_PC16; break;

	mov	BYTE PTR [rbp+16], 1
	mov	dil, 21
	jmp	SHORT $LN2@write_relo
$LN6@write_relo:

; 1104 :         case FIX_OFF8:     em->extused = TRUE; elftype = R_386_8;    break;

	mov	BYTE PTR [rbp+16], 1
	mov	dil, 22
	jmp	SHORT $LN2@write_relo
$LN5@write_relo:

; 1105 :         case FIX_RELOFF8:  em->extused = TRUE; elftype = R_386_PC8;  break;

	mov	BYTE PTR [rbp+16], 1
	mov	dil, 23
	jmp	SHORT $LN2@write_relo
$LN4@write_relo:

; 1106 : #endif
; 1107 :         default:
; 1108 :             DebugMsg(("write_relocs32(): unhandled reloc loc=%X type=%u idx=%u sym=%s\n",
; 1109 :                       fixup->locofs, fixup->type, fixup->sym->ext_idx, fixup->sym->name));
; 1110 :             elftype = R_386_NONE;

	xor	dil, dil

; 1111 :             if ( fixup->type < FIX_LAST ) {

	cmp	r10d, 14
	jge	SHORT $LN3@write_relo

; 1112 :                 EmitErr( INVALID_FIXUP_TYPE, ModuleInfo.fmtopt->formatname, fixup->type, curr->sym.name, fixup->locofs );

	mov	rdx, QWORD PTR ModuleInfo+344
	mov	eax, DWORD PTR [rbx+20]
	mov	r9, QWORD PTR [rsi+8]
	add	rdx, 10
	mov	r8d, r10d
	mov	ecx, 198				; 000000c6H
	mov	DWORD PTR [rsp+32], eax
	call	EmitErr

; 1113 :             } else

	jmp	SHORT $LN2@write_relo
$LN3@write_relo:

; 1114 :                 EmitErr( UNKNOWN_FIXUP_TYPE, fixup->type, curr->sym.name, fixup->locofs );

	mov	r9d, DWORD PTR [rbx+20]
	mov	r8, QWORD PTR [rsi+8]
	mov	edx, r10d
	mov	ecx, 196				; 000000c4H
	call	EmitErr
$LN2@write_relo:

; 1115 :         }
; 1116 :         /* the low 8 bits of info are type */
; 1117 :         /* the high 24 bits are symbol table index */
; 1118 :         reloc32.r_info = ELF32_R_INFO( fixup->sym->ext_idx, elftype );

	mov	rax, QWORD PTR [rbx+56]

; 1119 :         if ( fwrite( &reloc32, 1, sizeof(reloc32), CurrFile[OBJ] ) != sizeof(reloc32) )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	edx, 1
	mov	ecx, DWORD PTR [rax+96]
	movzx	eax, dil
	lea	r8d, QWORD PTR [rdx+7]
	shl	ecx, 8
	add	ecx, eax
	mov	DWORD PTR reloc32$[rsp+4], ecx
	lea	rcx, QWORD PTR reloc32$[rsp]
	call	fwrite
	cmp	rax, 8
	je	SHORT $LN15@write_relo

; 1120 :             WriteError();

	call	WriteError
$LN15@write_relo:

; 1083 :     uint_8 elftype;
; 1084 :     struct fixup *fixup;
; 1085 :     Elf32_Rel reloc32;
; 1086 : 
; 1087 :     DebugMsg(("write_relocs32: enter\n"));
; 1088 :     for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rbx, QWORD PTR [rbx+8]
	test	rbx, rbx
	jne	$LL16@write_relo
	mov	r12, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+104]
$LN14@write_relo:
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]

; 1121 :     }
; 1122 :     DebugMsg(("write_relocs32: exit\n"));
; 1123 :     return;
; 1124 : }

	add	rsp, 72					; 00000048H
	ret	0
	npad	3
$LN21@write_relo:
	DD	$LN5@write_relo
	DD	$LN7@write_relo
	DD	$LN10@write_relo
	DD	$LN6@write_relo
	DD	$LN8@write_relo
	DD	$LN11@write_relo
	DD	$LN4@write_relo
	DD	$LN4@write_relo
	DD	$LN4@write_relo
	DD	$LN4@write_relo
	DD	$LN4@write_relo
	DD	$LN9@write_relo
write_relocs32 ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$write_relocs64 DD 051201H
	DD	0e6412H
	DD	0c340dH
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$write_relocs64 DD @imagerel(write_relocs64#)
	DD	@imagerel(write_relocs64#+34)
	DD	@imagerel($unwind$write_relocs64#)
pdata	ENDS
xdata	SEGMENT
$chain$4$write_relocs64 DD 060f21H
	DD	0f740fH
	DD	0d540aH
	DD	0ac405H
	DD	@imagerel(write_relocs64#)
	DD	@imagerel(write_relocs64#+34)
	DD	@imagerel($unwind$write_relocs64#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$write_relocs64 DD @imagerel(write_relocs64#+34)
	DD	@imagerel(write_relocs64#+310)
	DD	@imagerel($chain$4$write_relocs64#)
pdata	ENDS
xdata	SEGMENT
$chain$5$write_relocs64 DD 021H
	DD	@imagerel(write_relocs64#)
	DD	@imagerel(write_relocs64#+34)
	DD	@imagerel($unwind$write_relocs64#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$write_relocs64 DD @imagerel(write_relocs64#+310)
	DD	@imagerel(write_relocs64#+328)
	DD	@imagerel($chain$5$write_relocs64#)
pdata	ENDS
xdata	SEGMENT
$chain$6$write_relocs64 DD 060021H
	DD	0ac400H
	DD	0f7400H
	DD	0d5400H
	DD	@imagerel(write_relocs64#)
	DD	@imagerel(write_relocs64#+34)
	DD	@imagerel($unwind$write_relocs64#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$write_relocs64 DD @imagerel(write_relocs64#+328)
	DD	@imagerel(write_relocs64#+376)
	DD	@imagerel($chain$6$write_relocs64#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
reloc64$ = 48
curr$ = 96
write_relocs64 PROC NEAR

; 1132 : {

	sub	rsp, 88					; 00000058H

; 1133 :     uint_8 elftype;
; 1134 :     struct fixup *fixup;
; 1135 :     Elf64_Rela reloc64; /* v2.05: changed to Rela */
; 1136 : 
; 1137 :     DebugMsg(("write_relocs64: enter\n"));
; 1138 :     for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rax, QWORD PTR [rcx+104]
	mov	QWORD PTR [rsp+96], rbx
	mov	QWORD PTR [rsp+112], rsi
	mov	rbx, QWORD PTR [rax+40]
	mov	rsi, rcx
	test	rbx, rbx
	je	$LN15@write_relo@2
	mov	QWORD PTR [rsp+80], r12
	mov	QWORD PTR [rsp+104], rbp
	mov	QWORD PTR [rsp+120], rdi
	lea	r12, OFFSET FLAT:__ImageBase
	npad	8
$LL17@write_relo@2:

; 1139 :         unsigned symidx = fixup->sym->ext_idx;

	mov	rax, QWORD PTR [rbx+56]
	mov	ebp, DWORD PTR [rax+96]

; 1140 :         reloc64.r_offset = fixup->locofs;

	mov	eax, DWORD PTR [rbx+20]
	mov	QWORD PTR reloc64$[rsp], rax

; 1141 :         /* v2.07: addend wasn't handled correctly.
; 1142 :          * Also note the type cast for fixup.offset -
; 1143 :          * r_addend has type int_64, while fixup.offset has type uint_32!
; 1144 :          */
; 1145 :         //reloc64.r_addend = fixup->offset;
; 1146 :         /* the following line depends on what's done in store_fixup().
; 1147 :          * if the inline addend is set to 0 there, the fixup->offset
; 1148 :          * must be used in the calculation ( it's 32-bit only!!! ).
; 1149 :          */
; 1150 :         //reloc64.r_addend = (int_32)fixup->offset - fixup->addbytes;
; 1151 :         /*
; 1152 :          * if the inline addend is not touched in store_fixup(),
; 1153 :          * we just have to use the addbytes field.
; 1154 :          */
; 1155 :         reloc64.r_addend = - fixup->addbytes;

	movzx	eax, BYTE PTR [rbx+32]
	neg	rax
	mov	QWORD PTR reloc64$[rsp+16], rax

; 1156 :         DebugMsg(("write_relocs64(): reloc loc=%X type=%u idx=%u sym=%s ofs=%X addbyt=%u\n",
; 1157 :                   fixup->locofs, fixup->type, fixup->sym->ext_idx, fixup->sym->name, fixup->offset, fixup->addbytes ));
; 1158 :         switch ( fixup->type ) {

	mov	r10d, DWORD PTR [rbx+24]
	lea	eax, DWORD PTR [r10-1]
	cmp	eax, 11
	ja	SHORT $LN4@write_relo@2
	cdqe
	mov	ecx, DWORD PTR $LN22@write_relo@2[r12+rax*4]
	add	rcx, r12
	jmp	rcx
$LN12@write_relo@2:

; 1159 :         case FIX_RELOFF32:
; 1160 : #if 0  /* v2.07: activate if the section's index is to be used as symtab ref */
; 1161 :             if ( fixup->sym->segment != &curr->sym ) {
; 1162 :                 //printf("PC-relative fixup to another section: %s\n", fixup->sym->name );
; 1163 :                 reloc64.r_addend += fixup->sym->offset;
; 1164 :                 symidx = fixup->sym->segment->ext_idx;
; 1165 :             }
; 1166 : #endif
; 1167 :             elftype = R_X86_64_PC32;

	mov	dil, 2

; 1168 :             break;

	jmp	SHORT $LN2@write_relo@2
$LN11@write_relo@2:

; 1169 :         case FIX_OFF64:        elftype = R_X86_64_64;          break;

	mov	dil, 1
	jmp	SHORT $LN2@write_relo@2
$LN10@write_relo@2:

; 1170 :         //case FIX_???:        elftype = R_X86_64_GOT32;       break;
; 1171 :         //case FIX_???:        elftype = R_X86_64_PLT32;       break;
; 1172 :         //case FIX_???:        elftype = R_X86_64_COPY;        break;
; 1173 :         //case FIX_???:        elftype = R_X86_64_GLOB_DAT;    break;
; 1174 :         //case FIX_???:        elftype = R_X86_64_JMP_SLOT;    break;
; 1175 :         case FIX_OFF32_IMGREL: elftype = R_X86_64_RELATIVE;    break;

	mov	dil, 8
	jmp	SHORT $LN2@write_relo@2
$LN9@write_relo@2:

; 1176 :         //case FIX_???:        elftype = R_X86_64_GOTPCREL;    break;
; 1177 :         case FIX_OFF32:        elftype = R_X86_64_32;          break;

	mov	dil, 10
	jmp	SHORT $LN2@write_relo@2
$LN8@write_relo@2:

; 1178 :         //case FIX_???:        elftype = R_X86_64_32S;         break;
; 1179 :         case FIX_OFF16:        elftype = R_X86_64_16;          break;

	mov	dil, 12
	jmp	SHORT $LN2@write_relo@2
$LN7@write_relo@2:

; 1180 :         case FIX_RELOFF16:     elftype = R_X86_64_PC16;        break;

	mov	dil, 13
	jmp	SHORT $LN2@write_relo@2
$LN6@write_relo@2:

; 1181 :         case FIX_OFF8:         elftype = R_X86_64_8;           break;

	mov	dil, 14
	jmp	SHORT $LN2@write_relo@2
$LN5@write_relo@2:

; 1182 :         case FIX_RELOFF8:      elftype = R_X86_64_PC8;         break;

	mov	dil, 15
	jmp	SHORT $LN2@write_relo@2
$LN4@write_relo@2:

; 1183 :         //case FIX_???:        elftype = R_X86_64_DPTMOD64;    break;
; 1184 :         //case FIX_???:        elftype = R_X86_64_DPTOFF64;    break;
; 1185 :         //case FIX_???:        elftype = R_X86_64_TPOFF64;     break;
; 1186 :         //case FIX_???:        elftype = R_X86_64_TLSGD;       break;
; 1187 :         //case FIX_???:        elftype = R_X86_64_TLSLD;       break;
; 1188 :         //case FIX_???:        elftype = R_X86_64_DPTOFF32;    break;
; 1189 :         //case FIX_???:        elftype = R_X86_64_GOTTPOFF;    break;
; 1190 :         //case FIX_???:        elftype = R_X86_64_TPOFF32;     break;
; 1191 :         //case FIX_???:        elftype = R_X86_64_PC64;        break;
; 1192 :         //case FIX_???:        elftype = R_X86_64_GOTOFF64;    break;
; 1193 :         //case FIX_???:        elftype = R_X86_64_GOTPC32;     break;
; 1194 :         //case FIX_???:        elftype = R_X86_64_SIZE32;      break;
; 1195 :         //case FIX_???:        elftype = R_X86_64_SIZE64;      break;
; 1196 :         default:
; 1197 :             DebugMsg(("write_relocs64(): unhandled reloc loc=%X type=%u idx=%u sym=%s\n",
; 1198 :                       fixup->locofs, fixup->type, fixup->sym->ext_idx, fixup->sym->name));
; 1199 :             elftype = R_X86_64_NONE;

	xor	dil, dil

; 1200 :             if ( fixup->type < FIX_LAST ) {

	cmp	r10d, 14
	jge	SHORT $LN3@write_relo@2

; 1201 :                 EmitErr( INVALID_FIXUP_TYPE, ModuleInfo.fmtopt->formatname, fixup->type, curr->sym.name, fixup->locofs );

	mov	rdx, QWORD PTR ModuleInfo+344
	mov	eax, DWORD PTR [rbx+20]
	mov	r9, QWORD PTR [rsi+8]
	add	rdx, 10
	mov	r8d, r10d
	mov	ecx, 198				; 000000c6H
	mov	DWORD PTR [rsp+32], eax
	call	EmitErr

; 1202 :             } else

	jmp	SHORT $LN2@write_relo@2
$LN3@write_relo@2:

; 1203 :                 EmitErr( UNKNOWN_FIXUP_TYPE, fixup->type, curr->sym.name, fixup->locofs );

	mov	r9d, DWORD PTR [rbx+20]
	mov	r8, QWORD PTR [rsi+8]
	mov	edx, r10d
	mov	ecx, 196				; 000000c4H
	call	EmitErr
$LN2@write_relo@2:

; 1204 :         }
; 1205 :         /* the low 8 bits of info are type */
; 1206 :         /* the high 24 bits are symbol table index */
; 1207 :         reloc64.r_info = ELF64_R_INFO( symidx, elftype );
; 1208 :         if ( fwrite( &reloc64, 1, sizeof( reloc64 ), CurrFile[OBJ] ) != sizeof(reloc64) )

	mov	r9, QWORD PTR ModuleInfo+104
	movzx	eax, dil
	mov	edx, 1
	mov	rcx, rbp
	lea	r8d, QWORD PTR [rdx+23]
	shl	rcx, 32					; 00000020H
	add	rcx, rax
	mov	QWORD PTR reloc64$[rsp+8], rcx
	lea	rcx, QWORD PTR reloc64$[rsp]
	call	fwrite
	cmp	rax, 24
	je	SHORT $LN16@write_relo@2

; 1209 :             WriteError();

	call	WriteError
$LN16@write_relo@2:

; 1133 :     uint_8 elftype;
; 1134 :     struct fixup *fixup;
; 1135 :     Elf64_Rela reloc64; /* v2.05: changed to Rela */
; 1136 : 
; 1137 :     DebugMsg(("write_relocs64: enter\n"));
; 1138 :     for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rbx, QWORD PTR [rbx+8]
	test	rbx, rbx
	jne	$LL17@write_relo@2
	mov	r12, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+120]
	mov	rbp, QWORD PTR [rsp+104]
$LN15@write_relo@2:
	mov	rsi, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [rsp+96]

; 1210 :     }
; 1211 :     DebugMsg(("write_relocs64: exit\n"));
; 1212 :     return;
; 1213 : }

	add	rsp, 88					; 00000058H
	ret	0
	npad	3
$LN22@write_relo@2:
	DD	$LN5@write_relo@2
	DD	$LN7@write_relo@2
	DD	$LN12@write_relo@2
	DD	$LN6@write_relo@2
	DD	$LN8@write_relo@2
	DD	$LN9@write_relo@2
	DD	$LN11@write_relo@2
	DD	$LN4@write_relo@2
	DD	$LN4@write_relo@2
	DD	$LN4@write_relo@2
	DD	$LN4@write_relo@2
	DD	$LN10@write_relo@2
write_relocs64 ENDP
_TEXT	ENDS
EXTRN	EmitWarn:NEAR
EXTRN	fseek:NEAR
xdata	SEGMENT
$unwind$elf_write_data DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$elf_write_data DD @imagerel(elf_write_data#)
	DD	@imagerel(elf_write_data#+4)
	DD	@imagerel($unwind$elf_write_data#)
pdata	ENDS
xdata	SEGMENT
$chain$2$elf_write_data DD 060f21H
	DD	08640fH
	DD	07540aH
	DD	063405H
	DD	@imagerel(elf_write_data#)
	DD	@imagerel(elf_write_data#+4)
	DD	@imagerel($unwind$elf_write_data#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$elf_write_data DD @imagerel(elf_write_data#+4)
	DD	@imagerel(elf_write_data#+19)
	DD	@imagerel($chain$2$elf_write_data#)
pdata	ENDS
xdata	SEGMENT
$chain$3$elf_write_data DD 020521H
	DD	097405H
	DD	@imagerel(elf_write_data#+4)
	DD	@imagerel(elf_write_data#+19)
	DD	@imagerel($chain$2$elf_write_data#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$elf_write_data DD @imagerel(elf_write_data#+19)
	DD	@imagerel(elf_write_data#+240)
	DD	@imagerel($chain$3$elf_write_data#)
pdata	ENDS
xdata	SEGMENT
$chain$4$elf_write_data DD 021H
	DD	@imagerel(elf_write_data#+4)
	DD	@imagerel(elf_write_data#+19)
	DD	@imagerel($chain$2$elf_write_data#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$elf_write_data DD @imagerel(elf_write_data#+240)
	DD	@imagerel(elf_write_data#+328)
	DD	@imagerel($chain$4$elf_write_data#)
pdata	ENDS
xdata	SEGMENT
$chain$5$elf_write_data DD 021H
	DD	@imagerel(elf_write_data#)
	DD	@imagerel(elf_write_data#+4)
	DD	@imagerel($unwind$elf_write_data#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$elf_write_data DD @imagerel(elf_write_data#+328)
	DD	@imagerel(elf_write_data#+350)
	DD	@imagerel($chain$5$elf_write_data#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
modinfo$ = 48
em$ = 56
elf_write_data PROC NEAR

; 1220 : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi

; 1221 :     struct dsym *curr;
; 1222 :     //int seg_index;
; 1223 :     //uint_32 offset = 0;
; 1224 :     uint_32     size;
; 1225 :     int         i;
; 1226 : 
; 1227 :     DebugMsg(("elf_write_data: enter\n"));
; 1228 : 
; 1229 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rdi, QWORD PTR SymTables+32
	mov	rsi, rdx
	test	rdi, rdi
	mov	rbp, rcx
	je	SHORT $LN15@elf_write_@3
	npad	6
$LL17@elf_write_@3:

; 1230 :         size = curr->sym.max_offset - curr->e.seginfo->start_loc;

	mov	rax, QWORD PTR [rdi+104]
	mov	ebx, DWORD PTR [rdi+64]
	sub	ebx, DWORD PTR [rax+8]

; 1231 :         DebugMsg(("elf_write_data(%s): program data at ofs=%X, size=%X\n", curr->sym.name, curr->e.seginfo->fileoffset, size ));
; 1232 :         if ( curr->e.seginfo->segtype != SEGTYPE_BSS && size != 0 ) {

	cmp	DWORD PTR [rax+72], 3
	je	SHORT $LN16@elf_write_@3
	test	ebx, ebx
	je	SHORT $LN16@elf_write_@3

; 1233 :             fseek( CurrFile[OBJ], curr->e.seginfo->fileoffset + curr->e.seginfo->start_loc, SEEK_SET );

	mov	edx, DWORD PTR [rax+56]
	mov	rcx, QWORD PTR ModuleInfo+104
	xor	r8d, r8d
	add	edx, DWORD PTR [rax+8]
	call	fseek

; 1234 :             /**/myassert( curr->e.seginfo->CodeBuffer );
; 1235 :             if ( fwrite( curr->e.seginfo->CodeBuffer, 1, size, CurrFile[OBJ] ) != size )

	mov	rcx, QWORD PTR [rdi+104]
	mov	r9, QWORD PTR ModuleInfo+104
	mov	rcx, QWORD PTR [rcx+16]
	mov	r8, rbx
	mov	edx, 1
	call	fwrite
	cmp	rax, rbx
	je	SHORT $LN16@elf_write_@3

; 1236 :                 WriteError();

	call	WriteError
$LN16@elf_write_@3:

; 1221 :     struct dsym *curr;
; 1222 :     //int seg_index;
; 1223 :     //uint_32 offset = 0;
; 1224 :     uint_32     size;
; 1225 :     int         i;
; 1226 : 
; 1227 :     DebugMsg(("elf_write_data: enter\n"));
; 1228 : 
; 1229 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rdi, QWORD PTR [rdi+112]
	test	rdi, rdi
	jne	SHORT $LL17@elf_write_@3
$LN15@elf_write_@3:

; 1237 :         }
; 1238 :     }
; 1239 : 
; 1240 :     /* write internal sections */
; 1241 :     for ( i = 0; i < NUM_INTSEGS; i++ ) {

	lea	rbx, QWORD PTR [rsi+32]
	mov	edi, 3
$LL12@elf_write_@3:

; 1242 :         if ( em->internal_segs[i].data ) {

	cmp	QWORD PTR [rbx], 0
	je	SHORT $LN11@elf_write_@3

; 1243 :             DebugMsg(("elf_write_data(%s): internal at ofs=%X, size=%X\n", internal_segparms[i].name, em->internal_segs[i].fileoffset, em->internal_segs[i].size));
; 1244 :             fseek( CurrFile[OBJ], em->internal_segs[i].fileoffset, SEEK_SET );

	mov	edx, DWORD PTR [rbx-4]
	mov	rcx, QWORD PTR ModuleInfo+104
	xor	r8d, r8d
	call	fseek

; 1245 :             if ( fwrite( em->internal_segs[i].data, 1, em->internal_segs[i].size, CurrFile[OBJ] ) != em->internal_segs[i].size )

	mov	r8d, DWORD PTR [rbx-8]
	mov	r9, QWORD PTR ModuleInfo+104
	mov	rcx, QWORD PTR [rbx]
	mov	edx, 1
	call	fwrite
	mov	ecx, DWORD PTR [rbx-8]
	cmp	rax, rcx
	je	SHORT $LN11@elf_write_@3

; 1246 :                 WriteError();

	call	WriteError
$LN11@elf_write_@3:

; 1237 :         }
; 1238 :     }
; 1239 : 
; 1240 :     /* write internal sections */
; 1241 :     for ( i = 0; i < NUM_INTSEGS; i++ ) {

	add	rbx, 16
	dec	rdi
	jne	SHORT $LL12@elf_write_@3

; 1247 :         }
; 1248 :     }
; 1249 : 
; 1250 :     /* write reloc sections content */
; 1251 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+32
	mov	rdi, QWORD PTR [rsp+72]
	test	rbx, rbx
	je	SHORT $LN5@elf_write_@3
	npad	8
$LL7@elf_write_@3:

; 1252 :         if ( curr->e.seginfo->num_relocs ) {

	mov	rax, QWORD PTR [rbx+104]
	cmp	DWORD PTR [rax+64], 0
	je	SHORT $LN6@elf_write_@3

; 1253 :             DebugMsg(("elf_write_data(%s): relocs at ofs=%X, size=%X\n", curr->sym.name, curr->e.seginfo->reloc_offset, curr->e.seginfo->num_relocs * sizeof(Elf32_Rel)));
; 1254 :             fseek( CurrFile[OBJ], curr->e.seginfo->reloc_offset, SEEK_SET );

	mov	edx, DWORD PTR [rax+12]
	mov	rcx, QWORD PTR ModuleInfo+104
	xor	r8d, r8d
	call	fseek

; 1255 : #if AMD64_SUPPORT
; 1256 :             if ( modinfo->defOfssize == USE64 )

	cmp	BYTE PTR [rbp+405], 2
	jne	SHORT $LN3@elf_write_@3

; 1257 :                 write_relocs64( curr );

	mov	rcx, rbx
	call	write_relocs64

; 1258 :             else

	jmp	SHORT $LN6@elf_write_@3
$LN3@elf_write_@3:

; 1259 : #endif
; 1260 :                 write_relocs32( em, curr );

	mov	rdx, rbx
	mov	rcx, rsi
	call	write_relocs32
$LN6@elf_write_@3:
	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL7@elf_write_@3
$LN5@elf_write_@3:

; 1261 :         }
; 1262 :     }
; 1263 : #if GNURELOCS
; 1264 :     if ( em->extused ) {

	cmp	BYTE PTR [rsi+16], 0
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+64]
	je	SHORT $LN26@elf_write_@3

; 1265 :         EmitWarn( 2, ELF_GNU_EXTENSIONS_USED );

	mov	edx, 263				; 00000107H
	mov	ecx, 2
	call	EmitWarn
$LN26@elf_write_@3:

; 1266 :     }
; 1267 : #endif
; 1268 : 
; 1269 :     DebugMsg(("elf_write_data: exit\n"));
; 1270 : 
; 1271 :     return( NOT_ERROR );

	xor	eax, eax

; 1272 : }

	add	rsp, 40					; 00000028H
	ret	0
elf_write_data ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$elf_write_module DD 040e01H
	DD	01a340eH
	DD	017010aH
xdata	ENDS
pdata	SEGMENT
$pdata$elf_write_module DD @imagerel(elf_write_module#)
	DD	@imagerel(elf_write_module#+30)
	DD	@imagerel($unwind$elf_write_module#)
pdata	ENDS
xdata	SEGMENT
$chain$1$elf_write_module DD 020421H
	DD	01b7404H
	DD	@imagerel(elf_write_module#)
	DD	@imagerel(elf_write_module#+30)
	DD	@imagerel($unwind$elf_write_module#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$elf_write_module DD @imagerel(elf_write_module#+30)
	DD	@imagerel(elf_write_module#+96)
	DD	@imagerel($chain$1$elf_write_module#)
pdata	ENDS
xdata	SEGMENT
$chain$2$elf_write_module DD 021H
	DD	@imagerel(elf_write_module#)
	DD	@imagerel(elf_write_module#+30)
	DD	@imagerel($unwind$elf_write_module#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$elf_write_module DD @imagerel(elf_write_module#+96)
	DD	@imagerel(elf_write_module#+736)
	DD	@imagerel($chain$2$elf_write_module#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
em$ = 32
modinfo$ = 192
elf_write_module PROC NEAR

; 1278 : {

	mov	rax, rsp
	sub	rsp, 184				; 000000b8H
	mov	QWORD PTR [rax+24], rbx
	mov	rbx, rcx

; 1279 :     //struct dsym  *dir;
; 1280 :     struct elfmod em;
; 1281 : 
; 1282 :     DebugMsg(("elf_write_module: enter\n"));
; 1283 : 
; 1284 :     memset( &em, 0, sizeof( em ) );

	lea	rcx, QWORD PTR em$[rsp]
	xor	edx, edx
	mov	r8d, 136				; 00000088H
	mov	QWORD PTR [rax+32], rdi
	call	memset

; 1285 :     em.srcname = CurrFName[ASM];

	mov	r11, QWORD PTR ModuleInfo+128

; 1286 : #if 1
; 1287 :     /* the path part is stripped. todo: check if this is ok to do */
; 1288 :     em.srcname += strlen( em.srcname );

	xor	eax, eax
	mov	QWORD PTR em$[rsp+8], r11
	mov	rdi, r11
	mov	rcx, -1
	repne scasb
	mov	rdi, QWORD PTR [rsp+216]
	mov	rdx, r11
	not	rcx
	dec	rcx
	add	rdx, rcx

; 1289 :     while ( em.srcname > CurrFName[ASM] &&
; 1290 :            *(em.srcname-1) != '/' &&
; 1291 :            *(em.srcname-1) != '\\') em.srcname--;

	cmp	rdx, r11
	mov	QWORD PTR em$[rsp+8], rdx
	jbe	SHORT $LN29@elf_write_@4
	npad	1
$LL8@elf_write_@4:
	movzx	eax, BYTE PTR [rdx-1]
	dec	rdx
	cmp	al, 47					; 0000002fH
	je	SHORT $LN29@elf_write_@4
	cmp	al, 92					; 0000005cH
	je	SHORT $LN29@elf_write_@4
	cmp	rdx, r11
	mov	QWORD PTR em$[rsp+8], rdx
	ja	SHORT $LL8@elf_write_@4
$LN29@elf_write_@4:

; 1292 : #endif
; 1293 :     /* position at 0 ( probably unnecessary, since there were no writes yet ) */
; 1294 :     fseek( CurrFile[OBJ], 0, SEEK_SET );

	mov	rcx, QWORD PTR ModuleInfo+104
	xor	r8d, r8d
	xor	edx, edx
	call	fseek

; 1295 : 
; 1296 :     switch ( modinfo->defOfssize ) {

	cmp	BYTE PTR [rbx+405], 2
	je	$LN4@elf_write_@4

; 1331 :         break;
; 1332 : #endif
; 1333 :     default:
; 1334 :         memcpy( &em.ehdr32.e_ident, ELF_SIGNATURE, ELF_SIGNATURE_LEN );

	mov	eax, DWORD PTR $SG6159

; 1335 :         em.ehdr32.e_ident[EI_CLASS] = ELFCLASS32;
; 1336 :         em.ehdr32.e_ident[EI_DATA] = ELFDATA2LSB;
; 1337 :         em.ehdr32.e_ident[EI_VERSION] = EV_CURRENT;
; 1338 :         em.ehdr32.e_ident[EI_OSABI] = modinfo->elf_osabi;
; 1339 :         /* v2.07: set abiversion to 0 */
; 1340 :         //ehdr32.e_ident[EI_ABIVERSION] = EV_CURRENT;
; 1341 :         em.ehdr32.e_ident[EI_ABIVERSION] = 0;
; 1342 :         em.ehdr32.e_type = ET_REL; /* file type */
; 1343 :         em.ehdr32.e_machine = EM_386;
; 1344 :         em.ehdr32.e_version = EV_CURRENT;
; 1345 :         em.ehdr32.e_entry = 0; /* no entry for relocatable objects */
; 1346 :         em.ehdr32.e_phoff = 0; /* no progheaders for relocatable objects */
; 1347 :         em.ehdr32.e_shoff = sizeof( em.ehdr32 );
; 1348 :         em.ehdr32.e_flags = 0;
; 1349 :         em.ehdr32.e_ehsize = sizeof( em.ehdr32 );
; 1350 :         em.ehdr32.e_phentsize = 0; /* no progheaders for relocatable objects */
; 1351 :         em.ehdr32.e_phnum = 0;
; 1352 :         em.ehdr32.e_shentsize = sizeof( Elf32_Shdr );
; 1353 :         /* calculate # of sections. Add the following internal sections:
; 1354 :          - 1 NULL entry
; 1355 :          - 1 .shstrtab
; 1356 :          - 1 .symtab
; 1357 :          - 1 .strtab
; 1358 :          - n .rel<xxx> entries
; 1359 :          */
; 1360 :         em.ehdr32.e_shnum = 1 + modinfo->g.num_segs + 3 + get_num_reloc_sections();

	mov	rcx, QWORD PTR SymTables+32
	xor	edx, edx
	test	rcx, rcx
	mov	DWORD PTR em$[rsp+72], eax
	movzx	eax, BYTE PTR [rbx+412]
	mov	BYTE PTR em$[rsp+76], 1
	mov	BYTE PTR em$[rsp+77], 1
	mov	BYTE PTR em$[rsp+78], 1
	mov	BYTE PTR em$[rsp+79], al
	mov	BYTE PTR em$[rsp+80], 0
	mov	WORD PTR em$[rsp+88], 1
	mov	WORD PTR em$[rsp+90], 3
	mov	DWORD PTR em$[rsp+92], 1
	mov	DWORD PTR em$[rsp+96], edx
	mov	DWORD PTR em$[rsp+100], edx
	mov	DWORD PTR em$[rsp+104], 52		; 00000034H
	mov	DWORD PTR em$[rsp+108], edx
	mov	WORD PTR em$[rsp+112], 52		; 00000034H
	mov	WORD PTR em$[rsp+114], dx
	mov	WORD PTR em$[rsp+116], dx
	mov	WORD PTR em$[rsp+118], 40		; 00000028H
	je	SHORT $LN18@elf_write_@4
	npad	8
$LL20@elf_write_@4:
	mov	rax, QWORD PTR [rcx+104]
	cmp	QWORD PTR [rax+40], 0
	je	SHORT $LN19@elf_write_@4
	inc	edx
$LN19@elf_write_@4:
	mov	rcx, QWORD PTR [rcx+112]
	test	rcx, rcx
	jne	SHORT $LL20@elf_write_@4
$LN18@elf_write_@4:
	movzx	ecx, WORD PTR [rbx+8]

; 1361 :         em.ehdr32.e_shstrndx = 1 + modinfo->g.num_segs + SHSTRTAB_IDX; /* set index of .shstrtab section */
; 1362 :         if ( fwrite( &em.ehdr32, 1, sizeof( em.ehdr32 ), CurrFile[OBJ] ) != sizeof( em.ehdr32 ) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	eax, DWORD PTR [rdx+rcx+4]
	inc	cx
	mov	edx, 1
	mov	WORD PTR em$[rsp+122], cx
	lea	r8d, QWORD PTR [rdx+51]
	lea	rcx, QWORD PTR em$[rsp+72]
	mov	WORD PTR em$[rsp+120], ax
	call	fwrite
	cmp	rax, 52					; 00000034H
	je	SHORT $LN1@elf_write_@4

; 1363 :             WriteError();

	call	WriteError
$LN1@elf_write_@4:

; 1364 :         elf_write_section_table32( modinfo, &em,
; 1365 :                                   sizeof( Elf32_Ehdr ) + em.ehdr32.e_shnum * em.ehdr32.e_shentsize );

	movzx	r8d, WORD PTR em$[rsp+120]
	movzx	eax, WORD PTR em$[rsp+118]
	lea	rdx, QWORD PTR em$[rsp]
	imul	r8d, eax
	mov	rcx, rbx
	add	r8d, 52					; 00000034H
	call	elf_write_section_table32
	jmp	$LN5@elf_write_@4
$LN4@elf_write_@4:

; 1297 : #if AMD64_SUPPORT
; 1298 :     case USE64:
; 1299 :         memcpy( &em.ehdr64.e_ident, ELF_SIGNATURE, ELF_SIGNATURE_LEN );

	mov	eax, DWORD PTR $SG6154

; 1300 :         em.ehdr64.e_ident[EI_CLASS] = ELFCLASS64;
; 1301 :         em.ehdr64.e_ident[EI_DATA] = ELFDATA2LSB;
; 1302 :         em.ehdr64.e_ident[EI_VERSION] = EV_CURRENT;
; 1303 :         em.ehdr64.e_ident[EI_OSABI] = modinfo->elf_osabi;
; 1304 :         /* v2.07: set abiversion to 0 */
; 1305 :         //ehdr64.e_ident[EI_ABIVERSION] = EV_CURRENT;
; 1306 :         em.ehdr64.e_ident[EI_ABIVERSION] = 0;
; 1307 :         em.ehdr64.e_type = ET_REL; /* file type */
; 1308 :         em.ehdr64.e_machine = EM_X86_64;
; 1309 :         em.ehdr64.e_version = EV_CURRENT;
; 1310 :         em.ehdr64.e_entry = 0; /* no entry for relocatable objects */
; 1311 :         em.ehdr64.e_phoff = 0; /* no progheaders for relocatable objects */
; 1312 :         em.ehdr64.e_shoff = sizeof( em.ehdr64 );
; 1313 :         em.ehdr64.e_flags = 0;
; 1314 :         em.ehdr64.e_ehsize = sizeof( em.ehdr64 );
; 1315 :         em.ehdr64.e_phentsize = 0; /* no progheaders for relocatable objects */
; 1316 :         em.ehdr64.e_phnum = 0;
; 1317 :         em.ehdr64.e_shentsize = sizeof( Elf64_Shdr );
; 1318 :         /* calculate # of sections. Add the following internal sections:
; 1319 :          - 1 NULL entry
; 1320 :          - 1 .shstrtab
; 1321 :          - 1 .symtab
; 1322 :          - 1 .strtab
; 1323 :          - n .rela<xxx> sections
; 1324 :          */
; 1325 :         em.ehdr64.e_shnum = 1 + modinfo->g.num_segs + 3 + get_num_reloc_sections();

	mov	rcx, QWORD PTR SymTables+32
	xor	edx, edx
	test	rcx, rcx
	mov	DWORD PTR em$[rsp+72], eax
	movzx	eax, BYTE PTR [rbx+412]
	mov	BYTE PTR em$[rsp+76], 2
	mov	BYTE PTR em$[rsp+77], 1
	mov	BYTE PTR em$[rsp+78], 1
	mov	BYTE PTR em$[rsp+79], al
	mov	BYTE PTR em$[rsp+80], 0
	mov	WORD PTR em$[rsp+88], 1
	mov	WORD PTR em$[rsp+90], 62		; 0000003eH
	mov	DWORD PTR em$[rsp+92], 1
	mov	QWORD PTR em$[rsp+96], rdx
	mov	QWORD PTR em$[rsp+104], rdx
	mov	QWORD PTR em$[rsp+112], 64		; 00000040H
	mov	DWORD PTR em$[rsp+120], edx
	mov	WORD PTR em$[rsp+124], 64		; 00000040H
	mov	WORD PTR em$[rsp+126], dx
	mov	WORD PTR em$[rsp+128], dx
	mov	WORD PTR em$[rsp+130], 64		; 00000040H
	je	SHORT $LN12@elf_write_@4
$LL14@elf_write_@4:
	mov	rax, QWORD PTR [rcx+104]
	cmp	QWORD PTR [rax+40], 0
	je	SHORT $LN13@elf_write_@4
	inc	edx
$LN13@elf_write_@4:
	mov	rcx, QWORD PTR [rcx+112]
	test	rcx, rcx
	jne	SHORT $LL14@elf_write_@4
$LN12@elf_write_@4:
	movzx	ecx, WORD PTR [rbx+8]

; 1326 :         em.ehdr64.e_shstrndx = 1 + modinfo->g.num_segs + SHSTRTAB_IDX; /* set index of .shstrtab section */
; 1327 :         if ( fwrite( &em.ehdr64, 1, sizeof( em.ehdr64 ), CurrFile[OBJ] ) != sizeof( em.ehdr64 ) )

	mov	r9, QWORD PTR ModuleInfo+104
	lea	eax, DWORD PTR [rdx+rcx+4]
	inc	cx
	mov	edx, 1
	mov	WORD PTR em$[rsp+134], cx
	lea	r8d, QWORD PTR [rdx+63]
	lea	rcx, QWORD PTR em$[rsp+72]
	mov	WORD PTR em$[rsp+132], ax
	call	fwrite
	cmp	rax, 64					; 00000040H
	je	SHORT $LN3@elf_write_@4

; 1328 :             WriteError();

	call	WriteError
$LN3@elf_write_@4:

; 1329 :         elf_write_section_table64( modinfo, &em,
; 1330 :                                   sizeof( Elf64_Ehdr ) + em.ehdr64.e_shnum * em.ehdr64.e_shentsize );

	movzx	r8d, WORD PTR em$[rsp+132]
	movzx	eax, WORD PTR em$[rsp+130]
	lea	rdx, QWORD PTR em$[rsp]
	imul	r8d, eax
	mov	rcx, rbx
	add	r8d, 64					; 00000040H
	call	elf_write_section_table64
$LN5@elf_write_@4:

; 1366 :     };
; 1367 :     elf_write_data( modinfo, &em );

	lea	rdx, QWORD PTR em$[rsp]
	mov	rcx, rbx
	call	elf_write_data
	mov	rbx, QWORD PTR [rsp+208]

; 1368 :     DebugMsg(("elf_write_module: exit\n"));
; 1369 :     return( NOT_ERROR );

	xor	eax, eax

; 1370 : }

	add	rsp, 184				; 000000b8H
	ret	0
elf_write_module ENDP
_TEXT	ENDS
PUBLIC	elf_init
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
modinfo$ = 8
elf_init PROC NEAR

; 1379 :     modinfo->elf_osabi = ELFOSABI_LINUX;
; 1380 :     modinfo->g.WriteModule = elf_write_module;

	lea	rax, OFFSET FLAT:elf_write_module
	mov	BYTE PTR [rcx+412], 3
	mov	QWORD PTR [rcx+288], rax

; 1381 : #if 0
; 1382 :     printf("size Elf_Ehdr: %2u - %2u\n", sizeof(Elf32_Ehdr), sizeof(Elf64_Ehdr));
; 1383 :     printf("size Elf_Shdr: %2u - %2u\n", sizeof(Elf32_Shdr), sizeof(Elf64_Shdr));
; 1384 :     printf("size Elf_Sym : %2u - %2u\n", sizeof(Elf32_Sym ), sizeof(Elf64_Sym ));
; 1385 :     printf("size Elf_Rel : %2u - %2u\n", sizeof(Elf32_Rel ), sizeof(Elf64_Rel ));
; 1386 :     printf("size Elf_Rela: %2u - %2u\n", sizeof(Elf32_Rela), sizeof(Elf64_Rela));
; 1387 : #endif
; 1388 :     return;
; 1389 : }

	ret	0
elf_init ENDP
_TEXT	ENDS
END
