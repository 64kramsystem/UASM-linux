; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
patchmask DW	0f8ffH
	ORG $+6
patchchr2 DB	057H
	DB	044H
	DB	045H
	DB	043H
	DB	053H
	DB	041H
	DB	046H
	DB	047H
CONST	ENDS
_DATA	SEGMENT
$SG5472	DB	'F__RQQ', 00H
_DATA	ENDS
PUBLIC	AddFloatingPointEmulationFixup
EXTRN	store_fixup:NEAR
EXTRN	CreateFixup:NEAR
EXTRN	omf_FlushCurrSeg:NEAR
EXTRN	ModuleInfo:BYTE
EXTRN	Options:BYTE
EXTRN	write_to_file:BYTE
EXTRN	MakeExtern:NEAR
EXTRN	SymFind:NEAR
EXTRN	__ImageBase:BYTE
xdata	SEGMENT
$unwind$AddFloatingPointEmulationFixup DD 051301H
	DD	0cc413H
	DD	0e340eH
	DD	0c204H
xdata	ENDS
pdata	SEGMENT
$pdata$AddFloatingPointEmulationFixup DD @imagerel($LN23#)
	DD	@imagerel($LN23#+19)
	DD	@imagerel($unwind$AddFloatingPointEmulationFixup#)
pdata	ENDS
xdata	SEGMENT
$chain$5$AddFloatingPointEmulationFixup DD 086a21H
	DD	011746aH
	DD	0106462H
	DD	0f545aH
	DD	0bd405H
	DD	@imagerel($LN23#)
	DD	@imagerel($LN23#+19)
	DD	@imagerel($unwind$AddFloatingPointEmulationFixup#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$AddFloatingPointEmulationFixup DD @imagerel($LN23#+19)
	DD	@imagerel($LN23#+289)
	DD	@imagerel($chain$5$AddFloatingPointEmulationFixup#)
pdata	ENDS
xdata	SEGMENT
$chain$6$AddFloatingPointEmulationFixup DD 021H
	DD	@imagerel($LN23#)
	DD	@imagerel($LN23#+19)
	DD	@imagerel($unwind$AddFloatingPointEmulationFixup#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$AddFloatingPointEmulationFixup DD @imagerel($LN23#+289)
	DD	@imagerel($LN23#+415)
	DD	@imagerel($chain$6$AddFloatingPointEmulationFixup#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\fpfixup.c
pdata	ENDS
_TEXT	SEGMENT
data$ = 48
name$ = 56
sym$ = 64
CodeInfo$ = 112
AddFloatingPointEmulationFixup PROC NEAR

; 68   : {

$LN23:
	sub	rsp, 104				; 00000068H

; 69   :     int i;
; 70   :     enum fp_patches patch;
; 71   :     struct asym *sym[2];
; 72   :     struct fixup *fixup;
; 73   :     int_32 data;
; 74   :     char name[8] = "F__RQQ";

	lea	rdx, QWORD PTR name$[rsp]
	mov	QWORD PTR [rsp+112], rbx
	mov	QWORD PTR [rsp+96], r12
	mov	QWORD PTR [rsp+88], r13
	lea	r13, OFFSET FLAT:__ImageBase

; 75   : 
; 76   :     DebugMsg(("AddFloatingPointEmulationFixup enter, token=%u, regoverride=%d\n", CodeInfo->token, CodeInfo->prefix.RegOverride ));
; 77   : 
; 78   :     if( CodeInfo->token == T_FWAIT ) {

	xor	r12d, r12d
	mov	eax, DWORD PTR $SG5472[r13]
	mov	DWORD PTR [rdx], eax
	movzx	eax, WORD PTR $SG5472[r13+4]
	mov	WORD PTR [rdx+4], ax
	movzx	eax, BYTE PTR $SG5472[r13+6]
	mov	BYTE PTR [rdx+6], al
	xor	eax, eax
	cmp	DWORD PTR [rcx+24], 833			; 00000341H
	mov	BYTE PTR name$[rsp+7], al
	jne	SHORT $LN16@AddFloatin

; 79   :         patch = FPP_WAIT;

	mov	ebx, r12d
	jmp	SHORT $LN13@AddFloatin
$LN16@AddFloatin:

; 80   :     } else if ( CodeInfo->prefix.RegOverride == EMPTY ) {

	mov	ebx, DWORD PTR [rcx+4]
	cmp	ebx, -2
	jne	SHORT $LN14@AddFloatin

; 81   :         patch = FPP_NORMAL;

	mov	ebx, 1

; 82   :     } else {

	jmp	SHORT $LN13@AddFloatin
$LN14@AddFloatin:

; 83   :         patch = CodeInfo->prefix.RegOverride + 2;

	add	ebx, 2
$LN13@AddFloatin:
	mov	QWORD PTR [rsp+120], rbp
	mov	QWORD PTR [rsp+128], rsi
	mov	QWORD PTR [rsp+136], rdi

; 84   :     }
; 85   : 
; 86   :     /* emit 1-2 externals for the patch if not done already */
; 87   :     for ( i = 0; i < 2; i++ ) {

	lea	rdi, QWORD PTR sym$[rsp]
	mov	esi, r12d
	movsxd	rbp, ebx
	npad	8
$LL12@AddFloatin:

; 88   :         sym[i] = NULL;
; 89   :         if ( patchmask & ( 1 << ( i*8+patch ) ) ) {

	mov	ecx, ebx
	mov	eax, 1
	mov	QWORD PTR [rdi], r12
	shl	eax, cl
	test	eax, 63743				; 0000f8ffH
	je	SHORT $LN11@AddFloatin

; 90   :             name[1] = 'I' + i;

	lea	eax, DWORD PTR [rsi+73]

; 91   :             name[2] = patchchr2[patch];
; 92   :             sym[i] = SymSearch( name );

	lea	rcx, QWORD PTR name$[rsp]
	mov	BYTE PTR name$[rsp+1], al
	movzx	eax, BYTE PTR patchchr2[r13+rbp]
	mov	BYTE PTR name$[rsp+2], al
	call	SymFind

; 93   :             if( sym[i] == NULL || sym[i]->state == SYM_UNDEFINED ) {

	test	rax, rax
	mov	QWORD PTR [rdi], rax
	je	SHORT $LN7@AddFloatin
	cmp	DWORD PTR [rax+40], r12d
	jne	SHORT $LN11@AddFloatin
$LN7@AddFloatin:

; 94   :                 sym[i] = MakeExtern( name, MT_FAR, NULL, sym[i], USE16 );

	lea	rcx, QWORD PTR name$[rsp]
	mov	r9, rax
	xor	r8d, r8d
	mov	edx, 130				; 00000082H
	mov	BYTE PTR [rsp+32], r12b
	call	MakeExtern
	mov	QWORD PTR [rdi], rax

; 95   :                 sym[i]->langtype = LANG_NONE;

	mov	DWORD PTR [rax+84], r12d
$LN11@AddFloatin:
	inc	esi
	add	ebx, 8
	add	rdi, 8
	cmp	esi, 2
	jl	SHORT $LL12@AddFloatin

; 96   :             }
; 97   :         }
; 98   :     }
; 99   : 
; 100  :     /* no need for fixups if no object file is written */
; 101  :     if ( write_to_file == FALSE )

	cmp	BYTE PTR write_to_file, r12b
	mov	r13, QWORD PTR [rsp+88]
	mov	rdi, QWORD PTR [rsp+136]
	mov	rsi, QWORD PTR [rsp+128]
	mov	rbp, QWORD PTR [rsp+120]
	je	SHORT $LN2@AddFloatin

; 102  :         return;
; 103  : 
; 104  :     /* make sure the next 3 bytes in code stream aren't separated.
; 105  :      * The first fixup covers bytes $+0 and $+1, the (possible) second
; 106  :      * fixup covers bytes $+1 and $+2.
; 107  :      */
; 108  :     if( Options.output_format == OFORMAT_OMF &&
; 109  :        ( CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc + 3 ) > MAX_LEDATA_THRESHOLD )

	cmp	DWORD PTR Options+156, 1
	jne	SHORT $LN5@AddFloatin
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rcx+12]
	sub	eax, DWORD PTR [rcx+8]
	add	eax, 3
	cmp	eax, 1014				; 000003f6H
	jbe	SHORT $LN5@AddFloatin

; 110  :         omf_FlushCurrSeg();

	call	omf_FlushCurrSeg
$LN5@AddFloatin:

; 111  : 
; 112  :     for ( i = 0; i < 2 ; i++ ) {

	mov	ebx, r12d
	npad	3
$LL4@AddFloatin:

; 113  :         if ( sym[i] ) {

	movsxd	rax, ebx
	mov	rcx, QWORD PTR sym$[rsp+rax*8]
	test	rcx, rcx
	je	SHORT $LN3@AddFloatin

; 114  :             fixup = CreateFixup( sym[i], FIX_OFF16, OPTJ_NONE );

	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+5]
	call	CreateFixup

; 115  :             fixup->frame_type = FRAME_TARG;
; 116  :             /* assume locofs has been set inside CreateFixup() */
; 117  :             //fixup->locofs = CurrSeg->e.seginfo->current_loc + i;
; 118  :             fixup->locofs += i;
; 119  :             data = 0;
; 120  :             store_fixup( fixup, CurrSeg, &data );

	lea	r8, QWORD PTR data$[rsp]
	add	DWORD PTR [rax+20], ebx
	mov	BYTE PTR [rax+40], 5
	mov	rdx, QWORD PTR ModuleInfo+432
	mov	rcx, rax
	mov	DWORD PTR data$[rsp], r12d
	call	store_fixup
$LN3@AddFloatin:
	inc	ebx
	cmp	ebx, 2
	jl	SHORT $LL4@AddFloatin
$LN2@AddFloatin:
	mov	r12, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [rsp+112]

; 121  :         }
; 122  :     }
; 123  :     return;
; 124  : }

	add	rsp, 104				; 00000068H
	ret	0
AddFloatingPointEmulationFixup ENDP
_TEXT	ENDS
END
