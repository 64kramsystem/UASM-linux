; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	UseSavedState:BYTE
COMM	StoreState:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	LineStoreCurr:QWORD
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
$SG5458	DB	'OUT', 00H
_DATA	ENDS
EXTRN	ContextSaveState:NEAR
EXTRN	AssumeSaveState:NEAR
EXTRN	SegmentSaveState:NEAR
EXTRN	ModuleInfo:BYTE
EXTRN	memcpy:NEAR
_BSS	SEGMENT
modstate DB	01e0H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$SaveState DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SaveState DD @imagerel(SaveState#)
	DD	@imagerel(SaveState#+85)
	DD	@imagerel($unwind$SaveState#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\fastpass.c
pdata	ENDS
_TEXT	SEGMENT
SaveState PROC NEAR

; 51   : {

	sub	rsp, 40					; 00000028H

; 52   :     DebugMsg1(("SaveState enter\n" ));
; 53   :     StoreState = TRUE;
; 54   :     UseSavedState = TRUE;
; 55   :     modstate.init = TRUE;
; 56   :     modstate.Equ.head = modstate.Equ.tail = NULL;

	xor	eax, eax

; 57   : 
; 58   :     memcpy( &modstate.modinfo, (uint_8 *)&ModuleInfo + sizeof( struct module_vars ), sizeof( modstate.modinfo ) );

	lea	rcx, OFFSET FLAT:modstate+24
	lea	rdx, OFFSET FLAT:ModuleInfo+320
	mov	r8d, 456				; 000001c8H
	mov	BYTE PTR StoreState, 1
	mov	BYTE PTR UseSavedState, 1
	mov	BYTE PTR modstate, 1
	mov	QWORD PTR modstate+16, rax
	mov	QWORD PTR modstate+8, rax
	call	memcpy

; 59   : 
; 60   :     SegmentSaveState();

	call	SegmentSaveState

; 61   :     AssumeSaveState();

	call	AssumeSaveState

; 62   :     ContextSaveState(); /* save pushcontext/popcontext stack */
; 63   : 
; 64   :     DebugMsg(( "SaveState exit\n" ));
; 65   : }

	add	rsp, 40					; 00000028H
	jmp	ContextSaveState
SaveState ENDP
_TEXT	ENDS
PUBLIC	StoreLine
EXTRN	isalnum:NEAR
EXTRN	_memicmp:NEAR
EXTRN	isspace:NEAR
EXTRN	list_pos:DWORD
EXTRN	get_curr_srcfile:NEAR
EXTRN	MacroLevel:BYTE
EXTRN	GetLineNumber:NEAR
EXTRN	LclAlloc:NEAR
_BSS	SEGMENT
LineStore DB	010H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$StoreLine DD 071a01H
	DD	08641aH
	DD	075415H
	DD	063410H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$StoreLine DD @imagerel($LN26#)
	DD	@imagerel($LN26#+132)
	DD	@imagerel($unwind$StoreLine#)
pdata	ENDS
xdata	SEGMENT
$chain$3$StoreLine DD 020521H
	DD	097405H
	DD	@imagerel($LN26#)
	DD	@imagerel($LN26#+132)
	DD	@imagerel($unwind$StoreLine#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$StoreLine DD @imagerel($LN26#+132)
	DD	@imagerel($LN26#+149)
	DD	@imagerel($chain$3$StoreLine#)
pdata	ENDS
xdata	SEGMENT
$chain$4$StoreLine DD 020521H
	DD	04c405H
	DD	@imagerel($LN26#+132)
	DD	@imagerel($LN26#+149)
	DD	@imagerel($chain$3$StoreLine#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$StoreLine DD @imagerel($LN26#+149)
	DD	@imagerel($LN26#+440)
	DD	@imagerel($chain$4$StoreLine#)
pdata	ENDS
xdata	SEGMENT
$chain$5$StoreLine DD 021H
	DD	@imagerel($LN26#+132)
	DD	@imagerel($LN26#+149)
	DD	@imagerel($chain$3$StoreLine#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$StoreLine DD @imagerel($LN26#+440)
	DD	@imagerel($LN26#+542)
	DD	@imagerel($chain$5$StoreLine#)
pdata	ENDS
xdata	SEGMENT
$chain$6$StoreLine DD 021H
	DD	@imagerel($LN26#)
	DD	@imagerel($LN26#+132)
	DD	@imagerel($unwind$StoreLine#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$StoreLine DD @imagerel($LN26#+542)
	DD	@imagerel($LN26#+609)
	DD	@imagerel($chain$6$StoreLine#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
srcline$ = 48
flags$ = 56
lst_position$ = 64
StoreLine PROC NEAR

; 69   : {

$LN26:
	sub	rsp, 40					; 00000028H

; 70   :     int i,j;
; 71   :     char *p;
; 72   : 
; 73   : #ifdef DEBUG_OUT
; 74   :     if ( Options.nofastpass )
; 75   :         return;
; 76   : #endif
; 77   :     if ( ModuleInfo.GeneratedCode ) /* don't store generated lines! */

	cmp	DWORD PTR ModuleInfo+456, 0
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	ebp, r8d
	mov	ebx, edx
	mov	rsi, rcx
	jne	$LN15@StoreLine

; 78   :         return;
; 79   :     if ( StoreState == FALSE ) /* line store already started? */

	cmp	BYTE PTR StoreState, 0
	jne	SHORT $LN19@StoreLine

; 80   :         SaveState();

	lea	rcx, OFFSET FLAT:modstate+24
	lea	rdx, OFFSET FLAT:ModuleInfo+320
	mov	r8d, 456				; 000001c8H
	mov	BYTE PTR StoreState, 1
	mov	BYTE PTR UseSavedState, 1
	mov	BYTE PTR modstate, 1
	mov	QWORD PTR modstate+16, 0
	mov	QWORD PTR modstate+8, 0
	call	memcpy
	call	SegmentSaveState
	call	AssumeSaveState
	call	ContextSaveState
$LN19@StoreLine:
	mov	QWORD PTR [rsp+72], rdi

; 81   : 
; 82   :     i = strlen( srcline );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rsi
	mov	QWORD PTR [rsp+32], r12
	repne scasb

; 83   :     j = ( ( ( flags & 1 ) && ModuleInfo.CurrComment ) ? strlen( ModuleInfo.CurrComment ) : 0 );

	test	bl, 1
	not	rcx
	lea	r12, QWORD PTR [rcx-1]
	je	SHORT $LN17@StoreLine
	mov	rdi, QWORD PTR ModuleInfo+472
	test	rdi, rdi
	je	SHORT $LN17@StoreLine
	mov	rcx, -1
	repne scasb
	not	rcx
	lea	rbx, QWORD PTR [rcx-1]
	jmp	SHORT $LN18@StoreLine
$LN17@StoreLine:
	xor	ebx, ebx
$LN18@StoreLine:

; 84   :     LineStoreCurr = LclAlloc( i + j + sizeof( struct line_item ) );

	lea	eax, DWORD PTR [rbx+r12]
	movsxd	rcx, eax
	add	rcx, 24
	call	LclAlloc
	mov	QWORD PTR LineStoreCurr, rax

; 85   :     LineStoreCurr->next = NULL;

	mov	QWORD PTR [rax], 0

; 86   :     LineStoreCurr->lineno = GetLineNumber();

	call	GetLineNumber
	mov	rdx, QWORD PTR LineStoreCurr
	mov	ecx, DWORD PTR [rdx+8]
	xor	ecx, eax
	and	ecx, 1048575				; 000fffffH
	xor	DWORD PTR [rdx+8], ecx

; 87   :     if ( MacroLevel ) {

	cmp	BYTE PTR MacroLevel, 0
	je	SHORT $LN12@StoreLine

; 88   :         LineStoreCurr->srcfile = 0xfff;

	mov	rax, QWORD PTR LineStoreCurr
	or	DWORD PTR [rax+8], -1048576		; fff00000H

; 89   :     } else {

	jmp	SHORT $LN11@StoreLine
$LN12@StoreLine:

; 90   :         LineStoreCurr->srcfile = get_curr_srcfile();

	call	get_curr_srcfile
	mov	rdx, QWORD PTR LineStoreCurr
	mov	ecx, DWORD PTR [rdx+8]
	shl	eax, 20
	and	ecx, 1048575				; 000fffffH
	or	ecx, eax
	mov	DWORD PTR [rdx+8], ecx
$LN11@StoreLine:

; 91   :     }
; 92   :     LineStoreCurr->list_pos = ( lst_position ? lst_position : list_pos );

	mov	ecx, DWORD PTR list_pos
	mov	rax, QWORD PTR LineStoreCurr
	test	ebp, ebp
	cmovne	ecx, ebp

; 93   :     if ( j ) {

	test	ebx, ebx
	mov	DWORD PTR [rax+12], ecx
	je	SHORT $LN10@StoreLine

; 94   :         memcpy( LineStoreCurr->line, srcline, i );

	mov	rcx, QWORD PTR LineStoreCurr
	movsxd	rdi, r12d
	mov	rdx, rsi
	add	rcx, 16
	mov	r8, rdi
	call	memcpy

; 95   :         memcpy( LineStoreCurr->line + i, ModuleInfo.CurrComment, j + 1 );

	mov	rax, QWORD PTR LineStoreCurr
	lea	edx, DWORD PTR [rbx+1]
	movsxd	r8, edx
	mov	rdx, QWORD PTR ModuleInfo+472
	lea	rcx, QWORD PTR [rdi+rax+16]
	call	memcpy

; 96   :     } else

	jmp	SHORT $LN9@StoreLine
$LN10@StoreLine:

; 97   :         memcpy( LineStoreCurr->line, srcline, i + 1 );

	mov	rcx, QWORD PTR LineStoreCurr
	lea	eax, DWORD PTR [r12+1]
	mov	rdx, rsi
	add	rcx, 16
	movsxd	r8, eax
	call	memcpy
$LN9@StoreLine:

; 98   : 
; 99   :     DebugMsg1(("StoreLine(>%s<, lst_position=%u): cur=%X\n", LineStoreCurr->line, lst_position, LineStoreCurr ));
; 100  : 
; 101  :     /* v2.08: don't store % operator at pos 0 */
; 102  :     for ( p = LineStoreCurr->line; *p && isspace(*p); p++ );

	mov	rdi, QWORD PTR LineStoreCurr
	mov	r12, QWORD PTR [rsp+32]
	add	rdi, 16
	cmp	BYTE PTR [rdi], 0
	je	SHORT $LN25@StoreLine
$LL8@StoreLine:
	movsx	ecx, BYTE PTR [rdi]
	call	isspace
	test	eax, eax
	je	SHORT $LN25@StoreLine
	inc	rdi
	cmp	BYTE PTR [rdi], 0
	jne	SHORT $LL8@StoreLine
$LN25@StoreLine:

; 103  :     if (*p == '%' && ( _memicmp( p+1, "OUT", 3 ) || is_valid_id_char( *(p+4) ) ) )

	cmp	BYTE PTR [rdi], 37			; 00000025H
	jne	SHORT $LN24@StoreLine
	lea	rcx, QWORD PTR [rdi+1]
	lea	rdx, OFFSET FLAT:$SG5458
	mov	r8d, 3
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN3@StoreLine
	movsx	ecx, BYTE PTR [rdi+4]
	call	isalnum
	test	eax, eax
	jne	SHORT $LN3@StoreLine
	movzx	eax, BYTE PTR [rdi+4]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN3@StoreLine
	cmp	al, 64					; 00000040H
	je	SHORT $LN3@StoreLine
	cmp	al, 36					; 00000024H
	je	SHORT $LN3@StoreLine
	cmp	al, 63					; 0000003fH
	jne	SHORT $LN24@StoreLine
$LN3@StoreLine:

; 104  :         *p = ' ';

	mov	BYTE PTR [rdi], 32			; 00000020H
$LN24@StoreLine:

; 105  : 
; 106  : #ifdef DEBUG_OUT
; 107  :     if ( Options.print_linestore )
; 108  :         printf("%s\n", LineStoreCurr->line );
; 109  : #endif
; 110  :     if ( LineStore.head )

	cmp	QWORD PTR LineStore, 0
	mov	rdi, QWORD PTR [rsp+72]
	je	SHORT $LN2@StoreLine

; 111  :         LineStore.tail->next = LineStoreCurr;

	mov	rax, QWORD PTR LineStore+8
	mov	rcx, QWORD PTR LineStoreCurr
	mov	QWORD PTR [rax], rcx

; 112  :     else

	jmp	SHORT $LN1@StoreLine
$LN2@StoreLine:

; 113  :         LineStore.head = LineStoreCurr;

	mov	rax, QWORD PTR LineStoreCurr
	mov	QWORD PTR LineStore, rax
$LN1@StoreLine:

; 114  :     LineStore.tail = LineStoreCurr;

	mov	rax, QWORD PTR LineStoreCurr
	mov	QWORD PTR LineStore+8, rax
$LN15@StoreLine:
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 115  : }

	add	rsp, 40					; 00000028H
	ret	0
StoreLine ENDP
_TEXT	ENDS
PUBLIC	SkipSavedState
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
SkipSavedState PROC NEAR

; 124  :     DebugMsg(("SkipSavedState enter\n"));
; 125  :     UseSavedState = FALSE;

	mov	BYTE PTR UseSavedState, 0

; 126  : }

	ret	0
SkipSavedState ENDP
_TEXT	ENDS
PUBLIC	SaveVariableState
xdata	SEGMENT
$unwind$SaveVariableState DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$SaveVariableState DD @imagerel($LN6#)
	DD	@imagerel($LN6#+112)
	DD	@imagerel($unwind$SaveVariableState#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
SaveVariableState PROC NEAR

; 141  : {

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H

; 142  :     struct equ_item *p;
; 143  : 
; 144  :     DebugMsg1(( "SaveVariableState(%s)=%d\n", sym->name, sym->value ));
; 145  :     sym->issaved = TRUE; /* don't try to save this symbol (anymore) */

	or	BYTE PTR [rcx+49], 16
	mov	rbx, rcx

; 146  :     p = LclAlloc( sizeof( struct equ_item ) );

	mov	ecx, 32					; 00000020H
	call	LclAlloc

; 147  :     p->next = NULL;

	mov	QWORD PTR [rax], 0

; 148  :     p->sym = sym;

	mov	QWORD PTR [rax+8], rbx

; 149  :     p->lvalue    = sym->value;

	mov	edx, DWORD PTR [rbx+16]
	mov	DWORD PTR [rax+16], edx

; 150  :     p->hvalue    = sym->value3264; /* v2.05: added */

	mov	edx, DWORD PTR [rbx+64]
	mov	DWORD PTR [rax+20], edx

; 151  :     p->mem_type  = sym->mem_type;  /* v2.07: added */

	mov	edx, DWORD PTR [rbx+44]
	mov	DWORD PTR [rax+24], edx

; 152  :     p->isdefined = sym->isdefined;

	movzx	ecx, BYTE PTR [rbx+48]
	shr	cl, 1
	and	cl, 1
	mov	BYTE PTR [rax+28], cl

; 153  :     if ( modstate.Equ.tail ) {

	mov	rcx, QWORD PTR modstate+16
	test	rcx, rcx
	je	SHORT $LN2@SaveVariab

; 154  :         modstate.Equ.tail->next = p;

	mov	QWORD PTR [rcx], rax

; 155  :         modstate.Equ.tail = p;
; 156  :     } else {
; 157  :         modstate.Equ.head = modstate.Equ.tail = p;

	mov	QWORD PTR modstate+16, rax

; 158  :     }
; 159  : //    printf("state of symbol >%s< saved, value=%u, defined=%u\n", sym->name, sym->value, sym->defined);
; 160  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@SaveVariab:

; 155  :         modstate.Equ.tail = p;
; 156  :     } else {
; 157  :         modstate.Equ.head = modstate.Equ.tail = p;

	mov	QWORD PTR modstate+8, rax
	mov	QWORD PTR modstate+16, rax

; 158  :     }
; 159  : //    printf("state of symbol >%s< saved, value=%u, defined=%u\n", sym->name, sym->value, sym->defined);
; 160  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
SaveVariableState ENDP
_TEXT	ENDS
PUBLIC	RestoreState
EXTRN	SymSetCmpFunc:NEAR
EXTRN	SetOfssize:NEAR
xdata	SEGMENT
$unwind$RestoreState DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$RestoreState DD @imagerel($LN10#)
	DD	@imagerel($LN10#+135)
	DD	@imagerel($unwind$RestoreState#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
RestoreState PROC NEAR

; 164  : {

$LN10:
	sub	rsp, 40					; 00000028H

; 165  :     DebugMsg1(("RestoreState enter\n"));
; 166  :     if ( modstate.init ) {

	cmp	BYTE PTR modstate, 0
	je	SHORT $LN9@RestoreSta

; 167  :         struct equ_item *curr;
; 168  :         /* restore values of assembly time variables */
; 169  :         for ( curr = modstate.Equ.head; curr; curr = curr->next ) {

	mov	rdx, QWORD PTR modstate+8
	test	rdx, rdx
	je	SHORT $LN1@RestoreSta
	npad	7
$LL3@RestoreSta:

; 170  :             DebugMsg1(("RestoreState: sym >%s<, value=%Xh (hvalue=%Xh), defined=%u\n", curr->sym->name, curr->lvalue, curr->hvalue, curr->isdefined ));
; 171  :             /* v2.07: MT_ABS is obsolete */
; 172  :             //if ( curr->sym->mem_type == MT_ABS ) {
; 173  :                 curr->sym->value     = curr->lvalue;

	mov	rcx, QWORD PTR [rdx+8]
	mov	eax, DWORD PTR [rdx+16]
	mov	DWORD PTR [rcx+16], eax

; 174  :                 curr->sym->value3264 = curr->hvalue;

	mov	rcx, QWORD PTR [rdx+8]
	mov	eax, DWORD PTR [rdx+20]
	mov	DWORD PTR [rcx+64], eax

; 175  :                 curr->sym->mem_type  = curr->mem_type; /* v2.07: added */

	mov	rcx, QWORD PTR [rdx+8]
	mov	eax, DWORD PTR [rdx+24]
	mov	DWORD PTR [rcx+44], eax

; 176  :                 curr->sym->isdefined = curr->isdefined;

	movzx	eax, BYTE PTR [rdx+28]
	mov	rcx, QWORD PTR [rdx+8]
	add	al, al
	xor	al, BYTE PTR [rcx+48]
	and	al, 2
	xor	BYTE PTR [rcx+48], al
	mov	rdx, QWORD PTR [rdx]
	test	rdx, rdx
	jne	SHORT $LL3@RestoreSta
$LN1@RestoreSta:

; 177  :             //}
; 178  :         }
; 179  :         /* fields in module_vars are not to be restored.
; 180  :          * v2.10: the module_vars fields are not saved either.
; 181  :          */
; 182  :         //memcpy( &modstate.modinfo.g, &ModuleInfo.g, sizeof( ModuleInfo.g ) );
; 183  :         memcpy( (char *)&ModuleInfo + sizeof( struct module_vars ), &modstate.modinfo, sizeof( modstate.modinfo ) );

	lea	rcx, OFFSET FLAT:ModuleInfo+320
	lea	rdx, OFFSET FLAT:modstate+24
	mov	r8d, 456				; 000001c8H
	call	memcpy

; 184  :         SetOfssize();

	call	SetOfssize

; 185  :         SymSetCmpFunc();

	call	SymSetCmpFunc
$LN9@RestoreSta:

; 186  :     }
; 187  : 
; 188  : #if 0
; 189  :     /* v2.05: AFAICS this can't happen anymore. */
; 190  :     if ( LineStore.head == NULL ) {
; 191  :         struct line_item *endl = LclAlloc( sizeof( struct line_item ) + 3 );
; 192  :         endl->next = NULL;
; 193  :         endl->srcfile = 0;
; 194  :         endl->lineno = GetLineNumber();
; 195  :         endl->list_pos = 0;
; 196  :         strcpy( endl->line, "END");
; 197  :         LineStore.head = endl;
; 198  :         DebugMsg(("RestoreState: LineStore.head was NULL !!!\n" ));
; 199  :     }
; 200  : #endif
; 201  :     return( LineStore.head );

	mov	rax, QWORD PTR LineStore

; 202  : }

	add	rsp, 40					; 00000028H
	ret	0
RestoreState ENDP
_TEXT	ENDS
PUBLIC	FastpassInit
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
FastpassInit PROC NEAR

; 224  :     StoreState = FALSE;
; 225  :     modstate.init = FALSE;
; 226  :     LineStore.head = NULL;

	xor	eax, eax
	mov	BYTE PTR StoreState, 0
	mov	BYTE PTR modstate, 0
	mov	QWORD PTR LineStore, rax

; 227  :     LineStore.tail = NULL;

	mov	QWORD PTR LineStore+8, rax

; 228  :     UseSavedState = FALSE;

	mov	BYTE PTR UseSavedState, al

; 229  : }

	ret	0
FastpassInit ENDP
_TEXT	ENDS
END
