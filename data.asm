; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG6178	DB	01H DUP (?)
$SG6173	DB	01H DUP (?)
$SG6168	DB	01H DUP (?)
$SG6113	DB	01H DUP (?)
$SG6109	DB	01H DUP (?)
$SG6105	DB	01H DUP (?)
$SG5861	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
$SG5972	DB	'%f', 00H
	ORG $+1
$SG6031	DB	'(', 00H
	ORG $+2
$SG6045	DB	')', 00H
	ORG $+2
$SG6059	DB	'BSS', 00H
$SG6060	DB	'AT', 00H
_DATA	ENDS
EXTRN	FillDataBytes:NEAR
EXTRN	SetCurrOffset:NEAR
EXTRN	EmitErr:NEAR
EXTRN	Tokenize:NEAR
EXTRN	ModuleInfo:BYTE
EXTRN	SizeFromMemtype:NEAR
EXTRN	GetCurrOffset:NEAR
xdata	SEGMENT
$unwind$InitializeArray DD 0123001H
	DD	0df430H
	DD	0ee426H
	DD	0fd422H
	DD	010c41eH
	DD	015741aH
	DD	0146416H
	DD	0135412H
	DD	012340eH
	DD	011010aH
xdata	ENDS
pdata	SEGMENT
$pdata$InitializeArray DD @imagerel(InitializeArray#)
	DD	@imagerel(InitializeArray#+730)
	DD	@imagerel($unwind$InitializeArray#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\data.c
pdata	ENDS
_TEXT	SEGMENT
lvl$ = 80
j$ = 84
f$ = 144
pi$ = 152
tokenarray$ = 160
InitializeArray PROC NEAR

; 75   : {

	mov	rax, rsp
	sub	rsp, 136				; 00000088H
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	QWORD PTR [rax-8], r12
	mov	QWORD PTR [rax-16], r13
	mov	QWORD PTR [rax-24], r14

; 76   :     uint_32 oldofs;
; 77   :     uint_32 no_of_bytes;
; 78   :     int  i = *pi;

	movsxd	r14, DWORD PTR [rdx]
	mov	r12, r8
	mov	QWORD PTR [rax-32], r15
	mov	rbx, rdx
	mov	rsi, rcx

; 79   :     int  j;
; 80   :     int  lvl;
; 81   :     int old_tokencount;
; 82   :     char bArray;
; 83   :     ret_code rc;
; 84   : 
; 85   :     oldofs = GetCurrOffset();

	call	GetCurrOffset

; 86   :     no_of_bytes = SizeFromMemtype( f->sym.mem_type, USE_EMPTY, f->sym.type );

	mov	r8, QWORD PTR [rsi+88]
	mov	ecx, DWORD PTR [rsi+44]
	mov	edx, 254				; 000000feH
	mov	r15d, eax
	call	SizeFromMemtype

; 87   : 
; 88   :     DebugMsg1(("InitializeArray(%s) enter, items=%" I32_SPEC "u size=%" I32_SPEC "u mem_type=%xh type=%s currofs=%" I32_SPEC "X [%s]\n",
; 89   :                f->sym.name, f->sym.total_length, no_of_bytes, f->sym.mem_type,
; 90   :                f->sym.type ? f->sym.type->name : "NULL", oldofs, tokenarray[i].tokpos ));
; 91   : 
; 92   :     /* If current item is a literal enclosed in <> or {}, just use this
; 93   :      * item. Else, use all items until a comma or EOL is found.
; 94   :      */
; 95   : 
; 96   :     if ( tokenarray[i].token != T_STRING ||
; 97   :          ( tokenarray[i].string_delim != '<' &&
; 98   :            tokenarray[i].string_delim != '{' )) {

	mov	r9, r14
	shl	r9, 5
	cmp	BYTE PTR [r9+r12], 9
	mov	r13d, eax
	lea	rdi, QWORD PTR [r9+r12]
	jne	$LN28@Initialize
	movzx	ecx, BYTE PTR [rdi+1]
	cmp	cl, 60					; 0000003cH
	je	SHORT $LN29@Initialize
	cmp	cl, 123					; 0000007bH
	jne	$LN28@Initialize
$LN29@Initialize:

; 131  :         }
; 132  : 
; 133  :     } else {
; 134  : 
; 135  :         /* initializer is a literal */
; 136  :         (*pi)++;

	inc	DWORD PTR [rbx]

; 137  :         old_tokencount = Token_Count;
; 138  :         j = Token_Count + 1;
; 139  :         /* if the string is empty, use the default initializer */
; 140  :         if ( tokenarray[i].stringlen == 0 ) {

	cmp	DWORD PTR [rdi+16], 0
	mov	ebx, DWORD PTR ModuleInfo+496
	lea	edx, DWORD PTR [rbx+1]
	mov	DWORD PTR j$[rsp], edx
	jne	SHORT $LN9@Initialize

; 141  :             Token_Count = Tokenize( (char *)f->ivalue, j, tokenarray, TOK_RESCAN );

	lea	rcx, QWORD PTR [rsi+112]
	mov	r9d, 1
	mov	r8, r12
	call	Tokenize
	mov	r11d, eax
	mov	DWORD PTR ModuleInfo+496, eax

; 142  :         } else {

	jmp	SHORT $LN8@Initialize
$LN9@Initialize:

; 143  :             Token_Count = Tokenize( tokenarray[i].string_ptr, j, tokenarray, TOK_RESCAN );

	mov	rcx, QWORD PTR [rdi+8]
	mov	r9d, 1
	mov	r8, r12
	call	Tokenize
	mov	r11d, eax
	mov	DWORD PTR ModuleInfo+496, eax
$LN8@Initialize:

; 144  :         }
; 145  :         rc = data_item( &j, tokenarray, NULL, no_of_bytes, f->sym.type, 1, FALSE, f->sym.mem_type & MT_FLOAT, FALSE, Token_Count );

	movzx	eax, BYTE PTR [rsi+44]
	mov	DWORD PTR [rsp+72], r11d
	mov	BYTE PTR [rsp+64], 0
	and	al, 32					; 00000020H
	lea	rcx, QWORD PTR j$[rsp]
	mov	r9d, r13d
	mov	BYTE PTR [rsp+56], al
	mov	rax, QWORD PTR [rsi+88]
	mov	BYTE PTR [rsp+48], 0
	xor	r8d, r8d
	mov	rdx, r12
	mov	DWORD PTR [rsp+40], 1
	mov	QWORD PTR [rsp+32], rax
	call	data_item

; 146  :         Token_Count = old_tokencount;

	mov	DWORD PTR ModuleInfo+496, ebx
	mov	ebp, eax
	jmp	$LN11@Initialize
$LN28@Initialize:

; 99   : 
; 100  :         /* scan for comma or final. Ignore commas inside DUP argument */
; 101  :         for( j = i, lvl = 0, bArray = FALSE; tokenarray[j].token != T_FINAL; j++ ) {

	xor	ebp, ebp
	mov	DWORD PTR j$[rsp], r14d
	xor	r9b, r9b
	mov	ecx, ebp
	mov	DWORD PTR lvl$[rsp], ebp
	mov	r8d, r14d
	cmp	BYTE PTR [rdi], cl
	je	SHORT $LN35@Initialize
	mov	rdx, rdi
	npad	5
$LL27@Initialize:

; 102  :             if ( tokenarray[j].token == T_OP_BRACKET )

	movzx	eax, BYTE PTR [rdx]
	cmp	al, 40					; 00000028H
	jne	SHORT $LN24@Initialize

; 103  :                 lvl++;

	inc	ecx
	mov	DWORD PTR lvl$[rsp], ecx
	jmp	SHORT $LN26@Initialize
$LN24@Initialize:

; 104  :             else if ( tokenarray[j].token == T_CL_BRACKET )

	cmp	al, 41					; 00000029H
	jne	SHORT $LN22@Initialize

; 105  :                 lvl--;

	dec	ecx
	mov	DWORD PTR lvl$[rsp], ecx
	jmp	SHORT $LN26@Initialize
$LN22@Initialize:

; 106  :             else if ( lvl == 0 && tokenarray[j].token == T_COMMA )

	test	ecx, ecx
	jne	SHORT $LN20@Initialize
	cmp	al, 44					; 0000002cH
	je	SHORT $LN35@Initialize
$LN20@Initialize:

; 107  :                 break;
; 108  :             else if ( tokenarray[j].token == T_RES_ID && tokenarray[j].tokval == T_DUP )

	cmp	al, 7
	jne	SHORT $LN18@Initialize
	cmp	DWORD PTR [rdx+16], 259			; 00000103H
	jne	SHORT $LN18@Initialize

; 109  :                 bArray = TRUE;

	mov	r9b, 1

; 110  :             else if ( no_of_bytes == 1 && tokenarray[j].token == T_STRING &&

	jmp	SHORT $LN26@Initialize
$LN18@Initialize:

; 111  :                      ( tokenarray[j].string_delim == '"' || tokenarray[j].string_delim == '\'' ))

	cmp	r13d, 1
	jne	SHORT $LN26@Initialize
	cmp	al, 9
	jne	SHORT $LN26@Initialize
	movzx	eax, BYTE PTR [rdx+1]
	cmp	al, 34					; 00000022H
	je	SHORT $LN15@Initialize
	cmp	al, 39					; 00000027H
	jne	SHORT $LN26@Initialize
$LN15@Initialize:

; 112  :                 bArray = TRUE;

	mov	r9b, 1
$LN26@Initialize:

; 99   : 
; 100  :         /* scan for comma or final. Ignore commas inside DUP argument */
; 101  :         for( j = i, lvl = 0, bArray = FALSE; tokenarray[j].token != T_FINAL; j++ ) {

	inc	r8d
	movsxd	rax, r8d
	mov	DWORD PTR j$[rsp], r8d
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], bpl
	lea	rdx, QWORD PTR [rax+r12]
	jne	SHORT $LL27@Initialize
$LN35@Initialize:

; 113  :         }
; 114  :         *pi = j;
; 115  : 
; 116  :         if ( bArray == FALSE ) {

	test	r9b, r9b
	mov	DWORD PTR [rbx], r8d
	jne	SHORT $LN14@Initialize

; 117  :             DebugMsg1(("InitializeArray(%s): error, array init requires DUP, string or literal\n", f->sym.name ));
; 118  :             return( EmitErr( INITIALIZER_MUST_BE_A_STRING_OR_SINGLE_ITEM, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdi+24]
	mov	ecx, 152				; 00000098H
	call	EmitErr
	jmp	$LN30@Initialize
$LN14@Initialize:

; 119  :         }
; 120  : 
; 121  :         lvl = tokenarray[j].tokpos - tokenarray[i].tokpos;

	movsxd	rax, r8d
	shl	rax, 5
	mov	ecx, DWORD PTR [rax+r12+24]
	sub	ecx, DWORD PTR [rdi+24]

; 122  : 
; 123  :         /* v2.07: accept an "empty" quoted string as array initializer for byte arrays */
; 124  :         if ( lvl == 2 &&
; 125  :             f->sym.total_size == f->sym.total_length &&
; 126  :             ( tokenarray[i].string_delim == '"' || tokenarray[i].string_delim == '\'' ) )

	cmp	ecx, 2
	mov	DWORD PTR lvl$[rsp], ecx
	jne	SHORT $LN13@Initialize
	mov	eax, DWORD PTR [rsi+72]
	cmp	DWORD PTR [rsi+64], eax
	jne	SHORT $LN13@Initialize
	movzx	eax, BYTE PTR [rdi+1]
	cmp	al, 34					; 00000022H
	je	SHORT $LN11@Initialize
	cmp	al, 39					; 00000027H

; 127  :             rc = NOT_ERROR;
; 128  :         else {

	je	SHORT $LN11@Initialize
$LN13@Initialize:

; 129  :             lvl = i; /* i must remain the start index */
; 130  :             rc = data_item( &lvl, tokenarray, NULL, no_of_bytes, f->sym.type, 1, FALSE, f->sym.mem_type & MT_FLOAT, FALSE, j );

	movzx	eax, BYTE PTR [rsi+44]
	mov	DWORD PTR [rsp+72], r8d
	mov	BYTE PTR [rsp+64], bpl
	and	al, 32					; 00000020H
	lea	rcx, QWORD PTR lvl$[rsp]
	mov	r9d, r13d
	mov	BYTE PTR [rsp+56], al
	mov	rax, QWORD PTR [rsi+88]
	mov	BYTE PTR [rsp+48], bpl
	xor	r8d, r8d
	mov	rdx, r12
	mov	DWORD PTR [rsp+40], 1
	mov	QWORD PTR [rsp+32], rax
	mov	DWORD PTR lvl$[rsp], r14d
	call	data_item
	mov	ebp, eax
$LN11@Initialize:

; 147  :     }
; 148  : 
; 149  :     /* get size of array items */
; 150  :     no_of_bytes = GetCurrOffset() - oldofs ;

	call	GetCurrOffset

; 151  :     DebugMsg1(("InitializeArray(%s): new offset=%X\n", f->sym.name, no_of_bytes + oldofs ));
; 152  : 
; 153  :     if ( no_of_bytes > f->sym.total_size ) {

	mov	edx, DWORD PTR [rsi+64]
	mov	r11d, eax
	sub	r11d, r15d
	cmp	r11d, edx
	jbe	SHORT $LN7@Initialize

; 154  :         DebugMsg1(("InitializeArray(%s): error, cursize=%u total_size=%u\n", f->sym.name, no_of_bytes, f->sym.total_size ));
; 155  :         EmitErr( TOO_MANY_INITIAL_VALUES_FOR_ARRAY, tokenarray[i].tokpos );

	mov	rdx, QWORD PTR [rdi+24]
	mov	ecx, 154				; 0000009aH
	call	EmitErr

; 156  :         rc = ERROR;

	mov	ebp, -1
	jmp	SHORT $LN3@Initialize
$LN7@Initialize:

; 157  :     } else if ( no_of_bytes < f->sym.total_size ) {

	cmp	r11d, edx
	jae	SHORT $LN3@Initialize

; 158  :         char filler = NULLC;
; 159  :         DebugMsg1(("InitializeArray: remaining bytes=%" I32_SPEC "u\n", f->sym.total_size - no_of_bytes ));
; 160  :         if ( CurrSeg && CurrSeg->e.seginfo->segtype == SEGTYPE_BSS )

	mov	rcx, QWORD PTR ModuleInfo+432
	xor	r8b, r8b
	test	rcx, rcx
	je	SHORT $LN4@Initialize
	mov	rax, QWORD PTR [rcx+104]
	cmp	DWORD PTR [rax+72], 3
	jne	SHORT $LN4@Initialize

; 161  :             SetCurrOffset( CurrSeg, f->sym.total_size - no_of_bytes, TRUE, TRUE );

	mov	r9b, 1
	sub	edx, r11d
	movzx	r8d, r9b
	call	SetCurrOffset

; 162  :         else {

	jmp	SHORT $LN3@Initialize
$LN4@Initialize:

; 163  :             /* v2.07: if element size is 1 and a string is used as initial value,
; 164  :              * pad array with spaces!
; 165  :              */
; 166  :             if ( f->sym.total_size == f->sym.total_length &&
; 167  :                 ( f->ivalue[0] == '"' || f->ivalue[0] == '\'' ) )

	cmp	edx, DWORD PTR [rsi+72]
	jne	SHORT $LN2@Initialize
	movzx	eax, BYTE PTR [rsi+112]
	cmp	al, 34					; 00000022H
	je	SHORT $LN1@Initialize
	cmp	al, 39					; 00000027H
	jne	SHORT $LN2@Initialize
$LN1@Initialize:

; 168  :                 filler = ' ';

	mov	r8b, 32					; 00000020H
$LN2@Initialize:

; 169  :             FillDataBytes( filler, f->sym.total_size - no_of_bytes );

	sub	edx, r11d
	movzx	ecx, r8b
	call	FillDataBytes
$LN3@Initialize:

; 170  :         }
; 171  :     }
; 172  : 
; 173  :     DebugMsg1(("InitializeArray(%s) exit, curr ofs=%X\n", f->sym.name, GetCurrOffset() ));
; 174  :     return( rc );

	mov	eax, ebp
$LN30@Initialize:
	mov	r15, QWORD PTR [rsp+104]
	mov	r14, QWORD PTR [rsp+112]
	mov	r13, QWORD PTR [rsp+120]
	mov	r12, QWORD PTR [rsp+128]
	mov	rdi, QWORD PTR [rsp+168]
	mov	rsi, QWORD PTR [rsp+160]
	mov	rbp, QWORD PTR [rsp+152]
	mov	rbx, QWORD PTR [rsp+144]

; 175  : }

	add	rsp, 136				; 00000088H
	ret	0
InitializeArray ENDP
_TEXT	ENDS
EXTRN	OutputBytes:NEAR
EXTRN	EvalOperand:NEAR
EXTRN	EmitError:NEAR
xdata	SEGMENT
$unwind$InitStructuredVar DD 081b01H
	DD	01d741bH
	DD	01f5417H
	DD	0203413H
	DD	021010fH
xdata	ENDS
pdata	SEGMENT
$pdata$InitStructuredVar DD @imagerel(InitStructuredVar#)
	DD	@imagerel(InitStructuredVar#+225)
	DD	@imagerel($unwind$InitStructuredVar#)
pdata	ENDS
xdata	SEGMENT
$chain$3$InitStructuredVar DD 020821H
	DD	01e6408H
	DD	@imagerel(InitStructuredVar#)
	DD	@imagerel(InitStructuredVar#+225)
	DD	@imagerel($unwind$InitStructuredVar#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$InitStructuredVar DD @imagerel(InitStructuredVar#+225)
	DD	@imagerel(InitStructuredVar#+1459)
	DD	@imagerel($chain$3$InitStructuredVar#)
pdata	ENDS
xdata	SEGMENT
$chain$4$InitStructuredVar DD 021H
	DD	@imagerel(InitStructuredVar#)
	DD	@imagerel(InitStructuredVar#+225)
	DD	@imagerel($unwind$InitStructuredVar#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$InitStructuredVar DD @imagerel(InitStructuredVar#+1459)
	DD	@imagerel(InitStructuredVar#+1670)
	DD	@imagerel($chain$4$InitStructuredVar#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
no_of_bytes$1$ = 80
j$5901 = 80
old_tokencount$1$ = 84
dwRecInit$ = 88
j$5897 = 96
opndx$ = 112
is_record_set$1$ = 272
j$5871 = 272
is_record_set$ = 272
index$ = 272
i$ = 280
tokenarray$ = 280
symtype$ = 288
embedded$ = 296
InitStructuredVar PROC NEAR

; 191  : {

	mov	QWORD PTR [rsp+24], r8
	mov	rax, rsp
	sub	rsp, 264				; 00000108H
	mov	QWORD PTR [rax-8], rbx
	mov	QWORD PTR [rax-16], rbp
	mov	QWORD PTR [rax-32], rdi

; 192  :     //char            *ptr;
; 193  :     struct sfield   *f;
; 194  :     int_32          nextofs;
; 195  :     int             i;
; 196  :     int             old_tokencount = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496

; 197  :     char            *old_stringbufferend = StringBufferEnd;
; 198  :     int             lvl;
; 199  : #if AMD64_SUPPORT
; 200  :     uint_64         dwRecInit;
; 201  : #else
; 202  :     uint_32         dwRecInit;
; 203  : #endif
; 204  :     bool            is_record_set;
; 205  :     struct expr     opndx;
; 206  :     //char            line[MAX_LINE_LEN];
; 207  : 
; 208  :     DebugMsg1(("InitStructuredVar(%s) enter, total_size=%" I32_SPEC "u, init=>%s<, embedded=%s, alignm=%u\n",
; 209  :               symtype->sym.name, symtype->sym.total_size, tokenarray[index].string_ptr, embedded ? embedded->name : "NULL", symtype->e.structinfo->alignment ));
; 210  : 
; 211  :     /**/myassert( symtype->sym.state == SYM_TYPE && symtype->sym.typekind != TYPE_TYPEDEF );
; 212  : 
; 213  :     if ( tokenarray[index].token == T_STRING ) {

	movsxd	rcx, ecx
	mov	rbx, r8
	shl	rcx, 5
	mov	DWORD PTR old_tokencount$1$[rsp], eax
	mov	rax, QWORD PTR ModuleInfo+488
	movzx	eax, BYTE PTR [rcx+rdx]
	mov	rdi, rdx
	mov	ebp, 1
	cmp	al, 9
	jne	SHORT $LN68@InitStruct

; 214  :         /* v2.08: no special handling of {}-literals anymore */
; 215  :         if ( tokenarray[index].string_delim != '<' &&
; 216  :             tokenarray[index].string_delim != '{' ) {

	movzx	eax, BYTE PTR [rcx+rdx+1]
	cmp	al, 60					; 0000003cH
	je	SHORT $LN67@InitStruct
	cmp	al, 123					; 0000007bH
	je	SHORT $LN67@InitStruct

; 217  :             return( EmitError( MISSING_ANGLE_BRACKET_OR_BRACE_IN_LITERAL ) );

	mov	ecx, 216				; 000000d8H
	call	EmitError
	jmp	$LN69@InitStruct
$LN67@InitStruct:

; 218  :         }
; 219  :         i = Token_Count + 1;

	mov	edx, DWORD PTR ModuleInfo+496

; 220  :         //strcpy( line, tokenarray[index].string_ptr );
; 221  :         Token_Count = Tokenize( tokenarray[index].string_ptr, i, tokenarray, TOK_RESCAN );

	mov	rcx, QWORD PTR [rcx+rdi+8]
	mov	r9d, ebp
	inc	edx
	mov	r8, rdi
	mov	DWORD PTR i$[rsp], edx
	call	Tokenize

; 222  :         /* once Token_Count has been modified, don't exit without
; 223  :          * restoring this value!
; 224  :          */
; 225  :         index++;
; 226  : 
; 227  :     } else if ( embedded &&

	mov	r10d, DWORD PTR i$[rsp]
	mov	DWORD PTR ModuleInfo+496, eax
	jmp	SHORT $LN63@InitStruct
$LN68@InitStruct:

; 228  :                 ( tokenarray[index].token == T_COMMA ||
; 229  :                  tokenarray[index].token == T_FINAL)) {

	test	r9, r9
	je	$LN71@InitStruct
	cmp	al, 44					; 0000002cH
	je	SHORT $LN64@InitStruct
	test	al, al
	jne	$LN65@InitStruct
$LN64@InitStruct:

; 230  :         i = Token_Count;

	mov	r10d, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rsp], r10d
$LN63@InitStruct:

; 233  :     }
; 234  :     if ( symtype->sym.typekind == TYPE_RECORD ) {

	xor	r8d, r8d
	cmp	BYTE PTR [rbx+74], 4
	jne	SHORT $LN83@InitStruct

; 235  :         dwRecInit = 0;
; 236  :         is_record_set = FALSE;

	xor	dl, dl
	mov	QWORD PTR dwRecInit$[rsp], r8
	mov	BYTE PTR is_record_set$1$[rsp], dl
	jmp	SHORT $LN62@InitStruct
$LN83@InitStruct:
	movzx	edx, BYTE PTR is_record_set$[rsp]
	mov	BYTE PTR is_record_set$1$[rsp], dl
$LN62@InitStruct:

; 237  :     }
; 238  : 
; 239  :     /* scan the STRUCT/UNION/RECORD's members */
; 240  :     for( f = symtype->e.structinfo->head; f != NULL; f = f->next ) {

	mov	rax, QWORD PTR [rbx+104]
	mov	QWORD PTR [rsp+240], rsi
	mov	rsi, QWORD PTR [rax]
	test	rsi, rsi
	je	$LN77@InitStruct
$LL61@InitStruct:

; 241  : 
; 242  :         DebugMsg1(("InitStructuredVar(%s) field=%s ofs=%" I32_SPEC "u total_size=%" I32_SPEC "u total_len=%" I32_SPEC "u value=>%s< >%s<\n",
; 243  :                   symtype->sym.name,
; 244  :                   f->sym.name,
; 245  :                   f->sym.offset,
; 246  :                   f->sym.total_size,
; 247  :                   f->sym.total_length,
; 248  :                   //f->initializer ? f->initializer : "NULL",
; 249  :                   f->ivalue, tokenarray[i].tokpos ));
; 250  : 
; 251  :         /* is it a RECORD field? */
; 252  :         if ( f->sym.mem_type == MT_BITS ) {

	mov	r9d, DWORD PTR [rsi+44]
	cmp	r9d, 193				; 000000c1H
	jne	$LN58@InitStruct

; 253  :             if ( tokenarray[i].token == T_COMMA || tokenarray[i].token == T_FINAL ) {

	movsxd	rax, r10d
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+rdi]
	cmp	cl, 44					; 0000002cH
	je	SHORT $LN56@InitStruct
	test	cl, cl
	je	SHORT $LN56@InitStruct

; 263  :                 }
; 264  :             } else {
; 265  :                 EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 );

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rdi
	mov	BYTE PTR [rsp+32], 0
	call	EvalOperand

; 266  :                 is_record_set = TRUE;

	mov	BYTE PTR is_record_set$1$[rsp], 1
$LN54@InitStruct:

; 267  :             }
; 268  :             if ( opndx.kind != EXPR_CONST || opndx.quoted_string != NULL )

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN51@InitStruct
	cmp	QWORD PTR opndx$[rsp+16], 0
	je	$LN84@InitStruct
$LN51@InitStruct:

; 269  :                 EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError
	mov	r10d, DWORD PTR i$[rsp]
	jmp	SHORT $LN52@InitStruct
$LN56@InitStruct:

; 254  :                 if ( f->ivalue[0] ) {

	cmp	BYTE PTR [rsi+112], 0
	lea	rcx, QWORD PTR [rsi+112]
	je	SHORT $LN55@InitStruct

; 255  :                     int j = Token_Count + 1;

	mov	edx, DWORD PTR ModuleInfo+496

; 256  :                     int max_item = Tokenize( f->ivalue, j, tokenarray, TOK_RESCAN );

	mov	r9d, ebp
	mov	r8, rdi
	inc	edx
	mov	DWORD PTR j$5871[rsp], edx
	call	Tokenize

; 257  :                     EvalOperand( &j, tokenarray, max_item, &opndx, 0 );

	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR j$5871[rsp]
	mov	rdx, rdi
	mov	r8d, eax
	mov	BYTE PTR [rsp+32], 0
	call	EvalOperand

; 258  :                     is_record_set = TRUE;

	mov	BYTE PTR is_record_set$1$[rsp], 1

; 259  :                 } else {

	jmp	SHORT $LN54@InitStruct
$LN55@InitStruct:

; 260  :                     opndx.value = 0;

	mov	DWORD PTR opndx$[rsp], r8d

; 261  :                     opndx.kind = EXPR_CONST;

	mov	DWORD PTR opndx$[rsp+60], r8d

; 262  :                     opndx.quoted_string = NULL;

	mov	QWORD PTR opndx$[rsp+16], r8

; 267  :             }
; 268  :             if ( opndx.kind != EXPR_CONST || opndx.quoted_string != NULL )

	jmp	SHORT $LN52@InitStruct
$LN84@InitStruct:

; 269  :                 EmitError( CONSTANT_EXPECTED );

	mov	r10d, DWORD PTR i$[rsp]
$LN52@InitStruct:

; 270  : 
; 271  :             /* fixme: max bits in 64-bit is 64 - see MAXRECBITS! */
; 272  :             if ( f->sym.total_size < 32 ) {

	mov	ecx, DWORD PTR [rsi+64]
	cmp	ecx, 32					; 00000020H
	jae	SHORT $LN49@InitStruct

; 273  :                 uint_32 dwMax = (1 << f->sym.total_size);

	mov	eax, ebp
	shl	eax, cl

; 274  :                 if ( opndx.value >= dwMax )

	cmp	DWORD PTR opndx$[rsp], eax
	jb	SHORT $LN49@InitStruct

; 275  :                     EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, f->sym.name );

	mov	rdx, QWORD PTR [rsi+8]
	mov	ecx, 172				; 000000acH
	call	EmitErr
	mov	r10d, DWORD PTR i$[rsp]
$LN49@InitStruct:

; 276  :             }
; 277  : #if AMD64_SUPPORT
; 278  :             dwRecInit |= opndx.llvalue << f->sym.offset;

	movzx	ecx, BYTE PTR [rsi+16]
	mov	rax, QWORD PTR opndx$[rsp]
	shl	rax, cl
	or	QWORD PTR dwRecInit$[rsp], rax
	jmp	$LN86@InitStruct
$LN58@InitStruct:

; 279  : #else
; 280  :             dwRecInit |= opndx.value << f->sym.offset;
; 281  : #endif
; 282  : 
; 283  :         //} else if ( f->init_dir == NULL ) {  /* embedded struct? */
; 284  :         } else if ( f->ivalue[0] == NULLC ) {  /* embedded struct? */

	cmp	BYTE PTR [rsi+112], 0
	jne	SHORT $LN47@InitStruct

; 285  : 
; 286  :             InitStructuredVar( i, tokenarray, (struct dsym *)f->sym.type, &f->sym );

	mov	r8, QWORD PTR [rsi+88]
	mov	r9, rsi
	mov	rdx, rdi
	mov	ecx, r10d
	call	InitStructuredVar

; 287  :             if ( tokenarray[i].token == T_STRING )

	movsxd	r10, DWORD PTR i$[rsp]
	mov	rax, r10
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 9
	jne	$LN90@InitStruct

; 288  :                 i++;

	inc	r10d

; 289  : 
; 290  :         } else if ( f->sym.isarray &&

	mov	ebp, 1
	mov	DWORD PTR i$[rsp], r10d
	jmp	$LN86@InitStruct
$LN47@InitStruct:

; 291  :                     tokenarray[i].token != T_FINAL &&
; 292  :                     tokenarray[i].token != T_COMMA ) {

	test	BYTE PTR [rsi+49], 2
	je	SHORT $LN44@InitStruct
	movsxd	rax, r10d
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+rdi]
	test	cl, cl
	je	SHORT $LN44@InitStruct
	cmp	cl, 44					; 0000002cH
	je	SHORT $LN44@InitStruct

; 293  :             if ( ERROR == InitializeArray( f, &i, tokenarray ) )

	lea	rdx, QWORD PTR i$[rsp]
	mov	r8, rdi
	mov	rcx, rsi
	call	InitializeArray
	cmp	eax, -1
	je	$LN88@InitStruct

; 294  :                 break;
; 295  : 
; 296  :         } else if ( f->sym.total_size == f->sym.total_length &&

	mov	r10d, DWORD PTR i$[rsp]
	mov	ebp, 1
	jmp	$LN86@InitStruct
$LN44@InitStruct:

; 297  :                    tokenarray[i].token == T_STRING &&
; 298  :                    tokenarray[i].stringlen > 1 &&
; 299  :                    ( tokenarray[i].string_delim == '"' ||
; 300  :                     tokenarray[i].string_delim == '\'' ) ) {

	mov	eax, DWORD PTR [rsi+72]
	cmp	DWORD PTR [rsi+64], eax
	jne	SHORT $LN41@InitStruct
	movsxd	rax, r10d
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 9
	jne	SHORT $LN41@InitStruct
	cmp	DWORD PTR [rax+rdi+16], 1
	jbe	SHORT $LN41@InitStruct
	movzx	ecx, BYTE PTR [rax+rdi+1]
	cmp	cl, 34					; 00000022H
	je	SHORT $LN40@InitStruct
	cmp	cl, 39					; 00000027H
	jne	SHORT $LN41@InitStruct
$LN40@InitStruct:

; 301  :             /* v2.07: it's a byte type, but no array, string initializer must have true length 1 */
; 302  :             EmitError( STRING_OR_TEXT_LITERAL_TOO_LONG );

	mov	ecx, 155				; 0000009bH
	call	EmitError

; 303  :             i++;

	mov	r10d, DWORD PTR i$[rsp]

; 304  :         } else {

	mov	ebp, 1
	inc	r10d
	mov	DWORD PTR i$[rsp], r10d
	jmp	$LN86@InitStruct
$LN41@InitStruct:

; 305  :             //struct asym *sym;
; 306  :             uint_32 no_of_bytes = SizeFromMemtype( f->sym.mem_type, USE_EMPTY, f->sym.type );

	mov	r8, QWORD PTR [rsi+88]
	mov	edx, 254				; 000000feH
	mov	ecx, r9d
	call	SizeFromMemtype

; 307  : 
; 308  :             /* v2.09: check for empty <> or {} string if a struct/union is embedded */
; 309  :             //for ( sym = f->sym->type; sym && sym->type; sym = sym->type );
; 310  : 
; 311  :             if ( tokenarray[i].token == T_FINAL || tokenarray[i].token == T_COMMA ) {

	movsxd	r8, DWORD PTR i$[rsp]
	mov	rcx, r8
	mov	r11d, eax
	mov	DWORD PTR no_of_bytes$1$[rsp], eax
	shl	rcx, 5
	lea	rdx, QWORD PTR [rcx+rdi]
	movzx	ecx, BYTE PTR [rcx+rdi]
	test	cl, cl
	je	$LN37@InitStruct
	cmp	cl, 44					; 0000002cH
	je	$LN37@InitStruct

; 317  :             } else {
; 318  :                 char c;
; 319  :                 int j = i;

	mov	DWORD PTR j$5901[rsp], r8d

; 320  :                 /* ignore commas enclosed in () ( might occur inside DUP argument! ).
; 321  :                  */
; 322  :                 for ( lvl = 0, c = 0; tokenarray[i].token != T_FINAL; i++ ) {

	movzx	eax, BYTE PTR [rdx]
	xor	ecx, ecx
	xor	r9b, r9b
	test	al, al
	mov	r10, r8
	je	SHORT $LN25@InitStruct
	npad	4
$LL35@InitStruct:

; 323  :                     if ( tokenarray[i].token == T_OP_BRACKET )

	cmp	al, 40					; 00000028H
	jne	SHORT $LN32@InitStruct

; 324  :                         lvl++;

	inc	ecx
	jmp	SHORT $LN34@InitStruct
$LN32@InitStruct:

; 325  :                     else if ( tokenarray[i].token == T_CL_BRACKET )

	cmp	al, 41					; 00000029H
	jne	SHORT $LN30@InitStruct

; 326  :                         lvl--;

	dec	ecx
	jmp	SHORT $LN34@InitStruct
$LN30@InitStruct:

; 327  :                     else if ( lvl == 0 && tokenarray[i].token == T_COMMA )

	test	ecx, ecx
	jne	SHORT $LN28@InitStruct
	cmp	al, 44					; 0000002cH
	je	SHORT $LN76@InitStruct
$LN28@InitStruct:

; 328  :                         break;
; 329  :                     else if ( tokenarray[i].token == T_RES_ID && tokenarray[i].tokval == T_DUP )

	cmp	al, 7
	jne	SHORT $LN34@InitStruct
	cmp	DWORD PTR [rdx+16], 259			; 00000103H
	jne	SHORT $LN34@InitStruct

; 330  :                         c++; /* v2.08: check added */

	inc	r9b
$LN34@InitStruct:

; 320  :                 /* ignore commas enclosed in () ( might occur inside DUP argument! ).
; 321  :                  */
; 322  :                 for ( lvl = 0, c = 0; tokenarray[i].token != T_FINAL; i++ ) {

	inc	r8d
	movsxd	rax, r8d
	mov	DWORD PTR i$[rsp], r8d
	shl	rax, 5
	lea	rdx, QWORD PTR [rax+rdi]
	mov	al, BYTE PTR [rax+rdi]
	test	al, al
	jne	SHORT $LL35@InitStruct
$LN76@InitStruct:

; 331  :                 }
; 332  :                 if ( c ) {

	test	r9b, r9b
	je	SHORT $LN25@InitStruct

; 333  :                     EmitErr( INITIALIZER_MUST_BE_A_STRING_OR_SINGLE_ITEM, tokenarray[j].tokpos );

	mov	rdx, r10
	mov	ecx, 152				; 00000098H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rdi+24]
	call	EmitErr

; 334  :                 } else

	mov	r10d, DWORD PTR i$[rsp]
	mov	ebp, 1
	jmp	$LN86@InitStruct
$LN25@InitStruct:

; 335  :                     if ( ERROR == data_item( &j, tokenarray, NULL, no_of_bytes, f->sym.type, 1, FALSE, f->sym.mem_type & MT_FLOAT, FALSE, i ) ) {

	movzx	eax, BYTE PTR [rsi+44]
	mov	DWORD PTR [rsp+72], r8d
	mov	BYTE PTR [rsp+64], 0
	and	al, 32					; 00000020H
	mov	ebp, 1
	lea	rcx, QWORD PTR j$5901[rsp]
	mov	BYTE PTR [rsp+56], al
	mov	rax, QWORD PTR [rsi+88]
	mov	BYTE PTR [rsp+48], 0
	mov	r9d, r11d
	xor	r8d, r8d
	mov	rdx, rdi
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rax
	call	data_item
	cmp	eax, -1
	jne	$LN85@InitStruct

; 336  :                         EmitErr( INVALID_DATA_INITIALIZER, f->sym.name );

	mov	rdx, QWORD PTR [rsi+8]
	mov	ecx, 231				; 000000e7H
	call	EmitErr
	mov	r10d, DWORD PTR i$[rsp]
	jmp	$LN86@InitStruct
$LN37@InitStruct:

; 312  :                 int tc = Token_Count;

	mov	ebx, DWORD PTR ModuleInfo+496

; 313  :                 int j = Token_Count+1;
; 314  :                 Token_Count = Tokenize( f->ivalue, j, tokenarray, TOK_RESCAN );

	lea	rcx, QWORD PTR [rsi+112]
	mov	r9d, 1
	lea	edx, DWORD PTR [rbx+1]
	mov	r8, rdi
	mov	DWORD PTR j$5897[rsp], edx
	call	Tokenize

; 315  :                 data_item( &j, tokenarray, NULL, no_of_bytes, f->sym.type, 1, FALSE, f->sym.mem_type & MT_FLOAT, FALSE, Token_Count );

	mov	r9d, DWORD PTR no_of_bytes$1$[rsp]
	mov	DWORD PTR [rsp+72], eax
	mov	BYTE PTR [rsp+64], 0
	mov	DWORD PTR ModuleInfo+496, eax
	movzx	ecx, BYTE PTR [rsi+44]
	mov	rax, QWORD PTR [rsi+88]
	mov	ebp, 1
	and	cl, 32					; 00000020H
	xor	r8d, r8d
	mov	rdx, rdi
	mov	BYTE PTR [rsp+56], cl
	mov	BYTE PTR [rsp+48], 0
	lea	rcx, QWORD PTR j$5897[rsp]
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rax
	call	data_item

; 316  :                 Token_Count = tc;

	mov	r10d, DWORD PTR i$[rsp]
	mov	DWORD PTR ModuleInfo+496, ebx
	mov	rbx, QWORD PTR symtype$[rsp]
	jmp	SHORT $LN86@InitStruct
$LN85@InitStruct:
	mov	r10d, DWORD PTR i$[rsp]
	jmp	SHORT $LN86@InitStruct
$LN90@InitStruct:
	mov	ebp, 1
$LN86@InitStruct:

; 337  :                     }
; 338  :             }
; 339  :         }
; 340  :         /* Add padding bytes if necessary (never inside RECORDS!).
; 341  :          * f->next == NULL : it's the last field of the struct/union/record
; 342  :          */
; 343  :         if ( symtype->sym.typekind != TYPE_RECORD ) {

	movzx	eax, BYTE PTR [rbx+74]
	cmp	al, 4
	je	SHORT $LN18@InitStruct

; 344  :             if ( f->next == NULL || symtype->sym.typekind == TYPE_UNION )

	mov	rcx, QWORD PTR [rsi+104]
	test	rcx, rcx
	je	SHORT $LN20@InitStruct
	cmp	al, 2
	je	SHORT $LN20@InitStruct

; 346  :             else
; 347  :                 nextofs = f->next->sym.offset;

	mov	edx, DWORD PTR [rcx+16]
	jmp	SHORT $LN19@InitStruct
$LN20@InitStruct:

; 345  :                 nextofs = symtype->sym.total_size;

	mov	edx, DWORD PTR [rbx+64]
$LN19@InitStruct:

; 348  : 
; 349  :             if ( f->sym.offset + f->sym.total_size < nextofs ) {

	mov	ecx, DWORD PTR [rsi+64]
	mov	r8d, DWORD PTR [rsi+16]
	lea	eax, DWORD PTR [r8+rcx]
	cmp	eax, edx
	jae	SHORT $LN18@InitStruct

; 350  :                 DebugMsg1(("InitStructuredVar: padding, field=%s ofs=%" I32_SPEC "X total=%" I32_SPEC "X nextofs=%" I32_SPEC "X\n",
; 351  :                           f->sym.name, f->sym.offset, f->sym.total_size, nextofs ));
; 352  :                 SetCurrOffset( CurrSeg, nextofs - (f->sym.offset + f->sym.total_size), TRUE, TRUE );

	sub	edx, r8d
	mov	r9b, 1
	sub	edx, ecx
	mov	rcx, QWORD PTR ModuleInfo+432
	movzx	r8d, r9b
	call	SetCurrOffset
	mov	r10d, DWORD PTR i$[rsp]
$LN18@InitStruct:

; 353  :             }
; 354  :         }
; 355  :         /* for a union, just the first field is initialized */
; 356  :         if ( symtype->sym.typekind == TYPE_UNION )

	cmp	BYTE PTR [rbx+74], 2
	je	$LN91@InitStruct

; 357  :             break;
; 358  : 
; 359  :         if ( f->next != NULL ) {

	cmp	QWORD PTR [rsi+104], 0
	je	SHORT $LN60@InitStruct

; 360  : 
; 361  :             if ( tokenarray[i].token != T_FINAL )

	movsxd	rdx, r10d
	shl	rdx, 5
	movzx	eax, BYTE PTR [rdx+rdi]
	test	al, al
	je	SHORT $LN60@InitStruct

; 362  :                 if ( tokenarray[i].token == T_COMMA )

	cmp	al, 44					; 0000002cH
	jne	SHORT $LN14@InitStruct

; 363  :                     i++;

	inc	r10d
	mov	DWORD PTR i$[rsp], r10d

; 364  :                 else {

	jmp	SHORT $LN60@InitStruct
$LN14@InitStruct:

; 365  :                     EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos );

	mov	rdx, QWORD PTR [rdx+rdi+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 366  :                     while ( tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA )

	movsxd	r10, DWORD PTR i$[rsp]
	mov	rax, r10
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+rdi]
	test	cl, cl
	je	SHORT $LN60@InitStruct
$LL12@InitStruct:
	cmp	cl, 44					; 0000002cH
	je	SHORT $LN60@InitStruct

; 367  :                         i++;

	inc	r10d
	movsxd	rax, r10d
	mov	DWORD PTR i$[rsp], r10d
	shl	rax, 5
	mov	cl, BYTE PTR [rax+rdi]
	test	cl, cl
	jne	SHORT $LL12@InitStruct
$LN60@InitStruct:

; 237  :     }
; 238  : 
; 239  :     /* scan the STRUCT/UNION/RECORD's members */
; 240  :     for( f = symtype->e.structinfo->head; f != NULL; f = f->next ) {

	mov	rsi, QWORD PTR [rsi+104]
	mov	r8d, 0
	test	rsi, rsi
	jne	$LL61@InitStruct
	mov	dl, BYTE PTR is_record_set$1$[rsp]
	jmp	SHORT $LN77@InitStruct
$LN88@InitStruct:
	mov	r10d, DWORD PTR i$[rsp]
	mov	dl, BYTE PTR is_record_set$1$[rsp]
	jmp	SHORT $LN77@InitStruct
$LN91@InitStruct:
	mov	dl, BYTE PTR is_record_set$1$[rsp]
$LN77@InitStruct:

; 368  :                 }
; 369  :         }
; 370  :     }  /* end for */
; 371  : 
; 372  :     if ( symtype->sym.typekind == TYPE_RECORD ) {

	cmp	BYTE PTR [rbx+74], 4
	mov	rsi, QWORD PTR [rsp+240]
	jne	SHORT $LN2@InitStruct

; 373  :         int no_of_bytes;
; 374  :         switch ( symtype->sym.mem_type ) {

	mov	ecx, DWORD PTR [rbx+44]
	test	ecx, ecx
	je	SHORT $LN7@InitStruct
	dec	ecx
	je	SHORT $LN6@InitStruct
	cmp	ecx, 6
	je	SHORT $LN5@InitStruct

; 379  : #endif
; 380  :         default: no_of_bytes = 4;

	mov	eax, 4
	jmp	SHORT $LN8@InitStruct
$LN5@InitStruct:

; 377  : #if AMD64_SUPPORT
; 378  :         case MT_QWORD: no_of_bytes = 8; break;

	mov	eax, 8
	jmp	SHORT $LN8@InitStruct
$LN6@InitStruct:

; 375  :         case MT_BYTE: no_of_bytes = 1; break;
; 376  :         case MT_WORD: no_of_bytes = 2; break;

	mov	eax, 2
	jmp	SHORT $LN8@InitStruct
$LN7@InitStruct:
	mov	eax, 1
$LN8@InitStruct:

; 381  :         }
; 382  :         if ( is_record_set )

	test	dl, dl
	je	SHORT $LN3@InitStruct

; 383  :             OutputDataBytes( (uint_8 *)&dwRecInit, no_of_bytes );

	lea	rcx, QWORD PTR dwRecInit$[rsp]
	xor	r8d, r8d
	mov	edx, eax
	call	OutputBytes

; 384  :         else

	mov	r10d, DWORD PTR i$[rsp]
	jmp	SHORT $LN2@InitStruct
$LN3@InitStruct:

; 385  :             SetCurrOffset( CurrSeg, no_of_bytes, TRUE, TRUE );

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	r9b, 1
	mov	edx, eax
	movzx	r8d, r9b
	call	SetCurrOffset
	mov	r10d, DWORD PTR i$[rsp]
$LN2@InitStruct:

; 386  :     }
; 387  : 
; 388  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, r10d
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rdi], 0
	je	SHORT $LN1@InitStruct

; 389  :         DebugMsg1(("InitStructuredVar(%s): error, i=%u token=%s\n", symtype->sym.name, i, tokenarray[i].string_ptr ));
; 390  :         EmitErr( TOO_MANY_INITIAL_VALUES_FOR_STRUCTURE, tokenarray[i].tokpos );

	mov	rdx, QWORD PTR [rdx+rdi+24]
	mov	ecx, 153				; 00000099H
	call	EmitErr
$LN1@InitStruct:

; 391  :     }
; 392  : 
; 393  :     /* restore token status */
; 394  :     Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$1$[rsp]
	mov	DWORD PTR ModuleInfo+496, eax

; 395  :     StringBufferEnd = old_stringbufferend;

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR ModuleInfo+488, rax

; 396  :     DebugMsg1(("InitStructuredVar(%s) exit, current ofs=%" I32_SPEC "X\n", symtype->sym.name, GetCurrOffset() ));
; 397  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN69@InitStruct
$LN65@InitStruct:

; 231  :     } else {
; 232  :         return( EmitErr( INITIALIZER_MUST_BE_A_STRING_OR_SINGLE_ITEM, embedded ? embedded->name : "" ) );

	mov	rdx, QWORD PTR [r9+8]
	jmp	SHORT $LN72@InitStruct
$LN71@InitStruct:
	lea	rdx, OFFSET FLAT:$SG5861
$LN72@InitStruct:
	mov	ecx, 152				; 00000098H
	call	EmitErr
$LN69@InitStruct:
	mov	rdi, QWORD PTR [rsp+232]
	mov	rbp, QWORD PTR [rsp+248]
	mov	rbx, QWORD PTR [rsp+256]

; 398  : }

	add	rsp, 264				; 00000108H
	ret	0
InitStructuredVar ENDP
; Function compile flags: /Ogtpy
src$ = 8
len$ = 16
little_endian PROC NEAR

; 407  :     /* v2.06: input and output buffer must be different! */
; 408  :     char *dst = StringBufferEnd;
; 409  : 
; 410  :     for( ; len > 1; dst++, src++, len-- ) {

	cmp	edx, 1
	mov	rax, QWORD PTR ModuleInfo+488
	movsxd	r8, edx
	mov	r9, rax
	jbe	SHORT $LN2@little_end
	lea	r10d, DWORD PTR [rdx-2]
	shr	r10d, 1
	inc	r10d
	npad	4
$LL4@little_end:

; 411  :         len--;
; 412  :         *dst = *(src + len);

	movzx	eax, BYTE PTR [r8+rcx-1]
	inc	r9
	sub	r8, 2
	mov	BYTE PTR [r9-1], al

; 413  :         *(dst + len) = *src;

	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	mov	BYTE PTR [r8+r9], al
	add	edx, -2					; fffffffeH
	dec	r10
	jne	SHORT $LL4@little_end

; 407  :     /* v2.06: input and output buffer must be different! */
; 408  :     char *dst = StringBufferEnd;
; 409  : 
; 410  :     for( ; len > 1; dst++, src++, len-- ) {

	mov	rax, QWORD PTR ModuleInfo+488
$LN2@little_end:

; 414  :     }
; 415  :     if ( len )

	test	edx, edx
	je	SHORT $LN9@little_end

; 416  :         *dst = *src;

	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [r9], al

; 417  : 
; 418  :     return( StringBufferEnd );

	mov	rax, QWORD PTR ModuleInfo+488
$LN9@little_end:

; 419  : }

	ret	0
little_endian ENDP
_TEXT	ENDS
EXTRN	atofloat:NEAR
EXTRN	_snprintf:NEAR
EXTRN	_fltused:DWORD
xdata	SEGMENT
$unwind$output_float DD 051b01H
	DD	013741bH
	DD	012340bH
	DD	0e207H
xdata	ENDS
pdata	SEGMENT
$pdata$output_float DD @imagerel(output_float#)
	DD	@imagerel(output_float#+210)
	DD	@imagerel($unwind$output_float#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buffer$ = 48
tstr$ = 80
opnd$ = 128
size$ = 136
output_float PROC NEAR

; 423  : {

	mov	r11, rsp
	sub	rsp, 120				; 00000078H
	mov	QWORD PTR [r11+24], rbx
	mov	rbx, rcx

; 424  :     /* v2.07: buffer extended to max size of a data item (=32).
; 425  :      * test case: XMMWORD REAL10 ptr 1.0
; 426  :      */
; 427  :     //char buffer[12];
; 428  :     char buffer[32];
; 429  : 	char tstr[32];
; 430  : 
; 431  :     if ( opnd->mem_type != MT_EMPTY ) {

	mov	ecx, DWORD PTR [rcx+64]
	cmp	ecx, 192				; 000000c0H
	mov	QWORD PTR [r11+32], rdi
	mov	edi, edx
	je	SHORT $LN6@output_flo

; 432  :         int i;
; 433  :         memset( buffer, 0, sizeof( buffer ) );

	xor	eax, eax

; 434  :         i = SizeFromMemtype( opnd->mem_type, USE_EMPTY, NULL );

	xor	r8d, r8d
	mov	edx, 254				; 000000feH
	mov	QWORD PTR [r11-72], rax
	mov	QWORD PTR [r11-64], rax
	mov	QWORD PTR [r11-56], rax
	mov	QWORD PTR [r11-48], rax
	call	SizeFromMemtype

; 435  :         if ( i > size )

	cmp	eax, edi
	mov	r8d, eax
	jbe	SHORT $LN5@output_flo

; 436  :             EmitErr( INITIALIZER_OUT_OF_RANGE );

	mov	ecx, 55					; 00000037H
	call	EmitErr

; 437  :         else {

	jmp	SHORT $LN1@output_flo
$LN6@output_flo:

; 438  :             atofloat( buffer, opnd->float_tok->string_ptr, i , opnd->negative, opnd->float_tok->floattype );
; 439  :         }
; 440  :     } 
; 441  : 	else if (opnd->kind == EXPR_FLOATI)

	cmp	DWORD PTR [rbx+60], 4
	jne	SHORT $LN2@output_flo

; 442  : 	{
; 443  : 		snprintf(tstr, sizeof(tstr), "%f", opnd->fvalue);

	cvtss2sd xmm3, DWORD PTR [rbx]
	lea	r8, OFFSET FLAT:$SG5972
	lea	rcx, QWORD PTR tstr$[rsp]
	mov	edx, 32					; 00000020H
	movd	r9, xmm3
	call	_snprintf

; 444  : 		atofloat( buffer, tstr, size, opnd->negative, 0 );

	mov	BYTE PTR [rsp+32], 0
	mov	r8d, edi
	lea	rdx, QWORD PTR tstr$[rsp]

; 445  : 	}
; 446  : 	else {

	jmp	SHORT $LN9@output_flo
$LN2@output_flo:

; 447  :         atofloat( buffer, opnd->float_tok->string_ptr, size, opnd->negative, opnd->float_tok->floattype );

	mov	r8d, edi
$LN5@output_flo:
	mov	rdx, QWORD PTR [rbx+16]
	movzx	eax, BYTE PTR [rdx+1]
	mov	rdx, QWORD PTR [rdx+8]
	mov	BYTE PTR [rsp+32], al
$LN9@output_flo:
	mov	r9d, DWORD PTR [rbx+72]
	lea	rcx, QWORD PTR buffer$[rsp]
	shr	r9d, 5
	and	r9b, 1
	call	atofloat
$LN1@output_flo:

; 448  :     }
; 449  :     OutputDataBytes( buffer, size );

	lea	rcx, QWORD PTR buffer$[rsp]
	xor	r8d, r8d
	mov	edx, edi
	call	OutputBytes
	mov	rdi, QWORD PTR [rsp+152]
	mov	rbx, QWORD PTR [rsp+144]

; 450  :     return;
; 451  : }

	add	rsp, 120				; 00000078H
	ret	0
output_float ENDP
_TEXT	ENDS
PUBLIC	__real@bf800000
EXTRN	szNull:BYTE
EXTRN	EmitConstError:NEAR
EXTRN	OutputInterleavedBytes:NEAR
EXTRN	CreateFixup:NEAR
EXTRN	set_frame:NEAR
EXTRN	set_frame2:NEAR
EXTRN	segm_override:NEAR
EXTRN	SegOverride:QWORD
EXTRN	write_to_file:BYTE
EXTRN	Options:BYTE
EXTRN	GetSymOfssize:NEAR
EXTRN	__ImageBase:BYTE
EXTRN	EmitWarn:NEAR
EXTRN	Parse_Pass:DWORD
EXTRN	memset:NEAR
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
xdata	SEGMENT
$unwind$data_item DD 0e3701H
	DD	0117837H
	DD	0126832H
	DD	0277424H
	DD	0286420H
	DD	029541cH
	DD	02a3418H
	DD	02b0114H
xdata	ENDS
pdata	SEGMENT
$pdata$data_item DD @imagerel(data_item#)
	DD	@imagerel(data_item#+4320)
	DD	@imagerel($unwind$data_item#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 80
total$1$ = 84
initwarn$1$ = 88
opndx$ = 96
buffer$6471 = 208
buffer$6459 = 208
tstr$6472 = 240
start_pos$ = 352
tokenarray$ = 360
sym$ = 368
no_of_bytes$ = 376
type_sym$ = 384
fixup_type$ = 392
dup$ = 392
inside_struct$ = 400
is_float$ = 408
first$ = 416
end$ = 424
data_item PROC NEAR

; 480  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, rsp
	sub	rsp, 344				; 00000158H
	mov	QWORD PTR [rax-8], rbx
	mov	QWORD PTR [rax-16], rbp
	mov	QWORD PTR [rax-24], rsi
	mov	QWORD PTR [rax-32], rdi
	mov	esi, r9d
	mov	rbp, r8
	mov	r10, rdx
	movdqa	XMMWORD PTR [rax-56], xmm6
	movdqa	XMMWORD PTR [rax-72], xmm7

; 481  :     int                 i;
; 482  :     int                 string_len;
; 483  :     uint_32             total = 0;

	xor	eax, eax
	mov	ebx, eax
	mov	DWORD PTR total$1$[rsp], eax

; 484  :     bool                initwarn = FALSE;

	mov	BYTE PTR initwarn$1$[rsp], al

; 485  :     //unsigned int        count;
; 486  :     uint_8              *pchar;
; 487  :     char                tmp;
; 488  :     enum fixup_types    fixup_type;
; 489  :     struct fixup        *fixup;
; 490  :     struct expr         opndx;
; 491  : 
; 492  :     DebugMsg1(("data_item( idx=%u [%s], label=%s, no_of_bytes=%" I32_SPEC "u, type=%s, dup=%" I32_SPEC "Xh, inside_struct=%u, is_float=%u ) enter\n",
; 493  :                *start_pos, tokenarray[*start_pos].tokpos, sym ? sym->name : "NULL",
; 494  :                no_of_bytes, type_sym ? type_sym->name : "NULL",
; 495  :                dup, inside_struct, is_float ));
; 496  : 
; 497  :     for ( ; dup; dup-- ) {

	mov	eax, DWORD PTR dup$[rsp]
	test	eax, eax
	je	$LN240@data_item
	xorps	xmm7, xmm7
	movss	xmm6, DWORD PTR __real@bf800000
	mov	edi, DWORD PTR fixup_type$[rsp]
	npad	12
$LL170@data_item:

; 498  :     i = *start_pos;

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR i$[rsp], eax
	npad	10
$next_item$6008:

; 499  : next_item:  /* <--- continue scan if a comma has been detected */
; 500  :     /* since v1.94, the expression evaluator won't handle strings
; 501  :      * enclosed in <> or {}. That is, in previous versions syntax
; 502  :      * "mov eax,<1>" was accepted, now it's rejected.
; 503  :      */
; 504  :     if ( tokenarray[i].token == T_STRING && ( tokenarray[i].string_delim == '<'  || tokenarray[i].string_delim == '{' ) ) {

	movsxd	r8, DWORD PTR i$[rsp]
	shl	r8, 5
	movzx	ecx, BYTE PTR [r8+r10]
	cmp	cl, 9
	jne	$LN165@data_item
	movzx	eax, BYTE PTR [r8+r10+1]
	cmp	al, 60					; 0000003cH
	je	SHORT $LN166@data_item
	cmp	al, 123					; 0000007bH
	jne	$LN165@data_item
$LN166@data_item:

; 505  :         if( type_sym ) {

	mov	rdx, QWORD PTR type_sym$[rsp]
	test	rdx, rdx
	je	$LN165@data_item

; 506  :             DebugMsg1(("data_item(%s): literal/brace found: >%s<, inside_struct=%u, no_of_bytes=%" I32_SPEC "u, curr_ofs=%" I32_SPEC "X\n",
; 507  :                        type_sym->name, tokenarray[i].string_ptr, inside_struct, no_of_bytes, GetCurrOffset()));
; 508  : 
; 509  :             /* it's either a real data item - then inside_struct is FALSE -
; 510  :              * or a structure FIELD of arbitrary type.
; 511  :              *
; 512  :              * v2.10: regression in v2.09: alias types weren't skipped for InitStructuredVar()
; 513  :              */
; 514  :             while ( type_sym->type ) type_sym = type_sym->type;

	mov	rax, QWORD PTR [rdx+88]
	test	rax, rax
	je	SHORT $LN163@data_item
	npad	13
$LL164@data_item:
	mov	QWORD PTR type_sym$[rsp], rax
	mov	rax, QWORD PTR [rax+88]
	test	rax, rax
	jne	SHORT $LL164@data_item
	mov	ebx, DWORD PTR total$1$[rsp]
	mov	rdx, QWORD PTR type_sym$[rsp]
$LN163@data_item:

; 515  :             if( inside_struct == FALSE ) {

	cmp	BYTE PTR inside_struct$[rsp], 0
	jne	SHORT $LN162@data_item

; 516  :                 if ( InitStructuredVar( i, tokenarray, (struct dsym *)type_sym, NULL ) == ERROR )

	mov	ecx, DWORD PTR i$[rsp]
	mov	r8, rdx
	xor	r9d, r9d
	mov	rdx, r10
	call	InitStructuredVar
	cmp	eax, -1
	je	$LN122@data_item

; 531  :             }
; 532  : 
; 533  :             total++;

	inc	ebx

; 534  :             i++;

	inc	DWORD PTR i$[rsp]
	mov	DWORD PTR total$1$[rsp], ebx

; 535  :             goto item_done;

	jmp	$item_done$6021
$LN162@data_item:

; 517  :                     return( ERROR );
; 518  :             } else {
; 519  :                 /* v2.09: emit a warning if a TYPEDEF member is a simple type,
; 520  :                  * but is initialized with a literal.
; 521  :                  * Note: Masm complains about such literals only if the struct is instanced OR -Fl is set.
; 522  :                  * fixme: the best solution is to always set type_sym to NULL if
; 523  :                  * the type is a TYPEDEF. if the item is a struct member, then
; 524  :                  * sym is ALWAYS != NULL and the symbol's type can be gained from there.
; 525  :                  * v2.10: aliases are now already skipped here ( see above ).
; 526  :                  */
; 527  :                 //while ( type_sym->type ) /* skip alias types */
; 528  :                 //    type_sym = type_sym->type;
; 529  :                 if( type_sym->typekind == TYPE_TYPEDEF && Parse_Pass == PASS_1 )

	cmp	BYTE PTR [rdx+74], 3
	jne	SHORT $LN159@data_item
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN159@data_item

; 530  :                     EmitWarn( 2, COUNT_MUST_BE_POSITIVE_OR_ZERO, tokenarray[i].tokpos );

	mov	r8, QWORD PTR [r8+r10+24]
	mov	edx, 208				; 000000d0H
	mov	ecx, 2
	call	EmitWarn
$LN159@data_item:

; 531  :             }
; 532  : 
; 533  :             total++;

	inc	ebx

; 534  :             i++;

	inc	DWORD PTR i$[rsp]
	mov	DWORD PTR total$1$[rsp], ebx

; 535  :             goto item_done;

	jmp	$item_done$6021
$LN165@data_item:

; 536  : #if 0 /* v2.08: just let EvalOperand() emit 'Unexpected literal...' error */
; 537  :         } else {
; 538  :             DebugMsg(("data_item: invalid string initializer >%s<\n", tokenarray[i].tokpos ));
; 539  :             /* Masm accepts invalid initializer strings if they are actually never used
; 540  :              * for initialization.
; 541  :              */
; 542  :             if( inside_struct && Parse_Pass == PASS_1 ) {
; 543  :                 EmitWarn( 2, UNEXPECTED_LITERAL_FOUND_IN_EXPRESSION, tokenarray[i].tokpos );
; 544  :                 tokenarray[i].token = T_QUESTION_MARK;
; 545  :             }
; 546  : #endif
; 547  :         }
; 548  :     }
; 549  : 
; 550  :     if ( tokenarray[i].token == T_QUESTION_MARK )

	cmp	cl, 63					; 0000003fH
	jne	SHORT $LN158@data_item

; 551  :         opndx.kind = EXPR_EMPTY;

	mov	edx, -2
	mov	DWORD PTR opndx$[rsp+60], edx

; 552  :     else

	jmp	SHORT $LN156@data_item
$LN158@data_item:

; 553  :         if ( EvalOperand( &i, tokenarray, end, &opndx, 0 ) == ERROR )

	mov	r8d, DWORD PTR end$[rsp]
	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, r10
	mov	BYTE PTR [rsp+32], 0
	call	EvalOperand
	cmp	eax, -1
	je	$LN122@data_item
	mov	edx, DWORD PTR opndx$[rsp+60]
	mov	r10, QWORD PTR tokenarray$[rsp]
$LN156@data_item:

; 554  :             return( ERROR );
; 555  : 
; 556  :     //DebugMsg(("data_item, EvalOperand() returned, opndx.kind=%u\n", opndx.kind ));
; 557  : 
; 558  :     /* handle DUP operator */
; 559  : 
; 560  :     if ( tokenarray[i].token == T_RES_ID && tokenarray[i].tokval == T_DUP ) {

	movsxd	rax, DWORD PTR i$[rsp]
	mov	r9, rax
	shl	rax, 5
	movzx	r8d, BYTE PTR [rax+r10]
	cmp	r8b, 7
	jne	$LN155@data_item
	cmp	DWORD PTR [rax+r10+16], 259		; 00000103H
	jne	$LN155@data_item

; 561  :         /* v2.03: db 'AB' dup (0) is valid syntax! */
; 562  :         //if ( opndx.kind != EXPR_CONST || opndx.string != NULL ) {
; 563  :         if ( opndx.kind != EXPR_CONST ) {

	test	edx, edx
	jne	$LN213@data_item

; 571  :         }
; 572  :         /* max dup is 0x7fffffff */
; 573  :         if ( opndx.value < 0 ) {

	cmp	DWORD PTR opndx$[rsp], edx
	jl	$LN214@data_item

; 575  :         }
; 576  :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 577  :         if( tokenarray[i].token != T_OP_BRACKET ) {

	cdqe
	shl	rax, 5
	cmp	BYTE PTR [rax+r10], 40			; 00000028H
	jne	$LN215@data_item

; 580  :         }
; 581  :         i++;

	inc	DWORD PTR i$[rsp]

; 582  : 
; 583  :         if ( sym )

	test	rbp, rbp
	je	SHORT $LN149@data_item

; 584  :             sym->isarray = TRUE;

	or	BYTE PTR [rbp+49], 2
$LN149@data_item:

; 585  : 
; 586  :         if ( opndx.value == 0 ) {

	cmp	DWORD PTR opndx$[rsp], 0
	jne	SHORT $LN148@data_item

; 587  :             int level = 1;
; 588  :             for ( ; tokenarray[i].token != T_FINAL; i++ ) {

	movsxd	rax, DWORD PTR i$[rsp]
	mov	edx, 1
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+r10]
	test	cl, cl
	je	$LN139@data_item
$LL147@data_item:

; 589  :                 if ( tokenarray[i].token == T_OP_BRACKET )

	cmp	cl, 40					; 00000028H
	jne	SHORT $LN144@data_item

; 590  :                     level++;

	inc	edx
	jmp	SHORT $LN142@data_item
$LN144@data_item:

; 591  :                 else if ( tokenarray[i].token == T_CL_BRACKET )

	cmp	cl, 41					; 00000029H
	jne	SHORT $LN142@data_item

; 592  :                     level--;

	dec	edx
$LN142@data_item:

; 593  :                 if ( level == 0 )

	test	edx, edx
	je	$LN139@data_item
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	cdqe
	shl	rax, 5
	mov	cl, BYTE PTR [rax+r10]
	test	cl, cl
	jne	SHORT $LL147@data_item

; 594  :                     break;
; 595  :             }
; 596  :         } else {

	jmp	SHORT $LN139@data_item
$LN148@data_item:

; 597  :             DebugMsg1(("data_item(%s): op DUP, count=%" I32_SPEC "Xh, calling data_item()\n", sym ? sym->name : "NULL", opndx.uvalue ));
; 598  :             if ( data_item( &i, tokenarray, sym, no_of_bytes, type_sym, opndx.uvalue, inside_struct, is_float, first, end ) == ERROR ) {

	mov	eax, DWORD PTR end$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	r9d, esi
	mov	DWORD PTR [rsp+72], eax
	movzx	eax, BYTE PTR first$[rsp]
	mov	r8, rbp
	mov	BYTE PTR [rsp+64], al
	movzx	eax, BYTE PTR is_float$[rsp]
	mov	rdx, r10
	mov	BYTE PTR [rsp+56], al
	movzx	eax, BYTE PTR inside_struct$[rsp]
	mov	BYTE PTR [rsp+48], al
	mov	eax, DWORD PTR opndx$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR type_sym$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	data_item
	cmp	eax, -1
	je	$LN122@data_item
	mov	r10, QWORD PTR tokenarray$[rsp]
$LN139@data_item:

; 599  :                 DebugMsg(("data_item(%s): op DUP, count=%" I32_SPEC "Xh, returned with error\n", sym ? sym->name : "NULL", opndx.uvalue ));
; 600  :                 return( ERROR );
; 601  :             }
; 602  :         }
; 603  :         if( tokenarray[i].token != T_CL_BRACKET ) {

	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+r10], 41			; 00000029H
	jne	$LN217@data_item

; 606  :         }
; 607  :         /* v2.09: SIZE and LENGTH actually don't return values for "first initializer, but
; 608  :          * the "first dimension" values
; 609  :          * v2.11: fixme: if the first dimension is 0 ( opndx.value == 0),
; 610  :          * Masm ignores the expression - may be a Masm bug!
; 611  :          */
; 612  :         if ( sym && first && Parse_Pass == PASS_1 ) {

	test	rbp, rbp
	je	SHORT $LN137@data_item
	cmp	BYTE PTR first$[rsp], 0
	je	SHORT $LN137@data_item
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN137@data_item

; 613  :             sym->first_size = opndx.value * no_of_bytes;

	mov	ecx, DWORD PTR opndx$[rsp]

; 614  :             sym->first_length = opndx.value;
; 615  :             first = FALSE;

	mov	BYTE PTR first$[rsp], 0
	mov	eax, ecx
	mov	DWORD PTR [rbp+56], ecx
	imul	eax, esi
	mov	DWORD PTR [rbp+52], eax
$LN137@data_item:

; 616  :         }
; 617  : 
; 618  :         i++;

	inc	DWORD PTR i$[rsp]

; 619  :         goto item_done;

	jmp	$item_done$6021
$LN155@data_item:

; 620  :     }
; 621  :     /* a STRUCT/UNION/RECORD data item needs a literal as initializer */
; 622  :     /* v2.06: changed */
; 623  :     //if( type_sym != NULL && inside_struct == FALSE ) {
; 624  :     //if( type_sym != NULL && type_sym->typekind != TYPE_TYPEDEF ) {
; 625  :     if( type_sym ) {

	mov	r11, QWORD PTR type_sym$[rsp]
	test	r11, r11
	je	SHORT $LN133@data_item

; 626  :         /* v2.10: use a temp symbol, so the original type name can be displayed in the error msg. */
; 627  :         const struct asym *tmp = type_sym;
; 628  :         /* v2.10: check if target type is a struct/union/record; if yes, it's an error. */
; 629  :         while ( tmp->type ) tmp = tmp->type;

	mov	rax, QWORD PTR [r11+88]
	mov	rcx, r11
	test	rax, rax
	je	SHORT $LN134@data_item
$LL135@data_item:
	mov	rcx, rax
	mov	rax, QWORD PTR [rax+88]
	test	rax, rax
	jne	SHORT $LL135@data_item
$LN134@data_item:

; 630  :         if ( tmp->typekind != TYPE_TYPEDEF ) {

	cmp	BYTE PTR [rcx+74], 3
	jne	$LN218@data_item
$LN133@data_item:

; 633  :         }
; 634  :     }
; 635  : 
; 636  :     /* handle '?' */
; 637  :     if ( opndx.kind == EXPR_EMPTY && tokenarray[i].token == T_QUESTION_MARK ) {

	cmp	edx, -2
	jne	SHORT $LN132@data_item
	cmp	r8b, 63					; 0000003fH
	jne	SHORT $LN132@data_item

; 638  :         DebugMsg1(("data_item: ? found, curr_ofs=%X\n", GetCurrOffset()));
; 639  :         opndx.uvalue = no_of_bytes;
; 640  :         /* tiny optimization for uninitialized arrays */
; 641  :         if ( tokenarray[i+1].token != T_COMMA && i == *start_pos ) {

	lea	rax, QWORD PTR [r9+1]
	mov	DWORD PTR opndx$[rsp], esi
	shl	rax, 5
	cmp	BYTE PTR [rax+r10], 44			; 0000002cH
	je	SHORT $LN131@data_item
	mov	rax, QWORD PTR start_pos$[rsp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$[rsp], eax
	jne	SHORT $LN131@data_item

; 642  :             opndx.uvalue *= dup;

	mov	ecx, DWORD PTR dup$[rsp]
	mov	eax, esi

; 643  :             total += dup;
; 644  :             dup = 1; /* force loop exit */

	mov	DWORD PTR dup$[rsp], 1
	imul	eax, ecx
	add	ebx, ecx
	mov	DWORD PTR opndx$[rsp], eax
	mov	DWORD PTR total$1$[rsp], ebx

; 645  :         } else {

	jmp	SHORT $LN130@data_item
$LN131@data_item:

; 646  :             total++;

	inc	ebx
	mov	DWORD PTR total$1$[rsp], ebx
$LN130@data_item:

; 647  :         }
; 648  :         if( !inside_struct ) {

	cmp	BYTE PTR inside_struct$[rsp], 0
	jne	SHORT $LN129@data_item

; 649  :             SetCurrOffset( CurrSeg, opndx.uvalue, TRUE, TRUE );

	mov	edx, DWORD PTR opndx$[rsp]
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	r9b, 1
	movzx	r8d, r9b
	call	SetCurrOffset
$LN129@data_item:

; 650  :         }
; 651  :         i++;

	inc	DWORD PTR i$[rsp]

; 652  :         goto item_done;

	jmp	$item_done$6021
$LN132@data_item:

; 653  :     }
; 654  : 
; 655  :     /* warn about initialized data in BSS/AT segments */
; 656  :     if ( Parse_Pass == PASS_2 &&
; 657  :         inside_struct == FALSE  &&
; 658  :         // CurrSeg != NULL &&  /* this is already ensured to be true */
; 659  :         (CurrSeg->e.seginfo->segtype == SEGTYPE_BSS ||
; 660  :          CurrSeg->e.seginfo->segtype == SEGTYPE_ABS) &&
; 661  :         initwarn == FALSE ) {

	cmp	DWORD PTR Parse_Pass, 1
	jne	SHORT $LN244@data_item
	mov	r8b, BYTE PTR inside_struct$[rsp]
	test	r8b, r8b
	jne	SHORT $LN128@data_item
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rcx+72]
	cmp	eax, 3
	je	SHORT $LN127@data_item
	cmp	eax, 5
	jne	SHORT $LN128@data_item
$LN127@data_item:
	cmp	BYTE PTR initwarn$1$[rsp], 0
	jne	SHORT $LN128@data_item

; 662  :         EmitWarn( 2,
; 663  :                  INITIALIZED_DATA_NOT_SUPPORTED_IN_SEGMENT,
; 664  :                  (CurrSeg->e.seginfo->segtype == SEGTYPE_BSS) ? "BSS" : "AT" );

	cmp	eax, 3
	lea	rax, OFFSET FLAT:$SG6059
	lea	r8, OFFSET FLAT:$SG6060
	mov	edx, 184				; 000000b8H
	mov	ecx, 2
	cmove	r8, rax
	call	EmitWarn

; 665  :         initwarn = TRUE;

	mov	edx, DWORD PTR opndx$[rsp+60]
	mov	r10, QWORD PTR tokenarray$[rsp]
	mov	r8b, BYTE PTR inside_struct$[rsp]
	mov	BYTE PTR initwarn$1$[rsp], 1
	jmp	SHORT $LN128@data_item
$LN244@data_item:

; 597  :             DebugMsg1(("data_item(%s): op DUP, count=%" I32_SPEC "Xh, calling data_item()\n", sym ? sym->name : "NULL", opndx.uvalue ));
; 598  :             if ( data_item( &i, tokenarray, sym, no_of_bytes, type_sym, opndx.uvalue, inside_struct, is_float, first, end ) == ERROR ) {

	mov	r8b, BYTE PTR inside_struct$[rsp]
$LN128@data_item:

; 666  :     };
; 667  : 
; 668  :     switch( opndx.kind ) {

	cmp	edx, -2
	je	$LN124@data_item
	test	edx, edx
	je	$LN119@data_item
	cmp	edx, 1
	je	$LN91@data_item
	cmp	edx, 2
	je	$LN7@data_item
	cmp	edx, 3
	jne	$LN219@data_item

; 676  :     case EXPR_FLOAT:
; 677  :         DebugMsg1(("data_item.FLOAT: >%s<, inside_struct=%u, no_of_bytes=%u, curr_ofs=%X\n",
; 678  :                    opndx.float_tok->string_ptr, inside_struct, no_of_bytes, GetCurrOffset()));
; 679  :         if (!inside_struct)

	test	r8b, r8b
	jne	$LN195@data_item

; 680  :             output_float( &opndx, no_of_bytes );

	mov	ecx, DWORD PTR opndx$[rsp+64]
	cmp	ecx, 192				; 000000c0H
	je	SHORT $LN190@data_item
	xor	eax, eax
	xor	r8d, r8d
	mov	edx, 254				; 000000feH
	mov	QWORD PTR buffer$6459[rsp], rax
	mov	QWORD PTR buffer$6459[rsp+8], rax
	mov	QWORD PTR buffer$6459[rsp+16], rax
	mov	QWORD PTR buffer$6459[rsp+24], rax
	call	SizeFromMemtype
	cmp	eax, esi
	mov	r8d, eax
	jbe	SHORT $LN193@data_item
	mov	ecx, 55					; 00000037H
	call	EmitErr
	jmp	SHORT $LN189@data_item
$LN193@data_item:
	mov	rdx, QWORD PTR opndx$[rsp+16]
	mov	r9d, DWORD PTR opndx$[rsp+72]
	lea	rcx, QWORD PTR buffer$6459[rsp]
	movzx	eax, BYTE PTR [rdx+1]
	mov	rdx, QWORD PTR [rdx+8]
	shr	r9d, 5
	and	r9b, 1
	mov	BYTE PTR [rsp+32], al
	call	atofloat
	jmp	SHORT $LN189@data_item
$LN190@data_item:
	mov	rdx, QWORD PTR opndx$[rsp+16]
	mov	r9d, DWORD PTR opndx$[rsp+72]
	lea	rcx, QWORD PTR buffer$6459[rsp]
	movzx	eax, BYTE PTR [rdx+1]
	mov	rdx, QWORD PTR [rdx+8]
	shr	r9d, 5
	and	r9b, 1
	mov	r8d, esi
	mov	BYTE PTR [rsp+32], al
	call	atofloat
$LN189@data_item:
	lea	rcx, QWORD PTR buffer$6459[rsp]
	xor	r8d, r8d
	mov	edx, esi
	call	OutputBytes
$LN195@data_item:

; 681  :         total++;

	inc	ebx
	mov	DWORD PTR total$1$[rsp], ebx

; 682  :         break;

	jmp	$item_done$6021
$LN7@data_item:

; 1087 :     case EXPR_REG:
; 1088 :         EmitError( INVALID_USE_OF_REGISTER );

	mov	ecx, 170				; 000000aaH
	call	EmitError

; 1089 :         break;

	jmp	$item_done$6021
$LN91@data_item:

; 798  :         }
; 799  :         break;
; 800  :     case EXPR_ADDR:
; 801  :         /* since a fixup will be created, 8 bytes is max.
; 802  :          * there's no way to define an initialized tbyte "far64" address,
; 803  :          * because there's no fixup available for the selector part.
; 804  :          */
; 805  :         if ( no_of_bytes > sizeof(uint_64) ) {

	cmp	esi, 8
	jbe	SHORT $LN90@data_item

; 806  :             EmitErr( INVALID_DATA_INITIALIZER, sym ? sym->name : "" );

	test	rbp, rbp
	je	SHORT $LN179@data_item
	mov	rdx, QWORD PTR [rbp+8]
	mov	ecx, 231				; 000000e7H
	call	EmitErr

; 807  :             break;

	jmp	$item_done$6021
$LN179@data_item:

; 806  :             EmitErr( INVALID_DATA_INITIALIZER, sym ? sym->name : "" );

	lea	rdx, OFFSET FLAT:$SG6113
	mov	ecx, 231				; 000000e7H
	call	EmitErr

; 807  :             break;

	jmp	$item_done$6021
$LN90@data_item:

; 808  :         }
; 809  :         /* indirect addressing (incl. stack variables) is invalid */
; 810  :         if ( opndx.indirect == TRUE ) {

	test	BYTE PTR opndx$[rsp+72], 1
	je	SHORT $LN89@data_item

; 811  :             DebugMsg(("data_item.ADDR: error, indirect=%u, sym=%X\n", opndx.indirect, opndx.sym ));
; 812  :             EmitError( INVALID_USE_OF_REGISTER );

	mov	ecx, 170				; 000000aaH
	call	EmitError

; 813  :             break;

	jmp	$item_done$6021
$LN89@data_item:

; 814  :         }
; 815  : #if AMD64_SUPPORT
; 816  :         if ( ModuleInfo.Ofssize != USE64 )

	cmp	BYTE PTR ModuleInfo+404, 2
	je	SHORT $LN87@data_item

; 817  : #endif
; 818  :             if ( opndx.hvalue && ( opndx.hvalue != -1 || opndx.value >= 0 ) ) {

	mov	eax, DWORD PTR opndx$[rsp+4]
	test	eax, eax
	je	SHORT $LN87@data_item
	cmp	eax, -1
	jne	$LN86@data_item
	cmp	DWORD PTR opndx$[rsp], 0
	jge	$LN86@data_item
$LN87@data_item:

; 825  :             }
; 826  : 
; 827  :         if ( is_float ) {

	cmp	BYTE PTR is_float$[rsp], 0
	je	SHORT $LN85@data_item

; 828  :             DebugMsg(("data_item.ADDR: error, is_float=%u\n", is_float ));
; 829  :             EmitError( MUST_USE_FLOAT_INITIALIZER );

	mov	ecx, 212				; 000000d4H
	call	EmitError

; 830  :             break;

	jmp	$item_done$6021
$LN85@data_item:

; 831  :         }
; 832  : 
; 833  :         total++;

	inc	ebx

; 834  :         /* for STRUCT fields, don't emit anything! */
; 835  :         if ( inside_struct ) {

	test	r8b, r8b
	mov	DWORD PTR total$1$[rsp], ebx
	jne	$item_done$6021

; 836  :             break;
; 837  :         }
; 838  : 
; 839  :         /* determine what type of fixup is to be created */
; 840  : 
; 841  :         switch ( opndx.instr ) {

	mov	eax, DWORD PTR opndx$[rsp+56]
	add	eax, -230				; ffffffffffffff1aH
	cmp	eax, 14
	ja	$LN56@data_item
	lea	rdx, OFFSET FLAT:__ImageBase
	cdqe
	mov	ecx, DWORD PTR $LN229@data_item[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN81@data_item:

; 842  :         case T_SEG:
; 843  :             if ( no_of_bytes < 2 ) {

	cmp	esi, 2
	jae	SHORT $LN80@data_item

; 844  :                 DebugMsg(("data_item.ADDR: error, a SEG wont fit in a BYTE\n" ));
; 845  :                 EmitError( MAGNITUDE_TOO_LARGE_FOR_SPECIFIED_SIZE );

	mov	ecx, 76					; 0000004cH
	call	EmitError
$LN80@data_item:

; 846  :             }
; 847  :             fixup_type = FIX_SEG;

	mov	edi, 8

; 848  :             break;

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN79@data_item:

; 849  :         case T_OFFSET:
; 850  :             switch ( no_of_bytes ) {

	mov	eax, esi
	dec	eax
	je	SHORT $LN76@data_item
	dec	eax
	je	SHORT $LN73@data_item
	cmp	eax, 6
	jne	SHORT $LN71@data_item

; 865  : #if AMD64_SUPPORT
; 866  :             case 8:
; 867  :                 if ( ModuleInfo.Ofssize == USE64 ) {

	cmp	BYTE PTR ModuleInfo+404, 2
	jne	SHORT $LN71@data_item

; 868  :                     fixup_type = FIX_OFF64;

	lea	edi, QWORD PTR [rax+1]

; 869  :                     break;

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN71@data_item:

; 870  :                 }
; 871  : #endif
; 872  :             default:
; 873  :                 if ( opndx.sym && ( GetSymOfssize(opndx.sym) == USE16 ) )

	mov	rax, QWORD PTR opndx$[rsp+80]
	test	rax, rax
	je	SHORT $LN230@data_item
	mov	rcx, rax
	call	GetSymOfssize
	test	eax, eax
	jne	SHORT $LN230@data_item

; 874  :                     fixup_type = FIX_OFF16;

	lea	edi, QWORD PTR [rax+5]

; 875  :                 else

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN230@data_item:

; 876  :                     fixup_type = FIX_OFF32;

	mov	edi, 6

; 877  :                 break;

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN73@data_item:

; 860  :                 }
; 861  :                 break;
; 862  :             case 2:
; 863  :                 fixup_type = FIX_OFF16;

	mov	edi, 5

; 864  :                 break;

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN76@data_item:

; 851  :             case 1:
; 852  :                 /* forward reference? */
; 853  :                 if ( Parse_Pass == PASS_1 && opndx.sym && opndx.sym->state == SYM_UNDEFINED ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN75@data_item
	mov	rax, QWORD PTR opndx$[rsp+80]
	test	rax, rax
	je	SHORT $LN75@data_item
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN75@data_item

; 854  :                     DebugMsg(("data_item.ADDR: forward reference + OFFSET operator + DB -> may become error in Pass 2\n" ));
; 855  :                     fixup_type = FIX_VOID; /* v2.10: was regression in v2.09 */

	xor	ecx, ecx
	mov	edi, ecx

; 856  :                 } else {

	jmp	$LN233@data_item
$LN75@data_item:

; 857  :                     DebugMsg(("data_item.ADDR: error, an offset wont fit in a BYTE\n" ));
; 858  :                     EmitError( OFFSET_MAGNITUDE_TOO_LARGE );

	mov	ecx, 57					; 00000039H
	call	EmitError

; 859  :                     fixup_type = FIX_OFF8;

	mov	edi, 4

; 878  :             }
; 879  :             break;

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN67@data_item:

; 880  : #if IMAGERELSUPP
; 881  :         case T_IMAGEREL:
; 882  :             if ( no_of_bytes < sizeof(uint_32) ) {

	cmp	esi, 4
	jae	SHORT $LN66@data_item

; 883  :                 DebugMsg(("data_item.ADDR: IMAGEREL, error, size=%u (should be 4)\n", no_of_bytes ));
; 884  :                 EmitError( OFFSET_MAGNITUDE_TOO_LARGE );

	mov	ecx, 57					; 00000039H
	call	EmitError
$LN66@data_item:

; 885  :             }
; 886  :             fixup_type = FIX_OFF32_IMGREL;

	mov	edi, 12

; 887  :             break;

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN65@data_item:

; 888  : #endif
; 889  : #if SECTIONRELSUPP
; 890  :         case T_SECTIONREL:
; 891  :             if ( no_of_bytes < sizeof(uint_32) ) {

	cmp	esi, 4
	jae	SHORT $LN64@data_item

; 892  :                 DebugMsg(("data_item.ADDR: SECTIONREL, error, size=%u (should be 4)\n", no_of_bytes ));
; 893  :                 EmitError( OFFSET_MAGNITUDE_TOO_LARGE );

	mov	ecx, 57					; 00000039H
	call	EmitError
$LN64@data_item:

; 894  :             }
; 895  :             fixup_type = FIX_OFF32_SECREL;

	mov	edi, 13

; 896  :             break;

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN63@data_item:

; 897  : #endif
; 898  :         case T_LOW:
; 899  :             fixup_type = FIX_OFF8; /* OMF, BIN + GNU-ELF only */

	mov	edi, 4

; 900  :             break;

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN62@data_item:

; 901  :         case T_HIGH:
; 902  :             DebugMsg(("data_item.ADDR: HIGH detected\n"));
; 903  :             fixup_type = FIX_HIBYTE; /* OMF only */

	mov	edi, 11

; 904  :             break;

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN61@data_item:

; 905  :         case T_LOWWORD:
; 906  :             fixup_type = FIX_OFF16;
; 907  :             if ( no_of_bytes < 2 ) {

	cmp	esi, 2
	mov	edi, 5
	jae	$LN246@data_item

; 908  :                 EmitError( MAGNITUDE_TOO_LARGE_FOR_SPECIFIED_SIZE );

	lea	ecx, QWORD PTR [rdi+71]
	call	EmitError

; 909  :                 break;

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN59@data_item:

; 910  :             }
; 911  :             break;
; 912  : #if LOHI32
; 913  :         case T_HIGH32:
; 914  :             /* no break */
; 915  : #endif
; 916  :         case T_HIGHWORD:
; 917  :             fixup_type = FIX_VOID;

	xor	eax, eax
	mov	edi, eax

; 918  :             EmitError( CONSTANT_EXPECTED );

	lea	ecx, QWORD PTR [rax+65]
	call	EmitError

; 919  :             break;

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN58@data_item:

; 920  : #if LOHI32
; 921  :         case T_LOW32:
; 922  :             fixup_type = FIX_OFF32;
; 923  :             if ( no_of_bytes < 4 ) {

	cmp	esi, 4
	mov	edi, 6
	jae	$LN247@data_item

; 924  :                 EmitError( MAGNITUDE_TOO_LARGE_FOR_SPECIFIED_SIZE );

	lea	ecx, QWORD PTR [rdi+70]
	call	EmitError

; 925  :                 break;

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN56@data_item:

; 926  :             }
; 927  :             break;
; 928  : #endif
; 929  :         default:
; 930  :             /* size < 2 can work with T_LOW|T_HIGH operator only */
; 931  :             if ( no_of_bytes < 2 ) {

	cmp	esi, 2
	jae	SHORT $LN53@data_item

; 932  :                 /* forward reference? */
; 933  :                 if ( Parse_Pass == PASS_1 && opndx.sym && opndx.sym->state == SYM_UNDEFINED )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN54@data_item
	mov	rax, QWORD PTR opndx$[rsp+80]
	test	rax, rax
	je	SHORT $LN52@data_item
	cmp	DWORD PTR [rax+40], 0
	je	SHORT $LN53@data_item
$LN54@data_item:

; 934  :                     ;
; 935  :                 else {
; 936  :                     /* v2.08: accept 1-byte absolute externals */
; 937  :                     if ( opndx.sym && opndx.sym->state == SYM_EXTERNAL && opndx.is_abs == TRUE ) {

	mov	rax, QWORD PTR opndx$[rsp+80]
	test	rax, rax
	je	SHORT $LN52@data_item
	cmp	DWORD PTR [rax+40], 2
	jne	SHORT $LN52@data_item
	test	BYTE PTR opndx$[rsp+72], 4
	jne	SHORT $LN51@data_item
$LN52@data_item:

; 938  :                     } else {
; 939  :                         DebugMsg(("data_item.ADDR: error, no of bytes=%u\n", no_of_bytes ));
; 940  :                         EmitError( MAGNITUDE_TOO_LARGE_FOR_SPECIFIED_SIZE );

	mov	ecx, 76					; 0000004cH
	call	EmitError
$LN51@data_item:

; 941  :                     }
; 942  :                     fixup_type = FIX_OFF8;

	mov	edi, 4

; 943  :                     break;

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN53@data_item:

; 944  :                 }
; 945  :             }
; 946  :             /* if the symbol references a segment or group,
; 947  :              then generate a segment fixup.
; 948  :              */
; 949  :             if ( opndx.sym && (opndx.sym->state == SYM_SEG || opndx.sym->state == SYM_GRP ) ) {

	mov	rax, QWORD PTR opndx$[rsp+80]
	test	rax, rax
	je	SHORT $LN50@data_item
	mov	ecx, DWORD PTR [rax+40]
	cmp	ecx, 3
	je	SHORT $LN49@data_item
	cmp	ecx, 4
	jne	SHORT $LN50@data_item
$LN49@data_item:

; 950  :                 fixup_type = FIX_SEG;

	mov	edi, 8

; 951  :                 break;

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN50@data_item:

; 952  :             }
; 953  : 
; 954  :             switch ( no_of_bytes ) {

	cmp	esi, 2
	je	$LN46@data_item
	cmp	esi, 4
	je	$LN39@data_item
	cmp	esi, 6
	je	SHORT $LN23@data_item

; 1039 :             default:
; 1040 :                 /* Masm generates
; 1041 :                  * off32 if curr segment is 32bit
; 1042 :                  * ptr16 if curr segment is 16bit
; 1043 :                  * HJWasm additionally accepts a FAR32 PTR override
; 1044 :                  * and generates a ptr32 fixup then */
; 1045 :                 if ( opndx.explicit == TRUE && opndx.mem_type == MT_FAR && opndx.Ofssize == USE32 )

	test	BYTE PTR opndx$[rsp+72], 2
	je	SHORT $LN18@data_item
	cmp	DWORD PTR opndx$[rsp+64], 130		; 00000082H
	jne	SHORT $LN18@data_item
	cmp	BYTE PTR opndx$[rsp+69], 1
	jne	SHORT $LN18@data_item

; 1046 :                     fixup_type = FIX_PTR32;

	mov	edi, 10
	xor	ecx, ecx
	jmp	$LN233@data_item
$LN18@data_item:

; 1047 :                 else if( ModuleInfo.Ofssize == USE32 )

	cmp	BYTE PTR ModuleInfo+404, 1
	jne	SHORT $LN16@data_item

; 1048 :                     fixup_type = FIX_OFF32;

	mov	edi, 6
	xor	ecx, ecx
	jmp	$LN233@data_item
$LN16@data_item:

; 1049 : #if AMD64_SUPPORT
; 1050 :                 else if( ModuleInfo.Ofssize == USE64 )

	cmp	BYTE PTR ModuleInfo+404, 2
	mov	edi, 9
	mov	eax, 7
	cmove	edi, eax

; 1051 :                     fixup_type = FIX_OFF64;
; 1052 : #endif
; 1053 :                 else
; 1054 :                     fixup_type = FIX_PTR16;

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN23@data_item:

; 1023 :             case 6:
; 1024 :                 /* Masm generates a PTR32 fixup in OMF!
; 1025 :                  * and a DIR32 fixup in COFF.
; 1026 :                  */
; 1027 :                 /* COFF/ELF has no far fixups */
; 1028 : #if COFF_SUPPORT || ELF_SUPPORT
; 1029 :                 if ( Options.output_format == OFORMAT_COFF
; 1030 : #if ELF_SUPPORT
; 1031 :                     || Options.output_format == OFORMAT_ELF
; 1032 : #endif
; 1033 :                    ) {

	mov	eax, DWORD PTR Options+156
	cmp	eax, 2
	je	SHORT $LN21@data_item
	cmp	eax, 3
	je	SHORT $LN21@data_item

; 1035 :                 } else
; 1036 : #endif
; 1037 :                     fixup_type = FIX_PTR32;

	mov	edi, 10
	xor	ecx, ecx
	jmp	$LN233@data_item
$LN21@data_item:

; 1034 :                     fixup_type = FIX_OFF32;

	mov	edi, 6

; 1038 :                 break;

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN39@data_item:

; 974  :                 break;
; 975  :             case 4:
; 976  :                 /* masm generates:
; 977  :                  * off32 if curr segment is 32bit,
; 978  :                  * ptr16 if curr segment is 16bit,
; 979  :                  * and ignores type overrides.
; 980  :                  * if it's a NEAR external, size is 16, and
; 981  :                  * format isn't OMF, error 'symbol type conflict'
; 982  :                  * is displayed
; 983  :                  */
; 984  :                 if ( opndx.explicit == TRUE ) {

	test	BYTE PTR opndx$[rsp+72], 2
	je	$LN38@data_item

; 985  :                     if ( opndx.mem_type == MT_FAR ) {

	mov	eax, DWORD PTR opndx$[rsp+64]
	cmp	eax, 130				; 00000082H
	jne	SHORT $LN37@data_item

; 986  :                         if ( opndx.Ofssize != USE_EMPTY && opndx.Ofssize != USE16 ) {

	movzx	eax, BYTE PTR opndx$[rsp+69]
	cmp	al, 254					; 000000feH
	je	SHORT $LN36@data_item
	test	al, al
	je	SHORT $LN36@data_item

; 987  :                             DebugMsg(("data_item.ADDR: error, FAR32 won't fit in a DWORD\n" ));
; 988  :                             EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, opndx.sym ? opndx.sym->name : "" );

	mov	rax, QWORD PTR opndx$[rsp+80]
	test	rax, rax
	je	SHORT $LN185@data_item
	mov	rdx, QWORD PTR [rax+8]
	jmp	SHORT $LN186@data_item
$LN185@data_item:
	lea	rdx, OFFSET FLAT:$SG6178
$LN186@data_item:
	mov	ecx, 172				; 000000acH
	call	EmitErr
$LN36@data_item:

; 989  :                         }
; 990  :                         fixup_type = FIX_PTR16;

	mov	edi, 9
	xor	ecx, ecx
	jmp	$LN233@data_item
$LN37@data_item:

; 991  :                     } else if ( opndx.mem_type == MT_NEAR ) {

	cmp	eax, 129				; 00000081H
	jne	$LN245@data_item

; 992  :                         if ( opndx.Ofssize == USE16 )

	cmp	BYTE PTR opndx$[rsp+69], 0
	jne	SHORT $LN33@data_item

; 993  :                             fixup_type = FIX_OFF16;

	lea	edi, QWORD PTR [rax-124]
	xor	ecx, ecx
	jmp	$LN233@data_item
$LN33@data_item:

; 994  :                         else if ( opndx.sym && ( GetSymOfssize( opndx.sym ) == USE16 ) )

	mov	rax, QWORD PTR opndx$[rsp+80]
	test	rax, rax
	je	SHORT $LN231@data_item
	mov	rcx, rax
	call	GetSymOfssize
	test	eax, eax
	jne	SHORT $LN231@data_item

; 995  :                             fixup_type = FIX_OFF16;

	lea	edi, QWORD PTR [rax+5]

; 996  :                         else

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN231@data_item:

; 997  :                             fixup_type = FIX_OFF32;

	mov	edi, 6

; 998  :                     }
; 999  :                 } else {

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN38@data_item:

; 1000 :                     /* what's done if code size is 16 is Masm-compatible.
; 1001 :                      * It's not very smart, however.
; 1002 :                      * A better strategy is to choose fixup type depending
; 1003 :                      * on the symbol's offset size.
; 1004 :                      */
; 1005 :                     //if ( opndx.sym && ( GetSymOfssize( opndx.sym ) == USE16 ) )
; 1006 :                     if ( ModuleInfo.Ofssize == USE16 )

	cmp	BYTE PTR ModuleInfo+404, 0
	jne	SHORT $LN28@data_item

; 1007 : #if COFF_SUPPORT || ELF_SUPPORT
; 1008 :                         if ( opndx.mem_type == MT_NEAR &&
; 1009 :                             ( Options.output_format == OFORMAT_COFF
; 1010 : #if ELF_SUPPORT
; 1011 :                              || Options.output_format == OFORMAT_ELF
; 1012 : #endif
; 1013 :                             )) {

	cmp	DWORD PTR opndx$[rsp+64], 129		; 00000081H
	jne	SHORT $LN27@data_item
	mov	eax, DWORD PTR Options+156
	cmp	eax, 2
	je	SHORT $LN26@data_item
	cmp	eax, 3
	jne	SHORT $LN27@data_item
$LN26@data_item:

; 1014 :                             fixup_type = FIX_OFF16;
; 1015 :                             EmitErr( SYMBOL_TYPE_CONFLICT, sym->name );

	mov	rdx, QWORD PTR [rbp+8]
	mov	ecx, 136				; 00000088H
	mov	edi, 5
	call	EmitErr

; 1016 :                         } else

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN27@data_item:

; 1017 : #endif
; 1018 :                             fixup_type = FIX_PTR16;

	mov	edi, 9

; 1019 :                     else

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN28@data_item:

; 1020 :                         fixup_type = FIX_OFF32;

	mov	edi, 6

; 1021 :                 }
; 1022 :                 break;

	xor	ecx, ecx
	jmp	$LN233@data_item
$LN46@data_item:

; 955  :             case 2:
; 956  :                 /* accept "near16" override, else complain
; 957  :                  * if symbol's offset is 32bit */
; 958  :                 /* v2.06: if condition changed */
; 959  :                 //if ( opndx.explicit == TRUE && opndx.mem_type == MT_NEAR && opndx.Ofssize == USE16 )
; 960  :                 if ( opndx.explicit == TRUE ) {

	test	BYTE PTR opndx$[rsp+72], 2
	je	SHORT $LN45@data_item

; 961  :                     if ( SizeFromMemtype( opndx.mem_type, opndx.Ofssize, opndx.type ) > no_of_bytes ) {

	movzx	edx, BYTE PTR opndx$[rsp+69]
	mov	r8, QWORD PTR opndx$[rsp+96]
	mov	ecx, DWORD PTR opndx$[rsp+64]
	call	SizeFromMemtype
	cmp	eax, 2
	jbe	$LN232@data_item

; 962  :                         DebugMsg(("data_item.ADDR: error, memtype %X wont fit in a WORD\n", opndx.mem_type));
; 963  :                         EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, opndx.sym ? opndx.sym->name : "" );

	mov	rax, QWORD PTR opndx$[rsp+80]
	test	rax, rax
	je	SHORT $LN181@data_item
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 172				; 000000acH
	call	EmitErr

; 972  :                 }
; 973  :                 fixup_type = FIX_OFF16;

	mov	edi, 5
	xor	ecx, ecx
	jmp	$LN233@data_item
$LN181@data_item:

; 962  :                         DebugMsg(("data_item.ADDR: error, memtype %X wont fit in a WORD\n", opndx.mem_type));
; 963  :                         EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, opndx.sym ? opndx.sym->name : "" );

	lea	rdx, OFFSET FLAT:$SG6168
	mov	ecx, 172				; 000000acH
	call	EmitErr

; 972  :                 }
; 973  :                 fixup_type = FIX_OFF16;

	mov	edi, 5
	xor	ecx, ecx
	jmp	SHORT $LN233@data_item
$LN45@data_item:

; 964  :                     };
; 965  :                 } else if ( opndx.sym && opndx.sym->state == SYM_EXTERNAL && opndx.is_abs == TRUE ) {

	mov	rax, QWORD PTR opndx$[rsp+80]
	test	rax, rax
	je	SHORT $LN232@data_item
	mov	ecx, DWORD PTR [rax+40]
	cmp	ecx, 2
	jne	SHORT $LN42@data_item
	test	BYTE PTR opndx$[rsp+72], 4
	jne	SHORT $LN232@data_item
$LN42@data_item:

; 966  :                     /* v2.07a: accept ABSolute externals (regression in v2.07) */
; 967  :                 } else if ( opndx.sym &&
; 968  :                            opndx.sym->state != SYM_UNDEFINED &&
; 969  :                            ( GetSymOfssize(opndx.sym) > USE16 ) ) {

	test	ecx, ecx
	je	SHORT $LN232@data_item
	mov	rcx, QWORD PTR opndx$[rsp+80]
	call	GetSymOfssize
	test	eax, eax
	jle	SHORT $LN232@data_item

; 970  :                     DebugMsg(("data_item.ADDR: error, a 32bit offset (%s) wont fit in a WORD\n", opndx.sym->name));
; 971  :                     EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, opndx.sym ? opndx.sym->name : "" );

	mov	rax, QWORD PTR opndx$[rsp+80]
	test	rax, rax
	je	SHORT $LN183@data_item
	mov	rdx, QWORD PTR [rax+8]
	jmp	SHORT $LN184@data_item
$LN183@data_item:
	lea	rdx, OFFSET FLAT:$SG6173
$LN184@data_item:
	mov	ecx, 172				; 000000acH
	call	EmitErr
$LN232@data_item:

; 972  :                 }
; 973  :                 fixup_type = FIX_OFF16;

	mov	edi, 5
	xor	ecx, ecx
	jmp	SHORT $LN233@data_item
$LN245@data_item:

; 485  :     //unsigned int        count;
; 486  :     uint_8              *pchar;
; 487  :     char                tmp;
; 488  :     enum fixup_types    fixup_type;
; 489  :     struct fixup        *fixup;
; 490  :     struct expr         opndx;
; 491  : 
; 492  :     DebugMsg1(("data_item( idx=%u [%s], label=%s, no_of_bytes=%" I32_SPEC "u, type=%s, dup=%" I32_SPEC "Xh, inside_struct=%u, is_float=%u ) enter\n",
; 493  :                *start_pos, tokenarray[*start_pos].tokpos, sym ? sym->name : "NULL",
; 494  :                no_of_bytes, type_sym ? type_sym->name : "NULL",
; 495  :                dup, inside_struct, is_float ));
; 496  : 
; 497  :     for ( ; dup; dup-- ) {

	xor	ecx, ecx
	jmp	SHORT $LN233@data_item
$LN246@data_item:
	xor	ecx, ecx
	jmp	SHORT $LN233@data_item
$LN247@data_item:
	xor	ecx, ecx
$LN233@data_item:

; 1055 :             }
; 1056 :             break;
; 1057 :         } /* end switch ( opndx.instr ) */
; 1058 : 
; 1059 :         /* v2.07: fixup type check moved here */
; 1060 :         if ( ( 1 << fixup_type ) & ModuleInfo.fmtopt->invalid_fixup_type ) {

	mov	rdx, QWORD PTR ModuleInfo+344
	movsx	eax, WORD PTR [rdx+8]
	bt	eax, edi
	jb	$LN220@data_item

; 1064 :         }
; 1065 :         fixup = NULL;
; 1066 :         if ( write_to_file ) {

	cmp	BYTE PTR write_to_file, 0
	mov	rax, rcx
	je	SHORT $LN11@data_item

; 1067 :             /* there might be a segment override:
; 1068 :              * a segment, a group or a segment register.
; 1069 :              * Init var SegOverride, it's used inside set_frame()
; 1070 :              */
; 1071 :             SegOverride = NULL;

	mov	QWORD PTR SegOverride, rcx

; 1072 :             segm_override( &opndx, NULL );

	lea	rcx, QWORD PTR opndx$[rsp]
	xor	edx, edx
	call	segm_override

; 1073 : 
; 1074 :             /* set global vars Frame and Frame_Datum */
; 1075 :             /* opndx.sym may be NULL, then SegOverride is set. */
; 1076 :             if ( ModuleInfo.offsettype == OT_SEGMENT &&
; 1077 :                 ( opndx.instr == T_OFFSET || opndx.instr == T_SEG ))

	cmp	DWORD PTR ModuleInfo+384, 2
	jne	SHORT $LN10@data_item
	mov	eax, DWORD PTR opndx$[rsp+56]
	cmp	eax, 241				; 000000f1H
	je	SHORT $LN9@data_item
	cmp	eax, 244				; 000000f4H
	jne	SHORT $LN10@data_item
$LN9@data_item:

; 1078 :                 set_frame2( opndx.sym );

	mov	rcx, QWORD PTR opndx$[rsp+80]
	call	set_frame2

; 1079 :             else

	jmp	SHORT $LN8@data_item
$LN10@data_item:

; 1080 :                 set_frame( opndx.sym );

	mov	rcx, QWORD PTR opndx$[rsp+80]
	call	set_frame
$LN8@data_item:

; 1081 :             /* uses Frame and Frame_Datum  */
; 1082 :             fixup = CreateFixup( opndx.sym, fixup_type, OPTJ_NONE );

	mov	rcx, QWORD PTR opndx$[rsp+80]
	xor	r8d, r8d
	mov	edx, edi
	call	CreateFixup
$LN11@data_item:

; 1083 :             //store_fixup( fixup, &opndx.value ); /* may fail, but ignore error! */
; 1084 :         }
; 1085 :         OutputBytes( (unsigned char *)&opndx.value, no_of_bytes, fixup );

	lea	rcx, QWORD PTR opndx$[rsp]
	mov	r8, rax
	mov	edx, esi
	call	OutputBytes

; 1086 :         break;

	jmp	$item_done$6021
$LN119@data_item:

; 683  :     case EXPR_CONST:
; 684  :         if ( is_float ) {

	cmp	BYTE PTR is_float$[rsp], 0
	je	$LN118@data_item

; 685  : 			opndx.fvalue = (float)opndx.value;

	cvtsi2ss xmm0, DWORD PTR opndx$[rsp]

; 686  : 			opndx.kind = EXPR_FLOATI;

	mov	DWORD PTR opndx$[rsp+60], 4

; 687  : 			opndx.negative = (opndx.fvalue < 0) ? 1 : 0;

	comiss	xmm7, xmm0
	movss	DWORD PTR opndx$[rsp], xmm0
	jbe	SHORT $LN173@data_item
	mov	ecx, 1
	jmp	SHORT $LN174@data_item
$LN173@data_item:
	xor	eax, eax
	mov	ecx, eax
$LN174@data_item:
	mov	eax, DWORD PTR opndx$[rsp+72]
	shl	ecx, 5
	xor	ecx, eax
	and	ecx, 32					; 00000020H
	xor	eax, ecx

; 688  : 			if (opndx.negative)

	test	al, 32					; 00000020H
	mov	DWORD PTR opndx$[rsp+72], eax
	je	SHORT $LN117@data_item

; 689  : 				opndx.fvalue *= -1;

	mulss	xmm0, xmm6
	movss	DWORD PTR opndx$[rsp], xmm0
$LN117@data_item:

; 690  : 			output_float( &opndx, no_of_bytes); /* Coerce const integer value to float in data definitions */

	mov	ecx, DWORD PTR opndx$[rsp+64]
	cmp	ecx, 192				; 000000c0H
	je	SHORT $LN228@data_item
	xor	eax, eax
	xor	r8d, r8d
	mov	edx, 254				; 000000feH
	mov	QWORD PTR buffer$6471[rsp], rax
	mov	QWORD PTR buffer$6471[rsp+8], rax
	mov	QWORD PTR buffer$6471[rsp+16], rax
	mov	QWORD PTR buffer$6471[rsp+24], rax
	call	SizeFromMemtype
	cmp	eax, esi
	mov	r8d, eax
	jbe	SHORT $LN201@data_item
	mov	ecx, 55					; 00000037H
	call	EmitErr
	jmp	$LN197@data_item
$LN201@data_item:
	mov	rdx, QWORD PTR opndx$[rsp+16]
	mov	r9d, DWORD PTR opndx$[rsp+72]
	lea	rcx, QWORD PTR buffer$6471[rsp]
	movzx	eax, BYTE PTR [rdx+1]
	mov	rdx, QWORD PTR [rdx+8]
	shr	r9d, 5
	and	r9b, 1
	mov	BYTE PTR [rsp+32], al
	call	atofloat
	jmp	SHORT $LN197@data_item
$LN228@data_item:
	cvtss2sd xmm3, xmm0
	lea	r8, OFFSET FLAT:$SG5972
	lea	rcx, QWORD PTR tstr$6472[rsp]
	mov	edx, 32					; 00000020H
	movd	r9, xmm3
	call	_snprintf
	mov	r9d, DWORD PTR opndx$[rsp+72]
	shr	r9d, 5
	lea	rdx, QWORD PTR tstr$6472[rsp]
	lea	rcx, QWORD PTR buffer$6471[rsp]
	mov	r8d, esi
	and	r9b, 1
	mov	BYTE PTR [rsp+32], 0
	call	atofloat
$LN197@data_item:
	lea	rcx, QWORD PTR buffer$6471[rsp]
	xor	r8d, r8d
	mov	edx, esi
	call	OutputBytes

; 691  : 			total++;

	inc	ebx
	mov	DWORD PTR total$1$[rsp], ebx

; 692  : 			break;

	jmp	$item_done$6021
$LN118@data_item:

; 693  :             //return( EmitError( MUST_USE_FLOAT_INITIALIZER ) );
; 694  :         }
; 695  : 
; 696  :         /* a string returned by the evaluator (enclosed in quotes!)? */
; 697  : 
; 698  :         if ( opndx.quoted_string ) {

	mov	rdx, QWORD PTR opndx$[rsp+16]
	test	rdx, rdx
	je	$LN116@data_item

; 699  :             DebugMsg1(("data_item.CONST: string found: >%s<, inside_struct=%u, no_of_bytes=%u, curr_ofs=%X\n",
; 700  :                        opndx.quoted_string->string_ptr, inside_struct, no_of_bytes, GetCurrOffset()));
; 701  :             pchar = (uint_8 *)opndx.quoted_string->string_ptr + 1;

	mov	rax, QWORD PTR [rdx+8]

; 702  :             string_len = opndx.quoted_string->stringlen; /* this is the length without quotes */

	mov	ebx, DWORD PTR [rdx+16]
	inc	rax

; 703  : 
; 704  :             /* v2.07: check for empty string for ALL types */
; 705  :             if ( string_len == 0 ) {

	test	ebx, ebx
	jne	SHORT $LN113@data_item

; 706  :                 if ( inside_struct ) {

	test	r8b, r8b
	je	$LN114@data_item

; 707  :                     /* when the struct is declared, it's no error -
; 708  :                      * but won't be accepted when the struct is instanced.
; 709  :                      * v2.07: don't modify string_len! Instead
; 710  :                      * mark field as array!
; 711  :                      */
; 712  :                     //string_len = 1;
; 713  :                     sym->isarray = TRUE;

	or	BYTE PTR [rbp+49], 2
$LN113@data_item:

; 716  :                 }
; 717  :             }
; 718  :             /* a string is only regarded as an array if item size is 1 */
; 719  :             /* else it is regarded as ONE item */
; 720  :             if( no_of_bytes != 1 ) {

	cmp	esi, 1
	je	SHORT $LN111@data_item

; 721  :                 if( string_len > no_of_bytes && sym->mem_type != MT_WORD ) {

	cmp	ebx, esi
	jbe	SHORT $LN111@data_item
	cmp	DWORD PTR [rbp+44], 1
	jne	$LN221@data_item
$LN111@data_item:

; 723  :                 }
; 724  :             }
; 725  : 
; 726  :             if( sym && Parse_Pass == PASS_1 && string_len > 0 ) {

	test	rbp, rbp
	je	SHORT $LN234@data_item
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN234@data_item
	test	ebx, ebx
	jle	SHORT $LN234@data_item

; 727  :                 total++;

	mov	ecx, DWORD PTR total$1$[rsp]
	inc	ecx

; 728  :                 if ( no_of_bytes == 1 && string_len > 1 ) {

	cmp	esi, 1
	mov	DWORD PTR total$1$[rsp], ecx
	jne	SHORT $LN234@data_item
	cmp	ebx, esi
	jle	SHORT $LN234@data_item

; 729  :                     total += ( string_len - 1 );
; 730  :                     sym->isarray = TRUE; /* v2.07: added */

	or	BYTE PTR [rbp+49], 2

; 731  :                     if ( first ) {

	cmp	BYTE PTR first$[rsp], 0
	lea	ecx, DWORD PTR [rcx+rbx-1]
	mov	DWORD PTR total$1$[rsp], ecx
	je	SHORT $LN234@data_item

; 732  :                         sym->first_length = 1;

	mov	DWORD PTR [rbp+56], esi

; 733  :                         sym->first_size = 1;

	mov	DWORD PTR [rbp+52], esi

; 734  :                         first = FALSE; /* avoid to touch first_xxx fields below */

	mov	BYTE PTR first$[rsp], 0
$LN234@data_item:

; 735  :                     }
; 736  :                 }
; 737  :             }
; 738  : 
; 739  :             if( !inside_struct ) {

	test	r8b, r8b
	jne	$LN241@data_item

; 740  :                 /* anything bigger than a byte must be stored in little-endian
; 741  :                  * format -- LSB first */
; 742  : 				if (string_len > 1 && no_of_bytes > 1 && sym->mem_type == MT_WORD)

	cmp	ebx, 1
	jle	SHORT $LN104@data_item
	cmp	esi, 1
	jbe	SHORT $LN104@data_item
	cmp	DWORD PTR [rbp+44], 1
	jne	SHORT $LN106@data_item

; 743  : 				{
; 744  : 					OutputInterleavedDataBytes(pchar, string_len);

	xor	r8d, r8d
	mov	edx, ebx
	mov	rcx, rax
	call	OutputInterleavedBytes

; 745  : 				}
; 746  : 				else

	jmp	SHORT $LN105@data_item
$LN106@data_item:

; 747  : 				{
; 748  : 					if (string_len > 1 && no_of_bytes > 1)
; 749  : 					{
; 750  : 						pchar = little_endian((const char *)pchar, string_len);

	mov	edx, ebx
	mov	rcx, rax
	call	little_endian
$LN104@data_item:

; 751  : 					}
; 752  : 					OutputDataBytes(pchar, string_len);

	xor	r8d, r8d
	mov	edx, ebx
	mov	rcx, rax
	call	OutputBytes
$LN105@data_item:

; 753  : 				}
; 754  :                 if ( no_of_bytes > string_len )

	cmp	esi, ebx
	jbe	$LN242@data_item

; 755  :                     FillDataBytes( 0, no_of_bytes - string_len );

	mov	edx, esi
	xor	ecx, ecx
	sub	edx, ebx
	call	FillDataBytes

; 756  :             }
; 757  :         } else {

	mov	ebx, DWORD PTR total$1$[rsp]
	jmp	$item_done$6021
$LN116@data_item:

; 758  :             /* it's NOT a string */
; 759  :             DebugMsg1(("data_item.CONST: const found, value=%" I32_SPEC "Xh, no_of_bytes=%u, curr_ofs=%" I32_SPEC "X\n", opndx.value, no_of_bytes, GetCurrOffset()));
; 760  :             if( !inside_struct ) {

	test	r8b, r8b
	jne	$LN235@data_item

; 761  :                 /* the evaluator cannot handle types with size > 16.
; 762  :                  * so if a (simple) type is larger ( YMMWORD? ),
; 763  :                  * clear anything which is above.
; 764  :                  */
; 765  :                 if ( no_of_bytes > 16 ) {

	cmp	esi, 16
	jbe	SHORT $LN100@data_item

; 766  :                     OutputDataBytes( opndx.chararray, 16 );

	xor	r8d, r8d
	lea	rcx, QWORD PTR opndx$[rsp]
	lea	edx, QWORD PTR [r8+16]
	call	OutputBytes

; 767  :                     tmp = ( opndx.chararray[15] < 0x80 ? 0 : 0xFF );

	cmp	BYTE PTR opndx$[rsp+15], 128		; 00000080H
	mov	ecx, 0
	mov	eax, 255				; 000000ffH

; 768  :                     FillDataBytes( tmp, no_of_bytes - 16 );

	lea	edx, DWORD PTR [rsi-16]
	cmovb	eax, ecx
	movzx	ecx, al
	call	FillDataBytes

; 793  :                         }
; 794  :                     }
; 795  :                 }
; 796  :             }
; 797  :             total++;

	inc	ebx
	mov	DWORD PTR total$1$[rsp], ebx
	jmp	$item_done$6021
$LN100@data_item:

; 769  :                 } else {
; 770  :                     /* v2.06: TBYTE/OWORD/XMMWORD: extend a negative value to 16-byte */
; 771  :                     if ( no_of_bytes > sizeof( int_64 ) ) {

	cmp	esi, 8
	jbe	SHORT $LN97@data_item

; 772  :                         if ( opndx.negative && opndx.value64 < 0 && opndx.hlvalue == 0 )

	test	BYTE PTR opndx$[rsp+72], 32		; 00000020H
	je	SHORT $LN97@data_item
	cmp	QWORD PTR opndx$[rsp], 0
	jge	SHORT $LN97@data_item
	mov	rax, QWORD PTR opndx$[rsp+8]
	mov	rcx, -1
	test	rax, rax
	cmove	rax, rcx
	mov	QWORD PTR opndx$[rsp+8], rax
$LN97@data_item:

; 773  :                             opndx.hlvalue = -1;
; 774  :                     }
; 775  :                     OutputDataBytes( opndx.chararray, no_of_bytes );

	lea	rcx, QWORD PTR opndx$[rsp]
	xor	r8d, r8d
	mov	edx, esi
	call	OutputBytes

; 776  :                     /* check that there's no significant data left
; 777  :                      * which hasn't been emitted.
; 778  :                      */
; 779  :                     /* v2.06: rewritten, now more rigid and checks
; 780  :                      * 1-8 and 10 bytes instead of just 1-4.
; 781  :                      */
; 782  :                     if ( no_of_bytes <= sizeof( int_64 ) ) {

	cmp	esi, 8
	ja	SHORT $LN96@data_item

; 783  :                         tmp = ( opndx.chararray[7] < 0x80 ? 0 : 0xFF );

	cmp	BYTE PTR opndx$[rsp+7], 128		; 00000080H

; 784  :                         memset( opndx.chararray, tmp, no_of_bytes );

	lea	rcx, QWORD PTR opndx$[rsp]
	mov	r8, rsi
	sbb	edx, edx
	neg	edx
	dec	edx
	call	memset

; 785  :                         if ( opndx.llvalue != 0 && opndx.llvalue != -1 ) {

	mov	r11, QWORD PTR opndx$[rsp]
	test	r11, r11
	je	SHORT $LN235@data_item
	cmp	r11, -1
	je	SHORT $LN235@data_item

; 786  :                             DebugMsg(("data_item.CONST: error, unhandled data is %" I64_SPEC "X_%016" I64_SPEC "X\n", opndx.hlvalue, opndx.llvalue));
; 787  :                             return( EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, opndx.sym ? opndx.sym->name : "" ) );

	mov	rax, QWORD PTR opndx$[rsp+80]
	test	rax, rax
	je	$LN175@data_item
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 172				; 000000acH
	call	EmitErr
	jmp	$LN171@data_item
$LN96@data_item:

; 788  :                         }
; 789  :                     } else if ( no_of_bytes == 10 ) {

	cmp	esi, 10
	jne	SHORT $LN235@data_item

; 790  :                         //if ( opndx.hlvalue > 0xffff ) {
; 791  :                         if ( opndx.hlvalue > 0xffff && opndx.hlvalue < -0xffff ) {

	mov	rax, QWORD PTR opndx$[rsp+8]
	cmp	rax, 65535				; 0000ffffH
	jbe	SHORT $LN235@data_item
	cmp	rax, -65535				; ffffffffffff0001H
	jb	$LN223@data_item
$LN235@data_item:

; 793  :                         }
; 794  :                     }
; 795  :                 }
; 796  :             }
; 797  :             total++;

	inc	ebx
	mov	DWORD PTR total$1$[rsp], ebx
	jmp	SHORT $item_done$6021
$LN241@data_item:
	mov	ebx, DWORD PTR total$1$[rsp]
	jmp	SHORT $item_done$6021
$LN242@data_item:

; 756  :             }
; 757  :         } else {

	mov	ebx, DWORD PTR total$1$[rsp]
$item_done$6021:

; 1093 :     } /* end switch (opndx.kind) */
; 1094 : item_done:
; 1095 :     if( sym && first && Parse_Pass == PASS_1 ) {

	test	rbp, rbp
	je	SHORT $LN5@data_item
	cmp	BYTE PTR first$[rsp], 0
	je	SHORT $LN5@data_item
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN5@data_item

; 1096 :         sym->first_length = total;
; 1097 :         sym->first_size = total * no_of_bytes;

	mov	eax, ebx
	mov	DWORD PTR [rbp+56], ebx
	imul	eax, esi
	mov	DWORD PTR [rbp+52], eax
$LN5@data_item:

; 1098 :     }
; 1099 :     if( i < end && tokenarray[i].token == T_COMMA ) {

	movsxd	rax, DWORD PTR i$[rsp]
	cmp	eax, DWORD PTR end$[rsp]
	jge	SHORT $LN243@data_item
	mov	r10, QWORD PTR tokenarray$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+r10], 44			; 0000002cH
	jne	SHORT $LN169@data_item

; 1100 :         i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 1101 :         if ( tokenarray[i].token != T_FINAL &&
; 1102 :             tokenarray[i].token != T_CL_BRACKET ) {

	cdqe
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+r10]
	test	cl, cl
	je	SHORT $LN169@data_item
	cmp	cl, 41					; 00000029H
	je	SHORT $LN169@data_item

; 1103 :             first = FALSE;
; 1104 :             if ( sym )

	test	rbp, rbp
	mov	BYTE PTR first$[rsp], 0
	je	$next_item$6008

; 1105 :                 sym->isarray = TRUE;

	or	BYTE PTR [rbp+49], 2

; 1106 :             goto next_item;

	jmp	$next_item$6008
$LN243@data_item:

; 480  : {

	mov	r10, QWORD PTR tokenarray$[rsp]
$LN169@data_item:

; 485  :     //unsigned int        count;
; 486  :     uint_8              *pchar;
; 487  :     char                tmp;
; 488  :     enum fixup_types    fixup_type;
; 489  :     struct fixup        *fixup;
; 490  :     struct expr         opndx;
; 491  : 
; 492  :     DebugMsg1(("data_item( idx=%u [%s], label=%s, no_of_bytes=%" I32_SPEC "u, type=%s, dup=%" I32_SPEC "Xh, inside_struct=%u, is_float=%u ) enter\n",
; 493  :                *start_pos, tokenarray[*start_pos].tokpos, sym ? sym->name : "NULL",
; 494  :                no_of_bytes, type_sym ? type_sym->name : "NULL",
; 495  :                dup, inside_struct, is_float ));
; 496  : 
; 497  :     for ( ; dup; dup-- ) {

	mov	eax, DWORD PTR dup$[rsp]
	mov	rcx, QWORD PTR start_pos$[rsp]
	add	eax, -1					; ffffffffH
	mov	DWORD PTR dup$[rsp], eax
	jne	$LL170@data_item
$LN240@data_item:

; 1107 :         }
; 1108 :     }
; 1109 : 
; 1110 :     } /* end for */
; 1111 : 
; 1112 :     if( sym && Parse_Pass == PASS_1 ) {

	test	rbp, rbp
	je	SHORT $LN1@data_item
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN1@data_item

; 1113 :         sym->total_length += total;

	add	DWORD PTR [rbp+72], ebx

; 1114 :         sym->total_size += total * no_of_bytes;

	imul	ebx, esi
	add	DWORD PTR [rbp+64], ebx
$LN1@data_item:

; 1115 :     }
; 1116 : 
; 1117 :     *start_pos = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	DWORD PTR [rcx], eax

; 1118 :     DebugMsg1(("data_item: exit, no error, i=%d\n", i));
; 1119 :     return( NOT_ERROR );

	xor	eax, eax
$LN171@data_item:
	movdqa	xmm7, XMMWORD PTR [rsp+272]
	movdqa	xmm6, XMMWORD PTR [rsp+288]
	mov	rdi, QWORD PTR [rsp+312]
	mov	rsi, QWORD PTR [rsp+320]
	mov	rbp, QWORD PTR [rsp+328]
	mov	rbx, QWORD PTR [rsp+336]

; 1120 : }

	add	rsp, 344				; 00000158H
	ret	0
$LN213@data_item:

; 564  :             DebugMsg(("data_item, error, unexpected kind=%u of DUP's first operand\n", opndx.kind ));
; 565  :             /* v2.09: emit a better error msg if a forward ref was used */
; 566  :             if ( opndx.sym && opndx.sym->state == SYM_UNDEFINED )

	mov	rdx, QWORD PTR opndx$[rsp+80]
	test	rdx, rdx
	je	SHORT $LN153@data_item
	cmp	DWORD PTR [rdx+40], 0
	jne	SHORT $LN153@data_item

; 567  :                 EmitErr( SYMBOL_NOT_DEFINED, opndx.sym->name );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 102				; 00000066H
	call	EmitErr

; 570  :             return( ERROR );

	mov	rax, -1
	jmp	SHORT $LN171@data_item
$LN153@data_item:

; 568  :             else
; 569  :                 EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 570  :             return( ERROR );

	mov	rax, -1
	jmp	SHORT $LN171@data_item
$LN214@data_item:

; 574  :             return( EmitError( COUNT_MUST_BE_POSITIVE_OR_ZERO ) );

	mov	ecx, 208				; 000000d0H
	call	EmitError
	jmp	$LN171@data_item
$LN215@data_item:

; 578  :             DebugMsg(("data_item error, missing '('\n"));
; 579  :             return( EmitErr( EXPECTED, "(" ) );

	lea	rdx, OFFSET FLAT:$SG6031
	mov	ecx, 230				; 000000e6H
	call	EmitErr
	jmp	$LN171@data_item
$LN217@data_item:

; 604  :             DebugMsg(("data_item: error 'missing ')', exit\n"));
; 605  :             return( EmitErr( EXPECTED, ")" ) );

	lea	rdx, OFFSET FLAT:$SG6045
	mov	ecx, 230				; 000000e6H
	call	EmitErr
	jmp	$LN171@data_item
$LN218@data_item:

; 631  :             DebugMsg1(("data_item: error, type=%s needs literal, >%s<\n", type_sym->name, tokenarray[i].tokpos ));
; 632  :             return( EmitErr( STRUCTURE_IMPROPERLY_INITIALIZED, type_sym->name ) );

	mov	rdx, QWORD PTR [r11+8]
	mov	ecx, 229				; 000000e5H
	call	EmitErr
	jmp	$LN171@data_item
$LN219@data_item:

; 1090 :     default: /* unknown opndx.kind, shouldn't happen */
; 1091 :         DebugMsg(("data_item: error, opndx.kind=%u\n", opndx.kind ));
; 1092 :         return( EmitError( SYNTAX_ERROR ) );

	mov	ecx, 45					; 0000002dH
	call	EmitError
	jmp	$LN171@data_item
$LN86@data_item:

; 819  :                 /* v2.05: compared to Masm, the above is too restrictive.
; 820  :                  * the line below might be better.
; 821  :                  */
; 822  :                 //if ( opndx.hvalue != 0 && ( opndx.hvalue != -1 || opndx.value == 0 ) ) {
; 823  :                 DebugMsg(("data_item.ADDR: displacement doesn't fit in 32 bits: %" I64_SPEC "X\n", opndx.value64 ));
; 824  :                 return( EmitConstError( &opndx ) );

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError
	jmp	$LN171@data_item
$LN220@data_item:

; 1061 :             return( EmitErr( UNSUPPORTED_FIXUP_TYPE,
; 1062 :                     ModuleInfo.fmtopt->formatname,
; 1063 :                     opndx.sym ? opndx.sym->name : szNull ) );

	mov	rax, QWORD PTR opndx$[rsp+80]
	test	rax, rax
	je	SHORT $LN187@data_item
	mov	r8, QWORD PTR [rax+8]
	add	rdx, 10
	mov	ecx, 197				; 000000c5H
	call	EmitErr
	jmp	$LN171@data_item
$LN187@data_item:
	lea	r8, OFFSET FLAT:szNull
	add	rdx, 10
	mov	ecx, 197				; 000000c5H
	call	EmitErr
	jmp	$LN171@data_item
$LN114@data_item:

; 714  :                 } else {
; 715  :                     return( EmitError( EMPTY_STRING ) ); /* MASM doesn't like "" */

	mov	ecx, 163				; 000000a3H
	call	EmitError
	jmp	$LN171@data_item
$LN221@data_item:

; 722  :                     return( EmitError( INITIALIZER_OUT_OF_RANGE ) );

	mov	ecx, 55					; 00000037H
	call	EmitError
	jmp	$LN171@data_item
$LN175@data_item:

; 786  :                             DebugMsg(("data_item.CONST: error, unhandled data is %" I64_SPEC "X_%016" I64_SPEC "X\n", opndx.hlvalue, opndx.llvalue));
; 787  :                             return( EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, opndx.sym ? opndx.sym->name : "" ) );

	lea	rdx, OFFSET FLAT:$SG6105
	mov	ecx, 172				; 000000acH
	call	EmitErr
	jmp	$LN171@data_item
$LN223@data_item:

; 792  :                             return( EmitErr( INITIALIZER_MAGNITUDE_TOO_LARGE, opndx.sym ? opndx.sym->name : "" ) );

	mov	rax, QWORD PTR opndx$[rsp+80]
	test	rax, rax
	je	SHORT $LN177@data_item
	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 172				; 000000acH
	call	EmitErr
	jmp	$LN171@data_item
$LN177@data_item:
	lea	rdx, OFFSET FLAT:$SG6109
	mov	ecx, 172				; 000000acH
	call	EmitErr
	jmp	$LN171@data_item
$LN124@data_item:

; 669  :     case EXPR_EMPTY:
; 670  :         DebugMsg(("data_item.EMPTY: idx=%u, tokenarray.token=%X\n", i, tokenarray[i].token));
; 671  :         if ( tokenarray[i].token != T_FINAL )

	movsxd	rdx, DWORD PTR i$[rsp]
	shl	rdx, 5
	cmp	BYTE PTR [rdx+r10], 0
	je	SHORT $LN123@data_item

; 672  :             EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos );

	mov	rdx, QWORD PTR [rdx+r10+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 675  :         return( ERROR );

	mov	rax, -1
	jmp	$LN171@data_item
$LN123@data_item:

; 673  :         else
; 674  :             EmitError( SYNTAX_ERROR );

	mov	ecx, 45					; 0000002dH
	call	EmitError
$LN122@data_item:

; 675  :         return( ERROR );

	mov	rax, -1
	jmp	$LN171@data_item
	npad	3
$LN229@data_item:

; 1120 : }

	DD	$LN62@data_item
	DD	$LN59@data_item
	DD	$LN59@data_item
	DD	$LN67@data_item
	DD	$LN56@data_item
	DD	$LN56@data_item
	DD	$LN63@data_item
	DD	$LN58@data_item
	DD	$LN61@data_item
	DD	$LN56@data_item
	DD	$LN56@data_item
	DD	$LN79@data_item
	DD	$LN56@data_item
	DD	$LN65@data_item
	DD	$LN81@data_item
data_item ENDP
; Function compile flags: /Ogtpy
sym$ = 8
mem_type$ = 16
type_sym$ = 24
checktypes PROC NEAR

; 1125 :     /* for EXTERNDEF, check type changes */
; 1126 :     if ( sym->mem_type != MT_EMPTY ) {

	mov	r9d, DWORD PTR [rcx+44]
	cmp	r9d, 192				; 000000c0H
	je	SHORT $LN1@checktypes

; 1127 :         enum memtype mem_type2 = sym->mem_type;
; 1128 :         const struct asym *tmp;
; 1129 :         /* skip alias types */
; 1130 :         tmp = type_sym;
; 1131 :         while ( mem_type == MT_TYPE ) {

	cmp	edx, 196				; 000000c4H
	jne	SHORT $LN4@checktypes
	npad	11
$LL5@checktypes:

; 1132 :             mem_type = tmp->mem_type;

	mov	edx, DWORD PTR [r8+44]

; 1133 :             tmp = tmp->type;

	mov	r8, QWORD PTR [r8+88]
	cmp	edx, 196				; 000000c4H
	je	SHORT $LL5@checktypes
$LN4@checktypes:

; 1134 :         }
; 1135 :         tmp = sym;
; 1136 :         while ( mem_type2 == MT_TYPE ) {

	cmp	r9d, 196				; 000000c4H
	mov	rax, rcx
	jne	SHORT $LN2@checktypes
	npad	4
$LL3@checktypes:

; 1137 :             mem_type2 = tmp->mem_type;

	mov	r9d, DWORD PTR [rax+44]

; 1138 :             tmp = tmp->type;

	mov	rax, QWORD PTR [rax+88]
	cmp	r9d, 196				; 000000c4H
	je	SHORT $LL3@checktypes
$LN2@checktypes:

; 1139 :         }
; 1140 :         if ( mem_type2 != mem_type ) {

	cmp	r9d, edx
	je	SHORT $LN1@checktypes

; 1141 :             DebugMsg(("checktypes: memtype conflict: %u - %u\n", mem_type2, mem_type ));
; 1142 :             return( EmitErr( SYMBOL_TYPE_CONFLICT, sym->name ) );

	mov	rdx, QWORD PTR [rcx+8]
	mov	ecx, 136				; 00000088H

; 1146 : }

	jmp	EmitErr
$LN1@checktypes:

; 1143 :         }
; 1144 :     }
; 1145 :     return( NOT_ERROR );

	xor	eax, eax

; 1146 : }

	ret	0
checktypes ENDP
_TEXT	ENDS
PUBLIC	data_dir
EXTRN	LstWrite:NEAR
EXTRN	UpdateStructSize:NEAR
EXTRN	BackPatch:NEAR
EXTRN	SetSymSegOfs:NEAR
EXTRN	sym_remove_table:NEAR
EXTRN	SymTables:BYTE
EXTRN	sym_ext2int:NEAR
EXTRN	SymLookup:NEAR
EXTRN	omf_OutSelect:NEAR
EXTRN	StoreLine:NEAR
EXTRN	StoreState:BYTE
EXTRN	CreateStructField:NEAR
EXTRN	CurrStruct:QWORD
EXTRN	SpecialTable:BYTE
EXTRN	ExpandLiterals:NEAR
EXTRN	UseSavedState:BYTE
xdata	SEGMENT
$unwind$data_dir DD 0c2a01H
	DD	0de42aH
	DD	0ed41aH
	DD	0fc416H
	DD	0107412H
	DD	017340eH
	DD	013010aH
xdata	ENDS
pdata	SEGMENT
$pdata$data_dir DD @imagerel($LN80#)
	DD	@imagerel($LN80#+147)
	DD	@imagerel($unwind$data_dir#)
pdata	ENDS
xdata	SEGMENT
$chain$5$data_dir DD 020821H
	DD	0125408H
	DD	@imagerel($LN80#)
	DD	@imagerel($LN80#+147)
	DD	@imagerel($unwind$data_dir#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$data_dir DD @imagerel($LN80#+147)
	DD	@imagerel($LN80#+430)
	DD	@imagerel($chain$5$data_dir#)
pdata	ENDS
xdata	SEGMENT
$chain$7$data_dir DD 042021H
	DD	0cf420H
	DD	0116408H
	DD	@imagerel($LN80#+147)
	DD	@imagerel($LN80#+430)
	DD	@imagerel($chain$5$data_dir#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$data_dir DD @imagerel($LN80#+430)
	DD	@imagerel($LN80#+528)
	DD	@imagerel($chain$7$data_dir#)
pdata	ENDS
xdata	SEGMENT
$chain$8$data_dir DD 021H
	DD	@imagerel($LN80#+147)
	DD	@imagerel($LN80#+430)
	DD	@imagerel($chain$5$data_dir#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$data_dir DD @imagerel($LN80#+528)
	DD	@imagerel($LN80#+536)
	DD	@imagerel($chain$8$data_dir#)
pdata	ENDS
xdata	SEGMENT
$chain$9$data_dir DD 021H
	DD	@imagerel($LN80#)
	DD	@imagerel($LN80#+147)
	DD	@imagerel($unwind$data_dir#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$data_dir DD @imagerel($LN80#+536)
	DD	@imagerel($LN80#+575)
	DD	@imagerel($chain$9$data_dir#)
pdata	ENDS
xdata	SEGMENT
$chain$10$data_dir DD 060021H
	DD	0cf400H
	DD	0116400H
	DD	0125400H
	DD	@imagerel($LN80#)
	DD	@imagerel($LN80#+147)
	DD	@imagerel($unwind$data_dir#)
xdata	ENDS
pdata	SEGMENT
$pdata$10$data_dir DD @imagerel($LN80#+575)
	DD	@imagerel($LN80#+1570)
	DD	@imagerel($chain$10$data_dir#)
pdata	ENDS
xdata	SEGMENT
$chain$11$data_dir DD 020021H
	DD	0125400H
	DD	@imagerel($LN80#)
	DD	@imagerel($LN80#+147)
	DD	@imagerel($unwind$data_dir#)
xdata	ENDS
pdata	SEGMENT
$pdata$11$data_dir DD @imagerel($LN80#+1570)
	DD	@imagerel($LN80#+1590)
	DD	@imagerel($chain$11$data_dir#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
tv711 = 80
no_of_bytes$1$ = 84
symtype$1$ = 88
old_offset$ = 160
currofs$ = 160
i$ = 160
tokenarray$ = 168
foundSubType$1$ = 176
fPrev$ = 176
f2$ = 176
type_sym$ = 176
data_dir PROC NEAR

; 1160 : {

$LN80:
	mov	rax, rsp
	sub	rsp, 152				; 00000098H
	mov	QWORD PTR [rax+32], rbx
	mov	QWORD PTR [rax-24], rdi
	mov	QWORD PTR [rax-32], r12
	mov	QWORD PTR [rax-40], r13
	mov	rbx, r8

; 1161 :     uint_32             no_of_bytes;
; 1162 :     struct asym         *sym = NULL;

	xor	r10d, r10d

; 1163 :     uint_32             old_offset;
; 1164 :     uint_32             currofs; /* for LST output */
; 1165 :     enum memtype        mem_type;
; 1166 :     bool                is_float = FALSE;

	xor	r8b, r8b
	movsxd	r13, ecx
	mov	QWORD PTR [rax-48], r14

; 1167 :     int                 idx;
; 1168 :     char                *name;
; 1169 : 
; 1170 : 	struct dsym *symtype = ((struct dsym *)type_sym);
; 1171 : 	struct sfield   *f;
; 1172 : 	struct sfield   *f2;
; 1173 : 	struct sfield   *fPrev;
; 1174 : 	struct sfield   *fnext;
; 1175 : 	struct sfield   *f2next;
; 1176 : 	bool foundSubType = FALSE;

	xor	r14b, r14b

; 1177 : 	uint_32 subid = 0;
; 1178 : 	uint_32 subcnt = 0;
; 1179 : 	uint_32 k = 0;
; 1180 : 
; 1181 :     DebugMsg1(("data_dir( i=%u, type=%s ) enter\n", i, type_sym ? type_sym->name : "NULL" ));
; 1182 : 
; 1183 :     /* v2.05: the previous test in parser.c wasn't fool-proved */
; 1184 :     if ( i > 1 && ModuleInfo.m510 == FALSE ) {

	cmp	r13d, 1
	mov	r12, rdx
	mov	rdi, r10
	mov	DWORD PTR tv711[rsp], r8d
	mov	QWORD PTR symtype$1$[rsp], rbx
	jle	SHORT $LN61@data_dir
	test	BYTE PTR ModuleInfo+408, 128		; 00000080H
	jne	SHORT $LN61@data_dir

; 1185 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, r13
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r12+8]
	call	EmitErr
	jmp	$LN62@data_dir
$LN61@data_dir:

; 1186 :     }
; 1187 :     if( tokenarray[i+1].token == T_FINAL ) {

	lea	rax, QWORD PTR [r13+1]
	mov	rdx, r13
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], dil
	jne	SHORT $LN60@data_dir

; 1188 :         DebugMsg(("data_dir: missing initializer\n"));
; 1189 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	shl	rdx, 5
	mov	ecx, 209				; 000000d1H
	mov	rdx, QWORD PTR [rdx+r12+24]
	call	EmitErr
	jmp	$LN62@data_dir
$LN60@data_dir:

; 1190 :     }
; 1191 : 
; 1192 :     /* set values for mem_type and no_of_bytes */
; 1193 :     if ( type_sym ) {

	test	rbx, rbx
	mov	QWORD PTR [rsp+144], rbp
	mov	r11d, 1
	je	SHORT $LN59@data_dir

; 1194 :         /* if the parser found a TYPE id, type_sym is != NULL */
; 1195 :         //DebugMsg1(("data_dir: arbitrary type %s, calling SymSearch\n", type_sym->name ));
; 1196 :         //type_sym = SymSearch( tokenarray[i].string_ptr );
; 1197 :         mem_type = MT_TYPE;
; 1198 :         if ( type_sym->typekind != TYPE_TYPEDEF &&
; 1199 :              ( type_sym->total_size == 0 || ((struct dsym *)type_sym)->e.structinfo->OrgInside == TRUE ) ) {

	cmp	BYTE PTR [rbx+74], 3
	mov	ebp, 196				; 000000c4H
	je	SHORT $LN58@data_dir
	cmp	DWORD PTR [rbx+64], edi
	je	SHORT $LN57@data_dir
	mov	rax, QWORD PTR [rbx+104]
	test	BYTE PTR [rax+29], 4
	je	SHORT $LN58@data_dir
$LN57@data_dir:

; 1200 :             return( EmitError( STRUCT_CANNOT_BE_INSTANCED ) );

	mov	ecx, 215				; 000000d7H
	call	EmitError
	jmp	$LN76@data_dir
$LN58@data_dir:

; 1201 :         }
; 1202 : 
; 1203 :         /* v2.09: expand literals inside <> or {}.
; 1204 :          * Previously this was done inside InitStructuredVar()
; 1205 :          */
; 1206 : #if FASTPASS
; 1207 :         if ( Parse_Pass == PASS_1 || UseSavedState == FALSE )

	mov	eax, DWORD PTR Parse_Pass
	test	eax, eax
	je	SHORT $LN55@data_dir
	cmp	BYTE PTR UseSavedState, dil
	jne	SHORT $LN56@data_dir
$LN55@data_dir:

; 1208 : #endif
; 1209 :             ExpandLiterals( i+1, tokenarray );

	lea	ecx, DWORD PTR [r13+1]
	mov	rdx, r12
	call	ExpandLiterals
	mov	eax, DWORD PTR Parse_Pass
	xor	r10d, r10d
$LN56@data_dir:

; 1210 : 
; 1211 :         no_of_bytes = type_sym->total_size;

	mov	ecx, DWORD PTR [rbx+64]

; 1212 :         if ( no_of_bytes == 0 ) {

	test	ecx, ecx
	mov	DWORD PTR no_of_bytes$1$[rsp], ecx
	jne	$LN46@data_dir

; 1213 :             DebugMsg(("data_dir: size of arbitrary type is 0!\n"));
; 1214 :             /* a void type is not valid */
; 1215 :             if ( type_sym->typekind == TYPE_TYPEDEF ) {

	cmp	BYTE PTR [rbx+74], 3
	jne	$LN46@data_dir

; 1216 :                 return( EmitErr( INVALID_TYPE_FOR_DATA_DECLARATION, type_sym->name ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 160				; 000000a0H
	call	EmitErr
	jmp	$LN76@data_dir
$LN59@data_dir:

; 1217 :             }
; 1218 :         }
; 1219 :     } else {
; 1220 :         /* it's either a predefined type or a data directive. For types, the index
; 1221 :          into the simpletype table is in <bytval>, for data directives
; 1222 :          the index is found in <sflags>.
; 1223 :          * v2.06: SimpleType is obsolete. Use token index directly!
; 1224 :          */
; 1225 : 
; 1226 :         if ( tokenarray[i].token == T_STYPE ) {

	shl	rdx, 5
	lea	r9, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rdx+r12]
	cmp	al, 6
	jne	SHORT $LN51@data_dir

; 1227 :             //idx = tokenarray[i].bytval;
; 1228 :             idx = tokenarray[i].tokval;

	mov	eax, DWORD PTR [rdx+r12+16]

; 1229 :         } else if ( tokenarray[i].token == T_DIRECTIVE &&

	jmp	SHORT $LN48@data_dir
$LN51@data_dir:

; 1230 :                    ( tokenarray[i].dirtype == DRT_DATADIR )) {

	cmp	al, 3
	jne	$LN49@data_dir
	cmp	BYTE PTR [rdx+r12+1], 8
	jne	$LN49@data_dir

; 1231 :             idx = GetSflagsSp( tokenarray[i].tokval );

	mov	eax, DWORD PTR [rdx+r12+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	eax, DWORD PTR [r9+rcx*4+4]
$LN48@data_dir:

; 1234 :         }
; 1235 :         mem_type = GetMemtypeSp( idx );

	cdqe
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	ebp, BYTE PTR [r9+rcx*4+10]

; 1236 :         /* types NEAR[16|32], FAR[16|32] and PROC are invalid here */
; 1237 :         //if ( ( SimpleType[idx].mem_type & MT_SPECIAL_MASK ) == MT_ADDRESS ) {
; 1238 :         if ( ( mem_type & MT_SPECIAL_MASK ) == MT_ADDRESS ) {

	mov	eax, ebp
	and	eax, 192				; 000000c0H
	cmp	al, -128				; ffffffffffffff80H
	jne	SHORT $LN47@data_dir

; 1239 :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+r12+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN76@data_dir
$LN47@data_dir:

; 1240 :         }
; 1241 :         no_of_bytes = (mem_type & MT_SIZE_MASK) + 1;
; 1242 :         if ( mem_type & MT_FLOAT )

	mov	eax, DWORD PTR Parse_Pass
	mov	ecx, ebp
	movzx	r8d, r8b
	and	ecx, 31
	inc	ecx
	test	bpl, 32					; 00000020H
	cmovne	r8d, r11d
	mov	DWORD PTR no_of_bytes$1$[rsp], ecx
	mov	DWORD PTR tv711[rsp], r8d
$LN46@data_dir:

; 1243 :             is_float = TRUE;
; 1244 :     }
; 1245 : 
; 1246 :     /* if i == 1, there's a (data) label at pos 0.
; 1247 :      * (note: if -Zm is set, a code label may be at pos 0, and
; 1248 :      * i is 2 then.)
; 1249 :      */
; 1250 :     name = ( ( i == 1 ) ? tokenarray[0].string_ptr : NULL );

	cmp	r13d, 1
	mov	QWORD PTR [rsp+136], rsi
	jne	SHORT $LN64@data_dir
	mov	rsi, QWORD PTR [r12+8]
	jmp	SHORT $LN65@data_dir
$LN64@data_dir:
	mov	rsi, r10
$LN65@data_dir:

; 1251 : 
; 1252 :     /* in a struct declaration? */
; 1253 :     if( CurrStruct ) {

	cmp	QWORD PTR CurrStruct, rdi
	mov	QWORD PTR [rsp+96], r15
	je	$LN45@data_dir

; 1254 : 
; 1255 :         /* structure parsing is done in the first pass only */
; 1256 :         if( Parse_Pass == PASS_1 ) {

	test	eax, eax
	jne	$LN44@data_dir

; 1257 : 
; 1258 :             /* current offset isn't necessarily the fields start offset */
; 1259 :             //currofs = CurrStruct->sym.offset;
; 1260 : 
; 1261 :             if (!(sym = CreateStructField( i, tokenarray, name, mem_type, type_sym, no_of_bytes ))) {

	mov	DWORD PTR [rsp+40], ecx
	mov	r9d, ebp
	mov	r8, rsi
	mov	ecx, r13d
	mov	rdx, r12
	mov	QWORD PTR [rsp+32], rbx
	call	CreateStructField
	test	rax, rax
	mov	rdi, rax
	jne	SHORT $LN43@data_dir
$LN79@data_dir:

; 1262 :                 return ( ERROR );

	mov	eax, -1
$LN78@data_dir:
	mov	r15, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+136]
$LN76@data_dir:
	mov	rbp, QWORD PTR [rsp+144]
$LN62@data_dir:
	mov	r14, QWORD PTR [rsp+104]
	mov	r13, QWORD PTR [rsp+112]
	mov	r12, QWORD PTR [rsp+120]
	mov	rdi, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [rsp+184]

; 1456 : }

	add	rsp, 152				; 00000098H
	ret	0
$LN43@data_dir:

; 1263 :             }
; 1264 : #if FASTPASS
; 1265 :             if ( StoreState ) FStoreLine(0);

	cmp	BYTE PTR StoreState, 0
	je	SHORT $LN41@data_dir
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN41@data_dir
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	xor	edx, edx
	call	StoreLine
$LN41@data_dir:

; 1266 : #endif
; 1267 :             currofs = sym->offset;

	mov	r15d, DWORD PTR [rdi+16]

; 1268 :             sym->isdata = TRUE; /* 'first_size' is valid */

	or	BYTE PTR [rdi+49], 4

; 1269 :             DebugMsg1(("data_dir: %s, CreateStructField called, ofs=%d\n", sym->name, sym->offset ));
; 1270 :         } else { /* v2.04: else branch added */

	jmp	$LN15@data_dir
$LN44@data_dir:

; 1271 :             sym = &CurrStruct->e.structinfo->tail->sym;

	mov	rax, QWORD PTR CurrStruct
	mov	rcx, QWORD PTR [rax+104]
	mov	rdi, QWORD PTR [rcx+8]

; 1272 :             currofs = sym->offset;
; 1273 :             CurrStruct->e.structinfo->tail = CurrStruct->e.structinfo->tail->next;

	mov	rax, QWORD PTR [rdi+104]
	mov	r15d, DWORD PTR [rdi+16]
	mov	QWORD PTR [rcx+8], rax

; 1274 :         }
; 1275 : 
; 1276 :     } else {

	jmp	$LN15@data_dir
$LN45@data_dir:

; 1277 : 
; 1278 :         if( CurrSeg == NULL ) {

	cmp	QWORD PTR ModuleInfo+432, rdi
	jne	SHORT $LN37@data_dir

; 1279 :             return( EmitError( MUST_BE_IN_SEGMENT_BLOCK ) );

	mov	ecx, 82					; 00000052H
	call	EmitError
	jmp	$LN78@data_dir
$LN37@data_dir:

; 1280 :         }
; 1281 : 
; 1282 :         FStoreLine(0);

	test	eax, eax
	jne	SHORT $LN36@data_dir
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	xor	edx, edx
	call	StoreLine
$LN36@data_dir:

; 1283 : 
; 1284 :         if ( ModuleInfo.CommentDataInCode )

	cmp	BYTE PTR ModuleInfo+423, dil
	je	SHORT $LN34@data_dir

; 1285 :             omf_OutSelect( TRUE );

	mov	cl, 1
	call	omf_OutSelect
$LN34@data_dir:

; 1286 : 
; 1287 :         if ( ModuleInfo.list ) {

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN73@data_dir

; 1288 :             currofs = GetCurrOffset();

	call	GetCurrOffset
	mov	r15d, eax
	jmp	SHORT $LN33@data_dir
$LN73@data_dir:
	mov	r15d, DWORD PTR currofs$[rsp]
$LN33@data_dir:

; 1289 :         }
; 1290 : 
; 1291 :         /* is a label accociated with the data definition? */
; 1292 :         if( name ) {

	test	rsi, rsi
	je	$LN32@data_dir

; 1293 :             /* get/create the label. */
; 1294 :             DebugMsg1(("data_dir: calling SymLookup(%s)\n", name ));
; 1295 :             sym = SymLookup( name );

	mov	rcx, rsi
	call	SymLookup

; 1296 :             /* v2.11: cannot fail */
; 1297 :             //if( sym == NULL ) {
; 1298 :             //    DebugMsg(("data_dir exit, error: invalid label name\n"));
; 1299 :             //    return( ERROR );
; 1300 :             //}
; 1301 : 
; 1302 :             if( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	rdi, rax
	jne	$LN31@data_dir

; 1303 : 
; 1304 :                 if ( sym->state == SYM_EXTERNAL && sym->weak == TRUE && sym->isproc == FALSE ) { /* EXTERNDEF? */

	mov	eax, DWORD PTR [rax+40]
	cmp	eax, 2
	jne	SHORT $LN30@data_dir
	test	BYTE PTR [rdi+55], 8
	je	SHORT $LN30@data_dir
	test	BYTE PTR [rdi+49], 8
	jne	SHORT $LN30@data_dir

; 1305 : 
; 1306 :                     //if ( checktypes( sym, mem_type, type_sym ) == ERROR )
; 1307 :                     //    return( ERROR );
; 1308 :                     /* v2.0: display error and continue! */
; 1309 :                     checktypes( sym, mem_type, type_sym );

	mov	r8, rbx
	mov	edx, ebp
	mov	rcx, rdi
	call	checktypes

; 1310 :                     /* remove the external info */
; 1311 :                     sym_ext2int( sym );

	mov	rcx, rdi
	call	sym_ext2int

; 1312 :                     sym->total_size = 0;

	xor	eax, eax
	mov	DWORD PTR [rdi+64], eax

; 1313 :                     sym->total_length = 0;

	mov	DWORD PTR [rdi+72], eax

; 1314 :                     sym->first_length = 0;

	mov	DWORD PTR [rdi+56], eax
	jmp	SHORT $LN27@data_dir
$LN30@data_dir:

; 1315 : 
; 1316 :                 } else if( sym->state == SYM_UNDEFINED ) {

	test	eax, eax
	jne	SHORT $LN28@data_dir

; 1317 : 
; 1318 :                     sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rdi
	call	sym_remove_table

; 1319 :                     sym->state = SYM_INTERNAL;
; 1320 : #if 1
; 1321 :                     /* v2.11: Set the symbol's langtype. It may have been set
; 1322 :                      * by a PUBLIC directive, so take care not to overwrite it.
; 1323 :                      * Problem: Masm doesn't do this - might be a bug.
; 1324 :                      */
; 1325 :                     if ( sym->langtype == LANG_NONE )

	cmp	DWORD PTR [rdi+84], 0
	mov	eax, 1
	mov	DWORD PTR [rdi+40], eax
	jne	SHORT $LN27@data_dir

; 1326 :                         sym->langtype = ModuleInfo.langtype;

	mov	eax, DWORD PTR ModuleInfo+364
	mov	DWORD PTR [rdi+84], eax
$LN27@data_dir:

; 1348 :                 }
; 1349 :                 /* add the label to the linked list attached to curr segment */
; 1350 :                 /* this allows to reduce the number of passes (see Fixup.c) */
; 1351 :                 ((struct dsym *)sym)->next = (struct dsym *)CurrSeg->e.seginfo->label_list;

	mov	rax, QWORD PTR ModuleInfo+432

; 1352 :                 CurrSeg->e.seginfo->label_list = sym;
; 1353 : 
; 1354 :             } else {

	mov	esi, DWORD PTR old_offset$[rsp]
	mov	rcx, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rcx+32]
	mov	QWORD PTR [rdi+112], rax
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	mov	QWORD PTR [rcx+32], rdi
	jmp	SHORT $label_defined$6309
$LN28@data_dir:

; 1327 : #endif
; 1328 :                 } else if ( sym->state == SYM_INTERNAL) {

	cmp	eax, 1
	jne	SHORT $LN25@data_dir

; 1329 : 
; 1330 :                     /* accept a symbol "redefinition" if addresses and types
; 1331 :                      * do match.
; 1332 :                      */
; 1333 :                     if ( sym->segment != (struct asym *)CurrSeg ||
; 1334 :                         sym->offset != GetCurrOffset() ) {

	mov	rax, QWORD PTR ModuleInfo+432
	cmp	QWORD PTR [rdi+32], rax
	jne	SHORT $LN23@data_dir
	call	GetCurrOffset
	cmp	DWORD PTR [rdi+16], eax
	jne	SHORT $LN23@data_dir

; 1336 :                     }
; 1337 :                     /* check for symbol type conflict */
; 1338 :                     if ( checktypes( sym, mem_type, type_sym ) == ERROR )

	mov	r8, rbx
	mov	edx, ebp
	mov	rcx, rdi
	call	checktypes
	cmp	eax, -1

; 1339 :                         return( ERROR );

	je	$LN79@data_dir

; 1340 :                     /* v2.09: reset size and length ( might have been set by LABEL directive ) */
; 1341 :                     sym->total_size = 0;
; 1342 :                     sym->total_length = 0;
; 1343 :                     goto label_defined; /* don't relink the label */

	mov	esi, DWORD PTR old_offset$[rsp]
	xor	eax, eax
	mov	DWORD PTR [rdi+64], eax
	mov	DWORD PTR [rdi+72], eax
	jmp	SHORT $label_defined$6309
$LN23@data_dir:

; 1335 :                         return( EmitErr( SYMBOL_ALREADY_DEFINED, name ) );

	mov	rdx, rsi
	mov	ecx, 56					; 00000038H
	call	EmitErr
	jmp	$LN78@data_dir
$LN25@data_dir:

; 1344 : 
; 1345 :                 } else {
; 1346 :                     DebugMsg(("data_dir(%s): error, symbol redefinition, state=%X\n", sym->name, sym->state ));
; 1347 :                     return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rdi+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN78@data_dir
$LN31@data_dir:

; 1355 :                 old_offset = sym->offset;

	mov	esi, DWORD PTR [rax+16]
$label_defined$6309:

; 1356 :             }
; 1357 :         label_defined:
; 1358 :             SetSymSegOfs( sym );

	mov	rcx, rdi
	call	SetSymSegOfs

; 1359 :             if( Parse_Pass != PASS_1 && sym->offset != old_offset ) {

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN19@data_dir
	movzx	eax, BYTE PTR ModuleInfo+422
	cmp	DWORD PTR [rdi+16], esi
	mov	ecx, 1
	cmovne	eax, ecx
	mov	BYTE PTR ModuleInfo+422, al
$LN19@data_dir:

; 1360 : #ifdef DEBUG_OUT
; 1361 :                 if ( !ModuleInfo.PhaseError )
; 1362 :                     DebugMsg(("data_dir: Phase error, pass %u, sym >%s< first time, new=%X != old=%X\n", Parse_Pass+1, sym->name, sym->offset, old_offset));
; 1363 : #endif
; 1364 :                 ModuleInfo.PhaseError = TRUE;
; 1365 :             }
; 1366 :             sym->isdefined = TRUE;

	or	BYTE PTR [rdi+48], 2

; 1367 :             sym->isdata = TRUE; /* 'first_size' is valid */

	or	BYTE PTR [rdi+49], 4

; 1368 :             sym->mem_type = mem_type;
; 1369 :             sym->type = type_sym;
; 1370 : 
; 1371 :             /* backpatch for data items? Yes, if the item is defined
; 1372 :              * in a code segment then its offset may change!
; 1373 :              */
; 1374 :             BackPatch( sym );

	mov	rcx, rdi
	mov	DWORD PTR [rdi+44], ebp
	mov	QWORD PTR [rdi+88], rbx
	call	BackPatch
$LN32@data_dir:

; 1375 :         }
; 1376 : 
; 1377 :         if ( type_sym ) {

	test	rbx, rbx
	je	SHORT $LN15@data_dir

; 1378 :             while ( type_sym->mem_type == MT_TYPE )

	cmp	DWORD PTR [rbx+44], 196			; 000000c4H
	jne	SHORT $LN16@data_dir
	npad	3
$LL17@data_dir:

; 1379 :                 type_sym = type_sym->type;

	mov	rbx, QWORD PTR [rbx+88]
	cmp	DWORD PTR [rbx+44], 196			; 000000c4H
	je	SHORT $LL17@data_dir
$LN16@data_dir:

; 1380 :             /* if it is just a type alias, skip the arbitrary type */
; 1381 :             if ( type_sym->typekind == TYPE_TYPEDEF )

	cmp	BYTE PTR [rbx+74], 3
	mov	eax, 0
	cmove	rbx, rax
$LN15@data_dir:

; 1382 :                 type_sym = NULL;
; 1383 :         }
; 1384 : 
; 1385 :     }
; 1386 : 
; 1387 :     i++;

	inc	r13d

; 1388 : 
; 1389 : 	/* Enhanced HJWASM 2.22+ Union initialize */
; 1390 : 	if (tokenarray[i].token == T_DOT && type_sym->state == SYM_TYPE)

	movsxd	rax, r13d
	mov	DWORD PTR i$[rsp], r13d
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], 46			; 0000002eH
	jne	$LN74@data_dir
	cmp	DWORD PTR [rbx+40], 7
	jne	$LN74@data_dir

; 1391 : 	{
; 1392 : 		i++; // skip dot.
; 1393 : 		// Check sub type.
; 1394 : 		symtype = ((struct dsym *)type_sym);
; 1395 : 		foundSubType = FALSE;
; 1396 : 		subid = 0;
; 1397 : 		subcnt = 0;
; 1398 : 		k = 0;
; 1399 : 		for (f = symtype->e.structinfo->head; f != NULL; f = f->next) 

	mov	rbp, QWORD PTR [rbx+104]
	xor	r14b, r14b
	inc	r13d
	mov	r11, QWORD PTR [rbp]
	mov	QWORD PTR symtype$1$[rsp], rbx
	mov	BYTE PTR foundSubType$1$[rsp], r14b
	test	r11, r11
	mov	r8, r11
	je	SHORT $LN70@data_dir
	mov	r10, QWORD PTR f2$[rsp]
	mov	rsi, QWORD PTR fPrev$[rsp]
	movsxd	rax, r13d
	shl	rax, 5
	mov	r14, QWORD PTR [rax+r12+8]
$LL13@data_dir:

; 1400 : 		{
; 1401 : 			if (strcmp(tokenarray[i].string_ptr, f->sym.name) == 0)

	mov	r9, QWORD PTR [r8+8]
	mov	rax, r14
	sub	r9, r14
	npad	6
$LL71@data_dir:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r9]
	sub	edx, ecx
	jne	SHORT $LN72@data_dir
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL71@data_dir
$LN72@data_dir:
	test	edx, edx
	jne	SHORT $LN75@data_dir

; 1402 : 			{
; 1403 : 				f2 = f;
; 1404 : 				foundSubType = TRUE;

	mov	cl, 1
	mov	r10, r8

; 1405 : 				subid = subcnt;
; 1406 : 				fPrev = symtype->e.structinfo->head;

	mov	rsi, r11
	mov	BYTE PTR foundSubType$1$[rsp], cl
	jmp	SHORT $LN10@data_dir
$LN75@data_dir:

; 1402 : 			{
; 1403 : 				f2 = f;
; 1404 : 				foundSubType = TRUE;

	movzx	ecx, BYTE PTR foundSubType$1$[rsp]
$LN10@data_dir:

; 1391 : 	{
; 1392 : 		i++; // skip dot.
; 1393 : 		// Check sub type.
; 1394 : 		symtype = ((struct dsym *)type_sym);
; 1395 : 		foundSubType = FALSE;
; 1396 : 		subid = 0;
; 1397 : 		subcnt = 0;
; 1398 : 		k = 0;
; 1399 : 		for (f = symtype->e.structinfo->head; f != NULL; f = f->next) 

	mov	r8, QWORD PTR [r8+104]
	test	r8, r8
	jne	SHORT $LL13@data_dir

; 1407 : 			}
; 1408 : 			subcnt++;
; 1409 : 		}
; 1410 : 		if (!foundSubType)

	test	cl, cl
	jne	SHORT $LN9@data_dir
$LN70@data_dir:

; 1411 : 		{
; 1412 : 			EmitErr(INVALID_DATA_INITIALIZER, sym->name);

	mov	rdx, QWORD PTR [rdi+8]
	mov	ecx, 231				; 000000e7H
	call	EmitErr

; 1413 : 			return;

	jmp	$LN78@data_dir
$LN9@data_dir:

; 1414 : 		}
; 1415 : 		else
; 1416 : 		{
; 1417 : 			// sort the union subtypes so the one we want is first (in accordance with what is allowed for initialisation)
; 1418 : 			if (f2 == symtype->e.structinfo->head)

	cmp	r10, r11
	je	SHORT $LN6@data_dir

; 1419 : 			{
; 1420 : 				// Do nothing as the required sub type is the first one.
; 1421 : 			}
; 1422 : 			else
; 1423 : 			{
; 1424 : 				symtype->e.structinfo->head = f2;

	mov	QWORD PTR [rbp], r10
$LN6@data_dir:

; 1425 : 			}
; 1426 : 			
; 1427 : 		}
; 1428 : 		i++; /* skip subtype identifier */

	mov	r14b, BYTE PTR foundSubType$1$[rsp]
	inc	r13d
	mov	DWORD PTR i$[rsp], r13d
	jmp	SHORT $LN14@data_dir
$LN74@data_dir:
	mov	rsi, QWORD PTR fPrev$[rsp]
$LN14@data_dir:

; 1429 : 	}
; 1430 : 
; 1431 :     if ( data_item( &i, tokenarray, sym, no_of_bytes, type_sym, 1, CurrStruct != NULL, is_float, TRUE, Token_Count ) == ERROR ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	QWORD PTR CurrStruct, 0
	mov	r9d, DWORD PTR no_of_bytes$1$[rsp]
	mov	DWORD PTR [rsp+72], eax
	mov	eax, DWORD PTR tv711[rsp]
	mov	BYTE PTR [rsp+64], 1
	mov	BYTE PTR [rsp+56], al
	setne	cl
	mov	eax, 1
	mov	BYTE PTR [rsp+48], cl
	mov	DWORD PTR [rsp+40], eax
	lea	rcx, QWORD PTR i$[rsp]
	mov	r8, rdi
	mov	rdx, r12
	mov	QWORD PTR [rsp+32], rbx
	call	data_item
	cmp	eax, -1

; 1432 :         DebugMsg(("data_dir: error in data_item()\n"));
; 1433 :         return( ERROR );

	je	$LN79@data_dir

; 1434 :     }
; 1435 : 
; 1436 : 	if (foundSubType)

	test	r14b, r14b
	je	SHORT $LN4@data_dir

; 1437 : 		symtype->e.structinfo->head = fPrev;

	mov	rax, QWORD PTR symtype$1$[rsp]
	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR [rax], rsi
$LN4@data_dir:

; 1438 : 
; 1439 :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, DWORD PTR i$[rsp]
	shl	rdx, 5
	cmp	BYTE PTR [rdx+r12], 0
	je	SHORT $LN3@data_dir

; 1440 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+r12+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN78@data_dir
$LN3@data_dir:

; 1441 :     }
; 1442 : 
; 1443 :     /* v2.06: update struct size after ALL items have been processed */
; 1444 :     if ( CurrStruct )

	mov	rax, QWORD PTR CurrStruct
	test	rax, rax
	je	SHORT $LN2@data_dir

; 1445 :         UpdateStructSize( sym );

	mov	rcx, rdi
	call	UpdateStructSize
	mov	rax, QWORD PTR CurrStruct
$LN2@data_dir:

; 1446 : 
; 1447 :     if ( ModuleInfo.list )

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN1@data_dir

; 1448 :         LstWrite( CurrStruct ? LSTTYPE_STRUCT : LSTTYPE_DATA, currofs, sym );

	neg	rax
	mov	r8, rdi
	mov	edx, r15d
	sbb	ecx, ecx
	and	ecx, 6
	call	LstWrite
$LN1@data_dir:

; 1449 : 
; 1450 :     DebugMsg1(("data_dir: exit, no error, label=%s, is_array=%u Curr%s.ofs=%X\n",
; 1451 :                sym ? sym->name : "NULL",
; 1452 :                sym ? sym->isarray : 0,
; 1453 :                CurrStruct ? "Struct" : "Seg",
; 1454 :                CurrStruct ? CurrStruct->sym.offset : CurrSeg->sym.offset ));
; 1455 :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN78@data_dir
$LN49@data_dir:

; 1232 :         } else {
; 1233 :             return( EmitErr( INVALID_TYPE_FOR_DATA_DECLARATION, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+r12+8]
	mov	ecx, 160				; 000000a0H
	call	EmitErr
	jmp	$LN76@data_dir
data_dir ENDP
_TEXT	ENDS
END
