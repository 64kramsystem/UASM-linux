; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG5813	DB	01H DUP (?)
$SG5688	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	MacroLocals:DWORD
COMM	MacroLevel:BYTE
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
__digits DB	'0123456789ABCDEF'
CONST	ENDS
_DATA	SEGMENT
$SG6079	DB	'LOCAL', 00H
_DATA	ENDS
PUBLIC	myltoa
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$myltoa DD 030c01H
	DD	0c340cH
	DD	0c204H
xdata	ENDS
pdata	SEGMENT
$pdata$myltoa DD @imagerel($LN13#)
	DD	@imagerel($LN13#+48)
	DD	@imagerel($unwind$myltoa#)
pdata	ENDS
xdata	SEGMENT
$chain$1$myltoa DD 020521H
	DD	0b7405H
	DD	@imagerel($LN13#)
	DD	@imagerel($LN13#+48)
	DD	@imagerel($unwind$myltoa#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$myltoa DD @imagerel($LN13#+48)
	DD	@imagerel($LN13#+95)
	DD	@imagerel($chain$1$myltoa#)
pdata	ENDS
xdata	SEGMENT
$chain$2$myltoa DD 021H
	DD	@imagerel($LN13#)
	DD	@imagerel($LN13#+48)
	DD	@imagerel($unwind$myltoa#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$myltoa DD @imagerel($LN13#+95)
	DD	@imagerel($LN13#+173)
	DD	@imagerel($chain$2$myltoa#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\expans.c
pdata	ENDS
_TEXT	SEGMENT
tmpbuf$ = 32
value$ = 112
buffer$ = 120
radix$ = 128
sign$ = 136
addzero$ = 144
myltoa	PROC NEAR

; 54   : {

$LN13:
	sub	rsp, 104				; 00000068H

; 55   :     char   *p;
; 56   :     char   *dst = buffer;
; 57   :     char   tmpbuf[34];
; 58   : 
; 59   : #ifdef DEBUG_OUT
; 60   :     uint_32 saved_value = value;
; 61   : #endif
; 62   :     if ( sign ) {

	test	r9b, r9b
	mov	QWORD PTR [rsp+96], rbx
	mov	r10d, ecx
	mov	rbx, rdx
	mov	r11, rdx
	je	SHORT $LN7@myltoa

; 63   :         *dst++ = '-';

	mov	BYTE PTR [rdx], 45			; 0000002dH
	lea	r11, QWORD PTR [rdx+1]

; 64   :          value = 0 - value;

	neg	r10d
$LN5@myltoa:

; 67   :         *dst = NULLC;
; 68   :         return( buffer );
; 69   :     }
; 70   :     for ( p = &tmpbuf[33], *p = NULLC; value; value = value / radix )

	test	r10d, r10d
	lea	r9, QWORD PTR tmpbuf$[rsp+33]
	mov	BYTE PTR tmpbuf$[rsp+33], 0
	je	SHORT $LN2@myltoa
	mov	QWORD PTR [rsp+88], rdi
	lea	rdi, OFFSET FLAT:__digits
	npad	4
$LL4@myltoa:

; 71   :         *(--p) = __digits[value % radix];

	xor	edx, edx
	mov	eax, r10d
	dec	r9
	div	r8d
	mov	r10d, eax
	test	r10d, r10d
	movzx	eax, BYTE PTR [rdx+rdi]
	mov	BYTE PTR [r9], al
	jne	SHORT $LL4@myltoa
	mov	rdi, QWORD PTR [rsp+88]
$LN2@myltoa:

; 72   :     if ( addzero && ( *p > '9') ) /* v2: add a leading '0' if first digit is alpha */

	cmp	BYTE PTR addzero$[rsp], 0
	je	SHORT $LN1@myltoa
	cmp	BYTE PTR [r9], 57			; 00000039H
	jle	SHORT $LN1@myltoa

; 73   :         *dst++ = '0';

	mov	BYTE PTR [r11], 48			; 00000030H
	inc	r11
$LN1@myltoa:

; 74   :     memcpy( dst, p, &tmpbuf[33] + 1 - p );

	lea	r8, QWORD PTR tmpbuf$[rsp+34]
	mov	rdx, r9
	mov	rcx, r11
	sub	r8, r9
	call	memcpy

; 75   :     DebugMsg1(("myltoa( value=%" I32_SPEC "Xh, out=%s, radix=%u, sign=%u, %u)\n", saved_value, buffer, radix, sign, addzero ));
; 76   :     return( buffer );

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+96]

; 77   : }

	add	rsp, 104				; 00000068H
	ret	0
$LN7@myltoa:

; 65   :     } else if ( value == 0 ) {

	test	ecx, ecx
	jne	SHORT $LN5@myltoa

; 66   :         *dst++ = '0';

	mov	BYTE PTR [rdx], 48			; 00000030H

; 75   :     DebugMsg1(("myltoa( value=%" I32_SPEC "Xh, out=%s, radix=%u, sign=%u, %u)\n", saved_value, buffer, radix, sign, addzero ));
; 76   :     return( buffer );

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+96]
	mov	BYTE PTR [rdx+1], cl

; 77   : }

	add	rsp, 104				; 00000068H
	ret	0
myltoa	ENDP
_TEXT	ENDS
PUBLIC	myqtoa
xdata	SEGMENT
$unwind$myqtoa DD 020601H
	DD	030029206H
xdata	ENDS
pdata	SEGMENT
$pdata$myqtoa DD @imagerel($LN13#)
	DD	@imagerel($LN13#+162)
	DD	@imagerel($unwind$myqtoa#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
tmpbuf$ = 32
value$ = 96
buffer$ = 104
radix$ = 112
sign$ = 120
addzero$ = 128
myqtoa	PROC NEAR

; 84   : {

$LN13:
	push	rbx
	sub	rsp, 80					; 00000050H

; 85   :   char   *p;
; 86   :   char   *dst = buffer;
; 87   :   char   tmpbuf[34];
; 88   : #ifdef DEBUG_OUT
; 89   :   uint_64 saved_value = value;
; 90   : #endif
; 91   :   if (sign) {

	test	r9b, r9b
	mov	rbx, rdx
	mov	r10, rdx
	je	SHORT $LN7@myqtoa

; 92   :     *dst++ = '-';

	mov	BYTE PTR [rdx], 45			; 0000002dH
	lea	r10, QWORD PTR [rdx+1]

; 93   :     value = 0 - value;

	neg	rcx
$LN5@myqtoa:

; 97   :     *dst = NULLC;
; 98   :     return(buffer);
; 99   :     }
; 100  :   for (p = &tmpbuf[33], *p = NULLC; value; value = value / radix)

	test	rcx, rcx
	lea	r9, QWORD PTR tmpbuf$[rsp+33]
	mov	BYTE PTR tmpbuf$[rsp+33], 0
	je	SHORT $LN2@myqtoa
	mov	r11d, r8d
	lea	r8, OFFSET FLAT:__digits
	npad	12
$LL4@myqtoa:

; 101  :     *(--p) = __digits[value % radix];

	xor	edx, edx
	mov	rax, rcx
	dec	r9
	div	r11
	mov	rcx, rax
	test	rcx, rcx
	movzx	eax, BYTE PTR [rdx+r8]
	mov	BYTE PTR [r9], al
	jne	SHORT $LL4@myqtoa
$LN2@myqtoa:

; 102  :   if (addzero && (*p > '9')) /* v2: add a leading '0' if first digit is alpha */

	cmp	BYTE PTR addzero$[rsp], 0
	je	SHORT $LN1@myqtoa
	cmp	BYTE PTR [r9], 57			; 00000039H
	jle	SHORT $LN1@myqtoa

; 103  :     *dst++ = '0';

	mov	BYTE PTR [r10], 48			; 00000030H
	inc	r10
$LN1@myqtoa:

; 104  :   memcpy(dst, p, &tmpbuf[33] + 1 - p);

	lea	r8, QWORD PTR tmpbuf$[rsp+34]
	mov	rdx, r9
	mov	rcx, r10
	sub	r8, r9
	call	memcpy

; 105  :   DebugMsg1(("myltoa( value=%" I32_SPEC "Xh, out=%s, radix=%u, sign=%u, %u)\n", saved_value, buffer, radix, sign, addzero));
; 106  :   return(buffer);

	mov	rax, rbx

; 107  : }

	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
$LN7@myqtoa:

; 94   :   }
; 95   :   else if (value == 0) {

	test	rcx, rcx
	jne	SHORT $LN5@myqtoa

; 96   :     *dst++ = '0';

	mov	BYTE PTR [rdx], 48			; 00000030H

; 105  :   DebugMsg1(("myltoa( value=%" I32_SPEC "Xh, out=%s, radix=%u, sign=%u, %u)\n", saved_value, buffer, radix, sign, addzero));
; 106  :   return(buffer);

	mov	rax, rbx
	mov	BYTE PTR [rdx+1], cl

; 107  : }

	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
myqtoa	ENDP
_TEXT	ENDS
EXTRN	Tokenize:NEAR
EXTRN	GetTextLine:NEAR
xdata	SEGMENT
$unwind$SkipMacro DD 030901H
	DD	0840109H
	DD	03002H
xdata	ENDS
pdata	SEGMENT
$pdata$SkipMacro DD @imagerel(SkipMacro#)
	DD	@imagerel(SkipMacro#+74)
	DD	@imagerel($unwind$SkipMacro#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buffer$ = 32
tokenarray$ = 1072
SkipMacro PROC NEAR

; 133  : {

	push	rbx
	sub	rsp, 1056				; 00000420H
	mov	rbx, rcx

; 134  :     char buffer[MAX_LINE_LEN];
; 135  : 
; 136  :     /* The queue isn't just thrown away, because any
; 137  :      * coditional assembly directives found in the source
; 138  :      * must be executed.
; 139  :      */
; 140  :      while ( GetTextLine( buffer ) ) {

	lea	rcx, QWORD PTR buffer$[rsp]
	call	GetTextLine
	test	rax, rax
	je	SHORT $LN1@SkipMacro
	npad	5
$LL2@SkipMacro:

; 141  :         Tokenize( buffer, 0, tokenarray, TOK_DEFAULT );

	lea	rcx, QWORD PTR buffer$[rsp]
	xor	r9d, r9d
	mov	r8, rbx
	xor	edx, edx
	call	Tokenize
	lea	rcx, QWORD PTR buffer$[rsp]
	call	GetTextLine
	test	rax, rax
	jne	SHORT $LL2@SkipMacro
$LN1@SkipMacro:

; 142  :     }
; 143  : 
; 144  : }

	add	rsp, 1056				; 00000420H
	pop	rbx
	ret	0
SkipMacro ENDP
; Function compile flags: /Ogtpy
tokenarray$ = 8
start$ = 16
count$ = 24
end$ = 32
AddTokens PROC NEAR

; 828  :     int i;
; 829  : 
; 830  :     if ( count > 0 ) {

	test	r8d, r8d
	movsxd	rax, r8d
	mov	r11, rcx
	jle	SHORT $LN16@AddTokens

; 831  :         for( i = end; i >= start; i-- ) {

	movsxd	r9, r9d
	movsxd	r8, edx
	cmp	r9, r8
	jl	$LN1@AddTokens
	mov	rdx, r9
	shl	rdx, 5
	add	rdx, rcx
	lea	rcx, QWORD PTR [r9+rax]
	sub	r9, r8
	shl	rcx, 5
	add	rcx, r11
	inc	r9
	npad	11
$LL8@AddTokens:

; 832  :             tokenarray[i+count] = tokenarray[i];

	mov	rax, QWORD PTR [rdx]
	sub	rcx, 32					; 00000020H
	sub	rdx, 32					; 00000020H
	dec	r9
	mov	QWORD PTR [rcx+32], rax
	mov	rax, QWORD PTR [rdx+40]
	mov	QWORD PTR [rcx+40], rax
	mov	rax, QWORD PTR [rdx+48]
	mov	QWORD PTR [rcx+48], rax
	mov	rax, QWORD PTR [rdx+56]
	mov	QWORD PTR [rcx+56], rax
	jne	SHORT $LL8@AddTokens

; 837  :         }
; 838  :     }
; 839  : }

	ret	0
$LN16@AddTokens:

; 833  :         }
; 834  :     } else if ( count < 0 ) {

	jns	SHORT $LN1@AddTokens

; 835  :         for( i = start - count; i <= end; ++i ) {

	sub	edx, eax
	movsxd	r8, r9d
	movsxd	r10, edx
	cmp	r10, r8
	jg	SHORT $LN1@AddTokens
	mov	rdx, r10
	sub	r8, r10
	shl	rdx, 5
	add	rdx, rcx
	lea	rcx, QWORD PTR [r10+rax]
	shl	rcx, 5
	add	rcx, r11
	inc	r8
	npad	9
$LL3@AddTokens:

; 836  :             tokenarray[i+count] = tokenarray[i];

	mov	rax, QWORD PTR [rdx]
	add	rcx, 32					; 00000020H
	add	rdx, 32					; 00000020H
	dec	r8
	mov	QWORD PTR [rcx-32], rax
	mov	rax, QWORD PTR [rdx-24]
	mov	QWORD PTR [rcx-24], rax
	mov	rax, QWORD PTR [rdx-16]
	mov	QWORD PTR [rcx-16], rax
	mov	rax, QWORD PTR [rdx-8]
	mov	QWORD PTR [rcx-8], rax
	jne	SHORT $LL3@AddTokens
$LN1@AddTokens:

; 837  :         }
; 838  :     }
; 839  : }

	ret	0
AddTokens ENDP
_TEXT	ENDS
PUBLIC	RunMacro
PUBLIC	ExpandLine
PUBLIC	ExpandText
EXTRN	EmitError:NEAR
EXTRN	isspace:NEAR
EXTRN	SymFind:NEAR
EXTRN	isalnum:NEAR
EXTRN	isalpha:NEAR
EXTRN	ModuleInfo:BYTE
xdata	SEGMENT
$unwind$ExpandText DD 0123901H
	DD	01ef439H
	DD	01fe435H
	DD	020d431H
	DD	021c42dH
	DD	0227429H
	DD	0236425H
	DD	0245421H
	DD	029341dH
	DD	0250119H
xdata	ENDS
pdata	SEGMENT
$pdata$ExpandText DD @imagerel($LN204#)
	DD	@imagerel($LN204#+1445)
	DD	@imagerel($unwind$ExpandText#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
rc$1$ = 48
tv1169 = 52
lvl$1$ = 56
is_exitm$ = 60
old_tokencount$1$ = 64
old_stringbufferend$1$ = 72
sp$ = 80
line$ = 304
tokenarray$ = 312
substitute$ = 320
ExpandText PROC NEAR

; 851  : {

$LN204:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, rsp
	sub	rsp, 296				; 00000128H
	mov	QWORD PTR [rax+32], rbx
	mov	QWORD PTR [rax-8], rbp
	mov	QWORD PTR [rax-16], rsi
	mov	QWORD PTR [rax-24], rdi
	mov	QWORD PTR [rax-32], r12
	mov	QWORD PTR [rax-40], r13
	mov	QWORD PTR [rax-48], r14
	mov	QWORD PTR [rax-56], r15

; 852  :     char *pSrc;
; 853  :     char *pDst;
; 854  :     char *pIdent;
; 855  :     int  lvl;
; 856  :     bool is_exitm;
; 857  :     int old_tokencount = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR old_tokencount$1$[rsp], eax

; 858  :     char *old_stringbufferend = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488

; 859  :     char quoted_string = 0;
; 860  :     char macro_proc = FALSE;

	xor	r12b, r12b
	mov	QWORD PTR old_stringbufferend$1$[rsp], rax

; 861  :     //char *pStart;
; 862  :     ret_code rc;
; 863  :     struct asym *sym;
; 864  :     char *sp[MAX_TEXTMACRO_NESTING];
; 865  : 
; 866  :         DebugMsg1(("ExpandText(line=>%s<, subst=%u ) enter\n", line, substitute ));
; 867  :     sp[0] = line;
; 868  :     pDst = StringBufferEnd;

	mov	rbp, rax

; 869  :     StringBufferEnd += MAX_LINE_LEN;

	add	rax, 1024				; 00000400H
	mov	r13d, r8d
	xor	r14b, r14b

; 870  :     rc = NOT_ERROR;

	xor	r8d, r8d
	mov	rdi, rdx
	mov	DWORD PTR tv1169[rsp], r12d
	mov	QWORD PTR sp$[rsp], rcx
	mov	DWORD PTR rc$1$[rsp], r8d

; 871  :     for ( lvl = 0; lvl >= 0; lvl-- ) {

	mov	edx, r8d
	mov	DWORD PTR lvl$1$[rsp], r8d
	mov	r15, r8
	mov	QWORD PTR ModuleInfo+488, rax
	jmp	SHORT $LN52@ExpandText
	npad	6
$LL203@ExpandText:

; 851  : {

	mov	r13d, DWORD PTR substitute$[rsp]
$LN52@ExpandText:

; 872  :         pSrc = sp[lvl];

	mov	rbx, QWORD PTR sp$[rsp+r15*8]

; 873  :         while ( *pSrc ) {

	movzx	eax, BYTE PTR [rbx]
	test	al, al
	jne	$LN49@ExpandText

; 953  :                             StringBufferEnd = GetAlignedPointer( pSrc, cnt );
; 954  :                             pDst = pIdent;
; 955  :                             rc = STRING_EXPANDED;

	mov	esi, DWORD PTR rc$1$[rsp]
$LN51@ExpandText:

; 871  :     for ( lvl = 0; lvl >= 0; lvl-- ) {

	dec	edx
	dec	r15
	mov	DWORD PTR lvl$1$[rsp], edx
	jns	SHORT $LL203@ExpandText

; 974  :             }
; 975  :         } /* end while */
; 976  :     }
; 977  :     *pDst++ = NULLC;
; 978  : 
; 979  :     StringBufferEnd = old_stringbufferend;
; 980  :     if ( rc == STRING_EXPANDED ) {

	cmp	esi, 1
	mov	rcx, QWORD PTR old_stringbufferend$1$[rsp]
	mov	BYTE PTR [rbp], 0
	mov	QWORD PTR ModuleInfo+488, rcx
	jne	SHORT $LN5@ExpandText

; 981  :         memcpy( line, StringBufferEnd, pDst - StringBufferEnd );

	sub	rbp, rcx
	mov	rdx, rcx
	mov	rcx, QWORD PTR line$[rsp]
	lea	r8, QWORD PTR [rbp+1]
	call	memcpy
$LN5@ExpandText:

; 982  :         DebugMsg1(("ExpandText: expanded line=>%s<\n", line));
; 983  :     }
; 984  :     if ( substitute ) {

	cmp	DWORD PTR substitute$[rsp], 0
	je	$LN2@ExpandText

; 985  :         if ( rc == STRING_EXPANDED ) {

	cmp	esi, 1
	jne	$LN194@ExpandText

; 986  :             Token_Count = Tokenize( tokenarray[0].tokpos, 0, tokenarray, TOK_RESCAN );

	mov	rcx, QWORD PTR [rdi+24]
	mov	r9d, esi
	mov	r8, rdi
	xor	edx, edx
	call	Tokenize

; 989  :             return( ExpandLine( tokenarray[0].tokpos, tokenarray ) );

	mov	rdx, rdi
	mov	DWORD PTR ModuleInfo+496, eax
	mov	rcx, QWORD PTR [rdi+24]
	call	ExpandLine
	jmp	$LN53@ExpandText
	npad	14
$LL202@ExpandText:

; 851  : {

	mov	r13d, DWORD PTR substitute$[rsp]
$LN49@ExpandText:

; 874  :             if( is_valid_id_first_char( *pSrc ) && ( substitute != 0 || quoted_string == 0 ) ) {

	movsx	ecx, al
	call	isalpha
	test	eax, eax
	jne	SHORT $LN46@ExpandText
	movzx	eax, BYTE PTR [rbx]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN46@ExpandText
	cmp	al, 64					; 00000040H
	je	SHORT $LN46@ExpandText
	cmp	al, 36					; 00000024H
	je	SHORT $LN46@ExpandText
	cmp	al, 63					; 0000003fH
	je	SHORT $LN46@ExpandText
	cmp	al, 46					; 0000002eH
	jne	SHORT $LN47@ExpandText
	test	BYTE PTR ModuleInfo+408, 32		; 00000020H
	je	SHORT $LN47@ExpandText
$LN46@ExpandText:
	test	r13d, r13d
	jne	SHORT $LN45@ExpandText
	test	r14b, r14b
	je	SHORT $LN45@ExpandText
$LN47@ExpandText:

; 963  :                         break;
; 964  :                     }
; 965  :                 }
; 966  :             } else {
; 967  :                 if ( *pSrc == '"' || *pSrc == '\'' ) {

	movzx	ecx, BYTE PTR [rbx]
	cmp	cl, 34					; 00000022H
	je	SHORT $LN9@ExpandText
	cmp	cl, 39					; 00000027H
	jne	SHORT $LN6@ExpandText
$LN9@ExpandText:

; 968  :                     if ( quoted_string == 0 )

	test	r14b, r14b
	jne	SHORT $LN8@ExpandText

; 971  :                         quoted_string = 0;
; 972  :                 }
; 973  :                 *pDst++ = *pSrc++;

	mov	esi, DWORD PTR rc$1$[rsp]
	mov	BYTE PTR [rbp], cl
	inc	rbp
	inc	rbx
	movzx	r14d, cl
	jmp	$LN12@ExpandText
$LN8@ExpandText:

; 969  :                         quoted_string = *pSrc;
; 970  :                     else if ( *pSrc == quoted_string )

	movzx	eax, r14b
	cmp	cl, r14b
	mov	edx, 0
	cmove	eax, edx
	mov	r14b, al
$LN6@ExpandText:

; 971  :                         quoted_string = 0;
; 972  :                 }
; 973  :                 *pDst++ = *pSrc++;

	mov	esi, DWORD PTR rc$1$[rsp]
	mov	BYTE PTR [rbp], cl
	inc	rbp
	inc	rbx
	jmp	$LN12@ExpandText
$LN45@ExpandText:

; 875  :                 pIdent = pDst;

	mov	rsi, rbp
	npad	3
$LL44@ExpandText:

; 876  :                 do {
; 877  :                     *pDst++ = *pSrc++;

	movzx	eax, BYTE PTR [rbx]
	inc	rbx
	inc	rbp
	mov	BYTE PTR [rbp-1], al

; 878  :                 } while ( is_valid_id_char( *pSrc ));

	movsx	ecx, BYTE PTR [rbx]
	call	isalnum
	test	eax, eax
	jne	SHORT $LL44@ExpandText
	movzx	eax, BYTE PTR [rbx]
	cmp	al, 95					; 0000005fH
	je	SHORT $LL44@ExpandText
	cmp	al, 64					; 00000040H
	je	SHORT $LL44@ExpandText
	cmp	al, 36					; 00000024H
	je	SHORT $LL44@ExpandText
	cmp	al, 63					; 0000003fH
	je	SHORT $LL44@ExpandText

; 879  :                 *pDst = NULLC;
; 880  :                 sym = SymSearch( pIdent );

	mov	rcx, rsi
	mov	BYTE PTR [rbp], 0
	call	SymFind

; 881  : #ifdef DEBUG_OUT
; 882  :                 if ( sym && ( sym->state == SYM_TMACRO || sym->state == SYM_MACRO ) ) {
; 883  :                     DebugMsg1(( "ExpandText: symbol found: %s, %s, defined=%u, *pDst-1=%c\n", sym->name, sym->state == SYM_TMACRO ? "SYM_TMACRO" : "SYM_MACRO", sym->isdefined, *(pDst-1) ));
; 884  :                 }
; 885  : #endif
; 886  :                 if ( sym && sym->isdefined == TRUE ) {

	test	rax, rax
	mov	r12, rax
	je	$LN197@ExpandText
	test	BYTE PTR [rax+48], 2
	je	$LN198@ExpandText

; 887  :                     if ( sym->state == SYM_TMACRO ) {

	mov	eax, DWORD PTR [rax+40]
	cmp	eax, 10
	jne	$LN40@ExpandText

; 888  :                         /* v2.08: no expansion inside quoted strings without & */
; 889  :                         if ( quoted_string && *(pIdent-1) != '&' && *pSrc != '&' )

	test	r14b, r14b
	je	SHORT $LN39@ExpandText
	cmp	BYTE PTR [rsi-1], 38			; 00000026H
	je	SHORT $LN39@ExpandText
	cmp	BYTE PTR [rbx], 38			; 00000026H
	jne	$LN196@ExpandText
$LN39@ExpandText:

; 890  :                             continue;
; 891  :                         if ( substitute ) {

	test	r13d, r13d
	je	SHORT $LN38@ExpandText

; 892  :                             if ( *(pIdent-1) == '&' )

	cmp	BYTE PTR [rsi-1], 38			; 00000026H
	lea	rax, QWORD PTR [rsi-1]
	cmove	rsi, rax

; 893  :                                 pIdent--;
; 894  :                             if ( *pSrc == '&' )

	cmp	BYTE PTR [rbx], 38			; 00000026H
	jne	SHORT $LN34@ExpandText

; 895  :                                 pSrc++;

	inc	rbx

; 896  :                         } else if ( pIdent > old_stringbufferend && *(pIdent-1) == '%' )

	jmp	SHORT $LN34@ExpandText
$LN38@ExpandText:
	cmp	rsi, QWORD PTR old_stringbufferend$1$[rsp]
	jbe	SHORT $LN34@ExpandText
	cmp	BYTE PTR [rsi-1], 37			; 00000025H
	lea	rax, QWORD PTR [rsi-1]
	cmove	rsi, rax
$LN34@ExpandText:

; 897  :                                 pIdent--;
; 898  : 
; 899  :                         sp[lvl++] = pSrc;

	inc	DWORD PTR lvl$1$[rsp]

; 900  :                         pSrc = StringBufferEnd;
; 901  :                         //StringBufferEnd = GetAlignedPointer( pSrc, GetLiteralValue( pSrc, sym->string_ptr ) );
; 902  :                         strcpy( pSrc, sym->string_ptr );

	mov	rcx, QWORD PTR [r12+16]
	mov	QWORD PTR sp$[rsp+r15*8], rbx
	mov	rbx, QWORD PTR ModuleInfo+488
	inc	r15
	mov	rdx, rbx
	npad	10
$LL55@ExpandText:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL55@ExpandText

; 903  :                         StringBufferEnd = GetAlignedPointer( pSrc, strlen( pSrc ) );
; 904  :                         DebugMsg1(("ExpandText: %s replaced by >%s<\n", sym->name, pSrc ));
; 905  :                         pDst = pIdent;
; 906  :                         rc = STRING_EXPANDED;

	mov	r12d, DWORD PTR tv1169[rsp]
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	mov	rbp, rsi
	repne scasb
	mov	rdi, QWORD PTR tokenarray$[rsp]
	mov	eax, 1
	not	rcx
	mov	esi, eax
	mov	DWORD PTR rc$1$[rsp], eax
	add	rcx, 7
	and	rcx, -8
	add	rcx, rbx
	mov	QWORD PTR ModuleInfo+488, rcx
	jmp	$LN13@ExpandText
$LN40@ExpandText:

; 907  :                     } else if ( sym->state == SYM_MACRO && sym->isfunc == TRUE ) {

	cmp	eax, 9
	jne	$LN32@ExpandText
	test	BYTE PTR [r12+52], 2
	je	$LN32@ExpandText

; 908  :                         /* expand macro functions. */
; 909  :                         char *p = pSrc;
; 910  :                         int i;
; 911  :                         while ( isspace(*p) ) p++;

	movsx	ecx, BYTE PTR [rbx]
	mov	rdi, rbx
	call	isspace
	test	eax, eax
	je	SHORT $LN30@ExpandText
	npad	9
$LL31@ExpandText:
	movsx	ecx, BYTE PTR [rdi+1]
	inc	rdi
	call	isspace
	test	eax, eax
	jne	SHORT $LL31@ExpandText
$LN30@ExpandText:

; 912  :                         /* no macro function invokation if the '(' is missing! */
; 913  :                         if ( *p == '(' ) {

	cmp	BYTE PTR [rdi], 40			; 00000028H
	jne	$LN199@ExpandText

; 914  :                             int j;
; 915  :                             int cnt;
; 916  :                             i = Token_Count + 1;

	mov	r13d, DWORD PTR ModuleInfo+496

; 917  :                             Token_Count = Tokenize( p, i, tokenarray, TOK_RESCAN );

	mov	r8, QWORD PTR tokenarray$[rsp]
	mov	r9d, 1
	inc	r13d
	mov	rcx, rdi
	mov	edx, r13d
	call	Tokenize

; 918  :                             for ( j = i, cnt = 0; j < Token_Count; j++ ) {

	xor	r8d, r8d
	mov	edi, r13d
	mov	r11d, eax
	mov	DWORD PTR ModuleInfo+496, eax
	mov	eax, r8d
	cmp	r13d, r11d
	movsxd	rdx, r13d
	jge	SHORT $LN26@ExpandText
	shl	rdx, 5
	add	rdx, QWORD PTR tokenarray$[rsp]
$LL28@ExpandText:

; 919  :                                 if ( tokenarray[j].token == T_OP_BRACKET )

	movzx	ecx, BYTE PTR [rdx]
	cmp	cl, 40					; 00000028H
	jne	SHORT $LN25@ExpandText

; 920  :                                     cnt++;

	inc	eax
	jmp	SHORT $LN27@ExpandText
$LN25@ExpandText:

; 921  :                                 else if ( tokenarray[j].token == T_CL_BRACKET ) {

	cmp	cl, 41					; 00000029H
	jne	SHORT $LN27@ExpandText

; 922  :                                     cnt--;

	dec	eax

; 923  :                                     if ( cnt == 0 ) {

	je	SHORT $LN188@ExpandText
$LN27@ExpandText:

; 918  :                             for ( j = i, cnt = 0; j < Token_Count; j++ ) {

	inc	edi
	add	rdx, 32					; 00000020H
	cmp	edi, r11d
	jl	SHORT $LL28@ExpandText

; 958  :                         macro_proc = TRUE;
; 959  :                     }
; 960  :                     if ( lvl == MAX_TEXTMACRO_NESTING ) {

	jmp	SHORT $LN26@ExpandText
$LN188@ExpandText:

; 924  :                                         j++;

	inc	edi
$LN26@ExpandText:

; 925  :                                         break;
; 926  :                                     }
; 927  :                                 }
; 928  :                             }
; 929  :                             /* don't substitute inside quoted strings if there's no '&' */
; 930  :                             if ( quoted_string && *(pIdent-1) != '&' && tokenarray[j].token != '&' ) {

	test	r14b, r14b
	je	SHORT $LN201@ExpandText
	cmp	BYTE PTR [rsi-1], 38			; 00000026H
	je	SHORT $LN200@ExpandText
	movsxd	rax, edi
	mov	rdi, QWORD PTR tokenarray$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 38			; 00000026H
	je	SHORT $LN21@ExpandText

; 931  :                                 Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$1$[rsp]

; 932  :                                 continue;

	mov	esi, DWORD PTR rc$1$[rsp]
	mov	r12d, DWORD PTR tv1169[rsp]
	mov	DWORD PTR ModuleInfo+496, eax
	jmp	$LN12@ExpandText
$LN200@ExpandText:

; 956  :                         }

	mov	rdi, QWORD PTR tokenarray$[rsp]
	jmp	SHORT $LN21@ExpandText
$LN201@ExpandText:
	mov	rdi, QWORD PTR tokenarray$[rsp]
$LN21@ExpandText:

; 933  :                             }
; 934  :                             if ( substitute ) {

	mov	ebx, DWORD PTR substitute$[rsp]
	test	ebx, ebx
	je	SHORT $LN20@ExpandText

; 935  :                                 if ( *(pIdent-1) == '&' )

	cmp	BYTE PTR [rsi-1], 38			; 00000026H
	jne	SHORT $LN17@ExpandText

; 936  :                                     pIdent--;

	dec	rsi

; 937  :                             } else if ( pIdent > old_stringbufferend && *(pIdent-1) == '%' )

	jmp	SHORT $LN17@ExpandText
$LN20@ExpandText:
	cmp	rsi, QWORD PTR old_stringbufferend$1$[rsp]
	jbe	SHORT $LN17@ExpandText
	cmp	BYTE PTR [rsi-1], 37			; 00000025H
	lea	rax, QWORD PTR [rsi-1]
	cmove	rsi, rax
$LN17@ExpandText:

; 938  :                                 pIdent--;
; 939  :                             //*StringBufferEnd = NULLC;
; 940  :                             i = RunMacro( (struct dsym *)sym, i, tokenarray, pDst, 0, &is_exitm );

	lea	rax, QWORD PTR is_exitm$[rsp]
	mov	r9, rbp
	mov	edx, r13d
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], r8d
	mov	r8, rdi
	mov	rcx, r12
	call	RunMacro

; 941  :                             Token_Count = old_tokencount;

	mov	ecx, DWORD PTR old_tokencount$1$[rsp]

; 942  :                             DebugMsg1(( "ExpandText: back from RunMacro(%s), rc=%u, text returned=>%s<, rest=>%s<\n", sym->name, i, pDst, i >= 0 ? tokenarray[i].tokpos : "" ));
; 943  :                             if ( i == -1 ) {

	cmp	eax, -1
	mov	DWORD PTR ModuleInfo+496, ecx
	je	$LN189@ExpandText

; 945  :                             }
; 946  :                             pSrc = tokenarray[i-1].tokpos + strlen( tokenarray[i-1].string_ptr );

	movsxd	rdx, eax
	xor	eax, eax
	mov	rcx, -1
	shl	rdx, 5
	mov	rdi, QWORD PTR [rdx+rdi-24]
	repne scasb
	mov	rax, QWORD PTR tokenarray$[rsp]
	not	rcx
	dec	rcx
	add	rcx, QWORD PTR [rdx+rax-8]

; 947  :                             if ( substitute && *pSrc == '&' )

	test	ebx, ebx
	je	SHORT $LN15@ExpandText
	cmp	BYTE PTR [rcx], 38			; 00000026H
	jne	SHORT $LN15@ExpandText

; 948  :                                 pSrc++;

	inc	rcx
$LN15@ExpandText:

; 949  :                             sp[lvl++] = pSrc;
; 950  :                             pSrc = StringBufferEnd;

	mov	rbx, QWORD PTR ModuleInfo+488
	inc	DWORD PTR lvl$1$[rsp]
	mov	QWORD PTR sp$[rsp+r15*8], rcx

; 951  :                             cnt = strlen( pDst );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbp
	repne scasb

; 952  :                             memcpy( pSrc, pDst, cnt + 1 );

	mov	rdx, rbp
	inc	r15
	not	rcx
	movsxd	rdi, ecx
	mov	rcx, rbx
	mov	r8, rdi
	call	memcpy

; 956  :                         }

	mov	r12d, DWORD PTR tv1169[rsp]
	lea	rdx, QWORD PTR [rdi+7]
	mov	rdi, QWORD PTR tokenarray$[rsp]
	mov	eax, 1
	and	rdx, -8
	add	rdx, rbx
	mov	rbp, rsi
	mov	esi, eax
	mov	QWORD PTR ModuleInfo+488, rdx
	mov	DWORD PTR rc$1$[rsp], eax
	jmp	SHORT $LN13@ExpandText
$LN32@ExpandText:

; 957  :                     } else if ( sym->state == SYM_MACRO ) {

	mov	r12d, DWORD PTR tv1169[rsp]
	mov	esi, DWORD PTR rc$1$[rsp]
	cmp	eax, 9
	movzx	r12d, r12b
	mov	eax, 1
	cmove	r12d, eax
	mov	DWORD PTR tv1169[rsp], r12d
	jmp	SHORT $LN13@ExpandText
$LN199@ExpandText:

; 932  :                                 continue;

	mov	esi, DWORD PTR rc$1$[rsp]
	mov	rdi, QWORD PTR tokenarray$[rsp]
	mov	r12d, DWORD PTR tv1169[rsp]
$LN13@ExpandText:

; 958  :                         macro_proc = TRUE;
; 959  :                     }
; 960  :                     if ( lvl == MAX_TEXTMACRO_NESTING ) {

	cmp	r15, 20
	jne	SHORT $LN12@ExpandText

; 961  :                         DebugMsg(("ExpandText(line=>%s<) error exit\n", line));
; 962  :                         EmitError( MACRO_NESTING_LEVEL_TOO_DEEP );

	lea	ecx, QWORD PTR [r15+81]
	call	EmitError
	mov	edx, DWORD PTR lvl$1$[rsp]
	jmp	$LN51@ExpandText
$LN196@ExpandText:

; 932  :                                 continue;

	mov	esi, DWORD PTR rc$1$[rsp]
	mov	r12d, DWORD PTR tv1169[rsp]
	jmp	SHORT $LN12@ExpandText
$LN197@ExpandText:
	mov	esi, DWORD PTR rc$1$[rsp]
	mov	r12d, DWORD PTR tv1169[rsp]
	jmp	SHORT $LN12@ExpandText
$LN198@ExpandText:
	mov	esi, DWORD PTR rc$1$[rsp]
	mov	r12d, DWORD PTR tv1169[rsp]
$LN12@ExpandText:
	mov	al, BYTE PTR [rbx]
	test	al, al
	jne	$LL202@ExpandText

; 958  :                         macro_proc = TRUE;
; 959  :                     }
; 960  :                     if ( lvl == MAX_TEXTMACRO_NESTING ) {

	mov	edx, DWORD PTR lvl$1$[rsp]
	jmp	$LN51@ExpandText
$LN189@ExpandText:

; 944  :                                 return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN53@ExpandText
$LN194@ExpandText:

; 987  :         }
; 988  :         if ( rc == STRING_EXPANDED || macro_proc ) {

	test	r12b, r12b
	je	SHORT $LN2@ExpandText

; 989  :             return( ExpandLine( tokenarray[0].tokpos, tokenarray ) );

	mov	rcx, QWORD PTR [rdi+24]
	mov	rdx, rdi
	call	ExpandLine
	jmp	SHORT $LN53@ExpandText
$LN2@ExpandText:

; 990  :         }
; 991  :     }
; 992  :     return( rc );

	mov	eax, esi
$LN53@ExpandText:
	mov	r15, QWORD PTR [rsp+240]
	mov	r14, QWORD PTR [rsp+248]
	mov	r13, QWORD PTR [rsp+256]
	mov	r12, QWORD PTR [rsp+264]
	mov	rdi, QWORD PTR [rsp+272]
	mov	rsi, QWORD PTR [rsp+280]
	mov	rbp, QWORD PTR [rsp+288]
	mov	rbx, QWORD PTR [rsp+328]

; 993  : }

	add	rsp, 296				; 00000128H
	ret	0
ExpandText ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$ExpandTMacro DD 042701H
	DD	08e3427H
	DD	08f011bH
xdata	ENDS
pdata	SEGMENT
$pdata$ExpandTMacro DD @imagerel(ExpandTMacro#)
	DD	@imagerel(ExpandTMacro#+85)
	DD	@imagerel($unwind$ExpandTMacro#)
pdata	ENDS
xdata	SEGMENT
$chain$3$ExpandTMacro DD 061a21H
	DD	08b741aH
	DD	08c6412H
	DD	08d5408H
	DD	@imagerel(ExpandTMacro#)
	DD	@imagerel(ExpandTMacro#+85)
	DD	@imagerel($unwind$ExpandTMacro#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$ExpandTMacro DD @imagerel(ExpandTMacro#+85)
	DD	@imagerel(ExpandTMacro#+312)
	DD	@imagerel($chain$3$ExpandTMacro#)
pdata	ENDS
xdata	SEGMENT
$chain$5$ExpandTMacro DD 060021H
	DD	08b7400H
	DD	08c6400H
	DD	08d5400H
	DD	@imagerel(ExpandTMacro#)
	DD	@imagerel(ExpandTMacro#+85)
	DD	@imagerel($unwind$ExpandTMacro#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$ExpandTMacro DD @imagerel(ExpandTMacro#+312)
	DD	@imagerel(ExpandTMacro#+766)
	DD	@imagerel($chain$5$ExpandTMacro#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
is_exitm$ = 48
old_tokencount$1$ = 52
tv458 = 56
tv457 = 64
buffer$ = 80
outbuf$ = 1152
tokenarray$ = 1160
equmode$ = 1168
level$ = 1176
ExpandTMacro PROC NEAR

; 1002 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1144				; 00000478H

; 1003 :     int old_tokencount = Token_Count;
; 1004 :     int i;
; 1005 :     char expanded = TRUE;
; 1006 :     int len;
; 1007 :     bool is_exitm;
; 1008 :     struct asym *sym;
; 1009 :     //char lvalue[MAX_LINE_LEN];    /* holds literal value */
; 1010 :     char buffer[MAX_LINE_LEN];
; 1011 : 
; 1012 :     DebugMsg1(("ExpandTMacro(text=>%s< equm=%u lvl=%u) enter\n", outbuf, equmode, level ));
; 1013 : 
; 1014 :     if ( level >= MAX_TEXTMACRO_NESTING ) {

	cmp	r9d, 20
	mov	QWORD PTR [rsp+1136], rbx
	mov	rbx, rdx
	movsxd	rdx, DWORD PTR ModuleInfo+496
	mov	DWORD PTR old_tokencount$1$[rsp], edx
	jl	SHORT $LN18@ExpandTMac

; 1015 :         return( EmitError( MACRO_NESTING_LEVEL_TOO_DEEP ) );

	mov	ecx, 101				; 00000065H
	call	EmitError
	mov	rbx, QWORD PTR [rsp+1136]

; 1069 : }

	add	rsp, 1144				; 00000478H
	ret	0
$LN18@ExpandTMac:
	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR [rsp+1128], rbp
	inc	edx
	mov	QWORD PTR [rsp+1120], rsi
	mov	QWORD PTR [rsp+1112], rdi
	mov	QWORD PTR tv457[rsp], rax
	mov	DWORD PTR tv458[rsp], edx
	npad	8
$LL11@ExpandTMac:

; 1016 :     }
; 1017 : 
; 1018 :     while ( expanded == TRUE ) {
; 1019 :         i = old_tokencount + 1;
; 1020 :         Token_Count = Tokenize( outbuf, i, tokenarray, TOK_RESCAN );

	mov	r9d, 1
	mov	r8, rbx
	mov	esi, edx
	mov	rbp, rax
	call	Tokenize

; 1021 :         expanded = FALSE;
; 1022 :         for ( ; i < Token_Count; i++ ) {

	cmp	esi, eax
	mov	DWORD PTR ModuleInfo+496, eax
	jge	SHORT $LN10@ExpandTMac
	lea	rdi, QWORD PTR [rbp+1]
	shl	rdi, 5
	add	rdi, rbx
$LL9@ExpandTMac:

; 1023 :             if ( tokenarray[i].token == T_ID ) {

	cmp	BYTE PTR [rdi-32], 8
	jne	SHORT $LN8@ExpandTMac

; 1024 :                 sym = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rdi-24]
	call	SymFind

; 1025 :                 /* expand macro functions */
; 1026 :                 if ( sym && sym->state == SYM_MACRO &&
; 1027 :                     sym->isdefined == TRUE && sym->isfunc == TRUE &&
; 1028 :                     tokenarray[i+1].token == T_OP_BRACKET && equmode == FALSE ) {

	test	rax, rax
	mov	rbx, rax
	je	SHORT $LN32@ExpandTMac
	mov	eax, DWORD PTR [rax+40]
	cmp	eax, 9
	jne	SHORT $LN5@ExpandTMac
	test	BYTE PTR [rbx+48], 2
	je	SHORT $LN5@ExpandTMac
	test	BYTE PTR [rbx+52], 2
	je	SHORT $LN5@ExpandTMac
	cmp	BYTE PTR [rdi], 40			; 00000028H
	jne	SHORT $LN5@ExpandTMac
	cmp	DWORD PTR equmode$[rsp], 0
	je	SHORT $LN23@ExpandTMac
$LN5@ExpandTMac:

; 1040 :                     /* is i to be decremented here? */
; 1041 :                     break;
; 1042 :                 } else if ( sym && sym->state == SYM_TMACRO && sym->isdefined == TRUE ) {

	cmp	eax, 10
	jne	SHORT $LN32@ExpandTMac
	test	BYTE PTR [rbx+48], 2
	jne	$LN24@ExpandTMac
$LN32@ExpandTMac:
	mov	eax, DWORD PTR ModuleInfo+496
$LN8@ExpandTMac:

; 1021 :         expanded = FALSE;
; 1022 :         for ( ; i < Token_Count; i++ ) {

	inc	esi
	inc	rbp
	add	rdi, 32					; 00000020H
	cmp	esi, eax
	jl	SHORT $LL9@ExpandTMac
$LN10@ExpandTMac:

; 1067 :     //strcpy( outbuf, lvalue );
; 1068 :     return( NOT_ERROR );

	xor	eax, eax
$LN36@ExpandTMac:

; 1060 :                     expanded = TRUE;
; 1061 :                     break;
; 1062 :                 }
; 1063 :             }
; 1064 :         }
; 1065 :     }
; 1066 :     Token_Count = old_tokencount;

	mov	ecx, DWORD PTR old_tokencount$1$[rsp]
	mov	rsi, QWORD PTR [rsp+1120]
	mov	rbp, QWORD PTR [rsp+1128]
	mov	rdi, QWORD PTR [rsp+1112]
	mov	rbx, QWORD PTR [rsp+1136]
	mov	DWORD PTR ModuleInfo+496, ecx

; 1069 : }

	add	rsp, 1144				; 00000478H
	ret	0
$LN23@ExpandTMac:

; 1029 :                     len = tokenarray[i].tokpos - outbuf;

	mov	rax, QWORD PTR tokenarray$[rsp]
	shl	rbp, 5

; 1030 :                     memcpy( buffer, outbuf, len );

	lea	rcx, QWORD PTR buffer$[rsp]
	mov	eax, DWORD PTR [rax+rbp+24]
	mov	rbp, QWORD PTR outbuf$[rsp]
	sub	eax, ebp
	mov	rdx, rbp
	movsxd	rdi, eax
	mov	r8, rdi
	call	memcpy

; 1031 :                     i = RunMacro( (struct dsym *)sym, i+1, tokenarray, buffer+len, 0, &is_exitm );

	mov	r8, QWORD PTR tokenarray$[rsp]
	lea	rax, QWORD PTR is_exitm$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rdi, QWORD PTR buffer$[rsp+rdi]
	lea	edx, DWORD PTR [rsi+1]
	mov	rcx, rbx
	mov	r9, rdi
	mov	DWORD PTR [rsp+32], 0
	call	RunMacro

; 1032 :                     if ( i < 0 ) {

	test	eax, eax
	js	$LN25@ExpandTMac

; 1035 :                     }
; 1036 :                     DebugMsg1(("ExpandTMacro(%u): repl >%s()< by >%s<\n", level, sym->name, buffer+len ));
; 1037 :                     strcat( buffer+len, tokenarray[i].tokpos );

	mov	rbx, QWORD PTR tokenarray$[rsp]
	movsxd	rdx, eax
	xor	eax, eax
	shl	rdx, 5
	mov	rcx, -1
	mov	r8, QWORD PTR [rdx+rbx+24]
	repne scasb
	xor	ecx, ecx
	npad	5
$LL31@ExpandTMac:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL31@ExpandTMac

; 1038 :                     strcpy( outbuf, buffer );

	lea	rax, QWORD PTR buffer$[rsp]
	mov	rdx, rbp
	lea	rcx, QWORD PTR buffer$[rsp]
	sub	rdx, rax
$LL15@ExpandTMac:
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx+rcx-1], al
	jne	SHORT $LL15@ExpandTMac

; 1039 :                     expanded = TRUE;

	mov	rcx, QWORD PTR outbuf$[rsp]
	mov	edx, DWORD PTR tv458[rsp]
	mov	rax, QWORD PTR tv457[rsp]
	jmp	$LL11@ExpandTMac
$LN24@ExpandTMac:

; 1043 :                     char *p;
; 1044 :                     len = tokenarray[i].tokpos - outbuf;

	mov	rcx, QWORD PTR outbuf$[rsp]
	mov	rsi, QWORD PTR tokenarray$[rsp]
	shl	rbp, 5
	mov	eax, DWORD PTR [rsi+rbp+24]

; 1045 :                     memcpy( buffer, outbuf, len );

	mov	rdx, rcx
	sub	eax, ecx
	lea	rcx, QWORD PTR buffer$[rsp]
	movsxd	rdi, eax
	mov	r8, rdi
	call	memcpy

; 1046 :                     //GetLiteralValue( buffer+len, sym->string_ptr );
; 1047 :                     strcpy( buffer+len, sym->string_ptr );

	mov	r11, QWORD PTR [rbx+16]
	lea	rdi, QWORD PTR buffer$[rsp+rdi]
	mov	rcx, rdi
	npad	3
$LL16@ExpandTMac:
	movzx	eax, BYTE PTR [r11]
	inc	rcx
	inc	r11
	test	al, al
	mov	BYTE PTR [rcx-1], al
	jne	SHORT $LL16@ExpandTMac

; 1048 :                     DebugMsg1(("ExpandTMacro(>%s<, %u): calling ExpandTMacro, value >%s<\n", sym->name, level, buffer+len ));
; 1049 :                     if ( ERROR == ExpandTMacro( buffer + len, tokenarray, equmode, level+1 ) ) {

	mov	r9d, DWORD PTR level$[rsp]
	mov	r8d, DWORD PTR equmode$[rsp]
	mov	rdx, rsi
	inc	r9d
	mov	rcx, rdi
	call	ExpandTMacro
	cmp	eax, -1
	je	$LN25@ExpandTMac

; 1050 :                         Token_Count = old_tokencount;
; 1051 :                         return( ERROR );
; 1052 :                     }
; 1053 :                     DebugMsg1(("ExpandTMacro(%u): repl >%s< by >%s<\n", level, sym->name, buffer+len ));
; 1054 :                     //if ( level || ( tokenarray[i+1].token != T_FINAL && tokenarray[i+1].token != T_COMMA ))
; 1055 :                         p = tokenarray[i].tokpos + sym->name_size;
; 1056 :                     //else
; 1057 :                     //    p = tokenarray[i+1].tokpos;
; 1058 :                     strcat( buffer+len, p );

	movzx	edx, BYTE PTR [rbx+80]
	mov	rbx, QWORD PTR tokenarray$[rsp]
	xor	eax, eax
	add	rdx, QWORD PTR [rbx+rbp+24]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	10
$LL30@ExpandTMac:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL30@ExpandTMac

; 1059 :                     strcpy( outbuf, buffer );

	mov	rdx, QWORD PTR outbuf$[rsp]
	lea	rax, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp]
	sub	rdx, rax
	npad	12
$LL17@ExpandTMac:
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx+rcx-1], al
	jne	SHORT $LL17@ExpandTMac
	mov	rcx, QWORD PTR outbuf$[rsp]
	mov	edx, DWORD PTR tv458[rsp]
	mov	rax, QWORD PTR tv457[rsp]
	jmp	$LL11@ExpandTMac
$LN25@ExpandTMac:

; 1033 :                         Token_Count = old_tokencount;
; 1034 :                         return( ERROR );

	mov	eax, -1
	jmp	$LN36@ExpandTMac
ExpandTMacro ENDP
_TEXT	ENDS
EXTRN	EmitErr:NEAR
xdata	SEGMENT
$unwind$RebuildLine DD 0122f01H
	DD	087f42fH
	DD	088e42bH
	DD	089d427H
	DD	08ac423H
	DD	08b741fH
	DD	08c641bH
	DD	08d5417H
	DD	08e3413H
	DD	08f010fH
xdata	ENDS
pdata	SEGMENT
$pdata$RebuildLine DD @imagerel(RebuildLine#)
	DD	@imagerel(RebuildLine#+482)
	DD	@imagerel($unwind$RebuildLine#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
tv313 = 32
buffer$ = 48
newstring$ = 1152
i$ = 1160
tokenarray$ = 1168
oldlen$ = 1176
pos_line$ = 1184
addbrackets$ = 1192
RebuildLine PROC NEAR

; 1081 : {

	mov	QWORD PTR [rsp+24], r8
	mov	rax, rsp
	sub	rsp, 1144				; 00000478H
	mov	QWORD PTR [rax-8], rbx
	mov	QWORD PTR [rax-16], rbp
	mov	QWORD PTR [rax-24], rsi
	mov	QWORD PTR [rax-32], rdi
	mov	QWORD PTR [rax-40], r12
	mov	QWORD PTR [rax-48], r13
	mov	QWORD PTR [rax-56], r14
	mov	QWORD PTR [rax-64], r15
	mov	rsi, rcx
	movsxd	rbp, edx
	mov	r14d, r9d

; 1082 :     char *dest;
; 1083 :     const char *src;
; 1084 :     unsigned  newlen;
; 1085 :     unsigned  rest = strlen( tokenarray[i].tokpos + oldlen ) + 1;

	mov	rcx, -1
	mov	rax, rbp
	shl	rax, 5
	mov	rbx, QWORD PTR [rax+r8+24]
	xor	eax, eax
	lea	rdi, QWORD PTR [r14+rbx]

; 1086 :     char buffer[MAX_LINE_LEN];
; 1087 : 
; 1088 :     dest = tokenarray[i].tokpos;
; 1089 :     memcpy( buffer, dest + oldlen, rest ); /* save content of line behind item */

	lea	rdx, QWORD PTR [r14+rbx]
	repne scasb
	not	rcx
	mov	eax, ecx
	mov	r15d, ecx
	mov	r8d, ecx
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	QWORD PTR tv313[rsp], rax
	call	memcpy

; 1090 :     newlen = strlen( newstring );
; 1091 :     if ( addbrackets ) {

	mov	edx, DWORD PTR addbrackets$[rsp]
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rsi
	repne scasb
	test	edx, edx
	not	rcx
	lea	r12, QWORD PTR [rcx-1]
	je	SHORT $LN15@RebuildLin

; 1092 :         newlen += 2;   /* count '<' and '>' */
; 1093 :         for ( src = newstring; *src; src++ )

	movzx	eax, BYTE PTR [rsi]
	add	r12d, 2
	mov	rcx, rsi
	test	al, al
	je	SHORT $LN15@RebuildLin
	npad	1
$LL17@RebuildLin:

; 1094 :             if ( *src == '<' || *src == '>' || *src == '!' )    /* count '!' operator */

	cmp	al, 60					; 0000003cH
	je	SHORT $LN13@RebuildLin
	cmp	al, 62					; 0000003eH
	je	SHORT $LN13@RebuildLin
	cmp	al, 33					; 00000021H
	jne	SHORT $LN16@RebuildLin
$LN13@RebuildLin:

; 1095 :                 newlen++;

	inc	r12d
$LN16@RebuildLin:

; 1092 :         newlen += 2;   /* count '<' and '>' */
; 1093 :         for ( src = newstring; *src; src++ )

	mov	al, BYTE PTR [rcx+1]
	inc	rcx
	test	al, al
	jne	SHORT $LL17@RebuildLin
$LN15@RebuildLin:

; 1096 :     }
; 1097 :     if ( newlen > oldlen )

	cmp	r12d, r14d
	jbe	SHORT $LN11@RebuildLin

; 1098 :         if ( ( pos_line + newlen - oldlen + rest ) >= MAX_LINE_LEN ) {

	mov	eax, r12d
	sub	eax, r14d
	add	eax, r15d
	add	eax, DWORD PTR pos_line$[rsp]
	cmp	eax, 1024				; 00000400H
	jb	SHORT $LN11@RebuildLin

; 1099 :             return( EmitErr( EXPANDED_LINE_TOO_LONG, tokenarray[0].tokpos ) );

	mov	rcx, QWORD PTR tokenarray$[rsp]
	mov	rdx, QWORD PTR [rcx+24]
	mov	ecx, 90					; 0000005aH
	call	EmitErr
	jmp	$LN19@RebuildLin
$LN11@RebuildLin:

; 1100 :         }
; 1101 : 
; 1102 :     if ( addbrackets ) {

	test	edx, edx
	je	SHORT $LN10@RebuildLin

; 1103 :         *dest++ = '<';

	mov	BYTE PTR [rbx], 60			; 0000003cH
	inc	rbx

; 1104 :         for ( src = newstring; *src; src++ ) {

	cmp	BYTE PTR [rsi], 0
	je	SHORT $LN7@RebuildLin
	npad	1
$LL9@RebuildLin:

; 1105 :             if ( *src == '<' || *src == '>' || *src == '!' )    /* count '!' operator */

	movzx	eax, BYTE PTR [rsi]
	cmp	al, 60					; 0000003cH
	je	SHORT $LN5@RebuildLin
	cmp	al, 62					; 0000003eH
	je	SHORT $LN5@RebuildLin
	cmp	al, 33					; 00000021H
	jne	SHORT $LN6@RebuildLin
$LN5@RebuildLin:

; 1106 :                 *dest++ = '!';

	mov	BYTE PTR [rbx], 33			; 00000021H
	inc	rbx
$LN6@RebuildLin:

; 1107 :             *dest++ = *src;

	movzx	eax, BYTE PTR [rsi]
	inc	rsi
	inc	rbx
	mov	BYTE PTR [rbx-1], al
	cmp	BYTE PTR [rsi], 0
	jne	SHORT $LL9@RebuildLin
$LN7@RebuildLin:

; 1108 :         }
; 1109 :         *dest++ = '>';

	mov	BYTE PTR [rbx], 62			; 0000003eH
	inc	rbx

; 1110 :     } else {

	jmp	SHORT $LN4@RebuildLin
$LN10@RebuildLin:

; 1111 :         memcpy( dest, newstring, newlen );

	mov	r8d, r12d
	mov	rdx, rsi
	mov	rcx, rbx
	mov	edi, r12d
	call	memcpy

; 1112 :         dest += newlen;

	add	rbx, rdi
$LN4@RebuildLin:

; 1113 :     }
; 1114 :     memcpy( dest, buffer, rest ); /* add rest of line */

	mov	r8, QWORD PTR tv313[rsp]
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rbx
	call	memcpy

; 1115 : 
; 1116 :     /* v2.05: changed '<' to '<=' */
; 1117 :     for ( i++; i <= Token_Count; i++ ) {

	inc	ebp
	cmp	ebp, DWORD PTR ModuleInfo+496
	movsxd	rax, ebp
	jg	SHORT $LN1@RebuildLin
	mov	rcx, QWORD PTR tokenarray$[rsp]
	shl	rax, 5
	mov	edx, r12d
	lea	rcx, QWORD PTR [rax+rcx+24]
	npad	11
$LL3@RebuildLin:

; 1118 :         tokenarray[i].tokpos = tokenarray[i].tokpos - oldlen + newlen;

	mov	rax, rdx
	inc	ebp
	add	rcx, 32					; 00000020H
	sub	rax, r14
	add	QWORD PTR [rcx-32], rax
	cmp	ebp, DWORD PTR ModuleInfo+496
	jle	SHORT $LL3@RebuildLin
$LN1@RebuildLin:

; 1119 :     }
; 1120 : 
; 1121 :     return( NOT_ERROR );

	xor	eax, eax
$LN19@RebuildLin:
	mov	r15, QWORD PTR [rsp+1080]
	mov	r14, QWORD PTR [rsp+1088]
	mov	r13, QWORD PTR [rsp+1096]
	mov	r12, QWORD PTR [rsp+1104]
	mov	rdi, QWORD PTR [rsp+1112]
	mov	rsi, QWORD PTR [rsp+1120]
	mov	rbp, QWORD PTR [rsp+1128]
	mov	rbx, QWORD PTR [rsp+1136]

; 1122 : }

	add	rsp, 1144				; 00000478H
	ret	0
RebuildLine ENDP
_TEXT	ENDS
PUBLIC	ExpandLiterals
xdata	SEGMENT
$unwind$ExpandLiterals DD 062001H
	DD	0257420H
	DD	02b5417H
	DD	0270113H
xdata	ENDS
pdata	SEGMENT
$pdata$ExpandLiterals DD @imagerel($LN96#)
	DD	@imagerel($LN96#+128)
	DD	@imagerel($unwind$ExpandLiterals#)
pdata	ENDS
xdata	SEGMENT
$chain$7$ExpandLiterals DD 0c6c21H
	DD	024c46cH
	DD	02a3442H
	DD	021f424H
	DD	022e418H
	DD	023d410H
	DD	0266408H
	DD	@imagerel($LN96#)
	DD	@imagerel($LN96#+128)
	DD	@imagerel($unwind$ExpandLiterals#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$ExpandLiterals DD @imagerel($LN96#+128)
	DD	@imagerel($LN96#+1127)
	DD	@imagerel($chain$7$ExpandLiterals#)
pdata	ENDS
xdata	SEGMENT
$chain$8$ExpandLiterals DD 021H
	DD	@imagerel($LN96#)
	DD	@imagerel($LN96#+128)
	DD	@imagerel($unwind$ExpandLiterals#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$ExpandLiterals DD @imagerel($LN96#+1127)
	DD	@imagerel($LN96#+1151)
	DD	@imagerel($chain$8$ExpandLiterals#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
lvl$1$ = 48
is_exitm$6466 = 52
old_stringbufferend$1$ = 56
old_tokencount$1$ = 64
$T6560 = 72
$T6579 = 80
sp$6473 = 96
i$ = 320
tokenarray$ = 328
ExpandLiterals PROC NEAR

; 1394 : {

$LN96:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	mov	rax, rsp
	sub	rsp, 312				; 00000138H
	mov	QWORD PTR [rax+32], rbp
	movsxd	r9, ecx

; 1395 :     int cnt = 0;

	xor	ebp, ebp
	mov	QWORD PTR [rax-16], rdi

; 1396 :     int idx;
; 1397 :     /* count non-empty literals */
; 1398 :     for ( idx = i; idx < Token_Count; idx++ ) {

	mov	edi, DWORD PTR ModuleInfo+496
	mov	r10, rdx
	cmp	r9d, edi
	mov	edx, ebp
	mov	r8, r9
	mov	DWORD PTR old_tokencount$1$[rsp], edi
	jge	$LN1@ExpandLite
	mov	rax, r9
	shl	rax, 5
	lea	rcx, QWORD PTR [rax+r10+1]
	mov	eax, edi
	sub	eax, r9d
	mov	edi, eax
	npad	2
$LL7@ExpandLite:

; 1399 :         if ( tokenarray[idx].token == T_STRING &&
; 1400 :             tokenarray[idx].stringlen &&
; 1401 :             ( tokenarray[idx].string_delim == '<' || tokenarray[idx].string_delim == '{' ) ) {

	cmp	BYTE PTR [rcx-1], 9
	jne	SHORT $LN6@ExpandLite
	cmp	DWORD PTR [rcx+15], ebp
	je	SHORT $LN6@ExpandLite
	movzx	eax, BYTE PTR [rcx]
	cmp	al, 60					; 0000003cH
	je	SHORT $LN3@ExpandLite
	cmp	al, 123					; 0000007bH
	jne	SHORT $LN6@ExpandLite
$LN3@ExpandLite:

; 1402 :             cnt++;

	inc	edx
$LN6@ExpandLite:

; 1396 :     int idx;
; 1397 :     /* count non-empty literals */
; 1398 :     for ( idx = i; idx < Token_Count; idx++ ) {

	add	rcx, 32					; 00000020H
	dec	rdi
	jne	SHORT $LL7@ExpandLite

; 1403 :         }
; 1404 :     }
; 1405 :     /* if non-empty literals are found, expand the line. if the line
; 1406 :      * was expanded, re-tokenize it.
; 1407 :      */
; 1408 :     if ( cnt ) {

	test	edx, edx
	je	$LN1@ExpandLite

; 1409 :         if ( ExpandText( tokenarray[i].tokpos, tokenarray, FALSE ) == STRING_EXPANDED )

	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR [rsp+304], rsi
	mov	QWORD PTR [rsp+280], r13
	mov	QWORD PTR [rsp+272], r14
	shl	r8, 5
	mov	QWORD PTR [rsp+264], r15
	mov	rcx, QWORD PTR [r8+r10+24]
	mov	QWORD PTR old_stringbufferend$1$[rsp], rax
	mov	rsi, rax
	xor	r13b, r13b
	add	rax, 1024				; 00000400H
	mov	QWORD PTR [rsp+336], rbx
	mov	QWORD PTR $T6560[rsp], rcx
	mov	QWORD PTR sp$6473[rsp], rcx
	mov	QWORD PTR $T6579[rsp], r8
	mov	QWORD PTR ModuleInfo+488, rax
	mov	r14d, ebp
	mov	edi, ebp
	mov	DWORD PTR lvl$1$[rsp], ebp
	mov	r15, rbp
	mov	QWORD PTR [rsp+288], r12
	npad	4
$LL61@ExpandLite:
	mov	rbx, QWORD PTR sp$6473[rsp+r15*8]
	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	$LN60@ExpandLite
$LL58@ExpandLite:
	movsx	ecx, al
	call	isalpha
	test	eax, eax
	jne	SHORT $LN55@ExpandLite
	movzx	eax, BYTE PTR [rbx]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN55@ExpandLite
	cmp	al, 64					; 00000040H
	je	SHORT $LN55@ExpandLite
	cmp	al, 36					; 00000024H
	je	SHORT $LN55@ExpandLite
	cmp	al, 63					; 0000003fH
	je	SHORT $LN55@ExpandLite
	cmp	al, 46					; 0000002eH
	jne	$LN56@ExpandLite
	test	BYTE PTR ModuleInfo+408, 32		; 00000020H
	je	$LN56@ExpandLite
$LN55@ExpandLite:
	test	r13b, r13b
	jne	$LN56@ExpandLite
	mov	rbp, rsi
$LL53@ExpandLite:
	movzx	eax, BYTE PTR [rbx]
	inc	rbx
	inc	rsi
	mov	BYTE PTR [rsi-1], al
	movsx	ecx, BYTE PTR [rbx]
	call	isalnum
	test	eax, eax
	jne	SHORT $LL53@ExpandLite
	movzx	eax, BYTE PTR [rbx]
	cmp	al, 95					; 0000005fH
	je	SHORT $LL53@ExpandLite
	cmp	al, 64					; 00000040H
	je	SHORT $LL53@ExpandLite
	cmp	al, 36					; 00000024H
	je	SHORT $LL53@ExpandLite
	cmp	al, 63					; 0000003fH
	je	SHORT $LL53@ExpandLite
	mov	rcx, rbp
	mov	BYTE PTR [rsi], 0
	call	SymFind
	test	rax, rax
	mov	r12, rax
	je	$LN89@ExpandLite
	test	BYTE PTR [rax+48], 2
	je	$LN88@ExpandLite
	mov	ecx, DWORD PTR [rax+40]
	cmp	ecx, 10
	jne	$LN49@ExpandLite
	cmp	rbp, QWORD PTR old_stringbufferend$1$[rsp]
	jbe	SHORT $LN43@ExpandLite
	cmp	BYTE PTR [rbp-1], 37			; 00000025H
	lea	rax, QWORD PTR [rbp-1]
	cmove	rbp, rax
$LN43@ExpandLite:
	mov	rcx, QWORD PTR [r12+16]
	mov	QWORD PTR sp$6473[rsp+r15*8], rbx
	mov	rbx, QWORD PTR ModuleInfo+488
	inc	edi
	mov	rdx, rbx
	inc	r15
	mov	DWORD PTR lvl$1$[rsp], edi
	npad	8
$LL64@ExpandLite:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL64@ExpandLite
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	mov	edi, DWORD PTR lvl$1$[rsp]
	mov	rsi, rbp
	not	rcx
	lea	r14d, QWORD PTR [rax+1]
	add	rcx, 7
	and	rcx, -8
	add	rcx, rbx
	mov	QWORD PTR ModuleInfo+488, rcx
	jmp	$LN38@ExpandLite
$LN49@ExpandLite:
	cmp	ecx, 9
	jne	$LN38@ExpandLite
	test	BYTE PTR [rax+52], 2
	je	$LN38@ExpandLite
	movsx	ecx, BYTE PTR [rbx]
	mov	rdi, rbx
	call	isspace
	test	eax, eax
	je	SHORT $LN39@ExpandLite
	npad	11
$LL40@ExpandLite:
	movsx	ecx, BYTE PTR [rdi+1]
	inc	rdi
	call	isspace
	test	eax, eax
	jne	SHORT $LL40@ExpandLite
$LN39@ExpandLite:
	cmp	BYTE PTR [rdi], 40			; 00000028H
	jne	$LN87@ExpandLite
	mov	ebx, DWORD PTR ModuleInfo+496
	mov	r14, QWORD PTR tokenarray$[rsp]
	mov	r9d, 1
	inc	ebx
	mov	r8, r14
	mov	rcx, rdi
	mov	edx, ebx
	call	Tokenize
	xor	ecx, ecx
	mov	edi, ebx
	cmp	ebx, eax
	mov	r11d, eax
	mov	DWORD PTR ModuleInfo+496, eax
	movsxd	rdx, ebx
	jge	SHORT $LN86@ExpandLite
	shl	rdx, 5
	add	rdx, r14
$LL37@ExpandLite:
	movzx	eax, BYTE PTR [rdx]
	cmp	al, 40					; 00000028H
	jne	SHORT $LN34@ExpandLite
	inc	ecx
	jmp	SHORT $LN36@ExpandLite
$LN34@ExpandLite:
	cmp	al, 41					; 00000029H
	jne	SHORT $LN36@ExpandLite
	dec	ecx
	je	SHORT $LN86@ExpandLite
$LN36@ExpandLite:
	inc	edi
	add	rdx, 32					; 00000020H
	cmp	edi, r11d
	jl	SHORT $LL37@ExpandLite
$LN86@ExpandLite:
	cmp	rbp, QWORD PTR old_stringbufferend$1$[rsp]
	jbe	SHORT $LN26@ExpandLite
	cmp	BYTE PTR [rbp-1], 37			; 00000025H
	lea	rax, QWORD PTR [rbp-1]
	cmove	rbp, rax
$LN26@ExpandLite:
	lea	rax, QWORD PTR is_exitm$6466[rsp]
	mov	r9, rsi
	mov	r8, r14
	mov	QWORD PTR [rsp+40], rax
	mov	edx, ebx
	mov	rcx, r12
	mov	DWORD PTR [rsp+32], 0
	call	RunMacro
	mov	ecx, DWORD PTR old_tokencount$1$[rsp]
	cmp	eax, -1
	mov	DWORD PTR ModuleInfo+496, ecx
	je	$LN95@ExpandLite
	mov	rbx, QWORD PTR ModuleInfo+488
	inc	DWORD PTR lvl$1$[rsp]
	movsxd	rdx, eax
	shl	rdx, 5
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, QWORD PTR [rdx+r14-24]
	inc	r15
	repne scasb
	mov	rdi, rsi
	not	rcx
	dec	rcx
	add	rcx, QWORD PTR [rdx+r14-8]
	mov	rdx, rsi
	mov	QWORD PTR sp$6473[rsp+r15*8-8], rcx
	mov	rcx, -1
	repne scasb
	not	rcx
	movsxd	rdi, ecx
	mov	eax, ecx
	mov	rcx, rbx
	mov	r8, rdi
	call	memcpy
	lea	rdx, QWORD PTR [rdi+7]
	mov	edi, DWORD PTR lvl$1$[rsp]
	and	rdx, -8
	mov	rsi, rbp
	mov	r14d, 1
	add	rdx, rbx
	mov	QWORD PTR ModuleInfo+488, rdx
	jmp	SHORT $LN38@ExpandLite
$LN87@ExpandLite:
	mov	edi, DWORD PTR lvl$1$[rsp]
$LN38@ExpandLite:
	cmp	r15, 20
	je	SHORT $LN80@ExpandLite
	xor	ebp, ebp
	jmp	SHORT $LN20@ExpandLite
$LN56@ExpandLite:
	movzx	ecx, BYTE PTR [rbx]
	cmp	cl, 34					; 00000022H
	je	SHORT $LN18@ExpandLite
	cmp	cl, 39					; 00000027H
	jne	SHORT $LN15@ExpandLite
$LN18@ExpandLite:
	test	r13b, r13b
	jne	SHORT $LN17@ExpandLite
	mov	BYTE PTR [rsi], cl
	inc	rsi
	movzx	r13d, cl
	inc	rbx
	jmp	SHORT $LN20@ExpandLite
$LN17@ExpandLite:
	movzx	eax, r13b
	cmp	cl, r13b
	cmove	eax, ebp
	mov	r13b, al
$LN15@ExpandLite:
	mov	BYTE PTR [rsi], cl
	inc	rsi
	inc	rbx
	jmp	SHORT $LN20@ExpandLite
$LN88@ExpandLite:
	xor	ebp, ebp
	jmp	SHORT $LN20@ExpandLite
$LN89@ExpandLite:
	xor	ebp, ebp
$LN20@ExpandLite:
	mov	al, BYTE PTR [rbx]
	test	al, al
	jne	$LL58@ExpandLite
	jmp	SHORT $LN60@ExpandLite
$LN80@ExpandLite:
	mov	ecx, 101				; 00000065H
	call	EmitError
$LN60@ExpandLite:
	dec	edi
	dec	r15
	mov	ebp, 0
	mov	DWORD PTR lvl$1$[rsp], edi
	jns	$LL61@ExpandLite
	cmp	r14d, 1
	mov	rcx, QWORD PTR old_stringbufferend$1$[rsp]
	mov	BYTE PTR [rsi], bpl
	mov	QWORD PTR ModuleInfo+488, rcx
	jne	SHORT $LN95@ExpandLite
	sub	rsi, rcx
	mov	rdx, rcx
	mov	rcx, QWORD PTR $T6560[rsp]
	lea	r8, QWORD PTR [rsi+1]
	call	memcpy

; 1410 :             Tokenize( tokenarray[i].tokpos, i, tokenarray, TOK_RESCAN );

	mov	r10, QWORD PTR tokenarray$[rsp]
	mov	rcx, QWORD PTR $T6579[rsp]
	mov	rcx, QWORD PTR [rcx+r10+24]
	mov	edx, DWORD PTR i$[rsp]
	mov	r9d, r14d
	mov	r8, r10
	call	Tokenize
$LN95@ExpandLite:
	mov	r12, QWORD PTR [rsp+288]
	mov	rbx, QWORD PTR [rsp+336]
	mov	r13, QWORD PTR [rsp+280]
	mov	rsi, QWORD PTR [rsp+304]
	mov	r14, QWORD PTR [rsp+272]
	mov	r15, QWORD PTR [rsp+264]
$LN1@ExpandLite:
	mov	rdi, QWORD PTR [rsp+296]
	mov	rbp, QWORD PTR [rsp+344]

; 1411 :     }
; 1412 : 
; 1413 : }

	add	rsp, 312				; 00000138H
	ret	0
ExpandLiterals ENDP
_TEXT	ENDS
EXTRN	PopInputStatus:NEAR
EXTRN	TextItemError:NEAR
EXTRN	WritePreprocessedLine:NEAR
EXTRN	Options:BYTE
EXTRN	ParseLine:NEAR
EXTRN	SetIfNestLevel:NEAR
EXTRN	SetLineNumber:NEAR
EXTRN	_memicmp:NEAR
EXTRN	fill_placeholders:NEAR
EXTRN	PreprocessLine:NEAR
EXTRN	GetIfNestLevel:NEAR
EXTRN	PushMacro:NEAR
EXTRN	PushInputStatus:NEAR
EXTRN	LstWriteSrcLine:NEAR
EXTRN	EmitWarn:NEAR
EXTRN	strchr:NEAR
EXTRN	EvalOperand:NEAR
EXTRN	__chkstk:NEAR
xdata	SEGMENT
$unwind$RunMacro DD 0350a4b01H
	DD	0c9744bH
	DD	0ca643cH
	DD	0cb3435H
	DD	011b3320H
	DD	0501400ccH
xdata	ENDS
pdata	SEGMENT
$pdata$RunMacro DD @imagerel($LN421#)
	DD	@imagerel($LN421#+6007)
	DD	@imagerel($unwind$RunMacro#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 0
quoted_string$1$ = 4
inside_literal$1$ = 8
ptr$1$ = 16
parmidx$1$ = 24
inside_angle_brackets$1$ = 28
oldifnesting$1$ = 32
cnt_opnum$1$ = 32
lvl$1$ = 36
rc$1$ = 40
varargcnt$1$ = 44
parm_end_delim$1$ = 48
bracket_level$1$ = 52
cntgoto$1$ = 56
skipcomma$1$ = 56
$T6891 = 64
tv2960 = 64
old_tokencount$1$ = 72
tmp$1$ = 72
max$1$ = 72
currparm$1$ = 80
pIdent$1$ = 88
$T6847 = 88
$T6890 = 96
is_exitm2$5777 = 104
is_exitm$6618 = 105
info$1$ = 112
old_stringbufferend$1$ = 120
tv2965 = 120
sym$1$ = 128
$T6848 = 128
currparm$ = 128
old_tokencount$1$ = 136
savedStringBuffer$1$ = 144
mi$ = 152
$T6889 = 200
tmpbuf$6687 = 208
oldstat$5828 = 208
opndx$ = 256
sp$6625 = 368
buffer$6702 = 528
buffer$6708 = 528
macro$ = 1600
idx$ = 1608
tokenarray$ = 1616
out$ = 1624
mflags$ = 1632
is_exitm$ = 1640
RunMacro PROC NEAR

; 161  : {

$LN421:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 1632				; 00000660H
	lea	rbp, QWORD PTR [rsp+48]

; 162  :     char        *currparm;
; 163  :     char        *savedStringBuffer = StringBufferEnd;
; 164  :     int         i;
; 165  :     //int         start = idx-1;
; 166  :     int         parmidx;
; 167  :     int         skipcomma;
; 168  :     int         varargcnt;
; 169  :     int         bracket_level = -1;/* () level (needed for macro functions) */
; 170  :     int         parm_end_delim;   /* parameter end delimiter */
; 171  :     //char        addprefix;
; 172  :     char        *ptr;
; 173  :     char        *parmstrings;
; 174  :     struct macro_info *info;
; 175  :     struct srcline    *lnode;
; 176  :     struct asym       *sym;
; 177  :     struct expr       opndx;
; 178  :     struct macro_instance mi;
; 179  : 
; 180  :     DebugMsg1(("RunMacro(%s, idx=%u src=>%s< ) enter, lvl=%u, locals=%04u\n", macro->sym.name, idx, tokenarray[idx].tokpos, MacroLevel, MacroLocals ));
; 181  : 
; 182  :     if ( MacroLevel == MAX_MACRO_NESTING ) {

	cmp	BYTE PTR MacroLevel, 128		; 00000080H
	mov	rax, QWORD PTR ModuleInfo+488
	mov	QWORD PTR [rbp+1576], rbx
	mov	QWORD PTR [rbp+1568], rsi
	mov	ebx, -1
	mov	r10, r9
	mov	QWORD PTR [rbp+1560], rdi
	mov	QWORD PTR savedStringBuffer$1$[rbp], rax
	mov	r9, r8
	movsxd	rsi, edx
	mov	rdi, rcx
	mov	DWORD PTR bracket_level$1$[rbp], ebx
	jne	SHORT $LN162@RunMacro

; 183  :         EmitError( NESTING_LEVEL_TOO_DEEP );

	lea	ecx, QWORD PTR [rbx+101]
	call	EmitError

; 184  :         return( -1 );

	mov	eax, ebx
	jmp	$LN163@RunMacro
$LN162@RunMacro:

; 185  :     }
; 186  :     mi.parm_array = NULL;
; 187  :     info = macro->e.macroinfo;

	mov	r8, QWORD PTR [rcx+104]
	xor	eax, eax

; 188  : #ifdef DEBUG_OUT
; 189  :     info->count++;
; 190  : #endif
; 191  : 
; 192  :     /* invokation of macro functions requires params enclosed in "()" */
; 193  : 
; 194  :     parm_end_delim = T_FINAL;
; 195  :     if ( macro->sym.isfunc ) {

	test	BYTE PTR [rcx+52], 2
	mov	rdx, rax
	mov	QWORD PTR mi$[rbp+24], rax
	mov	DWORD PTR parm_end_delim$1$[rbp], eax
	mov	QWORD PTR info$1$[rbp], r8
	je	SHORT $LN161@RunMacro

; 196  :         if ( tokenarray[idx].token == T_OP_BRACKET ) { /* should be always true */

	mov	rax, rsi
	shl	rax, 5
	cmp	BYTE PTR [rax+r9], 40			; 00000028H
	jne	SHORT $LN160@RunMacro

; 197  :             idx++;

	inc	esi

; 198  :             parm_end_delim = T_CL_BRACKET;
; 199  :             bracket_level = 1;

	mov	ebx, 1
	mov	DWORD PTR parm_end_delim$1$[rbp], 41	; 00000029H
	mov	DWORD PTR idx$[rbp], esi
	mov	DWORD PTR bracket_level$1$[rbp], ebx
$LN160@RunMacro:

; 200  :         }
; 201  :         *out = NULLC; /* v2.08: init return value buffer */

	mov	BYTE PTR [r10], dl
$LN161@RunMacro:

; 202  :     }
; 203  :     /* v2.08: if macro is purged, return "void" */
; 204  :     if ( macro->sym.purged ) {

	movzx	ecx, BYTE PTR [rcx+52]
	test	cl, 16
	je	SHORT $LN159@RunMacro

; 205  :         if ( bracket_level > 0 ) {

	test	ebx, ebx
	jle	SHORT $LN158@RunMacro
	movsxd	rax, esi

; 206  :             for( ; bracket_level && tokenarray[idx].token != T_FINAL; idx++ )

	shl	rax, 5
	add	rax, r9
	npad	5
$LL157@RunMacro:
	movzx	ecx, BYTE PTR [rax]
	test	cl, cl
	je	$LN1@RunMacro

; 207  :                 if ( tokenarray[idx].token == T_OP_BRACKET )

	cmp	cl, 40					; 00000028H
	jne	SHORT $LN154@RunMacro

; 208  :                     bracket_level++;

	inc	ebx
	jmp	SHORT $LN156@RunMacro
$LN154@RunMacro:

; 209  :                 else if ( tokenarray[idx].token == T_CL_BRACKET )

	cmp	cl, 41					; 00000029H
	jne	SHORT $LN156@RunMacro

; 210  :                     bracket_level--;

	dec	ebx
$LN156@RunMacro:

; 206  :             for( ; bracket_level && tokenarray[idx].token != T_FINAL; idx++ )

	inc	esi
	add	rax, 32					; 00000020H
	test	ebx, ebx
	jne	SHORT $LL157@RunMacro

; 211  :         } else

	jmp	$LN1@RunMacro
$LN158@RunMacro:

; 212  :             idx = Token_Count;

	mov	esi, DWORD PTR ModuleInfo+496

; 213  :         DebugMsg1(("RunMacro(%s) exit, macro is purged\n", macro->sym.name ));
; 214  :         return( idx );

	jmp	$LN1@RunMacro
$LN159@RunMacro:

; 215  :     }
; 216  : 
; 217  :     DebugMsg1(( "RunMacro(%s): params=>%s< parmcnt=%u vararg=%u\n", macro->sym.name, tokenarray[idx].tokpos, info->parmcnt, macro->sym.mac_vararg ));
; 218  : 
; 219  :     if ( info->parmcnt ) {

	movzx	eax, WORD PTR [r8]
	test	ax, ax
	je	SHORT $LN370@RunMacro

; 220  :         mi.parm_array = (char **)myalloca( info->parmcnt * sizeof( char * ) + PARMSTRINGSIZE );

	movzx	eax, ax
	lea	rax, QWORD PTR [rax*8+2048]
	add	rax, 15
	and	rax, -16
	call	__chkstk
	sub	rsp, rax
	lea	rdx, QWORD PTR [rsp+48]
	mov	QWORD PTR mi$[rbp+24], rdx

; 222  :         /* init the macro arguments pointer */
; 223  :         currparm = parmstrings;

	movzx	eax, WORD PTR [r8]
	lea	r11, QWORD PTR [rdx+rax*8]
	jmp	SHORT $LN410@RunMacro
$LN370@RunMacro:

; 221  :         parmstrings = (char *)(mi.parm_array + info->parmcnt);

	mov	r11, QWORD PTR currparm$[rbp]
$LN410@RunMacro:

; 224  :     }
; 225  : 
; 226  :     /* now get all the parameters from the original src line.
; 227  :      * macro parameters are expanded if
; 228  :      * - it is a macro function call            or
; 229  :      * - the expansion operator (%) is found
; 230  :      */
; 231  : 
; 232  :     parmidx = 0;

	xor	eax, eax

; 233  : #if MACROLABEL
; 234  :     if ( macro->sym.label ) {

	test	cl, 4
	mov	QWORD PTR currparm$1$[rbp], r11
	mov	r8d, eax
	mov	DWORD PTR parmidx$1$[rbp], eax
	je	SHORT $LN149@RunMacro

; 235  :         if ( mflags & MF_LABEL ) {

	test	BYTE PTR mflags$[rbp], 1
	je	SHORT $LN148@RunMacro

; 236  :             i = strlen( tokenarray[0].string_ptr );

	mov	rdi, QWORD PTR [r9+8]
	mov	rcx, -1
	repne scasb
	not	rcx
	dec	rcx
	mov	DWORD PTR i$[rbp], ecx

; 237  :             mi.parm_array[parmidx] = currparm;

	mov	QWORD PTR [rdx], r11

; 238  :             memcpy( currparm, tokenarray[0].string_ptr, i+1 );

	mov	eax, DWORD PTR i$[rbp]
	mov	rdx, QWORD PTR [r9+8]
	inc	eax
	mov	rcx, r11
	movsxd	r8, eax
	call	memcpy

; 239  :             currparm = GetAlignedPointer( currparm, i );

	mov	eax, DWORD PTR i$[rbp]
	mov	r11, QWORD PTR currparm$1$[rbp]

; 240  :         } else

	mov	rdi, QWORD PTR macro$[rbp]
	inc	eax
	cdqe
	add	rax, 7
	and	rax, -8
	add	r11, rax
	mov	QWORD PTR currparm$1$[rbp], r11
	jmp	SHORT $LN147@RunMacro
$LN148@RunMacro:

; 241  :             mi.parm_array[parmidx] = "";

	lea	rax, OFFSET FLAT:$SG5688
	mov	QWORD PTR [rdx], rax
$LN147@RunMacro:

; 242  :         parmidx++;

	mov	r8d, 1
	mov	DWORD PTR parmidx$1$[rbp], r8d
$LN149@RunMacro:

; 243  :     }
; 244  : #endif
; 245  : 
; 246  :     *is_exitm = FALSE;

	mov	rax, QWORD PTR is_exitm$[rbp]

; 247  : 
; 248  :     /* v2.08: allow T_FINAL to be chained, lastidx==0 is true final */
; 249  :     tokenarray[Token_Count].lastidx = 0;

	mov	r10, QWORD PTR tokenarray$[rbp]
	xor	ecx, ecx
	mov	BYTE PTR [rax], 0
	movsxd	rax, DWORD PTR ModuleInfo+496

; 250  : 
; 251  :     for( varargcnt = 0, skipcomma = 0; parmidx < info->parmcnt; parmidx++ ) {

	movsxd	r9, r8d
	shl	rax, 5
	mov	DWORD PTR varargcnt$1$[rbp], ecx
	mov	QWORD PTR $T6890[rbp], r9
	mov	DWORD PTR [rax+r10+16], ecx
	mov	rax, QWORD PTR info$1$[rbp]
	movzx	edx, WORD PTR [rax]
	cmp	r8d, edx
	jge	$LN374@RunMacro

; 336  :                             }
; 337  :                             continue;
; 338  :                         }
; 339  :                         /* count brackets */
; 340  :                         if ( parm_end_delim == T_CL_BRACKET )

	movsxd	rax, DWORD PTR parm_end_delim$1$[rbp]
	mov	rbx, QWORD PTR info$1$[rbp]
	mov	QWORD PTR $T6889[rbp], rax
$LL146@RunMacro:
	movsxd	rax, esi
	shl	rax, 5
	cmp	BYTE PTR [rax+r10], 44			; 0000002cH
	jne	SHORT $LN143@RunMacro

; 252  : 
; 253  :         /* v2.09: don't skip comma if it was the last argument.
; 254  :          * this will a) make a trailing comma trigger warning 'too many arguments...'
; 255  :          * and b), argument handling of FOR loop is significantly simplified.
; 256  :          */
; 257  :         if ( tokenarray[idx].token == T_COMMA && skipcomma )

	test	ecx, ecx
	je	SHORT $LN143@RunMacro

; 258  :             idx++;

	inc	esi
	mov	DWORD PTR idx$[rbp], esi
$LN143@RunMacro:

; 259  :         skipcomma = 1;
; 260  : 
; 261  :         if ( tokenarray[idx].token == T_FINAL ||
; 262  :             tokenarray[idx].token == parm_end_delim ||
; 263  :             ( tokenarray[idx].token == T_COMMA &&
; 264  :              ( macro->sym.mac_vararg == FALSE || parmidx != info->parmcnt - 1 ) ) ) {

	movsxd	rax, esi
	mov	DWORD PTR skipcomma$1$[rbp], 1
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+r10]
	test	cl, cl
	je	$LN140@RunMacro
	movzx	eax, cl
	cmp	eax, DWORD PTR parm_end_delim$1$[rbp]
	je	$LN140@RunMacro
	cmp	cl, 44					; 0000002cH
	jne	SHORT $LN142@RunMacro
	test	BYTE PTR [rdi+52], 1
	je	$LN140@RunMacro
	lea	eax, DWORD PTR [rdx-1]
	cmp	r8d, eax
	jne	$LN140@RunMacro
$LN142@RunMacro:

; 277  :                 DebugMsg1(("RunMacro(%s.%u): curr (=def) parameter value=>%s<\n", macro->sym.name, parmidx, mi.parm_array[parmidx] ? parmidx, mi.parm_array[parmidx] : "NULL" ));
; 278  :             }
; 279  : 
; 280  :         } else {
; 281  :             int  inside_literal = 0;

	xor	eax, eax

; 282  :             int  inside_angle_brackets = 0;
; 283  :             int  old_tokencount = Token_Count;
; 284  : 
; 285  :             *currparm = NULLC;
; 286  : 
; 287  :             DebugMsg1(( "RunMacro(%s.%u), >%s<\n", macro->sym.name, parmidx, tokenarray[idx].tokpos ));
; 288  : 
; 289  :             for( ptr = currparm; ( tokenarray[idx].token != T_FINAL && tokenarray[idx].token != T_COMMA ) || inside_literal; idx++ ) {

	mov	r9, r11
	mov	QWORD PTR ptr$1$[rbp], r11
	mov	ecx, eax
	mov	edx, eax
	mov	DWORD PTR inside_literal$1$[rbp], eax
	mov	DWORD PTR inside_angle_brackets$1$[rbp], eax
	mov	eax, DWORD PTR ModuleInfo+496
	mov	BYTE PTR [r11], cl
	mov	DWORD PTR old_tokencount$1$[rbp], eax
	npad	2
$LL134@RunMacro:
	movsxd	rdi, esi
	mov	rbx, rdi
	mov	QWORD PTR $T6848[rbp], rdi
	shl	rbx, 5
	mov	QWORD PTR tv2965[rbp], rbx
	movzx	eax, BYTE PTR [rbx+r10]
	test	al, al
	je	SHORT $LN130@RunMacro
	cmp	al, 44					; 0000002cH
	jne	SHORT $LN131@RunMacro
$LN130@RunMacro:
	test	edx, edx
	je	$LN338@RunMacro
$LN131@RunMacro:

; 290  : 
; 291  :                 /* if were're inside a literal, go up one level and continue scanning the argument */
; 292  :                 if ( tokenarray[idx].token == T_FINAL ) {

	test	al, al
	jne	SHORT $LN129@RunMacro

; 293  :                     idx = tokenarray[idx].lastidx; /* restore token index */

	movsxd	rsi, DWORD PTR [rbx+r10+16]

; 294  :                     inside_literal--;

	dec	edx

; 295  :                     if ( tokenarray[idx].string_delim == '<' )

	mov	rax, rsi
	mov	DWORD PTR inside_literal$1$[rbp], edx
	shl	rax, 5
	cmp	BYTE PTR [rax+r10+1], 60		; 0000003cH
	jne	SHORT $LN128@RunMacro

; 296  :                         inside_angle_brackets = 0;

	xor	eax, eax
	inc	esi
	mov	DWORD PTR idx$[rbp], esi
	mov	ecx, eax
	mov	DWORD PTR inside_angle_brackets$1$[rbp], eax
	jmp	SHORT $LL134@RunMacro
$LN128@RunMacro:

; 297  :                     else {
; 298  :                         *ptr++ = '}';

	mov	BYTE PTR [r9], 125			; 0000007dH
	inc	r9
	inc	esi
	mov	DWORD PTR idx$[rbp], esi
	mov	QWORD PTR ptr$1$[rbp], r9
	jmp	SHORT $LL134@RunMacro
$LN129@RunMacro:

; 299  :                     }
; 300  :                     continue;
; 301  :                 }
; 302  : 
; 303  :                 if ( tokenarray[idx].token == T_PERCENT ) {

	cmp	al, 37					; 00000025H
	jne	$LN126@RunMacro

; 304  :                     int max;
; 305  :                     int cnt;
; 306  :                     int cnt_opnum;
; 307  :                     /* expansion of macro parameters.
; 308  :                      * if the token behind % is not a text macro or macro function
; 309  :                      * the expression will be always expanded and evaluated.
; 310  :                      * Else it is expanded, but only evaluated if
; 311  :                      */
; 312  :                     idx++;

	inc	esi

; 313  :                     while ( tokenarray[idx].token == T_PERCENT ) idx++;

	movsxd	rcx, esi
	mov	DWORD PTR idx$[rbp], esi
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+r10], 37			; 00000025H
	jne	SHORT $LN124@RunMacro
	shl	rcx, 5
	add	rcx, r10
$LL125@RunMacro:
	add	rcx, 32					; 00000020H
	inc	esi
	cmp	BYTE PTR [rcx], 37			; 00000025H
	je	SHORT $LL125@RunMacro
	mov	DWORD PTR idx$[rbp], esi
$LN124@RunMacro:

; 314  :                     i = idx;
; 315  :                     cnt_opnum = 1;
; 316  :                     if ( tokenarray[i].token == T_ID ) {

	movsxd	rax, esi
	mov	DWORD PTR i$[rbp], esi
	mov	ecx, esi
	mov	rdi, rax
	mov	DWORD PTR cnt_opnum$1$[rbp], 1
	mov	QWORD PTR $T6847[rbp], rax
	shl	rdi, 5
	mov	QWORD PTR tv2960[rbp], rdi
	cmp	BYTE PTR [rdi+r10], 8
	jne	SHORT $LN409@RunMacro

; 317  :                         sym = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rdi+r10+8]
	call	SymFind

; 318  :                         if ( sym && sym->isdefined &&
; 319  :                             ( sym->state == SYM_TMACRO ||
; 320  :                              ( sym->state == SYM_MACRO && sym->isfunc == TRUE && tokenarray[i+1].token == T_OP_BRACKET ) ) )

	test	rax, rax
	je	SHORT $LN371@RunMacro
	test	BYTE PTR [rax+48], 2
	je	SHORT $LN371@RunMacro
	mov	edx, DWORD PTR [rax+40]
	movsxd	rcx, DWORD PTR i$[rbp]
	mov	r10, QWORD PTR tokenarray$[rbp]
	cmp	edx, 10
	je	SHORT $LN121@RunMacro
	cmp	edx, 9
	jne	SHORT $LN409@RunMacro
	test	BYTE PTR [rax+52], 2
	je	SHORT $LN409@RunMacro
	lea	rax, QWORD PTR [rcx+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+r10], 40			; 00000028H
	jne	SHORT $LN409@RunMacro
$LN121@RunMacro:

; 321  :                             cnt_opnum = 0;

	xor	eax, eax
	mov	DWORD PTR cnt_opnum$1$[rbp], eax
	jmp	SHORT $LN122@RunMacro
$LN371@RunMacro:
	mov	ecx, DWORD PTR i$[rbp]
	mov	r10, QWORD PTR tokenarray$[rbp]
$LN409@RunMacro:

; 729  :                     *is_exitm = TRUE;

	xor	eax, eax
$LN122@RunMacro:

; 322  :                     }
; 323  : 
; 324  :                     for( cnt = 0; tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA; i++ ) {

	mov	ebx, eax
	movsxd	rax, ecx
	shl	rax, 5
	lea	rdx, QWORD PTR [rax+r10]
	movzx	eax, BYTE PTR [rax+r10]
	test	al, al
	je	$LN332@RunMacro
	mov	rsi, QWORD PTR $T6889[rbp]
$LL120@RunMacro:
	cmp	al, 44					; 0000002cH
	je	$LN376@RunMacro

; 325  :                         if ( is_valid_id_first_char( *tokenarray[i].string_ptr )) {

	mov	rax, QWORD PTR [rdx+8]
	movsx	ecx, BYTE PTR [rax]
	call	isalpha
	movsxd	rcx, DWORD PTR i$[rbp]
	mov	r10, QWORD PTR tokenarray$[rbp]
	test	eax, eax
	jne	SHORT $LN116@RunMacro
	mov	rdi, rcx
	shl	rdi, 5
	mov	rax, QWORD PTR [rdi+r10+8]
	movzx	edx, BYTE PTR [rax]
	cmp	dl, 95					; 0000005fH
	je	SHORT $LN116@RunMacro
	cmp	dl, 64					; 00000040H
	je	SHORT $LN116@RunMacro
	cmp	dl, 36					; 00000024H
	je	SHORT $LN116@RunMacro
	cmp	dl, 63					; 0000003fH
	je	SHORT $LN116@RunMacro
	cmp	dl, 46					; 0000002eH
	jne	SHORT $LN117@RunMacro
	test	BYTE PTR ModuleInfo+408, 32		; 00000020H
	jne	SHORT $LN116@RunMacro
$LN117@RunMacro:

; 336  :                             }
; 337  :                             continue;
; 338  :                         }
; 339  :                         /* count brackets */
; 340  :                         if ( parm_end_delim == T_CL_BRACKET )

	cmp	rsi, 41					; 00000029H
	jne	SHORT $LN105@RunMacro

; 341  :                             if ( tokenarray[i].token == T_OP_BRACKET )

	movzx	eax, BYTE PTR [rdi+r10]
	cmp	al, 40					; 00000028H
	jne	SHORT $LN107@RunMacro

; 342  :                                 cnt++;

	inc	ebx
	jmp	SHORT $LN105@RunMacro
$LN107@RunMacro:

; 343  :                             else if ( tokenarray[i].token == T_CL_BRACKET ) {

	cmp	al, 41					; 00000029H
	jne	SHORT $LN105@RunMacro

; 344  :                                 if ( cnt == 0 )

	test	ebx, ebx
	je	$LN376@RunMacro

; 345  :                                     break;
; 346  :                                 cnt--;

	dec	ebx
$LN105@RunMacro:

; 347  :                             }
; 348  : 
; 349  :                         /* stop if undelimited string occurs (need to scan for '!') */
; 350  :                         if ( tokenarray[i].token == T_STRING && tokenarray[i].string_delim == NULLC )

	movzx	eax, BYTE PTR [rdi+r10]
	cmp	al, 9
	jne	SHORT $LN103@RunMacro
	cmp	BYTE PTR [rdi+r10+1], 0
	je	SHORT $LN376@RunMacro
$LN103@RunMacro:

; 351  :                             break;
; 352  : 
; 353  :                         /* names dot and amp are ok */
; 354  :                         if ( tokenarray[i].token == T_DOT || tokenarray[i].token == '&' || tokenarray[i].token == '%' )

	cmp	al, 46					; 0000002eH
	je	SHORT $LN119@RunMacro
	cmp	al, 38					; 00000026H
	je	SHORT $LN119@RunMacro
	cmp	al, 37					; 00000025H
	je	SHORT $LN119@RunMacro

; 355  :                             ;
; 356  :                         else
; 357  :                             cnt_opnum++; /* anything else will trigger numeric evaluation */

	inc	DWORD PTR cnt_opnum$1$[rbp]

; 358  :                     }

	jmp	SHORT $LN119@RunMacro
$LN116@RunMacro:

; 326  :                             if ( tokenarray[i+1].token == T_OP_BRACKET ) {

	lea	rax, QWORD PTR [rcx+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+r10], 40			; 00000028H
	jne	SHORT $LN119@RunMacro

; 327  :                                 int cnt2;
; 328  :                                 i += 2;

	add	ecx, 2

; 329  :                                 for ( cnt2 = 1;cnt2 && tokenarray[i].token != T_FINAL; i++ ) {

	mov	edx, 1
	mov	DWORD PTR i$[rbp], ecx
	npad	14
$LL114@RunMacro:
	movsxd	rax, ecx
	shl	rax, 5
	movzx	eax, BYTE PTR [rax+r10]
	test	al, al
	je	SHORT $LN112@RunMacro

; 330  :                                     if ( tokenarray[i].token == T_OP_BRACKET )

	cmp	al, 40					; 00000028H
	jne	SHORT $LN111@RunMacro

; 331  :                                         cnt2++;

	inc	edx
	jmp	SHORT $LN113@RunMacro
$LN111@RunMacro:

; 332  :                                     else if ( tokenarray[i].token == T_CL_BRACKET )

	cmp	al, 41					; 00000029H
	jne	SHORT $LN113@RunMacro

; 333  :                                         cnt2--;

	dec	edx
$LN113@RunMacro:

; 329  :                                 for ( cnt2 = 1;cnt2 && tokenarray[i].token != T_FINAL; i++ ) {

	inc	ecx
	test	edx, edx
	mov	DWORD PTR i$[rbp], ecx
	jne	SHORT $LL114@RunMacro
$LN112@RunMacro:

; 334  :                                 }
; 335  :                                 i--;

	dec	ecx
$LN119@RunMacro:

; 322  :                     }
; 323  : 
; 324  :                     for( cnt = 0; tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA; i++ ) {

	inc	ecx
	movsxd	rax, ecx
	mov	DWORD PTR i$[rbp], ecx
	shl	rax, 5
	lea	rdx, QWORD PTR [rax+r10]
	mov	al, BYTE PTR [rax+r10]
	test	al, al
	jne	$LL120@RunMacro
$LN376@RunMacro:
	mov	esi, DWORD PTR idx$[rbp]
	mov	rdi, QWORD PTR tv2960[rbp]
$LN332@RunMacro:

; 359  : 
; 360  :                     if ( i == idx ) { /* no items except %? */

	cmp	ecx, esi
	jne	SHORT $LN99@RunMacro

; 361  :                         idx--;

	dec	esi
$LN402@RunMacro:

; 531  :                 ptr += i;

	mov	r9, QWORD PTR ptr$1$[rbp]
	mov	r8d, DWORD PTR parmidx$1$[rbp]
	mov	ecx, DWORD PTR inside_angle_brackets$1$[rbp]
	mov	edx, DWORD PTR inside_literal$1$[rbp]
	inc	esi
	mov	DWORD PTR idx$[rbp], esi
	jmp	$LL134@RunMacro
$LN99@RunMacro:

; 362  :                         continue;
; 363  :                     }
; 364  : 
; 365  :                     cnt = tokenarray[i].tokpos - tokenarray[idx].tokpos;
; 366  :                     while ( isspace( *(tokenarray[idx].tokpos+cnt-1) ) ) cnt--;

	mov	rsi, QWORD PTR tv2960[rbp]
	movsxd	rax, ecx
	shl	rax, 5
	mov	ebx, DWORD PTR [rax+r10+24]
	mov	rax, QWORD PTR [rsi+r10+24]
	sub	ebx, DWORD PTR [rdi+r10+24]
	movsxd	rdi, ebx
	movsx	ecx, BYTE PTR [rax+rdi-1]
	call	isspace
	test	eax, eax
	je	SHORT $LN97@RunMacro
	mov	rax, QWORD PTR $T6847[rbp]
	mov	rsi, QWORD PTR tokenarray$[rbp]
	shl	rax, 5
	mov	QWORD PTR $T6847[rbp], rax
	npad	2
$LL98@RunMacro:
	mov	rax, QWORD PTR [rax+rsi+24]
	dec	rdi
	dec	ebx
	movsx	ecx, BYTE PTR [rdi+rax-1]
	call	isspace
	test	eax, eax
	mov	rax, QWORD PTR $T6847[rbp]
	jne	SHORT $LL98@RunMacro
	mov	rsi, QWORD PTR tv2960[rbp]
$LN97@RunMacro:

; 367  :                     memcpy( ptr, tokenarray[idx].tokpos, cnt );

	mov	rax, QWORD PTR tokenarray$[rbp]
	movsxd	rdi, ebx
	mov	rbx, QWORD PTR ptr$1$[rbp]
	mov	rdx, QWORD PTR [rsi+rax+24]
	mov	r8, rdi
	mov	rcx, rbx
	call	memcpy

; 368  :                     *(ptr+cnt) = NULLC;

	mov	BYTE PTR [rdi+rbx], 0

; 369  :                     if ( ExpandText( ptr, tokenarray, FALSE ) == ERROR ) {

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR old_tokencount$1$[rbp], eax
	mov	rax, QWORD PTR ModuleInfo+488
	xor	dl, dl
	mov	QWORD PTR old_stringbufferend$1$[rbp], rax
	mov	rsi, rax
	add	rax, 1024				; 00000400H
	mov	QWORD PTR ModuleInfo+488, rax
	xor	eax, eax
	mov	BYTE PTR quoted_string$1$[rbp], dl
	mov	edi, eax
	mov	DWORD PTR rc$1$[rbp], eax
	mov	ecx, eax
	mov	DWORD PTR lvl$1$[rbp], eax
	mov	QWORD PTR $T6891[rbp], rax
	mov	QWORD PTR sp$6625[rbp], rbx
$LL222@RunMacro:
	mov	rbx, QWORD PTR sp$6625[rbp+rax*8]
	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	$LN221@RunMacro
$LL219@RunMacro:
	movsx	ecx, al
	call	isalpha
	test	eax, eax
	jne	SHORT $LN216@RunMacro
	movzx	eax, BYTE PTR [rbx]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN216@RunMacro
	cmp	al, 64					; 00000040H
	je	SHORT $LN216@RunMacro
	cmp	al, 36					; 00000024H
	je	SHORT $LN216@RunMacro
	cmp	al, 63					; 0000003fH
	je	SHORT $LN216@RunMacro
	cmp	al, 46					; 0000002eH
	jne	$LN393@RunMacro
	test	BYTE PTR ModuleInfo+408, 32		; 00000020H
	je	$LN393@RunMacro
$LN216@RunMacro:
	movzx	edx, BYTE PTR quoted_string$1$[rbp]
	test	dl, dl
	jne	$LN217@RunMacro
	mov	rdi, rsi
	mov	QWORD PTR pIdent$1$[rbp], rsi
	npad	4
$LL214@RunMacro:
	movzx	eax, BYTE PTR [rbx]
	inc	rbx
	inc	rsi
	mov	BYTE PTR [rsi-1], al
	movsx	ecx, BYTE PTR [rbx]
	call	isalnum
	test	eax, eax
	jne	SHORT $LL214@RunMacro
	movzx	eax, BYTE PTR [rbx]
	cmp	al, 95					; 0000005fH
	je	SHORT $LL214@RunMacro
	cmp	al, 64					; 00000040H
	je	SHORT $LL214@RunMacro
	cmp	al, 36					; 00000024H
	je	SHORT $LL214@RunMacro
	cmp	al, 63					; 0000003fH
	je	SHORT $LL214@RunMacro
	mov	rcx, rdi
	mov	BYTE PTR [rsi], 0
	call	SymFind
	test	rax, rax
	mov	rdx, rax
	mov	QWORD PTR sym$1$[rbp], rax
	je	$LN388@RunMacro
	test	BYTE PTR [rax+48], 2
	je	$LN388@RunMacro
	mov	ecx, DWORD PTR [rax+40]
	cmp	ecx, 10
	jne	$LN210@RunMacro
	cmp	rdi, QWORD PTR old_stringbufferend$1$[rbp]
	jbe	SHORT $LN204@RunMacro
	cmp	BYTE PTR [rdi-1], 37			; 00000025H
	lea	rax, QWORD PTR [rdi-1]
	cmove	rdi, rax
	mov	QWORD PTR pIdent$1$[rbp], rdi
$LN204@RunMacro:
	mov	rax, QWORD PTR $T6891[rbp]
	inc	DWORD PTR lvl$1$[rbp]
	mov	rcx, QWORD PTR [rdx+16]
	mov	QWORD PTR sp$6625[rbp+rax*8], rbx
	mov	rbx, QWORD PTR ModuleInfo+488
	inc	rax
	mov	rdx, rbx
	mov	QWORD PTR $T6891[rbp], rax
	npad	7
$LL225@RunMacro:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL225@RunMacro
	mov	rsi, QWORD PTR pIdent$1$[rbp]
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	mov	edi, 1
	not	rcx
	mov	DWORD PTR rc$1$[rbp], edi
	add	rcx, 7
	and	rcx, -8
	add	rcx, rbx
	mov	QWORD PTR ModuleInfo+488, rcx
	jmp	$LN199@RunMacro
$LN210@RunMacro:
	cmp	ecx, 9
	jne	$LN391@RunMacro
	test	BYTE PTR [rax+52], 2
	je	$LN391@RunMacro
	movsx	ecx, BYTE PTR [rbx]
	mov	rdi, rbx
	call	isspace
	test	eax, eax
	je	SHORT $LN200@RunMacro
	npad	10
$LL201@RunMacro:
	movsx	ecx, BYTE PTR [rdi+1]
	inc	rdi
	call	isspace
	test	eax, eax
	jne	SHORT $LL201@RunMacro
$LN200@RunMacro:
	cmp	BYTE PTR [rdi], 40			; 00000028H
	jne	$LN391@RunMacro
	mov	ebx, DWORD PTR ModuleInfo+496
	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	r9d, 1
	inc	ebx
	mov	rcx, rdi
	mov	edx, ebx
	call	Tokenize
	xor	r8d, r8d
	mov	edi, ebx
	cmp	ebx, eax
	mov	r11d, eax
	mov	DWORD PTR ModuleInfo+496, eax
	mov	ecx, r8d
	movsxd	rdx, ebx
	jge	SHORT $LN334@RunMacro
	shl	rdx, 5
	add	rdx, QWORD PTR tokenarray$[rbp]
	npad	5
$LL198@RunMacro:
	movzx	eax, BYTE PTR [rdx]
	cmp	al, 40					; 00000028H
	jne	SHORT $LN195@RunMacro
	inc	ecx
	jmp	SHORT $LN197@RunMacro
$LN195@RunMacro:
	cmp	al, 41					; 00000029H
	jne	SHORT $LN197@RunMacro
	dec	ecx
	je	SHORT $LN334@RunMacro
$LN197@RunMacro:
	inc	edi
	add	rdx, 32					; 00000020H
	cmp	edi, r11d
	jl	SHORT $LL198@RunMacro
$LN334@RunMacro:
	mov	rcx, QWORD PTR pIdent$1$[rbp]
	cmp	rcx, QWORD PTR old_stringbufferend$1$[rbp]
	jbe	SHORT $LN187@RunMacro
	cmp	BYTE PTR [rcx-1], 37			; 00000025H
	lea	rax, QWORD PTR [rcx-1]
	cmove	rcx, rax
	mov	QWORD PTR pIdent$1$[rbp], rcx
$LN187@RunMacro:
	mov	rdi, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR sym$1$[rbp]
	lea	rax, QWORD PTR is_exitm$6618[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], r8d
	mov	r9, rsi
	mov	r8, rdi
	mov	edx, ebx
	call	RunMacro
	mov	ecx, DWORD PTR old_tokencount$1$[rbp]
	cmp	eax, -1
	mov	DWORD PTR ModuleInfo+496, ecx
	je	$LN337@RunMacro
	mov	rbx, QWORD PTR ModuleInfo+488
	inc	DWORD PTR lvl$1$[rbp]
	movsxd	rdx, eax
	xor	eax, eax
	shl	rdx, 5
	mov	rcx, -1
	mov	rdi, QWORD PTR [rdx+rdi-24]
	repne scasb
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	rdi, rsi
	not	rcx
	dec	rcx
	add	rcx, QWORD PTR [rdx+rax-8]
	mov	rax, QWORD PTR $T6891[rbp]
	mov	rdx, rsi
	mov	QWORD PTR sp$6625[rbp+rax*8], rcx
	inc	rax
	mov	rcx, -1
	mov	QWORD PTR $T6891[rbp], rax
	xor	eax, eax
	repne scasb
	not	rcx
	movsxd	rdi, ecx
	mov	eax, ecx
	mov	rcx, rbx
	mov	r8, rdi
	call	memcpy
	mov	rsi, QWORD PTR pIdent$1$[rbp]
	lea	rdx, QWORD PTR [rdi+7]
	and	rdx, -8
	mov	edi, 1
	add	rdx, rbx
	mov	DWORD PTR rc$1$[rbp], edi
	mov	QWORD PTR ModuleInfo+488, rdx
	jmp	SHORT $LN199@RunMacro
$LN391@RunMacro:
	mov	edi, DWORD PTR rc$1$[rbp]
$LN199@RunMacro:
	cmp	QWORD PTR $T6891[rbp], 20
	jne	$LN181@RunMacro
	mov	ecx, 101				; 00000065H
	call	EmitError
$LN412@RunMacro:
	mov	ecx, DWORD PTR lvl$1$[rbp]
$LN221@RunMacro:
	mov	rax, QWORD PTR $T6891[rbp]
	dec	ecx
	dec	rax
	mov	DWORD PTR lvl$1$[rbp], ecx
	mov	QWORD PTR $T6891[rbp], rax
	jns	$LL222@RunMacro
	cmp	edi, 1
	mov	r9, QWORD PTR old_stringbufferend$1$[rbp]
	mov	BYTE PTR [rsi], 0
	mov	QWORD PTR ModuleInfo+488, r9
	jne	SHORT $LN175@RunMacro
	mov	rbx, QWORD PTR ptr$1$[rbp]
	sub	rsi, r9
	mov	rdx, r9
	lea	r8, QWORD PTR [rsi+1]
	mov	rcx, rbx
	call	memcpy
	jmp	SHORT $LN368@RunMacro
$LN393@RunMacro:
	mov	dl, BYTE PTR quoted_string$1$[rbp]
$LN217@RunMacro:
	movzx	ecx, BYTE PTR [rbx]
	cmp	cl, 34					; 00000022H
	je	SHORT $LN179@RunMacro
	cmp	cl, 39					; 00000027H
	jne	SHORT $LN176@RunMacro
$LN179@RunMacro:
	test	dl, dl
	jne	SHORT $LN178@RunMacro
	mov	BYTE PTR [rsi], cl
	inc	rsi
	mov	dl, cl
	inc	rbx
	mov	BYTE PTR quoted_string$1$[rbp], cl
	jmp	SHORT $LN181@RunMacro
$LN178@RunMacro:
	movzx	eax, dl
	cmp	cl, dl
	mov	edx, 0
	cmove	eax, edx
	mov	dl, al
	mov	BYTE PTR quoted_string$1$[rbp], al
$LN176@RunMacro:
	mov	BYTE PTR [rsi], cl
	inc	rsi
	inc	rbx
	jmp	SHORT $LN181@RunMacro
$LN388@RunMacro:
	mov	edi, DWORD PTR rc$1$[rbp]
$LN181@RunMacro:
	mov	al, BYTE PTR [rbx]
	test	al, al
	jne	$LL219@RunMacro

; 756  :                                     /* label found! */
; 757  :                                     break;
; 758  :                                 }
; 759  :                             }
; 760  :                         }
; 761  :                         if ( !lnode ) {

	jmp	$LN412@RunMacro

; 369  :                     if ( ExpandText( ptr, tokenarray, FALSE ) == ERROR ) {

$LN175@RunMacro:
	cmp	edi, -1
	je	$LN337@RunMacro
	mov	rbx, QWORD PTR ptr$1$[rbp]
$LN368@RunMacro:

; 372  :                     }
; 373  :                     idx = i - 1;

	mov	esi, DWORD PTR i$[rbp]
	dec	esi

; 374  :                     if ( cnt_opnum ) {

	cmp	DWORD PTR cnt_opnum$1$[rbp], 0
	je	$LN403@RunMacro

; 375  :                         /* convert numeric expression into a string */
; 376  :                         max = Tokenize( ptr, Token_Count+1, tokenarray, TOK_RESCAN );

	mov	edx, DWORD PTR ModuleInfo+496
	mov	rdi, QWORD PTR tokenarray$[rbp]
	mov	r9d, 1
	inc	edx
	mov	r8, rdi
	mov	rcx, rbx
	call	Tokenize

; 377  :                         i = Token_Count + 1;

	mov	ecx, DWORD PTR ModuleInfo+496

; 378  :                         DebugMsg1(( "RunMacro(%s.%u), num expansion: >%s<\n", macro->sym.name, parmidx, ptr ));
; 379  :                         /* the % operator won't accept forward references.
; 380  :                          * v2.09: flag EXPF_NOUNDEF set.
; 381  :                          */
; 382  :                         if ( EvalOperand( &i, tokenarray, max, &opndx, EXPF_NOUNDEF ) == ERROR )

	lea	r9, QWORD PTR opndx$[rbp]
	inc	ecx
	mov	r8d, eax
	mov	rdx, rdi
	mov	DWORD PTR i$[rbp], ecx
	lea	rcx, QWORD PTR i$[rbp]
	mov	ebx, eax
	mov	DWORD PTR max$1$[rbp], eax
	mov	BYTE PTR [rsp+32], 2
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN94@RunMacro

; 383  :                             opndx.llvalue = 0;

	xor	eax, eax
	mov	rcx, rax
	mov	QWORD PTR opndx$[rbp], rax
	jmp	SHORT $LN92@RunMacro
$LN94@RunMacro:

; 384  :                         else if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rbp+60], 0
	je	SHORT $LN372@RunMacro

; 385  :                             EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 386  :                             opndx.llvalue = 0;

	xor	eax, eax
	mov	rcx, rax
	mov	QWORD PTR opndx$[rbp], rax
	jmp	SHORT $LN92@RunMacro
$LN372@RunMacro:
	mov	rcx, QWORD PTR opndx$[rbp]
$LN92@RunMacro:

; 387  :                         }
; 388  :                         DebugMsg1(( "RunMacro(%s.%u): num expansion, opndx.type=%d, value=%d\n", macro->sym.name, parmidx, opndx.type, opndx.value ));
; 389  :                         /* v2.08: accept constant and copy any stuff that's following */
; 390  :                         myltoa( opndx.uvalue, StringBufferEnd, ModuleInfo.radix, opndx.hvalue < 0, FALSE );

	movzx	r8d, BYTE PTR ModuleInfo+396
	mov	r9, QWORD PTR ModuleInfo+488
	mov	rax, rcx
	shr	rax, 32					; 00000020H
	test	eax, eax
	jns	$LN286@RunMacro
	mov	BYTE PTR [r9], 45			; 0000002dH
	inc	r9
	neg	ecx
$LN284@RunMacro:
	test	ecx, ecx
	lea	rdi, QWORD PTR tmpbuf$6687[rbp+33]
	mov	BYTE PTR tmpbuf$6687[rbp+33], 0
	je	SHORT $LN281@RunMacro
	lea	rbx, OFFSET FLAT:__digits
	npad	4
$LL283@RunMacro:
	xor	edx, edx
	mov	eax, ecx
	dec	rdi
	div	r8d
	mov	ecx, edx
	mov	edx, eax
	test	edx, edx
	movzx	eax, BYTE PTR [rcx+rbx]
	mov	ecx, edx
	mov	BYTE PTR [rdi], al
	jne	SHORT $LL283@RunMacro
	mov	ebx, DWORD PTR max$1$[rbp]
$LN281@RunMacro:
	lea	r8, QWORD PTR tmpbuf$6687[rbp+34]
	mov	rdx, rdi
	mov	rcx, r9
	sub	r8, rdi
	call	memcpy
$LN287@RunMacro:

; 391  :                         //ptr += strlen( ptr );
; 392  :                         if ( i != max ) {

	movsxd	rax, DWORD PTR i$[rbp]
	cmp	eax, ebx
	je	SHORT $LN91@RunMacro

; 393  :                             /* the evaluator was unable to evaluate the full expression. the rest
; 394  :                              * has to be "copied" */
; 395  :                             DebugMsg1(( "RunMacro(%s.%u): num expansion, additional token=%s\n", macro->sym.name, parmidx, tokenarray[i].tokpos ));
; 396  :                             /* just copy won't work, since <>-literals aren't handled correctly then */
; 397  :                             //EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos );
; 398  :                             strcat( StringBufferEnd, tokenarray[i].tokpos );

	mov	rdi, QWORD PTR ModuleInfo+488
	mov	rdx, rax
	xor	eax, eax
	shl	rdx, 5
	mov	rcx, -1
	repne scasb
	mov	rax, QWORD PTR tokenarray$[rbp]
	xor	ecx, ecx
	mov	r8, QWORD PTR [rdx+rax+24]
	npad	15
$LL369@RunMacro:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL369@RunMacro
$LN91@RunMacro:

; 399  :                         }
; 400  :                         strcpy( ptr, StringBufferEnd );

	mov	r9, QWORD PTR ptr$1$[rbp]
	mov	rcx, QWORD PTR ModuleInfo+488
	mov	rdx, r9
	npad	2
$LL165@RunMacro:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL165@RunMacro

; 443  :                             ptr += tokenarray[idx].stringlen;

	jmp	SHORT $LN95@RunMacro

; 387  :                         }
; 388  :                         DebugMsg1(( "RunMacro(%s.%u): num expansion, opndx.type=%d, value=%d\n", macro->sym.name, parmidx, opndx.type, opndx.value ));
; 389  :                         /* v2.08: accept constant and copy any stuff that's following */
; 390  :                         myltoa( opndx.uvalue, StringBufferEnd, ModuleInfo.radix, opndx.hvalue < 0, FALSE );

$LN286@RunMacro:
	test	ecx, ecx
	jne	$LN284@RunMacro
	mov	BYTE PTR [r9], 48			; 00000030H
	mov	BYTE PTR [r9+1], cl
	jmp	$LN287@RunMacro
$LN403@RunMacro:

; 443  :                             ptr += tokenarray[idx].stringlen;

	mov	r9, QWORD PTR ptr$1$[rbp]
$LN95@RunMacro:

; 401  :                     }
; 402  :                     ptr += strlen( ptr );
; 403  :                     /**/myassert( ptr < parmstrings + PARMSTRINGSIZE );
; 404  :                     continue;

	mov	r10, QWORD PTR tokenarray$[rbp]

; 531  :                 ptr += i;

	mov	r8d, DWORD PTR parmidx$1$[rbp]
	mov	edx, DWORD PTR inside_literal$1$[rbp]
	xor	eax, eax
	mov	rdi, r9
	mov	rcx, -1
	repne scasb
	not	rcx
	dec	rcx
	add	r9, rcx
	mov	ecx, DWORD PTR inside_angle_brackets$1$[rbp]
	inc	esi
	mov	DWORD PTR idx$[rbp], esi
	mov	QWORD PTR ptr$1$[rbp], r9
	jmp	$LL134@RunMacro
$LN126@RunMacro:

; 405  :                 }
; 406  : 
; 407  :                 if ( tokenarray[idx].token == T_STRING && tokenarray[idx].string_delim == '{' ) {

	cmp	al, 9
	jne	SHORT $LN90@RunMacro
	cmp	BYTE PTR [rbx+r10+1], 123		; 0000007bH
	jne	SHORT $LN90@RunMacro

; 408  :                     char *p = tokenarray[idx].string_ptr;

	mov	rcx, QWORD PTR [rbx+r10+8]

; 409  :                     int tmp = idx;
; 410  :                     /* copy the '{' */
; 411  :                     *ptr++ = '{';

	mov	BYTE PTR [r9], 123			; 0000007bH

; 412  :                     /* the string must be tokenized */
; 413  :                     inside_literal++;

	inc	edx
	inc	r9
	mov	DWORD PTR inside_literal$1$[rbp], edx
	mov	edi, esi

; 414  :                     idx = Token_Count;

	mov	esi, DWORD PTR ModuleInfo+496
	mov	QWORD PTR ptr$1$[rbp], r9

; 415  :                     Token_Count = Tokenize( p, idx + 1, tokenarray, TOK_RESCAN | TOK_NOCURLBRACES );

	mov	r9d, 3
	lea	edx, DWORD PTR [rsi+1]
	mov	r8, r10
	call	Tokenize

; 416  :                     tokenarray[Token_Count].lastidx = tmp;

	mov	r10, QWORD PTR tokenarray$[rbp]
	movsxd	rcx, eax
	mov	DWORD PTR ModuleInfo+496, eax
	shl	rcx, 5
	mov	DWORD PTR [rcx+r10+16], edi

; 417  :                     continue;

	jmp	$LN402@RunMacro
$LN90@RunMacro:

; 418  :                 }
; 419  : 
; 420  :                 if ( inside_angle_brackets == 0 ) {

	test	ecx, ecx
	jne	$LN73@RunMacro

; 421  :                     /* track brackets for macro functions; exit if one more ')' than '(' is found */
; 422  :                     if ( bracket_level > 0 ) {

	mov	ecx, DWORD PTR bracket_level$1$[rbp]
	test	ecx, ecx
	jle	SHORT $LN84@RunMacro

; 423  :                         if ( tokenarray[idx].token == T_OP_BRACKET ) {

	cmp	al, 40					; 00000028H
	jne	SHORT $LN87@RunMacro

; 424  :                             bracket_level++;

	inc	ecx
	mov	DWORD PTR bracket_level$1$[rbp], ecx
	jmp	SHORT $LN84@RunMacro
$LN87@RunMacro:

; 425  :                         } else if ( tokenarray[idx].token == T_CL_BRACKET ) {

	cmp	al, 41					; 00000029H
	jne	SHORT $LN84@RunMacro

; 426  :                             bracket_level--;

	dec	ecx
	mov	DWORD PTR bracket_level$1$[rbp], ecx

; 427  :                             if ( bracket_level == 0 )

	je	$LN338@RunMacro
$LN84@RunMacro:

; 428  :                                 break;
; 429  :                         }
; 430  :                     }
; 431  : 
; 432  :                     /* if there's a literal enclosed in <>, remove the delimiters and
; 433  :                      * tokenize the item (Token_Count must be adjusted, since RunMacro()
; 434  :                      * might be called later!)
; 435  :                      */
; 436  :                     if ( tokenarray[idx].token == T_STRING && tokenarray[idx].string_delim == '<' && inside_angle_brackets == 0 ) {

	cmp	al, 9
	jne	$LN83@RunMacro
	cmp	BYTE PTR [rbx+r10+1], 60		; 0000003cH
	jne	$LN83@RunMacro

; 437  :                         char *p;
; 438  :                         int tmp;
; 439  :                         int size;
; 440  : #if 1
; 441  :                         if ( !strchr( tokenarray[idx].string_ptr, '%' ) ) {

	mov	rcx, QWORD PTR [rbx+r10+8]
	mov	edx, 37					; 00000025H
	call	strchr
	test	rax, rax
	jne	SHORT $LN82@RunMacro

; 442  :                             memcpy( ptr, tokenarray[idx].string_ptr, tokenarray[idx].stringlen );

	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	rcx, QWORD PTR ptr$1$[rbp]
	mov	r8d, DWORD PTR [rbx+rax+16]
	mov	rdx, QWORD PTR [rbx+rax+8]
	call	memcpy

; 443  :                             ptr += tokenarray[idx].stringlen;

	mov	r9, QWORD PTR ptr$1$[rbp]
	mov	r10, QWORD PTR tokenarray$[rbp]
	mov	edx, DWORD PTR [rbx+r10+16]

; 531  :                 ptr += i;

	mov	r8d, DWORD PTR parmidx$1$[rbp]
	mov	ecx, DWORD PTR inside_angle_brackets$1$[rbp]
	add	r9, rdx
	mov	edx, DWORD PTR inside_literal$1$[rbp]
	inc	esi
	mov	DWORD PTR idx$[rbp], esi
	mov	QWORD PTR ptr$1$[rbp], r9
	jmp	$LL134@RunMacro
$LN82@RunMacro:

; 448  :                         size = tokenarray[idx+1].tokpos - (tokenarray[idx].tokpos+1);

	mov	rcx, QWORD PTR tokenarray$[rbp]
	shl	rdi, 5
	mov	DWORD PTR tmp$1$[rbp], esi
	mov	edi, DWORD PTR [rdi+rcx+56]

; 449  :                         p = StringBufferEnd;
; 450  :                         memcpy( p, tokenarray[idx].tokpos+1, size );

	mov	rdx, QWORD PTR [rbx+rcx+24]
	mov	rsi, QWORD PTR ModuleInfo+488
	sub	edi, DWORD PTR [rbx+rcx+24]
	inc	rdx
	mov	rcx, rsi
	dec	edi
	movsxd	r8, edi
	call	memcpy

; 451  :                         while ( *(p+size-1) != '>' ) size--;

	movsxd	rax, edi
	cmp	BYTE PTR [rax+rsi-1], 62		; 0000003eH
	je	SHORT $LN80@RunMacro

; 444  :                             continue;
; 445  :                         }
; 446  : #endif
; 447  :                         tmp = idx;

	lea	rax, QWORD PTR [rax+rsi-1]
$LL81@RunMacro:

; 451  :                         while ( *(p+size-1) != '>' ) size--;

	dec	rax
	dec	edi
	cmp	BYTE PTR [rax], 62			; 0000003eH
	jne	SHORT $LL81@RunMacro
$LN80@RunMacro:

; 452  :                         *(p+size-1) = NULLC;
; 453  :                         StringBufferEnd = GetAlignedPointer( p, size );
; 454  :                         //strcpy( tmpline, tokenarray[idx].string_ptr );
; 455  :                         /* the string must be tokenized */
; 456  :                         inside_literal++;
; 457  :                         inside_angle_brackets = 1;
; 458  :                         idx = Token_Count;
; 459  :                         Token_Count = Tokenize( p, idx + 1, tokenarray, TOK_RESCAN );

	mov	rbx, QWORD PTR tokenarray$[rbp]
	movsxd	rax, edi
	mov	r9d, 1
	mov	BYTE PTR [rax+rsi-1], 0
	lea	eax, DWORD PTR [rdi+1]
	movsxd	rdi, DWORD PTR ModuleInfo+496
	movsxd	rcx, eax
	lea	edx, DWORD PTR [rdi+1]
	mov	r8, rbx
	add	rcx, 7
	mov	DWORD PTR inside_angle_brackets$1$[rbp], 1
	mov	DWORD PTR idx$[rbp], edi
	and	rcx, -8
	add	rcx, rsi
	mov	QWORD PTR ModuleInfo+488, rcx
	mov	ecx, DWORD PTR inside_literal$1$[rbp]
	inc	ecx
	mov	DWORD PTR inside_literal$1$[rbp], ecx
	mov	rcx, rsi
	call	Tokenize

; 460  :                         tokenarray[Token_Count].lastidx = tmp;
; 461  :                         /* copy spaces located before the first token */
; 462  :                         memcpy( ptr, p, tokenarray[idx+1].tokpos - p );

	shl	rdi, 5
	mov	rdx, rsi
	mov	DWORD PTR ModuleInfo+496, eax
	movsxd	rcx, eax
	mov	eax, DWORD PTR tmp$1$[rbp]
	shl	rcx, 5
	mov	DWORD PTR [rcx+rbx+16], eax
	mov	r8, QWORD PTR [rdi+rbx+56]
	mov	rcx, QWORD PTR ptr$1$[rbp]
	sub	r8, rsi
	call	memcpy

; 463  :                         ptr += tokenarray[idx+1].tokpos - p;

	mov	r9, QWORD PTR ptr$1$[rbp]
	mov	rdx, QWORD PTR [rdi+rbx+56]
	sub	rdx, rsi
	mov	r10, rbx
	add	r9, rdx
	mov	QWORD PTR ptr$1$[rbp], r9
$LN381@RunMacro:

; 464  :                         continue;

	mov	esi, DWORD PTR idx$[rbp]

; 531  :                 ptr += i;

	mov	r8d, DWORD PTR parmidx$1$[rbp]
	mov	ecx, DWORD PTR inside_angle_brackets$1$[rbp]
	mov	edx, DWORD PTR inside_literal$1$[rbp]
	inc	esi
	mov	DWORD PTR idx$[rbp], esi
	jmp	$LL134@RunMacro
$LN83@RunMacro:

; 465  :                     }
; 466  :                     /* macros functions must be expanded always.
; 467  :                      * text macros are expanded only selectively
; 468  :                      */
; 469  :                     if ( tokenarray[idx].token == T_ID ) {

	cmp	al, 8
	jne	$LN73@RunMacro

; 470  :                         if ( sym = SymSearch( tokenarray[idx].string_ptr ) ) {

	mov	rcx, QWORD PTR [rbx+r10+8]
	call	SymFind
	test	rax, rax
	mov	rsi, rax
	je	$LN382@RunMacro

; 471  :                             if ( sym->state == SYM_MACRO && sym->isdefined == TRUE &&
; 472  :                                 sym->isfunc == TRUE && tokenarray[idx+1].token == T_OP_BRACKET ) {

	mov	ecx, DWORD PTR [rax+40]
	cmp	ecx, 9
	jne	$LN397@RunMacro
	test	BYTE PTR [rax+48], 2
	je	$LN397@RunMacro
	test	BYTE PTR [rax+52], 2
	mov	r10, QWORD PTR tokenarray$[rbp]
	je	$LN77@RunMacro
	lea	rax, QWORD PTR [rdi+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+r10], 40			; 00000028H
	jne	$LN77@RunMacro

; 473  :                                 bool is_exitm2;
; 474  :                                 //int oldidx = idx;
; 475  :                                 idx = RunMacro( (struct dsym *)sym, idx+1, tokenarray, ptr, 0, &is_exitm2 );

	mov	edx, DWORD PTR idx$[rbp]
	mov	r9, QWORD PTR ptr$1$[rbp]
	lea	rax, QWORD PTR is_exitm2$5777[rbp]
	mov	QWORD PTR [rsp+40], rax
	xor	eax, eax
	inc	edx
	mov	r8, r10
	mov	rcx, rsi
	mov	DWORD PTR [rsp+32], eax
	call	RunMacro

; 476  :                                 if ( idx < 0 ) {

	test	eax, eax
	movsxd	rsi, eax
	js	$LN339@RunMacro

; 479  :                                 }
; 480  :                                 ptr += strlen( ptr );

	mov	r9, QWORD PTR ptr$1$[rbp]

; 481  :                                 /* copy spaces behind macro function call */
; 482  :                                 if ( tokenarray[idx].token != T_FINAL && tokenarray[idx].token != T_COMMA ) {

	mov	r10, QWORD PTR tokenarray$[rbp]
	xor	eax, eax
	mov	rdi, r9
	mov	rcx, -1
	mov	rdx, rsi
	repne scasb
	mov	rax, rsi
	not	rcx
	shl	rax, 5
	dec	rcx
	add	r9, rcx
	movzx	ecx, BYTE PTR [rax+r10]
	test	cl, cl
	mov	QWORD PTR ptr$1$[rbp], r9
	je	SHORT $LN75@RunMacro
	cmp	cl, 44					; 0000002cH
	je	SHORT $LN75@RunMacro

; 483  :                                     i = tokenarray[idx].tokpos - ( tokenarray[idx-1].tokpos + 1 );

	mov	eax, DWORD PTR [rax+r10+24]
	shl	rdx, 5

; 484  :                                     memcpy( ptr, tokenarray[idx-1].tokpos + 1, i );

	mov	rcx, r9
	sub	eax, DWORD PTR [rdx+r10-8]
	mov	rdx, QWORD PTR [rdx+r10-8]
	dec	eax
	inc	rdx
	movsxd	r8, eax
	mov	DWORD PTR i$[rbp], eax
	call	memcpy

; 485  :                                     ptr += i;

	mov	r9, QWORD PTR ptr$1$[rbp]
	movsxd	rdx, DWORD PTR i$[rbp]
	mov	r10, QWORD PTR tokenarray$[rbp]
	add	r9, rdx
	mov	QWORD PTR ptr$1$[rbp], r9
$LN75@RunMacro:

; 531  :                 ptr += i;

	mov	r8d, DWORD PTR parmidx$1$[rbp]
	mov	ecx, DWORD PTR inside_angle_brackets$1$[rbp]
	mov	edx, DWORD PTR inside_literal$1$[rbp]
	dec	esi
	inc	esi
	mov	DWORD PTR idx$[rbp], esi
	jmp	$LL134@RunMacro
$LN397@RunMacro:

; 495  :                                 ptr += strlen( ptr );
; 496  :                                 /* copy spaces behind text macro */
; 497  :                                 if ( tokenarray[idx+1].token != T_FINAL && tokenarray[idx+1].token != T_COMMA ) {

	mov	r10, QWORD PTR tokenarray$[rbp]
$LN77@RunMacro:

; 486  :                                 }
; 487  :                                 idx--; /* adjust token index */
; 488  :                                 /**/myassert( ptr < parmstrings + PARMSTRINGSIZE );
; 489  :                                 continue;
; 490  :                             } else if ( sym->state == SYM_TMACRO && sym->isdefined == TRUE &&
; 491  :                                        ( macro->sym.predefined && ( info->autoexp & ( 1 << parmidx ) ) ) ) {

	cmp	ecx, 10
	jne	$LN386@RunMacro
	test	BYTE PTR [rsi+48], 2
	je	$LN386@RunMacro
	mov	rax, QWORD PTR macro$[rbp]
	test	BYTE PTR [rax+48], 32			; 00000020H
	je	$LN386@RunMacro
	mov	rax, QWORD PTR info$1$[rbp]
	mov	ecx, DWORD PTR parmidx$1$[rbp]
	movzx	eax, WORD PTR [rax+2]
	bt	eax, ecx
	jae	$LN386@RunMacro

; 492  :                                 //GetLiteralValue( ptr, sym->string_ptr );
; 493  :                                 strcpy( ptr, sym->string_ptr );

	mov	rdi, QWORD PTR ptr$1$[rbp]
	mov	rcx, QWORD PTR [rsi+16]
	mov	rdx, rdi
	npad	4
$LL166@RunMacro:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL166@RunMacro

; 494  :                                 ExpandTMacro( ptr, tokenarray, FALSE, 0 );

	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, r10
	mov	rcx, rdi
	call	ExpandTMacro

; 495  :                                 ptr += strlen( ptr );
; 496  :                                 /* copy spaces behind text macro */
; 497  :                                 if ( tokenarray[idx+1].token != T_FINAL && tokenarray[idx+1].token != T_COMMA ) {

	mov	r10, QWORD PTR tokenarray$[rbp]
	xor	eax, eax
	mov	r9, rdi
	mov	rcx, -1
	repne scasb
	mov	rax, QWORD PTR $T6848[rbp]
	not	rcx
	dec	rcx
	add	r9, rcx
	lea	rcx, QWORD PTR [rax+1]
	shl	rcx, 5
	mov	QWORD PTR ptr$1$[rbp], r9
	movzx	eax, BYTE PTR [rcx+r10]
	test	al, al
	je	$LN381@RunMacro
	cmp	al, 44					; 0000002cH
	je	$LN381@RunMacro

; 498  :                                     i = tokenarray[idx+1].tokpos - ( tokenarray[idx].tokpos + sym->name_size );

	mov	ecx, DWORD PTR [rcx+r10+24]
	movzx	eax, BYTE PTR [rsi+80]
	sub	ecx, eax
	sub	ecx, DWORD PTR [rbx+r10+24]
	mov	DWORD PTR i$[rbp], ecx

; 499  :                                     memcpy( ptr, tokenarray[idx].tokpos + sym->name_size, i );

	movzx	edx, BYTE PTR [rsi+80]
	movsxd	r8, ecx
	add	rdx, QWORD PTR [rbx+r10+24]
	mov	rcx, r9
	call	memcpy

; 500  :                                     ptr += i;

	movsxd	rdx, DWORD PTR i$[rbp]
	mov	r9, QWORD PTR ptr$1$[rbp]

; 501  :                                 }
; 502  :                                 /**/myassert( ptr < parmstrings + PARMSTRINGSIZE );
; 503  :                                 continue;

	mov	esi, DWORD PTR idx$[rbp]
	mov	r10, QWORD PTR tokenarray$[rbp]

; 531  :                 ptr += i;

	mov	r8d, DWORD PTR parmidx$1$[rbp]
	mov	ecx, DWORD PTR inside_angle_brackets$1$[rbp]
	add	r9, rdx
	mov	edx, DWORD PTR inside_literal$1$[rbp]
	inc	esi
	mov	QWORD PTR ptr$1$[rbp], r9
	mov	DWORD PTR idx$[rbp], esi
	jmp	$LL134@RunMacro
$LN382@RunMacro:

; 464  :                         continue;

	mov	r10, QWORD PTR tokenarray$[rbp]
$LN386@RunMacro:
	mov	esi, DWORD PTR idx$[rbp]
$LN73@RunMacro:

; 504  :                             }
; 505  :                         }
; 506  :                     }
; 507  :                 }
; 508  :                 /* get length of item */
; 509  :                 i = tokenarray[idx+1].tokpos - tokenarray[idx].tokpos;
; 510  :                 if ( !inside_literal && ( tokenarray[idx+1].token == T_COMMA ||
; 511  :                     tokenarray[idx+1].token == parm_end_delim ) ) {

	mov	ecx, DWORD PTR inside_literal$1$[rbp]
	lea	rax, QWORD PTR [rdi+1]
	shl	rax, 5
	mov	edx, DWORD PTR [rax+r10+24]
	sub	edx, DWORD PTR [rbx+r10+24]
	test	ecx, ecx
	mov	DWORD PTR i$[rbp], edx
	jne	SHORT $LN68@RunMacro
	movzx	ecx, BYTE PTR [rax+r10]
	cmp	cl, 44					; 0000002cH
	je	SHORT $LN323@RunMacro
	movzx	eax, cl
	cmp	eax, DWORD PTR parm_end_delim$1$[rbp]
	jne	SHORT $LN68@RunMacro
$LN323@RunMacro:

; 512  :                     while ( isspace( *(tokenarray[idx].tokpos+i-1 ) ) ) i--;

	mov	rax, QWORD PTR [rbx+r10+24]
	movsxd	rcx, edx
	movsx	ecx, BYTE PTR [rcx+rax-1]
	call	isspace
	test	eax, eax
	je	SHORT $LN373@RunMacro
	mov	rbx, QWORD PTR tokenarray$[rbp]
	shl	rdi, 5
	npad	3
$LL69@RunMacro:
	mov	eax, DWORD PTR i$[rbp]
	dec	eax
	mov	DWORD PTR i$[rbp], eax
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rdi+rbx+24]
	movsx	ecx, BYTE PTR [rcx+rax-1]
	call	isspace
	test	eax, eax
	jne	SHORT $LL69@RunMacro
	mov	rbx, QWORD PTR tv2965[rbp]
$LN373@RunMacro:
	mov	r10, QWORD PTR tokenarray$[rbp]
	mov	edx, DWORD PTR i$[rbp]
$LN68@RunMacro:

; 513  :                 }
; 514  :                 /* the literal character operator ! is valid for macro arguments */
; 515  :                 if ( tokenarray[idx].token == T_STRING && tokenarray[idx].string_delim == NULLC ) {

	cmp	BYTE PTR [rbx+r10], 9
	jne	SHORT $LN67@RunMacro
	cmp	BYTE PTR [rbx+r10+1], 0
	jne	SHORT $LN67@RunMacro

; 516  :                     char *p;
; 517  :                     char *end;
; 518  :                     DebugMsg1(("RunMacro(%s.%u): undelimited string >%s<, watching '!'\n", macro->sym.name, parmidx, tokenarray[idx].string_ptr ));
; 519  :                     p = tokenarray[idx].tokpos;

	mov	rcx, QWORD PTR [rbx+r10+24]

; 520  :                     end = p + i;

	movsxd	rdx, edx
	add	rdx, rcx

; 521  :                     /**/myassert( ( ptr + i ) < parmstrings + PARMSTRINGSIZE );
; 522  :                     for ( ; p < end; p++ ) {

	cmp	rcx, rdx
	jae	$LN402@RunMacro
	mov	r9, QWORD PTR ptr$1$[rbp]
$LL66@RunMacro:

; 523  :                         if ( *p == '!' )

	cmp	BYTE PTR [rcx], 33			; 00000021H
	jne	SHORT $LN63@RunMacro

; 524  :                             p++;

	inc	rcx
$LN63@RunMacro:

; 525  :                         *ptr++ = *p;

	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	inc	r9
	cmp	rcx, rdx
	mov	BYTE PTR [r9-1], al
	jb	SHORT $LL66@RunMacro

; 531  :                 ptr += i;

	mov	r8d, DWORD PTR parmidx$1$[rbp]
	mov	ecx, DWORD PTR inside_angle_brackets$1$[rbp]
	mov	edx, DWORD PTR inside_literal$1$[rbp]
	inc	esi
	mov	QWORD PTR ptr$1$[rbp], r9
	mov	DWORD PTR idx$[rbp], esi
	jmp	$LL134@RunMacro
$LN67@RunMacro:

; 526  :                     }
; 527  :                     continue;
; 528  :                 }
; 529  :                 /**/myassert( ( ptr + i ) < parmstrings + PARMSTRINGSIZE );
; 530  :                 memcpy( ptr, tokenarray[idx].tokpos, i );

	mov	rcx, QWORD PTR ptr$1$[rbp]
	movsxd	r8, edx
	mov	rdx, QWORD PTR [rbx+r10+24]
	call	memcpy

; 531  :                 ptr += i;

	movsxd	rdx, DWORD PTR i$[rbp]
	mov	r9, QWORD PTR ptr$1$[rbp]
	mov	r10, QWORD PTR tokenarray$[rbp]
	mov	r8d, DWORD PTR parmidx$1$[rbp]
	mov	ecx, DWORD PTR inside_angle_brackets$1$[rbp]
	add	r9, rdx
	mov	edx, DWORD PTR inside_literal$1$[rbp]
	inc	esi
	mov	DWORD PTR idx$[rbp], esi
	mov	QWORD PTR ptr$1$[rbp], r9
	jmp	$LL134@RunMacro
$LN338@RunMacro:

; 532  : 
; 533  :             } /* end for */
; 534  : 
; 535  :             *ptr = NULLC;
; 536  : 
; 537  :             /* restore input status values */
; 538  :             Token_Count = old_tokencount;

	mov	eax, DWORD PTR old_tokencount$1$[rbp]

; 539  :             StringBufferEnd = savedStringBuffer;
; 540  : 
; 541  :             /* store the macro argument in the parameter array */
; 542  :             if (  macro->sym.mac_vararg && ( parmidx == info->parmcnt - 1 ) ) {

	mov	rdi, QWORD PTR macro$[rbp]
	mov	rbx, QWORD PTR info$1$[rbp]
	mov	BYTE PTR [r9], 0
	mov	DWORD PTR ModuleInfo+496, eax
	mov	rax, QWORD PTR savedStringBuffer$1$[rbp]
	mov	QWORD PTR ModuleInfo+488, rax
	test	BYTE PTR [rdi+52], 1
	je	$LN62@RunMacro
	movzx	eax, WORD PTR [rbx]
	dec	eax
	cmp	r8d, eax
	jne	$LN62@RunMacro

; 543  :                 if ( varargcnt == 0 )

	cmp	DWORD PTR varargcnt$1$[rbp], 0

; 544  :                     mi.parm_array[parmidx] = currparm;

	mov	r11, QWORD PTR currparm$1$[rbp]
	mov	rdx, QWORD PTR $T6890[rbp]
	jne	SHORT $LN61@RunMacro
	mov	rax, QWORD PTR mi$[rbp+24]
	mov	QWORD PTR [rax+rdx*8], r11
$LN61@RunMacro:

; 545  :                 DebugMsg1(("RunMacro(%s.%u[%u]): curr parameter value=>%s<\n", macro->sym.name, parmidx, varargcnt, currparm ));
; 546  :                 currparm = ( macro->sym.predefined ? GetAlignedPointer( currparm, ptr - currparm ) : ptr );

	movzx	ecx, BYTE PTR [rdi+48]
	shr	cl, 5
	and	cl, 1
	je	SHORT $LN167@RunMacro
	sub	r9, r11
	add	r9, 8
	and	r9, -8
	add	r11, r9
	jmp	SHORT $LN414@RunMacro
$LN167@RunMacro:
	mov	r11, r9
$LN414@RunMacro:

; 547  :                 /* v2.08: Masm swallows the last trailing comma */
; 548  :                 //if ( tokenarray[idx].token == T_COMMA ) {
; 549  :                 if ( tokenarray[idx].token == T_COMMA ) {

	movsxd	rax, esi
	mov	QWORD PTR currparm$1$[rbp], r11
	shl	rax, 5
	cmp	BYTE PTR [rax+r10], 44			; 0000002cH
	jne	SHORT $LN60@RunMacro

; 550  :                     idx++;

	inc	esi

; 551  :                     if ( macro->sym.isfunc == FALSE || tokenarray[idx].token != parm_end_delim ) {

	test	BYTE PTR [rdi+52], 2
	mov	DWORD PTR idx$[rbp], esi
	je	SHORT $LN58@RunMacro
	movsxd	rax, esi
	shl	rax, 5
	movzx	eax, BYTE PTR [rax+r10]
	cmp	eax, DWORD PTR parm_end_delim$1$[rbp]
	je	SHORT $LN59@RunMacro
$LN58@RunMacro:

; 552  :                         parmidx--;

	dec	rdx
	dec	r8d

; 553  :                         if ( !macro->sym.predefined ) {

	test	cl, cl
	mov	QWORD PTR $T6890[rbp], rdx
	jne	SHORT $LN57@RunMacro

; 554  :                             *currparm++ = ',';

	mov	BYTE PTR [r11], 44			; 0000002cH
	inc	r11
	mov	QWORD PTR currparm$1$[rbp], r11
$LN57@RunMacro:

; 555  :                         }
; 556  :                         *currparm = NULLC;

	mov	BYTE PTR [r11], 0
$LN59@RunMacro:

; 557  :                     }
; 558  :                     skipcomma = 0;

	xor	eax, eax
	mov	DWORD PTR skipcomma$1$[rbp], eax
$LN60@RunMacro:

; 559  :                 }
; 560  :                 varargcnt++;

	inc	DWORD PTR varargcnt$1$[rbp]
	mov	r9, QWORD PTR $T6890[rbp]
	jmp	SHORT $LN145@RunMacro
$LN62@RunMacro:

; 561  :             } else if ( *currparm ) {

	mov	r11, QWORD PTR currparm$1$[rbp]

; 562  :                 mi.parm_array[parmidx] = currparm;

	mov	rax, QWORD PTR mi$[rbp+24]
	cmp	BYTE PTR [r11], 0
	je	SHORT $LN55@RunMacro
	mov	rcx, QWORD PTR $T6890[rbp]

; 563  :                 DebugMsg1(("RunMacro(%s.%u): curr parameter value=>%s<\n", macro->sym.name, parmidx, currparm ));
; 564  :                 currparm = GetAlignedPointer( currparm, ptr - currparm );

	sub	r9, r11
	add	r9, 8
	mov	QWORD PTR [rax+rcx*8], r11
	and	r9, -8
	add	r11, r9

; 565  :             } else {

	mov	r9, rcx
	mov	QWORD PTR currparm$1$[rbp], r11
	jmp	SHORT $LN145@RunMacro
$LN55@RunMacro:

; 566  :                 mi.parm_array[parmidx] = "";

	mov	r9, QWORD PTR $T6890[rbp]
	lea	rcx, OFFSET FLAT:$SG5813
	jmp	SHORT $LN415@RunMacro
$LN140@RunMacro:

; 265  : 
; 266  :             /* it's a blank parm */
; 267  :             if( info->parmlist[parmidx].required ) {

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, r9
	add	rcx, rcx
	test	BYTE PTR [rax+rcx*8+8], 1
	jne	SHORT $LN340@RunMacro

; 274  :             }
; 275  :             if ( varargcnt == 0 ) {

	cmp	DWORD PTR varargcnt$1$[rbp], 0
	jne	SHORT $LN145@RunMacro

; 276  :                 mi.parm_array[parmidx] = info->parmlist[parmidx].deflt;

	mov	rcx, QWORD PTR [rax+rcx*8]
	mov	rax, QWORD PTR mi$[rbp+24]
$LN415@RunMacro:
	mov	QWORD PTR [rax+r9*8], rcx
$LN145@RunMacro:

; 250  : 
; 251  :     for( varargcnt = 0, skipcomma = 0; parmidx < info->parmcnt; parmidx++ ) {

	movzx	edx, WORD PTR [rbx]
	inc	r8d
	inc	r9
	cmp	r8d, edx
	mov	DWORD PTR parmidx$1$[rbp], r8d
	mov	QWORD PTR $T6890[rbp], r9
	jge	SHORT $LN404@RunMacro
	mov	ecx, DWORD PTR skipcomma$1$[rbp]
	jmp	$LL146@RunMacro
$LN337@RunMacro:

; 370  :                         StringBufferEnd = savedStringBuffer;

	mov	rax, QWORD PTR savedStringBuffer$1$[rbp]
	mov	QWORD PTR ModuleInfo+488, rax

; 371  :                         return(-1);

	mov	eax, -1
	jmp	$LN163@RunMacro
$LN339@RunMacro:

; 477  :                                     StringBufferEnd = savedStringBuffer;

	mov	rax, QWORD PTR savedStringBuffer$1$[rbp]
	mov	QWORD PTR ModuleInfo+488, rax

; 478  :                                     return( idx );

	jmp	$LN1@RunMacro
$LN340@RunMacro:

; 268  :                 DebugMsg1(( "RunMacro(%s.%u), parameter %u required >%s<\n", macro->sym.name, parmidx, parmidx, tokenarray[idx].tokpos ));
; 269  :                 if ( *macro->sym.name == NULLC )

	mov	rdx, QWORD PTR [rdi+8]
	cmp	BYTE PTR [rdx], 0
	jne	SHORT $LN138@RunMacro

; 270  :                     EmitErr( MISSING_MACRO_ARGUMENT_2, macro->sym.value + 1 );

	mov	edx, DWORD PTR [rdi+16]
	mov	ecx, 87					; 00000057H
	inc	edx
	call	EmitErr

; 273  :                 return( -1 );

	mov	eax, -1
	jmp	$LN163@RunMacro
$LN138@RunMacro:

; 271  :                 else
; 272  :                     EmitErr( MISSING_MACRO_ARGUMENT, macro->sym.name, parmidx + 1 );

	inc	r8d
	mov	ecx, 220				; 000000dcH
	call	EmitErr

; 273  :                 return( -1 );

	mov	eax, -1
	jmp	$LN163@RunMacro
$LN404@RunMacro:

; 198  :             parm_end_delim = T_CL_BRACKET;
; 199  :             bracket_level = 1;

	mov	ebx, DWORD PTR bracket_level$1$[rbp]
$LN374@RunMacro:

; 567  :                 DebugMsg1(("RunMacro(%s.%u): curr parameter value=><\n", macro->sym.name, parmidx ));
; 568  :             }
; 569  :         } /*end if */
; 570  :     } /* end for  */
; 571  : 
; 572  :     /* for macro functions, check for the terminating ')' */
; 573  :     if ( bracket_level >= 0 ) {

	test	ebx, ebx
	js	$LN53@RunMacro

; 574  :         if ( tokenarray[idx].token != T_CL_BRACKET ) {

	movsxd	rcx, esi
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+r10], 41			; 00000029H
	je	SHORT $LN47@RunMacro

; 575  :             for ( i = idx; idx < Token_Count && tokenarray[idx].token != T_CL_BRACKET; idx++ );

	cmp	esi, DWORD PTR ModuleInfo+496
	movsxd	rax, esi
	mov	DWORD PTR i$[rbp], eax
	jge	SHORT $LN416@RunMacro
	shl	rcx, 5
	add	rcx, r10
$LL51@RunMacro:
	cmp	BYTE PTR [rcx], 41			; 00000029H
	je	SHORT $LN49@RunMacro
	inc	esi
	add	rcx, 32					; 00000020H
	cmp	esi, DWORD PTR ModuleInfo+496
	jl	SHORT $LL51@RunMacro
$LN49@RunMacro:

; 576  :             if ( idx == Token_Count ) {

	cmp	esi, DWORD PTR ModuleInfo+496
$LN416@RunMacro:
	jne	SHORT $LN48@RunMacro

; 577  :                 DebugMsg1(("RunMacro(%s): missing ')'\n", macro->sym.name));
; 578  :                 EmitError( MISSING_RIGHT_PARENTHESIS );

	mov	ecx, 244				; 000000f4H
	call	EmitError

; 579  :                 return( -1 );

	mov	eax, -1
	jmp	$LN163@RunMacro
$LN48@RunMacro:

; 580  :             } else {
; 581  :                 DebugMsg1(("RunMacro(%s): expected ')', found >%s<\n", macro->sym.name, tokenarray[i].tokpos ));
; 582  :                 /* v2.09: changed to a warning only (Masm-compatible) */
; 583  :                 EmitWarn( 1, TOO_MANY_ARGUMENTS_IN_MACRO_CALL, macro->sym.name, tokenarray[i].tokpos );

	mov	r8, QWORD PTR [rdi+8]
	mov	r9, rax
	mov	edx, 149				; 00000095H
	shl	r9, 5
	mov	ecx, 1
	mov	r9, QWORD PTR [r9+r10+24]
	call	EmitWarn
$LN47@RunMacro:

; 584  :             }
; 585  :         }
; 586  :         idx++;

	inc	esi
	mov	DWORD PTR idx$[rbp], esi
$LN407@RunMacro:
	mov	ebx, DWORD PTR mflags$[rbp]
$LN44@RunMacro:

; 596  :         //return( -1 );
; 597  :     }
; 598  : 
; 599  :     /* a predefined macro func with a function address? */
; 600  : 
; 601  :     if ( macro->sym.predefined == TRUE && macro->sym.func_ptr != NULL ) {

	test	BYTE PTR [rdi+48], 32			; 00000020H
	je	SHORT $LN43@RunMacro
	mov	rax, QWORD PTR [rdi+16]
	test	rax, rax
	je	SHORT $LN43@RunMacro

; 602  :         mi.parmcnt = varargcnt;

	mov	ecx, DWORD PTR varargcnt$1$[rbp]

; 603  :         macro->sym.func_ptr( &mi, out, tokenarray );

	mov	r8, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR out$[rbp]
	mov	DWORD PTR mi$[rbp+40], ecx
	lea	rcx, QWORD PTR mi$[rbp]
	call	rax

; 604  :         *is_exitm = TRUE;

	mov	rax, QWORD PTR is_exitm$[rbp]
	mov	BYTE PTR [rax], 1

; 605  :         return( idx );

	jmp	$LN1@RunMacro
$LN53@RunMacro:

; 587  :     //} else if ( tokenarray[idx].token != T_FINAL && *macro->sym.name != NULLC ) { /* v2.08: changed */
; 588  :     } else if ( tokenarray[idx].token != T_FINAL ) {

	movsxd	r9, esi
	shl	r9, 5
	cmp	BYTE PTR [r9+r10], 0
	je	SHORT $LN407@RunMacro

; 589  :         DebugMsg1(("RunMacro(%s): expected T_FINAL, found >%s<, parmidx=%u\n", macro->sym.name, tokenarray[idx].tokpos, parmidx ));
; 590  :         /* v2.05: changed to a warning. That's what Masm does */
; 591  :         /* v2.09: don't emit a warning if it's a FOR directive
; 592  :          * (in this case, the caller knows better what to do ).
; 593  :          */
; 594  :         if ( !(mflags & MF_IGNARGS) )

	mov	ebx, DWORD PTR mflags$[rbp]
	test	bl, 4
	jne	SHORT $LN44@RunMacro

; 595  :             EmitWarn( 1, TOO_MANY_ARGUMENTS_IN_MACRO_CALL, macro->sym.name, tokenarray[idx].tokpos );

	mov	r9, QWORD PTR [r9+r10+24]
	mov	r8, QWORD PTR [rdi+8]
	mov	edx, 149				; 00000095H
	mov	ecx, 1
	call	EmitWarn
	jmp	SHORT $LN44@RunMacro
$LN43@RunMacro:

; 606  :     }
; 607  : 
; 608  : #if 0
; 609  :     /* check if a (code) label before the macro is to be written
; 610  :      * v2.08: this is the wrong place, because the label is written
; 611  :      * AFTER possible macro functions in the arguments are evaluated.
; 612  :      * Hence this functionality has been moved to ExpandToken().
; 613  :      */
; 614  :     addprefix = FALSE;
; 615  :     if ( macro->sym.isfunc == FALSE && 
; 616  : #if MACROLABEL
; 617  :         macro->sym.label == FALSE &&
; 618  : #endif
; 619  :         label >= 0 && start > label )
; 620  :         addprefix = TRUE;
; 621  : #endif
; 622  : 
; 623  :     mi.localstart = MacroLocals;

	mov	ecx, DWORD PTR MacroLocals

; 624  :     MacroLocals += info->localcnt; /* adjust global variable MacroLocals */

	mov	rdx, QWORD PTR info$1$[rbp]
	mov	DWORD PTR mi$[rbp+16], ecx
	movzx	eax, WORD PTR [rdx+2]
	add	ecx, eax

; 625  : 
; 626  :     /* avoid to use values stored in struct macro_info directly. A macro
; 627  :      * may be redefined within the macro! Hence copy all values that are
; 628  :      * needed later in the while loop to macro_instance!
; 629  :      */
; 630  :     mi.startline = info->data;
; 631  :     mi.currline = NULL;

	xor	eax, eax
	mov	DWORD PTR MacroLocals, ecx
	mov	rcx, QWORD PTR [rdx+16]
	mov	QWORD PTR mi$[rbp], rax

; 632  :     mi.parmcnt = info->parmcnt;
; 633  : 
; 634  :     /* v2.03: no processing if macro has no lines */
; 635  :     /* v2.08: addprefix is obsolete */
; 636  :     //if ( mi.currline || addprefix ) {
; 637  :     if ( mi.startline ) {

	test	rcx, rcx
	mov	QWORD PTR mi$[rbp+8], rcx
	movzx	eax, WORD PTR [rdx]
	mov	DWORD PTR mi$[rbp+40], eax
	je	$LN1@RunMacro

; 638  :         struct input_status oldstat;
; 639  :         int oldifnesting;
; 640  :         int cntgoto;
; 641  : 
; 642  :         DebugMsg1(("RunMacro(%s): enter assembly loop, macro level=%u\n", macro->sym.name, MacroLevel+1 ));
; 643  :         /* v2.04: this listing is too excessive */
; 644  :         //if ( ModuleInfo.list && ( ModuleInfo.list_macro == LM_LISTMACROALL || MacroLevel == 0 ) )
; 645  :         //if ( MacroLevel == 0 && macro->sym.isfunc == FALSE && *macro->sym.name )
; 646  :         if ( macro->sym.isfunc == FALSE && *macro->sym.name )

	test	BYTE PTR [rdi+52], 2
	jne	SHORT $LN41@RunMacro
	mov	rax, QWORD PTR [rdi+8]
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN41@RunMacro

; 647  :             LstWriteSrcLine();

	call	LstWriteSrcLine
$LN41@RunMacro:

; 648  :         if ( !( mflags & MF_NOSAVE ) )

	and	ebx, 2
	mov	DWORD PTR mflags$[rbp], ebx
	jne	SHORT $LN394@RunMacro

; 649  :             tokenarray = PushInputStatus( &oldstat );

	lea	rcx, QWORD PTR oldstat$5828[rbp]
	call	PushInputStatus
	mov	rbx, rax
	mov	QWORD PTR tokenarray$[rbp], rax
	jmp	SHORT $LN40@RunMacro
$LN394@RunMacro:

; 772  :                             continue;

	mov	rbx, QWORD PTR tokenarray$[rbp]
$LN40@RunMacro:

; 650  : 
; 651  :         /*
; 652  :          * move the macro instance onto the file stack!
; 653  :          * Also reset the current linenumber!
; 654  :          */
; 655  :         mi.macro = &macro->sym;
; 656  :         PushMacro( &mi );

	lea	rcx, QWORD PTR mi$[rbp]
	mov	QWORD PTR mi$[rbp+32], rdi
	call	PushMacro

; 657  :         MacroLevel++;

	inc	BYTE PTR MacroLevel

; 658  :         oldifnesting = GetIfNestLevel(); /* v2.10 */

	call	GetIfNestLevel
	mov	edi, eax
	mov	DWORD PTR oldifnesting$1$[rbp], eax

; 659  :         cntgoto = 0; /* v2.10 */

	xor	eax, eax
	mov	esi, eax
	mov	DWORD PTR cntgoto$1$[rbp], eax
$LN2@RunMacro:

; 660  :         /* Run the assembler until we hit EXITM or ENDM.
; 661  :          * Also handle GOTO and macro label lines!
; 662  :          * v2.08 no need anymore to check the queue level
; 663  :          * v2.11 GetPreprocessedLine() replaced by GetTextLine()
; 664  :          * and PreprocessLine().
; 665  :          */
; 666  : 
; 667  :         while ( GetTextLine( CurrSource ) ) {

	mov	rcx, QWORD PTR ModuleInfo+464
	call	GetTextLine
	test	rax, rax
	je	$LN293@RunMacro

; 668  :             if ( PreprocessLine( CurrSource, tokenarray ) == 0 )

	mov	rcx, QWORD PTR ModuleInfo+464
	mov	rdx, rbx
	call	PreprocessLine
	test	eax, eax
	je	SHORT $LN2@RunMacro

; 669  :                 continue;
; 670  :             /* skip macro label lines */
; 671  :             if ( tokenarray[0].token == T_COLON ) {

	movzx	eax, BYTE PTR [rbx]
	cmp	al, 58					; 0000003aH
	jne	SHORT $LN36@RunMacro

; 672  :                 /* v2.05: emit the error msg here, not in StoreMacro() */
; 673  :                 if ( tokenarray[1].token != T_ID )

	cmp	BYTE PTR [rbx+32], 8
	je	SHORT $LN35@RunMacro

; 674  :                     EmitErr( SYNTAX_ERROR_EX, tokenarray[0].tokpos );

	mov	rdx, QWORD PTR [rbx+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN2@RunMacro
$LN35@RunMacro:

; 675  :                 else if ( tokenarray[2].token != T_FINAL )

	cmp	BYTE PTR [rbx+64], 0
	je	SHORT $LN2@RunMacro

; 676  :                     EmitErr( SYNTAX_ERROR_EX, tokenarray[2].tokpos );

	mov	rdx, QWORD PTR [rbx+88]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 677  :                 continue;

	jmp	SHORT $LN2@RunMacro
$LN36@RunMacro:

; 678  :             }
; 679  : 
; 680  :             if ( tokenarray[0].token == T_DIRECTIVE ) {

	cmp	al, 3
	jne	$LN15@RunMacro

; 681  :                 if ( tokenarray[0].tokval == T_EXITM ) {

	mov	eax, DWORD PTR [rbx+16]
	cmp	eax, 398				; 0000018eH
	je	$LN342@RunMacro

; 730  :                     break;
; 731  : #if 0 /* won't happen anymore */
; 732  :                 } else if ( tokenarray[0].tokval == T_ENDM ) {
; 733  :                     DebugMsg1(("RunMacro(%s): ENDM\n", macro->sym.name ));
; 734  :                     break;
; 735  : #endif
; 736  :                 } else if ( tokenarray[0].tokval == T_GOTO ) {

	cmp	eax, 400				; 00000190H
	jne	$LN15@RunMacro

; 737  :                     if ( tokenarray[1].token != T_FINAL ) {

	cmp	BYTE PTR [rbx+32], 0
	je	$LN14@RunMacro

; 738  :                         int len = strlen( tokenarray[1].string_ptr );

	mov	rdi, QWORD PTR [rbx+40]

; 739  :                         DebugMsg1(("RunMacro(%s): GOTO %s, MacroLevel=%u\n", macro->sym.name, tokenarray[1].string_ptr, MacroLevel ));
; 740  :                         /* search for the destination line */
; 741  :                         for( i = 1, lnode = mi.startline; lnode != NULL; lnode = lnode->next, i++ ) {

	mov	rbx, QWORD PTR mi$[rbp+8]
	xor	eax, eax
	mov	rcx, -1
	repne scasb
	mov	eax, 1
	not	rcx
	dec	rcx
	movsxd	rsi, ecx
$LN418@RunMacro:
	test	rbx, rbx
	mov	DWORD PTR i$[rbp], eax
	je	$LN343@RunMacro

; 742  :                             ptr = lnode->line;
; 743  :                             //DebugMsg(("RunMacro(%s): GOTO, scan line >%s< for label >%s<\n", macro->sym.name, ptr, line));
; 744  :                             if ( *ptr == ':' ) {

	cmp	BYTE PTR [rbx+9], 58			; 0000003aH
	lea	rdi, QWORD PTR [rbx+9]
	jne	$LN12@RunMacro

; 745  :                                 if ( lnode->ph_count ) {

	cmp	BYTE PTR [rbx+8], 0
	je	SHORT $LN9@RunMacro

; 746  :                                     fill_placeholders( StringBufferEnd, lnode->line, mi.parmcnt, mi.localstart, mi.parm_array );

	mov	rax, QWORD PTR mi$[rbp+24]
	mov	r9d, DWORD PTR mi$[rbp+16]
	mov	r8d, DWORD PTR mi$[rbp+40]
	mov	rcx, QWORD PTR ModuleInfo+488
	mov	rdx, rdi
	mov	QWORD PTR [rsp+32], rax
	call	fill_placeholders

; 747  :                                     ptr = StringBufferEnd;

	mov	rdi, QWORD PTR ModuleInfo+488
$LN9@RunMacro:

; 748  :                                 }
; 749  :                                 ptr++;
; 750  :                                 while( isspace( *ptr )) ptr++;

	movsx	ecx, BYTE PTR [rdi+1]
	inc	rdi
	call	isspace
	test	eax, eax
	je	SHORT $LN7@RunMacro
$LL8@RunMacro:
	movsx	ecx, BYTE PTR [rdi+1]
	inc	rdi
	call	isspace
	test	eax, eax
	jne	SHORT $LL8@RunMacro
$LN7@RunMacro:

; 751  :                                 DebugMsg1(("RunMacro(%s): GOTO, line=>%s<\n", macro->sym.name, ptr ));
; 752  :                                 /* macro labels are always case-insensitive! */
; 753  :                                 //if ( ( SymCmpFunc( ptr, tokenarray[1].string_ptr, len ) == 0 ) &&
; 754  :                                 if ( ( _memicmp( ptr, tokenarray[1].string_ptr, len ) == 0 ) &&
; 755  :                                     ( is_valid_id_char(*(ptr+len) ) == FALSE ) ) {

	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	r8, rsi
	mov	rcx, rdi
	mov	rdx, QWORD PTR [rax+40]
	call	_memicmp
	test	eax, eax
	jne	SHORT $LN375@RunMacro
	movsx	ecx, BYTE PTR [rsi+rdi]
	call	isalnum
	test	eax, eax
	jne	SHORT $LN375@RunMacro
	movzx	eax, BYTE PTR [rsi+rdi]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN375@RunMacro
	cmp	al, 64					; 00000040H
	je	SHORT $LN375@RunMacro
	cmp	al, 36					; 00000024H
	je	SHORT $LN375@RunMacro
	cmp	al, 63					; 0000003fH
	jne	SHORT $LN367@RunMacro
$LN375@RunMacro:
	mov	eax, DWORD PTR i$[rbp]
$LN12@RunMacro:

; 739  :                         DebugMsg1(("RunMacro(%s): GOTO %s, MacroLevel=%u\n", macro->sym.name, tokenarray[1].string_ptr, MacroLevel ));
; 740  :                         /* search for the destination line */
; 741  :                         for( i = 1, lnode = mi.startline; lnode != NULL; lnode = lnode->next, i++ ) {

	mov	rbx, QWORD PTR [rbx]
	inc	eax
	jmp	$LN418@RunMacro
$LN367@RunMacro:

; 765  :                         } else {
; 766  :                             DebugMsg1(("RunMacro(%s): GOTO, found label >%s<\n", macro->sym.name, ptr));
; 767  :                             /* v2.10: rewritten, "if"-nesting-level handling added */
; 768  :                             mi.currline = lnode;
; 769  :                             SetLineNumber( i );

	mov	ecx, DWORD PTR i$[rbp]
	mov	QWORD PTR mi$[rbp], rbx
	call	SetLineNumber

; 770  :                             SetIfNestLevel( oldifnesting );

	mov	edi, DWORD PTR oldifnesting$1$[rbp]
	mov	ecx, edi
	call	SetIfNestLevel

; 771  :                             cntgoto++;

	mov	esi, DWORD PTR cntgoto$1$[rbp]

; 772  :                             continue;

	mov	rbx, QWORD PTR tokenarray$[rbp]
	inc	esi
	mov	DWORD PTR cntgoto$1$[rbp], esi
	jmp	$LN2@RunMacro
$LN15@RunMacro:

; 778  :                     break;
; 779  :                 }
; 780  :             }
; 781  :             ParseLine( tokenarray );

	mov	rcx, rbx
	call	ParseLine

; 782  :             if ( Options.preprocessor_stdout == TRUE )

	cmp	BYTE PTR Options+134, 1
	jne	$LN2@RunMacro

; 783  :                 WritePreprocessedLine( CurrSource );

	mov	rcx, QWORD PTR ModuleInfo+464
	call	WritePreprocessedLine
	jmp	$LN2@RunMacro
$LN342@RunMacro:

; 682  :                     if ( ModuleInfo.list && ModuleInfo.list_macro == LM_LISTMACROALL )

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN30@RunMacro
	cmp	DWORD PTR ModuleInfo+400, 2
	jne	SHORT $LN30@RunMacro

; 683  :                         LstWriteSrcLine();

	call	LstWriteSrcLine
$LN30@RunMacro:

; 684  :                     if ( tokenarray[1].token != T_FINAL ) {

	movzx	eax, BYTE PTR [rbx+32]
	lea	rcx, QWORD PTR [rbx+32]
	test	al, al
	je	$LN20@RunMacro

; 685  :                         /* v2.05: display error if there's more than 1 argument or
; 686  :                          * the argument isn't a text item
; 687  :                          */
; 688  :                         if ( tokenarray[1].token != T_STRING || tokenarray[1].string_delim != '<' )

	cmp	al, 9
	jne	$LN27@RunMacro
	cmp	BYTE PTR [rbx+33], 60			; 0000003cH
	jne	$LN27@RunMacro

; 690  :                         else if ( Token_Count > 2 )

	cmp	DWORD PTR ModuleInfo+496, 2
	jle	SHORT $LN25@RunMacro

; 691  :                             EmitErr( SYNTAX_ERROR_EX, tokenarray[2].tokpos );

	mov	rdx, QWORD PTR [rbx+88]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN20@RunMacro
$LN25@RunMacro:

; 692  :                         else if ( out ) { /* return value buffer may be NULL ( loop directives ) */

	mov	r9, QWORD PTR out$[rbp]
	test	r9, r9
	je	$LN20@RunMacro

; 693  : 
; 694  :                             /* v2.08a: the <>-literal behind EXITM is handled specifically,
; 695  :                              * macro operator '!' within the literal is only handled
; 696  :                              * if it contains a placeholder (macro argument, macro local ).
; 697  :                              *
; 698  :                              * v2.09: handle '!' inside literal if ANY expansion occurred.
; 699  :                              * To determine text macro or macro function expansion,
; 700  :                              * check if there's a literal in the original line.
; 701  :                              */
; 702  :                             if ( mi.currline->ph_count || *(mi.currline->line+(tokenarray[1].tokpos-CurrSource)) != '<' ) {

	mov	rcx, QWORD PTR mi$[rbp]
	cmp	BYTE PTR [rcx+8], 0
	jne	SHORT $LN21@RunMacro
	sub	rcx, QWORD PTR ModuleInfo+464
	mov	rax, QWORD PTR [rbx+56]
	cmp	BYTE PTR [rcx+rax+9], 60		; 0000003cH
	jne	SHORT $LN21@RunMacro

; 705  :                                 /* since the string_ptr member has the !-operator stripped, it
; 706  :                                  * cannot be used. To get the original value of the literal,
; 707  :                                  * use tokpos.
; 708  :                                  */
; 709  :                                 int len;
; 710  :                                 len = tokenarray[2].tokpos - (tokenarray[1].tokpos+1);

	mov	edi, DWORD PTR [rbx+88]

; 711  :                                 memcpy( out, tokenarray[1].tokpos+1, len );

	mov	rcx, r9
	sub	edi, eax
	mov	rax, QWORD PTR tokenarray$[rbp]
	mov	rdx, QWORD PTR [rax+56]
	dec	edi
	movsxd	rbx, edi
	inc	rdx
	mov	r8, rbx
	call	memcpy

; 712  :                                 while( *(out+len-1) != '>' ) len--;

	mov	rcx, QWORD PTR out$[rbp]
	cmp	BYTE PTR [rbx+rcx-1], 62		; 0000003eH
	je	SHORT $LN18@RunMacro

; 705  :                                 /* since the string_ptr member has the !-operator stripped, it
; 706  :                                  * cannot be used. To get the original value of the literal,
; 707  :                                  * use tokpos.
; 708  :                                  */
; 709  :                                 int len;
; 710  :                                 len = tokenarray[2].tokpos - (tokenarray[1].tokpos+1);

	lea	rax, QWORD PTR [rbx+rcx-1]
	npad	8
$LL19@RunMacro:

; 712  :                                 while( *(out+len-1) != '>' ) len--;

	dec	rax
	dec	edi
	cmp	BYTE PTR [rax], 62			; 0000003eH
	jne	SHORT $LL19@RunMacro
$LN18@RunMacro:

; 713  :                                 *(out+len-1) = NULLC;

	mov	rbx, QWORD PTR tokenarray$[rbp]
	movsxd	rax, edi
	mov	edi, DWORD PTR oldifnesting$1$[rbp]
	mov	BYTE PTR [rax+rcx-1], 0
	jmp	SHORT $LN20@RunMacro
$LN21@RunMacro:

; 703  :                                 memcpy( out, tokenarray[1].string_ptr, tokenarray[1].stringlen + 1 );

	mov	r8d, DWORD PTR [rbx+48]
	mov	rdx, QWORD PTR [rbx+40]
	mov	rcx, r9
	inc	r8d
	call	memcpy

; 704  :                             } else {

	jmp	SHORT $LN20@RunMacro
$LN27@RunMacro:

; 689  :                             TextItemError( &tokenarray[1] );

	call	TextItemError
$LN20@RunMacro:

; 714  :                             }
; 715  :                         }
; 716  :                     }
; 717  :                     DebugMsg1(("RunMacro(%s): EXITM, result=>%s<\n", macro->sym.name, out ? out : "NULL" ));
; 718  : 
; 719  :                     /* v2.10: if a goto had occured, rescan the full macro to ensure that
; 720  :                      * the "if"-nesting level is ok.
; 721  :                      */
; 722  :                     if ( cntgoto ) {

	test	esi, esi
	je	SHORT $LN328@RunMacro

; 723  :                         mi.currline = NULL;

	xor	eax, eax

; 724  :                         SetLineNumber( 0 );

	xor	ecx, ecx
	mov	QWORD PTR mi$[rbp], rax
	call	SetLineNumber

; 725  :                         SetIfNestLevel( oldifnesting );

	mov	ecx, edi
	call	SetIfNestLevel
$LN328@RunMacro:

; 726  :                     }
; 727  : 
; 728  :                     SkipMacro( tokenarray );

	lea	rcx, QWORD PTR buffer$6702[rbp]
	call	GetTextLine
	test	rax, rax
	je	SHORT $LN289@RunMacro
	npad	12
$LL290@RunMacro:
	lea	rcx, QWORD PTR buffer$6702[rbp]
	xor	r9d, r9d
	mov	r8, rbx
	xor	edx, edx
	call	Tokenize
	lea	rcx, QWORD PTR buffer$6702[rbp]
	call	GetTextLine
	test	rax, rax
	jne	SHORT $LL290@RunMacro
$LN289@RunMacro:

; 729  :                     *is_exitm = TRUE;

	mov	rax, QWORD PTR is_exitm$[rbp]
	mov	BYTE PTR [rax], 1
	jmp	SHORT $LN293@RunMacro
$LN343@RunMacro:

; 762  :                             /* v2.05: display error msg BEFORE SkipMacro()! */
; 763  :                             DebugMsg1(("RunMacro(%s): GOTO, label >%s< not found!\n", macro->sym.name, tokenarray[1].string_ptr ));
; 764  :                             EmitErr( MACRO_LABEL_NOT_DEFINED, tokenarray[1].string_ptr );

	mov	rbx, QWORD PTR tokenarray$[rbp]
	mov	ecx, 265				; 00000109H
	mov	rdx, QWORD PTR [rbx+40]

; 773  :                         }
; 774  :                     } else {

	jmp	SHORT $LN420@RunMacro
$LN14@RunMacro:

; 775  :                         EmitErr( SYNTAX_ERROR_EX, tokenarray->tokpos );

	mov	rdx, QWORD PTR [rbx+24]
	mov	ecx, 209				; 000000d1H
$LN420@RunMacro:
	call	EmitErr

; 776  :                     }
; 777  :                     SkipMacro( tokenarray );

	lea	rcx, QWORD PTR buffer$6708[rbp]
	call	GetTextLine
	test	rax, rax
	je	SHORT $LN293@RunMacro
	npad	14
$LL294@RunMacro:
	lea	rcx, QWORD PTR buffer$6708[rbp]
	xor	r9d, r9d
	mov	r8, rbx
	xor	edx, edx
	call	Tokenize
	lea	rcx, QWORD PTR buffer$6708[rbp]
	call	GetTextLine
	test	rax, rax
	jne	SHORT $LL294@RunMacro
$LN293@RunMacro:

; 784  : 
; 785  :             /* the macro might contain an END directive.
; 786  :              * v2.08: this doesn't mean the macro is to be cancelled.
; 787  :              * Masm continues to run it and the assembly is stopped
; 788  :              * when the top source level is reached again.
; 789  :              */
; 790  :             //if ( ModuleInfo.EndDirFound ) {
; 791  :             //    SkipMacro( tokenarray );
; 792  :             //    *is_exitm = TRUE; /* force loop exit */
; 793  :             //    break;
; 794  :             //}
; 795  :         } /* end while */
; 796  : 
; 797  :         MacroLevel--;

	add	BYTE PTR MacroLevel, 255		; 000000ffH

; 798  :         if ( !(mflags & MF_NOSAVE ) )

	cmp	DWORD PTR mflags$[rbp], 0
	jne	SHORT $LN379@RunMacro

; 799  :             PopInputStatus( &oldstat );

	lea	rcx, QWORD PTR oldstat$5828[rbp]
	call	PopInputStatus
$LN379@RunMacro:

; 584  :             }
; 585  :         }
; 586  :         idx++;

	mov	esi, DWORD PTR idx$[rbp]
$LN1@RunMacro:

; 800  : 
; 801  :         /* don't use tokenarray from here on, it's invalid after PopInputStatus() */
; 802  : 
; 803  : #if FASTMEM==0
; 804  :         /* v2.06: free "old" macro line data if macro has been changed
; 805  :          * and isn't in use anymore */
; 806  :         if ( mi.startline != info->data && ( !MacroInUse( macro ) ) ) {
; 807  :             struct srcline  *curr;
; 808  :             struct srcline  *next;
; 809  :             DebugMsg1(("RunMacro(%s): macro has been changed, releasing old lines\n", macro->sym.name ));
; 810  :             for( curr = mi.startline ; curr; curr = next ) {
; 811  :                 next = curr->next;
; 812  :                 LclFree( curr );
; 813  :             }
; 814  :         }
; 815  : #endif
; 816  :     } /* end if */
; 817  : 
; 818  :     DebugMsg1(("RunMacro(%s) exit, MacroLevel=%u\n", macro->sym.name, MacroLevel ));
; 819  : 
; 820  :     return( idx );

	mov	eax, esi
$LN163@RunMacro:

; 821  : }

	mov	rbx, QWORD PTR [rbp+1576]
	mov	rsi, QWORD PTR [rbp+1568]
	mov	rdi, QWORD PTR [rbp+1560]
	lea	rsp, QWORD PTR [rbp+1584]
	pop	rbp
	ret	0
RunMacro ENDP
_TEXT	ENDS
EXTRN	WriteCodeLabel:NEAR
EXTRN	SymFindDeclare:NEAR
EXTRN	_stricmp:NEAR
xdata	SEGMENT
$unwind$ExpandToken DD 0124601H
	DD	09df446H
	DD	09ee43cH
	DD	09fd433H
	DD	0a0c42fH
	DD	0a1742bH
	DD	0a26427H
	DD	0a35423H
	DD	0a4341dH
	DD	0a50119H
xdata	ENDS
pdata	SEGMENT
$pdata$ExpandToken DD @imagerel(ExpandToken#)
	DD	@imagerel(ExpandToken#+1957)
	DD	@imagerel($unwind$ExpandToken#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
evaluate$1$ = 48
i$3$ = 52
tmp$ = 56
tv879 = 60
is_exitm$ = 64
tmpbuf$6943 = 72
opndx$ = 112
buffer$ = 224
line$ = 1328
pi$ = 1336
tokenarray$ = 1344
pos$ = 1352
max$ = 1352
bracket_flags$ = 1360
equmode$ = 1368
ExpandToken PROC NEAR

; 1131 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, rsp
	sub	rsp, 1320				; 00000528H
	mov	QWORD PTR [rax-8], rbx

; 1132 :     int pos;
; 1133 :     int tmp;
; 1134 :     int i = *pi;

	mov	ebx, DWORD PTR [rdx]
	mov	QWORD PTR [rax-16], rbp
	mov	QWORD PTR [rax-24], rsi
	mov	QWORD PTR [rax-32], rdi
	mov	QWORD PTR [rax-40], r12
	mov	QWORD PTR [rax-48], r13

; 1135 :     int size;
; 1136 :     int addbrackets = bracket_flags;
; 1137 :     char evaluate = FALSE;
; 1138 :     //char *p;
; 1139 :     bool is_exitm;
; 1140 :     struct expr opndx;
; 1141 :     struct asym *sym;
; 1142 :     ret_code rc = NOT_ERROR;

	xor	r12d, r12d
	xor	dl, dl
	mov	QWORD PTR [rax-56], r14

; 1143 :     char buffer[MAX_LINE_LEN];
; 1144 : 	char inLocal = FALSE;

	xor	bpl, bpl

; 1145 : 
; 1146 :     for ( ; i < max && tokenarray[i].token != T_COMMA; i++ ) {

	cmp	ebx, r9d
	mov	QWORD PTR [rax-64], r15
	mov	r15d, DWORD PTR bracket_flags$[rsp]
	mov	rsi, r8
	mov	r14d, r12d
	mov	r13, rcx
	mov	BYTE PTR evaluate$1$[rsp], dl
	jge	$LN86@ExpandToke
	mov	r11d, DWORD PTR pos$[rsp]
	mov	DWORD PTR i$3$[rsp], r11d
	npad	2
$LL43@ExpandToke:
	movsxd	r13, ebx
	mov	rdi, r13
	shl	rdi, 5
	cmp	BYTE PTR [rdi+rsi], 44			; 0000002cH
	je	$LN94@ExpandToke

; 1147 :     
; 1148 : 		if (strcasecmp(tokenarray[i].string_ptr, "LOCAL") == 0)

	mov	rcx, QWORD PTR [rdi+rsi+8]
	lea	rdx, OFFSET FLAT:$SG6079
	call	_stricmp
	movzx	ebp, bpl
	test	eax, eax
	mov	eax, 1
	cmove	ebp, eax

; 1149 : 		{
; 1150 : 			inLocal = TRUE;
; 1151 : 		}
; 1152 : 		/* v2.05: the '%' should only be handled as an operator if addbrackets==TRUE,
; 1153 :          * which means that the current directive is a preprocessor directive and the
; 1154 :          * expected argument is a literal (or text macro).
; 1155 :          */
; 1156 :         if ( tokenarray[i].token == T_PERCENT && addbrackets && evaluate == FALSE ) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	al, 37					; 00000025H
	mov	DWORD PTR tv879[rsp], ebp
	jne	SHORT $LN39@ExpandToke
	test	r15d, r15d
	je	SHORT $LN39@ExpandToke
	cmp	BYTE PTR evaluate$1$[rsp], r12b
	jne	SHORT $LN39@ExpandToke

; 1157 :             evaluate = TRUE;
; 1158 :             addbrackets = FALSE;
; 1159 :             equmode = FALSE;
; 1160 :             pos = i;
; 1161 :             DebugMsg1(("ExpandToken: %% found, line=%s\n", tokenarray[i].tokpos ));
; 1162 :             continue;

	mov	r13, QWORD PTR line$[rsp]
	mov	dl, 1
	mov	r15d, r12d
	mov	DWORD PTR equmode$[rsp], r12d
	mov	ecx, ebx
	mov	DWORD PTR i$3$[rsp], ebx
	mov	BYTE PTR evaluate$1$[rsp], dl
	jmp	$LN42@ExpandToke
$LN39@ExpandToke:

; 1163 :         }
; 1164 :         if( tokenarray[i].token == T_ID ) {

	cmp	al, 8
	jne	$LN95@ExpandToke

; 1165 : 			if(inLocal == TRUE)

	cmp	bpl, 1
	jne	SHORT $LN37@ExpandToke

; 1166 : 				sym = SymFindDeclare(tokenarray[i].string_ptr);

	mov	rcx, QWORD PTR [rdi+rsi+8]
	call	SymFindDeclare
	mov	rbp, rax

; 1167 : 			else

	jmp	SHORT $LN36@ExpandToke
$LN37@ExpandToke:

; 1168 : 				sym = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rdi+rsi+8]
	call	SymFind
	mov	rbp, rax
$LN36@ExpandToke:

; 1169 :             DebugMsg1(("ExpandToken: testing id >%s< equmode=%u\n", tokenarray[i].string_ptr, equmode ));
; 1170 :             /* don't check isdefined flag (which cannot occur in pass one, and this code usually runs
; 1171 :              * in pass one only!
; 1172 :              */
; 1173 :             //if( sym && sym->isdefined ) {
; 1174 :             if( sym ) {

	test	rbp, rbp
	je	$LN91@ExpandToke

; 1175 :                 if ( sym->state == SYM_MACRO ) {

	mov	eax, DWORD PTR [rbp+40]
	cmp	eax, 9
	jne	$LN34@ExpandToke

; 1176 :                     tmp = i; /* save index of macro name */

	mov	DWORD PTR tmp$[rsp], ebx

; 1177 :                     if ( sym->isfunc == TRUE ) {

	movzx	eax, BYTE PTR [rbp+52]
	test	al, 2
	je	$LN33@ExpandToke

; 1178 :                         /* ignore macro functions without a following '(' */
; 1179 :                         if ( tokenarray[i+1].token != T_OP_BRACKET ) {

	lea	rax, QWORD PTR [r13+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 40			; 00000028H
	jne	$LN93@ExpandToke

; 1180 :                             DebugMsg1(("ExpandToken(%s): macro function without () - not expanded!\n", sym->name ));
; 1181 :                             continue;
; 1182 :                         }
; 1183 :                         i++;
; 1184 :                         if ( equmode == TRUE ) {

	mov	edi, DWORD PTR equmode$[rsp]
	cmp	edi, 1
	jne	SHORT $LN31@ExpandToke

; 1185 :                             i++; /* skip '(' */
; 1186 :                             /* go beyond the ')' */
; 1187 :                             for ( tmp = 1; i < max; i++ ) {

	movsxd	rcx, DWORD PTR max$[rsp]
	add	ebx, 2
	mov	eax, edi
	cmp	ebx, ecx
	mov	DWORD PTR tmp$[rsp], edi
	movsxd	rdx, ebx
	jge	SHORT $LN89@ExpandToke
	mov	r8, rcx
	mov	rcx, rdx
	shl	rcx, 5
	add	rcx, rsi
$LL30@ExpandToke:

; 1188 :                                 if ( tokenarray[i].token == T_OP_BRACKET )

	movzx	edi, BYTE PTR [rcx]
	cmp	dil, 40					; 00000028H
	jne	SHORT $LN27@ExpandToke

; 1189 :                                     tmp++;

	inc	eax
	mov	DWORD PTR tmp$[rsp], eax
	jmp	SHORT $LN29@ExpandToke
$LN27@ExpandToke:

; 1190 :                                 else if ( tokenarray[i].token == T_CL_BRACKET ) {

	cmp	dil, 41					; 00000029H
	jne	SHORT $LN29@ExpandToke

; 1191 :                                     tmp--;

	dec	eax
	mov	DWORD PTR tmp$[rsp], eax

; 1192 :                                     if ( tmp == 0 )

	je	SHORT $LN89@ExpandToke
$LN29@ExpandToke:

; 1185 :                             i++; /* skip '(' */
; 1186 :                             /* go beyond the ')' */
; 1187 :                             for ( tmp = 1; i < max; i++ ) {

	inc	rdx
	inc	ebx
	add	rcx, 32					; 00000020H
	cmp	rdx, r8
	jl	SHORT $LL30@ExpandToke
$LN89@ExpandToke:

; 1193 :                                         break;
; 1194 :                                 }
; 1195 :                             }
; 1196 :                             i--;
; 1197 :                             continue;

	mov	ebp, DWORD PTR tv879[rsp]
	mov	ecx, DWORD PTR i$3$[rsp]
	movzx	edx, BYTE PTR evaluate$1$[rsp]
	mov	r13, QWORD PTR line$[rsp]
	dec	ebx
	jmp	$LN42@ExpandToke
$LN31@ExpandToke:

; 1198 :                         }
; 1199 :                         //DebugMsg1(("ExpandToken: macro function %s to be expanded\n", sym->name ));
; 1200 :                         i = RunMacro( (struct dsym *)sym, i, tokenarray, buffer,
; 1201 : #if MACROLABEL
; 1202 :                                      (tmp == 1 ? MF_LABEL : 0),
; 1203 : #else
; 1204 :                                      0,
; 1205 : #endif
; 1206 :                                      &is_exitm );

	mov	eax, r12d
	lea	rcx, QWORD PTR is_exitm$[rsp]
	cmp	ebx, 1
	mov	QWORD PTR [rsp+40], rcx
	sete	al
	lea	r9, QWORD PTR buffer$[rsp]
	lea	edx, DWORD PTR [rbx+1]
	mov	rcx, rbp
	mov	r8, rsi
	mov	DWORD PTR [rsp+32], eax
	call	RunMacro
	movsxd	r13, eax

; 1207 :                         if ( i == -1 )

	cmp	r13d, -1
	je	$LN79@ExpandToke

; 1208 :                             return( ERROR );
; 1209 :                         DebugMsg1(("ExpandToken(%s, addbr=%u): macro function expanded to >%s<\n", sym->name, addbrackets, buffer));
; 1210 :                         /* expand text, but don't if macro was at position 0 (might be a text macro definition directive */
; 1211 :                         /* v2.09: don't expand further if addbrackets is set */
; 1212 :                         if ( tmp && (!addbrackets) && ( ERROR == ExpandTMacro( buffer, tokenarray, equmode, 0 ) ) )

	mov	ebp, DWORD PTR tmp$[rsp]
	test	ebp, ebp
	je	SHORT $LN22@ExpandToke
	test	r15d, r15d
	jne	SHORT $LN22@ExpandToke
	lea	rcx, QWORD PTR buffer$[rsp]
	xor	r9d, r9d
	mov	r8d, edi
	mov	rdx, rsi
	call	ExpandTMacro
	cmp	eax, -1
	je	$LN79@ExpandToke
	mov	ebp, DWORD PTR tmp$[rsp]
$LN22@ExpandToke:

; 1213 :                             return( ERROR );
; 1214 :                         /* get size of string to replace ( must be done before AddTokens() */
; 1215 :                         size = ( tokenarray[i-1].tokpos + 1) - tokenarray[tmp].tokpos;
; 1216 :                         AddTokens( tokenarray, tmp+1, tmp+1 - i, Token_Count );

	mov	r9d, DWORD PTR ModuleInfo+496
	mov	r8d, ebp
	mov	rax, r13
	shl	rax, 5
	sub	r8d, r13d
	movsxd	rbx, ebp
	mov	edi, DWORD PTR [rax+rsi-8]
	lea	edx, DWORD PTR [rbp+1]
	shl	rbx, 5
	sub	edi, DWORD PTR [rbx+rsi+24]
	inc	r8d
	mov	rcx, rsi
	call	AddTokens

; 1217 :                         Token_Count += (tmp+1) - i;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	ecx, ebp
	sub	ecx, r13d

; 1218 :                         if ( Token_Count < max ) /* take care not to read beyond T_FINAL */
; 1219 :                             max = Token_Count;
; 1220 :                         if ( ERROR == RebuildLine( buffer, tmp, tokenarray,
; 1221 :                                                   size, tokenarray[tmp].tokpos - line, addbrackets ) )

	mov	r13, QWORD PTR line$[rsp]
	lea	r9d, DWORD PTR [rdi+1]
	lea	ecx, DWORD PTR [rax+rcx+1]
	mov	eax, DWORD PTR max$[rsp]
	mov	r8, rsi
	cmp	ecx, eax
	mov	DWORD PTR ModuleInfo+496, ecx
	mov	edx, ebp
	cmovl	eax, ecx
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	DWORD PTR [rsp+40], r15d
	mov	DWORD PTR max$[rsp], eax
	mov	eax, DWORD PTR [rbx+rsi+24]
	sub	eax, r13d
	mov	DWORD PTR [rsp+32], eax
	call	RebuildLine
	cmp	eax, -1
	je	$LN79@ExpandToke

; 1222 :                             return( ERROR );
; 1223 :                         rc = STRING_EXPANDED;
; 1224 :                         i = tmp;

	mov	ebx, DWORD PTR tmp$[rsp]

; 1278 :                         break;
; 1279 :                     }

	mov	ebp, DWORD PTR tv879[rsp]
	mov	ecx, DWORD PTR i$3$[rsp]
	mov	dl, BYTE PTR evaluate$1$[rsp]
	mov	r14d, 1
	jmp	$LN42@ExpandToke
$LN33@ExpandToke:

; 1225 :                     } else {
; 1226 :                         /* a macro proc is expanded at pos 0 or pos 2
; 1227 :                          * (or at pos 1 if sym->label is on)
; 1228 :                          */
; 1229 :                         if ( i == 0 ||
; 1230 :                             ( i == 2 && ( tokenarray[1].token == T_COLON ||
; 1231 :                                          tokenarray[1].token == T_DBL_COLON ))
; 1232 : #if MACROLABEL
; 1233 :                             || ( i == 1 && sym->label )
; 1234 : #endif
; 1235 :                            )

	test	ebx, ebx
	je	$LN13@ExpandToke
	cmp	ebx, 2
	jne	SHORT $LN16@ExpandToke
	movzx	eax, BYTE PTR [rsi+32]
	cmp	al, 58					; 0000003aH
	je	$LN85@ExpandToke
	cmp	al, 13
	je	$LN85@ExpandToke
	mov	ebp, DWORD PTR tv879[rsp]
	mov	ecx, DWORD PTR i$3$[rsp]
	mov	dl, BYTE PTR evaluate$1$[rsp]
	mov	r13, QWORD PTR line$[rsp]
	jmp	$LN42@ExpandToke
$LN16@ExpandToke:
	cmp	ebx, 1
	jne	$LN90@ExpandToke
	test	al, 4
	jne	$LN13@ExpandToke

; 1236 :                             ;
; 1237 :                         else {
; 1238 :                             DebugMsg1(("ExpandToken(%s): macro proc at pos %u NOT expanded\n", sym->name, i ));
; 1239 : #if 1 /* v2.03: no error, just don't expand! */
; 1240 :                             continue;

	mov	ebp, DWORD PTR tv879[rsp]
	mov	ecx, DWORD PTR i$3$[rsp]
	mov	dl, BYTE PTR evaluate$1$[rsp]
	mov	r13, QWORD PTR line$[rsp]
	jmp	$LN42@ExpandToke
$LN34@ExpandToke:

; 1280 :                 } else if( sym->state == SYM_TMACRO ) {

	cmp	eax, 10
	jne	$LN92@ExpandToke

; 1281 : 
; 1282 :                     //GetLiteralValue( buffer, sym->string_ptr );
; 1283 :                     strcpy( buffer, sym->string_ptr );

	mov	rcx, QWORD PTR [rbp+16]
	lea	rdx, QWORD PTR buffer$[rsp]
	npad	8
$LL46@ExpandToke:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL46@ExpandToke

; 1284 :                     if ( ERROR == ExpandTMacro( buffer, tokenarray, equmode, 0 ) )

	mov	r8d, DWORD PTR equmode$[rsp]
	lea	rcx, QWORD PTR buffer$[rsp]
	xor	r9d, r9d
	mov	rdx, rsi
	call	ExpandTMacro
	cmp	eax, -1
	je	$LN79@ExpandToke

; 1285 :                         return( ERROR );
; 1286 :                     DebugMsg1(("ExpandToken(%s, addbr=%u): value >%s< expanded to >%s<\n", sym->name, addbrackets, sym->string_ptr, buffer ));
; 1287 :                     if ( ERROR == RebuildLine( buffer, i, tokenarray, strlen( tokenarray[i].string_ptr ),
; 1288 :                                               tokenarray[i].tokpos - line, addbrackets ) )

	mov	edx, DWORD PTR [rdi+rsi+24]
	mov	rdi, QWORD PTR [rdi+rsi+8]
	mov	r13, QWORD PTR line$[rsp]
	sub	edx, r13d
	xor	eax, eax
	mov	rcx, -1
	repne scasb
	mov	DWORD PTR [rsp+40], r15d
	mov	DWORD PTR [rsp+32], edx
	not	rcx
	mov	r8, rsi
	mov	edx, ebx
	lea	r9, QWORD PTR [rcx-1]
	lea	rcx, QWORD PTR buffer$[rsp]
	call	RebuildLine
	cmp	eax, -1
	je	$LN79@ExpandToke
	mov	ebp, DWORD PTR tv879[rsp]
	mov	ecx, DWORD PTR i$3$[rsp]
	mov	dl, BYTE PTR evaluate$1$[rsp]

; 1290 :                     rc = STRING_EXPANDED;

	mov	r14d, 1
	jmp	SHORT $LN42@ExpandToke
$LN90@ExpandToke:

; 1147 :     
; 1148 : 		if (strcasecmp(tokenarray[i].string_ptr, "LOCAL") == 0)

	mov	ebp, DWORD PTR tv879[rsp]
	mov	ecx, DWORD PTR i$3$[rsp]
	mov	dl, BYTE PTR evaluate$1$[rsp]
	mov	r13, QWORD PTR line$[rsp]
	jmp	SHORT $LN42@ExpandToke
$LN91@ExpandToke:

; 1225 :                     } else {
; 1226 :                         /* a macro proc is expanded at pos 0 or pos 2
; 1227 :                          * (or at pos 1 if sym->label is on)
; 1228 :                          */
; 1229 :                         if ( i == 0 ||
; 1230 :                             ( i == 2 && ( tokenarray[1].token == T_COLON ||
; 1231 :                                          tokenarray[1].token == T_DBL_COLON ))
; 1232 : #if MACROLABEL
; 1233 :                             || ( i == 1 && sym->label )
; 1234 : #endif
; 1235 :                            )

	mov	ebp, DWORD PTR tv879[rsp]
	mov	ecx, DWORD PTR i$3$[rsp]
	mov	dl, BYTE PTR evaluate$1$[rsp]
	mov	r13, QWORD PTR line$[rsp]
	jmp	SHORT $LN42@ExpandToke
$LN92@ExpandToke:

; 1278 :                         break;
; 1279 :                     }

	mov	ebp, DWORD PTR tv879[rsp]
	mov	ecx, DWORD PTR i$3$[rsp]
	mov	dl, BYTE PTR evaluate$1$[rsp]
	mov	r13, QWORD PTR line$[rsp]
	jmp	SHORT $LN42@ExpandToke
$LN93@ExpandToke:
	mov	ebp, DWORD PTR tv879[rsp]
	mov	ecx, DWORD PTR i$3$[rsp]
	mov	dl, BYTE PTR evaluate$1$[rsp]
	mov	r13, QWORD PTR line$[rsp]
	jmp	SHORT $LN42@ExpandToke
$LN95@ExpandToke:

; 1225 :                     } else {
; 1226 :                         /* a macro proc is expanded at pos 0 or pos 2
; 1227 :                          * (or at pos 1 if sym->label is on)
; 1228 :                          */
; 1229 :                         if ( i == 0 ||
; 1230 :                             ( i == 2 && ( tokenarray[1].token == T_COLON ||
; 1231 :                                          tokenarray[1].token == T_DBL_COLON ))
; 1232 : #if MACROLABEL
; 1233 :                             || ( i == 1 && sym->label )
; 1234 : #endif
; 1235 :                            )

	mov	ecx, DWORD PTR i$3$[rsp]
	mov	dl, BYTE PTR evaluate$1$[rsp]
	mov	r13, QWORD PTR line$[rsp]
$LN42@ExpandToke:
	inc	ebx
	cmp	ebx, DWORD PTR max$[rsp]
	jl	$LL43@ExpandToke

; 1285 :                         return( ERROR );
; 1286 :                     DebugMsg1(("ExpandToken(%s, addbr=%u): value >%s< expanded to >%s<\n", sym->name, addbrackets, sym->string_ptr, buffer ));
; 1287 :                     if ( ERROR == RebuildLine( buffer, i, tokenarray, strlen( tokenarray[i].string_ptr ),
; 1288 :                                               tokenarray[i].tokpos - line, addbrackets ) )

	jmp	SHORT $LN41@ExpandToke
$LN85@ExpandToke:

; 1241 : #else
; 1242 :                             return( EmitErr( SYNTAX_ERROR_EX, sym->name ) );
; 1243 : #endif
; 1244 :                         }
; 1245 :                         /* v2.08: write optional code label. This has been
; 1246 :                          * moved out from RunMacro().
; 1247 :                          */
; 1248 :                         if ( i == 2 ) {
; 1249 :                             if ( ERROR == WriteCodeLabel( line, tokenarray ) )

	mov	rcx, QWORD PTR line$[rsp]
	mov	rdx, rsi
	call	WriteCodeLabel
	cmp	eax, -1

; 1250 :                                 return( ERROR );

	je	$LN79@ExpandToke
$LN13@ExpandToke:

; 1251 :                         }
; 1252 :                         //buffer[0] = NULLC; /* nothing should be returned, just to be safe */
; 1253 :                         DebugMsg1(("ExpandToken(%s): macro proc to be expanded\n", sym->name ));
; 1254 :                         i = RunMacro( (struct dsym *)sym, i+1, tokenarray, NULL,
; 1255 : #if MACROLABEL
; 1256 :                                      MF_NOSAVE | (i == 1 ? MF_LABEL : 0),
; 1257 : #else
; 1258 :                                      MF_NOSAVE,
; 1259 : #endif
; 1260 :                                      &is_exitm );

	mov	eax, r12d
	lea	rcx, QWORD PTR is_exitm$[rsp]
	cmp	ebx, 1
	sete	al
	mov	QWORD PTR [rsp+40], rcx
	lea	edx, DWORD PTR [rbx+1]
	or	eax, 2
	xor	r9d, r9d
	mov	r8, rsi
	mov	rcx, rbp
	mov	DWORD PTR [rsp+32], eax
	call	RunMacro

; 1261 :                         DebugMsg1(("ExpandToken(%s): macro proc called\n", sym->name));
; 1262 :                         if ( i == -1 )

	cmp	eax, -1
	sete	r12b
	lea	eax, DWORD PTR [r12-2]

; 1263 :                             return( ERROR );
; 1264 : #if 0
; 1265 :                         /* it's possible to "hide" the EXITM directive when the
; 1266 :                          * macro lines are read. But it's not useful for macro
; 1267 :                          * procs to check if exitm has been executed, because
; 1268 :                          * Masm simply will ignore anything that's "returned".
; 1269 :                          */
; 1270 :                         if ( is_exitm ) {
; 1271 :                             DebugMsg(("ExpandToken: EXITM in macro procedure!\n" ));
; 1272 :                             strcat( buffer, tokenarray[tmp].tokpos );
; 1273 :                             strcpy( line, buffer );
; 1274 :                             rc = STRING_EXPANDED;
; 1275 :                         } else
; 1276 : #endif
; 1277 :                             return( EMPTY ); /* no further processing */

	jmp	$LN44@ExpandToke
$LN86@ExpandToke:

; 1289 :                         return( ERROR );

	mov	ecx, DWORD PTR pos$[rsp]
	mov	DWORD PTR i$3$[rsp], ecx
	jmp	SHORT $LN41@ExpandToke
$LN94@ExpandToke:

; 1291 :                     DebugMsg1(("ExpandToken(%s): rest after expansion: %s\n", sym->name, tokenarray[i].tokpos ));
; 1292 :                 }
; 1293 :             }
; 1294 :         }
; 1295 :     }
; 1296 :     *pi = i;
; 1297 :     if ( evaluate ) {
; 1298 :         int old_tokencount = Token_Count;
; 1299 :         if ( i == (pos+1) ) { /* just a single %? */
; 1300 :             opndx.value = 0;
; 1301 :             i = pos;
; 1302 :         } else {
; 1303 :             i = pos++;

	mov	ecx, DWORD PTR i$3$[rsp]
	mov	dl, BYTE PTR evaluate$1$[rsp]
	mov	r13, QWORD PTR line$[rsp]
$LN41@ExpandToke:
	test	dl, dl
	mov	r15, QWORD PTR pi$[rsp]
	mov	DWORD PTR [r15], ebx
	je	$LN7@ExpandToke
	mov	ebp, DWORD PTR ModuleInfo+496
	lea	eax, DWORD PTR [rcx+1]
	cmp	ebx, eax
	jne	SHORT $LN6@ExpandToke
	mov	DWORD PTR opndx$[rsp], r12d
	mov	ebx, 1
	jmp	$LN5@ExpandToke
$LN6@ExpandToke:

; 1304 :             tmp = tokenarray[*pi].tokpos - tokenarray[pos].tokpos;

	movsxd	rdx, eax
	movsxd	rax, DWORD PTR [r15]
	mov	DWORD PTR i$3$[rsp], ecx
	shl	rdx, 5
	shl	rax, 5
	mov	ecx, DWORD PTR [rax+rsi+24]
	sub	ecx, DWORD PTR [rdx+rsi+24]

; 1305 :             memcpy( buffer, tokenarray[pos].tokpos, tmp );

	mov	rdx, QWORD PTR [rdx+rsi+24]
	movsxd	rdi, ecx
	mov	DWORD PTR tmp$[rsp], ecx
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	r8, rdi
	call	memcpy

; 1306 :             buffer[tmp] = NULLC;
; 1307 :             tmp = old_tokencount + 1;

	lea	edx, DWORD PTR [rbp+1]

; 1308 :             Token_Count = Tokenize( buffer, tmp, tokenarray, TOK_RESCAN );

	mov	ebx, 1
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	r9d, ebx
	mov	r8, rsi
	mov	DWORD PTR tmp$[rsp], edx
	mov	BYTE PTR buffer$[rsp+rdi], r12b
	call	Tokenize

; 1309 :             if ( EvalOperand( &tmp, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR )

	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR tmp$[rsp]
	mov	rdx, rsi
	mov	r8d, eax
	mov	DWORD PTR ModuleInfo+496, eax
	mov	BYTE PTR [rsp+32], 2
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN4@ExpandToke

; 1310 :                 opndx.value = 0; /* v2.09: assume value 0, don't return with ERROR */

	mov	DWORD PTR opndx$[rsp], r12d
	jmp	SHORT $LN2@ExpandToke
$LN4@ExpandToke:

; 1311 :             else if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], r12d
	je	SHORT $LN87@ExpandToke

; 1312 :                 /* v2.09: with flag EXPF_NOUNDEF, EvalOperand() will have returned
; 1313 :                  * with error if there's an undefined symbol involved
; 1314 :                  */
; 1315 :                 //if ( opndx.sym && opndx.sym->state == SYM_UNDEFINED )
; 1316 :                 //    EmitErr( SYMBOL_NOT_DEFINED, opndx.sym->name );
; 1317 :                 //else {
; 1318 :                     DebugMsg(("ExpandToken: 'constant expected' error\n"));
; 1319 :                     EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 1320 :                 //}
; 1321 :                 //return( ERROR );
; 1322 :                 opndx.value = 0; /* assume value 0 */

	mov	DWORD PTR opndx$[rsp], r12d
	jmp	SHORT $LN2@ExpandToke
$LN87@ExpandToke:
	mov	r12d, DWORD PTR opndx$[rsp]
$LN2@ExpandToke:

; 1323 :             }
; 1324 :             Token_Count = old_tokencount;

	mov	DWORD PTR ModuleInfo+496, ebp
$LN5@ExpandToke:

; 1325 :         }
; 1326 : #if TEVALUE_UNSIGNED
; 1327 :         /* v2.03: Masm compatible: returns an unsigned value */
; 1328 :         myltoa( opndx.value, StringBufferEnd, ModuleInfo.radix, FALSE, FALSE );

	test	r12d, r12d
	movzx	r8d, BYTE PTR ModuleInfo+396
	mov	r9, QWORD PTR ModuleInfo+488
	jne	SHORT $LN51@ExpandToke
	mov	BYTE PTR [r9], 48			; 00000030H
	mov	BYTE PTR [r9+1], r12b
	jmp	SHORT $LN54@ExpandToke
$LN51@ExpandToke:
	lea	rdi, QWORD PTR tmpbuf$6943[rsp+33]
	mov	BYTE PTR tmpbuf$6943[rsp+33], 0
	lea	r10, OFFSET FLAT:__digits
	npad	6
$LL50@ExpandToke:
	xor	edx, edx
	mov	eax, r12d
	dec	rdi
	div	r8d
	mov	r12d, eax
	test	r12d, r12d
	movzx	eax, BYTE PTR [rdx+r10]
	mov	BYTE PTR [rdi], al
	jne	SHORT $LL50@ExpandToke
	lea	r8, QWORD PTR tmpbuf$6943[rsp+34]
	mov	rdx, rdi
	mov	rcx, r9
	sub	r8, rdi
	call	memcpy
$LN54@ExpandToke:

; 1329 : #else
; 1330 :         myltoa( opndx.value, StringBufferEnd, ModuleInfo.radix, opndx.hvalue < 0, FALSE );
; 1331 : #endif
; 1332 :             /* v2.05: get size of string to be "replaced" */
; 1333 :         tmp = tokenarray[*pi].tokpos - tokenarray[i].tokpos;

	movsxd	r11, DWORD PTR i$3$[rsp]
	movsxd	rax, DWORD PTR [r15]
	shl	rax, 5
	mov	r8, r11

; 1334 :         DebugMsg1(("ExpandToken: curr pos=%u, start expr=%u, expr size=%d\n", *pi, i, tmp ));
; 1335 : 
; 1336 :         //tokenarray[i].token = T_STRING;
; 1337 :         tokenarray[i].string_ptr = StringBufferEnd;
; 1338 :         AddTokens( tokenarray, i+1, i+1 - *pi, Token_Count );

	lea	ecx, DWORD PTR [r11+1]
	mov	r9d, DWORD PTR [rax+rsi+24]
	mov	rax, QWORD PTR ModuleInfo+488
	shl	r8, 5
	sub	r9d, DWORD PTR [r8+rsi+24]
	mov	QWORD PTR [r8+rsi+8], rax
	mov	eax, r11d
	sub	eax, DWORD PTR [r15]
	mov	DWORD PTR tmp$[rsp], r9d
	inc	eax
	test	eax, eax
	movsxd	r10, eax
	jle	SHORT $LN64@ExpandToke
	movsxd	rax, DWORD PTR ModuleInfo+496
	cmp	eax, ecx
	mov	rdi, rax
	jl	$LN88@ExpandToke
	movsxd	rax, ecx
	lea	rcx, QWORD PTR [rdi+r10]
	mov	rdx, rdi
	shl	rcx, 5
	shl	rdx, 5
	sub	rdi, rax
	add	rcx, rsi
	add	rdx, rsi
	inc	rdi
	npad	2
$LL63@ExpandToke:
	mov	rax, QWORD PTR [rdx]
	sub	rcx, 32					; 00000020H
	sub	rdx, 32					; 00000020H
	dec	rdi
	mov	QWORD PTR [rcx+32], rax
	mov	rax, QWORD PTR [rdx+40]
	mov	QWORD PTR [rcx+40], rax
	mov	rax, QWORD PTR [rdx+48]
	mov	QWORD PTR [rcx+48], rax
	mov	rax, QWORD PTR [rdx+56]
	mov	QWORD PTR [rcx+56], rax
	jne	SHORT $LL63@ExpandToke
	jmp	SHORT $LN88@ExpandToke
$LN64@ExpandToke:
	test	eax, eax
	jns	SHORT $LN88@ExpandToke
	movsxd	rdx, DWORD PTR ModuleInfo+496
	sub	ecx, eax
	cmp	ecx, edx
	movsxd	rax, ecx
	jg	SHORT $LN88@ExpandToke
	mov	rdi, rdx
	lea	rcx, QWORD PTR [rax+r10]
	mov	rdx, rax
	shl	rcx, 5
	shl	rdx, 5
	sub	rdi, rax
	add	rcx, rsi
	add	rdx, rsi
	inc	rdi
$LL58@ExpandToke:
	mov	rax, QWORD PTR [rdx]
	add	rcx, 32					; 00000020H
	add	rdx, 32					; 00000020H
	dec	rdi
	mov	QWORD PTR [rcx-32], rax
	mov	rax, QWORD PTR [rdx-24]
	mov	QWORD PTR [rcx-24], rax
	mov	rax, QWORD PTR [rdx-16]
	mov	QWORD PTR [rcx-16], rax
	mov	rax, QWORD PTR [rdx-8]
	mov	QWORD PTR [rcx-8], rax
	jne	SHORT $LL58@ExpandToke
$LN88@ExpandToke:

; 1339 :         Token_Count += (i+1) - *pi;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	ecx, r11d

; 1340 : 
; 1341 :         if ( ERROR == RebuildLine( StringBufferEnd, i, tokenarray,
; 1342 :                                   tmp, tokenarray[i].tokpos - line, bracket_flags ) )

	mov	edx, r11d
	sub	ecx, DWORD PTR [r15]
	lea	ecx, DWORD PTR [rax+rcx+1]
	mov	DWORD PTR ModuleInfo+496, ecx
	mov	eax, DWORD PTR [r8+rsi+24]
	mov	ecx, DWORD PTR bracket_flags$[rsp]
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR ModuleInfo+488
	sub	eax, r13d
	mov	r8, rsi
	mov	DWORD PTR [rsp+32], eax
	call	RebuildLine
	cmp	eax, -1
	jne	SHORT $LN1@ExpandToke
$LN79@ExpandToke:

; 1343 :             return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN44@ExpandToke
$LN1@ExpandToke:

; 1344 :         rc = STRING_EXPANDED;

	mov	r14d, ebx
$LN7@ExpandToke:

; 1345 :     }
; 1346 :     return( rc );

	mov	eax, r14d
$LN44@ExpandToke:
	mov	r15, QWORD PTR [rsp+1256]
	mov	r14, QWORD PTR [rsp+1264]
	mov	r13, QWORD PTR [rsp+1272]
	mov	r12, QWORD PTR [rsp+1280]
	mov	rdi, QWORD PTR [rsp+1288]
	mov	rsi, QWORD PTR [rsp+1296]
	mov	rbp, QWORD PTR [rsp+1304]
	mov	rbx, QWORD PTR [rsp+1312]

; 1347 : }

	add	rsp, 1320				; 00000528H
	ret	0
ExpandToken ENDP
_TEXT	ENDS
PUBLIC	ExpandLineItems
xdata	SEGMENT
$unwind$ExpandLineItems DD 0113701H
	DD	0e3437H
	DD	07f431H
	DD	08e425H
	DD	09d421H
	DD	0ac41dH
	DD	0b7419H
	DD	0c6415H
	DD	0d5411H
	DD	0e207H
xdata	ENDS
pdata	SEGMENT
$pdata$ExpandLineItems DD @imagerel($LN19#)
	DD	@imagerel($LN19#+276)
	DD	@imagerel($unwind$ExpandLineItems#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
line$ = 128
k$ = 136
i$ = 136
tokenarray$ = 144
addbrackets$ = 152
equmode$ = 160
ExpandLineItems PROC NEAR

; 1356 : {

$LN19:
	mov	r11, rsp
	sub	rsp, 120				; 00000078H

; 1357 :     int k;
; 1358 :     int lvl;
; 1359 :     int tmp;
; 1360 :     ret_code rc;
; 1361 : 
; 1362 :     for ( lvl = 0; ; lvl++ ) {

	mov	eax, DWORD PTR ModuleInfo+496
	mov	QWORD PTR [r11-16], rbp
	mov	QWORD PTR [r11-24], rsi
	mov	QWORD PTR [r11-32], rdi
	mov	QWORD PTR [r11-40], r12
	mov	QWORD PTR [r11-48], r13
	mov	QWORD PTR [r11-56], r14
	mov	r14d, DWORD PTR equmode$[rsp]
	mov	QWORD PTR [r11-64], r15
	xor	esi, esi
	mov	QWORD PTR [r11-8], rbx
	mov	r13d, r9d
	mov	rdi, r8
	mov	ebp, edx
	mov	r12, rcx
	lea	r15d, QWORD PTR [rsi+1]
	npad	10
$LL10@ExpandLine:

; 1363 :         rc = NOT_ERROR;

	xor	ebx, ebx

; 1364 :         for( k = i; k < Token_Count; ) {

	cmp	ebp, eax
	mov	DWORD PTR k$[rsp], ebp
	jge	$LN8@ExpandLine
$LL7@ExpandLine:

; 1365 :             tmp = ExpandToken( line, &k, tokenarray, Token_Count, addbrackets, equmode );

	lea	rdx, QWORD PTR k$[rsp]
	mov	r9d, eax
	mov	r8, rdi
	mov	rcx, r12
	mov	DWORD PTR [rsp+40], r14d
	mov	DWORD PTR [rsp+32], r13d
	call	ExpandToken

; 1366 :             if ( tmp == ERROR )

	cmp	eax, -1
	je	SHORT $LN8@ExpandLine

; 1367 :                 return( lvl );
; 1368 :             if ( tmp == STRING_EXPANDED )
; 1369 :                 rc = STRING_EXPANDED;
; 1370 :             if ( tokenarray[k].token == T_COMMA )

	movsxd	rcx, DWORD PTR k$[rsp]
	cmp	eax, r15d
	cmove	ebx, r15d
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 44			; 0000002cH
	jne	SHORT $LN3@ExpandLine

; 1371 :                 k++;

	inc	ecx
	mov	DWORD PTR k$[rsp], ecx
$LN3@ExpandLine:
	mov	eax, DWORD PTR ModuleInfo+496
	cmp	ecx, eax
	jl	SHORT $LL7@ExpandLine

; 1372 :         }
; 1373 :         if ( rc == NOT_ERROR )

	test	ebx, ebx
	je	SHORT $LN8@ExpandLine

; 1374 :             break;
; 1375 :         /* expansion happened, re-tokenize and continue! */
; 1376 :         Token_Count = Tokenize( line, i, tokenarray, TOK_RESCAN );

	mov	r9d, r15d
	mov	r8, rdi
	mov	edx, ebp
	mov	rcx, r12
	call	Tokenize

; 1377 :         if ( lvl == MAX_TEXTMACRO_NESTING ) {

	cmp	esi, 20
	mov	DWORD PTR ModuleInfo+496, eax
	je	SHORT $LN18@ExpandLine

; 1357 :     int k;
; 1358 :     int lvl;
; 1359 :     int tmp;
; 1360 :     ret_code rc;
; 1361 : 
; 1362 :     for ( lvl = 0; ; lvl++ ) {

	inc	esi
	jmp	$LL10@ExpandLine
$LN18@ExpandLine:

; 1378 :             EmitError( MACRO_NESTING_LEVEL_TOO_DEEP );

	mov	ecx, 101				; 00000065H
	call	EmitError
$LN8@ExpandLine:
	mov	r15, QWORD PTR [rsp+56]
	mov	r14, QWORD PTR [rsp+64]
	mov	r13, QWORD PTR [rsp+72]
	mov	r12, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+112]

; 1379 :             break;
; 1380 :         }
; 1381 :     }
; 1382 :     return( lvl );

	mov	eax, esi
	mov	rsi, QWORD PTR [rsp+96]

; 1383 : }

	add	rsp, 120				; 00000078H
	ret	0
ExpandLineItems ENDP
_TEXT	ENDS
EXTRN	SpecialTable:BYTE
EXTRN	__ImageBase:BYTE
xdata	SEGMENT
$unwind$ExpandLine DD 0114501H
	DD	0117445H
	DD	010642dH
	DD	0f5429H
	DD	0e3422H
	DD	09f41eH
	DD	0ae41aH
	DD	0bd416H
	DD	0cc412H
	DD	0c207H
xdata	ENDS
pdata	SEGMENT
$pdata$ExpandLine DD @imagerel($LN75#)
	DD	@imagerel($LN75#+1236)
	DD	@imagerel($unwind$ExpandLine#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
count$ = 48
string$ = 112
tokenarray$ = 120
ExpandLine PROC NEAR

; 1421 : {

$LN75:
	mov	rax, rsp
	sub	rsp, 104				; 00000068H

; 1422 :     int count;
; 1423 :     unsigned int bracket_flags; /* flags */
; 1424 :     int flags;
; 1425 :     int lvl;
; 1426 :     int i;
; 1427 :     int j;
; 1428 :     ret_code rc;
; 1429 :     struct asym *sym;
; 1430 : 
; 1431 :     /* filter certain conditions.
; 1432 :      * bracket_flags: for (preprocessor) directives that expect a literal
; 1433 :      * parameter, the expanded argument has to be enclosed in '<>' again.
; 1434 :      */
; 1435 :     DebugMsg1(( "ExpandLine(>%s<) enter\n", string ));
; 1436 :     for ( lvl = 0; lvl < MAX_TEXTMACRO_NESTING; lvl++ ) {

	mov	r8d, DWORD PTR ModuleInfo+496
	mov	QWORD PTR [rax-8], r12
	mov	QWORD PTR [rax-16], r13
	mov	QWORD PTR [rax-24], r14
	mov	QWORD PTR [rax-32], r15
	mov	QWORD PTR [rax+8], rbx
	xor	r15d, r15d
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	r12, rdx
	mov	r13, rcx
	lea	r9, OFFSET FLAT:__ImageBase
	lea	r10d, QWORD PTR [r15+1]
	mov	r14d, r15d
	mov	QWORD PTR [rax+32], rdi
	npad	11
$LL49@ExpandLine@2:

; 1437 :         bracket_flags = 0;
; 1438 :         count = 0;
; 1439 :         rc = NOT_ERROR;
; 1440 :         i = ( Token_Count > 2 && ( tokenarray[1].token == T_COLON || tokenarray[1].token == T_DBL_COLON ) && tokenarray[2].token == T_DIRECTIVE ) ? 2 : 0;

	cmp	r8d, 2
	mov	esi, r15d
	mov	edx, r15d
	mov	DWORD PTR count$[rsp], r15d
	mov	ebp, r15d
	jle	SHORT $LN53@ExpandLine@2
	movzx	eax, BYTE PTR [r12+32]
	cmp	al, 58					; 0000003aH
	je	SHORT $LN52@ExpandLine@2
	cmp	al, 13
	jne	SHORT $LN53@ExpandLine@2
$LN52@ExpandLine@2:
	cmp	BYTE PTR [r12+64], 3
	jne	SHORT $LN53@ExpandLine@2
	mov	edi, 2
	mov	rax, rdi
	jmp	SHORT $LN54@ExpandLine@2
$LN53@ExpandLine@2:
	mov	edi, r15d
	mov	rax, r15
$LN54@ExpandLine@2:

; 1441 :         if ( tokenarray[i].token == T_DIRECTIVE ) {

	shl	rax, 5
	cmp	BYTE PTR [rax+r12], 3
	lea	rbx, QWORD PTR [rax+r12]
	jne	$LN46@ExpandLine@2

; 1442 :             flags = GetValueSp( tokenarray[i].tokval );

	mov	ecx, DWORD PTR [rbx+16]
	lea	rax, QWORD PTR [rcx+rcx*2]
	mov	r9d, DWORD PTR SpecialTable[r9+rax*4]

; 1443 :             if ( flags & DF_STRPARM ) {

	test	r9b, 2
	je	SHORT $LN45@ExpandLine@2

; 1444 :                 bracket_flags = -1;
; 1445 :                 /* v2.08 handle .ERRDEF and .ERRNDEF here. Previously
; 1446 :                  * expansion for these directives was handled in condasm.asm,
; 1447 :                  * and the directives were flagged as DF_NOEXPAND.
; 1448 :                  */
; 1449 :                 if ( tokenarray[i].dirtype == DRT_ERRDIR ) {

	cmp	BYTE PTR [rbx+1], 10
	mov	esi, -1					; ffffffffH
	jne	$LN73@ExpandLine@2

; 1450 :                     if (tokenarray[i].tokval == T_DOT_ERRDEF || tokenarray[i].tokval == T_DOT_ERRNDEF ) {

	cmp	ecx, 361				; 00000169H
	je	SHORT $LN42@ExpandLine@2
	cmp	ecx, 362				; 0000016aH
	jne	$LN74@ExpandLine@2
$LN42@ExpandLine@2:

; 1451 :                         if ( i )

	test	edi, edi
	je	SHORT $LN56@ExpandLine@2

; 1452 :                             rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	lea	rdx, QWORD PTR count$[rsp]
	mov	r9d, r10d
	mov	r8, r12
	mov	rcx, r13
	mov	DWORD PTR [rsp+40], r15d
	mov	DWORD PTR [rsp+32], r15d
	call	ExpandToken
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	ebp, eax
$LN56@ExpandLine@2:

; 1453 :                         while ( tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA ) i++;

	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	SHORT $LN70@ExpandLine@2
$LL40@ExpandLine@2:
	cmp	al, 44					; 0000002cH
	je	SHORT $LN70@ExpandLine@2
	mov	al, BYTE PTR [rbx+32]
	add	rbx, 32					; 00000020H
	inc	edi
	test	al, al
	jne	SHORT $LL40@ExpandLine@2
$LN70@ExpandLine@2:

; 1454 :                         count = i; /* don't expand the symbol name */

	mov	edx, edi
	mov	DWORD PTR count$[rsp], edi

; 1455 :                     }
; 1456 :                 }

	mov	ebx, 1
	jmp	$LN58@ExpandLine@2
$LN45@ExpandLine@2:

; 1457 :             } else if ( flags & DF_NOEXPAND ) {

	test	r9b, 4
	jne	$LN18@ExpandLine@2

; 1458 :                 /* [ELSE]IF[N]DEF, ECHO, FOR[C]
; 1459 :                  * .[NO|X]CREF, INCLUDE */
; 1460 :                 /* don't expand arguments */
; 1461 :                 return( NOT_ERROR );
; 1462 :             }

	mov	ebx, 1
	jmp	$LN58@ExpandLine@2
$LN46@ExpandLine@2:

; 1463 :         } else if ( Token_Count > 1 && tokenarray[1].token == T_DIRECTIVE ) {

	cmp	r8d, 1
	jle	$LN35@ExpandLine@2
	cmp	BYTE PTR [r12+32], 3
	jne	$LN35@ExpandLine@2

; 1464 :             switch ( tokenarray[1].dirtype ) {

	movzx	eax, BYTE PTR [r12+33]
	add	eax, -4
	cmp	eax, 43					; 0000002bH
	ja	$LN71@ExpandLine@2
	cdqe
	movzx	eax, BYTE PTR $LN66@ExpandLine@2[r9+rax]
	mov	ecx, DWORD PTR $LN67@ExpandLine@2[r9+rax*4]
	add	rcx, r9
	jmp	rcx
$LN32@ExpandLine@2:

; 1465 :             case DRT_CATSTR:
; 1466 :                 bracket_flags = -1;
; 1467 :                 count = 2;

	mov	edx, 2
	mov	esi, -1					; ffffffffH

; 1468 :                 break;

	lea	ebx, QWORD PTR [rdx-1]
	mov	DWORD PTR count$[rsp], edx
	jmp	$LN58@ExpandLine@2
$LN31@ExpandLine@2:

; 1469 :             case DRT_SUBSTR:
; 1470 :                 /* syntax: name SUBSTR <literal>, pos [, size] */
; 1471 :                 bracket_flags = 0x1;

	mov	ebx, 1

; 1472 :                 count = 2;

	mov	edx, 2
	mov	esi, ebx
	mov	DWORD PTR count$[rsp], edx

; 1473 :                 break;

	jmp	$LN58@ExpandLine@2
$LN30@ExpandLine@2:

; 1474 :             case DRT_SIZESTR:
; 1475 :                 /* syntax: label SIZESTR literal */
; 1476 :                 rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	mov	ebx, 1
	lea	rdx, QWORD PTR count$[rsp]
	mov	r8, r12
	mov	rcx, r13
	mov	r9d, ebx
	mov	DWORD PTR [rsp+40], r15d
	mov	DWORD PTR [rsp+32], r15d
	call	ExpandToken

; 1477 :                 bracket_flags = 0x1;
; 1478 :                 count = 2;
; 1479 :                 break;

	mov	r8d, DWORD PTR ModuleInfo+496
	mov	edx, 2
	mov	ebp, eax
	mov	esi, ebx
	mov	DWORD PTR count$[rsp], edx
	jmp	$LN58@ExpandLine@2
$LN29@ExpandLine@2:

; 1480 :             case DRT_INSTR:
; 1481 :                 /* syntax: label INSTR [number,] literal, literal */
; 1482 :                 rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	mov	ebx, 1
	lea	rdx, QWORD PTR count$[rsp]
	mov	r8, r12
	mov	rcx, r13
	mov	r9d, ebx
	mov	DWORD PTR [rsp+40], r15d
	mov	DWORD PTR [rsp+32], r15d
	call	ExpandToken

; 1483 :                 /* check if the optional <number> argument is given */
; 1484 :                 for ( i = 2, count = 0, j = 0; i < Token_Count; i++ ) {

	mov	r8d, DWORD PTR ModuleInfo+496
	cmp	r8d, 2
	mov	ebp, eax
	mov	ecx, r15d
	mov	r9d, r15d
	jle	SHORT $LN26@ExpandLine@2
	lea	eax, DWORD PTR [r8-2]
	lea	rdx, QWORD PTR [r12+64]
	mov	r10d, eax
$LL28@ExpandLine@2:

; 1485 :                     if ( tokenarray[i].token == T_OP_BRACKET )

	movzx	eax, BYTE PTR [rdx]
	cmp	al, 40					; 00000028H
	jne	SHORT $LN25@ExpandLine@2

; 1486 :                         count++;

	inc	ecx
	jmp	SHORT $LN27@ExpandLine@2
$LN25@ExpandLine@2:

; 1487 :                     else if ( tokenarray[i].token == T_CL_BRACKET )

	cmp	al, 41					; 00000029H
	jne	SHORT $LN23@ExpandLine@2

; 1488 :                         count--;

	dec	ecx
	jmp	SHORT $LN27@ExpandLine@2
$LN23@ExpandLine@2:

; 1489 :                     else if ( tokenarray[i].token == T_COMMA && count == 0 )

	cmp	al, 44					; 0000002cH
	jne	SHORT $LN27@ExpandLine@2
	test	ecx, ecx
	jne	SHORT $LN27@ExpandLine@2

; 1490 :                         j++;

	inc	r9d
$LN27@ExpandLine@2:

; 1483 :                 /* check if the optional <number> argument is given */
; 1484 :                 for ( i = 2, count = 0, j = 0; i < Token_Count; i++ ) {

	add	rdx, 32					; 00000020H
	dec	r10
	jne	SHORT $LL28@ExpandLine@2
$LN26@ExpandLine@2:

; 1491 :                 }
; 1492 : 
; 1493 :                 bracket_flags = ( ( j > 1 ) ? 0x6 : 0x3 );

	mov	esi, 3
	cmp	r9d, ebx
	mov	eax, 6

; 1494 :                 count = 2;

	mov	edx, 2
	cmovg	esi, eax
	mov	DWORD PTR count$[rsp], edx

; 1495 :                 break;

	jmp	$LN58@ExpandLine@2
$LN20@ExpandLine@2:

; 1496 :             case DRT_MACRO:
; 1497 :                 sym = SymSearch( tokenarray[0].string_ptr );

	mov	rcx, QWORD PTR [r12+8]
	call	SymFind

; 1498 :                 /* don't expand macro DEFINITIONs!
; 1499 :                  * the name is an exception, if it's not the macro itself
; 1500 :                  */
; 1501 :                 if ( sym && sym->state != SYM_MACRO )

	test	rax, rax
	je	$LN47@ExpandLine@2
	cmp	DWORD PTR [rax+40], 9
	je	$LN47@ExpandLine@2

; 1502 :                     rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	lea	rdx, QWORD PTR count$[rsp]
	mov	r9d, 1
	mov	r8, r12
	mov	rcx, r13
	mov	DWORD PTR [rsp+40], r15d
	mov	DWORD PTR [rsp+32], r15d
	call	ExpandToken
	mov	ebp, eax

; 1516 :             }
; 1517 :         } else {

	jmp	$LN8@ExpandLine@2
$LN35@ExpandLine@2:

; 1518 :             /* v2.08: expand the very first token and then ... */
; 1519 :             rc = ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE );

	mov	ebx, 1
	lea	rdx, QWORD PTR count$[rsp]
	mov	r8, r12
	mov	rcx, r13
	mov	r9d, ebx
	mov	DWORD PTR [rsp+40], r15d
	mov	DWORD PTR [rsp+32], r15d
	call	ExpandToken

; 1520 :             if( rc == ERROR || rc == EMPTY )

	cmp	eax, -1
	mov	ebp, eax
	je	$LN50@ExpandLine@2
	cmp	eax, -2
	je	$LN50@ExpandLine@2

; 1521 :                 return( rc );
; 1522 :             if ( rc == STRING_EXPANDED ) {

	cmp	eax, ebx
	jne	SHORT $LN14@ExpandLine@2

; 1523 :                 /* ... fully retokenize - the expansion might have revealed a conditional
; 1524 :                  * assembly directive
; 1525 :                  */
; 1526 :                 Token_Count = Tokenize( string, 0, tokenarray, TOK_DEFAULT );

	xor	r9d, r9d
	mov	r8, r12
	xor	edx, edx
	mov	rcx, r13
	call	Tokenize
	mov	r8d, eax
	mov	DWORD PTR ModuleInfo+496, eax

; 1527 :                 continue;

	jmp	$LN48@ExpandLine@2
$LN14@ExpandLine@2:

; 1528 :             }
; 1529 : #if 1 /* v2.10. see regression test equate27.asm */
; 1530 :             if ( count == 1 && tokenarray[0].token == T_ID && tokenarray[1].token == T_ID ) {

	mov	edx, DWORD PTR count$[rsp]
	cmp	edx, ebx
	jne	SHORT $LN69@ExpandLine@2
	cmp	BYTE PTR [r12], 8
	jne	SHORT $LN69@ExpandLine@2
	cmp	BYTE PTR [r12+32], 8
	jne	SHORT $LN69@ExpandLine@2

; 1531 :                 rc = ExpandToken( string, &count, tokenarray, 2, FALSE, FALSE );

	lea	rdx, QWORD PTR count$[rsp]
	mov	r9d, 2
	mov	r8, r12
	mov	rcx, r13
	mov	DWORD PTR [rsp+40], r15d
	mov	DWORD PTR [rsp+32], r15d
	call	ExpandToken

; 1532 :                 if( rc == ERROR || rc == EMPTY )

	cmp	eax, -1
	mov	ebp, eax
	je	$LN50@ExpandLine@2
	cmp	eax, -2
	je	$LN50@ExpandLine@2

; 1533 :                     return( rc );
; 1534 :                 if ( rc == STRING_EXPANDED ) {

	cmp	eax, ebx
	jne	SHORT $LN68@ExpandLine@2

; 1535 :                     Token_Count = Tokenize( string, 0, tokenarray, TOK_DEFAULT );

	xor	r9d, r9d
	mov	r8, r12
	xor	edx, edx
	mov	rcx, r13
	call	Tokenize
	mov	r8d, eax
	mov	DWORD PTR ModuleInfo+496, eax

; 1536 :                     continue;

	jmp	$LN48@ExpandLine@2
$LN68@ExpandLine@2:
	mov	edx, DWORD PTR count$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	jmp	SHORT $LN58@ExpandLine@2
$LN69@ExpandLine@2:
	mov	r8d, DWORD PTR ModuleInfo+496
	jmp	SHORT $LN58@ExpandLine@2
$LN71@ExpandLine@2:

; 1422 :     int count;
; 1423 :     unsigned int bracket_flags; /* flags */
; 1424 :     int flags;
; 1425 :     int lvl;
; 1426 :     int i;
; 1427 :     int j;
; 1428 :     ret_code rc;
; 1429 :     struct asym *sym;
; 1430 : 
; 1431 :     /* filter certain conditions.
; 1432 :      * bracket_flags: for (preprocessor) directives that expect a literal
; 1433 :      * parameter, the expanded argument has to be enclosed in '<>' again.
; 1434 :      */
; 1435 :     DebugMsg1(( "ExpandLine(>%s<) enter\n", string ));
; 1436 :     for ( lvl = 0; lvl < MAX_TEXTMACRO_NESTING; lvl++ ) {

	mov	ebx, 1
	jmp	SHORT $LN58@ExpandLine@2
$LN72@ExpandLine@2:

; 1536 :                     continue;

	mov	ebx, 1
	jmp	SHORT $LN58@ExpandLine@2
$LN73@ExpandLine@2:
	mov	ebx, 1
	jmp	SHORT $LN58@ExpandLine@2
$LN74@ExpandLine@2:
	mov	ebx, 1
$LN58@ExpandLine@2:

; 1537 :                 }
; 1538 :             }
; 1539 : #endif
; 1540 :         }
; 1541 :         /* scan the line from left to right for (text) macros.
; 1542 :          * it's currently not quite correct. a macro proc should only
; 1543 :          * be evaluated in the following cases:
; 1544 :          * 1. it is the first token of a line
; 1545 :          * 2. it is the second token, and the first one is an ID
; 1546 :          * 3. it is the third token, the first one is an ID and
; 1547 :          *    the second is a ':' or '::'.
; 1548 :          */
; 1549 :         while ( count < Token_Count ) {

	cmp	edx, r8d
	jge	SHORT $LN8@ExpandLine@2
	npad	9
$LL9@ExpandLine@2:

; 1550 :             int tmp;
; 1551 :             int addbrackets;
; 1552 :             addbrackets = bracket_flags & 1;

	mov	eax, esi
	and	eax, 1

; 1553 :             if ( bracket_flags != -1 )

	cmp	esi, -1					; ffffffffH
	je	SHORT $LN7@ExpandLine@2

; 1554 :                 bracket_flags = bracket_flags >> 1;

	shr	esi, 1
$LN7@ExpandLine@2:

; 1555 :             tmp = ExpandToken( string, &count, tokenarray, Token_Count, addbrackets, FALSE );

	mov	r9d, r8d
	lea	rdx, QWORD PTR count$[rsp]
	mov	rcx, r13
	mov	r8, r12
	mov	DWORD PTR [rsp+40], r15d
	mov	DWORD PTR [rsp+32], eax
	call	ExpandToken

; 1556 :             if( tmp < NOT_ERROR ) /* ERROR or EMPTY? */

	test	eax, eax
	js	SHORT $LN50@ExpandLine@2

; 1557 :                 return( tmp );
; 1558 :             if ( tmp == STRING_EXPANDED )
; 1559 :                 rc = STRING_EXPANDED;
; 1560 :             if ( tokenarray[count].token == T_COMMA )

	movsxd	rcx, DWORD PTR count$[rsp]
	cmp	eax, 1
	cmove	ebp, ebx
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], 44			; 0000002cH
	jne	SHORT $LN4@ExpandLine@2

; 1561 :                 count++;

	inc	ecx
	mov	DWORD PTR count$[rsp], ecx
$LN4@ExpandLine@2:
	mov	r8d, DWORD PTR ModuleInfo+496
	cmp	ecx, r8d
	jl	SHORT $LL9@ExpandLine@2
$LN8@ExpandLine@2:

; 1562 :         }
; 1563 :         if( rc == STRING_EXPANDED ) {

	cmp	ebp, 1
	jne	SHORT $LN47@ExpandLine@2

; 1564 :             DebugMsg1(( "ExpandLine(%s): expansion occured, retokenize\n", string ));
; 1565 :             Token_Count = Tokenize( string, 0, tokenarray, TOK_RESCAN | TOK_LINE );

	lea	r9d, QWORD PTR [rbp+4]
	mov	r8, r12
	xor	edx, edx
	mov	rcx, r13
	call	Tokenize
	mov	r8d, eax
	mov	DWORD PTR ModuleInfo+496, eax
$LN48@ExpandLine@2:
	inc	r14d
	mov	r10d, 1
	lea	r9, OFFSET FLAT:__ImageBase
	cmp	r14d, 20
	jl	$LL49@ExpandLine@2
$LN47@ExpandLine@2:

; 1566 :         } else
; 1567 :             break;
; 1568 :     } /* end for() */
; 1569 :     if ( lvl == MAX_TEXTMACRO_NESTING ) {

	cmp	r14d, 20
	jne	SHORT $LN1@ExpandLine@2

; 1570 :         return( EmitError( MACRO_NESTING_LEVEL_TOO_DEEP ) );

	lea	ecx, QWORD PTR [r14+81]
	call	EmitError
	jmp	SHORT $LN50@ExpandLine@2
$LN18@ExpandLine@2:

; 1503 :                 count = Token_Count; /* stop further expansion */
; 1504 :                 break;
; 1505 :             case DRT_EQU:
; 1506 :                 /* EQU is a special case. If the - expanded - expression is
; 1507 :                  * a number, then the value for EQU is numeric. Else the
; 1508 :                  * expression isn't expanded at all. This effectively makes it
; 1509 :                  * impossible to expand EQU lines here.
; 1510 :                  */
; 1511 : #if 0 /* v2.09: EQU should NEVER be expanded here. See regression test equate20.aso */
; 1512 :                 sym = SymSearch( tokenarray[0].string_ptr );
; 1513 :                 if ( sym == NULL || sym->state == SYM_TMACRO )
; 1514 : #endif
; 1515 :                     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN50@ExpandLine@2
$LN1@ExpandLine@2:

; 1571 :     }
; 1572 :     DebugMsg1(( "ExpandLine(>%s<) exit, rc=%u, token_count=%u\n", string, rc, Token_Count ));
; 1573 :     return( rc );

	mov	eax, ebp
$LN50@ExpandLine@2:
	mov	r15, QWORD PTR [rsp+72]
	mov	r14, QWORD PTR [rsp+80]
	mov	r13, QWORD PTR [rsp+88]
	mov	r12, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+136]
	mov	rsi, QWORD PTR [rsp+128]
	mov	rbp, QWORD PTR [rsp+120]
	mov	rbx, QWORD PTR [rsp+112]

; 1574 : }

	add	rsp, 104				; 00000068H
	ret	0
	npad	2
$LN67@ExpandLine@2:
	DD	$LN20@ExpandLine@2
	DD	$LN32@ExpandLine@2
	DD	$LN31@ExpandLine@2
	DD	$LN29@ExpandLine@2
	DD	$LN30@ExpandLine@2
	DD	$LN18@ExpandLine@2
	DD	$LN72@ExpandLine@2
$LN66@ExpandLine@2:
	DB	0
	DB	1
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
ExpandLine ENDP
_TEXT	ENDS
END
