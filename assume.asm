; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	szDgroup
_BSS	SEGMENT
$SG5748	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	StdAssumeTable:BYTE:0100H
COMM	SegAssumeTable:BYTE:060H
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
searchtab DD	03H
	DD	02H
	DD	00H
	DD	04H
	DD	05H
	DD	01H
szError	DB	'ERROR', 00H
	ORG $+2
szNothing DB	'NOTHING', 00H
szDgroup DB	'DGROUP', 00H
CONST	ENDS
_DATA	SEGMENT
$SG5679	DB	'%r %r:%r,%r:%r,%r:%r,%r:%r,%r:%s,%r:%s', 00H
	ORG $+1
$SG5686	DB	'%r %r:%s,%r:%s,%r:%s', 00H
	ORG $+3
$SG5688	DB	'%r %r:%s,%r:%s', 00H
_DATA	ENDS
PUBLIC	SetSegAssumeTable
EXTRN	memcpy:NEAR
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assume.c
_TEXT	SEGMENT
savedstate$ = 8
SetSegAssumeTable PROC NEAR

; 89   : {

	mov	rdx, rcx

; 90   :     DebugMsg(("SetSegAssumeTable\n" ));
; 91   :     memcpy( &SegAssumeTable, savedstate, sizeof(SegAssumeTable) );

	lea	rcx, OFFSET FLAT:SegAssumeTable
	mov	r8d, 96					; 00000060H

; 92   : }

	jmp	memcpy
SetSegAssumeTable ENDP
_TEXT	ENDS
PUBLIC	GetSegAssumeTable
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
savedstate$ = 8
GetSegAssumeTable PROC NEAR

; 96   :     DebugMsg(("GetSegAssumeTable\n" ));
; 97   :     memcpy( savedstate, &SegAssumeTable, sizeof(SegAssumeTable) );

	lea	rdx, OFFSET FLAT:SegAssumeTable
	mov	r8d, 96					; 00000060H

; 98   : }

	jmp	memcpy
GetSegAssumeTable ENDP
_TEXT	ENDS
PUBLIC	SetStdAssumeTable
xdata	SEGMENT
$unwind$SetStdAssumeTable DD 051501H
	DD	097415H
	DD	083409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetStdAssumeTable DD @imagerel($LN9#)
	DD	@imagerel($LN9#+131)
	DD	@imagerel($unwind$SetStdAssumeTable#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
savedstate$ = 48
ti$ = 56
SetStdAssumeTable PROC NEAR

; 109  : {

$LN9:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rbx

; 110  :     int i;
; 111  : 
; 112  :     DebugMsg(("SetStdAssumeTable enter\n" ));
; 113  :     memcpy( &StdAssumeTable, savedstate, sizeof(StdAssumeTable) );

	lea	rbx, OFFSET FLAT:StdAssumeTable
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rdx
	mov	rdx, rcx
	mov	r8d, 256				; 00000100H
	mov	rcx, rbx
	call	memcpy
	lea	rdx, OFFSET FLAT:StdAssumeTable+256
$LL4@SetStdAssu:

; 114  :     for ( i = 0; i < NUM_STDREGS; i++, ti++ ) {
; 115  :         if ( StdAssumeTable[i].symbol ) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN3@SetStdAssu

; 116  :             StdAssumeTable[i].symbol->type        = ti->type;

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rcx+88], rax

; 117  :             StdAssumeTable[i].symbol->target_type = ti->target_type;

	mov	rcx, QWORD PTR [rbx]
	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rcx+56], rax

; 118  :             StdAssumeTable[i].symbol->mem_type    = ti->mem_type;

	mov	rcx, QWORD PTR [rbx]
	mov	eax, DWORD PTR [rdi+16]
	mov	DWORD PTR [rcx+44], eax

; 119  :             StdAssumeTable[i].symbol->ptr_memtype = ti->ptr_memtype;

	mov	rcx, QWORD PTR [rbx]
	movzx	eax, BYTE PTR [rdi+20]
	mov	BYTE PTR [rcx+54], al

; 120  :             StdAssumeTable[i].symbol->is_ptr      = ti->is_ptr;

	mov	rcx, QWORD PTR [rbx]
	movzx	eax, BYTE PTR [rdi+21]
	mov	BYTE PTR [rcx+53], al
$LN3@SetStdAssu:
	add	rbx, 16
	add	rdi, 24
	cmp	rbx, rdx
	jl	SHORT $LL4@SetStdAssu
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 121  :         }
; 122  :     }
; 123  : }

	add	rsp, 40					; 00000028H
	ret	0
SetStdAssumeTable ENDP
_TEXT	ENDS
PUBLIC	GetStdAssumeTable
xdata	SEGMENT
$unwind$GetStdAssumeTable DD 051501H
	DD	097415H
	DD	083409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$GetStdAssumeTable DD @imagerel($LN9#)
	DD	@imagerel($LN9#+131)
	DD	@imagerel($unwind$GetStdAssumeTable#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
savedstate$ = 48
ti$ = 56
GetStdAssumeTable PROC NEAR

; 127  : {

$LN9:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rbx

; 128  :     int i;
; 129  :     DebugMsg(("GetStdAssumeTable\n" ));
; 130  :     memcpy( savedstate, &StdAssumeTable, sizeof(StdAssumeTable) );

	lea	rbx, OFFSET FLAT:StdAssumeTable
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rdx
	mov	r8d, 256				; 00000100H
	mov	rdx, rbx
	call	memcpy
	lea	rdx, OFFSET FLAT:StdAssumeTable+256
	npad	3
$LL4@GetStdAssu:

; 131  :     for ( i = 0; i < NUM_STDREGS; i++, ti++ ) {
; 132  :         if ( StdAssumeTable[i].symbol ) {

	mov	rax, QWORD PTR [rbx]
	test	rax, rax
	je	SHORT $LN3@GetStdAssu

; 133  :             ti->type        = StdAssumeTable[i].symbol->type;

	mov	rax, QWORD PTR [rax+88]
	mov	QWORD PTR [rdi], rax

; 134  :             ti->target_type = StdAssumeTable[i].symbol->target_type;

	mov	rax, QWORD PTR [rbx]
	mov	rcx, QWORD PTR [rax+56]
	mov	QWORD PTR [rdi+8], rcx

; 135  :             ti->mem_type    = StdAssumeTable[i].symbol->mem_type;

	mov	rax, QWORD PTR [rbx]
	mov	ecx, DWORD PTR [rax+44]
	mov	DWORD PTR [rdi+16], ecx

; 136  :             ti->ptr_memtype = StdAssumeTable[i].symbol->ptr_memtype;

	mov	rax, QWORD PTR [rbx]
	movzx	ecx, BYTE PTR [rax+54]
	mov	BYTE PTR [rdi+20], cl

; 137  :             ti->is_ptr      = StdAssumeTable[i].symbol->is_ptr;

	mov	rax, QWORD PTR [rbx]
	movzx	ecx, BYTE PTR [rax+53]
	mov	BYTE PTR [rdi+21], cl
$LN3@GetStdAssu:
	add	rbx, 16
	add	rdi, 24
	cmp	rbx, rdx
	jl	SHORT $LL4@GetStdAssu
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 138  :         }
; 139  :     }
; 140  : }

	add	rsp, 40					; 00000028H
	ret	0
GetStdAssumeTable ENDP
_TEXT	ENDS
PUBLIC	AssumeSaveState
_BSS	SEGMENT
	ALIGN	4

saved_StdTypeInfo DB 0180H DUP (?)
saved_StdAssumeTable DB 0100H DUP (?)
saved_SegAssumeTable DB 060H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$AssumeSaveState DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$AssumeSaveState DD @imagerel($LN13#)
	DD	@imagerel($LN13#+145)
	DD	@imagerel($unwind$AssumeSaveState#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
AssumeSaveState PROC NEAR

; 145  : {

$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H

; 146  :     GetSegAssumeTable( &saved_SegAssumeTable );

	lea	rcx, OFFSET FLAT:saved_SegAssumeTable
	lea	rdx, OFFSET FLAT:SegAssumeTable
	mov	r8d, 96					; 00000060H
	call	memcpy

; 147  :     GetStdAssumeTable( &saved_StdAssumeTable, saved_StdTypeInfo );

	lea	rbx, OFFSET FLAT:StdAssumeTable
	lea	rcx, OFFSET FLAT:saved_StdAssumeTable
	mov	rdx, rbx
	mov	r8d, 256				; 00000100H
	call	memcpy
	lea	r11, OFFSET FLAT:saved_StdTypeInfo+16
	lea	rdx, OFFSET FLAT:StdAssumeTable+256
	npad	7
$LL8@AssumeSave:
	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN7@AssumeSave
	mov	rax, QWORD PTR [rcx+88]
	mov	QWORD PTR [r11-16], rax
	mov	rax, QWORD PTR [rcx+56]
	mov	QWORD PTR [r11-8], rax
	mov	eax, DWORD PTR [rcx+44]
	mov	DWORD PTR [r11], eax
	movzx	eax, BYTE PTR [rcx+54]
	mov	BYTE PTR [r11+4], al
	movzx	eax, BYTE PTR [rcx+53]
	mov	BYTE PTR [r11+5], al
$LN7@AssumeSave:
	add	rbx, 16
	add	r11, 24
	cmp	rbx, rdx
	jl	SHORT $LL8@AssumeSave

; 148  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
AssumeSaveState ENDP
_TEXT	ENDS
PUBLIC	AssumeInit
EXTRN	UseSavedState:BYTE
EXTRN	memset:NEAR
_BSS	SEGMENT
	ALIGN	8

stdsym	DQ	010H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$AssumeInit DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$AssumeInit DD @imagerel($LN27#)
	DD	@imagerel($LN27#+285)
	DD	@imagerel($unwind$AssumeInit#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pass$ = 48
AssumeInit PROC NEAR

; 153  : {

$LN27:
	push	rbx
	sub	rsp, 32					; 00000020H

; 154  :     int reg;
; 155  : 
; 156  :     for( reg = 0; reg < NUM_SEGREGS; reg++ ) {

	lea	rax, OFFSET FLAT:SegAssumeTable+8
	xor	edx, edx
	lea	r8, OFFSET FLAT:SegAssumeTable+104
	npad	10
$LL9@AssumeInit:

; 157  :         SegAssumeTable[reg].symbol = NULL;

	mov	QWORD PTR [rax-8], rdx

; 158  :         SegAssumeTable[reg].error = FALSE;

	mov	BYTE PTR [rax], dl

; 159  :         SegAssumeTable[reg].is_flat = FALSE;

	mov	BYTE PTR [rax+1], dl
	add	rax, 16
	cmp	rax, r8
	jl	SHORT $LL9@AssumeInit

; 160  :     }
; 161  : 
; 162  :     /* the GPR assumes are handled somewhat special by masm.
; 163  :      * they aren't reset for each pass - instead they keep their value.
; 164  :      */
; 165  : 
; 166  :     if ( pass <= PASS_1 ) { /* v2.10: just reset assumes in pass one */

	test	ecx, ecx
	jg	SHORT $LN26@AssumeInit

; 167  : 
; 168  :         for( reg = 0; reg < NUM_STDREGS; reg++ ) {
; 169  :             StdAssumeTable[reg].symbol = NULL;

	lea	rax, OFFSET FLAT:StdAssumeTable+8
	lea	r8, OFFSET FLAT:StdAssumeTable+264
	npad	12
$LL5@AssumeInit:
	mov	QWORD PTR [rax-8], rdx

; 170  :             StdAssumeTable[reg].error = 0;

	mov	BYTE PTR [rax], dl
	add	rax, 16
	cmp	rax, r8
	jl	SHORT $LL5@AssumeInit

; 171  :         }
; 172  :         if ( pass == PASS_1 )

	test	ecx, ecx
	jne	$LN15@AssumeInit

; 173  :             memset( &stdsym, 0, sizeof( stdsym ) );

	lea	rcx, OFFSET FLAT:stdsym
	mov	r8d, 128				; 00000080H

; 199  :     }
; 200  : #endif
; 201  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	memset
$LN26@AssumeInit:

; 174  :     }
; 175  : #if FASTPASS
; 176  :     if ( pass > PASS_1 && UseSavedState ) {

	cmp	BYTE PTR UseSavedState, dl
	je	$LN15@AssumeInit

; 177  :         SetSegAssumeTable( &saved_SegAssumeTable );

	lea	rcx, OFFSET FLAT:SegAssumeTable
	lea	rdx, OFFSET FLAT:saved_SegAssumeTable
	mov	r8d, 96					; 00000060H
	call	memcpy

; 178  : #if 0
; 179  :         /* v2.10: this is a weird Masm feature:
; 180  :          * if a GPR is assumed to be a pointer to a struct,
; 181  :          * it isn't reset when a new pass starts.
; 182  :          * see assume11.asm and assume12.asm
; 183  :          */
; 184  :         if ( pass == PASS_2 ) {
; 185  :             struct assume_info *psaved = &saved_StdAssumeTable;
; 186  :             struct stdassume_typeinfo *ptype = &saved_StdTypeInfo;
; 187  :             for ( reg = 0; reg < NUM_STDREGS; reg++, psaved++, ptype++ )
; 188  :                 if ( psaved->symbol == NULL && StdAssumeTable[reg].symbol && StdAssumeTable[reg].symbol->target_type ) {
; 189  :                     psaved->symbol = StdAssumeTable[reg].symbol;
; 190  :                     ptype->type        = psaved->symbol->type;
; 191  :                     ptype->target_type = psaved->symbol->target_type;
; 192  :                     ptype->mem_type    = psaved->symbol->mem_type;
; 193  :                     ptype->ptr_memtype = psaved->symbol->ptr_memtype;
; 194  :                     ptype->is_ptr      = psaved->symbol->is_ptr;
; 195  :                 }
; 196  :         }
; 197  : #endif
; 198  :         SetStdAssumeTable( &saved_StdAssumeTable, saved_StdTypeInfo );

	lea	rbx, OFFSET FLAT:StdAssumeTable
	lea	rdx, OFFSET FLAT:saved_StdAssumeTable
	mov	rcx, rbx
	mov	r8d, 256				; 00000100H
	call	memcpy
	lea	r11, OFFSET FLAT:saved_StdTypeInfo+16
	lea	rdx, OFFSET FLAT:StdAssumeTable+256
	npad	3
$LL17@AssumeInit:
	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN16@AssumeInit
	mov	rax, QWORD PTR [r11-16]
	mov	QWORD PTR [rcx+88], rax
	mov	rcx, QWORD PTR [rbx]
	mov	rax, QWORD PTR [r11-8]
	mov	QWORD PTR [rcx+56], rax
	mov	rcx, QWORD PTR [rbx]
	mov	eax, DWORD PTR [r11]
	mov	DWORD PTR [rcx+44], eax
	mov	rcx, QWORD PTR [rbx]
	movzx	eax, BYTE PTR [r11+4]
	mov	BYTE PTR [rcx+54], al
	mov	rcx, QWORD PTR [rbx]
	movzx	eax, BYTE PTR [r11+5]
	mov	BYTE PTR [rcx+53], al
$LN16@AssumeInit:
	add	rbx, 16
	add	r11, 24
	cmp	rbx, rdx
	jl	SHORT $LL17@AssumeInit
$LN15@AssumeInit:

; 199  :     }
; 200  : #endif
; 201  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
AssumeInit ENDP
_TEXT	ENDS
PUBLIC	ModelAssumeInit
EXTRN	SimGetSegName:NEAR
EXTRN	Options:BYTE
EXTRN	AddLineQueueX:NEAR
EXTRN	ModuleInfo:BYTE
xdata	SEGMENT
$unwind$ModelAssumeInit DD 020601H
	DD	03002d206H
xdata	ENDS
pdata	SEGMENT
$pdata$ModelAssumeInit DD @imagerel($LN14#)
	DD	@imagerel($LN14#+288)
	DD	@imagerel($unwind$ModelAssumeInit#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
ModelAssumeInit PROC NEAR

; 208  : {

$LN14:
	push	rbx
	sub	rsp, 112				; 00000070H

; 209  :     const char *pCS;
; 210  :     const char *pFSassume = szError;
; 211  :     const char *pGSassume = szError;
; 212  :     const char *pFmt;
; 213  : 
; 214  :     /* Generates codes for assume */
; 215  :     switch( ModuleInfo.model ) {

	mov	eax, DWORD PTR ModuleInfo+360
	lea	rcx, OFFSET FLAT:szError
	test	eax, eax
	jle	$LN5@ModelAssum
	cmp	eax, 6
	jle	$LN7@ModelAssum
	cmp	eax, 7
	jne	$LN5@ModelAssum

; 216  :     case MODEL_FLAT:
; 217  : #if AMD64_SUPPORT
; 218  :         if ( ModuleInfo.fctype == FCT_WIN64 )

	cmp	DWORD PTR ModuleInfo+376, 2
	lea	rax, OFFSET FLAT:szNothing

; 219  :             pGSassume = szNothing;
; 220  : #endif
; 221  :         AddLineQueueX( "%r %r:%r,%r:%r,%r:%r,%r:%r,%r:%s,%r:%s",
; 222  :                   T_ASSUME, T_CS, T_FLAT, T_DS, T_FLAT, T_SS, T_FLAT, T_ES, T_FLAT, T_FS, pFSassume, T_GS, pGSassume );

	mov	edx, 444				; 000001bcH
	cmovne	rax, rcx
	mov	r9d, 261				; 00000105H
	mov	r8d, 26
	mov	QWORD PTR [rsp+104], rax
	mov	DWORD PTR [rsp+96], 30
	mov	QWORD PTR [rsp+88], rcx
	mov	DWORD PTR [rsp+80], 29
	mov	DWORD PTR [rsp+72], 261			; 00000105H
	mov	DWORD PTR [rsp+64], 25
	mov	DWORD PTR [rsp+56], 261			; 00000105H
	mov	DWORD PTR [rsp+48], 27
	lea	rcx, OFFSET FLAT:$SG5679
	mov	DWORD PTR [rsp+40], 261			; 00000105H
	mov	DWORD PTR [rsp+32], 28
	call	AddLineQueueX

; 249  :         break;
; 250  :     }
; 251  : }

	add	rsp, 112				; 00000070H
	pop	rbx
	ret	0
$LN7@ModelAssum:

; 223  :         break;
; 224  :     case MODEL_TINY:
; 225  :     case MODEL_SMALL:
; 226  :     case MODEL_COMPACT:
; 227  :     case MODEL_MEDIUM:
; 228  :     case MODEL_LARGE:
; 229  :     case MODEL_HUGE:
; 230  :         /* v2.03: no DGROUP for COFF/ELF */
; 231  : #if COFF_SUPPORT || ELF_SUPPORT
; 232  :         if( Options.output_format == OFORMAT_COFF
; 233  : #if ELF_SUPPORT
; 234  :            || Options.output_format == OFORMAT_ELF
; 235  : #endif
; 236  :           )

	mov	ecx, DWORD PTR Options+156
	cmp	ecx, 2
	je	SHORT $LN5@ModelAssum
	cmp	ecx, 3
	je	SHORT $LN5@ModelAssum

; 237  :             break;
; 238  : #endif
; 239  :         if ( ModuleInfo.model == MODEL_TINY )

	cmp	eax, 1
	lea	rbx, OFFSET FLAT:szDgroup
	jne	SHORT $LN4@ModelAssum

; 240  :             pCS = szDgroup;

	mov	rax, rbx

; 241  :         else

	jmp	SHORT $LN3@ModelAssum
$LN4@ModelAssum:

; 242  :             pCS = SimGetSegName( SIM_CODE );

	xor	ecx, ecx
	call	SimGetSegName
$LN3@ModelAssum:

; 243  : 
; 244  :         if ( ModuleInfo.distance != STACK_FAR )

	cmp	DWORD PTR ModuleInfo+356, 1
	lea	rdx, OFFSET FLAT:$SG5688

; 245  :             pFmt = "%r %r:%s,%r:%s,%r:%s";
; 246  :         else
; 247  :             pFmt = "%r %r:%s,%r:%s";
; 248  :         AddLineQueueX( pFmt, T_ASSUME, T_CS, pCS, T_DS, szDgroup, T_SS, szDgroup );

	mov	QWORD PTR [rsp+56], rbx
	mov	DWORD PTR [rsp+48], 27
	lea	rcx, OFFSET FLAT:$SG5686
	mov	r9, rax
	cmove	rcx, rdx
	mov	r8d, 26
	mov	edx, 444				; 000001bcH
	mov	QWORD PTR [rsp+40], rbx
	mov	DWORD PTR [rsp+32], 28
	call	AddLineQueueX
$LN5@ModelAssum:

; 249  :         break;
; 250  :     }
; 251  : }

	add	rsp, 112				; 00000070H
	pop	rbx
	ret	0
ModelAssumeInit ENDP
_TEXT	ENDS
PUBLIC	GetStdAssume
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
reg$ = 8
GetStdAssume PROC NEAR

; 258  :     if ( StdAssumeTable[reg].symbol )

	movsxd	rax, ecx
	lea	rcx, OFFSET FLAT:StdAssumeTable
	add	rax, rax
	mov	rax, QWORD PTR [rcx+rax*8]
	test	rax, rax
	je	SHORT $LN1@GetStdAssu@2

; 259  :         if ( StdAssumeTable[reg].symbol->mem_type == MT_TYPE )

	cmp	DWORD PTR [rax+44], 196			; 000000c4H
	jne	SHORT $LN2@GetStdAssu@2

; 260  :             return( StdAssumeTable[reg].symbol->type );

	mov	rax, QWORD PTR [rax+88]

; 264  : }

	ret	0
$LN2@GetStdAssu@2:

; 261  :         else
; 262  :             return( StdAssumeTable[reg].symbol->target_type );

	mov	rax, QWORD PTR [rax+56]

; 264  : }

	ret	0
$LN1@GetStdAssu@2:

; 263  :     return ( NULL );

	xor	eax, eax

; 264  : }

	ret	0
GetStdAssume ENDP
_TEXT	ENDS
PUBLIC	GetStdAssumeEx
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
reg$ = 8
GetStdAssumeEx PROC NEAR

; 273  :   if (reg >= NUM_STDREGS)

	cmp	ecx, 16
	jl	SHORT $LN1@GetStdAssu@3

; 274  :     return NULL;

	xor	eax, eax

; 276  : }

	ret	0
$LN1@GetStdAssu@3:

; 275  :   return(StdAssumeTable[reg].symbol);

	movsxd	rax, ecx
	lea	rcx, OFFSET FLAT:StdAssumeTable
	add	rax, rax
	mov	rax, QWORD PTR [rcx+rax*8]

; 276  : }

	ret	0
GetStdAssumeEx ENDP
_TEXT	ENDS
PUBLIC	AssumeDirective
EXTRN	EmitErr:NEAR
EXTRN	StoreLine:NEAR
EXTRN	Parse_Pass:DWORD
EXTRN	EvalOperand:NEAR
EXTRN	CreateTypeSymbol:NEAR
EXTRN	EmitError:NEAR
EXTRN	OperandSize:NEAR
EXTRN	GetQualifiedType:NEAR
EXTRN	SpecialTable:BYTE
EXTRN	_stricmp:NEAR
EXTRN	__ImageBase:BYTE
xdata	SEGMENT
$unwind$AssumeDirective DD 0123501H
	DD	019f435H
	DD	01ae431H
	DD	01bd42dH
	DD	01cc41eH
	DD	01d741aH
	DD	01e6416H
	DD	0235412H
	DD	022340eH
	DD	01f010aH
xdata	ENDS
pdata	SEGMENT
$pdata$AssumeDirective DD @imagerel($LN95#)
	DD	@imagerel($LN95#+1663)
	DD	@imagerel($unwind$AssumeDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
ti$ = 48
opnd$5752 = 80
i$ = 256
tokenarray$ = 264
AssumeDirective PROC NEAR

; 287  : {

$LN95:
	mov	rax, rsp
	sub	rsp, 248				; 000000f8H
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax+32], rbp
	mov	QWORD PTR [rax-8], rsi
	mov	QWORD PTR [rax-16], rdi
	mov	QWORD PTR [rax-24], r12

; 288  :     int             reg;
; 289  :     int             j;
; 290  :     int             size;
; 291  :     uint_32         flags;
; 292  :     struct assume_info *info;
; 293  :     bool            segtable;
; 294  :     struct qualified_type ti;
; 295  : 
; 296  :     DebugMsg1(( "AssumeDirective enter, pass=%u\n", Parse_Pass+1 ));
; 297  : 
; 298  :     for( i++; i < Token_Count; i++ ) {

	lea	r8d, DWORD PTR [rcx+1]
	cmp	r8d, DWORD PTR ModuleInfo+496
	mov	QWORD PTR [rax-32], r13
	mov	QWORD PTR [rax-40], r14
	mov	QWORD PTR [rax-48], r15
	mov	r12, rdx
	mov	DWORD PTR [rax+8], r8d
	jge	$LN1@AssumeDire
	lea	r14, OFFSET FLAT:__ImageBase
	lea	rdx, OFFSET FLAT:SegAssumeTable
	lea	r9, OFFSET FLAT:StdAssumeTable
	xor	r15d, r15d
	npad	6
$LL50@AssumeDire:

; 299  : 
; 300  :         if( ( tokenarray[i].token == T_ID )
; 301  :             && (0 == _stricmp( tokenarray[i].string_ptr, szNothing )) ) {

	movsxd	rcx, r8d
	shl	rcx, 5
	cmp	BYTE PTR [rcx+r12], 8
	jne	SHORT $LN47@AssumeDire
	mov	rcx, QWORD PTR [rcx+r12+8]
	lea	rdx, OFFSET FLAT:szNothing
	call	_stricmp
	test	eax, eax
	je	$LN81@AssumeDire
	mov	r8d, DWORD PTR i$[rsp]
	lea	rdx, OFFSET FLAT:SegAssumeTable
	lea	r9, OFFSET FLAT:StdAssumeTable
$LN47@AssumeDire:

; 305  :         }
; 306  : 
; 307  :         /*---- get the info ptr for the register ----*/
; 308  : 
; 309  :         info = NULL;
; 310  :         if ( tokenarray[i].token == T_REG ) {

	movsxd	rax, r8d
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], 2
	jne	$LN82@AssumeDire

; 311  :             reg = tokenarray[i].tokval;

	movsxd	r13, DWORD PTR [rax+r12+16]

; 312  :             j = GetRegNo( reg );

	lea	rcx, QWORD PTR [r13+r13*2]

; 313  :             flags = GetValueSp( reg );

	mov	edi, DWORD PTR SpecialTable[r14+rcx*4]
	movzx	eax, BYTE PTR SpecialTable[r14+rcx*4+10]

; 314  :             if ( flags & OP_SR ) {

	test	edi, 24576				; 00006000H
	je	SHORT $LN45@AssumeDire

; 315  :                 info = &SegAssumeTable[j];

	movsxd	rsi, eax

; 316  :                 segtable = TRUE;

	mov	bpl, 1
	mov	rbx, rsi
	shl	rbx, 4
	add	rbx, rdx
	jmp	SHORT $LN43@AssumeDire
$LN45@AssumeDire:

; 317  :             } else if ( flags & OP_R ) {

	test	dil, 15
	je	$LN82@AssumeDire

; 318  :                 info = &StdAssumeTable[j];

	mov	rbx, rax
	mov	rsi, rax
	shl	rbx, 4
	add	rbx, r9

; 319  :                 segtable = FALSE;

	xor	bpl, bpl
$LN43@AssumeDire:

; 320  :             }
; 321  :         }
; 322  :         if ( info == NULL ) {

	test	rbx, rbx
	je	$LN82@AssumeDire

; 324  :         }
; 325  : 
; 326  :         if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) < GetCpuSp( reg ) ) {

	mov	eax, DWORD PTR ModuleInfo+392
	movzx	ecx, WORD PTR SpecialTable[r14+rcx*4+8]
	and	eax, 240				; 000000f0H
	cmp	eax, ecx
	jl	$LN83@AssumeDire

; 328  :         }
; 329  : 
; 330  :         i++; /* go past register */

	inc	r8d

; 331  : 
; 332  :         if( tokenarray[i].token != T_COLON ) {

	movsxd	rax, r8d
	mov	DWORD PTR i$[rsp], r8d
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], 58			; 0000003aH
	jne	$LN84@AssumeDire

; 334  :         }
; 335  :         i++;

	inc	r8d

; 336  : 
; 337  :         if( tokenarray[i].token == T_FINAL ) {

	movsxd	rcx, r8d
	mov	DWORD PTR i$[rsp], r8d
	shl	rcx, 5
	cmp	BYTE PTR [rcx+r12], r15b
	je	$LN85@AssumeDire

; 339  :         }
; 340  : 
; 341  :         /* check for ERROR and NOTHING */
; 342  : 
; 343  :         if( 0 == _stricmp( tokenarray[i].string_ptr, szError )) {

	mov	rcx, QWORD PTR [rcx+r12+8]
	lea	rdx, OFFSET FLAT:szError
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN38@AssumeDire

; 344  :             if ( segtable ) {

	test	bpl, bpl
	je	SHORT $LN37@AssumeDire

; 349  :             info->symbol = NULL;
; 350  :             i++;

	mov	r8d, DWORD PTR i$[rsp]
	mov	BYTE PTR [rbx+9], r15b
	mov	BYTE PTR [rbx+8], 1
	inc	r8d
	mov	QWORD PTR [rbx], r15
	mov	DWORD PTR i$[rsp], r8d
	jmp	$LN22@AssumeDire
$LN37@AssumeDire:

; 345  :                 info->is_flat = FALSE;
; 346  :                 info->error = TRUE;
; 347  :             } else
; 348  :                 info->error |= (( reg >= T_AH && reg <= T_BH ) ? RH_ERROR : ( flags & OP_R ));

	lea	eax, DWORD PTR [r13-5]
	cmp	eax, 3
	ja	SHORT $LN53@AssumeDire
	mov	edi, 16
	jmp	SHORT $LN54@AssumeDire
$LN53@AssumeDire:
	and	edi, 15
$LN54@AssumeDire:

; 349  :             info->symbol = NULL;
; 350  :             i++;

	mov	r8d, DWORD PTR i$[rsp]
	or	BYTE PTR [rbx+8], dil
	mov	QWORD PTR [rbx], r15
	inc	r8d
	mov	DWORD PTR i$[rsp], r8d
	jmp	$LN22@AssumeDire
$LN38@AssumeDire:

; 351  :         } else if( 0 == _stricmp( tokenarray[i].string_ptr, szNothing )) {

	movsxd	rcx, DWORD PTR i$[rsp]
	lea	rdx, OFFSET FLAT:szNothing
	shl	rcx, 5
	mov	rcx, QWORD PTR [rcx+r12+8]
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN34@AssumeDire

; 352  :             if ( segtable ) {

	test	bpl, bpl
	je	SHORT $LN33@AssumeDire

; 357  :             info->symbol = NULL;
; 358  :             i++;

	mov	r8d, DWORD PTR i$[rsp]
	mov	BYTE PTR [rbx+9], r15b
	mov	BYTE PTR [rbx+8], r15b
	inc	r8d
	mov	QWORD PTR [rbx], r15
	mov	DWORD PTR i$[rsp], r8d
	jmp	$LN22@AssumeDire
$LN33@AssumeDire:

; 353  :                 info->is_flat = FALSE;
; 354  :                 info->error = FALSE;
; 355  :             } else
; 356  :                 info->error &= ~(( reg >= T_AH && reg <= T_BH ) ? RH_ERROR : ( flags & OP_R ));

	lea	eax, DWORD PTR [r13-5]
	cmp	eax, 3
	ja	SHORT $LN55@AssumeDire
	mov	edi, 16
	jmp	SHORT $LN56@AssumeDire
$LN55@AssumeDire:
	and	edi, 15
$LN56@AssumeDire:

; 357  :             info->symbol = NULL;
; 358  :             i++;

	mov	r8d, DWORD PTR i$[rsp]
	not	dil
	mov	QWORD PTR [rbx], r15
	and	BYTE PTR [rbx+8], dil
	inc	r8d
	mov	DWORD PTR i$[rsp], r8d
	jmp	$LN22@AssumeDire
$LN34@AssumeDire:

; 359  :         } else if ( segtable == FALSE ) {

	test	bpl, bpl
	jne	$LN30@AssumeDire

; 360  : 
; 361  :             /* v2.05: changed to use new GetQualifiedType() function */
; 362  :             ti.size = 0;
; 363  :             ti.is_ptr = 0;
; 364  :             ti.is_far = FALSE;
; 365  :             ti.mem_type = MT_EMPTY;
; 366  :             ti.ptr_memtype = MT_EMPTY;
; 367  :             ti.symtype = NULL;
; 368  :             ti.Ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404

; 369  :             if ( GetQualifiedType( &i, tokenarray, &ti ) == ERROR )

	lea	r8, QWORD PTR ti$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, r12
	mov	DWORD PTR ti$[rsp], r15d
	mov	BYTE PTR ti$[rsp+20], r15b
	mov	BYTE PTR ti$[rsp+22], al
	mov	BYTE PTR ti$[rsp+21], r15b
	mov	DWORD PTR ti$[rsp+16], 192		; 000000c0H
	mov	DWORD PTR ti$[rsp+24], 192		; 000000c0H
	mov	QWORD PTR ti$[rsp+8], r15
	call	GetQualifiedType
	cmp	eax, -1
	je	$LN87@AssumeDire

; 370  :                 return( ERROR );
; 371  : 
; 372  :             /* v2.04: check size of argument! */
; 373  :             size = OperandSize( flags, NULL );

	xor	edx, edx
	mov	ecx, edi
	call	OperandSize

; 374  :             if ( ( ti.is_ptr == 0 && size != ti.size ) ||
; 375  :                 ( ti.is_ptr > 0 && size < CurrWordSize ) ) {

	mov	ecx, DWORD PTR ti$[rsp]
	mov	r11d, eax
	movzx	eax, BYTE PTR ti$[rsp+20]
	test	al, al
	jne	SHORT $LN26@AssumeDire
	cmp	r11d, ecx
	je	SHORT $LN28@AssumeDire
$LN27@AssumeDire:

; 376  :                 return( EmitError( TYPE_IS_WRONG_SIZE_FOR_REGISTER ) );

	mov	ecx, 247				; 000000f7H
	call	EmitError
	jmp	$LN51@AssumeDire
$LN26@AssumeDire:

; 374  :             if ( ( ti.is_ptr == 0 && size != ti.size ) ||
; 375  :                 ( ti.is_ptr > 0 && size < CurrWordSize ) ) {

	test	al, al
	je	SHORT $LN28@AssumeDire
	movzx	eax, BYTE PTR ModuleInfo+406
	cmp	r11d, eax
	jl	SHORT $LN27@AssumeDire
$LN28@AssumeDire:

; 377  :             }
; 378  :             info->error &= ~(( reg >= T_AH && reg <= T_BH ) ? RH_ERROR : ( flags & OP_R ));

	lea	eax, DWORD PTR [r13-5]
	cmp	eax, 3
	ja	SHORT $LN57@AssumeDire
	mov	edi, 16
	jmp	SHORT $LN58@AssumeDire
$LN57@AssumeDire:
	and	edi, 15
$LN58@AssumeDire:
	not	dil
	and	BYTE PTR [rbx+8], dil

; 379  :             if ( stdsym[j] == NULL ) {

	cmp	QWORD PTR stdsym[r14+rsi*8], r15
	jne	SHORT $LN25@AssumeDire

; 380  :                 stdsym[j] = CreateTypeSymbol( NULL, "", FALSE );

	lea	rdx, OFFSET FLAT:$SG5748
	xor	r8d, r8d
	xor	ecx, ecx
	call	CreateTypeSymbol
	mov	QWORD PTR stdsym[r14+rsi*8], rax

; 381  :                 stdsym[j]->typekind = TYPE_TYPEDEF;

	mov	BYTE PTR [rax+74], 3
	mov	ecx, DWORD PTR ti$[rsp]
$LN25@AssumeDire:

; 382  :             }
; 383  : 
; 384  :             stdsym[j]->total_size = ti.size;

	mov	rax, QWORD PTR stdsym[r14+rsi*8]
	mov	DWORD PTR [rax+64], ecx

; 385  :             stdsym[j]->mem_type   = ti.mem_type;

	mov	rcx, QWORD PTR stdsym[r14+rsi*8]
	mov	eax, DWORD PTR ti$[rsp+16]
	mov	DWORD PTR [rcx+44], eax

; 386  :             stdsym[j]->is_ptr     = ti.is_ptr;

	mov	rcx, QWORD PTR stdsym[r14+rsi*8]
	movzx	eax, BYTE PTR ti$[rsp+20]
	mov	BYTE PTR [rcx+53], al

; 387  :             stdsym[j]->isfar      = ti.is_far;

	mov	rcx, QWORD PTR stdsym[r14+rsi*8]
	movzx	eax, BYTE PTR ti$[rsp+21]
	shl	al, 4
	xor	al, BYTE PTR [rcx+55]
	and	al, 16
	xor	BYTE PTR [rcx+55], al

; 388  :             stdsym[j]->Ofssize    = ti.Ofssize;

	mov	rcx, QWORD PTR stdsym[r14+rsi*8]
	movzx	eax, BYTE PTR ti$[rsp+22]
	mov	BYTE PTR [rcx+52], al

; 389  :             stdsym[j]->ptr_memtype = ti.ptr_memtype; /* added v2.05 rc13 */

	mov	rcx, QWORD PTR stdsym[r14+rsi*8]
	movzx	eax, BYTE PTR ti$[rsp+24]
	mov	BYTE PTR [rcx+54], al

; 390  :             if ( ti.mem_type == MT_TYPE )

	cmp	DWORD PTR ti$[rsp+16], 196		; 000000c4H
	jne	SHORT $LN24@AssumeDire

; 391  :                 stdsym[j]->type = ti.symtype;

	mov	rax, QWORD PTR ti$[rsp+8]
	mov	rcx, QWORD PTR stdsym[r14+rsi*8]
	mov	QWORD PTR [rcx+88], rax

; 394  : 
; 395  :             info->symbol = stdsym[j];

	mov	rax, QWORD PTR stdsym[r14+rsi*8]

; 396  : 
; 397  :         } else { /* segment register */

	mov	r8d, DWORD PTR i$[rsp]
	mov	QWORD PTR [rbx], rax
	jmp	$LN22@AssumeDire
$LN24@AssumeDire:

; 392  :             else
; 393  :                 stdsym[j]->target_type = ti.symtype;

	mov	rax, QWORD PTR ti$[rsp+8]
	mov	rcx, QWORD PTR stdsym[r14+rsi*8]
	mov	QWORD PTR [rcx+56], rax

; 394  : 
; 395  :             info->symbol = stdsym[j];

	mov	rax, QWORD PTR stdsym[r14+rsi*8]

; 396  : 
; 397  :         } else { /* segment register */

	mov	r8d, DWORD PTR i$[rsp]
	mov	QWORD PTR [rbx], rax
	jmp	$LN22@AssumeDire
$LN30@AssumeDire:

; 398  :             struct expr opnd;
; 399  : 
; 400  :             /* v2.08: read expression with standard evaluator */
; 401  :             if( EvalOperand( &i, tokenarray, Token_Count, &opnd, 0 ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opnd$5752[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, r12
	mov	BYTE PTR [rsp+32], r15b
	call	EvalOperand
	cmp	eax, -1
	je	$LN87@AssumeDire

; 403  :             switch ( opnd.kind ) {

	mov	ecx, DWORD PTR opnd$5752[rsp+60]
	dec	ecx
	je	SHORT $LN18@AssumeDire
	dec	ecx
	jne	$LN4@AssumeDire

; 421  :                 break;
; 422  :             case EXPR_REG:
; 423  :                 if ( GetValueSp( opnd.base_reg->tokval ) & OP_SR ) {

	mov	rdx, QWORD PTR opnd$5752[rsp+24]
	mov	eax, DWORD PTR [rdx+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	test	DWORD PTR SpecialTable[r14+rcx*4], 24576 ; 00006000H
	je	$LN4@AssumeDire

; 424  :                     info->symbol = SegAssumeTable[ GetRegNo( opnd.base_reg->tokval ) ].symbol;

	mov	eax, DWORD PTR [rdx+16]
	lea	r8, OFFSET FLAT:SegAssumeTable
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR SpecialTable[r14+rcx*4+10]
	add	rax, rax
	mov	rax, QWORD PTR [r8+rax*8]
	mov	QWORD PTR [rbx], rax

; 425  :                     info->is_flat = SegAssumeTable[ GetRegNo( opnd.base_reg->tokval ) ].is_flat;

	mov	eax, DWORD PTR [rdx+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR SpecialTable[r14+rcx*4+10]
	add	rax, rax
	movzx	eax, BYTE PTR [r8+rax*8+9]
	mov	BYTE PTR [rbx+9], al

; 426  :                     break;

	jmp	$LN19@AssumeDire
$LN18@AssumeDire:

; 404  :             case EXPR_ADDR:
; 405  :                 if ( opnd.sym == NULL || opnd.indirect == TRUE || opnd.value ) {

	mov	rax, QWORD PTR opnd$5752[rsp+80]
	test	rax, rax
	je	$LN4@AssumeDire
	test	BYTE PTR opnd$5752[rsp+72], 1
	jne	$LN4@AssumeDire
	cmp	DWORD PTR opnd$5752[rsp], r15d
	jne	$LN4@AssumeDire

; 406  :                     return( EmitError( SEGMENT_GROUP_OR_SEGREG_EXPECTED ) );
; 407  :                 } else if ( opnd.sym->state == SYM_UNDEFINED ) {

	mov	ecx, DWORD PTR [rax+40]
	test	ecx, ecx
	jne	SHORT $LN14@AssumeDire

; 408  :                     /* ensure that directive is rerun in pass 2
; 409  :                      * so an error msg can be emitted.
; 410  :                      */
; 411  :                     FStoreLine( 0 );

	cmp	DWORD PTR Parse_Pass, r15d
	jne	SHORT $LN13@AssumeDire
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	xor	edx, edx
	call	StoreLine
	mov	rax, QWORD PTR opnd$5752[rsp+80]
$LN13@AssumeDire:

; 412  :                     info->symbol = opnd.sym;

	mov	QWORD PTR [rbx], rax
	jmp	SHORT $LN6@AssumeDire
$LN14@AssumeDire:

; 413  :                 } else if ( ( opnd.sym->state == SYM_SEG || opnd.sym->state == SYM_GRP ) && opnd.instr == EMPTY ) {

	cmp	ecx, 3
	mov	edx, DWORD PTR opnd$5752[rsp+56]
	je	SHORT $LN9@AssumeDire
	cmp	ecx, 4
	jne	SHORT $LN10@AssumeDire
$LN9@AssumeDire:
	cmp	edx, -2
	jne	SHORT $LN10@AssumeDire

; 414  :                     info->symbol = opnd.sym;

	mov	QWORD PTR [rbx], rax
	jmp	SHORT $LN6@AssumeDire
$LN10@AssumeDire:

; 415  :                 } else if ( opnd.instr == T_SEG ) {

	cmp	edx, 244				; 000000f4H
	jne	$LN4@AssumeDire

; 416  :                     info->symbol = opnd.sym->segment;

	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR [rbx], rax
$LN6@AssumeDire:

; 417  :                 } else {
; 418  :                     return( EmitError( SEGMENT_GROUP_OR_SEGREG_EXPECTED ) );
; 419  :                 }
; 420  :                 info->is_flat = ( info->symbol == &ModuleInfo.flat_grp->sym );

	mov	rax, QWORD PTR ModuleInfo+440
	cmp	QWORD PTR [rbx], rax
	sete	al
	mov	BYTE PTR [rbx+9], al
$LN19@AssumeDire:

; 430  :             }
; 431  :             info->error = FALSE;

	mov	r8d, DWORD PTR i$[rsp]
	mov	BYTE PTR [rbx+8], r15b
$LN22@AssumeDire:

; 432  :         }
; 433  : 
; 434  :         /* comma expected */
; 435  :         if( i < Token_Count && tokenarray[i].token != T_COMMA )

	mov	ecx, DWORD PTR ModuleInfo+496
	cmp	r8d, ecx
	jge	SHORT $LN49@AssumeDire
	movsxd	rax, r8d
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], 44			; 0000002cH
	jne	$LN48@AssumeDire
$LN49@AssumeDire:

; 288  :     int             reg;
; 289  :     int             j;
; 290  :     int             size;
; 291  :     uint_32         flags;
; 292  :     struct assume_info *info;
; 293  :     bool            segtable;
; 294  :     struct qualified_type ti;
; 295  : 
; 296  :     DebugMsg1(( "AssumeDirective enter, pass=%u\n", Parse_Pass+1 ));
; 297  : 
; 298  :     for( i++; i < Token_Count; i++ ) {

	inc	r8d
	cmp	r8d, ecx
	mov	DWORD PTR i$[rsp], r8d
	jge	$LN1@AssumeDire
	lea	rdx, OFFSET FLAT:SegAssumeTable
	lea	r9, OFFSET FLAT:StdAssumeTable
	jmp	$LL50@AssumeDire
$LN81@AssumeDire:

; 302  :             AssumeInit( -1 );

	lea	rax, OFFSET FLAT:SegAssumeTable+8
	lea	rcx, OFFSET FLAT:SegAssumeTable+104
$LL67@AssumeDire:
	mov	QWORD PTR [rax-8], r15
	mov	BYTE PTR [rax], r15b
	mov	BYTE PTR [rax+1], r15b
	add	rax, 16
	cmp	rax, rcx
	jl	SHORT $LL67@AssumeDire
	lea	rax, OFFSET FLAT:StdAssumeTable+8
	lea	rcx, OFFSET FLAT:StdAssumeTable+264
	npad	14
$LL63@AssumeDire:
	mov	QWORD PTR [rax-8], r15
	mov	BYTE PTR [rax], r15b
	add	rax, 16
	cmp	rax, rcx
	jl	SHORT $LL63@AssumeDire

; 303  :             i++;

	mov	r8d, DWORD PTR i$[rsp]

; 304  :             break;

	mov	ecx, DWORD PTR ModuleInfo+496
	inc	r8d
	mov	DWORD PTR i$[rsp], r8d
$LN48@AssumeDire:

; 436  :             break;
; 437  :     }
; 438  :     if ( i < Token_Count ) {

	cmp	r8d, ecx
	jge	SHORT $LN1@AssumeDire

; 439  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rdx, r8d
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r12+24]
	call	EmitErr
	jmp	SHORT $LN51@AssumeDire
$LN82@AssumeDire:

; 323  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, r8d
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r12+8]
	call	EmitErr
	jmp	SHORT $LN51@AssumeDire
$LN83@AssumeDire:

; 327  :             return( EmitError( INSTRUCTION_OR_REGISTER_NOT_ACCEPTED_IN_CURRENT_CPU_MODE ) );

	mov	ecx, 30
	call	EmitError
	jmp	SHORT $LN51@AssumeDire
$LN84@AssumeDire:

; 333  :             return( EmitError( COLON_EXPECTED ) );

	mov	ecx, 84					; 00000054H
	call	EmitError
	jmp	SHORT $LN51@AssumeDire
$LN85@AssumeDire:

; 338  :             return( EmitError( SYNTAX_ERROR ) );

	mov	ecx, 45					; 0000002dH
	call	EmitError
	jmp	SHORT $LN51@AssumeDire
$LN87@AssumeDire:

; 402  :                 return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN51@AssumeDire
$LN4@AssumeDire:

; 427  :                 }
; 428  :             default:
; 429  :                 return( EmitError( SEGMENT_GROUP_OR_SEGREG_EXPECTED ) );

	mov	ecx, 69					; 00000045H
	call	EmitError
	jmp	SHORT $LN51@AssumeDire
$LN1@AssumeDire:

; 440  :     }
; 441  :     return( NOT_ERROR );

	xor	eax, eax
$LN51@AssumeDire:
	mov	r15, QWORD PTR [rsp+200]
	mov	r14, QWORD PTR [rsp+208]
	mov	r13, QWORD PTR [rsp+216]
	mov	r12, QWORD PTR [rsp+224]
	mov	rdi, QWORD PTR [rsp+232]
	mov	rsi, QWORD PTR [rsp+240]
	mov	rbp, QWORD PTR [rsp+280]
	mov	rbx, QWORD PTR [rsp+272]

; 442  : }

	add	rsp, 248				; 000000f8H
	ret	0
AssumeDirective ENDP
_TEXT	ENDS
PUBLIC	search_assume
EXTRN	GetGroup:NEAR
xdata	SEGMENT
$unwind$search_assume DD 071601H
	DD	097416H
	DD	086411H
	DD	06340cH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$search_assume DD @imagerel($LN28#)
	DD	@imagerel($LN28#+149)
	DD	@imagerel($unwind$search_assume#)
pdata	ENDS
xdata	SEGMENT
$chain$3$search_assume DD 020521H
	DD	075405H
	DD	@imagerel($LN28#)
	DD	@imagerel($LN28#+149)
	DD	@imagerel($unwind$search_assume#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$search_assume DD @imagerel($LN28#+149)
	DD	@imagerel($LN28#+290)
	DD	@imagerel($chain$3$search_assume#)
pdata	ENDS
xdata	SEGMENT
$chain$5$search_assume DD 020021H
	DD	075400H
	DD	@imagerel($LN28#)
	DD	@imagerel($LN28#+149)
	DD	@imagerel($unwind$search_assume#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$search_assume DD @imagerel($LN28#+290)
	DD	@imagerel($LN28#+308)
	DD	@imagerel($chain$5$search_assume#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
def$ = 56
search_grps$ = 64
search_assume PROC NEAR

; 457  : {

$LN28:
	sub	rsp, 40					; 00000028H

; 458  :     struct asym *grp;
; 459  : 
; 460  :     if( sym == NULL )

	test	rcx, rcx
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	movzx	esi, r8b
	movsxd	rbx, edx
	mov	rdi, rcx
	jne	SHORT $LN16@search_ass

; 461  :         return( ASSUME_NOTHING );

	lea	eax, QWORD PTR [rcx-2]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]

; 497  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN16@search_ass:

; 462  : 
; 463  :     grp = GetGroup( sym );

	call	GetGroup

; 464  : 
; 465  :     /* first check the default segment register */
; 466  : 
; 467  :     if( def != ASSUME_NOTHING ) {

	cmp	ebx, -2
	mov	r9, QWORD PTR ModuleInfo+440
	mov	r11, rax
	lea	r10, OFFSET FLAT:SegAssumeTable
	je	SHORT $LN11@search_ass

; 468  :         if( SegAssumeTable[def].symbol == sym )

	mov	rax, rbx
	add	rax, rax
	mov	rcx, QWORD PTR [r10+rax*8]
	cmp	rcx, rdi

; 469  :             return( def );

	je	SHORT $LN27@search_ass

; 470  :         if( search_grps && grp ) {

	test	sil, sil
	je	SHORT $LN11@search_ass
	test	r11, r11
	je	SHORT $LN11@search_ass

; 471  :             if( SegAssumeTable[def].is_flat && grp == &ModuleInfo.flat_grp->sym )

	cmp	BYTE PTR [r10+rax*8+9], 0
	je	SHORT $LN12@search_ass
	cmp	r11, r9

; 472  :                 return( def );

	je	SHORT $LN27@search_ass
$LN12@search_ass:

; 473  :             if( SegAssumeTable[def].symbol == grp )

	cmp	rcx, r11
	jne	SHORT $LN11@search_ass
$LN27@search_ass:

; 474  :                 return( def );

	mov	eax, ebx
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]

; 497  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN11@search_ass:
	mov	QWORD PTR [rsp+56], rbp

; 475  :         }
; 476  :     }
; 477  : 
; 478  :     /* now check all segment registers */
; 479  : 
; 480  :     for( def = 0; def < NUM_SEGREGS; def++ ) {

	lea	rbp, OFFSET FLAT:searchtab
	xor	edx, edx
	mov	rcx, rbp
	mov	r8d, edx
	lea	rbx, OFFSET FLAT:searchtab+24
$LL10@search_ass:

; 481  :         if( SegAssumeTable[searchtab[def]].symbol == sym ) {

	movsxd	rax, DWORD PTR [rcx]
	add	rax, rax
	cmp	QWORD PTR [r10+rax*8], rdi
	je	SHORT $LN21@search_ass
	add	rcx, 4
	inc	r8d
	cmp	rcx, rbx
	jl	SHORT $LL10@search_ass

; 483  :         }
; 484  :     }
; 485  : 
; 486  :     /* now check the groups */
; 487  :     if( search_grps && grp )

	test	sil, sil
	je	SHORT $LN3@search_ass
	test	r11, r11
	je	SHORT $LN3@search_ass

; 488  :         for( def = 0; def < NUM_SEGREGS; def++ ) {

	mov	rax, rbp
	npad	11
$LL5@search_ass:

; 489  :             if( SegAssumeTable[searchtab[def]].is_flat && grp == &ModuleInfo.flat_grp->sym )

	movsxd	rcx, DWORD PTR [rax]
	add	rcx, rcx
	cmp	BYTE PTR [r10+rcx*8+9], 0
	je	SHORT $LN2@search_ass
	cmp	r11, r9
	je	SHORT $LN22@search_ass
$LN2@search_ass:

; 491  :             if( SegAssumeTable[searchtab[def]].symbol == grp ) {

	cmp	QWORD PTR [r10+rcx*8], r11
	je	SHORT $LN22@search_ass
	add	rax, 4
	inc	edx
	cmp	rax, rbx
	jl	SHORT $LL5@search_ass
$LN3@search_ass:

; 492  :                 return( searchtab[def] );
; 493  :             }
; 494  :         }
; 495  : 
; 496  :     return( ASSUME_NOTHING );

	mov	eax, -2
$LN26@search_ass:
	mov	rbp, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]

; 497  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN21@search_ass:

; 482  :             return( searchtab[def] );

	movsxd	rax, r8d
	mov	eax, DWORD PTR [rbp+rax*4]
	jmp	SHORT $LN26@search_ass
$LN22@search_ass:

; 490  :                 return( searchtab[def] );

	movsxd	rax, edx
	mov	eax, DWORD PTR [rbp+rax*4]
	jmp	SHORT $LN26@search_ass
search_assume ENDP
_TEXT	ENDS
PUBLIC	GetOverrideAssume
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
override$ = 8
GetOverrideAssume PROC NEAR

; 508  :     if( SegAssumeTable[override].is_flat ) {

	movsxd	rax, ecx
	lea	rcx, OFFSET FLAT:SegAssumeTable
	add	rax, rax
	cmp	BYTE PTR [rcx+rax*8+9], 0
	je	SHORT $LN1@GetOverrid

; 509  :         return( (struct asym *)ModuleInfo.flat_grp );

	mov	rax, QWORD PTR ModuleInfo+440

; 512  : 
; 513  : }

	ret	0
$LN1@GetOverrid:

; 510  :     }
; 511  :     return( SegAssumeTable[override].symbol);

	mov	rax, QWORD PTR [rcx+rax*8]

; 512  : 
; 513  : }

	ret	0
GetOverrideAssume ENDP
_TEXT	ENDS
PUBLIC	GetAssume
xdata	SEGMENT
$unwind$GetAssume DD 0b2001H
	DD	04c420H
	DD	097418H
	DD	086413H
	DD	07540eH
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$GetAssume DD @imagerel($LN63#)
	DD	@imagerel($LN63#+521)
	DD	@imagerel($unwind$GetAssume#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
override$ = 48
sym$ = 56
def$ = 64
passume$ = 72
GetAssume PROC NEAR

; 527  : {

$LN63:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	movsxd	rbx, r8d
	mov	QWORD PTR [rsp+32], r12

; 528  :     enum assume_segreg  reg;
; 529  : 
; 530  :     if( ( def != ASSUME_NOTHING ) && SegAssumeTable[def].is_flat ) {

	cmp	ebx, -2
	lea	r12, OFFSET FLAT:SegAssumeTable
	mov	rbp, r9
	mov	rsi, rdx
	mov	rdi, rcx
	je	SHORT $LN8@GetAssume
	mov	rax, rbx
	add	rax, rax
	cmp	BYTE PTR [r12+rax*8+9], 0
	je	SHORT $LN8@GetAssume

; 531  :         *passume = (struct asym *)ModuleInfo.flat_grp;

	mov	rax, QWORD PTR ModuleInfo+440
	mov	QWORD PTR [r9], rax

; 532  :         return( def );

	mov	eax, ebx
	jmp	$LN9@GetAssume
$LN8@GetAssume:

; 533  :     }
; 534  :     if( override != NULL ) {

	test	rcx, rcx
	je	SHORT $LN7@GetAssume

; 535  :         reg = search_assume( override, def, FALSE );

	call	GetGroup
	cmp	ebx, -2
	je	SHORT $LN24@GetAssume
	mov	rax, rbx
	add	rax, rax
	cmp	QWORD PTR [r12+rax*8], rdi
	jne	SHORT $LN24@GetAssume
	mov	eax, ebx
	jmp	$LN45@GetAssume
$LN24@GetAssume:
	lea	r9, OFFSET FLAT:searchtab
	xor	edx, edx
	lea	r8, OFFSET FLAT:searchtab+24
	mov	rcx, r9
	npad	7
$LL20@GetAssume:
	movsxd	rax, DWORD PTR [rcx]
	add	rax, rax
	cmp	QWORD PTR [r12+rax*8], rdi
	je	SHORT $LN51@GetAssume
	add	rcx, 4
	inc	edx
	cmp	rcx, r8
	jl	SHORT $LL20@GetAssume

; 543  : #endif
; 544  :     } else {
; 545  :         reg = search_assume( sym->segment, def, TRUE );

	jmp	$LN62@GetAssume
$LN51@GetAssume:

; 535  :         reg = search_assume( override, def, FALSE );

	movsxd	rax, edx
	mov	eax, DWORD PTR [r9+rax*4]
	jmp	$LN45@GetAssume
$LN7@GetAssume:

; 536  : #if 1 /* v2.10: added */
; 537  :     } else if ( sym->state == SYM_STACK ) {

	cmp	DWORD PTR [rdx+40], 5
	jne	SHORT $LN5@GetAssume

; 538  :         /* stack symbols don't have a segment part.
; 539  :          * In case [R|E]BP is used as base, it doesn't matter.
; 540  :          * However, if option -Zg is set, this isn't true.
; 541  :          */
; 542  :         reg = ASSUME_SS;

	mov	eax, 2

; 553  :         *passume = SegAssumeTable[reg].symbol;

	movsxd	rcx, eax
	add	rcx, rcx
	mov	rcx, QWORD PTR [r12+rcx*8]
	mov	QWORD PTR [rbp], rcx

; 554  :         return( reg );

	jmp	$LN9@GetAssume
$LN5@GetAssume:

; 543  : #endif
; 544  :     } else {
; 545  :         reg = search_assume( sym->segment, def, TRUE );

	mov	rdi, QWORD PTR [rdx+32]
	test	rdi, rdi
	je	$LN62@GetAssume
	mov	rcx, rdi
	call	GetGroup
	cmp	ebx, -2
	mov	r10, QWORD PTR ModuleInfo+440
	mov	r11, rax
	je	SHORT $LN39@GetAssume
	mov	rax, rbx
	add	rax, rax
	mov	rcx, QWORD PTR [r12+rax*8]
	cmp	rcx, rdi
	jne	SHORT $LN42@GetAssume
	mov	eax, ebx
	jmp	$LN45@GetAssume
$LN42@GetAssume:
	test	r11, r11
	je	SHORT $LN39@GetAssume
	cmp	BYTE PTR [r12+rax*8+9], 0
	je	SHORT $LN40@GetAssume
	cmp	r11, r10
	jne	SHORT $LN40@GetAssume
	mov	eax, ebx
	jmp	$LN45@GetAssume
$LN40@GetAssume:
	cmp	rcx, r11
	jne	SHORT $LN39@GetAssume
	mov	eax, ebx
	jmp	SHORT $LN45@GetAssume
$LN39@GetAssume:
	lea	r9, OFFSET FLAT:searchtab
	xor	edx, edx
	lea	r8, OFFSET FLAT:searchtab+24
	mov	rcx, r9
	npad	11
$LL38@GetAssume:
	movsxd	rax, DWORD PTR [rcx]
	add	rax, rax
	cmp	QWORD PTR [r12+rax*8], rdi
	je	SHORT $LN54@GetAssume
	add	rcx, 4
	inc	edx
	cmp	rcx, r8
	jl	SHORT $LL38@GetAssume
	test	r11, r11
	je	SHORT $LN62@GetAssume
	xor	ecx, ecx
	mov	rax, r9
$LL33@GetAssume:
	movsxd	rdx, DWORD PTR [rax]
	add	rdx, rdx
	cmp	BYTE PTR [r12+rdx*8+9], 0
	je	SHORT $LN30@GetAssume
	cmp	r11, r10
	je	SHORT $LN55@GetAssume
$LN30@GetAssume:
	cmp	QWORD PTR [r12+rdx*8], r11
	je	SHORT $LN56@GetAssume
	add	rax, 4
	inc	ecx
	cmp	rax, r8
	jl	SHORT $LL33@GetAssume
	jmp	SHORT $LN62@GetAssume
$LN54@GetAssume:
	movsxd	rax, edx
	mov	eax, DWORD PTR [r9+rax*4]
	jmp	SHORT $LN45@GetAssume
$LN55@GetAssume:
	movsxd	rax, ecx
	mov	eax, DWORD PTR [r9+rax*4]
	jmp	SHORT $LN45@GetAssume
$LN56@GetAssume:
	movsxd	rax, ecx
	mov	eax, DWORD PTR [r9+rax*4]
$LN45@GetAssume:

; 546  :     }
; 547  :     if( reg == ASSUME_NOTHING ) {

	cmp	eax, -2
	jne	SHORT $LN61@GetAssume
$LN62@GetAssume:

; 548  :         if( sym && sym->state == SYM_EXTERNAL && sym->segment == NULL ) {

	test	rsi, rsi
	je	SHORT $LN1@GetAssume
	cmp	DWORD PTR [rsi+40], 2
	jne	SHORT $LN1@GetAssume
	cmp	QWORD PTR [rsi+32], 0
	jne	SHORT $LN1@GetAssume

; 549  :             reg = def;
; 550  :         }
; 551  :     }
; 552  :     if( reg != ASSUME_NOTHING ) {

	cmp	ebx, -2
	mov	eax, ebx
	je	SHORT $LN1@GetAssume
$LN61@GetAssume:

; 553  :         *passume = SegAssumeTable[reg].symbol;

	movsxd	rcx, eax
	add	rcx, rcx
	mov	rcx, QWORD PTR [r12+rcx*8]
	mov	QWORD PTR [rbp], rcx

; 554  :         return( reg );

	jmp	SHORT $LN9@GetAssume
$LN1@GetAssume:

; 555  :     }
; 556  :     *passume = NULL;

	mov	QWORD PTR [rbp], 0

; 557  :     return( ASSUME_NOTHING );

	mov	eax, -2
$LN9@GetAssume:
	mov	r12, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 558  : }

	add	rsp, 40					; 00000028H
	ret	0
GetAssume ENDP
_TEXT	ENDS
END
