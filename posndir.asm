; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
NopList16 DB	03H
	DB	02eH
	DB	08bH
	DB	0c0H
	DB	08bH
	DB	0c0H
	DB	090H
	ORG $+1
NopList32 DB	07H
	DB	08dH
	DB	0a4H
	DB	024H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	08dH
	DB	080H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02eH
	DB	08dH
	DB	044H
	DB	020H
	DB	00H
	DB	08dH
	DB	044H
	DB	020H
	DB	00H
	DB	08dH
	DB	040H
	DB	00H
	DB	08bH
	DB	0ffH
	DB	090H
	ORG $+3
NopList64 DB	07H
	DB	0fH
	DB	01fH
	DB	080H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	066H
	DB	0fH
	DB	01fH
	DB	044H
	DB	00H
	DB	00H
	DB	0fH
	DB	01fH
	DB	044H
	DB	00H
	DB	00H
	DB	0fH
	DB	01fH
	DB	040H
	DB	00H
	DB	0fH
	DB	01fH
	DB	00H
	DB	066H
	DB	090H
	DB	090H
	ORG $+3
NopLists DQ	FLAT:NopList16
	DQ	FLAT:NopList32
	DQ	FLAT:NopList64
CONST	ENDS
PUBLIC	OrgDirective
EXTRN	SetCurrOffset:NEAR
EXTRN	AddOrgFixup:NEAR
EXTRN	StoreLine:NEAR
EXTRN	Parse_Pass:DWORD
EXTRN	StoreState:BYTE
EXTRN	EmitError:NEAR
EXTRN	SetStructCurrentOffset:NEAR
EXTRN	CurrStruct:QWORD
EXTRN	EmitErr:NEAR
EXTRN	EvalOperand:NEAR
EXTRN	ModuleInfo:BYTE
EXTRN	Options:BYTE
xdata	SEGMENT
$unwind$OrgDirective DD 030c01H
	DD	014010cH
	DD	03002H
xdata	ENDS
pdata	SEGMENT
$pdata$OrgDirective DD @imagerel($LN19#)
	DD	@imagerel($LN19#+462)
	DD	@imagerel($unwind$OrgDirective#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\posndir.c
pdata	ENDS
_TEXT	SEGMENT
opndx$ = 48
i$ = 176
tokenarray$ = 184
OrgDirective PROC NEAR

; 95   : {

$LN19:
	push	rbx
	mov	r11, rsp
	sub	rsp, 160				; 000000a0H

; 96   :     //struct asym  *sym;
; 97   :     //int_32       value = 0;
; 98   :     struct expr opndx;
; 99   : 
; 100  :     DebugMsg1(("OrgDirective(%u) enter\n", i));
; 101  :     i++;
; 102  :     /* v2.09: if -Zne is set, don't allow forward reference in ORG argument */
; 103  :     //if ( ( ERROR == EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) ) )
; 104  :     if ( ( ERROR == EvalOperand( &i, tokenarray, Token_Count, &opndx, Options.strict_masm_compat ? EXPF_NOUNDEF : 0 ) ) )

	movzx	eax, BYTE PTR Options+136
	mov	r8d, DWORD PTR ModuleInfo+496
	inc	ecx
	mov	DWORD PTR [r11+16], ecx
	neg	al
	lea	r9, QWORD PTR [r11-112]
	sbb	cl, cl
	mov	rbx, rdx
	and	cl, 2
	mov	BYTE PTR [rsp+32], cl
	lea	rcx, QWORD PTR [r11+16]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN15@OrgDirecti

; 141  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN15@OrgDirecti:

; 105  :         return( ERROR );
; 106  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, DWORD PTR i$[rsp]
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbx], 0
	je	SHORT $LN14@OrgDirecti

; 107  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+rbx+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 141  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN14@OrgDirecti:

; 108  :     }
; 109  :     if ( CurrStruct ) {

	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN13@OrgDirecti

; 110  :         if ( opndx.kind == EXPR_CONST )

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	$LN2@OrgDirecti

; 111  :             return( SetStructCurrentOffset( opndx.value ) );

	mov	ecx, DWORD PTR opndx$[rsp]
	call	SetStructCurrentOffset

; 141  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN13@OrgDirecti:

; 112  :     } else {
; 113  :         if( CurrSeg == NULL ) {

	mov	r10, QWORD PTR ModuleInfo+432
	test	r10, r10
	jne	SHORT $LN10@OrgDirecti

; 114  :             return( EmitError( MUST_BE_IN_SEGMENT_BLOCK ) );

	lea	ecx, QWORD PTR [r10+82]

; 138  : 		}
; 139  :     }
; 140  :     return( EmitError( ORG_NEEDS_A_CONSTANT_OR_LOCAL_OFFSET ) );

	call	EmitError

; 141  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN10@OrgDirecti:

; 115  :         }
; 116  : #if FASTPASS
; 117  :         if ( StoreState == FALSE ) FStoreLine(0);

	cmp	BYTE PTR StoreState, 0
	jne	SHORT $LN8@OrgDirecti
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN6@OrgDirecti
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	xor	edx, edx
	call	StoreLine
	mov	r10, QWORD PTR ModuleInfo+432
$LN8@OrgDirecti:

; 118  : #endif
; 119  :         /* v2.04: added */
; 120  :         if ( Parse_Pass == PASS_1 && CurrSeg->e.seginfo->FixupList.head )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN6@OrgDirecti
	mov	rax, QWORD PTR [r10+104]
	cmp	QWORD PTR [rax+40], 0
	je	SHORT $LN6@OrgDirecti

; 121  :             CurrSeg->e.seginfo->FixupList.head->orgoccured = TRUE;

	mov	rcx, QWORD PTR [rax+40]
	or	BYTE PTR [rcx+33], 2
	mov	r10, QWORD PTR ModuleInfo+432
$LN6@OrgDirecti:

; 122  : 
; 123  : 		if (opndx.kind == EXPR_CONST)

	mov	eax, DWORD PTR opndx$[rsp+60]
	test	eax, eax
	jne	SHORT $LN5@OrgDirecti

; 124  : 		{
; 125  : 			if ( (opndx.value > CurrSeg->e.seginfo->current_loc) && (CurrSeg->e.seginfo->current_loc > CurrSeg->e.seginfo->start_loc) )

	mov	rax, QWORD PTR [r10+104]
	mov	edx, DWORD PTR opndx$[rsp]
	mov	ecx, DWORD PTR [rax+12]
	cmp	edx, ecx
	jbe	SHORT $LN4@OrgDirecti
	mov	r8, rax
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR [r8+12], eax
	jbe	SHORT $LN4@OrgDirecti

; 126  : 			{
; 127  : 				AddOrgFixup(CurrSeg->e.seginfo->current_loc, opndx.value);

	call	AddOrgFixup
	mov	edx, DWORD PTR opndx$[rsp]
	mov	r10, QWORD PTR ModuleInfo+432
$LN4@OrgDirecti:

; 128  : 			}
; 129  : 			return(SetCurrOffset(CurrSeg, opndx.value, FALSE, FALSE));

	xor	r9d, r9d
	xor	r8d, r8d
	mov	rcx, r10
	call	SetCurrOffset

; 141  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN5@OrgDirecti:

; 130  : 		}
; 131  : 		else if (opndx.kind == EXPR_ADDR && opndx.indirect == FALSE)

	cmp	eax, 1
	jne	SHORT $LN2@OrgDirecti
	test	BYTE PTR opndx$[rsp+72], al
	jne	SHORT $LN2@OrgDirecti

; 132  : 		{
; 133  : 			if ( (opndx.value > CurrSeg->e.seginfo->current_loc) && (CurrSeg->e.seginfo->current_loc > CurrSeg->e.seginfo->start_loc) )

	mov	rax, QWORD PTR [r10+104]
	mov	r8d, DWORD PTR opndx$[rsp]
	mov	ecx, DWORD PTR [rax+12]
	cmp	r8d, ecx
	jbe	SHORT $LN1@OrgDirecti
	mov	rdx, rax
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR [rdx+12], eax
	jbe	SHORT $LN1@OrgDirecti

; 134  : 			{
; 135  : 				AddOrgFixup(CurrSeg->e.seginfo->current_loc, opndx.sym->offset + opndx.value);

	mov	rax, QWORD PTR opndx$[rsp+80]
	mov	edx, DWORD PTR [rax+16]
	add	edx, r8d
	call	AddOrgFixup
	mov	r8d, DWORD PTR opndx$[rsp]
	mov	r10, QWORD PTR ModuleInfo+432
$LN1@OrgDirecti:

; 136  : 			}
; 137  : 			return(SetCurrOffset(CurrSeg, opndx.sym->offset + opndx.value, FALSE, FALSE));

	mov	rax, QWORD PTR opndx$[rsp+80]
	xor	r9d, r9d
	mov	ecx, DWORD PTR [rax+16]
	lea	edx, DWORD PTR [r8+rcx]
	xor	r8d, r8d
	mov	rcx, r10
	call	SetCurrOffset

; 141  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
$LN2@OrgDirecti:

; 138  : 		}
; 139  :     }
; 140  :     return( EmitError( ORG_NEEDS_A_CONSTANT_OR_LOCAL_OFFSET ) );

	mov	ecx, 40					; 00000028H
	call	EmitError

; 141  : }

	add	rsp, 160				; 000000a0H
	pop	rbx
	ret	0
OrgDirective ENDP
_TEXT	ENDS
EXTRN	OutputByte:NEAR
EXTRN	FillDataBytes:NEAR
xdata	SEGMENT
$unwind$fill_in_objfile_space DD 0b6601H
	DD	04c466H
	DD	097461H
	DD	07545cH
	DD	063457H
	DD	086409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$fill_in_objfile_space DD @imagerel(fill_in_objfile_space#)
	DD	@imagerel(fill_in_objfile_space#+333)
	DD	@imagerel($unwind$fill_in_objfile_space#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
size$ = 48
fill_in_objfile_space PROC NEAR

; 145  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rsi
	mov	esi, ecx

; 146  :     int i;
; 147  :     int nop_type;
; 148  : 
; 149  :     /* emit
; 150  :      - nothing ... for BSS
; 151  :      - x'00'   ... for DATA
; 152  :      - nops    ... for CODE
; 153  :      */
; 154  : 
; 155  :     /* v2.04: no output if nothing has been written yet */
; 156  :     if( CurrSeg->e.seginfo->written == FALSE ) {

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rcx+104]
	test	BYTE PTR [rax+107], 32			; 00000020H
	jne	SHORT $LN16@fill_in_ob

; 157  : 
; 158  :         SetCurrOffset( CurrSeg, size, TRUE, TRUE );

	mov	r9b, 1
	mov	edx, esi
	movzx	r8d, r9b
	mov	rsi, QWORD PTR [rsp+64]

; 182  :         }
; 183  :     }
; 184  : }

	add	rsp, 40					; 00000028H
	jmp	SetCurrOffset
$LN16@fill_in_ob:

; 159  : 
; 160  :     } else if( CurrSeg->e.seginfo->segtype != SEGTYPE_CODE ) {

	cmp	DWORD PTR [rax+72], 1
	je	SHORT $LN19@fill_in_ob

; 161  : 
; 162  :         FillDataBytes( 0x00, size ); /* just output nulls */

	mov	edx, esi
	xor	ecx, ecx
	mov	rsi, QWORD PTR [rsp+64]

; 182  :         }
; 183  :     }
; 184  : }

	add	rsp, 40					; 00000028H
	jmp	FillDataBytes
$LN19@fill_in_ob:

; 163  : 
; 164  :     } else {
; 165  :         /* output appropriate NOP type instructions to fill in the gap */
; 166  : 
; 167  :         while( size > NopLists[ ModuleInfo.Ofssize ][0] ) {

	movzx	edx, BYTE PTR ModuleInfo+404
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+72], rdi
	mov	QWORD PTR [rsp+32], r12
	lea	r12, OFFSET FLAT:NopLists
	mov	rcx, QWORD PTR [r12+rdx*8]
	mov	ebp, 1
	movzx	eax, BYTE PTR [rcx]
	cmp	esi, eax
	jbe	SHORT $LN11@fill_in_ob
	npad	3
$LL12@fill_in_ob:

; 168  :             for( i = 1; i <= NopLists[ ModuleInfo.Ofssize ][0]; i++ ) {

	cmp	eax, ebp
	mov	ebx, ebp
	mov	rdi, rbp
	jl	SHORT $LN8@fill_in_ob
	npad	7
$LL10@fill_in_ob:

; 169  :                 OutputByte( NopLists[ ModuleInfo.Ofssize ][i] );

	movzx	ecx, BYTE PTR [rcx+rdi]
	call	OutputByte
	movzx	edx, BYTE PTR ModuleInfo+404
	inc	ebx
	mov	rcx, QWORD PTR [r12+rdx*8]
	inc	rdi
	movzx	eax, BYTE PTR [rcx]
	cmp	ebx, eax
	jle	SHORT $LL10@fill_in_ob
$LN8@fill_in_ob:

; 170  :             }
; 171  :             size -= NopLists[ ModuleInfo.Ofssize ][0];

	movzx	eax, dl
	mov	rcx, QWORD PTR [r12+rax*8]
	movzx	eax, BYTE PTR [rcx]
	sub	esi, eax
	cmp	esi, eax
	ja	SHORT $LL12@fill_in_ob
$LN11@fill_in_ob:

; 172  :         }
; 173  :         if( size == 0 ) return;

	test	esi, esi
	je	SHORT $LN34@fill_in_ob

; 178  :         }
; 179  :         /* i now is the index of the 1st part of the NOP that we want */
; 180  :         for( ; nop_type > 0; nop_type--,i++ ) {

	xor	ecx, ecx
	movzx	eax, dl
	mov	rax, QWORD PTR [r12+rax*8]
	mov	r8d, ecx
	movzx	ebx, BYTE PTR [rax]
	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 2
	jl	SHORT $LC28@fill_in_ob
	lea	eax, DWORD PTR [rsi+1]
	npad	1

; 174  : 
; 175  :         i=1; /* here i is the index into the NOP table */
; 176  :         for( nop_type = NopLists[ ModuleInfo.Ofssize ][0]; nop_type > size ; nop_type-- ) {

$LL29@fill_in_ob:

; 177  :             i+=nop_type;

	add	ecx, ebx
	lea	r8d, DWORD PTR [r8+rbx-1]
	sub	ebx, 2

; 178  :         }
; 179  :         /* i now is the index of the 1st part of the NOP that we want */
; 180  :         for( ; nop_type > 0; nop_type--,i++ ) {

	cmp	ebx, eax
	jg	SHORT $LL29@fill_in_ob
$LC28@fill_in_ob:

; 174  : 
; 175  :         i=1; /* here i is the index into the NOP table */
; 176  :         for( nop_type = NopLists[ ModuleInfo.Ofssize ][0]; nop_type > size ; nop_type-- ) {

	cmp	ebx, esi
	jbe	SHORT $LN27@fill_in_ob

; 177  :             i+=nop_type;

	lea	ebp, DWORD PTR [rbx+1]

; 178  :         }
; 179  :         /* i now is the index of the 1st part of the NOP that we want */
; 180  :         for( ; nop_type > 0; nop_type--,i++ ) {

	dec	ebx
$LN27@fill_in_ob:
	lea	eax, DWORD PTR [r8+rcx]
	add	eax, ebp
	test	ebx, ebx
	movsxd	rdi, eax
	jle	SHORT $LN34@fill_in_ob
	jmp	SHORT $LN3@fill_in_ob
	npad	10
$LL30@fill_in_ob:
	mov	dl, BYTE PTR ModuleInfo+404
$LN3@fill_in_ob:

; 181  :             OutputByte( NopLists[ ModuleInfo.Ofssize ][i] );

	movzx	eax, dl
	mov	rax, QWORD PTR [r12+rax*8]
	movzx	ecx, BYTE PTR [rax+rdi]
	call	OutputByte
	dec	ebx
	inc	rdi
	test	ebx, ebx
	jg	SHORT $LL30@fill_in_ob
$LN34@fill_in_ob:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
	mov	r12, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+64]

; 182  :         }
; 183  :     }
; 184  : }

	add	rsp, 40					; 00000028H
	ret	0
fill_in_objfile_space ENDP
_TEXT	ENDS
PUBLIC	AlignCurrOffset
EXTRN	GetCurrOffset:NEAR
xdata	SEGMENT
$unwind$AlignCurrOffset DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$AlignCurrOffset DD @imagerel($LN4#)
	DD	@imagerel($LN4#+41)
	DD	@imagerel($unwind$AlignCurrOffset#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
value$ = 48
AlignCurrOffset PROC NEAR

; 190  : {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 191  :     int seg_align;
; 192  :     int alignment = (1 << value);

	mov	ebx, 1
	shl	ebx, cl

; 193  :     unsigned int CurrAddr;
; 194  : 
; 195  :     CurrAddr = GetCurrOffset();

	call	GetCurrOffset

; 196  :     seg_align = CurrAddr % alignment;

	xor	edx, edx
	div	ebx

; 197  :     if( seg_align ) {

	test	edx, edx
	je	SHORT $LN1@AlignCurrO

; 198  :         alignment -= seg_align;

	sub	ebx, edx

; 199  :         fill_in_objfile_space( alignment );

	mov	ecx, ebx
	call	fill_in_objfile_space
$LN1@AlignCurrO:

; 200  :     }
; 201  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
AlignCurrOffset ENDP
_TEXT	ENDS
PUBLIC	AlignDirective
EXTRN	LstWrite:NEAR
EXTRN	EmitWarn:NEAR
EXTRN	myltoa:NEAR
EXTRN	AlignInStruct:NEAR
EXTRN	GetCurrSegAlign:NEAR
xdata	SEGMENT
$unwind$AlignDirective DD 030c01H
	DD	018010cH
	DD	03005H
xdata	ENDS
pdata	SEGMENT
$pdata$AlignDirective DD @imagerel($LN37#)
	DD	@imagerel($LN37#+547)
	DD	@imagerel($unwind$AlignDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
opndx$ = 48
buffer$ = 160
i$ = 208
tokenarray$ = 216
AlignDirective PROC NEAR

; 207  : {

$LN37:
	mov	DWORD PTR [rsp+8], ecx
	push	rbx
	sub	rsp, 192				; 000000c0H

; 208  :     int seg_align;
; 209  :     struct expr opndx;
; 210  :     uint_32 CurrAddr;
; 211  :     char buffer[32];
; 212  : 
; 213  :     DebugMsg1(("AlignDirective enter\n"));
; 214  : 
; 215  :     switch( tokenarray[i].tokval ) {

	movsxd	rax, ecx
	mov	rbx, rdx
	shl	rax, 5
	mov	r8d, DWORD PTR [rax+rdx+16]
	sub	r8d, 439				; 000001b7H
	je	SHORT $LN24@AlignDirec
	dec	r8d
	jne	$LN32@AlignDirec

; 235  :         }
; 236  :         break;
; 237  :     case T_EVEN:
; 238  :         align_value = 2;

	mov	eax, 2

; 239  :         i++;

	inc	ecx
	mov	DWORD PTR opndx$[rsp], eax
	mov	DWORD PTR i$[rsp], ecx

; 240  :         break;

	jmp	$LN14@AlignDirec
$LN24@AlignDirec:

; 216  :     case T_ALIGN:
; 217  :         i++;
; 218  :         if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	inc	ecx
	lea	r9, QWORD PTR opndx$[rsp]
	mov	DWORD PTR i$[rsp], ecx
	lea	rcx, QWORD PTR i$[rsp]
	mov	BYTE PTR [rsp+32], 2
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN23@AlignDirec

; 279  : }

	add	rsp, 192				; 000000c0H
	pop	rbx
	ret	0
$LN23@AlignDirec:

; 219  :             return( ERROR );
; 220  :         if ( opndx.kind == EXPR_CONST ) {

	mov	eax, DWORD PTR opndx$[rsp+60]
	test	eax, eax
	jne	SHORT $LN22@AlignDirec

; 221  :             int_32 power;
; 222  :             /* check that the parm is a power of 2 */
; 223  :             for( power = 1; power < align_value; power <<= 1 );

	mov	eax, DWORD PTR opndx$[rsp]
	mov	ecx, 1
	cmp	ecx, eax
	jge	SHORT $LN34@AlignDirec
	npad	2
$LL21@AlignDirec:
	add	ecx, ecx
	cmp	ecx, eax
	jl	SHORT $LL21@AlignDirec
$LN34@AlignDirec:

; 224  :             if( power != align_value ) {

	je	SHORT $LN33@AlignDirec

; 225  :                 return( EmitErr( POWER_OF_2, align_value ) );

	mov	edx, eax
	mov	ecx, 129				; 00000081H
	call	EmitErr

; 279  : }

	add	rsp, 192				; 000000c0H
	pop	rbx
	ret	0
$LN22@AlignDirec:

; 226  :             }
; 227  :         } else if ( opndx.kind == EXPR_EMPTY ) { /* ALIGN without argument? */

	cmp	eax, -2
	jne	$LN16@AlignDirec

; 228  :             /* v2.03: special STRUCT handling was missing */
; 229  :             if ( CurrStruct )

	mov	rax, QWORD PTR CurrStruct
	test	rax, rax
	je	SHORT $LN15@AlignDirec

; 230  :                 align_value = CurrStruct->e.structinfo->alignment;

	mov	rax, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rax+28]
$LN35@AlignDirec:
	mov	DWORD PTR opndx$[rsp], eax
$LN33@AlignDirec:

; 240  :         break;

	mov	ecx, DWORD PTR i$[rsp]
$LN14@AlignDirec:

; 241  :     }
; 242  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, ecx
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbx], 0
	je	SHORT $LN11@AlignDirec

; 243  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+rbx+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 279  : }

	add	rsp, 192				; 000000c0H
	pop	rbx
	ret	0
$LN15@AlignDirec:

; 231  :             else
; 232  :                 align_value = GetCurrSegAlign();

	call	GetCurrSegAlign
	jmp	SHORT $LN35@AlignDirec
$LN32@AlignDirec:
	mov	eax, DWORD PTR opndx$[rsp]
	jmp	SHORT $LN14@AlignDirec
$LN11@AlignDirec:

; 244  :     }
; 245  : 
; 246  :     /* ALIGN/EVEN inside a STRUCT definition? */
; 247  :     if ( CurrStruct )

	cmp	QWORD PTR CurrStruct, 0
	je	SHORT $LN10@AlignDirec

; 248  :         return( AlignInStruct( align_value ));

	mov	ecx, eax
	call	AlignInStruct

; 279  : }

	add	rsp, 192				; 000000c0H
	pop	rbx
	ret	0
$LN10@AlignDirec:

; 249  : 
; 250  : #if FASTPASS
; 251  :     if ( StoreState == FALSE ) FStoreLine(0);

	cmp	BYTE PTR StoreState, 0
	jne	SHORT $LN8@AlignDirec
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN8@AlignDirec
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	xor	edx, edx
	call	StoreLine
$LN8@AlignDirec:

; 252  : #endif
; 253  :     seg_align = GetCurrSegAlign(); /* # of bytes */

	call	GetCurrSegAlign

; 254  :     if( seg_align <= 0 ) {

	test	eax, eax
	jg	SHORT $LN6@AlignDirec

; 255  :         return( EmitError( MUST_BE_IN_SEGMENT_BLOCK ) );

	mov	ecx, 82					; 00000052H

; 233  :         } else {
; 234  :             return( EmitError( CONSTANT_EXPECTED ) );

	call	EmitError

; 279  : }

	add	rsp, 192				; 000000c0H
	pop	rbx
	ret	0
$LN6@AlignDirec:

; 256  :     }
; 257  :     if( align_value > seg_align ) {

	mov	ecx, DWORD PTR opndx$[rsp]
	cmp	ecx, eax
	jle	SHORT $LN4@AlignDirec

; 258  :         if (( Parse_Pass == PASS_1 )&&                   //We need 32 0r 64 bit for VEX and EVEX
; 259  :           (ModuleInfo.flat_grp->sym.isdefined == FALSE)) //No warning if "FLAT"

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN3@AlignDirec
	mov	rax, QWORD PTR ModuleInfo+440
	test	BYTE PTR [rax+48], 2
	jne	SHORT $LN31@AlignDirec

; 260  :             EmitWarn( 1, ALIGN_TOO_HIGH, myltoa( align_value, buffer, 10, FALSE, FALSE ) );

	xor	r9d, r9d
	lea	rdx, QWORD PTR buffer$[rsp]
	mov	BYTE PTR [rsp+32], 0
	lea	r8d, QWORD PTR [r9+10]
	call	myltoa
	mov	edx, 130				; 00000082H
	mov	ecx, 1
	mov	r8, rax
	call	EmitWarn
$LN4@AlignDirec:

; 261  :         //return( ERROR ); /* v2.0: don't exit */
; 262  :     }
; 263  :     /* v2.04: added, Skip backpatching after ALIGN occured */
; 264  :     if ( Parse_Pass == PASS_1 && CurrSeg && CurrSeg->e.seginfo->FixupList.head )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN3@AlignDirec
$LN31@AlignDirec:
	mov	rcx, QWORD PTR ModuleInfo+432
	test	rcx, rcx
	je	SHORT $LN3@AlignDirec
	mov	rax, QWORD PTR [rcx+104]
	cmp	QWORD PTR [rax+40], 0
	je	SHORT $LN3@AlignDirec

; 265  :         CurrSeg->e.seginfo->FixupList.head->orgoccured = TRUE;

	mov	rcx, QWORD PTR [rax+40]
	or	BYTE PTR [rcx+33], 2
$LN3@AlignDirec:

; 266  :     /* find out how many bytes past alignment we are & add the remainder */
; 267  :     /* store temp. value */
; 268  :     CurrAddr = GetCurrOffset();

	call	GetCurrOffset

; 269  :     seg_align = CurrAddr % align_value;

	mov	ecx, DWORD PTR opndx$[rsp]
	xor	edx, edx
	mov	ebx, eax
	div	ecx

; 270  :     if( seg_align ) {

	test	edx, edx
	je	SHORT $LN2@AlignDirec

; 271  :         align_value -= seg_align;

	sub	ecx, edx
	mov	DWORD PTR opndx$[rsp], ecx

; 272  :         fill_in_objfile_space( align_value );

	call	fill_in_objfile_space
$LN2@AlignDirec:

; 273  :     }
; 274  :     if ( CurrFile[LST] ) {

	cmp	QWORD PTR ModuleInfo+112, 0
	je	SHORT $LN1@AlignDirec

; 275  :         LstWrite( LSTTYPE_DATA, CurrAddr, NULL );

	xor	r8d, r8d
	mov	edx, ebx
	xor	ecx, ecx
	call	LstWrite
$LN1@AlignDirec:

; 276  :     }
; 277  :     DebugMsg1(("AlignDirective exit\n"));
; 278  :     return( NOT_ERROR );

	xor	eax, eax

; 279  : }

	add	rsp, 192				; 000000c0H
	pop	rbx
	ret	0
$LN16@AlignDirec:

; 233  :         } else {
; 234  :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 279  : }

	add	rsp, 192				; 000000c0H
	pop	rbx
	ret	0
AlignDirective ENDP
_TEXT	ENDS
END
