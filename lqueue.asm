; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
PUBLIC	DeleteLineQueue
EXTRN	MemFree:NEAR
EXTRN	ModuleInfo:BYTE
xdata	SEGMENT
$unwind$DeleteLineQueue DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$DeleteLineQueue DD @imagerel($LN9#)
	DD	@imagerel($LN9#+51)
	DD	@imagerel($unwind$DeleteLineQueue#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\lqueue.c
pdata	ENDS
_TEXT	SEGMENT
DeleteLineQueue PROC NEAR

; 45   : {

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H

; 46   :     struct qitem *curr;
; 47   :     struct qitem *next;
; 48   :     for( curr = line_queue.head; curr; curr = next ) {

	mov	rcx, QWORD PTR ModuleInfo+184
	test	rcx, rcx
	je	SHORT $LN8@DeleteLine
$LL3@DeleteLine:

; 49   :         next = curr->next;

	mov	rbx, QWORD PTR [rcx]

; 50   :         MemFree( curr );

	call	MemFree
	test	rbx, rbx
	mov	rcx, rbx
	jne	SHORT $LL3@DeleteLine
$LN8@DeleteLine:

; 51   :     }
; 52   :     line_queue.head = NULL;

	mov	QWORD PTR ModuleInfo+184, 0

; 53   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
DeleteLineQueue ENDP
_TEXT	ENDS
PUBLIC	AddLineQueue
EXTRN	MemAlloc:NEAR
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$AddLineQueue DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$AddLineQueue DD @imagerel($LN6#)
	DD	@imagerel($LN6#+4)
	DD	@imagerel($unwind$AddLineQueue#)
pdata	ENDS
xdata	SEGMENT
$chain$2$AddLineQueue DD 061421H
	DD	097414H
	DD	08640fH
	DD	073405H
	DD	@imagerel($LN6#)
	DD	@imagerel($LN6#+4)
	DD	@imagerel($unwind$AddLineQueue#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$AddLineQueue DD @imagerel($LN6#+4)
	DD	@imagerel($LN6#+102)
	DD	@imagerel($chain$2$AddLineQueue#)
pdata	ENDS
xdata	SEGMENT
$chain$3$AddLineQueue DD 020021H
	DD	086400H
	DD	@imagerel($LN6#)
	DD	@imagerel($LN6#+4)
	DD	@imagerel($unwind$AddLineQueue#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$AddLineQueue DD @imagerel($LN6#+102)
	DD	@imagerel($LN6#+153)
	DD	@imagerel($chain$3$AddLineQueue#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
line$ = 48
AddLineQueue PROC NEAR

; 68   : {

$LN6:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+56], rbx
	mov	rbx, rcx

; 69   :     unsigned i = strlen( line );

	xor	eax, eax
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	dec	rcx
	mov	rdi, rcx

; 70   :     struct lq_line   *new;
; 71   : 
; 72   :     DebugMsg1(( "AddLineQueue(%p): #=%u >%s<\n", line, ++lqlines_written, line ));
; 73   : 
; 74   :     /* v2.11: line queue has become static. */
; 75   :     //if ( line_queue == NULL ) {
; 76   :     //    line_queue = MemAlloc( sizeof( struct input_queue ) );
; 77   :     //    line_queue->tail = NULL;
; 78   :     //}
; 79   :     new = MemAlloc( sizeof( struct lq_line ) + i );

	mov	ecx, ecx
	add	rcx, 16
	call	MemAlloc

; 80   :     new->next = NULL;
; 81   :     DebugCmd( new->lineno = lqlines_written );
; 82   :     memcpy( new->line, line, i + 1 );

	lea	r8d, DWORD PTR [rdi+1]
	mov	rdx, rbx
	lea	rcx, QWORD PTR [rax+8]
	mov	rsi, rax
	mov	QWORD PTR [rax], 0
	call	memcpy

; 83   : 
; 84   :     if( line_queue.head == NULL ) {

	cmp	QWORD PTR ModuleInfo+184, 0
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+56]
	jne	SHORT $LN2@AddLineQue

; 85   :         line_queue.head = new;

	mov	QWORD PTR ModuleInfo+184, rsi

; 89   :     }
; 90   :     line_queue.tail = new;

	mov	QWORD PTR ModuleInfo+192, rsi
	mov	rsi, QWORD PTR [rsp+64]

; 91   :     return;
; 92   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@AddLineQue:

; 86   :     } else {
; 87   :         /* insert at the tail */
; 88   :         ((struct qnode *)line_queue.tail)->next = new;

	mov	rax, QWORD PTR ModuleInfo+192
	mov	QWORD PTR [rax], rsi

; 89   :     }
; 90   :     line_queue.tail = new;

	mov	QWORD PTR ModuleInfo+192, rsi
	mov	rsi, QWORD PTR [rsp+64]

; 91   :     return;
; 92   : }

	add	rsp, 40					; 00000028H
	ret	0
AddLineQueue ENDP
_TEXT	ENDS
PUBLIC	AddLineQueueX
EXTRN	myltoa:NEAR
EXTRN	myqtoa:NEAR
EXTRN	ResWordTable:BYTE
EXTRN	GetResWName:NEAR
EXTRN	__ImageBase:BYTE
xdata	SEGMENT
$unwind$AddLineQueueX DD 042501H
	DD	08a3425H
	DD	08b011eH
xdata	ENDS
pdata	SEGMENT
$pdata$AddLineQueueX DD @imagerel($LN28#)
	DD	@imagerel($LN28#+37)
	DD	@imagerel($unwind$AddLineQueueX#)
pdata	ENDS
xdata	SEGMENT
$chain$3$AddLineQueueX DD 061521H
	DD	0877415H
	DD	0886408H
	DD	0895404H
	DD	@imagerel($LN28#)
	DD	@imagerel($LN28#+37)
	DD	@imagerel($unwind$AddLineQueueX#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$AddLineQueueX DD @imagerel($LN28#+37)
	DD	@imagerel($LN28#+67)
	DD	@imagerel($chain$3$AddLineQueueX#)
pdata	ENDS
xdata	SEGMENT
$chain$4$AddLineQueueX DD 020421H
	DD	086c404H
	DD	@imagerel($LN28#+37)
	DD	@imagerel($LN28#+67)
	DD	@imagerel($chain$3$AddLineQueueX#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$AddLineQueueX DD @imagerel($LN28#+67)
	DD	@imagerel($LN28#+466)
	DD	@imagerel($chain$4$AddLineQueueX#)
pdata	ENDS
xdata	SEGMENT
$chain$5$AddLineQueueX DD 021H
	DD	@imagerel($LN28#+37)
	DD	@imagerel($LN28#+67)
	DD	@imagerel($chain$3$AddLineQueueX#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$AddLineQueueX DD @imagerel($LN28#+466)
	DD	@imagerel($LN28#+567)
	DD	@imagerel($chain$5$AddLineQueueX#)
pdata	ENDS
xdata	SEGMENT
$chain$6$AddLineQueueX DD 021H
	DD	@imagerel($LN28#)
	DD	@imagerel($LN28#+37)
	DD	@imagerel($unwind$AddLineQueueX#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$AddLineQueueX DD @imagerel($LN28#+567)
	DD	@imagerel($LN28#+612)
	DD	@imagerel($chain$6$AddLineQueueX#)
pdata	ENDS
xdata	SEGMENT
$chain$7$AddLineQueueX DD 080021H
	DD	086c400H
	DD	0877400H
	DD	0886400H
	DD	0895400H
	DD	@imagerel($LN28#)
	DD	@imagerel($LN28#+37)
	DD	@imagerel($unwind$AddLineQueueX#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$AddLineQueueX DD @imagerel($LN28#+612)
	DD	@imagerel($LN28#+653)
	DD	@imagerel($chain$7$AddLineQueueX#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buffer$ = 48
fmt$ = 1120
AddLineQueueX PROC NEAR

; 98   : {

$LN28:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	mov	rax, rsp
	sub	rsp, 1112				; 00000458H

; 99   :     va_list args;
; 100  :     char *d;
; 101  :     int i;
; 102  :     int_32 l;
; 103  :     int_64 q;
; 104  :     const char *s;
; 105  :     const char *p;
; 106  :     char buffer[MAX_LINE_LEN];
; 107  : 
; 108  :     //DebugMsg(("AddlineQueueX(%s) enter\n", fmt ));
; 109  :     va_start( args, fmt );
; 110  :     for ( s = fmt, d = buffer; *s; s++ ) {

	cmp	BYTE PTR [rcx], 0
	mov	QWORD PTR [rax-8], rbx
	mov	QWORD PTR [rax-16], rbp
	mov	QWORD PTR [rax-24], rsi
	lea	rbp, QWORD PTR [rax+16]
	lea	rbx, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rax-32], rdi
	mov	rsi, rcx
	je	$LN14@AddLineQue@2
	mov	QWORD PTR [rax-40], r12
	add	rbp, -8
	lea	r12, OFFSET FLAT:__ImageBase
$LL16@AddLineQue@2:

; 111  :         if ( *s == '%' ) {

	movzx	eax, BYTE PTR [rsi]
	cmp	al, 37					; 00000025H
	jne	$LN13@AddLineQue@2

; 112  :             s++;
; 113  :             switch ( *s ) {

	movsx	edx, BYTE PTR [rsi+1]
	inc	rsi
	lea	eax, DWORD PTR [rdx-100]
	cmp	eax, 20
	ja	$LN2@AddLineQue@2
	cdqe
	movzx	eax, BYTE PTR $LN25@AddLineQue@2[r12+rax]
	mov	ecx, DWORD PTR $LN26@AddLineQue@2[r12+rax*4]
	add	rcx, r12
	jmp	rcx
$LN10@AddLineQue@2:

; 114  :             case 'r':
; 115  :                 i = va_arg( args, int );

	movsxd	rdi, DWORD PTR [rbp+8]
	add	rbp, 8

; 116  :                 GetResWName( i , d );

	mov	rdx, rbx
	mov	ecx, edi
	call	GetResWName

; 117  :                 /* v2.06: the name is already copied */
; 118  :                 //memcpy( d, ResWordTable[i].name, ResWordTable[i].len );
; 119  :                 d += ResWordTable[i].len;

	mov	rdx, rdi
	shl	rdx, 4
	movzx	eax, BYTE PTR ResWordTable[rdx+r12+2]
	add	rbx, rax

; 120  :                 break;

	jmp	$LN15@AddLineQue@2
$LN9@AddLineQue@2:

; 121  :             case 's':
; 122  :                 p = va_arg( args, char * );

	mov	rdx, QWORD PTR [rbp+8]

; 123  :                 i = strlen( p );

	xor	eax, eax
	add	rbp, 8
	mov	rdi, rdx
	mov	rcx, -1
	repne scasb
	not	rcx
	dec	rcx

; 124  :                 memcpy( d, p, i );

	movsxd	rdi, ecx
	mov	rcx, rbx
	mov	r8, rdi
	call	memcpy

; 125  :                 d += i;

	add	rbx, rdi

; 126  :                 *d = NULLC;

	mov	BYTE PTR [rbx], 0

; 127  :                 break;

	jmp	$LN15@AddLineQue@2
$LN8@AddLineQue@2:

; 128  : #if AMD64_SUPPORT
; 129  :             case 'q':
; 130  :               q = va_arg(args, int_64);

	mov	rcx, QWORD PTR [rbp+8]
	add	rbp, 8

; 131  :               myqtoa(q, d, 10, q < 0, FALSE);

	mov	r8d, 10
	test	rcx, rcx
	mov	rdx, rbx
	mov	BYTE PTR [rsp+32], 0
	sets	r9b
	call	myqtoa

; 132  :               d += strlen(d);

	xor	eax, eax
	mov	rdi, rbx
	mov	rcx, -1
	repne scasb
	not	rcx
	dec	rcx
	add	rbx, rcx

; 133  :               /* v2.07: add a 't' suffix if radix is != 10 */
; 134  :               if (ModuleInfo.radix != 10)

	cmp	BYTE PTR ModuleInfo+396, 10
	je	$LN15@AddLineQue@2

; 135  :                 *d++ = 't';

	mov	BYTE PTR [rbx], 116			; 00000074H
	inc	rbx

; 136  :               break;

	jmp	$LN15@AddLineQue@2
$LN6@AddLineQue@2:

; 137  : #endif
; 138  :             case 'd':
; 139  :             case 'u':
; 140  :             case 'x':
; 141  : #ifdef __I86__ /* v2.08: use long only if size(int) is 16-bit */
; 142  :                 l = va_arg( args, long );
; 143  : #else
; 144  :                 l = va_arg( args, int );

	mov	ecx, DWORD PTR [rbp+8]
	add	rbp, 8

; 145  : #endif
; 146  :                 if ( *s == 'x' ) {

	cmp	dl, 120					; 00000078H
	jne	SHORT $LN5@AddLineQue@2

; 147  :                     myltoa( l, d, 16, FALSE, FALSE );

	xor	r9d, r9d
	mov	rdx, rbx
	mov	BYTE PTR [rsp+32], 0
	lea	r8d, QWORD PTR [r9+16]
	call	myltoa

; 148  :                     d += strlen( d );

	xor	eax, eax
	mov	rdi, rbx
	mov	rcx, -1
	repne scasb
	not	rcx
	dec	rcx
	add	rbx, rcx

; 149  :                 } else {

	jmp	SHORT $LN15@AddLineQue@2
$LN5@AddLineQue@2:

; 150  :                     myltoa( l, d, 10, l < 0, FALSE );

	test	ecx, ecx
	mov	r8d, 10
	mov	rdx, rbx
	sets	r9b
	mov	BYTE PTR [rsp+32], 0
	call	myltoa

; 151  :                     d += strlen( d );

	xor	eax, eax
	mov	rdi, rbx
	mov	rcx, -1
	repne scasb
	not	rcx
	dec	rcx
	add	rbx, rcx

; 152  :                     /* v2.07: add a 't' suffix if radix is != 10 */
; 153  :                     if ( ModuleInfo.radix != 10 )

	cmp	BYTE PTR ModuleInfo+396, 10
	je	SHORT $LN15@AddLineQue@2

; 154  :                         *d++ = 't';

	mov	BYTE PTR [rbx], 116			; 00000074H
	inc	rbx

; 155  :                 }
; 156  :                 break;

	jmp	SHORT $LN15@AddLineQue@2
$LN2@AddLineQue@2:

; 157  :             default:
; 158  :                 *d++ = *s;

	mov	BYTE PTR [rbx], dl
	inc	rbx

; 159  :             }
; 160  :         } else

	jmp	SHORT $LN15@AddLineQue@2
$LN13@AddLineQue@2:

; 161  :             *d++ = *s;

	mov	BYTE PTR [rbx], al
	inc	rbx
$LN15@AddLineQue@2:
	inc	rsi
	cmp	BYTE PTR [rsi], 0
	jne	$LL16@AddLineQue@2
	mov	r12, QWORD PTR [rsp+1072]
$LN14@AddLineQue@2:

; 162  :     }
; 163  :     *d = NULLC;
; 164  :     va_end( args );
; 165  :     //DebugMsg(("AddlineQueueX() done\n" ));
; 166  :     AddLineQueue( buffer );

	xor	eax, eax
	mov	BYTE PTR [rbx], 0
	lea	rdi, QWORD PTR buffer$[rsp]
	mov	rcx, -1
	repne scasb
	not	rcx
	dec	rcx
	mov	rdi, rcx
	mov	ecx, ecx
	add	rcx, 16
	call	MemAlloc
	lea	r8d, DWORD PTR [rdi+1]
	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR [rax+8]
	mov	rbx, rax
	mov	QWORD PTR [rax], 0
	call	memcpy
	cmp	QWORD PTR ModuleInfo+184, 0
	mov	rdi, QWORD PTR [rsp+1080]
	mov	rsi, QWORD PTR [rsp+1088]
	mov	rbp, QWORD PTR [rsp+1096]
	jne	SHORT $LN20@AddLineQue@2
	mov	QWORD PTR ModuleInfo+184, rbx
	jmp	SHORT $LN27@AddLineQue@2
$LN20@AddLineQue@2:
	mov	rax, QWORD PTR ModuleInfo+192
	mov	QWORD PTR [rax], rbx
$LN27@AddLineQue@2:
	mov	QWORD PTR ModuleInfo+192, rbx
	mov	rbx, QWORD PTR [rsp+1104]

; 167  :     return;
; 168  : }

	add	rsp, 1112				; 00000458H
	ret	0
	npad	3
$LN26@AddLineQue@2:
	DD	$LN6@AddLineQue@2
	DD	$LN8@AddLineQue@2
	DD	$LN10@AddLineQue@2
	DD	$LN9@AddLineQue@2
	DD	$LN2@AddLineQue@2
$LN25@AddLineQue@2:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	3
	DB	4
	DB	0
	DB	4
	DB	4
	DB	0
AddLineQueueX ENDP
_TEXT	ENDS
PUBLIC	RunLineQueue
EXTRN	PopInputStatus:NEAR
EXTRN	ParseLine:NEAR
EXTRN	PreprocessLine:NEAR
EXTRN	PushInputStatus:NEAR
xdata	SEGMENT
$unwind$RunLineQueue DD 051a01H
	DD	0c641aH
	DD	0b3409H
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$RunLineQueue DD @imagerel($LN10#)
	DD	@imagerel($LN10#+64)
	DD	@imagerel($unwind$RunLineQueue#)
pdata	ENDS
xdata	SEGMENT
$chain$2$RunLineQueue DD 020521H
	DD	0d7405H
	DD	@imagerel($LN10#)
	DD	@imagerel($LN10#+64)
	DD	@imagerel($unwind$RunLineQueue#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$RunLineQueue DD @imagerel($LN10#+64)
	DD	@imagerel($LN10#+167)
	DD	@imagerel($chain$2$RunLineQueue#)
pdata	ENDS
xdata	SEGMENT
$chain$3$RunLineQueue DD 021H
	DD	@imagerel($LN10#)
	DD	@imagerel($LN10#+64)
	DD	@imagerel($unwind$RunLineQueue#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$RunLineQueue DD @imagerel($LN10#+167)
	DD	@imagerel($LN10#+201)
	DD	@imagerel($chain$3$RunLineQueue#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
oldstat$ = 32
RunLineQueue PROC NEAR

; 179  : {

$LN10:
	sub	rsp, 72					; 00000048H
	mov	QWORD PTR [rsp+88], rbx

; 180  :     struct input_status oldstat;
; 181  :     struct asm_tok *tokenarray;
; 182  :     struct lq_line *currline = line_queue.head;

	mov	rbx, QWORD PTR ModuleInfo+184

; 183  : 
; 184  :     DebugMsg1(( "RunLineQueue() enter\n" ));
; 185  : 
; 186  :     /* v2.03: ensure the current source buffer is still aligned */
; 187  :     tokenarray = PushInputStatus( &oldstat );

	lea	rcx, QWORD PTR oldstat$[rsp]
	mov	QWORD PTR [rsp+96], rsi
	call	PushInputStatus

; 188  :     ModuleInfo.GeneratedCode++;

	mov	ecx, DWORD PTR ModuleInfo+456
	inc	ecx

; 189  : 
; 190  :     /* v2.11: line queues are no longer pushed onto the file stack.
; 191  :      * Instead, the queue is processed directly here.
; 192  :      */
; 193  :     line_queue.head = NULL;
; 194  :     DebugCmd( lqlines_written = 0 ); /* reset counter for AddLineQueue() */
; 195  :     DebugCmd( lqlines_read = 0 ); /* reset counter for line-queue reads below */
; 196  : 
; 197  :     for ( ; currline; ) {

	test	rbx, rbx
	mov	rsi, rax
	mov	DWORD PTR ModuleInfo+456, ecx
	mov	QWORD PTR ModuleInfo+184, 0
	je	SHORT $LN2@RunLineQue
	mov	QWORD PTR [rsp+104], rdi
	npad	11
$LL3@RunLineQue:

; 198  :         struct lq_line *nextline = currline->next;

	mov	rdi, QWORD PTR [rbx]

; 199  :         strcpy( CurrSource, currline->line );

	mov	r8, QWORD PTR ModuleInfo+464
	lea	rdx, QWORD PTR [rbx+8]
	npad	2
$LL6@RunLineQue:
	movzx	eax, BYTE PTR [rdx]
	inc	r8
	inc	rdx
	test	al, al
	mov	BYTE PTR [r8-1], al
	jne	SHORT $LL6@RunLineQue

; 200  :         DebugCmd ( lqlines_read++ );
; 201  :         MemFree( currline );

	mov	rcx, rbx
	call	MemFree

; 202  :         if ( PreprocessLine( CurrSource, tokenarray ) )

	mov	rcx, QWORD PTR ModuleInfo+464
	mov	rdx, rsi
	call	PreprocessLine
	test	eax, eax
	je	SHORT $LN1@RunLineQue

; 203  :             ParseLine( tokenarray );

	mov	rcx, rsi
	call	ParseLine
$LN1@RunLineQue:
	test	rdi, rdi

; 204  :         currline = nextline;

	mov	rbx, rdi
	jne	SHORT $LL3@RunLineQue
	mov	ecx, DWORD PTR ModuleInfo+456
	mov	rdi, QWORD PTR [rsp+104]
$LN2@RunLineQue:

; 205  :     }
; 206  : 
; 207  : #ifdef DEBUG_OUT
; 208  :     if ( ModuleInfo.EndDirFound == TRUE ) {
; 209  :         DebugMsg(("!!!!! Warning: End directive found in generated-code parser loop!\n"));
; 210  :     }
; 211  : #endif
; 212  :     ModuleInfo.GeneratedCode--;

	add	ecx, -1					; ffffffffH
	mov	DWORD PTR ModuleInfo+456, ecx

; 213  :     PopInputStatus( &oldstat );

	lea	rcx, QWORD PTR oldstat$[rsp]
	call	PopInputStatus
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [rsp+88]

; 214  : 
; 215  :     DebugMsg1(( "RunLineQueue() exit\n" ));
; 216  :     return;
; 217  : }

	add	rsp, 72					; 00000048H
	ret	0
RunLineQueue ENDP
_TEXT	ENDS
END
