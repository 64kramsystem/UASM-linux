; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	minintvalues
PUBLIC	maxintvalues
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
maxintvalues DQ	00000000ffffffffH
	DQ	00000000ffffffffH
	DQ	7fffffffffffffffH
minintvalues DQ	ffffffff00000000H
	DQ	ffffffff00000000H
	DQ	8000000000000000H
CONST	ENDS
EXTRN	BackPatch:NEAR
EXTRN	ModuleInfo:BYTE
EXTRN	Parse_Pass:DWORD
xdata	SEGMENT
$unwind$SetValue DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetValue DD @imagerel(SetValue#)
	DD	@imagerel(SetValue#+277)
	DD	@imagerel($unwind$SetValue#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\equate.c
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
opndx$ = 56
SetValue PROC NEAR

; 58   : {

	sub	rsp, 40					; 00000028H

; 59   : 
; 60   :     sym->isequate = TRUE;
; 61   :     sym->state = SYM_INTERNAL;
; 62   :     sym->isdefined = TRUE;

	or	BYTE PTR [rcx+48], 18
	mov	r9d, 1
	mov	r8, rcx
	mov	DWORD PTR [rcx+40], r9d

; 63   :     if ( opndx->kind == EXPR_CONST ) {

	cmp	DWORD PTR [rdx+60], 0
	jne	SHORT $LN8@SetValue

; 64   :         /* v2.07: use expression's memtype */
; 65   :         //sym->mem_type = MT_ABS;
; 66   :         sym->mem_type = opndx->mem_type;

	mov	eax, DWORD PTR [rdx+64]
	mov	DWORD PTR [rcx+44], eax

; 67   :         sym->uvalue = opndx->uvalue;

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+16], eax

; 68   :         sym->value3264 = opndx->hvalue;

	mov	eax, DWORD PTR [rdx+4]

; 69   :         sym->segment = NULL;
; 70   :         sym->isproc = FALSE;

	and	BYTE PTR [rcx+49], 247			; 000000f7H
	mov	DWORD PTR [rcx+64], eax
	mov	QWORD PTR [rcx+32], 0

; 116  :         }
; 117  : #endif
; 118  :     }
; 119  :     return;
; 120  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@SetValue:

; 71   :     } else {
; 72   :         sym->isproc = opndx->sym->isproc;

	mov	rax, QWORD PTR [rdx+80]
	movzx	ecx, BYTE PTR [rax+49]
	xor	cl, BYTE PTR [r8+49]
	and	cl, 8
	xor	BYTE PTR [r8+49], cl

; 73   :         /* for a PROC alias, copy the procinfo extension! */
; 74   :         if ( sym->isproc ) {

	test	BYTE PTR [r8+49], 8
	je	SHORT $LN6@SetValue

; 75   :             struct dsym *dir = (struct dsym *)sym;
; 76   :             dir->e.procinfo = ((struct dsym *)opndx->sym)->e.procinfo;

	mov	rax, QWORD PTR [rdx+80]
	mov	rcx, QWORD PTR [rax+104]
	mov	QWORD PTR [r8+104], rcx
$LN6@SetValue:

; 77   :         }
; 78   :         sym->mem_type = opndx->mem_type;

	mov	eax, DWORD PTR [rdx+64]
	mov	DWORD PTR [r8+44], eax

; 79   :         /* v2.01: allow equates of variables with arbitrary type.
; 80   :          * Currently the expression evaluator sets opndx.mem_type
; 81   :          * to the mem_type of the type (i.e. QWORD for a struct with size 8),
; 82   :          * which is a bad idea in this case. So the original mem_type of the
; 83   :          * label is used instead.
; 84   :          */
; 85   :         if ( opndx->sym->mem_type == MT_TYPE && opndx->explicit == FALSE ) {

	mov	rax, QWORD PTR [rdx+80]
	cmp	DWORD PTR [rax+44], 196			; 000000c4H
	jne	SHORT $LN5@SetValue
	test	BYTE PTR [rdx+72], 2
	jne	SHORT $LN5@SetValue

; 86   :             sym->mem_type = opndx->sym->mem_type;

	mov	ecx, DWORD PTR [rax+44]
	mov	DWORD PTR [r8+44], ecx

; 87   :             sym->type = opndx->sym->type;

	mov	rax, QWORD PTR [rdx+80]
	mov	rcx, QWORD PTR [rax+88]
	mov	QWORD PTR [r8+88], rcx
$LN5@SetValue:

; 88   :         }
; 89   :         sym->value3264 = 0; /* v2.09: added */
; 90   :         sym->segment = opndx->sym->segment;
; 91   : #if 1 /* v2.10: added */
; 92   :         /* labels are supposed to be added to the current segment's label_list chain.
; 93   :          * this isn't done for alias equates, for various reasons.
; 94   :          * consequently, if the alias was forward referenced, ensure that a third pass
; 95   :          * will be done! regression test forward5.asm.
; 96   :          */
; 97   :         if ( sym->variable ) {

	test	BYTE PTR [r8+48], 64			; 00000040H
	mov	DWORD PTR [r8+64], 0
	mov	rax, QWORD PTR [rdx+80]
	mov	rcx, QWORD PTR [rax+32]
	mov	QWORD PTR [r8+32], rcx
	je	SHORT $LN4@SetValue

; 98   :             sym->offset = opndx->sym->offset + opndx->value;

	mov	rax, QWORD PTR [rdx+80]
	mov	ecx, DWORD PTR [rax+16]
	add	ecx, DWORD PTR [rdx]
	mov	DWORD PTR [r8+16], ecx

; 99   :             if ( Parse_Pass == PASS_2 && sym->fwdref ) {

	cmp	DWORD PTR Parse_Pass, r9d
	jne	SHORT $LN2@SetValue
	test	BYTE PTR [r8+49], 32			; 00000020H
	je	SHORT $LN2@SetValue

; 100  : #ifdef DEBUG_OUT
; 101  :                 if ( !ModuleInfo.PhaseError )
; 102  :                     DebugMsg(("SetValue(%s): Phase error, enforced by alias equate\n", sym->name ));
; 103  : #endif
; 104  :                 ModuleInfo.PhaseError = TRUE;

	mov	BYTE PTR ModuleInfo+422, r9b

; 116  :         }
; 117  : #endif
; 118  :     }
; 119  :     return;
; 120  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@SetValue:

; 105  :             }
; 106  :         } else {
; 107  :             if( Parse_Pass != PASS_1 && sym->offset != ( opndx->sym->offset + opndx->value ) ) {

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN1@SetValue
	mov	rax, QWORD PTR [rdx+80]
	mov	ecx, DWORD PTR [rax+16]
	movzx	eax, BYTE PTR ModuleInfo+422
	add	ecx, DWORD PTR [rdx]
	cmp	DWORD PTR [r8+16], ecx
	cmovne	eax, r9d
	mov	BYTE PTR ModuleInfo+422, al
$LN1@SetValue:

; 108  : #ifdef DEBUG_OUT
; 109  :                 if ( !ModuleInfo.PhaseError )
; 110  :                     DebugMsg1(("SetValue(%s): Phase error, enforced by alias equate %" I32_SPEC "X != %" I32_SPEC "X\n", sym->name, sym->offset, opndx->sym->offset + opndx->value ));
; 111  : #endif
; 112  :                 ModuleInfo.PhaseError = TRUE;
; 113  :             }
; 114  :             sym->offset = opndx->sym->offset + opndx->value;

	mov	rax, QWORD PTR [rdx+80]
	mov	ecx, DWORD PTR [rax+16]
	add	ecx, DWORD PTR [rdx]
	mov	DWORD PTR [r8+16], ecx

; 115  :             BackPatch( sym );

	mov	rcx, r8
	call	BackPatch
$LN2@SetValue:

; 116  :         }
; 117  : #endif
; 118  :     }
; 119  :     return;
; 120  : }

	add	rsp, 40					; 00000028H
	ret	0
SetValue ENDP
_TEXT	ENDS
EXTRN	sym_remove_table:NEAR
EXTRN	SymTables:BYTE
EXTRN	SymCreate:NEAR
EXTRN	SaveVariableState:NEAR
EXTRN	sym_ext2int:NEAR
EXTRN	SymFind:NEAR
EXTRN	__ImageBase:BYTE
EXTRN	EmitConstError:NEAR
EXTRN	EmitError:NEAR
EXTRN	StoreLine:NEAR
EXTRN	StoreState:BYTE
EXTRN	EmitErr:NEAR
EXTRN	EvalOperand:NEAR
EXTRN	myatoi128:NEAR
xdata	SEGMENT
$unwind$CreateAssemblyTimeVariable DD 061601H
	DD	0197416H
	DD	0183412H
	DD	015010aH
xdata	ENDS
pdata	SEGMENT
$pdata$CreateAssemblyTimeVariable DD @imagerel(CreateAssemblyTimeVariable#)
	DD	@imagerel(CreateAssemblyTimeVariable#+640)
	DD	@imagerel($unwind$CreateAssemblyTimeVariable#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
opnd$ = 48
i$ = 176
tokenarray$ = 176
CreateAssemblyTimeVariable PROC NEAR

; 128  : {

	mov	rax, rsp
	sub	rsp, 168				; 000000a8H

; 129  :     struct asym         *sym;
; 130  :     const char          *name = tokenarray[0].string_ptr;
; 131  :     int                 i = 2;
; 132  :     struct expr         opnd;
; 133  : 
; 134  :     DebugMsg1(( "CreateAssemblyTimeVariable(%s) enter\n", name ));
; 135  : 
; 136  :     /* v2.08: for plain numbers ALWAYS avoid to call evaluator */
; 137  :     if ( tokenarray[2].token == T_NUM &&
; 138  :         //tokenarray[3].token == T_FINAL &&
; 139  :         //tokenarray[2].itemlen <= 8 ) {
; 140  :         tokenarray[3].token == T_FINAL ) {

	cmp	BYTE PTR [rcx+64], 10
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax+32], rdi
	mov	rdi, QWORD PTR [rcx+8]
	mov	rbx, rcx
	mov	DWORD PTR [rax+8], 2
	jne	SHORT $LN29@CreateAsse
	cmp	BYTE PTR [rcx+96], 0
	jne	SHORT $LN29@CreateAsse

; 141  :         //opnd.llvalue = tokenarray[2].value64;
; 142  :         //opnd.llvalue = *(uint_64 *)(tokenarray[2].string_ptr - sizeof(uint_64) );
; 143  :         myatoi128( tokenarray[i].string_ptr, &opnd.llvalue, tokenarray[i].numbase, tokenarray[i].itemlen );

	movsx	r8d, BYTE PTR [rcx+65]
	mov	r9d, DWORD PTR [rcx+80]
	mov	rcx, QWORD PTR [rcx+72]
	lea	rdx, QWORD PTR [rax-120]
	call	myatoi128
	mov	r11, QWORD PTR opnd$[rsp+8]
	jmp	$check_number$5688
$LN29@CreateAsse:

; 153  :         }
; 154  :     } else {
; 155  :         /* v2.09: don't create not-(yet)-defined symbols. Example:
; 156  :          * E1 = E1 or 1
; 157  :          * must NOT create E1.
; 158  :          */
; 159  :         if ( EvalOperand( &i, tokenarray, Token_Count, &opnd, 0 ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rdx, rcx
	lea	r9, QWORD PTR opnd$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	BYTE PTR [rsp+32], 0
	call	EvalOperand
	cmp	eax, -1

; 160  :             return( NULL );

	je	$LN33@CreateAsse

; 161  :         if( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, DWORD PTR i$[rsp]
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbx], 0
	je	SHORT $LN24@CreateAsse

; 162  :             EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	mov	rdx, QWORD PTR [rdx+rbx+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 163  :             return( NULL );

	xor	eax, eax
	jmp	$LN30@CreateAsse
$LN24@CreateAsse:

; 164  :         }
; 165  : 
; 166  :         /* expression may be a constant or a relocatable item.
; 167  :          * v2.09: kind may be EXPR_CONST and still include an undefined symbol.
; 168  :          * This is caused by MakeConst() in expreval.c. Brackets changed so
; 169  :          * opnd.sym is also checked for opnd.kind == EXPR_CONST.
; 170  :          */
; 171  :         if( opnd.kind != EXPR_CONST &&
; 172  :            ( opnd.kind != EXPR_ADDR || opnd.indirect == TRUE ) ||
; 173  :             ( opnd.sym != NULL && opnd.sym->state != SYM_INTERNAL ) ) {

	mov	edx, DWORD PTR opnd$[rsp+60]
	mov	rax, QWORD PTR opnd$[rsp+80]
	mov	ecx, DWORD PTR opnd$[rsp+72]
	test	edx, edx
	je	SHORT $LN21@CreateAsse
	cmp	edx, 1
	jne	SHORT $LN22@CreateAsse
	test	cl, dl
	jne	SHORT $LN22@CreateAsse
$LN21@CreateAsse:
	test	rax, rax
	je	SHORT $LN23@CreateAsse
	cmp	DWORD PTR [rax+40], 1
	je	SHORT $LN23@CreateAsse
$LN22@CreateAsse:

; 174  :             DebugMsg(( "CreateAssemblyTimeVariable(%s) kind=%u sym=%p state=%u\n", name, opnd.kind, opnd.sym, opnd.sym ? opnd.sym->state : 0 ));
; 175  :             /* v2.09: no error if argument is a forward reference,
; 176  :              * but don't create the variable either. Will enforce an
; 177  :              * error if referenced symbol is still undefined in pass 2.
; 178  :              */
; 179  :             if( opnd.sym && opnd.sym->state == SYM_UNDEFINED && opnd.indirect == FALSE ) {

	test	rax, rax
	je	SHORT $LN20@CreateAsse
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN20@CreateAsse
	test	cl, 1
	jne	SHORT $LN20@CreateAsse

; 180  : #if FASTPASS
; 181  :                 if ( StoreState == FALSE ) FStoreLine(0); /* make sure this line is evaluated in pass two */

	cmp	BYTE PTR StoreState, 0
	jne	SHORT $LN16@CreateAsse
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN16@CreateAsse
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	xor	edx, edx
	call	StoreLine

; 185  :             return( NULL );

	xor	eax, eax
	jmp	$LN30@CreateAsse
$LN20@CreateAsse:

; 182  : #endif
; 183  :             } else
; 184  :                 EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError
$LN16@CreateAsse:

; 185  :             return( NULL );

	xor	eax, eax
	jmp	$LN30@CreateAsse
$LN23@CreateAsse:

; 186  :         }
; 187  : 
; 188  :         /* v2.08: accept any result that fits in 64-bits from expression evaluator */
; 189  :         if ( opnd.hlvalue != 0 ) {

	mov	r11, QWORD PTR opnd$[rsp+8]
	test	r11, r11
	je	SHORT $LN15@CreateAsse
$LN27@CreateAsse:

; 190  :             EmitConstError( &opnd );

	lea	rcx, QWORD PTR opnd$[rsp]
	call	EmitConstError

; 191  :             return( NULL );

	xor	eax, eax
	jmp	$LN30@CreateAsse
$LN15@CreateAsse:

; 192  :         }
; 193  :         /* for quoted strings, the same restrictions as for plain numbers apply */
; 194  :         if ( opnd.quoted_string )

	cmp	QWORD PTR opnd$[rsp+16], 0
	je	SHORT $LN14@CreateAsse
$check_number$5688:

; 144  :     check_number:
; 145  :         opnd.kind = EXPR_CONST;
; 146  :         opnd.mem_type = MT_EMPTY; /* v2.07: added */
; 147  :         /* v2.08: check added. the number must be 32-bit */
; 148  :         if ( opnd.hlvalue != 0 ||
; 149  :             opnd.value64 < minintvalues[ModuleInfo.Ofssize] ||
; 150  :             opnd.value64 > maxintvalues[ModuleInfo.Ofssize] ) {

	test	r11, r11
	mov	DWORD PTR opnd$[rsp+60], 0
	mov	DWORD PTR opnd$[rsp+64], 192		; 000000c0H
	jne	SHORT $LN27@CreateAsse
	movzx	eax, BYTE PTR ModuleInfo+404
	mov	rcx, QWORD PTR opnd$[rsp]
	lea	rdx, OFFSET FLAT:__ImageBase
	cmp	rcx, QWORD PTR minintvalues[rdx+rax*8]
	jl	SHORT $LN27@CreateAsse
	cmp	rcx, QWORD PTR maxintvalues[rdx+rax*8]

; 151  :             EmitConstError( &opnd );
; 152  :             return( NULL );

	jg	SHORT $LN27@CreateAsse
$LN14@CreateAsse:

; 195  :             goto check_number;
; 196  :     }
; 197  : 
; 198  :     sym = SymSearch( name );

	mov	rcx, rdi
	call	SymFind

; 199  :     if( sym == NULL || sym->state == SYM_UNDEFINED ) {

	test	rax, rax
	mov	rbx, rax
	je	$LN32@CreateAsse
	mov	eax, DWORD PTR [rax+40]
	test	eax, eax
	je	$LN11@CreateAsse

; 209  : #endif
; 210  :     //} else if ( sym->state == SYM_EXTERNAL && sym->weak == TRUE && sym->mem_type == MT_ABS ) {
; 211  :     } else if ( sym->state == SYM_EXTERNAL && sym->weak == TRUE && sym->mem_type == MT_EMPTY ) {

	cmp	eax, 2
	jne	SHORT $LN8@CreateAsse
	test	BYTE PTR [rbx+55], 8
	je	SHORT $LN8@CreateAsse
	cmp	DWORD PTR [rbx+44], 192			; 000000c0H
	jne	SHORT $LN8@CreateAsse

; 212  :         sym_ext2int( sym );

	mov	rcx, rbx
	call	sym_ext2int

; 213  :         //sym->variable  = TRUE;
; 214  : #if FASTPASS
; 215  :         sym->issaved = StoreState; /* v2.10: added */

	movzx	eax, BYTE PTR StoreState
	shl	al, 4
	xor	al, BYTE PTR [rbx+49]
	and	al, 16
	xor	BYTE PTR [rbx+49], al

; 216  : #endif
; 217  :     } else {

	jmp	SHORT $LN3@CreateAsse
$LN8@CreateAsse:

; 218  :         if ( sym->state != SYM_INTERNAL ||
; 219  :             ( sym->variable == FALSE &&
; 220  :              ( opnd.uvalue != sym->uvalue || opnd.hvalue != sym->value3264 ) ) ) {

	cmp	eax, 1
	jne	SHORT $LN4@CreateAsse
	test	BYTE PTR [rbx+48], 64			; 00000040H
	jne	SHORT $LN6@CreateAsse
	mov	eax, DWORD PTR [rbx+16]
	cmp	DWORD PTR opnd$[rsp], eax
	jne	SHORT $LN4@CreateAsse
	mov	eax, DWORD PTR [rbx+64]
	cmp	DWORD PTR opnd$[rsp+4], eax
	jne	SHORT $LN4@CreateAsse
$LN6@CreateAsse:

; 223  :         }
; 224  : #if FASTPASS
; 225  :         /* v2.04a regression in v2.04. Do not save the variable when it
; 226  :          * is defined the first time
; 227  :          * v2.10: store state only when variable is changed and has been
; 228  :          * defined BEFORE SaveState() has been called.
; 229  :          */
; 230  :         //if ( StoreState && sym->issaved == FALSE && sym->isdefined == TRUE ) {
; 231  :         if ( StoreState && sym->issaved == FALSE ) {

	cmp	BYTE PTR StoreState, 0
	je	SHORT $LN3@CreateAsse
	test	BYTE PTR [rbx+49], 16
	jne	SHORT $LN3@CreateAsse

; 232  :             SaveVariableState( sym );

	mov	rcx, rbx
	call	SaveVariableState
	jmp	SHORT $LN3@CreateAsse
$LN4@CreateAsse:

; 221  :             EmitErr( SYMBOL_REDEFINITION, sym->name );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
$LN33@CreateAsse:

; 222  :             return( NULL );

	xor	eax, eax
	jmp	SHORT $LN30@CreateAsse
$LN32@CreateAsse:

; 200  :         if( sym == NULL ) {
; 201  :             sym = SymCreate( name );

	mov	rcx, rdi
	call	SymCreate
	mov	rbx, rax

; 202  :         } else {

	jmp	SHORT $LN10@CreateAsse
$LN11@CreateAsse:

; 203  :             sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rbx
	call	sym_remove_table

; 204  :             sym->fwdref = TRUE;

	or	BYTE PTR [rbx+49], 32			; 00000020H
$LN10@CreateAsse:

; 205  :         }
; 206  :         //sym->variable  = TRUE;
; 207  : #if FASTPASS
; 208  :         sym->issaved = StoreState; /* v2.10: added */

	movzx	eax, BYTE PTR StoreState
	shl	al, 4
	xor	al, BYTE PTR [rbx+49]
	and	al, 16
	xor	BYTE PTR [rbx+49], al
$LN3@CreateAsse:

; 233  :         }
; 234  : #endif
; 235  :     }
; 236  :     sym->variable = TRUE;

	or	BYTE PTR [rbx+48], 64			; 00000040H

; 237  : #ifdef DEBUG_OUT
; 238  :     if ( Parse_Pass > PASS_1 ) {
; 239  :         if ( opnd.kind == EXPR_CONST && sym->uvalue != opnd.uvalue )
; 240  :             DebugMsg1(( "CreateAssemblyTimeVariable(%s): kind=%u, value changed ( %d -> %d )\n", name, opnd.kind, sym->uvalue, opnd.uvalue ) );
; 241  :         else if ( opnd.kind == EXPR_ADDR && sym->uvalue != ( opnd.uvalue + opnd.sym->uvalue ) )
; 242  :             DebugMsg1(( "CreateAssemblyTimeVariable(%s): kind=%u, value changed ( %d -> %d )\n", name, opnd.kind, sym->uvalue, opnd.uvalue + opnd.sym->uvalue ) );
; 243  :     }
; 244  : #endif
; 245  :     /* v2.09: allow internal variables to be set */
; 246  :     if ( sym->predefined && sym->sfunc_ptr )

	test	BYTE PTR [rbx+48], 32			; 00000020H
	je	SHORT $LN2@CreateAsse
	mov	rax, QWORD PTR [rbx+72]
	test	rax, rax
	je	SHORT $LN2@CreateAsse

; 247  :         sym->sfunc_ptr( sym, &opnd );

	lea	rdx, QWORD PTR opnd$[rsp]
	mov	rcx, rbx
	call	rax

; 248  :     else

	jmp	SHORT $LN1@CreateAsse
$LN2@CreateAsse:

; 249  :         SetValue( sym, &opnd );

	lea	rdx, QWORD PTR opnd$[rsp]
	mov	rcx, rbx
	call	SetValue
$LN1@CreateAsse:

; 250  :     DebugMsg1(( "CreateAssemblyTimeVariable(%s) memtype=%Xh value=%d\n", name, sym->mem_type, sym->value ));
; 251  :     return( sym );

	mov	rax, rbx
$LN30@CreateAsse:
	mov	rdi, QWORD PTR [rsp+200]
	mov	rbx, QWORD PTR [rsp+192]

; 252  : }

	add	rsp, 168				; 000000a8H
	ret	0
CreateAssemblyTimeVariable ENDP
_TEXT	ENDS
PUBLIC	EqualSgnDirective
EXTRN	LstWrite:NEAR
xdata	SEGMENT
$unwind$EqualSgnDirective DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$EqualSgnDirective DD @imagerel($LN6#)
	DD	@imagerel($LN6#+80)
	DD	@imagerel($unwind$EqualSgnDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
EqualSgnDirective PROC NEAR

; 258  : {

$LN6:
	sub	rsp, 40					; 00000028H

; 259  :     struct asym *sym;
; 260  : 
; 261  :     if( tokenarray[0].token != T_ID ) {

	cmp	BYTE PTR [rdx], 8
	je	SHORT $LN3@EqualSgnDi

; 262  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 209				; 000000d1H

; 271  : }

	add	rsp, 40					; 00000028H
	jmp	EmitErr
$LN3@EqualSgnDi:

; 263  :     }
; 264  :     if ( sym = CreateAssemblyTimeVariable( tokenarray ) ) {

	mov	rcx, rdx
	call	CreateAssemblyTimeVariable
	test	rax, rax
	je	SHORT $LN2@EqualSgnDi

; 265  :         if ( ModuleInfo.list == TRUE ) {

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN1@EqualSgnDi

; 266  :             LstWrite( LSTTYPE_EQUATE, 0, sym );

	xor	edx, edx
	mov	r8, rax
	lea	ecx, QWORD PTR [rdx+2]
	call	LstWrite
$LN1@EqualSgnDi:

; 267  :         }
; 268  :         return( NOT_ERROR );

	xor	eax, eax

; 271  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@EqualSgnDi:

; 269  :     }
; 270  :     return( ERROR );

	mov	eax, -1

; 271  : }

	add	rsp, 40					; 00000028H
	ret	0
EqualSgnDirective ENDP
_TEXT	ENDS
PUBLIC	CreateVariable
xdata	SEGMENT
$unwind$CreateVariable DD 071301H
	DD	097413H
	DD	08640eH
	DD	073409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$CreateVariable DD @imagerel($LN9#)
	DD	@imagerel($LN9#+237)
	DD	@imagerel($unwind$CreateVariable#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
value$ = 56
CreateVariable PROC NEAR

; 280  : {

$LN9:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx
	mov	esi, edx

; 281  : 	struct asym      *sym;
; 282  : 
; 283  : 	DebugMsg1(("CreateVariable(%s, %d ) enter\n", name, value));
; 284  : 
; 285  : 	sym = SymSearch(name);

	call	SymFind

; 286  : 	if (sym == NULL) {

	test	rax, rax
	mov	rbx, rax
	jne	SHORT $LN6@CreateVari

; 287  : 		sym = SymCreate(name);

	mov	rcx, rdi
	call	SymCreate
	mov	rbx, rax

; 288  : #if FASTPASS
; 289  : 		//sym->issaved = FALSE;
; 290  : 		sym->issaved = StoreState; /* v2.10 */

	movzx	eax, BYTE PTR StoreState
	shl	al, 4
	xor	al, BYTE PTR [rbx+49]
	and	al, 16
	xor	BYTE PTR [rbx+49], al
	jmp	$LN1@CreateVari
$LN6@CreateVari:

; 291  : #endif
; 292  : 	}
; 293  : 	else if (sym->state == SYM_UNDEFINED) {

	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN4@CreateVari

; 294  : 		sym->value3264 = 0;   //fixed by HSE on qWord indication
; 295  : 		sym_remove_table(&SymTables[TAB_UNDEF], (struct dsym *)sym);

	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rax
	mov	DWORD PTR [rax+64], 0
	call	sym_remove_table

; 296  : 		sym->fwdref = TRUE;

	or	BYTE PTR [rbx+49], 32			; 00000020H
	movzx	eax, BYTE PTR [rbx+49]

; 297  : #if FASTPASS
; 298  : 		sym->issaved = StoreState; /* v2.10 */

	movzx	ecx, BYTE PTR StoreState
	shl	cl, 4
	xor	cl, al
	and	cl, 16
	xor	cl, al
	mov	BYTE PTR [rbx+49], cl

; 299  : #endif
; 300  : 	}
; 301  : 	else {

	jmp	SHORT $LN1@CreateVari
$LN4@CreateVari:

; 302  : 		sym->value3264 = 0;  //fixed by HSE on qWord indication
; 303  : 		if (sym->isequate == FALSE) {

	test	BYTE PTR [rax+48], 16
	mov	DWORD PTR [rax+64], 0
	jne	SHORT $LN2@CreateVari

; 304  : 			EmitErr(SYMBOL_REDEFINITION, name);

	mov	rdx, rdi
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 305  : 			return(NULL);

	xor	eax, eax
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 326  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@CreateVari:

; 306  : 		}
; 307  : #if FASTPASS
; 308  : 		/*
; 309  : 		* v2.09: don't save variable when it is defined the first time
; 310  : 		* v2.10: store state only when variable is changed and has been
; 311  : 		* defined BEFORE SaveState() has been called.
; 312  : 		*/
; 313  : 		//if ( StoreState && sym->issaved == FALSE && sym->isdefined == TRUE ) {
; 314  : 		if (StoreState && sym->issaved == FALSE) {

	cmp	BYTE PTR StoreState, 0
	je	SHORT $LN1@CreateVari
	test	BYTE PTR [rax+49], 16
	jne	SHORT $LN1@CreateVari

; 315  : 			SaveVariableState(sym);

	mov	rcx, rax
	call	SaveVariableState
$LN1@CreateVari:

; 316  : 		}
; 317  : #endif
; 318  : 	}
; 319  : 	sym->isdefined = TRUE;
; 320  : 	sym->state = SYM_INTERNAL;
; 321  : 	//sym->mem_type = MT_ABS;
; 322  : 	sym->variable = TRUE;
; 323  : 	sym->value = value;
; 324  : 	sym->isequate = TRUE;

	or	BYTE PTR [rbx+48], 82			; 00000052H
	mov	rdi, QWORD PTR [rsp+72]
	mov	DWORD PTR [rbx+16], esi
	mov	rsi, QWORD PTR [rsp+64]
	mov	DWORD PTR [rbx+40], 1

; 325  : 	return(sym);

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]

; 326  : }

	add	rsp, 40					; 00000028H
	ret	0
CreateVariable ENDP
_TEXT	ENDS
PUBLIC	CreateConstant
EXTRN	ExpandLineItems:NEAR
EXTRN	SetTextMacro:NEAR
xdata	SEGMENT
$unwind$CreateConstant DD 0a2101H
	DD	096c421H
	DD	09b741aH
	DD	09a6412H
	DD	098340eH
	DD	097010aH
xdata	ENDS
pdata	SEGMENT
$pdata$CreateConstant DD @imagerel($LN44#)
	DD	@imagerel($LN44#+208)
	DD	@imagerel($unwind$CreateConstant#)
pdata	ENDS
xdata	SEGMENT
$chain$4$CreateConstant DD 020821H
	DD	0995408H
	DD	@imagerel($LN44#)
	DD	@imagerel($LN44#+208)
	DD	@imagerel($unwind$CreateConstant#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$CreateConstant DD @imagerel($LN44#+208)
	DD	@imagerel($LN44#+613)
	DD	@imagerel($chain$4$CreateConstant#)
pdata	ENDS
xdata	SEGMENT
$chain$5$CreateConstant DD 021H
	DD	@imagerel($LN44#)
	DD	@imagerel($LN44#+208)
	DD	@imagerel($unwind$CreateConstant#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$CreateConstant DD @imagerel($LN44#+613)
	DD	@imagerel($LN44#+653)
	DD	@imagerel($chain$5$CreateConstant#)
pdata	ENDS
xdata	SEGMENT
$chain$6$CreateConstant DD 020021H
	DD	0995400H
	DD	@imagerel($LN44#)
	DD	@imagerel($LN44#+208)
	DD	@imagerel($unwind$CreateConstant#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$CreateConstant DD @imagerel($LN44#+653)
	DD	@imagerel($LN44#+850)
	DD	@imagerel($chain$6$CreateConstant#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
opnd$ = 64
argbuffer$ = 176
tokenarray$ = 1216
CreateConstant PROC NEAR

; 344  : {

$LN44:
	mov	rax, rsp
	sub	rsp, 1208				; 000004b8H
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+24], rsi

; 345  :     struct asym         *sym;
; 346  :     const char          *name = tokenarray[0].string_ptr;

	mov	rsi, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+32], rdi
	mov	rdi, rcx
	mov	QWORD PTR [rax-8], r12

; 347  :     int                 i = 2;
; 348  :     ret_code            rc;
; 349  :     char                *p;
; 350  :     bool                cmpvalue = FALSE;
; 351  :     struct expr         opnd;
; 352  :     char                argbuffer[MAX_LINE_LEN];
; 353  : 
; 354  :     DebugMsg1(( "CreateConstant(%s) enter\n", name ));
; 355  : 
; 356  :     sym = SymSearch( name );

	mov	rcx, rsi
	mov	DWORD PTR i$[rsp], 2
	xor	r12b, r12b
	call	SymFind

; 357  : 
; 358  :     /* if a literal follows, the equate MUST be(come) a text macro */
; 359  :     if ( tokenarray[2].token == T_STRING && tokenarray[2].string_delim == '<' )

	cmp	BYTE PTR [rdi+64], 9
	mov	rbx, rax
	jne	SHORT $LN34@CreateCons
	cmp	BYTE PTR [rdi+65], 60			; 0000003cH
	jne	SHORT $LN34@CreateCons

; 360  :         return ( SetTextMacro( tokenarray, sym, name, NULL ) );

	xor	r9d, r9d
	mov	r8, rsi
	mov	rdx, rax
	mov	rcx, rdi
	call	SetTextMacro
	jmp	$LN35@CreateCons
$LN34@CreateCons:

; 361  : 
; 362  :     if( sym == NULL ||
; 363  :        sym->state == SYM_UNDEFINED ||
; 364  :        ( sym->state == SYM_EXTERNAL && sym->weak == TRUE && sym->isproc == FALSE ) ) {

	test	rax, rax
	mov	edx, 1
	je	SHORT $LN32@CreateCons
	mov	eax, DWORD PTR [rax+40]
	test	eax, eax
	je	SHORT $LN32@CreateCons
	cmp	eax, 2
	jne	SHORT $LN33@CreateCons
	test	BYTE PTR [rbx+55], 8
	je	SHORT $LN33@CreateCons
	test	BYTE PTR [rbx+49], 8
	je	SHORT $LN32@CreateCons
$LN33@CreateCons:

; 365  :         /* It's a "new" equate.
; 366  :          * wait with definition until type of equate is clear
; 367  :          */
; 368  :     } else if( sym->state == SYM_TMACRO ) {

	cmp	eax, 10
	jne	SHORT $LN30@CreateCons

; 369  : 
; 370  :         return ( SetTextMacro( tokenarray, sym, name, tokenarray[2].tokpos ) );

	mov	r9, QWORD PTR [rdi+88]
	mov	r8, rsi
	mov	rdx, rbx
	mov	rcx, rdi
	call	SetTextMacro
	jmp	$LN35@CreateCons
$LN30@CreateCons:

; 371  : 
; 372  :     } else if( sym->isequate == FALSE ) {

	test	BYTE PTR [rbx+48], 16
	jne	SHORT $LN28@CreateCons

; 373  : 
; 374  :         DebugMsg1(( "CreateConstant(%s) state=%u, mem_type=%Xh, value=%" I32_SPEC "X, symbol redefinition\n", name, sym->state, sym->mem_type, sym->value));
; 375  :         EmitErr( SYMBOL_REDEFINITION, name );

	mov	rdx, rsi
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 376  :         return( NULL );

	xor	eax, eax
	jmp	$LN35@CreateCons
$LN28@CreateCons:

; 377  : 
; 378  :     } else {
; 379  :         if ( sym->asmpass == ( Parse_Pass & 0xFF ) )

	mov	eax, DWORD PTR Parse_Pass
	movzx	r12d, r12b
	cmp	BYTE PTR [rbx+54], al

; 380  :             cmpvalue = TRUE;
; 381  :         sym->asmpass = Parse_Pass;

	mov	BYTE PTR [rbx+54], al
	cmove	r12d, edx
$LN32@CreateCons:

; 382  :     }
; 383  : 
; 384  :     /* try to evaluate the expression */
; 385  : 
; 386  :     if ( tokenarray[2].token == T_NUM && Token_Count == 3 ) {

	cmp	BYTE PTR [rdi+64], 10
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	QWORD PTR [rsp+1224], rbp
	jne	SHORT $LN25@CreateCons
	cmp	r8d, 3
	jne	SHORT $LN25@CreateCons

; 387  : 
; 388  :         p = tokenarray[2].string_ptr;

	mov	rbp, QWORD PTR [rdi+72]
	jmp	SHORT $do_single_number$5776
$LN25@CreateCons:

; 409  :         p = tokenarray[2].tokpos;
; 410  :         if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	rbp, QWORD PTR [rdi+88]
	jne	$LN19@CreateCons

; 411  :             /* if the expression cannot be evaluated to a numeric value,
; 412  :              * it's to become a text macro. The value of this macro will be
; 413  :              * the original (unexpanded!) line - that's why it has to be
; 414  :              * saved here to argbuffer[].
; 415  :              */
; 416  :             strcpy( argbuffer, p );

	lea	r8, QWORD PTR argbuffer$[rsp]
	mov	rcx, rbp
	sub	r8, rbp
	npad	11
$LL37@CreateCons:
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [r8+rcx-1], al
	jne	SHORT $LL37@CreateCons

; 417  :             DebugMsg1(("CreateConstant(%s): before ExpandLineItems: >%s<\n", name, p ));
; 418  :             /* expand EQU argument (macro functions won't be expanded!) */
; 419  :             if ( ExpandLineItems( p, 2, tokenarray, FALSE, TRUE ) )

	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], edx
	mov	r8, rdi
	lea	edx, QWORD PTR [r9+2]
	mov	rcx, rbp
	call	ExpandLineItems
	lea	rcx, QWORD PTR argbuffer$[rsp]
	test	eax, eax
	cmove	rcx, rbp

; 420  :                 /* v2.08: if expansion result is a plain number, handle is specifically.
; 421  :                  * this is necessary because values of expressions may be 64-bit now.
; 422  :                  */
; 423  :                 p = argbuffer; /* ensure that p points to unexpanded source */
; 424  :                 if ( tokenarray[2].token == T_NUM && Token_Count == 3 ) {

	cmp	BYTE PTR [rdi+64], 10
	mov	rbp, rcx
	jne	SHORT $LN40@CreateCons
	mov	r8d, DWORD PTR ModuleInfo+496
	cmp	r8d, 3
	jne	SHORT $LN19@CreateCons
$do_single_number$5776:

; 389  :     do_single_number:
; 390  :         /* value is a plain number. it will be accepted only if it fits into 32-bits.
; 391  :          * Else a text macro is created.
; 392  :          */
; 393  :         myatoi128( tokenarray[2].string_ptr, &opnd.llvalue, tokenarray[2].numbase, tokenarray[2].itemlen );

	movsx	r8d, BYTE PTR [rdi+65]
	mov	r9d, DWORD PTR [rdi+80]
	mov	rcx, QWORD PTR [rdi+72]
	lea	rdx, QWORD PTR opnd$[rsp]
	call	myatoi128
	mov	r11d, DWORD PTR i$[rsp]
	jmp	SHORT $check_single_number$5777
$LN40@CreateCons:
	mov	r8d, DWORD PTR ModuleInfo+496
$LN19@CreateCons:

; 425  :                     goto do_single_number;
; 426  :                 }
; 427  :             DebugMsg1(("CreateConstant(%s): after ExpandLineItems: >%s<\n", name, p ));
; 428  :         }
; 429  :         rc = EvalOperand( &i, tokenarray, Token_Count, &opnd, EXPF_NOERRMSG | EXPF_NOUNDEF );

	lea	r9, QWORD PTR opnd$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rdi
	mov	BYTE PTR [rsp+32], 3
	call	EvalOperand

; 430  : 
; 431  :         /* v2.08: if it's a quoted string, handle it like a plain number */
; 432  :         /* v2.10: quoted_string field is != 0 if kind == EXPR_FLOAT,
; 433  :          * so this is a regression in v2.08-2.09.
; 434  :          */
; 435  :         if ( opnd.quoted_string && opnd.kind == EXPR_CONST ) {

	cmp	QWORD PTR opnd$[rsp+16], 0
	mov	ecx, DWORD PTR opnd$[rsp+60]
	je	SHORT $LN18@CreateCons
	test	ecx, ecx
	jne	SHORT $LN18@CreateCons

; 436  :             i--; /* v2.09: added; regression in v2.08 and v2.08a */

	mov	r11d, DWORD PTR i$[rsp]
	dec	r11d
	mov	DWORD PTR i$[rsp], r11d
$check_single_number$5777:
	mov	r8, QWORD PTR opnd$[rsp+8]
	xor	ecx, ecx
	mov	r9d, -2
	test	r8, r8
	mov	DWORD PTR opnd$[rsp+56], r9d
	mov	DWORD PTR opnd$[rsp+60], ecx
	mov	DWORD PTR opnd$[rsp+64], 192		; 000000c0H
	mov	BYTE PTR opnd$[rsp+72], cl
	jne	SHORT $LN24@CreateCons
	movzx	eax, BYTE PTR ModuleInfo+404
	mov	rdx, QWORD PTR opnd$[rsp]
	lea	r10, OFFSET FLAT:__ImageBase
	cmp	rdx, QWORD PTR minintvalues[r10+rax*8]
	jl	SHORT $LN24@CreateCons

; 394  :     check_single_number:
; 395  :         opnd.instr = EMPTY;
; 396  :         opnd.kind = EXPR_CONST;
; 397  :         opnd.mem_type = MT_EMPTY; /* v2.07: added */
; 398  :         opnd.flags1 = 0;
; 399  :         /* v2.08: does it fit in 32-bits */
; 400  :         if ( opnd.hlvalue == 0 && opnd.value64 >= minintvalues[ModuleInfo.Ofssize] &&
; 401  :             opnd.value64 <= maxintvalues[ModuleInfo.Ofssize] ) {

	cmp	rdx, QWORD PTR maxintvalues[r10+rax*8]
	jg	SHORT $LN24@CreateCons

; 402  :             rc = NOT_ERROR;
; 403  :             DebugMsg1(( "CreateConstant(%s): simple numeric value=%" I64_SPEC "d\n", name, opnd.value64 ));
; 404  :             i++;

	inc	r11d
	mov	DWORD PTR i$[rsp], r11d

; 407  : 
; 408  :     } else {

	jmp	SHORT $LN39@CreateCons
$LN24@CreateCons:

; 405  :         } else
; 406  :             return ( SetTextMacro( tokenarray, sym, name, p ) );

	mov	r9, rbp
	jmp	SHORT $LN43@CreateCons
$LN18@CreateCons:

; 437  :             goto check_single_number;
; 438  :         }
; 439  : 
; 440  :         /* check here if last token has been reached? */
; 441  :     }
; 442  :     /* what is an acceptable 'number' for EQU?
; 443  :      * 1. a numeric value - if magnitude is <= 64 (or 32, if it's a plain number)
; 444  :      *    This includes struct fields.
; 445  :      * 2. an address - if it is direct, has a label and is of type SYM_INTERNAL -
; 446  :      *    that is, no forward references, no seg, groups, externals;
; 447  :      *    Anything else will be stored as a text macro.
; 448  :      * v2.04: large parts rewritten.
; 449  :      */
; 450  :     if ( rc != ERROR &&
; 451  :         tokenarray[i].token == T_FINAL &&
; 452  :         ( ( opnd.kind == EXPR_CONST && opnd.hlvalue == 0 ) || /* magnitude <= 64 bits? */
; 453  :          ( opnd.kind == EXPR_ADDR && opnd.indirect == FALSE &&
; 454  :           opnd.sym != NULL &&
; 455  :           //opnd.sym->state != SYM_EXTERNAL ) ) && /* SYM_SEG, SYM_GROUP are also not ok */
; 456  :           opnd.sym->state == SYM_INTERNAL ) ) &&
; 457  :         ( opnd.instr == EMPTY ) ) {

	cmp	eax, -1
	je	SHORT $LN17@CreateCons
	mov	r11d, DWORD PTR i$[rsp]
	mov	r9d, DWORD PTR opnd$[rsp+56]
	mov	r8, QWORD PTR opnd$[rsp+8]
$LN39@CreateCons:
	movsxd	rax, r11d
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 0
	jne	SHORT $LN17@CreateCons
	test	ecx, ecx
	mov	rdx, QWORD PTR opnd$[rsp+80]
	jne	SHORT $LN15@CreateCons
	test	r8, r8
	je	SHORT $LN16@CreateCons
$LN17@CreateCons:

; 499  :     }
; 500  :     DebugMsg1(("CreateConstant(%s): calling SetTextMacro() [MI.Ofssize=%u]\n", name, ModuleInfo.Ofssize ));
; 501  :     return ( SetTextMacro( tokenarray, sym, name, argbuffer ) );

	lea	r9, QWORD PTR argbuffer$[rsp]
$LN43@CreateCons:
	mov	r8, rsi
	mov	rdx, rbx
	mov	rcx, rdi
	call	SetTextMacro
$LN41@CreateCons:
	mov	rbp, QWORD PTR [rsp+1224]
$LN35@CreateCons:
	mov	r12, QWORD PTR [rsp+1200]
	mov	rdi, QWORD PTR [rsp+1240]
	mov	rsi, QWORD PTR [rsp+1232]
	mov	rbx, QWORD PTR [rsp+1216]

; 502  : }

	add	rsp, 1208				; 000004b8H
	ret	0
$LN15@CreateCons:

; 437  :             goto check_single_number;
; 438  :         }
; 439  : 
; 440  :         /* check here if last token has been reached? */
; 441  :     }
; 442  :     /* what is an acceptable 'number' for EQU?
; 443  :      * 1. a numeric value - if magnitude is <= 64 (or 32, if it's a plain number)
; 444  :      *    This includes struct fields.
; 445  :      * 2. an address - if it is direct, has a label and is of type SYM_INTERNAL -
; 446  :      *    that is, no forward references, no seg, groups, externals;
; 447  :      *    Anything else will be stored as a text macro.
; 448  :      * v2.04: large parts rewritten.
; 449  :      */
; 450  :     if ( rc != ERROR &&
; 451  :         tokenarray[i].token == T_FINAL &&
; 452  :         ( ( opnd.kind == EXPR_CONST && opnd.hlvalue == 0 ) || /* magnitude <= 64 bits? */
; 453  :          ( opnd.kind == EXPR_ADDR && opnd.indirect == FALSE &&
; 454  :           opnd.sym != NULL &&
; 455  :           //opnd.sym->state != SYM_EXTERNAL ) ) && /* SYM_SEG, SYM_GROUP are also not ok */
; 456  :           opnd.sym->state == SYM_INTERNAL ) ) &&
; 457  :         ( opnd.instr == EMPTY ) ) {

	cmp	ecx, 1
	jne	SHORT $LN17@CreateCons
	test	BYTE PTR opnd$[rsp+72], cl
	jne	SHORT $LN17@CreateCons
	test	rdx, rdx
	je	SHORT $LN17@CreateCons
	cmp	DWORD PTR [rdx+40], ecx
	jne	SHORT $LN17@CreateCons
$LN16@CreateCons:
	cmp	r9d, -2
	jne	SHORT $LN17@CreateCons

; 458  : 
; 459  :         if ( !sym ) {

	test	rbx, rbx
	jne	SHORT $LN14@CreateCons

; 460  :             sym = SymCreate( name );

	mov	rcx, rsi
	call	SymCreate
	mov	rbx, rax

; 461  :             sym->asmpass = Parse_Pass;

	movzx	eax, BYTE PTR Parse_Pass
	mov	BYTE PTR [rbx+54], al
$LN2@CreateCons:

; 482  :                 }
; 483  :             }
; 484  :         }
; 485  :         /* change from alias to number is ok if value (=offset) won't change!
; 486  :          * memtype must not be checked!
; 487  :          */
; 488  :         //if ( opnd.kind == EXPR_CONST ) {
; 489  :         //    if ( sym->mem_type != MT_ABS && sym->mem_type != MT_EMPTY ) {
; 490  :         //        EmitErr( SYMBOL_REDEFINITION, name );
; 491  :         //        return( NULL );
; 492  :         //    }
; 493  :         //}
; 494  :         sym->variable = FALSE;

	and	BYTE PTR [rbx+48], 191			; 000000bfH

; 495  :         SetValue( sym, &opnd );

	lea	rdx, QWORD PTR opnd$[rsp]
	mov	rcx, rbx
	call	SetValue

; 496  :         DebugMsg1(("CreateConstant(%s): memtype=%Xh value=%" I64_SPEC "X isproc=%u variable=%u type=%s\n",
; 497  :             name, sym->mem_type, (uint_64)sym->value + ( (uint_64)sym->value3264 << 32), sym->isproc, sym->variable, sym->type ? sym->type->name : "NULL" ));
; 498  :         return( sym );

	mov	rax, rbx
	jmp	SHORT $LN41@CreateCons
$LN14@CreateCons:

; 462  :         } else if ( sym->state == SYM_UNDEFINED ) {

	mov	eax, DWORD PTR [rbx+40]
	test	eax, eax
	jne	SHORT $LN12@CreateCons

; 463  :             sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rbx
	call	sym_remove_table

; 464  :             sym->fwdref = TRUE;

	or	BYTE PTR [rbx+49], 32			; 00000020H
	jmp	SHORT $LN2@CreateCons
$LN12@CreateCons:

; 465  :         } else if ( sym->state == SYM_EXTERNAL ) {

	cmp	eax, 2
	jne	SHORT $LN10@CreateCons

; 466  :             sym_ext2int( sym );

	mov	rcx, rbx
	call	sym_ext2int
	jmp	SHORT $LN2@CreateCons
$LN10@CreateCons:

; 467  :         } else if ( cmpvalue ) {

	test	r12b, r12b
	je	SHORT $LN2@CreateCons

; 468  :             if ( opnd.kind == EXPR_CONST ) {

	test	ecx, ecx
	jne	SHORT $LN7@CreateCons

; 469  :                 /* for 64bit, it may be necessary to check 64bit value! */
; 470  :                 /* v2.08: always compare 64-bit values */
; 471  :                 //if ( sym->value != opnd.value ) {
; 472  :                 if ( sym->value != opnd.value || sym->value3264 != opnd.hvalue ) {

	mov	eax, DWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rbx+16], eax
	jne	SHORT $LN5@CreateCons
	mov	eax, DWORD PTR opnd$[rsp+4]
	cmp	DWORD PTR [rbx+64], eax
$LN42@CreateCons:
	je	SHORT $LN2@CreateCons
$LN5@CreateCons:

; 473  :                     DebugMsg(("CreateConstant(%s), CONST value changed: old=%X, new=%X\n", name, sym->offset, opnd.value ));
; 474  :                     EmitErr( SYMBOL_REDEFINITION, name );

	mov	rdx, rsi
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 475  :                     return( NULL );

	xor	eax, eax
	jmp	$LN41@CreateCons
$LN7@CreateCons:

; 476  :                 }
; 477  :             } else if ( opnd.kind == EXPR_ADDR ) {

	cmp	ecx, 1
	jne	SHORT $LN2@CreateCons

; 478  :                 if ( ( sym->offset != ( opnd.sym->offset + opnd.value ) ) || ( sym->segment != opnd.sym->segment ) ) {

	mov	ecx, DWORD PTR [rdx+16]
	mov	eax, DWORD PTR opnd$[rsp]
	add	ecx, eax
	cmp	DWORD PTR [rbx+16], ecx
	jne	SHORT $LN5@CreateCons
	mov	rax, QWORD PTR [rdx+32]
	cmp	QWORD PTR [rbx+32], rax

; 479  :                     DebugMsg(("CreateConstant(%s), ADDR value changed: old=%X, new ofs+val=%X+%X\n", name, sym->offset, opnd.sym->offset, opnd.value));
; 480  :                     EmitErr( SYMBOL_REDEFINITION, name );
; 481  :                     return( NULL );

	jmp	SHORT $LN42@CreateCons
CreateConstant ENDP
_TEXT	ENDS
PUBLIC	EquDirective
xdata	SEGMENT
$unwind$EquDirective DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$EquDirective DD @imagerel($LN6#)
	DD	@imagerel($LN6#+80)
	DD	@imagerel($unwind$EquDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
EquDirective PROC NEAR

; 513  : {

$LN6:
	sub	rsp, 40					; 00000028H

; 514  :     struct asym *sym;
; 515  : 
; 516  :     if( tokenarray[0].token != T_ID ) {

	cmp	BYTE PTR [rdx], 8
	je	SHORT $LN3@EquDirecti

; 517  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 209				; 000000d1H

; 528  : }

	add	rsp, 40					; 00000028H
	jmp	EmitErr
$LN3@EquDirecti:

; 518  :     }
; 519  :     DebugMsg1(("EquDirective(%s): calling CreateConstant\n", tokenarray[0].string_ptr ));
; 520  :     if ( sym = CreateConstant( tokenarray ) ) {

	mov	rcx, rdx
	call	CreateConstant
	test	rax, rax
	je	SHORT $LN2@EquDirecti

; 521  :         /**/myassert( sym->state == SYM_INTERNAL ); /* must not be a text macro */
; 522  :         if ( ModuleInfo.list == TRUE ) {

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN1@EquDirecti

; 523  :             LstWrite( LSTTYPE_EQUATE, 0, sym );

	xor	edx, edx
	mov	r8, rax
	lea	ecx, QWORD PTR [rdx+2]
	call	LstWrite
$LN1@EquDirecti:

; 524  :         }
; 525  :         return( NOT_ERROR );

	xor	eax, eax

; 528  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@EquDirecti:

; 526  :     }
; 527  :     return( ERROR );

	mov	eax, -1

; 528  : }

	add	rsp, 40					; 00000028H
	ret	0
EquDirective ENDP
_TEXT	ENDS
END
