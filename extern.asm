; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
szCOMM	DB	'COMM', 00H
CONST	ENDS
_DATA	SEGMENT
$SG5735	DB	'ABS', 00H
$SG5859	DB	')', 00H
	ORG $+2
$SG5863	DB	'ABS', 00H
_DATA	ENDS
EXTRN	sym_add_table:NEAR
EXTRN	ModuleInfo:BYTE
EXTRN	sym_remove_table:NEAR
EXTRN	SymTables:BYTE
EXTRN	SymCreate:NEAR
xdata	SEGMENT
$unwind$CreateExternal DD 051101H
	DD	097411H
	DD	08340cH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$CreateExternal DD @imagerel(CreateExternal#)
	DD	@imagerel(CreateExternal#+132)
	DD	@imagerel($unwind$CreateExternal#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\extern.c
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
name$ = 56
weak$ = 64
CreateExternal PROC NEAR

; 82   : {

	sub	rsp, 40					; 00000028H

; 83   :     if ( sym == NULL )

	test	rcx, rcx
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	movzx	edi, r8b
	mov	rbx, rcx
	jne	SHORT $LN3@CreateExte

; 84   :         sym = SymCreate( name );

	mov	rcx, rdx
	call	SymCreate
	mov	rbx, rax

; 85   :     else

	jmp	SHORT $LN2@CreateExte
$LN3@CreateExte:

; 86   :         sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table
$LN2@CreateExte:

; 87   : 
; 88   :     if ( sym ) {

	test	rbx, rbx
	je	SHORT $LN6@CreateExte

; 89   :         sym->state = SYM_EXTERNAL;
; 90   :         sym->seg_ofssize = ModuleInfo.Ofssize;
; 91   :         sym->iscomm = FALSE;
; 92   :         sym->weak = weak;

	and	dil, 1
	mov	DWORD PTR [rbx+40], 2
	movzx	eax, BYTE PTR ModuleInfo+404
	and	al, 3
	shl	dil, 3

; 93   :         sym_add_table( &SymTables[TAB_EXT], (struct dsym *)sym ); /* add EXTERNAL */

	lea	rcx, OFFSET FLAT:SymTables+16
	or	dil, al
	movzx	eax, BYTE PTR [rbx+55]
	mov	rdx, rbx
	and	al, 240					; 000000f0H
	or	dil, al
	mov	BYTE PTR [rbx+55], dil
	call	sym_add_table
$LN6@CreateExte:
	mov	rdi, QWORD PTR [rsp+72]

; 94   :     }
; 95   :     return( sym );

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+64]

; 96   : }

	add	rsp, 40					; 00000028H
	ret	0
CreateExternal ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$CreateComm DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$CreateComm DD @imagerel(CreateComm#)
	DD	@imagerel(CreateComm#+102)
	DD	@imagerel($unwind$CreateComm#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
name$ = 56
CreateComm PROC NEAR

; 103  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 104  :     if ( sym == NULL )

	test	rcx, rcx
	mov	rbx, rcx
	jne	SHORT $LN3@CreateComm

; 105  :         sym = SymCreate( name );

	mov	rcx, rdx
	call	SymCreate
	mov	rbx, rax

; 106  :     else

	jmp	SHORT $LN2@CreateComm
$LN3@CreateComm:

; 107  :         sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table
$LN2@CreateComm:

; 108  : 
; 109  :     if ( sym ) {

	test	rbx, rbx
	je	SHORT $LN6@CreateComm

; 110  :         sym->state = SYM_EXTERNAL;
; 111  :         sym->seg_ofssize = ModuleInfo.Ofssize;
; 112  :         sym->iscomm = TRUE;
; 113  :         sym->weak = FALSE;
; 114  :         sym->isfar = FALSE;

	movzx	eax, BYTE PTR [rbx+55]
	mov	DWORD PTR [rbx+40], 2
	movzx	ecx, BYTE PTR ModuleInfo+404
	and	cl, 3
	and	al, 228					; 000000e4H

; 115  :         sym_add_table( &SymTables[TAB_EXT], (struct dsym *)sym ); /* add EXTERNAL */

	mov	rdx, rbx
	or	cl, al
	or	cl, 4
	mov	BYTE PTR [rbx+55], cl
	lea	rcx, OFFSET FLAT:SymTables+16
	call	sym_add_table
$LN6@CreateComm:

; 116  :     }
; 117  :     return( sym );

	mov	rax, rbx

; 118  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
CreateComm ENDP
_TEXT	ENDS
EXTRN	ParseProc:NEAR
EXTRN	Parse_Pass:DWORD
EXTRN	CopyPrototype:NEAR
EXTRN	CreateProc:NEAR
EXTRN	EmitErr:NEAR
EXTRN	SymFind:NEAR
xdata	SEGMENT
$unwind$CreateProto DD 0b2301H
	DD	06c423H
	DD	0b741bH
	DD	0a6413H
	DD	09540eH
	DD	083409H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$CreateProto DD @imagerel(CreateProto#)
	DD	@imagerel(CreateProto#+309)
	DD	@imagerel($unwind$CreateProto#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 64
tokenarray$ = 72
name$ = 80
langtype$ = 88
CreateProto PROC NEAR

; 126  : {

	sub	rsp, 56					; 00000038H
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+80], rsi
	movsxd	rsi, ecx
	mov	QWORD PTR [rsp+88], rdi

; 127  :     struct asym      *sym;
; 128  :     struct dsym      *dir;
; 129  : 
; 130  :     DebugMsg1(("CreateProto( i=%u, name=%s, lang=%u )\n", i, name ? name : "NULL", langtype ));
; 131  :     sym = SymSearch( name );

	mov	rcx, r8
	mov	QWORD PTR [rsp+48], r12
	mov	r12d, r9d
	mov	rbp, r8
	mov	rdi, rdx
	call	SymFind

; 132  : 
; 133  :     /* the symbol must be either NULL or state
; 134  :      * - SYM_UNDEFINED
; 135  :      * - SYM_EXTERNAL + isproc == FALSE ( previous EXTERNDEF )
; 136  :      * - SYM_EXTERNAL + isproc == TRUE ( previous PROTO )
; 137  :      * - SYM_INTERNAL + isproc == TRUE ( previous PROC )
; 138  :      */
; 139  :     if( sym == NULL ||
; 140  :        sym->state == SYM_UNDEFINED ||
; 141  :        ( sym->state == SYM_EXTERNAL && sym->weak == TRUE && sym->isproc == FALSE )) {

	test	rax, rax
	mov	rbx, rax
	je	SHORT $LN10@CreateProt
	mov	eax, DWORD PTR [rax+40]
	test	eax, eax
	je	SHORT $LN10@CreateProt
	cmp	eax, 2
	jne	SHORT $LN11@CreateProt
	test	BYTE PTR [rbx+55], 8
	je	SHORT $LN11@CreateProt
	test	BYTE PTR [rbx+49], 8
	je	SHORT $LN10@CreateProt
$LN11@CreateProt:

; 144  :     } else if ( sym->isproc == FALSE ) {

	test	BYTE PTR [rbx+49], 8
	jne	SHORT $LN9@CreateProt

; 145  :         EmitErr( SYMBOL_REDEFINITION, sym->name );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 146  :         return( NULL );

	xor	eax, eax
	jmp	$LN12@CreateProt
$LN10@CreateProt:

; 142  :         if ( NULL == ( sym = CreateProc( sym, name, SYM_EXTERNAL ) ) )

	mov	r8d, 2
	mov	rdx, rbp
	mov	rcx, rbx
	call	CreateProc
	test	rax, rax
	mov	rbx, rax

; 143  :             return( NULL ); /* name was probably invalid */

	je	SHORT $LN14@CreateProt
$LN9@CreateProt:

; 147  :     }
; 148  :     dir = (struct dsym *)sym;
; 149  : 
; 150  :     /* a PROTO typedef may be used */
; 151  :     if ( tokenarray[i].token == T_ID ) {

	mov	rcx, rsi
	shl	rcx, 5
	cmp	BYTE PTR [rcx+rdi], 8
	jne	SHORT $LN5@CreateProt

; 152  :         struct asym * sym2;
; 153  :         sym2 = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rcx+rdi+8]
	call	SymFind

; 154  :         if ( sym2 && sym2->state == SYM_TYPE && sym2->mem_type == MT_PROC ) {

	test	rax, rax
	je	SHORT $LN5@CreateProt
	cmp	DWORD PTR [rax+40], 7
	jne	SHORT $LN5@CreateProt
	cmp	DWORD PTR [rax+44], 128			; 00000080H
	jne	SHORT $LN5@CreateProt

; 155  :             i++;

	inc	esi

; 156  :             if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, esi
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rdi], 0
	je	SHORT $LN4@CreateProt

; 157  :                 EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	mov	rdx, QWORD PTR [rdx+rdi+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN14@CreateProt:

; 158  :                 return( NULL );

	xor	eax, eax
	jmp	SHORT $LN12@CreateProt
$LN4@CreateProt:

; 159  :             }
; 160  :             CopyPrototype( dir, (struct dsym *)sym2->target_type );

	mov	rdx, QWORD PTR [rax+56]
	mov	rcx, rbx
	call	CopyPrototype

; 161  :             return( sym );

	jmp	SHORT $LN1@CreateProt
$LN5@CreateProt:

; 162  :         }
; 163  :     }
; 164  :     /* sym->isproc is set inside ParseProc() */
; 165  :     //sym->isproc = TRUE;
; 166  : 
; 167  :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN3@CreateProt

; 168  :         if ( ParseProc( dir, i, tokenarray, FALSE, langtype ) == ERROR )

	xor	r9d, r9d
	mov	r8, rdi
	mov	edx, esi
	mov	rcx, rbx
	mov	DWORD PTR [rsp+32], r12d
	call	ParseProc
	cmp	eax, -1

; 169  :             return( NULL );

	je	SHORT $LN14@CreateProt

; 170  : #if DLLIMPORT
; 171  :         sym->dll = ModuleInfo.CurrDll;

	mov	rax, QWORD PTR ModuleInfo+336
	mov	QWORD PTR [rbx+64], rax

; 172  : #endif
; 173  :     } else {

	jmp	SHORT $LN1@CreateProt
$LN3@CreateProt:

; 174  :         sym->isdefined = TRUE;

	or	BYTE PTR [rbx+48], 2
$LN1@CreateProt:

; 175  :     }
; 176  :     return( sym );

	mov	rax, rbx
$LN12@CreateProt:
	mov	r12, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 177  : }

	add	rsp, 56					; 00000038H
	ret	0
CreateProto ENDP
_TEXT	ENDS
PUBLIC	ProtoDirective
xdata	SEGMENT
$unwind$ProtoDirective DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$ProtoDirective DD @imagerel($LN6#)
	DD	@imagerel($LN6#+113)
	DD	@imagerel($unwind$ProtoDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
ProtoDirective PROC NEAR

; 380  : {

$LN6:
	sub	rsp, 40					; 00000028H

; 381  :     if( Parse_Pass != PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	rax, rdx
	je	SHORT $LN3@ProtoDirec

; 382  :         struct asym *sym;
; 383  :         /* v2.04: set the "defined" flag */
; 384  :         if ( ( sym = SymSearch( tokenarray[0].string_ptr ) ) && sym->isproc == TRUE )

	mov	rcx, QWORD PTR [rdx+8]
	call	SymFind
	test	rax, rax
	je	SHORT $LN2@ProtoDirec
	test	BYTE PTR [rax+49], 8
	je	SHORT $LN2@ProtoDirec

; 385  :             sym->isdefined = TRUE;

	or	BYTE PTR [rax+48], 2
$LN2@ProtoDirec:

; 386  :         return( NOT_ERROR );

	xor	eax, eax

; 393  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@ProtoDirec:

; 387  :     }
; 388  :     if( i != 1 ) {

	cmp	ecx, 1
	je	SHORT $LN1@ProtoDirec

; 389  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rax+8]

; 393  : }

	add	rsp, 40					; 00000028H
	jmp	EmitErr
$LN1@ProtoDirec:

; 390  :     }
; 391  : 
; 392  :     return( CreateProto( 2, tokenarray, tokenarray[0].string_ptr, ModuleInfo.langtype ) ? NOT_ERROR : ERROR );

	mov	r9d, DWORD PTR ModuleInfo+364
	mov	r8, QWORD PTR [rdx+8]
	mov	ecx, 2
	call	CreateProto
	neg	rax
	sbb	eax, eax
	neg	eax
	dec	eax

; 393  : }

	add	rsp, 40					; 00000028H
	ret	0
ProtoDirective ENDP
_TEXT	ENDS
PUBLIC	MakeExtern
EXTRN	Options:BYTE
xdata	SEGMENT
$unwind$MakeExtern DD 071601H
	DD	047416H
	DD	056411H
	DD	06340cH
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$MakeExtern DD @imagerel($LN14#)
	DD	@imagerel($LN14#+211)
	DD	@imagerel($unwind$MakeExtern#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 64
mem_type$ = 72
vartype$ = 80
sym$ = 88
Ofssize$ = 96
MakeExtern PROC NEAR

; 402  : {

$LN14:
	sub	rsp, 56					; 00000038H

; 403  :     sym = CreateExternal( sym, name, FALSE );

	test	r9, r9
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+40], rsi
	mov	QWORD PTR [rsp+32], rdi
	mov	rbx, r9
	mov	rsi, r8
	mov	edi, edx
	jne	SHORT $LN10@MakeExtern
	call	SymCreate
	mov	rbx, rax
	jmp	SHORT $LN9@MakeExtern
$LN10@MakeExtern:
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rbx
	call	sym_remove_table
$LN9@MakeExtern:
	test	rbx, rbx
	je	SHORT $LN13@MakeExtern
	movzx	eax, BYTE PTR [rbx+55]
	mov	DWORD PTR [rbx+40], 2
	movzx	ecx, BYTE PTR ModuleInfo+404
	and	cl, 3
	and	al, 240					; 000000f0H
	mov	rdx, rbx
	or	cl, al
	mov	BYTE PTR [rbx+55], cl
	lea	rcx, OFFSET FLAT:SymTables+16
	call	sym_add_table

; 406  : 
; 407  :     //if ( mem_type == MT_ABS )
; 408  :     if ( mem_type == MT_EMPTY )

	cmp	edi, 192				; 000000c0H
	je	SHORT $LN2@MakeExtern

; 409  :         ;
; 410  :     else if ( Options.masm_compat_gencode == FALSE || mem_type != MT_FAR )

	cmp	BYTE PTR Options+137, 0
	je	SHORT $LN1@MakeExtern
	cmp	edi, 130				; 00000082H
	je	SHORT $LN2@MakeExtern
$LN1@MakeExtern:

; 411  :         sym->segment = &CurrSeg->sym;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rbx+32], rax
$LN2@MakeExtern:

; 412  : 
; 413  :     sym->isdefined = TRUE;
; 414  :     sym->mem_type = mem_type;
; 415  :     sym->seg_ofssize = Ofssize;

	movzx	eax, BYTE PTR Ofssize$[rsp]
	or	BYTE PTR [rbx+48], 2
	and	BYTE PTR [rbx+55], 252			; 000000fcH
	and	al, 3
	mov	DWORD PTR [rbx+44], edi

; 416  :     sym->type = vartype;

	mov	QWORD PTR [rbx+88], rsi
	or	BYTE PTR [rbx+55], al

; 417  :     return( sym );

	mov	rax, rbx
	mov	rdi, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+40]
	mov	rbx, QWORD PTR [rsp+48]

; 418  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN13@MakeExtern:
	mov	rdi, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+40]
	mov	rbx, QWORD PTR [rsp+48]

; 404  :     if ( sym == NULL )
; 405  :         return( NULL );

	xor	eax, eax

; 418  : }

	add	rsp, 56					; 00000038H
	ret	0
MakeExtern ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$HandleAltname DD 071601H
	DD	097416H
	DD	086411H
	DD	07340cH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$HandleAltname DD @imagerel(HandleAltname#)
	DD	@imagerel(HandleAltname#+330)
	DD	@imagerel($unwind$HandleAltname#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
altname$ = 48
sym$ = 56
HandleAltname PROC NEAR

; 425  : {

	sub	rsp, 40					; 00000028H

; 426  :     struct asym *symalt;
; 427  : 
; 428  :     if ( altname && sym->state == SYM_EXTERNAL ) {

	test	rcx, rcx
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	mov	rsi, rcx
	mov	rdi, rdx
	je	$LN1@HandleAltn
	cmp	DWORD PTR [rdx+40], 2
	jne	$LN1@HandleAltn

; 429  : 
; 430  :         symalt = SymSearch( altname );

	call	SymFind
	mov	rbx, rax

; 431  : 
; 432  :         /* altname symbol changed? */
; 433  :         if ( sym->altname && sym->altname != symalt ) {

	mov	rax, QWORD PTR [rdi+72]
	test	rax, rax
	je	SHORT $LN16@HandleAltn
	cmp	rax, rbx
	je	SHORT $LN16@HandleAltn

; 434  :             return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rdi+8]
	mov	ecx, 143				; 0000008fH
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 493  : }

	add	rsp, 40					; 00000028H
	jmp	EmitErr
$LN16@HandleAltn:

; 435  :         }
; 436  : 
; 437  :         if ( Parse_Pass > PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jbe	SHORT $LN15@HandleAltn

; 438  :             if ( symalt->state == SYM_UNDEFINED ) {

	mov	eax, DWORD PTR [rbx+40]
	test	eax, eax
	jne	SHORT $LN14@HandleAltn

; 439  :                 EmitErr( SYMBOL_NOT_DEFINED, altname );

	lea	ecx, QWORD PTR [rax+102]
	mov	rdx, rsi
	call	EmitErr
	jmp	$LN1@HandleAltn
$LN14@HandleAltn:

; 440  :             } else if (symalt->state != SYM_INTERNAL && symalt->state != SYM_EXTERNAL ) {

	cmp	eax, 1
	je	SHORT $LN12@HandleAltn
	cmp	eax, 2

; 441  :                 EmitErr( SYMBOL_TYPE_CONFLICT, altname );
; 442  :             } else {

	jne	SHORT $LN20@HandleAltn
$LN12@HandleAltn:

; 443  : #if COFF_SUPPORT || ELF_SUPPORT
; 444  :                 if ( symalt->state == SYM_INTERNAL && symalt->ispublic == FALSE )

	cmp	eax, 1
	jne	SHORT $LN9@HandleAltn
	test	BYTE PTR [rbx+48], 128			; 00000080H
	jne	SHORT $LN9@HandleAltn

; 445  :                     if ( Options.output_format == OFORMAT_COFF
; 446  : #if ELF_SUPPORT
; 447  :                         || Options.output_format == OFORMAT_ELF
; 448  : #endif
; 449  :                        ) {

	mov	eax, DWORD PTR Options+156
	cmp	eax, 2
	je	SHORT $LN8@HandleAltn
	cmp	eax, 3
	jne	SHORT $LN9@HandleAltn
$LN8@HandleAltn:

; 450  :                         EmitErr( MUST_BE_PUBLIC_OR_EXTERNAL, altname );

	mov	rdx, rsi
	mov	ecx, 269				; 0000010dH
	call	EmitErr
$LN9@HandleAltn:

; 451  :                     }
; 452  : #endif
; 453  :                 if ( sym->mem_type != symalt->mem_type )

	mov	eax, DWORD PTR [rbx+44]
	cmp	DWORD PTR [rdi+44], eax
	je	SHORT $LN1@HandleAltn
$LN20@HandleAltn:

; 454  :                     EmitErr( SYMBOL_TYPE_CONFLICT, altname );

	mov	rdx, rsi
	mov	ecx, 136				; 00000088H
	call	EmitErr

; 455  :             }
; 456  :         } else {

	jmp	SHORT $LN1@HandleAltn
$LN15@HandleAltn:

; 457  : 
; 458  :             if ( symalt ) {

	test	rbx, rbx
	je	SHORT $LN5@HandleAltn

; 459  :                 DebugMsg(("HandleAltname: symbol '%s' found, state=%u\n", altname, symalt->state ));
; 460  :                 if ( symalt->state != SYM_INTERNAL &&
; 461  :                     symalt->state != SYM_EXTERNAL &&
; 462  :                     symalt->state != SYM_UNDEFINED ) {

	mov	eax, DWORD PTR [rbx+40]
	cmp	eax, 1
	je	SHORT $LN3@HandleAltn
	cmp	eax, 2
	je	SHORT $LN3@HandleAltn
	test	eax, eax
	je	SHORT $LN3@HandleAltn

; 463  :                     return( EmitErr( SYMBOL_TYPE_CONFLICT, altname ) );

	mov	rdx, rsi
	mov	ecx, 136				; 00000088H
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 493  : }

	add	rsp, 40					; 00000028H
	jmp	EmitErr
$LN5@HandleAltn:

; 464  :                 }
; 465  :             } else {
; 466  :                 symalt = SymCreate( altname );

	mov	rcx, rsi
	call	SymCreate

; 467  :                 sym_add_table( &SymTables[TAB_UNDEF], (struct dsym *)symalt );

	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rax
	mov	rbx, rax
	call	sym_add_table
$LN3@HandleAltn:

; 468  :             }
; 469  :             /* make sure the alt symbol becomes strong if it is an external
; 470  :              * v2.11: don't do this for OMF ( maybe neither for COFF/ELF? )
; 471  :              */
; 472  :             if ( Options.output_format != OFORMAT_OMF )

	cmp	DWORD PTR Options+156, 1
	je	SHORT $LN2@HandleAltn

; 473  :                 symalt->used = TRUE;

	or	BYTE PTR [rbx+48], 1
$LN2@HandleAltn:

; 474  :             /* symbol inserted in the "weak external" queue?
; 475  :              * currently needed for OMF only.
; 476  :              */
; 477  :             if ( sym->altname == NULL ) {

	cmp	QWORD PTR [rdi+72], 0
	jne	SHORT $LN1@HandleAltn

; 478  :                 sym->altname = symalt;

	mov	QWORD PTR [rdi+72], rbx
$LN1@HandleAltn:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 479  : #if 0 /* v2.11: removed. Member nextext wasn't free to use */
; 480  :                 DebugMsg1(("HandleAltname: symbol '%s' added to AltQueue\n", sym->name ));
; 481  :                 ((struct dsym *)sym)->nextext = NULL;
; 482  :                 if ( ModuleInfo.g.AltQueue.head == NULL )
; 483  :                     ModuleInfo.g.AltQueue.head = ModuleInfo.g.AltQueue.tail = (struct dsym *)sym;
; 484  :                 else {
; 485  :                     ((struct dsym *)ModuleInfo.g.AltQueue.tail)->nextext = (struct dsym *)sym;
; 486  :                     ModuleInfo.g.AltQueue.tail = (struct dsym *)sym;
; 487  :                 }
; 488  : #endif
; 489  :             }
; 490  :         }
; 491  :     }
; 492  :     return( NOT_ERROR );

	xor	eax, eax

; 493  : }

	add	rsp, 40					; 00000028H
	ret	0
HandleAltname ENDP
_TEXT	ENDS
PUBLIC	ExternDirective
EXTRN	EmitError:NEAR
EXTRN	SetMangler:NEAR
EXTRN	GetQualifiedType:NEAR
EXTRN	_stricmp:NEAR
EXTRN	GetLangType:NEAR
xdata	SEGMENT
$unwind$ExternDirective DD 0112c01H
	DD	09f42cH
	DD	0ae425H
	DD	0bd41fH
	DD	0d741bH
	DD	0e6417H
	DD	0135413H
	DD	012340fH
	DD	0cc40bH
	DD	0e207H
xdata	ENDS
pdata	SEGMENT
$pdata$ExternDirective DD @imagerel($LN68#)
	DD	@imagerel($LN68#+1402)
	DD	@imagerel($unwind$ExternDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
ti$ = 32
i$ = 128
langtype$ = 136
tokenarray$ = 136
ExternDirective PROC NEAR

; 499  : {

$LN68:
	mov	rax, rsp
	sub	rsp, 120				; 00000078H
	mov	QWORD PTR [rax-24], r12
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax+32], rbp
	mov	QWORD PTR [rax-8], rsi
	mov	QWORD PTR [rax-16], rdi
	mov	QWORD PTR [rax-32], r13

; 500  :     char                *token;
; 501  : #if MANGLERSUPP
; 502  :     char                *mangle_type = NULL;
; 503  : #endif
; 504  :     char                *altname;
; 505  :     struct asym         *sym;
; 506  :     enum lang_type      langtype;
; 507  :     struct qualified_type ti;
; 508  : 
; 509  :     DebugMsg1(("ExternDirective(%u) enter\n", i));
; 510  :     i++; /* skip EXT[E]RN token */

	inc	ecx
	mov	QWORD PTR [rax-40], r14
	mov	r12, rdx
	mov	QWORD PTR [rax-48], r15
	mov	DWORD PTR [rax+8], ecx
	npad	1
$LL36@ExternDire:

; 511  : #if MANGLERSUPP
; 512  :     mangle_type = Check4Mangler( &i, tokenarray );
; 513  : #endif
; 514  :     do {
; 515  : 
; 516  :         altname = NULL;
; 517  : 
; 518  :         /* get the symbol language type if present */
; 519  :         langtype = ModuleInfo.langtype;

	mov	eax, DWORD PTR ModuleInfo+364

; 520  :         GetLangType( &i, tokenarray, &langtype );

	lea	r8, QWORD PTR langtype$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, r12
	xor	r15d, r15d
	mov	DWORD PTR langtype$[rsp], eax
	call	GetLangType

; 521  : 
; 522  :         /* get the symbol name */
; 523  :         if( tokenarray[i].token != T_ID ) {

	movsxd	r11, DWORD PTR i$[rsp]
	mov	rax, r11
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], 8
	jne	$LN2@ExternDire

; 524  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );
; 525  :         }
; 526  :         token = tokenarray[i++].string_ptr;

	mov	r14, QWORD PTR [rax+r12+8]
	inc	r11d

; 527  : 
; 528  :         /* go past the optional alternative name (weak ext, default resolution) */
; 529  :         if( tokenarray[i].token == T_OP_BRACKET ) {

	movsxd	rax, r11d
	mov	DWORD PTR i$[rsp], r11d
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], 40			; 00000028H
	jne	SHORT $LN32@ExternDire

; 530  :             i++;

	inc	r11d

; 531  :             if ( tokenarray[i].token != T_ID ) {

	movsxd	rax, r11d
	mov	DWORD PTR i$[rsp], r11d
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], 8
	jne	$LN58@ExternDire

; 533  :             }
; 534  :             altname = tokenarray[i].string_ptr;

	mov	r15, QWORD PTR [rax+r12+8]

; 535  :             i++;

	inc	r11d

; 536  :             if( tokenarray[i].token != T_CL_BRACKET ) {

	movsxd	rax, r11d
	mov	DWORD PTR i$[rsp], r11d
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], 41			; 00000029H
	jne	$LN59@ExternDire

; 538  :             }
; 539  :             i++;

	inc	r11d
	mov	DWORD PTR i$[rsp], r11d
$LN32@ExternDire:

; 540  :         }
; 541  : 
; 542  :         /* go past the colon */
; 543  :         if( tokenarray[i].token != T_COLON ) {

	movsxd	rax, r11d
	shl	rax, 5
	cmp	BYTE PTR [rax+r12], 58			; 0000003aH
	jne	$LN60@ExternDire

; 545  :         }
; 546  :         i++;

	inc	r11d

; 547  :         sym = SymSearch( token );

	mov	rcx, r14
	mov	DWORD PTR i$[rsp], r11d
	call	SymFind

; 548  : 
; 549  :         ti.mem_type = MT_EMPTY;
; 550  :         ti.size = 0;
; 551  :         ti.is_ptr = 0;
; 552  :         ti.is_far = FALSE;
; 553  :         ti.ptr_memtype = MT_EMPTY;
; 554  :         ti.symtype = NULL;
; 555  :         ti.Ofssize = ModuleInfo.Ofssize;

	movzx	ecx, BYTE PTR ModuleInfo+404

; 556  : 
; 557  :         if ( tokenarray[i].token == T_ID && ( 0 == _stricmp( tokenarray[i].string_ptr, "ABS" ) ) ) {

	movsxd	r9, DWORD PTR i$[rsp]
	mov	BYTE PTR ti$[rsp+22], cl
	xor	r8b, r8b
	mov	esi, 192				; 000000c0H
	xor	edx, edx
	mov	rcx, r9
	shl	rcx, 5
	mov	DWORD PTR ti$[rsp], 0
	mov	BYTE PTR ti$[rsp+20], r8b
	mov	DWORD PTR ti$[rsp+16], esi
	mov	BYTE PTR ti$[rsp+21], r8b
	mov	DWORD PTR ti$[rsp+24], esi
	mov	QWORD PTR ti$[rsp+8], rdx
	cmp	BYTE PTR [rcx+r12], 8
	mov	rbx, rax
	jne	SHORT $LN28@ExternDire
	mov	rcx, QWORD PTR [rcx+r12+8]
	lea	rdx, OFFSET FLAT:$SG5863
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN66@ExternDire

; 558  :             //ti.mem_type = MT_ABS;
; 559  :             i++;

	inc	DWORD PTR i$[rsp]
	movzx	r8d, BYTE PTR ti$[rsp+20]
	mov	esi, DWORD PTR ti$[rsp+16]
	mov	rdx, QWORD PTR ti$[rsp+8]
	jmp	SHORT $LN20@ExternDire
$LN66@ExternDire:
	mov	r9d, DWORD PTR i$[rsp]
	mov	r8b, BYTE PTR ti$[rsp+20]
	mov	esi, DWORD PTR ti$[rsp+16]
	mov	rdx, QWORD PTR ti$[rsp+8]
$LN28@ExternDire:

; 560  :         } else if ( tokenarray[i].token == T_DIRECTIVE && tokenarray[i].tokval == T_PROTO ) {

	movsxd	rax, r9d
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+r12]
	cmp	cl, 3
	jne	SHORT $LN26@ExternDire
	cmp	DWORD PTR [rax+r12+16], 432		; 000001b0H
	je	$LN61@ExternDire
$LN26@ExternDire:

; 573  :             }
; 574  :         } else if ( tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA ) {

	test	cl, cl
	je	SHORT $LN20@ExternDire
	cmp	cl, 44					; 0000002cH
	je	SHORT $LN20@ExternDire

; 575  :             if ( GetQualifiedType( &i, tokenarray, &ti ) == ERROR )

	lea	r8, QWORD PTR ti$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, r12
	call	GetQualifiedType
	cmp	eax, -1
	je	$LN64@ExternDire
	mov	r8b, BYTE PTR ti$[rsp+20]
	mov	esi, DWORD PTR ti$[rsp+16]
	mov	rdx, QWORD PTR ti$[rsp+8]
$LN20@ExternDire:

; 576  :                 return( ERROR );
; 577  :         }
; 578  : 
; 579  :         DebugMsg1(("ExternDirective(%s): mem_type=%Xh\n", token, ti.mem_type ));
; 580  : 
; 581  :         if( sym == NULL || sym->state == SYM_UNDEFINED ) {

	test	rbx, rbx
	je	$LN18@ExternDire
	mov	eax, DWORD PTR [rbx+40]
	test	eax, eax
	je	$LN18@ExternDire

; 599  :                 DebugMsg1(("ExternDirective(%s): prototype copied, memtype=%X\n", token, ti.mem_type ));
; 600  :             }
; 601  : 
; 602  :         } else {
; 603  : #if MASM_EXTCOND
; 604  :             /* allow internal AND external definitions for equates */
; 605  :             //if ( sym->state == SYM_INTERNAL && sym->mem_type == MT_ABS )
; 606  :             if ( sym->state == SYM_INTERNAL && sym->mem_type == MT_EMPTY )

	cmp	eax, 1
	jne	SHORT $LN14@ExternDire
	cmp	DWORD PTR [rbx+44], 192			; 000000c0H
	je	SHORT $LN12@ExternDire
$LN14@ExternDire:

; 607  :                 ;
; 608  :             else
; 609  : #endif
; 610  :             if ( sym->state != SYM_EXTERNAL ) {

	cmp	eax, 2
	jne	$LN63@ExternDire
$LN12@ExternDire:

; 613  :             }
; 614  :             /* v2.05: added to accept type prototypes */
; 615  :             if ( ti.is_ptr == 0 && ti.symtype && ti.symtype->isproc ) {

	test	r8b, r8b
	jne	SHORT $LN11@ExternDire
	test	rdx, rdx
	je	SHORT $LN11@ExternDire
	test	BYTE PTR [rdx+49], 8
	je	SHORT $LN11@ExternDire

; 616  :                 ti.mem_type = ti.symtype->mem_type;

	mov	esi, DWORD PTR [rdx+44]

; 617  :                 ti.symtype = NULL;

	xor	edx, edx
	mov	DWORD PTR ti$[rsp+16], esi
	mov	QWORD PTR ti$[rsp+8], rdx
$LN11@ExternDire:

; 618  :             }
; 619  : 
; 620  :             if( sym->mem_type != ti.mem_type ||
; 621  :                sym->is_ptr != ti.is_ptr ||
; 622  :                sym->isfar != ti.is_far ||
; 623  :                ( sym->is_ptr && sym->ptr_memtype != ti.ptr_memtype ) ||
; 624  :                ((sym->mem_type == MT_TYPE) ? sym->type : sym->target_type) != ti.symtype ||
; 625  :                ( langtype != LANG_NONE && sym->langtype != LANG_NONE && sym->langtype != langtype )) {

	mov	r9d, DWORD PTR [rbx+44]
	cmp	r9d, esi
	jne	SHORT $LN9@ExternDire
	movzx	ecx, BYTE PTR [rbx+53]
	cmp	cl, r8b
	jne	SHORT $LN9@ExternDire
	movzx	eax, BYTE PTR [rbx+55]
	shr	al, 4
	and	al, 1
	cmp	al, BYTE PTR ti$[rsp+21]
	jne	SHORT $LN9@ExternDire
	test	cl, cl
	je	SHORT $LN8@ExternDire
	movzx	eax, BYTE PTR [rbx+54]
	cmp	eax, DWORD PTR ti$[rsp+24]
	jne	SHORT $LN9@ExternDire
$LN8@ExternDire:
	cmp	r9d, 196				; 000000c4H
	jne	SHORT $LN41@ExternDire
	mov	rax, QWORD PTR [rbx+88]
	jmp	SHORT $LN42@ExternDire
$LN41@ExternDire:
	mov	rax, QWORD PTR [rbx+56]
$LN42@ExternDire:
	cmp	rax, rdx
	jne	SHORT $LN9@ExternDire
	mov	eax, DWORD PTR langtype$[rsp]
	test	eax, eax
	je	$LN16@ExternDire
	mov	ecx, DWORD PTR [rbx+84]
	test	ecx, ecx
	je	$LN16@ExternDire
	cmp	ecx, eax
	je	$LN16@ExternDire
$LN9@ExternDire:

; 626  :                 DebugMsg(("ExternDirective: memtype:%X-%X ptr=%X-%X far=%X-%X ptr_memtype=%X-%X lang=%u-%u\n",
; 627  :                           sym->mem_type, ti.mem_type,
; 628  :                           sym->is_ptr, ti.is_ptr,
; 629  :                           sym->isfar, ti.is_far,
; 630  :                           sym->ptr_memtype, ti.ptr_memtype,
; 631  :                           sym->langtype, langtype
; 632  :                          ));
; 633  :                 return( EmitErr( SYMBOL_TYPE_CONFLICT, token ) );

	mov	rdx, r14
	mov	ecx, 136				; 00000088H
	call	EmitErr
	jmp	$LN37@ExternDire
$LN18@ExternDire:

; 582  :             /* v2.04: emit the error at the PUBLIC directive */
; 583  :             //if ( sym && sym->public == TRUE ) {
; 584  :             //    EmitErr( CANNOT_DEFINE_AS_PUBLIC_OR_EXTERNAL, sym->name );
; 585  :             //    return( ERROR );
; 586  :             //}
; 587  :             if(( sym = MakeExtern( token, ti.mem_type,
; 588  :                                   ti.mem_type == MT_TYPE ? ti.symtype : NULL, sym,
; 589  :                                   ti.is_ptr ? ModuleInfo.Ofssize : ti.Ofssize )) == NULL )

	test	r8b, r8b
	je	SHORT $LN39@ExternDire
	movzx	ebp, BYTE PTR ModuleInfo+404
	jmp	SHORT $LN40@ExternDire
$LN39@ExternDire:
	movzx	ebp, BYTE PTR ti$[rsp+22]
$LN40@ExternDire:
	xor	r13d, r13d
	cmp	esi, 196				; 000000c4H
	mov	rdi, rbx
	cmove	r13, rdx
	test	rbx, rbx
	jne	SHORT $LN52@ExternDire
	mov	rcx, r14
	call	SymCreate
	mov	rdi, rax
	jmp	SHORT $LN51@ExternDire
$LN52@ExternDire:
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rbx
	call	sym_remove_table
$LN51@ExternDire:
	test	rdi, rdi
	je	$LN64@ExternDire
	movzx	ecx, BYTE PTR [rdi+55]
	mov	DWORD PTR [rdi+40], 2
	movzx	eax, BYTE PTR ModuleInfo+404
	and	cl, 240					; 000000f0H
	and	al, 3
	mov	rdx, rdi
	or	cl, al
	mov	BYTE PTR [rdi+55], cl
	lea	rcx, OFFSET FLAT:SymTables+16
	call	sym_add_table
	cmp	esi, 192				; 000000c0H
	je	SHORT $LN44@ExternDire
	cmp	BYTE PTR Options+137, 0
	je	SHORT $LN43@ExternDire
	cmp	esi, 130				; 00000082H
	je	SHORT $LN44@ExternDire
$LN43@ExternDire:
	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rdi+32], rax
$LN44@ExternDire:
	and	BYTE PTR [rdi+55], 252			; 000000fcH
	or	BYTE PTR [rdi+48], 2
	and	bpl, 3
	or	BYTE PTR [rdi+55], bpl
	mov	DWORD PTR [rdi+44], esi
	mov	QWORD PTR [rdi+88], r13

; 591  : 
; 592  :             /* v2.05: added to accept type prototypes */
; 593  :             if ( ti.is_ptr == 0 && ti.symtype && ti.symtype->isproc ) {

	cmp	BYTE PTR ti$[rsp+20], 0
	mov	rbx, rdi
	jne	SHORT $LN16@ExternDire
	mov	rax, QWORD PTR ti$[rsp+8]
	test	rax, rax
	je	SHORT $LN16@ExternDire
	test	BYTE PTR [rax+49], 8
	je	SHORT $LN16@ExternDire

; 594  :                 CreateProc( sym, NULL, SYM_EXTERNAL );

	xor	edx, edx
	mov	rcx, rdi
	lea	r8d, QWORD PTR [rdx+2]
	call	CreateProc

; 595  :                 sym->weak = FALSE; /* v2.09: reset the weak bit that has been set inside CreateProc() */

	and	BYTE PTR [rdi+55], 247			; 000000f7H

; 596  :                 CopyPrototype( (struct dsym *)sym, (struct dsym *)ti.symtype );

	mov	rdx, QWORD PTR ti$[rsp+8]
	mov	rcx, rdi
	call	CopyPrototype

; 597  :                 ti.mem_type = ti.symtype->mem_type;

	mov	r11, QWORD PTR ti$[rsp+8]
	mov	eax, DWORD PTR [r11+44]

; 598  :                 ti.symtype = NULL;

	mov	QWORD PTR ti$[rsp+8], 0
	mov	DWORD PTR ti$[rsp+16], eax
$LN16@ExternDire:

; 634  :             }
; 635  :         }
; 636  : 
; 637  :         sym->isdefined = TRUE;

	or	BYTE PTR [rbx+48], 2

; 638  :         sym->Ofssize = ti.Ofssize;

	movzx	eax, BYTE PTR ti$[rsp+22]
	mov	BYTE PTR [rbx+52], al

; 639  : 
; 640  :         if ( ti.is_ptr == 0 && ti.Ofssize != ModuleInfo.Ofssize ) {

	cmp	BYTE PTR ti$[rsp+20], 0
	jne	SHORT $LN6@ExternDire
	movzx	ecx, BYTE PTR ti$[rsp+22]
	cmp	cl, BYTE PTR ModuleInfo+404
	je	SHORT $LN6@ExternDire

; 641  :             sym->seg_ofssize = ti.Ofssize;

	movzx	eax, BYTE PTR [rbx+55]
	xor	al, cl
	and	al, 3
	xor	BYTE PTR [rbx+55], al

; 642  :             if ( sym->segment && ((struct dsym *)sym->segment)->e.seginfo->Ofssize != sym->seg_ofssize )

	mov	rax, QWORD PTR [rbx+32]
	movzx	ecx, BYTE PTR [rbx+55]
	test	rax, rax
	je	SHORT $LN6@ExternDire
	mov	rax, QWORD PTR [rax+104]
	and	cl, 3
	cmp	BYTE PTR [rax+104], cl
	je	SHORT $LN6@ExternDire

; 643  :                 sym->segment = NULL;

	mov	QWORD PTR [rbx+32], 0
$LN6@ExternDire:

; 644  :         }
; 645  : 
; 646  :         sym->mem_type = ti.mem_type;

	mov	eax, DWORD PTR ti$[rsp+16]
	mov	DWORD PTR [rbx+44], eax

; 647  :         sym->is_ptr = ti.is_ptr;

	movzx	eax, BYTE PTR ti$[rsp+20]
	mov	BYTE PTR [rbx+53], al

; 648  :         sym->isfar = ti.is_far;

	movzx	eax, BYTE PTR ti$[rsp+21]
	shl	al, 4
	xor	al, BYTE PTR [rbx+55]
	and	al, 16
	xor	BYTE PTR [rbx+55], al

; 649  :         sym->ptr_memtype = ti.ptr_memtype;

	movzx	eax, BYTE PTR ti$[rsp+24]
	mov	BYTE PTR [rbx+54], al

; 650  :         if ( ti.mem_type == MT_TYPE )

	cmp	DWORD PTR ti$[rsp+16], 196		; 000000c4H
	jne	SHORT $LN5@ExternDire

; 651  :             sym->type = ti.symtype;

	mov	rax, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rbx+88], rax

; 652  :         else

	jmp	SHORT $LN4@ExternDire
$LN5@ExternDire:

; 653  :             sym->target_type = ti.symtype;

	mov	rax, QWORD PTR ti$[rsp+8]
	mov	QWORD PTR [rbx+56], rax
$LN4@ExternDire:

; 654  : 
; 655  :         HandleAltname( altname, sym );

	mov	rdx, rbx
	mov	rcx, r15
	call	HandleAltname

; 656  : 
; 657  :         SetMangler( sym, langtype, mangle_type );

	mov	edx, DWORD PTR langtype$[rsp]
	xor	r8d, r8d
	mov	rcx, rbx
	call	SetMangler

; 658  : 
; 659  :         if ( tokenarray[i].token != T_FINAL )

	movsxd	r11, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR ModuleInfo+496
	mov	rax, r11
	shl	rax, 5
	movzx	edx, BYTE PTR [rax+r12]
	test	dl, dl
	je	SHORT $LN35@ExternDire

; 660  :             if ( tokenarray[i].token == T_COMMA &&  ( (i + 1) < Token_Count ) ) {

	cmp	dl, 44					; 0000002cH
	jne	$LN2@ExternDire
	lea	eax, DWORD PTR [r11+1]
	cmp	eax, ecx
	jge	$LN2@ExternDire

; 661  :                 i++;

	mov	r11d, eax
	mov	DWORD PTR i$[rsp], eax
$LN35@ExternDire:

; 664  :             }
; 665  :     }  while ( i < Token_Count );

	cmp	r11d, ecx
	jl	$LL36@ExternDire

; 666  : 
; 667  :     return( NOT_ERROR );

	xor	eax, eax
$LN37@ExternDire:
	mov	r15, QWORD PTR [rsp+72]
	mov	r14, QWORD PTR [rsp+80]
	mov	r13, QWORD PTR [rsp+88]
	mov	r12, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+152]
	mov	rbx, QWORD PTR [rsp+144]

; 668  : }

	add	rsp, 120				; 00000078H
	ret	0
$LN58@ExternDire:

; 532  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, r11d
	jmp	$LN67@ExternDire
$LN59@ExternDire:

; 537  :                 return( EmitErr( EXPECTED, ")" ) );

	lea	rdx, OFFSET FLAT:$SG5859
	mov	ecx, 230				; 000000e6H
	call	EmitErr
	jmp	SHORT $LN37@ExternDire
$LN60@ExternDire:

; 544  :             return( EmitError( COLON_EXPECTED ) );

	mov	ecx, 84					; 00000054H
	call	EmitError
	jmp	SHORT $LN37@ExternDire
$LN61@ExternDire:

; 561  :             /* dont scan this line further */
; 562  :             /* CreateProto() will define a SYM_EXTERNAL */
; 563  :             sym = CreateProto( i + 1, tokenarray, token, langtype );

	lea	ecx, DWORD PTR [r9+1]
	mov	r9d, DWORD PTR langtype$[rsp]
	mov	r8, r14
	mov	rdx, r12
	call	CreateProto

; 564  :             DebugMsg1(("ExternDirective(%s): CreateProto()=%X\n", token, sym));
; 565  :             if ( sym == NULL )

	test	rax, rax

; 566  :                 return( ERROR );

	je	SHORT $LN64@ExternDire

; 567  :             if ( sym->state == SYM_EXTERNAL ) {

	cmp	DWORD PTR [rax+40], 2
	jne	SHORT $LN24@ExternDire

; 568  :                 sym->weak = FALSE;

	and	BYTE PTR [rax+55], 247			; 000000f7H

; 569  :                 return( HandleAltname( altname, sym ) );

	mov	rdx, rax
	mov	rcx, r15
	call	HandleAltname
	jmp	$LN37@ExternDire
$LN24@ExternDire:

; 570  :             } else {
; 571  :                 /* unlike EXTERNDEF, EXTERN doesn't allow a PROC for the same name */
; 572  :                 return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN37@ExternDire
$LN63@ExternDire:

; 611  :                 DebugMsg(("ExternDirective: symbol %s redefinition, state=%u\n", token, sym->state ));
; 612  :                 return( EmitErr( SYMBOL_REDEFINITION, token ) );

	mov	rdx, r14
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN37@ExternDire
$LN64@ExternDire:

; 590  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN37@ExternDire
$LN2@ExternDire:

; 662  :             } else {
; 663  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, r11
$LN67@ExternDire:
	shl	rdx, 5
	mov	ecx, 209				; 000000d1H
	mov	rdx, QWORD PTR [rdx+r12+8]
	call	EmitErr
	jmp	$LN37@ExternDire
ExternDirective ENDP
_TEXT	ENDS
EXTRN	EmitWarn:NEAR
EXTRN	MemtypeFromSize:NEAR
xdata	SEGMENT
$unwind$MakeComm DD 071601H
	DD	047416H
	DD	056411H
	DD	06340cH
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$MakeComm DD @imagerel(MakeComm#)
	DD	@imagerel(MakeComm#+259)
	DD	@imagerel($unwind$MakeComm#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 64
sym$ = 72
size$ = 80
count$ = 88
isfar$ = 96
MakeComm PROC NEAR

; 674  : {

	sub	rsp, 56					; 00000038H

; 675  :     sym = CreateComm( sym, name );

	test	rdx, rdx
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+40], rsi
	mov	QWORD PTR [rsp+32], rdi
	mov	esi, r9d
	mov	rbx, rdx
	mov	edi, r8d
	jne	SHORT $LN10@MakeComm
	call	SymCreate
	mov	rbx, rax
	jmp	SHORT $LN9@MakeComm
$LN10@MakeComm:
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table
$LN9@MakeComm:
	test	rbx, rbx
	je	$LN13@MakeComm
	movzx	eax, BYTE PTR [rbx+55]
	mov	DWORD PTR [rbx+40], 2
	movzx	ecx, BYTE PTR ModuleInfo+404
	and	cl, 3
	and	al, 228					; 000000e4H
	mov	rdx, rbx
	or	cl, al
	or	cl, 4
	mov	BYTE PTR [rbx+55], cl
	lea	rcx, OFFSET FLAT:SymTables+16
	call	sym_add_table

; 678  : 
; 679  :     sym->total_length = count;
; 680  :     sym->isfar = isfar;

	and	BYTE PTR [rbx+55], 239			; 000000efH
	movzx	ecx, BYTE PTR isfar$[rsp]
	movzx	eax, cl
	mov	DWORD PTR [rbx+72], esi
	and	al, 1
	shl	al, 4
	or	BYTE PTR [rbx+55], al

; 681  : 
; 682  :     /* v2.04: don't set segment if communal is far and -Zg is set */
; 683  :     if ( Options.masm_compat_gencode == FALSE || isfar == FALSE )

	cmp	BYTE PTR Options+137, 0
	je	SHORT $LN3@MakeComm
	test	cl, cl
	jne	SHORT $LN4@MakeComm
$LN3@MakeComm:

; 684  :         sym->segment = &CurrSeg->sym;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rbx+32], rax
$LN4@MakeComm:

; 685  : 
; 686  :     MemtypeFromSize( size, &sym->mem_type );

	lea	rdx, QWORD PTR [rbx+44]
	mov	ecx, edi
	call	MemtypeFromSize

; 687  : 
; 688  :     /* v2.04: warning added ( Masm emits an error ) */
; 689  :     /* v2.05: code active for 16-bit only */
; 690  :     if ( ModuleInfo.Ofssize == USE16 )

	cmp	BYTE PTR ModuleInfo+404, 0
	jne	SHORT $LN1@MakeComm

; 691  :         if ( ( count * size ) > 0x10000UL )

	mov	eax, edi
	imul	eax, esi
	cmp	eax, 65536				; 00010000H
	jbe	SHORT $LN1@MakeComm

; 692  :             EmitWarn( 2, COMM_VAR_EXCEEDS_64K, sym->name );

	mov	r8, QWORD PTR [rbx+8]
	mov	edx, 268				; 0000010cH
	mov	ecx, 2
	call	EmitWarn
$LN1@MakeComm:

; 693  : 
; 694  :     sym->total_size = count * size;

	imul	edi, esi

; 695  : 
; 696  :     return( sym );

	mov	rax, rbx
	mov	DWORD PTR [rbx+64], edi
	mov	rdi, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+40]
	mov	rbx, QWORD PTR [rsp+48]

; 697  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN13@MakeComm:
	mov	rdi, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+40]
	mov	rbx, QWORD PTR [rsp+48]

; 676  :     if( sym == NULL )
; 677  :         return( NULL );

	xor	eax, eax

; 697  : }

	add	rsp, 56					; 00000038H
	ret	0
MakeComm ENDP
_TEXT	ENDS
PUBLIC	CommDirective
EXTRN	EmitConstError:NEAR
EXTRN	EvalOperand:NEAR
EXTRN	__ImageBase:BYTE
xdata	SEGMENT
$unwind$CommDirective DD 0103101H
	DD	016e431H
	DD	017d42aH
	DD	018c420H
	DD	019741aH
	DD	01a6416H
	DD	01f5412H
	DD	01e340eH
	DD	01b010aH
xdata	ENDS
pdata	SEGMENT
$pdata$CommDirective DD @imagerel($LN72#)
	DD	@imagerel($LN72#+1072)
	DD	@imagerel($unwind$CommDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
langtype$ = 48
opndx$ = 64
i$ = 224
tokenarray$ = 232
CommDirective PROC NEAR

; 707  : {

$LN72:
	mov	rax, rsp
	sub	rsp, 216				; 000000d8H
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax+32], rbp
	mov	QWORD PTR [rax-8], rsi
	mov	QWORD PTR [rax-16], rdi

; 708  :     char            *token;
; 709  : #if MANGLERSUPP
; 710  :     char            *mangle_type = NULL;
; 711  : #endif
; 712  :     bool            isfar;
; 713  :     //int             distance;
; 714  :     int             tmp;
; 715  :     uint_32         size;  /* v2.12: changed from 'int' to 'uint_32' */
; 716  :     uint_32         count; /* v2.12: changed from 'int' to 'uint_32' */
; 717  :     struct asym     *sym;
; 718  :     struct expr     opndx;
; 719  :     enum lang_type  langtype;
; 720  : 
; 721  :     DebugMsg1(("CommDirective(%u) enter\n", i));
; 722  :     i++; /* skip COMM token */

	inc	ecx
	mov	QWORD PTR [rax-24], r12

; 723  :     for( ; i < Token_Count; i++ ) {

	cmp	ecx, DWORD PTR ModuleInfo+496
	mov	QWORD PTR [rax-32], r13
	mov	rbp, rdx
	mov	QWORD PTR [rax-40], r14
	mov	DWORD PTR [rax+8], ecx
	jge	$LN39@CommDirect
	lea	r14, OFFSET FLAT:__ImageBase
$LL41@CommDirect:

; 724  : #if MANGLERSUPP
; 725  :         mangle_type = Check4Mangler( &i, tokenarray );
; 726  : #endif
; 727  :         /* get the symbol language type if present */
; 728  :         langtype = ModuleInfo.langtype;

	mov	eax, DWORD PTR ModuleInfo+364

; 729  :         GetLangType( &i, tokenarray, &langtype );

	lea	r8, QWORD PTR langtype$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rbp
	mov	DWORD PTR langtype$[rsp], eax
	call	GetLangType

; 730  : 
; 731  :         /* get the -optional- distance ( near or far ) */
; 732  :         isfar = FALSE;
; 733  :         if ( tokenarray[i].token == T_STYPE )

	movsxd	rdx, DWORD PTR i$[rsp]
	xor	r13b, r13b
	mov	rax, rdx
	shl	rax, 5
	cmp	BYTE PTR [rax+rbp], 6
	jne	SHORT $LN36@CommDirect

; 734  :             switch ( tokenarray[i].tokval ) {

	mov	eax, DWORD PTR [rax+rbp+16]
	add	eax, -221				; ffffff23H
	cmp	eax, 5
	ja	SHORT $LN36@CommDirect
	mov	ecx, DWORD PTR $LN70@CommDirect[r14+rax*4]
	add	rcx, r14
	jmp	rcx
$LN35@CommDirect:

; 735  :             case T_FAR:
; 736  :             case T_FAR16:
; 737  :             case T_FAR32:
; 738  :                 if ( ModuleInfo.model == MODEL_FLAT ) {

	cmp	DWORD PTR ModuleInfo+360, 7
	jne	SHORT $LN34@CommDirect

; 739  :                     EmitError( FAR_NOT_ALLOWED_IN_FLAT_MODEL_COMM_VARIABLES );

	mov	ecx, 176				; 000000b0H
	call	EmitError

; 740  :                 } else

	mov	edx, DWORD PTR i$[rsp]
	jmp	SHORT $LN33@CommDirect
$LN34@CommDirect:

; 741  :                     isfar = TRUE;

	mov	r13b, 1
$LN33@CommDirect:

; 742  :                 /* no break */
; 743  :             case T_NEAR:
; 744  :             case T_NEAR16:
; 745  :             case T_NEAR32:
; 746  :                 i++;

	inc	edx
	mov	DWORD PTR i$[rsp], edx
$LN36@CommDirect:

; 747  :             }
; 748  : 
; 749  :         /* v2.08: ensure token is a valid id */
; 750  :         if( tokenarray[i].token != T_ID ) {

	movsxd	rax, edx
	shl	rax, 5
	cmp	BYTE PTR [rax+rbp], 8
	jne	$LN60@CommDirect

; 751  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );
; 752  :         }
; 753  :         /* get the symbol name */
; 754  :         token = tokenarray[i++].string_ptr;

	mov	r12, QWORD PTR [rax+rbp+8]
	inc	edx

; 755  : 
; 756  :         /* go past the colon */
; 757  :         if( tokenarray[i].token != T_COLON ) {

	movsxd	rax, edx
	mov	DWORD PTR i$[rsp], edx
	shl	rax, 5
	cmp	BYTE PTR [rax+rbp], 58			; 0000003aH
	jne	$LN60@CommDirect

; 759  :         }
; 760  :         i++;
; 761  :         /* the evaluator cannot handle a ':' so scan for one first */
; 762  :         for ( tmp = i; tmp < Token_Count;tmp++ )

	mov	ecx, DWORD PTR ModuleInfo+496
	inc	edx
	cmp	edx, ecx
	mov	DWORD PTR i$[rsp], edx
	movsxd	rax, edx
	jge	SHORT $LN71@CommDirect
	shl	rax, 5
	add	rax, rbp
$LL29@CommDirect:

; 763  :             if ( tokenarray[tmp].token == T_COLON )

	cmp	BYTE PTR [rax], 58			; 0000003aH
	je	SHORT $LN71@CommDirect
	inc	edx
	add	rax, 32					; 00000020H
	cmp	edx, ecx
	jl	SHORT $LL29@CommDirect
$LN71@CommDirect:

; 764  :                 break;
; 765  :         /* v2.10: expression evaluator isn't to accept forward references */
; 766  :         //if ( EvalOperand( &i, tokenarray, tmp, &opndx, 0 ) == ERROR )
; 767  :         if ( EvalOperand( &i, tokenarray, tmp, &opndx, EXPF_NOUNDEF ) == ERROR )

	mov	r8d, edx
	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rbp
	mov	BYTE PTR [rsp+32], 2
	call	EvalOperand
	cmp	eax, -1
	je	$LN64@CommDirect

; 768  :             return( ERROR );
; 769  : 
; 770  :         /* v2.03: a string constant is accepted by Masm */
; 771  :         /* v2.11: don't accept NEAR or FAR */
; 772  :         /* v2.12: check for too large value added */
; 773  :         //if ( opndx.kind != EXPR_CONST || opndx.string != NULL ) {
; 774  :         if ( opndx.kind != EXPR_CONST )

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN24@CommDirect

; 775  :             EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	SHORT $LN18@CommDirect
$LN24@CommDirect:

; 776  :         else if ( ( opndx.mem_type & MT_SPECIAL_MASK) == MT_ADDRESS )

	mov	eax, DWORD PTR opndx$[rsp+64]
	and	eax, 192				; 000000c0H
	cmp	al, -128				; ffffffffffffff80H
	jne	SHORT $LN22@CommDirect

; 777  :             EmitErr( INVALID_TYPE_FOR_DATA_DECLARATION, token );

	mov	rdx, r12
	mov	ecx, 160				; 000000a0H
	call	EmitErr
	jmp	SHORT $LN18@CommDirect
$LN22@CommDirect:

; 778  :         else if ( opndx.hvalue != 0 && opndx.hvalue != -1 )

	mov	eax, DWORD PTR opndx$[rsp+4]
	test	eax, eax
	je	SHORT $LN20@CommDirect
	cmp	eax, -1
	je	SHORT $LN20@CommDirect

; 779  :             EmitConstError( &opndx );

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError
	jmp	SHORT $LN18@CommDirect
$LN20@CommDirect:

; 780  :         else if ( opndx.uvalue == 0 )

	cmp	DWORD PTR opndx$[rsp], 0
	jne	SHORT $LN18@CommDirect

; 781  :             EmitError( POSITIVE_VALUE_EXPECTED );

	mov	ecx, 175				; 000000afH
	call	EmitError
$LN18@CommDirect:

; 782  : 
; 783  :         size = opndx.uvalue;
; 784  : 
; 785  :         count = 1;
; 786  :         if( tokenarray[i].token == T_COLON ) {

	movsxd	rcx, DWORD PTR i$[rsp]
	mov	esi, DWORD PTR opndx$[rsp]
	mov	edi, 1
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+rbp], 58			; 0000003aH
	jne	SHORT $LN17@CommDirect

; 787  :             i++;
; 788  :             /* get optional count argument */
; 789  :             /* v2.10: expression evaluator isn't to accept forward references */
; 790  :             //if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )
; 791  :             if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	inc	ecx
	lea	r9, QWORD PTR opndx$[rsp]
	mov	DWORD PTR i$[rsp], ecx
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rbp
	mov	BYTE PTR [rsp+32], 2
	call	EvalOperand
	cmp	eax, -1
	je	$LN64@CommDirect

; 792  :                 return( ERROR );
; 793  : 
; 794  :             /* v2.03: a string constant is acceptable! */
; 795  :             /* v2.12: check for too large value added */
; 796  :             //if ( opndx.kind != EXPR_CONST || opndx.string != NULL ) {
; 797  :             if ( opndx.kind != EXPR_CONST )

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN15@CommDirect

; 798  :                 EmitError( CONSTANT_EXPECTED );

	lea	ecx, QWORD PTR [rdi+64]
	call	EmitError
	jmp	SHORT $LN11@CommDirect
$LN15@CommDirect:

; 799  :             else if ( opndx.hvalue != 0 && opndx.hvalue != -1 )

	mov	eax, DWORD PTR opndx$[rsp+4]
	test	eax, eax
	je	SHORT $LN13@CommDirect
	cmp	eax, -1
	je	SHORT $LN13@CommDirect

; 800  :                 EmitConstError( &opndx );

	lea	rcx, QWORD PTR opndx$[rsp]
	call	EmitConstError
	jmp	SHORT $LN11@CommDirect
$LN13@CommDirect:

; 801  :             else if ( opndx.uvalue == 0 )

	cmp	DWORD PTR opndx$[rsp], 0
	jne	SHORT $LN11@CommDirect

; 802  :                 EmitError( POSITIVE_VALUE_EXPECTED );

	mov	ecx, 175				; 000000afH
	call	EmitError
$LN11@CommDirect:

; 803  : 
; 804  :             count = opndx.uvalue;

	mov	edi, DWORD PTR opndx$[rsp]
$LN17@CommDirect:

; 805  :         }
; 806  : 
; 807  :         sym = SymSearch( token );

	mov	rcx, r12
	call	SymFind

; 808  :         if( sym == NULL || sym->state == SYM_UNDEFINED ) {

	test	rax, rax
	mov	rbx, rax
	je	SHORT $LN9@CommDirect
	mov	eax, DWORD PTR [rax+40]
	test	eax, eax
	je	SHORT $LN9@CommDirect

; 812  :         } else if ( sym->state != SYM_EXTERNAL || sym->iscomm != TRUE ) {

	cmp	eax, 2
	jne	$LN5@CommDirect
	test	BYTE PTR [rbx+55], 4
	je	$LN5@CommDirect

; 814  :         } else {
; 815  :             tmp = sym->total_size / sym->total_length;
; 816  :             if( count != sym->total_length || size != tmp ) {

	mov	ecx, DWORD PTR [rbx+72]
	cmp	edi, ecx
	jne	SHORT $LN2@CommDirect
	mov	eax, DWORD PTR [rbx+64]
	xor	edx, edx
	div	ecx
	cmp	esi, eax
	je	$LN49@CommDirect
$LN2@CommDirect:

; 817  :                 return( EmitErr( NON_BENIGN_XXX_REDEFINITION, szCOMM, sym->name ) );

	mov	r8, QWORD PTR [rbx+8]
	lea	rdx, OFFSET FLAT:szCOMM
	mov	ecx, 139				; 0000008bH
	call	EmitErr
	jmp	$LN42@CommDirect
$LN9@CommDirect:

; 809  :             sym = MakeComm( token, sym, size, count, isfar );

	test	rbx, rbx
	jne	SHORT $LN53@CommDirect
	mov	rcx, r12
	call	SymCreate
	mov	rbx, rax
	jmp	SHORT $LN52@CommDirect
$LN53@CommDirect:
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rbx
	call	sym_remove_table
$LN52@CommDirect:
	test	rbx, rbx
	je	$LN64@CommDirect
	movzx	ecx, BYTE PTR [rbx+55]
	mov	DWORD PTR [rbx+40], 2
	movzx	eax, BYTE PTR ModuleInfo+404
	and	cl, 228					; 000000e4H
	and	al, 3
	mov	rdx, rbx
	or	cl, al
	or	cl, 4
	mov	BYTE PTR [rbx+55], cl
	lea	rcx, OFFSET FLAT:SymTables+16
	call	sym_add_table
	and	BYTE PTR [rbx+55], 239			; 000000efH
	movzx	eax, r13b
	and	al, 1
	mov	DWORD PTR [rbx+72], edi
	shl	al, 4
	or	BYTE PTR [rbx+55], al
	cmp	BYTE PTR Options+137, 0
	je	SHORT $LN46@CommDirect
	test	r13b, r13b
	jne	SHORT $LN47@CommDirect
$LN46@CommDirect:
	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rbx+32], rax
$LN47@CommDirect:
	lea	rdx, QWORD PTR [rbx+44]
	mov	ecx, esi
	call	MemtypeFromSize
	cmp	BYTE PTR ModuleInfo+404, 0
	jne	SHORT $LN44@CommDirect
	mov	eax, edi
	imul	eax, esi
	cmp	eax, 65536				; 00010000H
	jbe	SHORT $LN44@CommDirect
	mov	r8, QWORD PTR [rbx+8]
	mov	edx, 268				; 0000010cH
	mov	ecx, 2
	call	EmitWarn
$LN44@CommDirect:
	imul	edi, esi
	mov	DWORD PTR [rbx+64], edi
$LN49@CommDirect:

; 818  :             }
; 819  :         }
; 820  :         sym->isdefined = TRUE;

	or	BYTE PTR [rbx+48], 2

; 821  :         SetMangler( sym, langtype, mangle_type );

	mov	edx, DWORD PTR langtype$[rsp]
	xor	r8d, r8d
	mov	rcx, rbx
	call	SetMangler

; 822  : 
; 823  :         if ( tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA ) {

	movsxd	r11, DWORD PTR i$[rsp]
	mov	rax, r11
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+rbp]
	test	cl, cl
	je	SHORT $LN40@CommDirect
	cmp	cl, 44					; 0000002cH
	jne	$LN65@CommDirect
$LN40@CommDirect:

; 723  :     for( ; i < Token_Count; i++ ) {

	inc	r11d
	cmp	r11d, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rsp], r11d
	jl	$LL41@CommDirect
$LN39@CommDirect:

; 825  :         }
; 826  :     }
; 827  :     return( NOT_ERROR );

	xor	eax, eax
$LN42@CommDirect:
	mov	r14, QWORD PTR [rsp+176]
	mov	r13, QWORD PTR [rsp+184]
	mov	r12, QWORD PTR [rsp+192]
	mov	rdi, QWORD PTR [rsp+200]
	mov	rsi, QWORD PTR [rsp+208]
	mov	rbp, QWORD PTR [rsp+248]
	mov	rbx, QWORD PTR [rsp+240]

; 828  : }

	add	rsp, 216				; 000000d8H
	ret	0
$LN60@CommDirect:

; 758  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, edx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbp+8]
	call	EmitErr
	jmp	SHORT $LN42@CommDirect
$LN5@CommDirect:

; 813  :             return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	SHORT $LN42@CommDirect
$LN64@CommDirect:

; 810  :             if ( sym == NULL )
; 811  :                 return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN42@CommDirect
$LN65@CommDirect:

; 824  :             return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	mov	rdx, r11
	mov	ecx, 39					; 00000027H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbp+24]
	call	EmitErr
	jmp	$LN42@CommDirect
	npad	1
$LN70@CommDirect:

; 828  : }

	DD	$LN33@CommDirect
	DD	$LN35@CommDirect
	DD	$LN33@CommDirect
	DD	$LN33@CommDirect
	DD	$LN35@CommDirect
	DD	$LN35@CommDirect
CommDirective ENDP
_TEXT	ENDS
PUBLIC	AddPublicData
EXTRN	QAddItem:NEAR
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
sym$ = 8
AddPublicData PROC NEAR

; 833  :     DebugMsg1(("AddPublicData(%s)\n", sym->name ));
; 834  :     QAddItem( &ModuleInfo.g.PubQueue, sym );

	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:ModuleInfo+16

; 835  : }

	jmp	QAddItem
AddPublicData ENDP
_TEXT	ENDS
PUBLIC	FreePubQueue
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
FreePubQueue PROC NEAR

; 873  : #if FASTMEM==0
; 874  :     struct qnode *curr;
; 875  :     struct qnode *next;
; 876  :     for( curr = ModuleInfo.g.PubQueue.head; curr; curr = next ) {
; 877  :         next = curr->next;
; 878  :         LclFree( curr );
; 879  :     }
; 880  : #endif
; 881  :     ModuleInfo.g.PubQueue.head = NULL;

	mov	QWORD PTR ModuleInfo+16, 0

; 882  : }

	ret	0
FreePubQueue ENDP
_TEXT	ENDS
PUBLIC	PublicDirective
xdata	SEGMENT
$unwind$PublicDirective DD 092601H
	DD	057426H
	DD	0a3415H
	DD	06640eH
	DD	0b5409H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$PublicDirective DD @imagerel($LN36#)
	DD	@imagerel($LN36#+509)
	DD	@imagerel($unwind$PublicDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
skipitem$ = 64
i$ = 64
langtype$ = 72
tokenarray$ = 72
PublicDirective PROC NEAR

; 888  : {

$LN36:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR [rsp+88], rbp
	mov	QWORD PTR [rsp+48], rsi

; 889  : #if MANGLERSUPP
; 890  :     char                *mangle_type = NULL;
; 891  : #endif
; 892  :     char                *token;
; 893  :     struct asym         *sym;
; 894  :     //struct dsym       *dir;
; 895  :     char                skipitem;
; 896  :     enum lang_type      langtype;
; 897  : 
; 898  :     DebugMsg1(("PublicDirective(%u) enter\n", i));
; 899  :     i++; /* skip PUBLIC directive */

	inc	ecx
	mov	QWORD PTR [rsp+80], rbx
	mov	DWORD PTR i$[rsp], ecx
	movzx	esi, BYTE PTR skipitem$[rsp]
	mov	rbp, rdx
	mov	QWORD PTR [rsp+40], rdi
	npad	10
$LL28@PublicDire:

; 900  : #if MANGLERSUPP
; 901  :     mangle_type = Check4Mangler( &i, tokenarray );
; 902  : #endif
; 903  :     do {
; 904  : 
; 905  :         /* read the optional language type */
; 906  :         langtype = ModuleInfo.langtype;

	mov	eax, DWORD PTR ModuleInfo+364

; 907  :         GetLangType( &i, tokenarray, &langtype );

	lea	r8, QWORD PTR langtype$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rbp
	mov	DWORD PTR langtype$[rsp], eax
	call	GetLangType

; 908  : 
; 909  :         if ( tokenarray[i].token != T_ID ) {

	movsxd	r11, DWORD PTR i$[rsp]
	mov	rdi, r11
	shl	rdi, 5
	cmp	BYTE PTR [rdi+rbp], 8
	jne	$LN34@PublicDire

; 911  :         }
; 912  :         /* get the symbol name */
; 913  :         token = tokenarray[i++].string_ptr;

	mov	rdi, QWORD PTR [rdi+rbp+8]
	inc	r11d

; 914  : 
; 915  :         DebugMsg1(("PublicDirective: sym=%s\n", token ));
; 916  : 
; 917  :         /* Add the public name */
; 918  :         sym = SymSearch( token );

	mov	rcx, rdi
	mov	DWORD PTR i$[rsp], r11d
	call	SymFind

; 919  :         if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	rbx, rax
	jne	SHORT $LN24@PublicDire

; 920  :             if ( sym == NULL ) {

	test	rax, rax
	jne	SHORT $LN21@PublicDire

; 921  :                 if ( sym = SymCreate( token ) ) {

	mov	rcx, rdi
	call	SymCreate
	test	rax, rax
	mov	rbx, rax
	je	$LN22@PublicDire

; 922  :                     sym_add_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rax
	call	sym_add_table
$LN21@PublicDire:

; 926  :             }
; 927  :             skipitem = FALSE;

	xor	sil, sil

; 928  :         } else {

	jmp	SHORT $LN19@PublicDire
$LN24@PublicDire:

; 929  :             if ( sym == NULL || sym->state == SYM_UNDEFINED ) {

	test	rax, rax
	je	SHORT $LN18@PublicDire
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN19@PublicDire
$LN18@PublicDire:

; 930  :                 EmitErr( SYMBOL_NOT_DEFINED, token );

	mov	rdx, rdi
	mov	ecx, 102				; 00000066H
	call	EmitErr
$LN19@PublicDire:

; 931  :                 //return( ERROR ); /* v2.04: dont exit */
; 932  :             }
; 933  :         }
; 934  :         if ( sym ) {

	test	rbx, rbx
	je	$LN6@PublicDire

; 935  :             switch ( sym->state ) {

	mov	ecx, DWORD PTR [rbx+40]
	test	ecx, ecx
	je	SHORT $LN12@PublicDire
	dec	ecx
	je	SHORT $LN13@PublicDire
	dec	ecx
	je	SHORT $LN11@PublicDire

; 957  :             default:
; 958  :                 EmitErr( CANNOT_DEFINE_AS_PUBLIC_OR_EXTERNAL, sym->name );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 174				; 000000aeH
	call	EmitErr

; 959  :                 skipitem = TRUE;

	mov	sil, 1
	jmp	SHORT $LN12@PublicDire
$LN11@PublicDire:

; 942  :                     //return( ERROR );
; 943  :                 }
; 944  :                 break;
; 945  :             case SYM_EXTERNAL:
; 946  :                 if ( sym->iscomm == TRUE ) {

	movzx	eax, BYTE PTR [rbx+55]
	test	al, 4
	je	SHORT $LN10@PublicDire

; 947  :                     EmitErr( CANNOT_DEFINE_AS_PUBLIC_OR_EXTERNAL, sym->name );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 174				; 000000aeH
	call	EmitErr

; 948  :                     skipitem = TRUE;

	mov	sil, 1
	jmp	SHORT $LN12@PublicDire
$LN10@PublicDire:

; 949  :                     //return( ERROR );
; 950  :                 } else if ( sym->weak == FALSE ) {

	test	al, 8
	jne	SHORT $LN12@PublicDire

; 951  :                     /* for EXTERNs, emit a different error msg */
; 952  :                     EmitErr( SYMBOL_REDEFINITION, sym->name );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 953  :                     skipitem = TRUE;

	mov	sil, 1

; 954  :                     //return( ERROR );
; 955  :                 }
; 956  :                 break;

	jmp	SHORT $LN12@PublicDire
$LN13@PublicDire:

; 936  :             case SYM_UNDEFINED:
; 937  :                 break;
; 938  :             case SYM_INTERNAL:
; 939  :                 if ( sym->scoped == TRUE ) {

	test	BYTE PTR [rbx+48], 4
	je	SHORT $LN12@PublicDire

; 940  :                     EmitErr( CANNOT_DECLARE_SCOPED_CODE_LABEL_AS_PUBLIC, sym->name );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 180				; 000000b4H
	call	EmitErr

; 941  :                     skipitem = TRUE;

	mov	sil, 1
$LN12@PublicDire:

; 960  :                 //return( ERROR );
; 961  :             }
; 962  :             if( Parse_Pass == PASS_1 && skipitem == FALSE ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN6@PublicDire
	test	sil, sil
	jne	SHORT $LN6@PublicDire

; 963  :                 if ( sym->ispublic == FALSE ) {

	movzx	eax, BYTE PTR [rbx+48]
	test	al, al
	js	SHORT $LN31@PublicDire

; 964  :                     sym->ispublic = TRUE;

	or	al, 128					; 00000080H

; 965  :                     AddPublicData( sym ); /* put it into the public table */

	lea	rcx, OFFSET FLAT:ModuleInfo+16
	mov	rdx, rbx
	mov	BYTE PTR [rbx+48], al
	call	QAddItem
$LN31@PublicDire:

; 966  :                 }
; 967  :                 SetMangler( sym, langtype, mangle_type );

	mov	edx, DWORD PTR langtype$[rsp]
	xor	r8d, r8d
	mov	rcx, rbx
	call	SetMangler
$LN6@PublicDire:

; 968  :             }
; 969  :         }
; 970  : 
; 971  :         if ( tokenarray[i].token != T_FINAL )

	movsxd	rcx, DWORD PTR i$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rax, rcx
	shl	rax, 5
	movzx	edx, BYTE PTR [rax+rbp]
	test	dl, dl
	je	SHORT $LN27@PublicDire

; 972  :             if ( tokenarray[i].token == T_COMMA ) {

	cmp	dl, 44					; 0000002cH
	jne	SHORT $LN3@PublicDire

; 973  :                 if ( (i + 1) < Token_Count )

	lea	eax, DWORD PTR [rcx+1]
	cmp	eax, r8d
	cmovl	ecx, eax
	mov	DWORD PTR i$[rsp], ecx
$LN27@PublicDire:

; 977  :             }
; 978  : 
; 979  :     } while ( i < Token_Count );

	cmp	ecx, r8d
	jl	$LL28@PublicDire

; 980  : 
; 981  :     return( NOT_ERROR );

	xor	eax, eax
$LN29@PublicDire:
	mov	rdi, QWORD PTR [rsp+40]
	mov	rsi, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]

; 982  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN34@PublicDire:

; 910  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, r11
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbp+8]
	call	EmitErr
	jmp	SHORT $LN29@PublicDire
$LN22@PublicDire:

; 923  :                     DebugMsg1(("PublicDirective(%s): new symbol\n", sym->name ));
; 924  :                 } else
; 925  :                     return( ERROR ); /* name was too long */

	mov	eax, -1
	jmp	SHORT $LN29@PublicDire
$LN3@PublicDire:

; 974  :                     i++;
; 975  :             } else {
; 976  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, rcx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbp+24]
	call	EmitErr
	jmp	SHORT $LN29@PublicDire
PublicDirective ENDP
_TEXT	ENDS
PUBLIC	ExterndefDirective
xdata	SEGMENT
$unwind$ExterndefDirective DD 0b2201H
	DD	097422H
	DD	0a641aH
	DD	0e3415H
	DD	08c40eH
	DD	0f5409H
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$ExterndefDirective DD @imagerel($LN65#)
	DD	@imagerel($LN65#+1161)
	DD	@imagerel($unwind$ExterndefDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
ti$ = 32
i$ = 96
langtype$ = 104
tokenarray$ = 104
ExterndefDirective PROC NEAR

; 183  : {

$LN65:
	sub	rsp, 88					; 00000058H
	mov	QWORD PTR [rsp+120], rbp
	mov	QWORD PTR [rsp+64], r12

; 184  :     char                *token;
; 185  : #if MANGLERSUPP
; 186  :     char                *mangle_type = NULL;
; 187  : #endif
; 188  :     struct asym         *sym;
; 189  :     enum lang_type      langtype;
; 190  :     char isnew;
; 191  :     struct qualified_type ti;
; 192  : 
; 193  :     DebugMsg1(("ExterndefDirective(%u) enter\n", i));
; 194  : 
; 195  :     i++; /* skip EXTERNDEF token */

	inc	ecx
	mov	QWORD PTR [rsp+112], rbx
	mov	QWORD PTR [rsp+80], rsi
	mov	rbp, rdx
	mov	QWORD PTR [rsp+72], rdi
	mov	DWORD PTR i$[rsp], ecx
	xor	r12d, r12d
	npad	7
$LL42@ExterndefD:

; 196  : #if MANGLERSUPP
; 197  :     mangle_type = Check4Mangler( &i, tokenarray );
; 198  : #endif
; 199  :     do {
; 200  : 
; 201  :         ti.Ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404

; 202  : 
; 203  :         /* get the symbol language type if present */
; 204  :         langtype = ModuleInfo.langtype;
; 205  :         GetLangType( &i, tokenarray, &langtype );

	lea	r8, QWORD PTR langtype$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	BYTE PTR ti$[rsp+22], al
	mov	eax, DWORD PTR ModuleInfo+364
	mov	rdx, rbp
	mov	DWORD PTR langtype$[rsp], eax
	call	GetLangType

; 206  : 
; 207  :         /* get the symbol name */
; 208  :         if( tokenarray[i].token != T_ID ) {

	movsxd	r11, DWORD PTR i$[rsp]
	mov	rax, r11
	shl	rax, 5
	cmp	BYTE PTR [rax+rbp], 8
	jne	$LN55@ExterndefD

; 210  :         }
; 211  :         token = tokenarray[i++].string_ptr;

	mov	rsi, QWORD PTR [rax+rbp+8]
	inc	r11d

; 212  : 
; 213  :         /* go past the colon */
; 214  :         if( tokenarray[i].token != T_COLON ) {

	movsxd	rax, r11d
	mov	DWORD PTR i$[rsp], r11d
	shl	rax, 5
	cmp	BYTE PTR [rax+rbp], 58			; 0000003aH
	jne	$LN57@ExterndefD

; 216  :         }
; 217  :         i++;

	inc	r11d

; 218  :         sym = SymSearch( token );

	mov	rcx, rsi
	mov	DWORD PTR i$[rsp], r11d
	call	SymFind

; 219  : 
; 220  :         //typetoken = tokenarray[i].string_ptr;
; 221  :         ti.mem_type = MT_EMPTY;
; 222  :         ti.size = 0;
; 223  :         ti.is_ptr = 0;
; 224  :         ti.is_far = FALSE;
; 225  :         ti.ptr_memtype = MT_EMPTY;
; 226  :         ti.symtype = NULL;
; 227  :         ti.Ofssize = ModuleInfo.Ofssize;

	movzx	ecx, BYTE PTR ModuleInfo+404

; 228  : 
; 229  :         if ( tokenarray[i].token == T_ID && ( 0 == _stricmp( tokenarray[i].string_ptr, "ABS" ) ) ) {

	movsxd	r8, DWORD PTR i$[rsp]
	mov	BYTE PTR ti$[rsp+22], cl
	mov	DWORD PTR ti$[rsp+16], 192		; 000000c0H
	mov	rcx, r8
	mov	DWORD PTR ti$[rsp], r12d
	mov	BYTE PTR ti$[rsp+20], r12b
	shl	rcx, 5
	mov	BYTE PTR ti$[rsp+21], r12b
	mov	DWORD PTR ti$[rsp+24], 192		; 000000c0H
	mov	QWORD PTR ti$[rsp+8], r12
	cmp	BYTE PTR [rcx+rbp], 8
	mov	rdi, rax
	mov	rdx, r12
	jne	SHORT $LN37@ExterndefD
	mov	rcx, QWORD PTR [rcx+rbp+8]
	lea	rdx, OFFSET FLAT:$SG5735
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN63@ExterndefD

; 230  :             /* v2.07: MT_ABS is obsolete */
; 231  :             //ti.mem_type = MT_ABS;
; 232  :             i++;

	inc	DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR ti$[rsp+8]
	jmp	SHORT $LN32@ExterndefD
$LN63@ExterndefD:
	mov	r8d, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR ti$[rsp+8]
$LN37@ExterndefD:

; 233  :         } else if ( tokenarray[i].token == T_DIRECTIVE && tokenarray[i].tokval == T_PROTO ) {

	movsxd	rax, r8d
	shl	rax, 5
	movzx	ecx, BYTE PTR [rax+rbp]
	cmp	cl, 3
	jne	SHORT $LN35@ExterndefD
	cmp	DWORD PTR [rax+rbp+16], 432		; 000001b0H
	je	$LN58@ExterndefD
$LN35@ExterndefD:

; 246  :         } else if ( tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA ) {

	test	cl, cl
	je	SHORT $LN32@ExterndefD
	cmp	cl, 44					; 0000002cH
	je	SHORT $LN32@ExterndefD

; 247  :             if ( GetQualifiedType( &i, tokenarray, &ti ) == ERROR )

	lea	r8, QWORD PTR ti$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rbp
	call	GetQualifiedType
	cmp	eax, -1
	je	$LN59@ExterndefD
	mov	rdx, QWORD PTR ti$[rsp+8]
$LN32@ExterndefD:

; 249  :         }
; 250  : 
; 251  :         isnew = FALSE;
; 252  :         if ( sym == NULL || sym->state == SYM_UNDEFINED ) {

	test	rdi, rdi
	je	SHORT $LN30@ExterndefD
	cmp	DWORD PTR [rdi+40], r12d
	jne	$LN29@ExterndefD
$LN30@ExterndefD:

; 253  :             sym = CreateExternal( sym, token, TRUE );

	test	rdi, rdi
	mov	rbx, rdi
	jne	SHORT $LN47@ExterndefD
	mov	rcx, rsi
	call	SymCreate
	mov	rbx, rax
	jmp	SHORT $LN46@ExterndefD
$LN47@ExterndefD:
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rdi
	call	sym_remove_table
$LN46@ExterndefD:
	test	rbx, rbx
	je	SHORT $LN45@ExterndefD
	movzx	ecx, BYTE PTR [rbx+55]
	mov	DWORD PTR [rbx+40], 2
	movzx	eax, BYTE PTR ModuleInfo+404
	and	cl, 248					; 000000f8H
	and	al, 3
	mov	rdx, rbx
	or	cl, al
	or	cl, 8
	mov	BYTE PTR [rbx+55], cl
	lea	rcx, OFFSET FLAT:SymTables+16
	call	sym_add_table
$LN45@ExterndefD:

; 254  :             isnew = TRUE;
; 255  :         }
; 256  : 
; 257  :         /* new symbol? */
; 258  : 
; 259  :         if ( isnew ) {
; 260  :             DebugMsg1(("ExterndefDirective(%s): memtype=%X set, ofssize=%X\n", token, ti.mem_type, ti.Ofssize ));
; 261  : 
; 262  :             /* v2.05: added to accept type prototypes */
; 263  :             if ( ti.is_ptr == 0 && ti.symtype && ti.symtype->isproc ) {

	cmp	BYTE PTR ti$[rsp+20], r12b
	mov	rdi, rbx
	jne	SHORT $LN64@ExterndefD
	mov	rax, QWORD PTR ti$[rsp+8]
	test	rax, rax
	je	SHORT $LN64@ExterndefD
	test	BYTE PTR [rax+49], 8
	je	SHORT $LN64@ExterndefD

; 264  :                 CreateProc( sym, NULL, SYM_EXTERNAL );

	xor	edx, edx
	mov	rcx, rbx
	lea	r8d, QWORD PTR [rdx+2]
	call	CreateProc

; 265  :                 CopyPrototype( (struct dsym *)sym, (struct dsym *)ti.symtype );

	mov	rdx, QWORD PTR ti$[rsp+8]
	mov	rcx, rbx
	call	CopyPrototype

; 266  :                 ti.mem_type = ti.symtype->mem_type;

	mov	r11, QWORD PTR ti$[rsp+8]
	mov	ecx, DWORD PTR [r11+44]

; 267  :                 ti.symtype = NULL;

	mov	QWORD PTR ti$[rsp+8], r12
	mov	DWORD PTR ti$[rsp+16], ecx
	jmp	SHORT $LN28@ExterndefD
$LN64@ExterndefD:
	mov	ecx, DWORD PTR ti$[rsp+16]
$LN28@ExterndefD:

; 268  :             }
; 269  :             switch ( ti.mem_type ) {

	sub	ecx, 130				; 00000082H
	je	SHORT $LN24@ExterndefD
	sub	ecx, 62					; 0000003eH
	je	SHORT $LN26@ExterndefD
	jmp	SHORT $LN23@ExterndefD
$LN24@ExterndefD:

; 270  :             //case MT_ABS:
; 271  :             case MT_EMPTY:
; 272  :                 /* v2.04: hack no longer necessary */
; 273  :                 //if ( sym->weak == TRUE )
; 274  :                 //    sym->equate = TRUE; /* allow redefinition by EQU, = */
; 275  :                 break;
; 276  :             case MT_FAR:
; 277  :                 /* v2.04: don't inherit current segment for FAR externals
; 278  :                  * if -Zg is set.
; 279  :                  */
; 280  :                 if ( Options.masm_compat_gencode )

	cmp	BYTE PTR Options+137, r12b
	jne	SHORT $LN26@ExterndefD
$LN23@ExterndefD:

; 281  :                     break; 
; 282  :                 /* fall through */
; 283  :             default:
; 284  :                 //SetSymSegOfs( sym );
; 285  :                 sym->segment = &CurrSeg->sym;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rbx+32], rax
$LN26@ExterndefD:

; 286  :             }
; 287  :             sym->Ofssize = ti.Ofssize;

	movzx	eax, BYTE PTR ti$[rsp+22]
	mov	BYTE PTR [rbx+52], al

; 288  : 
; 289  :             if ( ti.is_ptr == 0 && ti.Ofssize != ModuleInfo.Ofssize ) {

	cmp	BYTE PTR ti$[rsp+20], r12b
	jne	SHORT $LN20@ExterndefD
	movzx	ecx, BYTE PTR ti$[rsp+22]
	cmp	cl, BYTE PTR ModuleInfo+404
	je	SHORT $LN20@ExterndefD

; 290  :                 sym->seg_ofssize = ti.Ofssize;

	movzx	eax, BYTE PTR [rbx+55]
	xor	al, cl
	and	al, 3
	xor	BYTE PTR [rbx+55], al

; 291  :                 if ( sym->segment && ((struct dsym *)sym->segment)->e.seginfo->Ofssize != sym->seg_ofssize )

	mov	rax, QWORD PTR [rbx+32]
	movzx	ecx, BYTE PTR [rbx+55]
	test	rax, rax
	je	SHORT $LN20@ExterndefD
	mov	rax, QWORD PTR [rax+104]
	and	cl, 3
	cmp	BYTE PTR [rax+104], cl
	je	SHORT $LN20@ExterndefD

; 292  :                     sym->segment = NULL;

	mov	QWORD PTR [rbx+32], r12
$LN20@ExterndefD:

; 293  :             }
; 294  : 
; 295  :             sym->mem_type = ti.mem_type;

	mov	eax, DWORD PTR ti$[rsp+16]
	mov	DWORD PTR [rbx+44], eax

; 296  :             sym->is_ptr = ti.is_ptr;

	movzx	eax, BYTE PTR ti$[rsp+20]
	mov	BYTE PTR [rbx+53], al

; 297  :             sym->isfar = ti.is_far;

	movzx	eax, BYTE PTR ti$[rsp+21]
	shl	al, 4
	xor	al, BYTE PTR [rbx+55]
	and	al, 16
	xor	BYTE PTR [rbx+55], al

; 298  :             sym->ptr_memtype = ti.ptr_memtype;

	movzx	eax, BYTE PTR ti$[rsp+24]
	mov	BYTE PTR [rbx+54], al

; 299  :             if ( ti.mem_type == MT_TYPE )

	cmp	DWORD PTR ti$[rsp+16], 196		; 000000c4H
	jne	SHORT $LN19@ExterndefD

; 300  :                 sym->type = ti.symtype;

	mov	rax, QWORD PTR ti$[rsp+8]

; 303  : 
; 304  :             /* v2.04: only set language if there was no previous definition */
; 305  :             SetMangler( sym, langtype, mangle_type );

	xor	r8d, r8d
	mov	rcx, rbx
	mov	QWORD PTR [rbx+88], rax
	mov	edx, DWORD PTR langtype$[rsp]
	call	SetMangler
	jmp	$LN6@ExterndefD
$LN19@ExterndefD:

; 301  :             else
; 302  :                 sym->target_type = ti.symtype;

	mov	rax, QWORD PTR ti$[rsp+8]

; 303  : 
; 304  :             /* v2.04: only set language if there was no previous definition */
; 305  :             SetMangler( sym, langtype, mangle_type );

	xor	r8d, r8d
	mov	rcx, rbx
	mov	QWORD PTR [rbx+56], rax
	mov	edx, DWORD PTR langtype$[rsp]
	call	SetMangler
	jmp	$LN6@ExterndefD
$LN29@ExterndefD:

; 306  : 
; 307  :         } else if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, r12d
	jne	$LN6@ExterndefD

; 308  : 
; 309  :             /* v2.05: added to accept type prototypes */
; 310  :             if ( ti.is_ptr == 0 && ti.symtype && ti.symtype->isproc ) {

	cmp	BYTE PTR ti$[rsp+20], r12b
	jne	SHORT $LN15@ExterndefD
	test	rdx, rdx
	je	SHORT $LN15@ExterndefD
	test	BYTE PTR [rdx+49], 8
	je	SHORT $LN15@ExterndefD

; 311  :                 ti.mem_type = ti.symtype->mem_type;

	mov	eax, DWORD PTR [rdx+44]

; 312  :                 ti.symtype = NULL;

	mov	rdx, r12
	mov	QWORD PTR ti$[rsp+8], r12
	mov	DWORD PTR ti$[rsp+16], eax
$LN15@ExterndefD:

; 313  :             }
; 314  :             /* ensure that the type of the symbol won't change */
; 315  : 
; 316  :             if ( sym->mem_type != ti.mem_type ) {

	mov	eax, DWORD PTR [rdi+44]
	cmp	eax, DWORD PTR ti$[rsp+16]
	je	SHORT $LN14@ExterndefD

; 317  :                 /* if the symbol is already defined (as SYM_INTERNAL), Masm
; 318  :                  won't display an error. The other way, first externdef and
; 319  :                  then the definition, will make Masm complain, however */
; 320  :                 DebugMsg(("ExterndefDirective: type conflict for %s. mem_types old-new: %X-%X\n", sym->name, sym->mem_type, ti.mem_type));
; 321  :                 EmitWarn( 1, SYMBOL_TYPE_CONFLICT, sym->name );

	mov	r8, QWORD PTR [rdi+8]
	mov	edx, 136				; 00000088H
	mov	ecx, 1
	call	EmitWarn
	jmp	SHORT $LN7@ExterndefD
$LN14@ExterndefD:

; 322  :             } else if ( sym->mem_type == MT_TYPE && sym->type != ti.symtype ) {

	cmp	eax, 196				; 000000c4H
	jne	SHORT $LN7@ExterndefD
	cmp	QWORD PTR [rdi+88], rdx
	je	SHORT $LN7@ExterndefD

; 323  :                 struct asym *sym2 = sym;
; 324  :                 /* skip alias types and compare the base types */
; 325  :                 DebugMsg(("ExterndefDirective(%s): types differ: %X (%s) - %X (%s)\n", sym->name, sym->type, sym->type->name, ti.symtype, ti.symtype->name));
; 326  :                 while ( sym2->type )

	mov	rax, QWORD PTR [rdi+88]
	mov	rcx, rdi
	test	rax, rax
	je	SHORT $LN54@ExterndefD
	npad	3
$LL11@ExterndefD:

; 327  :                     sym2 = sym2->type;

	mov	rcx, rax
	mov	rax, QWORD PTR [rax+88]
	test	rax, rax
	jne	SHORT $LL11@ExterndefD
$LN54@ExterndefD:

; 328  :                 while ( ti.symtype->type )

	mov	rax, QWORD PTR [rdx+88]
	test	rax, rax
	je	SHORT $LN8@ExterndefD
	npad	11
$LL9@ExterndefD:

; 329  :                     ti.symtype = ti.symtype->type;

	mov	rdx, rax
	mov	QWORD PTR ti$[rsp+8], rax
	mov	rax, QWORD PTR [rax+88]
	test	rax, rax
	jne	SHORT $LL9@ExterndefD
$LN8@ExterndefD:

; 330  :                 if ( sym2 != ti.symtype ) {

	cmp	rcx, rdx
	je	SHORT $LN7@ExterndefD

; 331  :                     DebugMsg(("ExterndefDirective(%s): type conflict old-new: %X (%s) - %X (%s)\n", sym->name, sym2, sym2->name, ti.symtype, ti.symtype->name));
; 332  :                     EmitWarn( 1, SYMBOL_TYPE_CONFLICT, sym->name );

	mov	r8, QWORD PTR [rdi+8]
	mov	edx, 136				; 00000088H
	mov	ecx, 1
	call	EmitWarn
$LN7@ExterndefD:

; 333  :                 }
; 334  :             }
; 335  : 
; 336  :             /* v2.04: emit a - weak - warning if language differs.
; 337  :              * Masm doesn't warn.
; 338  :              */
; 339  :             if ( langtype != LANG_NONE && sym->langtype != langtype )

	mov	eax, DWORD PTR langtype$[rsp]
	test	eax, eax
	je	SHORT $LN6@ExterndefD
	cmp	DWORD PTR [rdi+84], eax
	je	SHORT $LN6@ExterndefD

; 340  :                 EmitWarn( 3, LANGUAGE_ATTRIBUTE_CONFLICT, sym->name );

	mov	r8, QWORD PTR [rdi+8]
	mov	edx, 103				; 00000067H
	lea	ecx, QWORD PTR [rdx-100]
	call	EmitWarn
$LN6@ExterndefD:

; 341  :         }
; 342  :         sym->isdefined = TRUE;

	or	BYTE PTR [rdi+48], 2

; 343  : 
; 344  : #if 0
; 345  :         /* write a global entry if none has been written yet */
; 346  :         if ( sym->state == SYM_EXTERNAL && sym->weak == FALSE )
; 347  :             ;/* skip EXTERNDEF if a real EXTERN/COMM was done */
; 348  :         else if ( sym->isglobal == FALSE ) {
; 349  :             sym->isglobal = TRUE;
; 350  :             DebugMsg1(("ExterndefDirective(%s): writing a global entry\n", sym->name));
; 351  :             QAddItem( &ModuleInfo.g.GlobalQueue, sym );
; 352  :         }
; 353  : #else
; 354  :         if ( sym->state == SYM_INTERNAL && sym->ispublic == FALSE ) {

	cmp	DWORD PTR [rdi+40], 1
	movzx	eax, BYTE PTR [rdi+48]
	jne	SHORT $LN50@ExterndefD
	test	al, al
	js	SHORT $LN50@ExterndefD

; 355  :             sym->ispublic = TRUE;

	or	al, 128					; 00000080H

; 356  :             AddPublicData( sym );

	lea	rcx, OFFSET FLAT:ModuleInfo+16
	mov	rdx, rdi
	mov	BYTE PTR [rdi+48], al
	call	QAddItem
$LN50@ExterndefD:

; 357  :         }
; 358  : #endif
; 359  : 
; 360  :         if ( tokenarray[i].token != T_FINAL )

	movsxd	rcx, DWORD PTR i$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	mov	rax, rcx
	shl	rax, 5
	movzx	edx, BYTE PTR [rax+rbp]
	test	dl, dl
	je	SHORT $LN41@ExterndefD

; 361  :             if ( tokenarray[i].token == T_COMMA ) {

	cmp	dl, 44					; 0000002cH
	jne	$LN3@ExterndefD

; 362  :                 if ( (i + 1) < Token_Count )

	lea	eax, DWORD PTR [rcx+1]
	cmp	eax, r8d
	cmovl	ecx, eax
	mov	DWORD PTR i$[rsp], ecx
$LN41@ExterndefD:

; 366  :             }
; 367  : 
; 368  :     } while ( i < Token_Count );

	cmp	ecx, r8d
	jl	$LL42@ExterndefD

; 369  : 
; 370  :     return( NOT_ERROR );

	xor	eax, eax
$LN43@ExterndefD:
	mov	r12, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+120]
	mov	rbx, QWORD PTR [rsp+112]

; 371  : }

	add	rsp, 88					; 00000058H
	ret	0
$LN55@ExterndefD:

; 209  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, r11
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbp+8]
	call	EmitErr
	jmp	SHORT $LN43@ExterndefD
$LN57@ExterndefD:

; 215  :             return( EmitError( COLON_EXPECTED ) );

	mov	ecx, 84					; 00000054H
	call	EmitError
	jmp	SHORT $LN43@ExterndefD
$LN58@ExterndefD:

; 234  :             /* dont scan this line further!
; 235  :              * CreateProto() will either define a SYM_EXTERNAL or fail
; 236  :              * if there's a syntax error or symbol redefinition.
; 237  :              */
; 238  :             sym = CreateProto( i + 1, tokenarray, token, langtype );

	mov	r9d, DWORD PTR langtype$[rsp]
	lea	ecx, DWORD PTR [r8+1]
	mov	rdx, rbp
	mov	r8, rsi
	call	CreateProto

; 239  : #if 0 /* global queue is obsolete */
; 240  :             if ( sym && sym->isglobal == FALSE ) {
; 241  :                 sym->isglobal = TRUE;
; 242  :                 QAddItem( &ModuleInfo.g.GlobalQueue, sym );
; 243  :             }
; 244  : #endif
; 245  :             return( sym ? NOT_ERROR : ERROR );

	neg	rax
	sbb	eax, eax
	neg	eax
	dec	eax
	jmp	SHORT $LN43@ExterndefD
$LN59@ExterndefD:

; 248  :                 return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN43@ExterndefD
$LN3@ExterndefD:

; 363  :                     i++;
; 364  :             } else {
; 365  :                 return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	mov	rdx, rcx
	mov	ecx, 39					; 00000027H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbp+24]
	call	EmitErr
	jmp	SHORT $LN43@ExterndefD
ExterndefDirective ENDP
_TEXT	ENDS
END
