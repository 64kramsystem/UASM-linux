; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG5629	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
PUBLIC	LoopDirective
EXTRN	Tokenize:NEAR
EXTRN	RunMacro:NEAR
EXTRN	isspace:NEAR
EXTRN	isalpha:NEAR
EXTRN	EmitError:NEAR
EXTRN	ReleaseMacroData:NEAR
EXTRN	StoreMacro:NEAR
EXTRN	get_curr_srcfile:NEAR
EXTRN	EvalOperand:NEAR
EXTRN	EmitErr:NEAR
EXTRN	LstWriteSrcLine:NEAR
EXTRN	ModuleInfo:BYTE
EXTRN	__chkstk:NEAR
EXTRN	memcpy:NEAR
EXTRN	memset:NEAR
xdata	SEGMENT
$unwind$LoopDirective DD 035125701H
	DD	02bf457H
	DD	02ce444H
	DD	02dd434H
	DD	02ec42dH
	DD	02f7426H
	DD	035641fH
	DD	0343418H
	DD	010c3311H
	DD	050050030H
xdata	ENDS
pdata	SEGMENT
$pdata$LoopDirective DD @imagerel($LN96#)
	DD	@imagerel($LN96#+1952)
	DD	@imagerel($unwind$LoopDirective#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\loop.c
pdata	ENDS
_TEXT	SEGMENT
buffer$ = 0
macinfo$ = 8
tmpmacro$ = 48
opnd$ = 176
arg_loc$ = 352
i$ = 352
is_exitm$ = 360
parmstring$ = 360
tokenarray$ = 360
LoopDirective PROC NEAR

; 26   : {

$LN96:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 384				; 00000180H
	lea	rbp, QWORD PTR [rsp+48]
	mov	QWORD PTR [rbp+368], rbx
	mov	QWORD PTR [rbp+376], rsi
	mov	QWORD PTR [rbp+328], rdi
	mov	QWORD PTR [rbp+320], r12
	mov	QWORD PTR [rbp+312], r13
	movsxd	r12, ecx

; 27   :     int directive = tokenarray[i].tokval;

	mov	rax, r12

; 28   :     int arg_loc;
; 29   :     int len;
; 30   :     //int skipcomma;
; 31   :     char *parmstring;
; 32   :     char *ptr;
; 33   :     struct dsym *macro;
; 34   :     bool is_exitm;
; 35   :     struct expr opnd;
; 36   :     struct macro_info macinfo;
; 37   :     struct dsym tmpmacro;
; 38   : #ifdef DEBUG_OUT
; 39   :     uint_32 count = 0;
; 40   : #endif
; 41   :     /* v2.08: use myalloca() to get space to store the argument */
; 42   :     //char line[MAX_LINE_LEN];
; 43   :     char buffer[4];
; 44   : 
; 45   :     DebugMsg1(("LoopDirective(%s) enter\n", GetResWName( directive, NULL ) ));
; 46   : 
; 47   :     i++; /* skip directive */

	inc	r12d
	mov	QWORD PTR [rbp+304], r14
	shl	rax, 5

; 48   :     if ( ModuleInfo.list == TRUE ) LstWriteSrcLine();

	bt	DWORD PTR ModuleInfo+408, 12
	mov	QWORD PTR [rbp+296], r15
	mov	r13d, DWORD PTR [rax+rdx+16]
	mov	DWORD PTR i$[rbp], r12d
	mov	rbx, rdx
	jae	SHORT $LN61@LoopDirect
	call	LstWriteSrcLine
	mov	r12d, DWORD PTR i$[rbp]
$LN61@LoopDirect:

; 49   : 
; 50   :     switch ( directive ) {

	xor	r15d, r15d
	cmp	r13d, 394				; 0000018aH
	jl	SHORT $LN51@LoopDirect
	cmp	r13d, 395				; 0000018bH
	jle	SHORT $LN87@LoopDirect
	cmp	r13d, 396				; 0000018cH
	je	SHORT $LN57@LoopDirect
$LN51@LoopDirect:

; 73   :     default: /* FOR, FORC, IRP, IRPC */
; 74   :         /* get the formal parameter and the argument list */
; 75   :         /* the format parameter will become a macro parameter, so it can
; 76   :          * be a simple T_ID, but also an instruction or something else.
; 77   :          * v2.02: And it can begin with a '.'!
; 78   :          */
; 79   :         if( tokenarray[i].token == T_FINAL ) {

	movsxd	rax, r12d
	shl	rax, 5
	cmp	BYTE PTR [rax+rbx], r15b
	jne	$LN50@LoopDirect

; 80   :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i-1].tokpos ) );

	mov	rdx, QWORD PTR [rax+rbx-8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN62@LoopDirect
$LN87@LoopDirect:

; 51   :     case T_WHILE:
; 52   :         arg_loc = i;

	mov	r12d, DWORD PTR arg_loc$[rbp]
$LN57@LoopDirect:

; 53   :         /* no break */
; 54   :     case T_REPT:
; 55   :     case T_REPEAT:
; 56   :         /* the expression is "critical", that is, no forward
; 57   :          * referenced symbols may be used here!
; 58   :          */
; 59   :         if ( EvalOperand( &i, tokenarray, Token_Count, &opnd, EXPF_NOUNDEF ) == ERROR ) {

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opnd$[rbp]
	lea	rcx, QWORD PTR i$[rbp]
	mov	rdx, rbx
	mov	BYTE PTR [rsp+32], 2
	call	EvalOperand
	cmp	eax, -1
	jne	$LN56@LoopDirect

; 60   :             opnd.value = 0;
; 61   :             i = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rbp], eax
$LN93@LoopDirect:

; 65   :             opnd.value = 0;

	mov	DWORD PTR opnd$[rbp], r15d
$LN88@LoopDirect:
	mov	rsi, QWORD PTR parmstring$[rbp]
$LN59@LoopDirect:

; 162  :     }
; 163  : 
; 164  :     /* now make a temporary macro */
; 165  :     macro = &tmpmacro;
; 166  :     memset( &tmpmacro, 0, sizeof(tmpmacro) );

	lea	rcx, QWORD PTR tmpmacro$[rbp]
	xor	edx, edx
	mov	r8d, 128				; 00000080H
	call	memset

; 167  :     tmpmacro.sym.name = "";
; 168  :     tmpmacro.e.macroinfo = &macinfo;

	lea	rax, QWORD PTR macinfo$[rbp]
	lea	rdx, OFFSET FLAT:$SG5629
	mov	QWORD PTR tmpmacro$[rbp+104], rax

; 169  :     memset( &macinfo, 0, sizeof(macinfo) );

	xor	eax, eax
	mov	QWORD PTR tmpmacro$[rbp+8], rdx
	mov	QWORD PTR macinfo$[rbp], rax
	mov	QWORD PTR macinfo$[rbp+8], rax
	mov	QWORD PTR macinfo$[rbp+16], rax
	mov	QWORD PTR macinfo$[rbp+24], rax

; 170  :     macinfo.srcfile = get_curr_srcfile();

	call	get_curr_srcfile

; 171  : 
; 172  : #if 0 //DEBUG_OUT
; 173  :     if ( directive ==  T_WHILE )
; 174  :         tmpmacro.sym.name = "<WHILE>";
; 175  :     else if ( directive == T_REPEAT || directive == T_REPT )
; 176  :         tmpmacro.sym.name = "<REPT>";
; 177  :     else if ( directive == T_FORC || directive == T_IRPC )
; 178  :         tmpmacro.sym.name = "<FORC>";
; 179  :     else
; 180  :         tmpmacro.sym.name = "<FOR>";
; 181  : #endif
; 182  : 
; 183  :     DebugMsg1(("LoopDirective(%s): calling StoreMacro\n", GetResWName( directive, NULL )));
; 184  :     if( StoreMacro( macro, i, tokenarray, TRUE ) == ERROR ) {

	mov	edx, DWORD PTR i$[rbp]
	lea	rcx, QWORD PTR tmpmacro$[rbp]
	mov	r9b, 1
	mov	r8, rbx
	mov	DWORD PTR macinfo$[rbp+24], eax
	call	StoreMacro
	cmp	eax, -1
	jne	$LN31@LoopDirect

; 185  :         ReleaseMacroData( macro );

	lea	rcx, QWORD PTR tmpmacro$[rbp]
	call	ReleaseMacroData

; 186  :         return( ERROR );

	mov	eax, -1
	jmp	$LN62@LoopDirect
$LN56@LoopDirect:

; 62   :         } else if ( opnd.kind != EXPR_CONST ) { /* syntax <REPEAT|WHILE 'A'> is valid! */

	cmp	DWORD PTR opnd$[rbp+60], r15d
	je	SHORT $LN54@LoopDirect

; 63   :             DebugMsg(( "LoopDirective(%s): invalid argument type %u\n", GetResWName( directive, NULL ), opnd.kind ));
; 64   :             EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 65   :             opnd.value = 0;

	jmp	$LN93@LoopDirect
$LN54@LoopDirect:

; 66   :         } else if( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, DWORD PTR i$[rbp]
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbx], r15b
	je	$LN88@LoopDirect

; 67   :             EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos );

	mov	rdx, QWORD PTR [rdx+rbx+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 68   :             /* v2.09: don't exit, the macro lines must be read first. */
; 69   :             //return( ERROR );
; 70   :             opnd.value = 0;
; 71   :         }
; 72   :         break;

	jmp	$LN93@LoopDirect
$LN50@LoopDirect:

; 81   :         }
; 82   :         /* v2.02: allow parameter name to begin with a '.' */
; 83   :         //c = *tokenarray[i].string_ptr;
; 84   :         //if( ( is_valid_id_char(c) == FALSE ) || ( isdigit(c) == TRUE ) ) {
; 85   :         if( is_valid_id_first_char( *tokenarray[i].string_ptr ) == FALSE ) {

	mov	rax, QWORD PTR [rax+rbx+8]
	movsx	ecx, BYTE PTR [rax]
	call	isalpha
	movsxd	rcx, DWORD PTR i$[rbp]
	test	eax, eax
	jne	SHORT $LN49@LoopDirect
	mov	rdi, rcx
	shl	rdi, 5
	mov	rax, QWORD PTR [rdi+rbx+8]
	movzx	edx, BYTE PTR [rax]
	cmp	dl, 95					; 0000005fH
	je	SHORT $LN49@LoopDirect
	cmp	dl, 64					; 00000040H
	je	SHORT $LN49@LoopDirect
	cmp	dl, 36					; 00000024H
	je	SHORT $LN49@LoopDirect
	cmp	dl, 63					; 0000003fH
	je	SHORT $LN49@LoopDirect
	cmp	dl, 46					; 0000002eH
	jne	SHORT $LN86@LoopDirect
	test	BYTE PTR ModuleInfo+408, 32		; 00000020H
	jne	SHORT $LN49@LoopDirect
$LN86@LoopDirect:

; 86   :             DebugMsg(( "LoopDirective(FOR/FORC): token %s is not a valid parameter name\n", tokenarray[i].string_ptr ));
; 87   :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdi+rbx+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN62@LoopDirect
$LN49@LoopDirect:

; 88   :         }
; 89   :         arg_loc = i;

	mov	r12d, ecx

; 90   :         i++;

	inc	ecx

; 91   : 
; 92   :         if( directive == T_FORC || directive == T_IRPC ) {

	cmp	r13d, 391				; 00000187H
	mov	DWORD PTR i$[rbp], ecx
	je	$LN47@LoopDirect
	cmp	r13d, 393				; 00000189H
	je	$LN47@LoopDirect

; 123  :             }
; 124  :         } else {
; 125  :             /* for FOR/IRP, skip everything between the name and the comma!
; 126  :              * these items will be stored as (first) macro parameter.
; 127  :              * for example, valid syntax is:
; 128  :              * FOR xxx,<a, ...>
; 129  :              * FOR xxx:REQ,<a, ...>
; 130  :              */
; 131  :             while ( tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA )

	movsxd	rax, ecx
	shl	rax, 5
	movzx	edx, BYTE PTR [rax+rbx]
	test	dl, dl
	je	SHORT $LN36@LoopDirect
$LL37@LoopDirect:
	cmp	dl, 44					; 0000002cH
	je	SHORT $LN36@LoopDirect

; 132  :                 i++;

	inc	ecx
	movsxd	rax, ecx
	mov	DWORD PTR i$[rbp], ecx
	shl	rax, 5
	mov	dl, BYTE PTR [rax+rbx]
	test	dl, dl
	jne	SHORT $LL37@LoopDirect
$LN36@LoopDirect:

; 133  :             if( tokenarray[i].token != T_COMMA ) {

	movsxd	rdx, ecx
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbx], 44			; 0000002cH
	je	SHORT $LN35@LoopDirect
$LN95@LoopDirect:

; 134  :                 return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rbx+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	$LN62@LoopDirect
$LN35@LoopDirect:

; 135  :             }
; 136  :             i++;

	inc	ecx

; 137  :             /* FOR/IRP accepts a literal enclosed in <> only */
; 138  :             if( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rdx, ecx
	mov	DWORD PTR i$[rbp], ecx
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbx], 9
	jne	SHORT $LN33@LoopDirect
	cmp	BYTE PTR [rdx+rbx+1], 60		; 0000003cH
	jne	SHORT $LN33@LoopDirect

; 140  :             }
; 141  :             /* v2.03: also ensure that the literal is the last item */
; 142  :             if( tokenarray[i+1].token != T_FINAL ) {

	cmp	BYTE PTR [rdx+rbx+32], r15b
	je	SHORT $LN32@LoopDirect

; 143  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rbx+56]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN62@LoopDirect
$LN32@LoopDirect:

; 144  :             }
; 145  :             /* v2.08: use myalloca() instead of a fixed-length buffer.
; 146  :              * the loop directives are often nested, they call RunMacro()
; 147  :              * and hence should be careful with stack usage because of JWASMR!
; 148  :              */
; 149  :             //parmstring = myalloca( tokenarray[i].stringlen + 1 );
; 150  :             /* v2.0: use GetLiteralValue() instead of memcpy!!! */
; 151  :             //memcpy( line, tokenarray[i].string_ptr, tokenarray[i].stringlen + 1 );
; 152  :             //GetLiteralValue( parmstring, tokenarray[i].string_ptr );
; 153  :             parmstring = tokenarray[i].string_ptr;

	mov	rsi, QWORD PTR [rdx+rbx+8]
	jmp	$LN41@LoopDirect
$LN33@LoopDirect:

; 139  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rbx+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN62@LoopDirect
$LN47@LoopDirect:

; 93   :             if( tokenarray[i].token != T_COMMA ) {

	movsxd	rdx, ecx
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbx], 44			; 0000002cH

; 94   :                 return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	jne	SHORT $LN95@LoopDirect

; 95   :             }
; 96   :             i++;

	inc	ecx

; 97   :             /* FORC/IRPC accepts anything as "argument list", even nothing! */
; 98   :             if( tokenarray[i].token == T_STRING && tokenarray[i].string_delim == '<' ) {

	movsxd	rdx, ecx
	mov	DWORD PTR i$[rbp], ecx
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbx], 9
	jne	$LN45@LoopDirect
	cmp	BYTE PTR [rdx+rbx+1], 60		; 0000003cH
	jne	$LN45@LoopDirect

; 99   :                 len = tokenarray[i+1].tokpos - (tokenarray[i].tokpos+1);

	mov	edi, DWORD PTR [rdx+rbx+56]
	sub	edi, DWORD PTR [rdx+rbx+24]
	dec	edi

; 100  :                 parmstring = myalloca( len );

	movsxd	r14, edi
	lea	rax, QWORD PTR [r14+15]
	and	rax, -16
	call	__chkstk

; 101  :                 //GetLiteralValue( parmstring, tokenarray[i].string_ptr );
; 102  :                 memcpy( parmstring, tokenarray[i].tokpos+1, len );

	mov	rdx, QWORD PTR [rdx+rbx+24]
	sub	rsp, rax
	lea	rsi, QWORD PTR [rsp+48]
	mov	r8, r14
	inc	rdx
	mov	rcx, rsi
	call	memcpy

; 103  :                 while( *(parmstring+len-1) != '>' ) len--;

	cmp	BYTE PTR [r14+rsi-1], 62		; 0000003eH
	je	SHORT $LN43@LoopDirect

; 99   :                 len = tokenarray[i+1].tokpos - (tokenarray[i].tokpos+1);

	lea	rax, QWORD PTR [r14+rsi-1]
	npad	5
$LL44@LoopDirect:

; 103  :                 while( *(parmstring+len-1) != '>' ) len--;

	dec	rax
	dec	edi
	cmp	BYTE PTR [rax], 62			; 0000003eH
	jne	SHORT $LL44@LoopDirect
$LN43@LoopDirect:

; 104  :                 *(parmstring+len-1) = NULLC;

	movsxd	rax, edi
	mov	BYTE PTR [rax+rsi-1], r15b

; 105  :                 /* v2.02: if there's additional stuff behind the <> literal,
; 106  :                  * it's an error!
; 107  :                  */
; 108  :                 if ( tokenarray[i+1].token != T_FINAL )

	movsxd	rcx, DWORD PTR i$[rbp]
	mov	rdx, rcx
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbx+32], r15b
	je	SHORT $LN41@LoopDirect

; 109  :                     EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].tokpos );

	mov	rdx, QWORD PTR [rdx+rbx+56]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 110  :             } else {

	jmp	SHORT $LN92@LoopDirect
$LN45@LoopDirect:

; 111  :                 char *ptr2;
; 112  :                 ptr = tokenarray[i].tokpos;

	mov	r14, QWORD PTR [rdx+rbx+24]

; 113  :                 ptr2 = ptr;

	mov	rdi, r14

; 114  :                 /* this is what Masm does: use the string until a space
; 115  :                  * is detected. Anything beyond the space is ignored.
; 116  :                  */
; 117  :                 while ( *ptr2 && ( isspace( *ptr2 ) == FALSE ) )

	cmp	BYTE PTR [r14], r15b
	je	SHORT $LN39@LoopDirect
$LL40@LoopDirect:
	movsx	ecx, BYTE PTR [rdi]
	call	isspace
	test	eax, eax
	jne	SHORT $LN39@LoopDirect

; 118  :                     ptr2++;

	inc	rdi
	cmp	BYTE PTR [rdi], r15b
	jne	SHORT $LL40@LoopDirect
$LN39@LoopDirect:

; 119  :                 len = ptr2 - ptr;

	sub	edi, r14d

; 120  :                 parmstring = myalloca( len + 1 );

	lea	eax, DWORD PTR [rdi+1]
	cdqe
	add	rax, 15
	and	rax, -16
	call	__chkstk
	sub	rsp, rax

; 121  :                 memcpy( parmstring, ptr, len );

	movsxd	rdi, edi
	lea	rsi, QWORD PTR [rsp+48]
	mov	r8, rdi
	mov	rdx, r14
	mov	rcx, rsi
	call	memcpy

; 122  :                 *(parmstring+len) = NULLC;

	mov	BYTE PTR [rdi+rsi], r15b
$LN92@LoopDirect:
	mov	ecx, DWORD PTR i$[rbp]
$LN41@LoopDirect:

; 154  :             DebugMsg1(("LoopDirective(FOR): param string >%s<\n", parmstring));
; 155  :         }
; 156  :         /* to run StoreMacro(), tokenarray must be setup correctly. */
; 157  :         /* clear contents beginning with the comma! */
; 158  :         i--;

	dec	ecx
	mov	DWORD PTR i$[rbp], ecx

; 159  :         tokenarray[i].token = T_FINAL;

	movsxd	rax, ecx
	shl	rax, 5
	mov	BYTE PTR [rax+rbx], r15b

; 160  :         Token_Count = i;

	mov	eax, DWORD PTR i$[rbp]

; 161  :         i = arg_loc;

	mov	DWORD PTR i$[rbp], r12d
	mov	DWORD PTR ModuleInfo+496, eax
	jmp	$LN59@LoopDirect
$LN31@LoopDirect:

; 187  :     }
; 188  :     /* EXITM <> is allowed inside a macro loop.
; 189  :      * This doesn't make the loop a macro function, reset the bit!
; 190  :      */
; 191  :     macro->sym.isfunc = FALSE;

	and	BYTE PTR tmpmacro$[rbp+52], 253		; 000000fdH

; 192  : 
; 193  :     /* now run the just created macro in a loop */
; 194  : 
; 195  :     /* don't run the macro if there are no lines (macroinfo->data == NULL)!
; 196  :      * this isn't exactly what Masm does; an empty 'WHILE 1'
; 197  :      * will loop "forever" in Masm,
; 198  :      */
; 199  :     if ( macinfo.data ) /* added in v2.01 */

	cmp	QWORD PTR macinfo$[rbp+16], r15
	je	$LN78@LoopDirect

; 200  :     switch ( directive ) {

	cmp	r13d, 391				; 00000187H
	je	$LN17@LoopDirect
	cmp	r13d, 393				; 00000189H
	je	$LN17@LoopDirect
	jle	$LN7@LoopDirect
	cmp	r13d, 395				; 0000018bH
	jle	$LN27@LoopDirect
	cmp	r13d, 396				; 0000018cH
	jne	$LN7@LoopDirect

; 215  :     case T_WHILE:
; 216  :         while ( opnd.kind == EXPR_CONST && opnd.value != 0 ) {

	cmp	DWORD PTR opnd$[rbp+60], r15d
	jne	$LN78@LoopDirect
$LL21@LoopDirect:
	cmp	DWORD PTR opnd$[rbp], r15d
	je	$LN78@LoopDirect

; 217  :             DebugMsg1(("LoopDirective WHILE: cnt=%u\n", count++ ));
; 218  :             RunMacro( macro, Token_Count, tokenarray, NULL, 0, &is_exitm );

	mov	edx, DWORD PTR ModuleInfo+496
	lea	rax, QWORD PTR is_exitm$[rbp]
	lea	rcx, QWORD PTR tmpmacro$[rbp]
	mov	QWORD PTR [rsp+40], rax
	xor	r9d, r9d
	mov	r8, rbx
	mov	DWORD PTR [rsp+32], r15d
	call	RunMacro

; 219  :             if ( is_exitm )

	cmp	BYTE PTR is_exitm$[rbp], r15b
	jne	$LN78@LoopDirect

; 220  :                 break;
; 221  :             i = arg_loc;
; 222  :             if ( EvalOperand( &i, tokenarray, Token_Count, &opnd, 0 ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opnd$[rbp]
	lea	rcx, QWORD PTR i$[rbp]
	mov	rdx, rbx
	mov	DWORD PTR i$[rbp], r12d
	mov	BYTE PTR [rsp+32], r15b
	call	EvalOperand
	cmp	eax, -1
	je	$LN78@LoopDirect

; 223  :                 break;
; 224  :             macro->sym.value++;

	inc	DWORD PTR tmpmacro$[rbp+16]
	cmp	DWORD PTR opnd$[rbp+60], r15d
	je	SHORT $LL21@LoopDirect

; 225  :         }
; 226  :         break;

	jmp	$LN78@LoopDirect
$LN27@LoopDirect:

; 201  :     case T_REPEAT:
; 202  :     case T_REPT:
; 203  :         /* negative repeat counts are accepted and are treated like 0 */
; 204  :         for ( ; macro->sym.value < opnd.value; macro->sym.value++ ) {

	mov	eax, DWORD PTR opnd$[rbp]
	cmp	DWORD PTR tmpmacro$[rbp+16], eax
	jge	$LN78@LoopDirect
	npad	13
$LL26@LoopDirect:

; 205  :             /* v2.10: Token_Count becomes volatile if MF_NOSAVE is set */
; 206  :             tokenarray[0].token = T_FINAL;
; 207  :             Token_Count = 0;
; 208  :             //RunMacro( macro, Token_Count, tokenarray, NULL, MF_NOSAVE, &is_exitm );
; 209  :             RunMacro( macro, 0, tokenarray, NULL, MF_NOSAVE, &is_exitm );

	lea	rax, QWORD PTR is_exitm$[rbp]
	mov	BYTE PTR [rbx], r15b
	lea	rcx, QWORD PTR tmpmacro$[rbp]
	mov	QWORD PTR [rsp+40], rax
	xor	r9d, r9d
	mov	r8, rbx
	xor	edx, edx
	mov	DWORD PTR ModuleInfo+496, r15d
	mov	DWORD PTR [rsp+32], 2
	call	RunMacro

; 210  :             if ( is_exitm )

	cmp	BYTE PTR is_exitm$[rbp], r15b
	jne	$LN78@LoopDirect
	mov	eax, DWORD PTR tmpmacro$[rbp+16]
	inc	eax
	cmp	eax, DWORD PTR opnd$[rbp]
	mov	DWORD PTR tmpmacro$[rbp+16], eax
	jl	SHORT $LL26@LoopDirect

; 211  :                 break;
; 212  :             DebugMsg1(("LoopDirective REPT: iteration=%" I32_SPEC "u\n", ++count ));
; 213  :         }
; 214  :         break;

	jmp	$LN78@LoopDirect
$LN7@LoopDirect:

; 257  :                 break;
; 258  :             DebugMsg1(("LoopDirective FORC: call RunMacro(), cnt=%" I32_SPEC "u, param=>%s<\n", count++, buffer ));
; 259  :         }
; 260  :         break;
; 261  :     default: /* T_FOR, T_IRP */
; 262  :         i = Token_Count + 1;

	mov	edx, DWORD PTR ModuleInfo+496

; 263  :         Token_Count = Tokenize( parmstring, i, tokenarray, TOK_RESCAN | TOK_NOCURLBRACES );

	mov	r9d, 3
	mov	r8, rbx
	inc	edx
	mov	rcx, rsi
	mov	DWORD PTR i$[rbp], edx
	call	Tokenize
	movsxd	rdi, eax

; 264  :         DebugMsg1(("LoopDirective FOR: full param=>%s<\n", tokenarray[i].tokpos ));
; 265  : 
; 266  :         /* v2.09: if a trailing comma is followed by white space(s), add a blank token */
; 267  :         if ( i != Token_Count && tokenarray[Token_Count-1].token == T_COMMA &&
; 268  :             *(tokenarray[Token_Count-1].tokpos+1) ) {

	mov	eax, DWORD PTR i$[rbp]
	cmp	eax, edi
	mov	DWORD PTR ModuleInfo+496, edi
	je	$LN6@LoopDirect
	mov	rdx, rdi
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbx-32], 44		; 0000002cH
	jne	$LN6@LoopDirect
	mov	rcx, QWORD PTR [rdx+rbx-8]
	cmp	BYTE PTR [rcx+1], r15b
	je	SHORT $LN6@LoopDirect

; 269  :             tokenarray[Token_Count].token = T_STRING;

	mov	BYTE PTR [rdx+rbx], 9

; 270  :             tokenarray[Token_Count].string_delim = NULLC;

	movsxd	rax, DWORD PTR ModuleInfo+496

; 271  :             tokenarray[Token_Count].stringlen = strlen( tokenarray[Token_Count].tokpos );

	mov	rcx, -1
	shl	rax, 5
	mov	BYTE PTR [rax+rbx+1], r15b
	movsxd	rdx, DWORD PTR ModuleInfo+496
	xor	eax, eax
	shl	rdx, 5
	mov	rdi, QWORD PTR [rdx+rbx+24]
	repne scasb
	not	rcx
	dec	rcx
	mov	DWORD PTR [rdx+rbx+16], ecx

; 272  :             tokenarray[Token_Count+1].tokpos = tokenarray[Token_Count].tokpos + tokenarray[Token_Count].stringlen;

	movsxd	rcx, DWORD PTR ModuleInfo+496
	shl	rcx, 5
	mov	eax, DWORD PTR [rcx+rbx+16]
	add	rax, QWORD PTR [rcx+rbx+24]
	mov	QWORD PTR [rcx+rbx+56], rax

; 273  :             Token_Count++;

	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	mov	DWORD PTR ModuleInfo+496, eax

; 274  :             tokenarray[Token_Count].token = T_FINAL;

	cdqe
	shl	rax, 5
	mov	BYTE PTR [rax+rbx], r15b
	mov	eax, DWORD PTR i$[rbp]
	mov	edi, DWORD PTR ModuleInfo+496
$LN6@LoopDirect:

; 275  :         }
; 276  : 
; 277  :         /* a FOR/IRP parameter can be a macro function call */
; 278  :         /* that's why the macro calls must be run synchronously */
; 279  :         /* v2.05: reset an optional VARARG attribute for the macro
; 280  :          * parameter.
; 281  :          * take care of a trailing comma, this is to make another
; 282  :          * RunMacro() call with a "blank" argument.
; 283  :          */
; 284  :         macro->sym.mac_vararg = FALSE;

	and	BYTE PTR tmpmacro$[rbp+52], 254		; 000000feH

; 285  :         /* v2.09: flag MF_IGNARGS introduced. This allows RunMacro() to
; 286  :          * parse the full argument and trigger macro expansion if necessary.
; 287  :          * No need anymore to count commas here. */
; 288  :         for( ; i < Token_Count; i++, macro->sym.value++ ) {

	cmp	eax, edi
	jge	$LN78@LoopDirect
	npad	10
$LL5@LoopDirect:

; 289  :             DebugMsg1(("LoopDirective FOR: cnt=%" I32_SPEC "u, calling RunMacro( param=>%s< )\n", count++, tokenarray[i].tokpos ));
; 290  :             i = RunMacro( macro, i, tokenarray, NULL, MF_IGNARGS, &is_exitm );

	lea	rcx, QWORD PTR is_exitm$[rbp]
	xor	r9d, r9d
	mov	r8, rbx
	mov	QWORD PTR [rsp+40], rcx
	lea	rcx, QWORD PTR tmpmacro$[rbp]
	mov	edx, eax
	mov	DWORD PTR [rsp+32], 4
	call	RunMacro

; 291  :             if ( i < 0 || is_exitm )

	test	eax, eax
	mov	DWORD PTR i$[rbp], eax
	js	$LN78@LoopDirect
	cmp	BYTE PTR is_exitm$[rbp], r15b
	jne	$LN78@LoopDirect
	inc	DWORD PTR tmpmacro$[rbp+16]
	inc	eax
	cmp	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rbp], eax
	jl	SHORT $LL5@LoopDirect

; 256  :             if ( is_exitm )

	jmp	$LN78@LoopDirect
$LN17@LoopDirect:

; 227  :     case T_FORC:
; 228  :     case T_IRPC:
; 229  :         for( ptr = parmstring; *ptr; ptr++, macro->sym.value++ ) {

	cmp	BYTE PTR [rsi], r15b
	je	$LN78@LoopDirect
$LL16@LoopDirect:

; 230  :             tokenarray[0].token = T_STRING;
; 231  :             tokenarray[0].string_delim = NULLC;
; 232  :             tokenarray[0].string_ptr = buffer;

	lea	rax, QWORD PTR buffer$[rbp]
	mov	BYTE PTR [rbx], 9
	mov	BYTE PTR [rbx+1], r15b
	mov	QWORD PTR [rbx+8], rax

; 233  :             tokenarray[0].tokpos = buffer;

	lea	rax, QWORD PTR buffer$[rbp]

; 234  :             tokenarray[1].token = T_FINAL;

	mov	BYTE PTR [rbx+32], r15b
	mov	QWORD PTR [rbx+24], rax

; 235  :             buffer[2] = NULLC;
; 236  :             Token_Count = 1;

	mov	DWORD PTR ModuleInfo+496, 1
	mov	BYTE PTR buffer$[rbp+2], r15b

; 237  :             if ( *ptr == '!' ) {

	movzx	eax, BYTE PTR [rsi]
	cmp	al, 33					; 00000021H
	jne	SHORT $LN13@LoopDirect

; 238  :                 buffer[0] = *ptr++;

	inc	rsi
	mov	BYTE PTR buffer$[rbp], al

; 239  :                 buffer[1] = *ptr;

	movzx	eax, BYTE PTR [rsi]
	mov	BYTE PTR buffer$[rbp+1], al

; 240  :                 if ( *ptr == NULLC ) /* ensure the macro won't go beyond the 00 */

	cmp	BYTE PTR [rsi], r15b
	jne	SHORT $LN12@LoopDirect

; 241  :                     ptr--;

	dec	rsi
$LN12@LoopDirect:

; 242  :                 tokenarray[0].stringlen = 2;

	mov	DWORD PTR [rbx+16], 2

; 243  :                 tokenarray[1].tokpos = buffer+2;

	lea	rax, QWORD PTR buffer$[rbp+2]
	jmp	SHORT $LN94@LoopDirect
$LN13@LoopDirect:

; 244  :             } else if ( isspace( *ptr ) ) {

	movsx	ecx, al
	call	isspace
	test	eax, eax
	je	SHORT $LN10@LoopDirect

; 245  :                 buffer[0] = '!';

	mov	BYTE PTR buffer$[rbp], 33		; 00000021H

; 246  :                 buffer[1] = *ptr;

	movzx	eax, BYTE PTR [rsi]

; 247  :                 tokenarray[0].stringlen = 2;

	mov	DWORD PTR [rbx+16], 2
	mov	BYTE PTR buffer$[rbp+1], al

; 248  :                 tokenarray[1].tokpos = buffer+2;

	lea	rax, QWORD PTR buffer$[rbp+2]

; 249  :             } else {

	jmp	SHORT $LN94@LoopDirect
$LN10@LoopDirect:

; 250  :                 buffer[0] = *ptr;

	movzx	eax, BYTE PTR [rsi]

; 251  :                 tokenarray[0].stringlen = 1;

	mov	DWORD PTR [rbx+16], 1

; 252  :                 tokenarray[1].tokpos = buffer+1;
; 253  :                 buffer[1] = NULLC;

	mov	BYTE PTR buffer$[rbp+1], r15b
	mov	BYTE PTR buffer$[rbp], al
	lea	rax, QWORD PTR buffer$[rbp+1]
$LN94@LoopDirect:
	mov	QWORD PTR [rbx+56], rax

; 254  :             }
; 255  :             RunMacro( macro, 0, tokenarray, NULL, MF_NOSAVE, &is_exitm );

	lea	rax, QWORD PTR is_exitm$[rbp]
	lea	rcx, QWORD PTR tmpmacro$[rbp]
	mov	QWORD PTR [rsp+40], rax
	xor	r9d, r9d
	mov	r8, rbx
	xor	edx, edx
	mov	DWORD PTR [rsp+32], 2
	call	RunMacro

; 256  :             if ( is_exitm )

	cmp	BYTE PTR is_exitm$[rbp], r15b
	jne	SHORT $LN78@LoopDirect
	inc	DWORD PTR tmpmacro$[rbp+16]
	inc	rsi
	cmp	BYTE PTR [rsi], r15b
	jne	$LL16@LoopDirect
$LN78@LoopDirect:

; 292  :                 break;
; 293  :         }
; 294  :     }
; 295  :     ReleaseMacroData( macro );

	lea	rcx, QWORD PTR tmpmacro$[rbp]
	call	ReleaseMacroData

; 296  :     DebugMsg1(("LoopDirective(%s) exit\n", GetResWName( directive, NULL ) ));
; 297  :     return( NOT_ERROR );

	xor	eax, eax
$LN62@LoopDirect:

; 298  : }

	mov	rbx, QWORD PTR [rbp+368]
	mov	rsi, QWORD PTR [rbp+376]
	mov	rdi, QWORD PTR [rbp+328]
	mov	r12, QWORD PTR [rbp+320]
	mov	r13, QWORD PTR [rbp+312]
	mov	r14, QWORD PTR [rbp+304]
	mov	r15, QWORD PTR [rbp+296]
	lea	rsp, QWORD PTR [rbp+336]
	pop	rbp
	ret	0
LoopDirective ENDP
_TEXT	ENDS
END
