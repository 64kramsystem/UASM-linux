; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
mzdata	DW	01eH
	DW	010H
	DW	00H
	DW	0ffffH
szCaption DB	'Binary Map:', 00H
	ORG $+12
szCaption2 DB	'Segment                  Pos(file)     RVA  Size(fil) Si'
	DB	'ze(mem)', 00H
szSep	DB	'--------------------------------------------------------'
	DB	'-------', 00H
szHeader DB	'<header>', 00H
	ORG $+7
szSegLine DB	'%-24s %8X %8X %9X %9X', 00H
	ORG $+2
szTotal	DB	'%-42s %9X %9X', 00H
	ORG $+2
dosseg_order DD	01H
	DD	00H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
flat_order DD	06H
	DD	01H
	DD	07H
	DD	02H
	DD	03H
	DD	09H
	DD	08H
	ORG $+4
hdrattr	DB	'read public ''HDR''', 00H
	ORG $+2
edataname DB	'.edata', 00H
	ORG $+5
edataattr DB	'FLAT read public alias(''.rdata'') ''DATA''', 00H
idataname DB	'.idata$', 00H
idataattr DB	'FLAT read public alias(''.rdata'') ''DATA''', 00H
	ORG $+8
mzcode	DB	'db ''MZ''', 00H, 'dw 80h, 1, 0, 4', 00H, 'dw 0, -1, 0, 0'
	DB	'B8h', 00H, 'dw 0, 0, 0, 40h', 00H, 'org 40h', 00H, 'push cs', 00H
	DB	'pop ds', 00H, 'mov dx,@F - 40h', 00H, 'mov ah,9', 00H, 'int 2'
	DB	'1h', 00H, 'mov ax,4C01h', 00H, 'int 21h', 00H, '@@:', 00H, 'd'
	DB	'b ''This is a PE executable'',0Dh,0Ah,''$''', 00H
	ORG $+12
pe32def	DD	04550H
	DW	014cH
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DW	0e0H
	DW	010fH
	DW	010bH
	DB	05H
	DB	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0400000H
	DD	01000H
	DD	0200H
	DW	04H
	DW	00H
	DW	00H
	DW	00H
	DW	04H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	03H
	DW	00H
	DD	0100000H
	DD	01000H
	DD	0100000H
	DD	01000H
	DD	00H
	DD	010H
	ORG $+128
	ORG $+8
pe64def	DD	04550H
	DW	08664H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DW	0f0H
	DW	012fH
	DW	020bH
	DB	05H
	DB	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DQ	0000000000400000H
	DD	01000H
	DD	0200H
	DW	04H
	DW	00H
	DW	00H
	DW	00H
	DW	04H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	03H
	DW	00H
	DQ	0000000000100000H
	DQ	0000000000001000H
	DQ	0000000000100000H
	DQ	0000000000001000H
	DD	00H
	DD	010H
	ORG $+128
CONST	ENDS
_DATA	SEGMENT
$SG6284	DB	'.hdr$1', 00H
	ORG $+1
$SG6286	DB	'%r DOTNAME', 00H
	ORG $+1
$SG6287	DB	'.hdr$', 00H
	ORG $+6
$SG6288	DB	'%s1 %r USE16 %r %s', 00H
	ORG $+1
$SG6292	DB	'.hdr$', 00H
	ORG $+2
$SG6293	DB	'%s1 %r', 00H
	ORG $+1
$SG6295	DB	'.hdr$1', 00H
	ORG $+1
$SG6306	DB	'.hdr$2', 00H
	ORG $+1
$SG6325	DB	'.hdr$2', 00H
	ORG $+1
$SG6329	DB	'HDR', 00H
$SG6330	DB	'.hdr$2', 00H
	ORG $+1
$SG6338	DB	'@pe_file_flags', 00H
	ORG $+1
$SG6351	DB	'.hdr$3', 00H
	ORG $+1
$SG6354	DB	'HDR', 00H
$SG6355	DB	'.hdr$3', 00H
	ORG $+1
$SG6365	DB	'CONST', 00H
	ORG $+2
$SG6369	DB	'.rsrc', 00H
	ORG $+2
$SG6373	DB	'.reloc', 00H
	ORG $+5
$SG6412	DB	'%r DOTNAME', 00H
	ORG $+5
$SG6413	DB	'%s %r %r %s', 00H
	ORG $+12
$SG6415	DB	'DD 0, 0%xh, 0, %r @%s_name, %u, %u, %u, %r @%s_func, %r '
	DB	'@%s_names, %r @%s_nameord', 00H
	ORG $+6
$SG6423	DB	'@%s_func %r DWORD', 00H
	ORG $+6
$SG6428	DB	'DD %r %s', 00H
	ORG $+7
$SG6429	DB	'@%s_names %r DWORD', 00H
	ORG $+5
$SG6433	DB	'DD %r @%s', 00H
	ORG $+6
$SG6434	DB	'@%s_nameord %r WORD', 00H
$SG6438	DB	'DW %u', 00H
	ORG $+6
$SG6444	DB	'@%s_name DB ''%s'',0', 00H
	ORG $+5
$SG6449	DB	'@%s DB ''%s'',0', 00H
	ORG $+2
$SG6450	DB	'%s %r', 00H
	ORG $+2
$SG6458	DB	'ALIGN(8)', 00H
	ORG $+7
$SG6459	DB	'ALIGN(4)', 00H
	ORG $+7
$SG6467	DB	'@LPPROC %r %r %r', 00H
	ORG $+7
$SG6468	DB	'%r DOTNAME', 00H
	ORG $+5
$SG6470	DB	'%s2 %r %r %s', 00H
	ORG $+3
$SG6471	DB	'DD %r @%s_ilt, 0, 0, %r @%s_name, %r @%s_iat', 00H
	ORG $+3
$SG6472	DB	'%s2 %r', 00H
	ORG $+1
$SG6473	DB	'%s4 %r %s %s', 00H
	ORG $+3
$SG6474	DB	'@%s_ilt label %r', 00H
	ORG $+7
$SG6480	DB	'@LPPROC %r @%s_name', 00H
	ORG $+4
$SG6481	DB	'@LPPROC 0', 00H
	ORG $+2
$SG6482	DB	'%s4 %r', 00H
	ORG $+5
$SG6483	DB	'%s5 %r %s %s', 00H
	ORG $+3
$SG6484	DB	'@%s_iat label %r', 00H
	ORG $+7
$SG6490	DB	'%s%s @LPPROC %r @%s_name', 00H
	ORG $+7
$SG6491	DB	'@LPPROC 0', 00H
	ORG $+2
$SG6492	DB	'%s5 %r', 00H
	ORG $+5
$SG6493	DB	'%s6 %r %r %s', 00H
	ORG $+3
$SG6499	DB	'@%s_name dw 0', 00H
	ORG $+2
$SG6500	DB	'db ''%s'',0', 00H
	ORG $+2
$SG6501	DB	'even', 00H
	ORG $+7
$SG6503	DB	'@%s_%s_name db ''%s.%s'',0', 00H
	ORG $+7
$SG6505	DB	'@%s_name db ''%s'',0', 00H
	ORG $+1
$SG6506	DB	'even', 00H
	ORG $+3
$SG6507	DB	'%s6 %r', 00H
	ORG $+5
$SG6509	DB	'%s3 %r %r %s', 00H
	ORG $+3
$SG6510	DB	'DD 0, 0, 0, 0, 0', 00H
	ORG $+3
$SG6511	DB	'%s3 %r', 00H
	ORG $+1
$SG6534	DB	'CONST', 00H
	ORG $+2
$SG6623	DB	'.hdr$1', 00H
	ORG $+1
$SG6625	DB	'.hdr$2', 00H
	ORG $+1
$SG6627	DB	'.hdr$3', 00H
	ORG $+1
$SG6634	DB	'RELOC', 00H
	ORG $+2
$SG6635	DB	'.reloc', 00H
	ORG $+5
$SG6690	DB	'.idata$2', 00H
	ORG $+7
$SG6695	DB	'.idata$3', 00H
	ORG $+7
$SG6697	DB	'.idata$5', 00H
	ORG $+3
$SG6700	DB	'.rsrc', 00H
	ORG $+2
$SG6703	DB	'.reloc', 00H
	ORG $+1
$SG6706	DB	'.tls', 00H
	ORG $+3
$SG6710	DB	'.pdata', 00H
	ORG $+1
$SG6827	DB	' ', 00H
_DATA	ENDS
EXTRN	EmitWarn:NEAR
EXTRN	strchr:NEAR
EXTRN	ModuleInfo:BYTE
xdata	SEGMENT
$unwind$CalcOffset DD 050e01H
	DD	09740eH
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$CalcOffset DD @imagerel(CalcOffset#)
	DD	@imagerel(CalcOffset#+69)
	DD	@imagerel($unwind$CalcOffset#)
pdata	ENDS
xdata	SEGMENT
$chain$3$CalcOffset DD 042c21H
	DD	07542cH
	DD	086405H
	DD	@imagerel(CalcOffset#)
	DD	@imagerel(CalcOffset#+69)
	DD	@imagerel($unwind$CalcOffset#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$CalcOffset DD @imagerel(CalcOffset#+69)
	DD	@imagerel(CalcOffset#+382)
	DD	@imagerel($chain$3$CalcOffset#)
pdata	ENDS
xdata	SEGMENT
$chain$4$CalcOffset DD 021H
	DD	@imagerel(CalcOffset#)
	DD	@imagerel(CalcOffset#+69)
	DD	@imagerel($unwind$CalcOffset#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$CalcOffset DD @imagerel(CalcOffset#+382)
	DD	@imagerel(CalcOffset#+397)
	DD	@imagerel($chain$4$CalcOffset#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\bin.c
pdata	ENDS
_TEXT	SEGMENT
curr$ = 48
cp$ = 56
CalcOffset PROC NEAR

; 211  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx

; 212  :     uint_32 align;
; 213  :     uint_32 alignbytes;
; 214  :     uint_32 offset;
; 215  :     struct dsym *grp;
; 216  : 
; 217  :     if ( curr->e.seginfo->segtype == SEGTYPE_ABS ) {

	mov	rcx, QWORD PTR [rcx+104]
	mov	rbx, rdx
	cmp	DWORD PTR [rcx+72], 5
	jne	SHORT $LN22@CalcOffset

; 218  :         curr->e.seginfo->start_offset = curr->e.seginfo->abs_frame << 4;

	movzx	eax, WORD PTR [rcx+88]
	shl	eax, 4
	mov	DWORD PTR [rcx+12], eax
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+48]

; 314  :     return;
; 315  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN22@CalcOffset:

; 219  :         DebugMsg(("CalcOffset(%s): abs seg, offset=%" I32_SPEC "Xh\n",
; 220  :                   curr->sym.name, curr->e.seginfo->start_offset ));
; 221  :         return;
; 222  :     } else if ( curr->e.seginfo->info )

	test	BYTE PTR [rcx+107], 2
	jne	$LN23@CalcOffset

; 223  :         return;
; 224  : 
; 225  :     grp = (struct dsym *)curr->e.seginfo->group;
; 226  :     if ( cp->alignment > curr->e.seginfo->alignment )

	movzx	edx, BYTE PTR [rdx+1]
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, QWORD PTR [rcx]
	cmp	dl, BYTE PTR [rcx+106]
	jbe	SHORT $LN19@CalcOffset

; 227  :         align = 1 << cp->alignment;

	movzx	ecx, dl
	mov	edx, 1
	shl	edx, cl

; 228  :     else

	jmp	SHORT $LN18@CalcOffset
$LN19@CalcOffset:

; 229  :         align = 1 << curr->e.seginfo->alignment;

	movzx	ecx, BYTE PTR [rcx+106]
	mov	edx, 1
	shl	edx, cl
$LN18@CalcOffset:

; 230  :     //alignbytes = ((offset + (align - 1)) & (-align)) - offset;
; 231  :     alignbytes = ((cp->fileoffset + (align - 1)) & (-align)) - cp->fileoffset;

	mov	eax, DWORD PTR [rbx+4]
	mov	QWORD PTR [rsp+56], rbp
	lea	ecx, DWORD PTR [rax+rdx-1]
	neg	edx
	and	ecx, edx
	sub	ecx, eax

; 232  :     cp->fileoffset += alignbytes;

	add	DWORD PTR [rbx+4], ecx

; 233  : 
; 234  :     if ( grp == NULL ) {

	test	rsi, rsi
	mov	ebp, DWORD PTR [rbx+4]
	jne	SHORT $LN17@CalcOffset

; 235  :         offset = cp->fileoffset - cp->sizehdr;  // + alignbytes;

	sub	ebp, DWORD PTR [rbx+8]

; 236  :         DebugMsg(("CalcOffset(%s): fileofs=%" I32_SPEC "Xh, ofs=%" I32_SPEC "Xh\n", curr->sym.name, cp->fileoffset, offset ));
; 237  :     } else {

	jmp	SHORT $LN12@CalcOffset
$LN17@CalcOffset:

; 238  : #if PE_SUPPORT
; 239  :         if ( ModuleInfo.sub_format == SFORMAT_PE )

	cmp	DWORD PTR ModuleInfo+372, 2
	jne	SHORT $LN15@CalcOffset

; 240  :             offset = cp->rva;

	mov	ebp, DWORD PTR [rbx+28]

; 241  :         else

	jmp	SHORT $LN12@CalcOffset
$LN15@CalcOffset:

; 242  : #endif
; 243  :             if ( grp->sym.total_size == 0 ) {

	mov	eax, DWORD PTR [rsi+64]
	test	eax, eax
	jne	SHORT $LN13@CalcOffset

; 244  :                 grp->sym.offset = cp->fileoffset - cp->sizehdr;

	sub	ebp, DWORD PTR [rbx+8]
	mov	DWORD PTR [rsi+16], ebp

; 245  :                 offset = 0;

	xor	ebp, ebp

; 246  :             } else

	jmp	SHORT $LN12@CalcOffset
$LN13@CalcOffset:

; 247  :                 offset = grp->sym.total_size + alignbytes;

	lea	ebp, DWORD PTR [rax+rcx]
$LN12@CalcOffset:

; 248  :         DebugMsg(("CalcOffset(%s): fileofs=%" I32_SPEC "Xh, alignbytes=%" I32_SPEC "u, ofs=%" I32_SPEC "Xh, group=%s, grp.ofs=%" I32_SPEC "Xh\n",
; 249  :                   curr->sym.name, cp->fileoffset, alignbytes, offset, grp->sym.name, grp->sym.offset ));
; 250  :     }
; 251  : 
; 252  :     /* v2.04: added */
; 253  :     /* v2.05: this addition did mess sample Win32_5.asm, because the
; 254  :      * "empty" alignment sections are now added to <fileoffset>.
; 255  :      * todo: VA in binary map is displayed wrong.
; 256  :      */
; 257  :     if ( cp->first == FALSE ) {

	cmp	BYTE PTR [rbx], 0
	jne	SHORT $LN10@CalcOffset

; 258  :         /* v2.05: do the reset more carefully.
; 259  :          * Do reset start_loc only if
; 260  :          * - segment is in a group and
; 261  :          * - group isn't FLAT or segment's name contains '$'
; 262  :          */
; 263  :         if ( grp && ( grp != ModuleInfo.flat_grp ||
; 264  :                      strchr( curr->sym.name, '$' ) ) )

	test	rsi, rsi
	je	SHORT $LN10@CalcOffset
	cmp	rsi, QWORD PTR ModuleInfo+440
	jne	SHORT $LN9@CalcOffset
	mov	rcx, QWORD PTR [rdi+8]
	mov	edx, 36					; 00000024H
	call	strchr
	test	rax, rax
	je	SHORT $LN10@CalcOffset
$LN9@CalcOffset:

; 265  :             curr->e.seginfo->start_loc = 0;

	mov	rax, QWORD PTR [rdi+104]
	mov	DWORD PTR [rax+8], 0
$LN10@CalcOffset:

; 266  :     }
; 267  : 
; 268  :     curr->e.seginfo->fileoffset = cp->fileoffset;

	mov	eax, DWORD PTR [rbx+4]
	mov	rcx, QWORD PTR [rdi+104]
	mov	DWORD PTR [rcx+56], eax

; 269  :     curr->e.seginfo->start_offset = offset;

	mov	rax, QWORD PTR [rdi+104]
	mov	DWORD PTR [rax+12], ebp

; 270  : 
; 271  :     //if ( cp->first && ModuleInfo.sub_format == SFORMAT_NONE ) {
; 272  :     if ( ModuleInfo.sub_format == SFORMAT_NONE ) {

	cmp	DWORD PTR ModuleInfo+372, 0
	jne	SHORT $LN8@CalcOffset

; 273  :         cp->fileoffset += curr->sym.max_offset - curr->e.seginfo->start_loc;

	mov	rax, QWORD PTR [rdi+104]
	mov	ecx, DWORD PTR [rdi+64]
	sub	ecx, DWORD PTR [rax+8]
	add	DWORD PTR [rbx+4], ecx

; 274  :         if ( cp->first )

	cmp	BYTE PTR [rbx], 0
	je	SHORT $LN7@CalcOffset

; 275  :             cp->imagestart = curr->e.seginfo->start_loc;

	mov	rax, QWORD PTR [rdi+104]
	mov	ecx, DWORD PTR [rax+8]
	mov	DWORD PTR [rbx+24], ecx
$LN7@CalcOffset:

; 276  :         /* there's no real entry address for BIN, therefore the
; 277  :          start label must be at the very beginning of the file */
; 278  :         if ( cp->entryoffset == -1 ) {

	cmp	DWORD PTR [rbx+12], -1			; ffffffffH
	jne	SHORT $LN3@CalcOffset

; 279  :             cp->entryoffset = offset;

	mov	DWORD PTR [rbx+12], ebp

; 280  :             cp->entryseg = (struct asym *)curr;

	mov	QWORD PTR [rbx+16], rdi

; 281  :         }
; 282  :     } else {

	jmp	SHORT $LN3@CalcOffset
$LN8@CalcOffset:

; 283  :         /* v2.05: changed, removed */
; 284  :         //curr->e.seginfo->fileoffset += curr->e.seginfo->start_loc;
; 285  :         //fileoffset += curr->sym.max_offset;
; 286  : #if PE_SUPPORT
; 287  :         cp->rva += curr->sym.max_offset - curr->e.seginfo->start_loc;

	mov	rax, QWORD PTR [rdi+104]
	mov	ecx, DWORD PTR [rdi+64]
	sub	ecx, DWORD PTR [rax+8]
	add	DWORD PTR [rbx+28], ecx

; 288  :         if ( curr->e.seginfo->segtype == SEGTYPE_BSS )

	mov	rax, QWORD PTR [rdi+104]
	cmp	DWORD PTR [rax+72], 3
	je	SHORT $LN3@CalcOffset

; 289  :             ;
; 290  :         else
; 291  : #endif
; 292  :         cp->fileoffset += curr->sym.max_offset - curr->e.seginfo->start_loc;

	mov	ecx, DWORD PTR [rdi+64]
	sub	ecx, DWORD PTR [rax+8]
	add	DWORD PTR [rbx+4], ecx
$LN3@CalcOffset:

; 293  :     }
; 294  : 
; 295  :     //offset += curr->sym.max_offset - curr->e.seginfo->start_loc;
; 296  :     offset += curr->sym.max_offset;
; 297  :     if ( grp ) {

	test	rsi, rsi
	je	SHORT $LN1@CalcOffset
	mov	ecx, DWORD PTR [rdi+64]
	add	ecx, ebp

; 298  :         //grp->sym.total_size = offset + curr->e.seginfo->start_loc;
; 299  :         grp->sym.total_size = offset;
; 300  :         /* v2.07: for 16-bit groups, ensure that it fits in 64 kB */
; 301  :         if ( grp->sym.total_size > 0x10000 && grp->sym.Ofssize == USE16 ) {

	cmp	ecx, 65536				; 00010000H
	mov	DWORD PTR [rsi+64], ecx
	jbe	SHORT $LN1@CalcOffset
	cmp	BYTE PTR [rsi+52], 0
	jne	SHORT $LN1@CalcOffset

; 302  :             EmitWarn( 2, GROUP_EXCEEDS_64K, grp->sym.name );

	mov	r8, QWORD PTR [rsi+8]
	mov	edx, 276				; 00000114H
	mov	ecx, 2
	call	EmitWarn
$LN1@CalcOffset:
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]

; 303  :         }
; 304  :     }
; 305  : #if PE_SUPPORT
; 306  :     DebugMsg(("CalcOffset(%s) exit: seg.fileofs=%" I32_SPEC "Xh, seg.start_offset=%" I32_SPEC "Xh, endofs=%" I32_SPEC "Xh fileofs=%" I32_SPEC "Xh rva=%" I32_SPEC "Xh\n",
; 307  :               curr->sym.name, curr->e.seginfo->fileoffset, curr->e.seginfo->start_offset, offset, cp->fileoffset, cp->rva ));
; 308  : #else
; 309  :     DebugMsg(("CalcOffset(%s) exit: seg.fileofs=%" I32_SPEC "Xh, seg.start_offset=%" I32_SPEC "Xh, endofs=%" I32_SPEC "Xh fileofs=%" I32_SPEC "Xh\n",
; 310  :               curr->sym.name, curr->e.seginfo->fileoffset, curr->e.seginfo->start_offset, offset, cp->fileoffset ));
; 311  : #endif
; 312  : 
; 313  :     cp->first = FALSE;

	mov	BYTE PTR [rbx], 0
$LN23@CalcOffset:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+48]

; 314  :     return;
; 315  : }

	add	rsp, 40					; 00000028H
	ret	0
CalcOffset ENDP
_TEXT	ENDS
EXTRN	SymTables:BYTE
xdata	SEGMENT
$unwind$1$GetSegRelocs DD 041101H
	DD	047411H
	DD	036405H
xdata	ENDS
pdata	SEGMENT
$pdata$1$GetSegRelocs DD @imagerel(GetSegRelocs#)
	DD	@imagerel(GetSegRelocs#+31)
	DD	@imagerel($unwind$1$GetSegRelocs#)
pdata	ENDS
xdata	SEGMENT
$chain$2$GetSegRelocs DD 020521H
	DD	023405H
	DD	@imagerel(GetSegRelocs#)
	DD	@imagerel(GetSegRelocs#+31)
	DD	@imagerel($unwind$1$GetSegRelocs#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$GetSegRelocs DD @imagerel(GetSegRelocs#+31)
	DD	@imagerel(GetSegRelocs#+293)
	DD	@imagerel($chain$2$GetSegRelocs#)
pdata	ENDS
xdata	SEGMENT
$chain$3$GetSegRelocs DD 021H
	DD	@imagerel(GetSegRelocs#)
	DD	@imagerel(GetSegRelocs#+31)
	DD	@imagerel($unwind$1$GetSegRelocs#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$GetSegRelocs DD @imagerel(GetSegRelocs#+293)
	DD	@imagerel(GetSegRelocs#+306)
	DD	@imagerel($chain$3$GetSegRelocs#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pDst$ = 8
GetSegRelocs PROC NEAR

; 326  : {

	mov	QWORD PTR [rsp+24], rsi

; 327  :     struct dsym *curr;
; 328  :     int count = 0;
; 329  :     uint_16 valueofs;
; 330  :     uint_16 valueseg;
; 331  :     uint_32 loc;
; 332  :     struct fixup *fixup;
; 333  : 
; 334  :     DebugMsg(("GetSegRelocs( %p ) enter\n", pDst ));
; 335  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rsi, QWORD PTR SymTables+32
	mov	QWORD PTR [rsp+32], rdi
	xor	edi, edi
	test	rsi, rsi
	mov	r9, rcx
	je	$LN27@GetSegRelo
	mov	QWORD PTR [rsp+16], rbx
	npad	12
$LL18@GetSegRelo:

; 336  :         if ( curr->e.seginfo->segtype == SEGTYPE_ABS )

	mov	r10, QWORD PTR [rsi+104]
	cmp	DWORD PTR [r10+72], 5
	je	$LN17@GetSegRelo

; 337  :             continue;
; 338  :         for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	r10, QWORD PTR [r10+40]
	test	r10, r10
	je	$LN17@GetSegRelo
	npad	4
$LL14@GetSegRelo:

; 339  :             switch ( fixup->type ) {

	mov	r11d, DWORD PTR [r10+24]
	lea	eax, DWORD PTR [r11-8]
	cmp	eax, 2
	ja	$LN13@GetSegRelo

; 340  :             case FIX_PTR32:
; 341  :             case FIX_PTR16:
; 342  :             case FIX_SEG:
; 343  :                 /* ignore fixups for absolute segments */
; 344  :                 if ( fixup->sym && fixup->sym->segment && ((struct dsym *)fixup->sym->segment)->e.seginfo->segtype == SEGTYPE_ABS )

	mov	rax, QWORD PTR [r10+56]
	test	rax, rax
	je	SHORT $LN8@GetSegRelo
	mov	rax, QWORD PTR [rax+32]
	test	rax, rax
	je	SHORT $LN8@GetSegRelo
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+72], 5
	je	$LN13@GetSegRelo
$LN8@GetSegRelo:

; 345  :                     break;
; 346  :                 DebugMsg(("GetSegRelocs: found seg-related fixup at %s.%" I32_SPEC "X\n", curr->sym.name, fixup->locofs ));
; 347  :                 count++;

	inc	edi

; 348  :                 if ( pDst ) {

	test	r9, r9
	je	$LN13@GetSegRelo

; 349  :                     /* v2.04: fixed */
; 350  :                     loc = fixup->locofs + ( curr->e.seginfo->start_offset & 0xf );

	mov	rax, QWORD PTR [rsi+104]
	mov	ebx, DWORD PTR [rax+12]
	mov	r8d, ebx

; 351  :                     valueseg = curr->e.seginfo->start_offset >> 4;

	shr	ebx, 4
	and	r8d, 15
	add	r8d, DWORD PTR [r10+20]

; 352  :                     if ( curr->e.seginfo->group ) {

	cmp	QWORD PTR [rax], 0
	je	SHORT $LN6@GetSegRelo

; 353  :                         loc += curr->e.seginfo->group->offset & 0xf;

	mov	rcx, QWORD PTR [rax]
	mov	edx, DWORD PTR [rcx+16]
	mov	eax, edx

; 354  :                         valueseg += curr->e.seginfo->group->offset >> 4;

	sar	edx, 4
	and	eax, 15
	add	r8d, eax
	add	bx, dx
$LN6@GetSegRelo:

; 355  :                     }
; 356  :                     if ( fixup->type == FIX_PTR16 )

	cmp	r11d, 9
	jne	SHORT $LN5@GetSegRelo

; 357  :                         loc += 2;

	add	r8d, 2
	jmp	SHORT $LN23@GetSegRelo
$LN5@GetSegRelo:

; 358  :                     else if ( fixup->type == FIX_PTR32 )

	cmp	r11d, 10
	jne	SHORT $LN23@GetSegRelo

; 359  :                         loc += 4;

	add	r8d, 4
$LN23@GetSegRelo:

; 360  : 
; 361  :                     /* offset may be > 64 kB */
; 362  :                     while ( loc >= 0x10000 ) {

	cmp	r8d, 65536				; 00010000H
	jb	SHORT $LN1@GetSegRelo
	lea	ecx, DWORD PTR [r8-65520]
	shr	rcx, 4
	add	bx, cx
	npad	8
$LL2@GetSegRelo:

; 363  :                         loc -= 16;

	add	r8d, -16				; fffffff0H
	dec	rcx
	jne	SHORT $LL2@GetSegRelo
$LN1@GetSegRelo:

; 364  :                         valueseg++;
; 365  :                     };
; 366  : 
; 367  :                     valueofs = loc;
; 368  :                     DebugMsg(("GetSegRelocs: locofs=%" I32_SPEC "X fileofs=%" I32_SPEC "X segofs=%" I32_SPEC "X grpofs=%" I32_SPEC "X, fixup value: %X %X\n",
; 369  :                               fixup->locofs, curr->e.seginfo->fileoffset, curr->e.seginfo->start_offset, curr->e.seginfo->group ? curr->e.seginfo->group->offset: 0, valueofs, valueseg ));
; 370  :                     *pDst++ = valueofs;

	mov	WORD PTR [r9], r8w

; 371  :                     *pDst++ = valueseg;

	mov	WORD PTR [r9+2], bx
	add	r9, 4
$LN13@GetSegRelo:
	mov	r10, QWORD PTR [r10+8]
	test	r10, r10
	jne	$LL14@GetSegRelo
$LN17@GetSegRelo:

; 327  :     struct dsym *curr;
; 328  :     int count = 0;
; 329  :     uint_16 valueofs;
; 330  :     uint_16 valueseg;
; 331  :     uint_32 loc;
; 332  :     struct fixup *fixup;
; 333  : 
; 334  :     DebugMsg(("GetSegRelocs( %p ) enter\n", pDst ));
; 335  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rsi, QWORD PTR [rsi+112]
	test	rsi, rsi
	jne	$LL18@GetSegRelo
	mov	rbx, QWORD PTR [rsp+16]
$LN27@GetSegRelo:
	mov	rsi, QWORD PTR [rsp+24]

; 372  :                 }
; 373  :                 break;
; 374  :             }
; 375  :         }
; 376  :     }
; 377  :     DebugMsg(("GetSegRelocs()=%u\n", count ));
; 378  :     return( count );

	mov	eax, edi
	mov	rdi, QWORD PTR [rsp+32]

; 379  : }

	ret	0
GetSegRelocs ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$GetImageSize DD 010201H
	DD	03002H
xdata	ENDS
pdata	SEGMENT
$pdata$GetImageSize DD @imagerel(GetImageSize#)
	DD	@imagerel(GetImageSize#+137)
	DD	@imagerel($unwind$GetImageSize#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
memimage$ = 16
GetImageSize PROC NEAR

; 390  : {

	push	rbx

; 391  :     struct dsym *curr;
; 392  :     bool first;
; 393  :     uint_32 vsize = 0;
; 394  :     uint_32 size = 0;
; 395  : 
; 396  :     for( curr = SymTables[TAB_SEG].head, first = TRUE; curr; curr = curr->next ) {

	mov	rdx, QWORD PTR SymTables+32
	xor	r10d, r10d
	movzx	r11d, cl
	test	rdx, rdx
	mov	r9d, r10d
	mov	bl, 1
	je	SHORT $LN27@GetImageSi
	npad	6
$LL15@GetImageSi:

; 397  :         uint_32 tmp;
; 398  :         if ( curr->e.seginfo->segtype == SEGTYPE_ABS || curr->e.seginfo->info )

	mov	r8, QWORD PTR [rdx+104]
	cmp	DWORD PTR [r8+72], 5
	je	SHORT $LN14@GetImageSi
	test	BYTE PTR [r8+107], 2
	jne	SHORT $LN14@GetImageSi

; 399  :             continue;
; 400  :         if ( memimage == FALSE ) {

	test	r11b, r11b
	jne	SHORT $LN20@GetImageSi

; 401  :             if ( curr->e.seginfo->bytes_written == 0 ) {

	cmp	DWORD PTR [r8+24], 0
	jne	SHORT $LN20@GetImageSi

; 402  :                 struct dsym *dir;
; 403  :                 for ( dir = curr->next; dir; dir = dir->next )

	mov	rcx, QWORD PTR [rdx+112]
$LN29@GetImageSi:
	test	rcx, rcx
	je	SHORT $LN27@GetImageSi

; 404  :                     if ( dir->e.seginfo->bytes_written )

	mov	rax, QWORD PTR [rcx+104]
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN20@GetImageSi

; 402  :                 struct dsym *dir;
; 403  :                 for ( dir = curr->next; dir; dir = dir->next )

	mov	rcx, QWORD PTR [rcx+112]
	jmp	SHORT $LN29@GetImageSi
$LN20@GetImageSi:

; 405  :                         break;
; 406  :                 if ( !dir )
; 407  :                     break; /* done, skip rest of segments! */
; 408  :             }
; 409  :         }
; 410  :         tmp = curr->e.seginfo->fileoffset + (curr->sym.max_offset - curr->e.seginfo->start_loc );

	mov	ecx, DWORD PTR [r8+56]
	sub	ecx, DWORD PTR [r8+8]
	add	ecx, DWORD PTR [rdx+64]

; 411  :         if ( first == FALSE )

	test	bl, bl
	jne	SHORT $LN3@GetImageSi

; 412  :             vsize += curr->e.seginfo->start_loc;

	add	r10d, DWORD PTR [r8+8]
$LN3@GetImageSi:

; 413  :         if ( memimage )

	test	r11b, r11b
	je	SHORT $LN2@GetImageSi

; 414  :             tmp += vsize;

	add	ecx, r10d
$LN2@GetImageSi:

; 415  :         DebugMsg(("GetImageSize(%s): fileofs=%" I32_SPEC "Xh, max_offs=%" I32_SPEC "Xh start=%" I32_SPEC "Xh\n",
; 416  :                   curr->sym.name, curr->e.seginfo->fileoffset, curr->sym.max_offset, curr->e.seginfo->start_loc ));
; 417  :         if ( size < tmp )

	cmp	r9d, ecx
	cmovb	r9d, ecx

; 418  :             size = tmp;
; 419  :         first = FALSE;

	xor	bl, bl
$LN14@GetImageSi:
	mov	rdx, QWORD PTR [rdx+112]
	test	rdx, rdx
	jne	SHORT $LL15@GetImageSi
$LN27@GetImageSi:

; 420  :     }
; 421  :     DebugMsg(("GetImageSize(%u)=%" I32_SPEC "Xh\n", memimage, size ));
; 422  :     return( size );

	mov	eax, r9d

; 423  : }

	pop	rbx
	ret	0
GetImageSize ENDP
_TEXT	ENDS
EXTRN	EmitErr:NEAR
EXTRN	__ImageBase:BYTE
EXTRN	memcmp:NEAR
xdata	SEGMENT
$unwind$DoFixup DD 051801H
	DD	07f418H
	DD	0115410H
	DD	0c20cH
xdata	ENDS
pdata	SEGMENT
$pdata$DoFixup DD @imagerel(DoFixup#)
	DD	@imagerel(DoFixup#+50)
	DD	@imagerel($unwind$DoFixup#)
pdata	ENDS
xdata	SEGMENT
$chain$7$DoFixup DD 0c1f21H
	DD	08e41fH
	DD	09d414H
	DD	0ac410H
	DD	0b740cH
	DD	0c6408H
	DD	0103404H
	DD	@imagerel(DoFixup#)
	DD	@imagerel(DoFixup#+50)
	DD	@imagerel($unwind$DoFixup#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$DoFixup DD @imagerel(DoFixup#+50)
	DD	@imagerel(DoFixup#+1212)
	DD	@imagerel($chain$7$DoFixup#)
pdata	ENDS
xdata	SEGMENT
$chain$8$DoFixup DD 021H
	DD	@imagerel(DoFixup#)
	DD	@imagerel(DoFixup#+50)
	DD	@imagerel($unwind$DoFixup#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$DoFixup DD @imagerel(DoFixup#+1212)
	DD	@imagerel(DoFixup#+1232)
	DD	@imagerel($chain$8$DoFixup#)
pdata	ENDS
xdata	SEGMENT
$chain$9$DoFixup DD 0c0021H
	DD	08e400H
	DD	09d400H
	DD	0ac400H
	DD	0b7400H
	DD	0c6400H
	DD	0103400H
	DD	@imagerel(DoFixup#)
	DD	@imagerel(DoFixup#+50)
	DD	@imagerel($unwind$DoFixup#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$DoFixup DD @imagerel(DoFixup#+1232)
	DD	@imagerel(DoFixup#+1284)
	DD	@imagerel($chain$9$DoFixup#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
value64$ = 112
curr$ = 112
cp$ = 120
DoFixup	PROC NEAR

; 441  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	rax, rsp
	sub	rsp, 104				; 00000068H
	mov	QWORD PTR [rax+32], rbp

; 442  :     union genptr codeptr;
; 443  :     struct dsym *seg;
; 444  :     uint_32 value;
; 445  : #if PE_SUPPORT && AMD64_SUPPORT
; 446  :     uint_64 value64;
; 447  : #endif
; 448  :     uint_32 offset;  /* v2.07 */
; 449  :     struct fixup *fixup;
; 450  :     char *tmp;
; 451  : 
; 452  :     if ( curr->e.seginfo->segtype == SEGTYPE_ABS )

	mov	rbp, QWORD PTR [rcx+104]
	mov	QWORD PTR [rax-48], r15
	cmp	DWORD PTR [rbp+72], 5
	mov	r15, rcx

; 453  :         return( NOT_ERROR );

	je	$LN56@DoFixup

; 454  : 
; 455  :     DebugMsg(("DoFixup(%s) enter, segment start ofs=%" I32_SPEC "Xh\n", curr->sym.name, curr->e.seginfo->start_offset ));
; 456  :     for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rbp, QWORD PTR [rbp+40]
	test	rbp, rbp
	je	$LN56@DoFixup
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax-8], rsi
	mov	QWORD PTR [rax-16], rdi
	mov	QWORD PTR [rax-24], r12
	mov	QWORD PTR [rax-32], r13
	lea	r9, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [rax-40], r14
$LL58@DoFixup:

; 457  :         codeptr.db = curr->e.seginfo->CodeBuffer +
; 458  :             ( fixup->locofs - curr->e.seginfo->start_loc );

	mov	rcx, QWORD PTR [r15+104]
	mov	ebx, DWORD PTR [rbp+20]

; 459  : 
; 460  :         //if ( fixup->sym && fixup->sym->segment ) { /* v2.08: changed */
; 461  :         if ( fixup->sym && ( fixup->sym->segment || fixup->sym->variable ) ) {

	mov	rax, QWORD PTR [rbp+56]
	sub	ebx, DWORD PTR [rcx+8]
	add	rbx, QWORD PTR [rcx+16]
	test	rax, rax
	je	$LN55@DoFixup
	mov	r12, QWORD PTR [rax+32]
	test	r12, r12
	jne	SHORT $LN54@DoFixup
	test	BYTE PTR [rax+48], 64			; 00000040H
	je	$LN55@DoFixup
$LN54@DoFixup:

; 462  :             /* assembly time variable (also $ symbol) in reloc? */
; 463  :             /* v2.07: moved inside if-block, using new local var "offset" */
; 464  :             if ( fixup->sym->variable ) {

	test	BYTE PTR [rax+48], 64			; 00000040H
	je	SHORT $LN53@DoFixup

; 465  :                 seg = (struct dsym *)fixup->segment_var;

	mov	r12, QWORD PTR [rbp+40]

; 466  :                 offset = 0;

	xor	r14d, r14d

; 467  :                 DebugMsg(("DoFixup(%s, %04" I32_SPEC "X, %s): variable, fixup->segment=%Xh fixup->offset=%" I32_SPEC "Xh, fixup->sym->offset=%" I32_SPEC "Xh\n",
; 468  :                           curr->sym.name, fixup->locofs, fixup->sym->name, seg, fixup->offset, fixup->sym->offset ));
; 469  :             } else {

	jmp	SHORT $LN52@DoFixup
$LN53@DoFixup:

; 470  :                 seg = (struct dsym *)fixup->sym->segment;
; 471  :                 offset = fixup->sym->offset;

	mov	r14d, DWORD PTR [rax+16]
$LN52@DoFixup:

; 472  :             }
; 473  :             /* the offset result consists of
; 474  :              * - the symbol's offset
; 475  :              * - the fixup's offset (usually the displacement )
; 476  :              * - the segment/group offset in the image
; 477  :              */
; 478  :             switch ( fixup->type ) {

	mov	eax, DWORD PTR [rbp+24]
	test	eax, eax
	jle	$LN41@DoFixup
	cmp	eax, 3
	jle	$LN42@DoFixup
	cmp	eax, 12
	je	$LN49@DoFixup
	cmp	eax, 13
	jne	$LN41@DoFixup

; 484  :             case FIX_OFF32_SECREL:
; 485  :                 value = ( fixup->offset + offset ) - seg->e.seginfo->start_loc;

	mov	rax, QWORD PTR [r12+104]

; 486  :                 /* check if symbol's segment name contains a '$'.
; 487  :                  * If yes, search the segment without suffix.
; 488  :                  */
; 489  :                 if ( tmp = strchr( seg->sym.name, '$' ) ) {

	mov	rcx, QWORD PTR [r12+8]
	mov	edi, r14d
	sub	edi, DWORD PTR [rax+8]
	mov	edx, 36					; 00000024H
	add	edi, DWORD PTR [rbp+16]
	call	strchr
	test	rax, rax
	mov	r13, rax
	je	$LN76@DoFixup

; 490  :                     int namlen = tmp - seg->sym.name;
; 491  :                     struct dsym *segfirst;
; 492  :                     for( segfirst = SymTables[TAB_SEG].head; segfirst; segfirst = segfirst->next ) {

	mov	rsi, QWORD PTR SymTables+32
	sub	r13d, DWORD PTR [r12+8]
	test	rsi, rsi
	je	$LN75@DoFixup
$LL46@DoFixup:

; 493  :                         if ( segfirst->sym.name_size == namlen &&
; 494  :                             ( memcmp( segfirst->sym.name, seg->sym.name, namlen ) == 0 ) ) {

	movzx	ecx, BYTE PTR [rsi+80]
	cmp	ecx, r13d
	jne	SHORT $LN45@DoFixup
	mov	rdx, QWORD PTR [r12+8]
	mov	rcx, QWORD PTR [rsi+8]
	movsxd	r8, r13d
	mov	r9d, 1
	mov	DWORD PTR [rsp+32], 1
	call	memcmp
	test	eax, eax
	je	SHORT $LN70@DoFixup
$LN45@DoFixup:

; 490  :                     int namlen = tmp - seg->sym.name;
; 491  :                     struct dsym *segfirst;
; 492  :                     for( segfirst = SymTables[TAB_SEG].head; segfirst; segfirst = segfirst->next ) {

	mov	rsi, QWORD PTR [rsi+112]
	test	rsi, rsi
	jne	SHORT $LL46@DoFixup

; 493  :                         if ( segfirst->sym.name_size == namlen &&
; 494  :                             ( memcmp( segfirst->sym.name, seg->sym.name, namlen ) == 0 ) ) {

	lea	r9, OFFSET FLAT:__ImageBase
	jmp	$LN74@DoFixup
$LN70@DoFixup:

; 495  :                             value = ( fixup->offset + offset + seg->e.seginfo->start_offset ) - segfirst->e.seginfo->start_offset;

	mov	rcx, QWORD PTR [r12+104]
	mov	rax, QWORD PTR [rsi+104]

; 496  :                             DebugMsg(("DoFixup(%s): SECREL, primary seg=%s, start_offset=%" I32_SPEC "X\n",
; 497  :                                       curr->sym.name, segfirst->sym.name, segfirst->e.seginfo->start_offset ));
; 498  :                             break;
; 499  :                         }
; 500  :                     }
; 501  :                 }
; 502  :                 DebugMsg(("DoFixup(%s): SECREL, loc=%" I32_SPEC "X, value=%" I32_SPEC "X\n",
; 503  :                         curr->sym.name, fixup->locofs, value ));
; 504  :                 break;

	lea	r9, OFFSET FLAT:__ImageBase
	mov	edi, DWORD PTR [rcx+12]
	sub	edi, DWORD PTR [rax+12]
	add	edi, r14d
	add	edi, DWORD PTR [rbp+16]
	jmp	$LN74@DoFixup
$LN49@DoFixup:

; 479  :             case FIX_OFF32_IMGREL:
; 480  :                 value = ( fixup->offset + offset + seg->e.seginfo->start_offset ) - cp->imagestart;

	mov	rax, QWORD PTR [r12+104]
	mov	edi, DWORD PTR [rax+12]
	sub	edi, DWORD PTR [rdx+24]
	add	edi, DWORD PTR [rbp+16]
	add	edi, r14d

; 481  :                 DebugMsg(("DoFixup(%s): IMGREL, loc=%" I32_SPEC "X value=%" I32_SPEC "X seg.start=%" I32_SPEC "X imagestart=%" I32_SPEC "X\n",
; 482  :                           curr->sym.name, fixup->locofs, value, seg->e.seginfo->start_offset, cp->imagestart ));
; 483  :                 break;

	jmp	$LN74@DoFixup
$LN42@DoFixup:

; 505  :             case FIX_RELOFF8:
; 506  :             case FIX_RELOFF16:
; 507  :             case FIX_RELOFF32:
; 508  :                 /* v1.96: special handling for "relative" fixups */
; 509  :                 value = seg->e.seginfo->start_offset + fixup->offset + offset;

	mov	rax, QWORD PTR [r12+104]
	mov	edi, DWORD PTR [rax+12]
	add	edi, DWORD PTR [rbp+16]
	add	edi, r14d

; 510  :                 DebugMsg(("DoFixup(%s): RELOFFx, loc=%" I32_SPEC "X, sym=%s, [start_offset=%" I32_SPEC "Xh, fixup->offset=%" I32_SPEC "Xh, fixup->sym->offset=%" I32_SPEC "Xh\n",
; 511  :                         curr->sym.name, fixup->locofs, fixup->sym->name, seg->e.seginfo->start_offset, fixup->offset, offset ));
; 512  :                 break;

	jmp	SHORT $LN74@DoFixup
$LN41@DoFixup:

; 513  :             default:
; 514  :                 /* v2.01: don't use group if fixup explicitely refers the segment! */
; 515  :                 //if ( seg->e.seginfo->group ) {
; 516  :                 if ( seg->e.seginfo->group && fixup->frame_type != FRAME_SEG ) {

	mov	rax, QWORD PTR [r12+104]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN40@DoFixup
	cmp	BYTE PTR [rbp+40], 0
	je	SHORT $LN40@DoFixup

; 517  :                     value = (seg->e.seginfo->group->offset & 0xF) + seg->e.seginfo->start_offset + fixup->offset + offset;

	mov	rcx, rax
	mov	rax, QWORD PTR [rax]
	mov	edi, DWORD PTR [rax+16]
	and	edi, 15
	add	edi, DWORD PTR [rcx+12]
	add	edi, DWORD PTR [rbp+16]
	add	edi, r14d

; 518  : #if PE_SUPPORT
; 519  :                     if ( ModuleInfo.sub_format == SFORMAT_PE ) {

	cmp	DWORD PTR ModuleInfo+372, 2
	jne	SHORT $LN74@DoFixup

; 520  : #if AMD64_SUPPORT
; 521  :                         if ( curr->e.seginfo->Ofssize == USE64 )

	mov	rax, QWORD PTR [r15+104]
	cmp	BYTE PTR [rax+104], 2
	jne	SHORT $LN38@DoFixup

; 522  :                             value64 = value + cp->imagebase64;

	mov	eax, edi
	add	rax, QWORD PTR [rdx+32]
	mov	QWORD PTR value64$[rsp], rax
$LN38@DoFixup:

; 523  : #endif
; 524  :                         value += cp->imagebase;

	add	edi, DWORD PTR [rdx+32]

; 525  :                     }
; 526  : #endif
; 527  :                 } else

	jmp	SHORT $LN74@DoFixup
$LN40@DoFixup:

; 528  :                     value = (seg->e.seginfo->start_offset & 0xF) + fixup->offset + offset;

	mov	edi, DWORD PTR [rax+12]
	and	edi, 15
	add	edi, DWORD PTR [rbp+16]
	add	edi, r14d

; 529  : 
; 530  :                 DebugMsg(("DoFixup(%s): loc=%04" I32_SPEC "X, sym=%s, target->start_offset=%" I32_SPEC "Xh, fixup->offset=%" I32_SPEC "Xh, fixup->sym->offset=%" I32_SPEC "Xh\n",
; 531  :                         curr->sym.name, fixup->locofs, fixup->sym->name, seg->e.seginfo->start_offset, fixup->offset, offset ));
; 532  :                 break;
; 533  :             }
; 534  : 
; 535  :         } else {

	jmp	SHORT $LN74@DoFixup
$LN55@DoFixup:

; 536  :             /* v2.10: member segment_var is for assembly-time variables only */
; 537  :             //seg = (struct dsym *)fixup->segment_var;
; 538  :             seg = NULL;

	xor	r12d, r12d

; 539  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X, %s): target segment=0, fixup->offset=%" I32_SPEC "Xh, fixup->sym->offset=%" I32_SPEC "Xh\n",
; 540  :                       curr->sym.name, fixup->locofs, fixup->sym ? fixup->sym->name : "", fixup->offset ? offset : 0 ));
; 541  :             value = 0;

	xor	edi, edi
	jmp	SHORT $LN74@DoFixup
$LN75@DoFixup:

; 454  : 
; 455  :     DebugMsg(("DoFixup(%s) enter, segment start ofs=%" I32_SPEC "Xh\n", curr->sym.name, curr->e.seginfo->start_offset ));
; 456  :     for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	lea	r9, OFFSET FLAT:__ImageBase
	jmp	SHORT $LN74@DoFixup
$LN76@DoFixup:

; 539  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X, %s): target segment=0, fixup->offset=%" I32_SPEC "Xh, fixup->sym->offset=%" I32_SPEC "Xh\n",
; 540  :                       curr->sym.name, fixup->locofs, fixup->sym ? fixup->sym->name : "", fixup->offset ? offset : 0 ));
; 541  :             value = 0;

	lea	r9, OFFSET FLAT:__ImageBase
$LN74@DoFixup:

; 542  :         }
; 543  : 
; 544  :         switch ( fixup->type ) {

	mov	r8d, DWORD PTR [rbp+24]
	lea	eax, DWORD PTR [r8-1]
	cmp	eax, 12
	ja	$LN4@DoFixup
	cdqe
	mov	ecx, DWORD PTR $LN73@DoFixup[r9+rax*4]
	add	rcx, r9
	jmp	rcx
$LN33@DoFixup:

; 545  :         case FIX_RELOFF8:
; 546  :             //*codeptr.db += (value - fixup->locofs + 1) & 0xff;
; 547  :             /* changed in v1.95 */
; 548  :             *codeptr.db += (value - (fixup->locofs + curr->e.seginfo->start_offset) - 1) & 0xff;

	mov	rax, QWORD PTR [r15+104]
	sub	dil, BYTE PTR [rax+12]
	sub	dil, BYTE PTR [rbp+20]
	dec	dil
	add	BYTE PTR [rbx], dil

; 549  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_RELOFF8, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.db ));
; 550  :             break;

	jmp	$LN57@DoFixup
$LN32@DoFixup:

; 551  :         case FIX_RELOFF16:
; 552  :             //*codeptr.dw += (value - fixup->locofs + 2) & 0xffff;
; 553  :             /* changed in v1.95 */
; 554  :             *codeptr.dw += (value - (fixup->locofs + curr->e.seginfo->start_offset) - 2) & 0xffff;

	mov	rax, QWORD PTR [r15+104]
	sub	di, WORD PTR [rax+12]
	sub	di, WORD PTR [rbp+20]
	sub	di, 2
	add	WORD PTR [rbx], di

; 555  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_RELOFF16, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.dw ));
; 556  :             break;

	jmp	$LN57@DoFixup
$LN31@DoFixup:

; 557  :         case FIX_RELOFF32:
; 558  : #if AMD64_SUPPORT
; 559  :             /* adjust the location for EIP-related offsets if USE64 */
; 560  :             if ( curr->e.seginfo->Ofssize == USE64 ) {

	mov	rax, QWORD PTR [r15+104]
	cmp	BYTE PTR [rax+104], 2
	jne	SHORT $LN30@DoFixup

; 561  :                 fixup->locofs += fixup->addbytes - 4;

	movzx	eax, BYTE PTR [rbp+32]
	sub	eax, 4
	add	DWORD PTR [rbp+20], eax
$LN30@DoFixup:

; 562  :             }
; 563  : #endif
; 564  :             //*codeptr.dd += (value - fixup->locofs + 4);
; 565  :             /* changed in v1.95 */
; 566  :             *codeptr.dd += (value - (fixup->locofs + curr->e.seginfo->start_offset) - 4);

	mov	rax, QWORD PTR [r15+104]
	sub	edi, DWORD PTR [rax+12]
	sub	edi, DWORD PTR [rbp+20]
	sub	edi, 4
	add	DWORD PTR [rbx], edi

; 567  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_RELOFF32, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.dd ));
; 568  :             break;

	jmp	$LN57@DoFixup
$LN29@DoFixup:

; 569  :         case FIX_OFF8:
; 570  :             *codeptr.db = value & 0xff;

	mov	BYTE PTR [rbx], dil

; 571  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_OFF8, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.db ));
; 572  :             break;

	jmp	$LN57@DoFixup
$LN28@DoFixup:

; 573  :         case FIX_OFF16:
; 574  :             *codeptr.dw = value & 0xffff;

	mov	WORD PTR [rbx], di

; 575  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_OFF16, value=%" I32_SPEC "Xh, target=%p *target=%Xh\n", curr->sym.name, fixup->locofs, value, codeptr, *codeptr.dw ));
; 576  :             break;

	jmp	$LN57@DoFixup
$LN27@DoFixup:

; 577  :         case FIX_OFF32:
; 578  :             *codeptr.dd = value;

	mov	DWORD PTR [rbx], edi

; 579  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_OFF32, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.dd ));
; 580  :             break;

	jmp	$LN57@DoFixup
$LN26@DoFixup:

; 581  :         case FIX_OFF32_IMGREL:
; 582  :             *codeptr.dd = value;

	mov	DWORD PTR [rbx], edi

; 583  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_OFF32_IMGREL, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.dd ));
; 584  :             break;

	jmp	$LN57@DoFixup
$LN25@DoFixup:

; 585  :         case FIX_OFF32_SECREL:
; 586  :             *codeptr.dd = value;

	mov	DWORD PTR [rbx], edi

; 587  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_OFF32_SECREL, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.dd ));
; 588  :             break;

	jmp	$LN57@DoFixup
$LN24@DoFixup:

; 589  : #if AMD64_SUPPORT
; 590  :         case FIX_OFF64:
; 591  : #if PE_SUPPORT
; 592  :             if ( ModuleInfo.sub_format == SFORMAT_PE && curr->e.seginfo->Ofssize == USE64 )

	cmp	DWORD PTR ModuleInfo+372, 2
	jne	SHORT $LN23@DoFixup
	mov	rax, QWORD PTR [r15+104]
	cmp	BYTE PTR [rax+104], 2
	jne	SHORT $LN23@DoFixup

; 593  :                 *codeptr.dq = value64;

	mov	rax, QWORD PTR value64$[rsp]
	mov	QWORD PTR [rbx], rax

; 594  :             else

	jmp	$LN57@DoFixup
$LN23@DoFixup:

; 595  : #endif
; 596  :                 *codeptr.dq = value;

	mov	eax, edi
	mov	QWORD PTR [rbx], rax

; 597  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_OFF64, value=%" I32_SPEC "Xh, *target=%" I64_SPEC "Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.dq ));
; 598  :             break;

	jmp	$LN57@DoFixup
$LN21@DoFixup:

; 599  : #endif
; 600  :         case FIX_HIBYTE:
; 601  :             *codeptr.db = (value >> 8) & 0xff;

	shr	edi, 8
	mov	BYTE PTR [rbx], dil

; 602  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_HIBYTE, value=%" I32_SPEC "Xh, *target=%Xh\n", curr->sym.name, fixup->locofs, value, *codeptr.db ));
; 603  :             break;

	jmp	$LN57@DoFixup
$LN20@DoFixup:

; 604  :         case FIX_SEG:
; 605  :             /* absolute segments are ok */
; 606  :             if ( fixup->sym &&
; 607  :                 fixup->sym->state == SYM_SEG &&
; 608  :                 ((struct dsym *)fixup->sym)->e.seginfo->segtype == SEGTYPE_ABS ) {

	mov	rax, QWORD PTR [rbp+56]
	test	rax, rax
	je	SHORT $LN19@DoFixup
	cmp	DWORD PTR [rax+40], 3
	jne	SHORT $LN19@DoFixup
	mov	rcx, QWORD PTR [rax+104]
	cmp	DWORD PTR [rcx+72], 5
	jne	SHORT $LN19@DoFixup

; 609  :                 *codeptr.dw = ((struct dsym *)fixup->sym)->e.seginfo->abs_frame;

	movzx	eax, WORD PTR [rcx+88]
	mov	WORD PTR [rbx], ax

; 610  :                 break;

	jmp	$LN57@DoFixup
$LN19@DoFixup:

; 611  :             }
; 612  : #if MZ_SUPPORT
; 613  :             if ( ModuleInfo.sub_format == SFORMAT_MZ ) {

	cmp	DWORD PTR ModuleInfo+372, 1
	jne	SHORT $LN18@DoFixup

; 614  :                 DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_SEG frame=%u, ", curr->sym.name, fixup->locofs, fixup->frame_type ));
; 615  :                 if ( fixup->sym->state == SYM_GRP ) {

	mov	ecx, DWORD PTR [rax+40]
	cmp	ecx, 4
	jne	SHORT $LN17@DoFixup

; 616  :                     seg = (struct dsym *)fixup->sym;
; 617  :                     *codeptr.dw = seg->sym.offset >> 4;

	mov	eax, DWORD PTR [rax+16]
	sar	eax, 4
	mov	WORD PTR [rbx], ax
	jmp	$LN57@DoFixup
$LN17@DoFixup:

; 618  :                     DebugMsg(("GROUP symbol, offset=%" I32_SPEC "Xh codeptr=%p\n", seg->sym.offset, codeptr ));
; 619  :                 } else if ( fixup->sym->state == SYM_SEG ) {

	cmp	ecx, 3
	jne	SHORT $LN15@DoFixup

; 620  :                     /* v2.04: added */
; 621  :                     seg = (struct dsym *)fixup->sym;
; 622  :                     *codeptr.dw = ( seg->e.seginfo->start_offset + ( seg->e.seginfo->group ? seg->e.seginfo->group->offset : 0 ) ) >> 4;

	mov	rcx, QWORD PTR [rax+104]
	cmp	QWORD PTR [rcx], 0
	je	SHORT $LN62@DoFixup
	mov	rax, QWORD PTR [rcx]
	mov	edx, DWORD PTR [rax+16]
	mov	eax, DWORD PTR [rcx+12]
	add	eax, edx
	shr	eax, 4
	mov	WORD PTR [rbx], ax
	jmp	$LN57@DoFixup
$LN62@DoFixup:
	mov	eax, DWORD PTR [rcx+12]
	xor	edx, edx
	add	eax, edx
	shr	eax, 4
	mov	WORD PTR [rbx], ax
	jmp	$LN57@DoFixup
$LN15@DoFixup:

; 623  :                     DebugMsg(("SEGMENT symbol, start_offset=%" I32_SPEC "Xh\n", seg->e.seginfo->start_offset ));
; 624  :                 //} else if ( seg->e.seginfo->group ) {
; 625  :                 } else if ( fixup->frame_type == FRAME_GRP ) {

	cmp	BYTE PTR [rbp+40], 1
	jne	SHORT $LN13@DoFixup

; 626  :                     /* v2.04: changed */
; 627  :                     //*codeptr.dw = (seg->e.seginfo->start_offset + seg->e.seginfo->group->offset) >> 4;
; 628  :                     *codeptr.dw = seg->e.seginfo->group->offset >> 4;

	mov	rax, QWORD PTR [r12+104]
	mov	rcx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rcx+16]
	sar	eax, 4
	mov	WORD PTR [rbx], ax

; 629  :                     DebugMsg(("group.offset=%" I32_SPEC "Xh\n", seg->e.seginfo->group->offset ));
; 630  :                 } else {

	jmp	$LN57@DoFixup
$LN13@DoFixup:

; 631  :                     *codeptr.dw = seg->e.seginfo->start_offset >> 4;

	mov	rax, QWORD PTR [r12+104]
	mov	ecx, DWORD PTR [rax+12]
	shr	ecx, 4
	mov	WORD PTR [rbx], cx

; 632  :                     DebugMsg(("segment.offset=%" I32_SPEC "Xh\n", seg->e.seginfo->start_offset ));
; 633  :                 }
; 634  :                 break;

	jmp	$LN57@DoFixup
$LN18@DoFixup:

; 635  :             }
; 636  : #endif
; 637  :         case FIX_PTR16:
; 638  : #if 1
; 639  :             /* v2.10: absolute segments are ok */
; 640  :             if ( seg && seg->e.seginfo->segtype == SEGTYPE_ABS ) {

	test	r12, r12
	je	SHORT $LN10@DoFixup
	mov	rax, QWORD PTR [r12+104]
	cmp	DWORD PTR [rax+72], 5
	jne	SHORT $LN10@DoFixup

; 641  :                 *codeptr.dw = value & 0xffff;

	mov	WORD PTR [rbx], di

; 642  :                 codeptr.dw++;
; 643  :                 *codeptr.dw = seg->e.seginfo->abs_frame;

	mov	rax, QWORD PTR [r12+104]
	movzx	ecx, WORD PTR [rax+88]
	mov	WORD PTR [rbx+2], cx

; 644  :                 break;

	jmp	$LN57@DoFixup
$LN10@DoFixup:

; 645  :             }
; 646  : #endif
; 647  : #if MZ_SUPPORT
; 648  :             if ( ModuleInfo.sub_format == SFORMAT_MZ ) {

	cmp	DWORD PTR ModuleInfo+372, 1
	jne	SHORT $LN9@DoFixup

; 649  :                 DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_PTR16, seg->start=%Xh\n", curr->sym.name, fixup->locofs, seg->e.seginfo->start_offset ));
; 650  :                 *codeptr.dw = value & 0xffff;

	mov	WORD PTR [rbx], di

; 651  :                 codeptr.dw++;
; 652  :                 //if ( seg->e.seginfo->group ) { /* v2.04: changed */
; 653  :                 if ( fixup->frame_type == FRAME_GRP ) {

	cmp	BYTE PTR [rbp+40], 1
	jne	SHORT $LN8@DoFixup

; 654  :                     /* v2.04: changed */
; 655  :                     //*codeptr.dw = (seg->e.seginfo->start_offset + seg->e.seginfo->group->offset) >> 4;
; 656  :                     *codeptr.dw = seg->e.seginfo->group->offset >> 4;

	mov	rax, QWORD PTR [r12+104]
	mov	rcx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rcx+16]
	sar	eax, 4
	mov	WORD PTR [rbx+2], ax

; 657  :                 } else {

	jmp	$LN57@DoFixup
$LN8@DoFixup:

; 658  :                     /* v2.05: changed */
; 659  :                     //*codeptr.dw = seg->e.seginfo->start_offset >> 4;
; 660  :                     *codeptr.dw = ( seg->e.seginfo->start_offset + ( seg->e.seginfo->group ? seg->e.seginfo->group->offset : 0 ) ) >> 4;

	mov	rcx, QWORD PTR [r12+104]
	cmp	QWORD PTR [rcx], 0
	je	SHORT $LN64@DoFixup
	mov	rax, QWORD PTR [rcx]
	mov	edx, DWORD PTR [rax+16]
	mov	eax, DWORD PTR [rcx+12]
	add	eax, edx
	shr	eax, 4
	mov	WORD PTR [rbx+2], ax

; 661  :                 }
; 662  :                 break;

	jmp	$LN57@DoFixup
$LN64@DoFixup:

; 658  :                     /* v2.05: changed */
; 659  :                     //*codeptr.dw = seg->e.seginfo->start_offset >> 4;
; 660  :                     *codeptr.dw = ( seg->e.seginfo->start_offset + ( seg->e.seginfo->group ? seg->e.seginfo->group->offset : 0 ) ) >> 4;

	mov	eax, DWORD PTR [rcx+12]
	xor	edx, edx
	add	eax, edx
	shr	eax, 4
	mov	WORD PTR [rbx+2], ax

; 661  :                 }
; 662  :                 break;

	jmp	$LN57@DoFixup
$LN9@DoFixup:

; 663  :             }
; 664  : #endif
; 665  :         case FIX_PTR32:
; 666  : #if 1
; 667  :             /* v2.10: absolute segments are ok */
; 668  :             if ( seg && seg->e.seginfo->segtype == SEGTYPE_ABS ) {

	test	r12, r12
	je	SHORT $LN5@DoFixup
	mov	rax, QWORD PTR [r12+104]
	cmp	DWORD PTR [rax+72], 5
	jne	SHORT $LN5@DoFixup

; 669  :                 *codeptr.dd = value;

	mov	DWORD PTR [rbx], edi

; 670  :                 codeptr.dd++;
; 671  :                 *codeptr.dw = seg->e.seginfo->abs_frame;

	mov	rax, QWORD PTR [r12+104]
	movzx	ecx, WORD PTR [rax+88]
	mov	WORD PTR [rbx+4], cx

; 672  :                 break;

	jmp	$LN57@DoFixup
$LN5@DoFixup:

; 673  :             }
; 674  : #endif
; 675  : #if MZ_SUPPORT
; 676  :             if ( ModuleInfo.sub_format == SFORMAT_MZ ) {

	cmp	DWORD PTR ModuleInfo+372, 1
	jne	SHORT $LN4@DoFixup

; 677  :                 DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): FIX_PTR32\n", curr->sym.name, fixup->locofs ));
; 678  :                 *codeptr.dd = value;

	mov	DWORD PTR [rbx], edi

; 679  :                 codeptr.dd++;
; 680  :                 //if (seg->e.seginfo->group ) { /* v2.04: changed */
; 681  :                 if ( fixup->frame_type == FRAME_GRP ) {

	cmp	BYTE PTR [rbp+40], 1
	jne	SHORT $LN3@DoFixup

; 682  :                     /* v2.04: changed */
; 683  :                     //*codeptr.dw = (seg->e.seginfo->start_offset + seg->e.seginfo->group->offset) >> 4;
; 684  :                     *codeptr.dw = seg->e.seginfo->group->offset >> 4;

	mov	rax, QWORD PTR [r12+104]
	mov	rcx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rcx+16]
	sar	eax, 4
	mov	WORD PTR [rbx+4], ax

; 685  :                 } else {

	jmp	SHORT $LN57@DoFixup
$LN3@DoFixup:

; 686  :                     /* v2.05: changed */
; 687  :                     //*codeptr.dw = seg->e.seginfo->start_offset >> 4;
; 688  :                     *codeptr.dw = ( seg->e.seginfo->start_offset + ( seg->e.seginfo->group ? seg->e.seginfo->group->offset : 0 ) ) >> 4;

	mov	rcx, QWORD PTR [r12+104]
	cmp	QWORD PTR [rcx], 0
	je	SHORT $LN66@DoFixup
	mov	rax, QWORD PTR [rcx]
	mov	edx, DWORD PTR [rax+16]
	mov	eax, DWORD PTR [rcx+12]
	add	eax, edx
	shr	eax, 4
	mov	WORD PTR [rbx+4], ax

; 689  :                 }
; 690  :                 break;

	jmp	SHORT $LN57@DoFixup
$LN66@DoFixup:

; 686  :                     /* v2.05: changed */
; 687  :                     //*codeptr.dw = seg->e.seginfo->start_offset >> 4;
; 688  :                     *codeptr.dw = ( seg->e.seginfo->start_offset + ( seg->e.seginfo->group ? seg->e.seginfo->group->offset : 0 ) ) >> 4;

	mov	eax, DWORD PTR [rcx+12]
	xor	edx, edx
	add	eax, edx
	shr	eax, 4
	mov	WORD PTR [rbx+4], ax

; 689  :                 }
; 690  :                 break;

	jmp	SHORT $LN57@DoFixup
$LN4@DoFixup:

; 691  :             }
; 692  : #endif
; 693  :         default:
; 694  :             DebugMsg(("DoFixup(%s, %04" I32_SPEC "X): invalid fixup %u\n", curr->sym.name, fixup->locofs, fixup->type ));
; 695  :             EmitErr( INVALID_FIXUP_TYPE, ModuleInfo.fmtopt->formatname, fixup->type, curr->sym.name, fixup->locofs );

	mov	rdx, QWORD PTR ModuleInfo+344
	mov	eax, DWORD PTR [rbp+20]
	mov	r9, QWORD PTR [r15+8]
	add	rdx, 10
	mov	ecx, 198				; 000000c6H
	mov	DWORD PTR [rsp+32], eax
	call	EmitErr
	lea	r9, OFFSET FLAT:__ImageBase
$LN57@DoFixup:
	mov	rbp, QWORD PTR [rbp+8]
	mov	rdx, QWORD PTR cp$[rsp]
	test	rbp, rbp
	jne	$LL58@DoFixup
	mov	r14, QWORD PTR [rsp+64]
	mov	r13, QWORD PTR [rsp+72]
	mov	r12, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [rsp+128]
$LN56@DoFixup:
	mov	r15, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+136]

; 696  :             //return( ERROR );
; 697  :         }
; 698  :     }
; 699  :     return( NOT_ERROR );

	xor	eax, eax

; 700  : }

	add	rsp, 104				; 00000068H
	ret	0
$LN73@DoFixup:
	DD	$LN33@DoFixup
	DD	$LN32@DoFixup
	DD	$LN31@DoFixup
	DD	$LN29@DoFixup
	DD	$LN28@DoFixup
	DD	$LN27@DoFixup
	DD	$LN24@DoFixup
	DD	$LN20@DoFixup
	DD	$LN18@DoFixup
	DD	$LN9@DoFixup
	DD	$LN21@DoFixup
	DD	$LN26@DoFixup
	DD	$LN25@DoFixup
DoFixup	ENDP
_TEXT	ENDS
EXTRN	RunLineQueue:NEAR
EXTRN	AddLineQueue:NEAR
EXTRN	AddLineQueueX:NEAR
EXTRN	SymFind:NEAR
EXTRN	Parse_Pass:DWORD
xdata	SEGMENT
$unwind$pe_create_MZ_header DD 031001H
	DD	0b7410H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$pe_create_MZ_header DD @imagerel(pe_create_MZ_header#)
	DD	@imagerel(pe_create_MZ_header#+70)
	DD	@imagerel($unwind$pe_create_MZ_header#)
pdata	ENDS
xdata	SEGMENT
$chain$2$pe_create_MZ_header DD 040a21H
	DD	0a640aH
	DD	093405H
	DD	@imagerel(pe_create_MZ_header#)
	DD	@imagerel(pe_create_MZ_header#+70)
	DD	@imagerel($unwind$pe_create_MZ_header#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$pe_create_MZ_header DD @imagerel(pe_create_MZ_header#+70)
	DD	@imagerel(pe_create_MZ_header#+234)
	DD	@imagerel($chain$2$pe_create_MZ_header#)
pdata	ENDS
xdata	SEGMENT
$chain$3$pe_create_MZ_header DD 021H
	DD	@imagerel(pe_create_MZ_header#)
	DD	@imagerel(pe_create_MZ_header#+70)
	DD	@imagerel($unwind$pe_create_MZ_header#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$pe_create_MZ_header DD @imagerel(pe_create_MZ_header#+234)
	DD	@imagerel(pe_create_MZ_header#+261)
	DD	@imagerel($chain$3$pe_create_MZ_header#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
modinfo$ = 64
pe_create_MZ_header PROC NEAR

; 706  : {

	sub	rsp, 56					; 00000038H

; 707  :     const char *p;
; 708  :     struct asym *sym;
; 709  : 
; 710  :     DebugMsg(("pe_create_MZ_header enter\n" ));
; 711  :     if ( Parse_Pass == PASS_1 && SymSearch( hdrname "1" ) == NULL )

	cmp	DWORD PTR Parse_Pass, 0
	mov	QWORD PTR [rsp+88], rdi
	mov	rdi, rcx
	jne	SHORT $LN6@pe_create_
	lea	rcx, OFFSET FLAT:$SG6284
	call	SymFind
	test	rax, rax
	jne	SHORT $LN6@pe_create_

; 712  :         modinfo->g.pe_flags |= PEF_MZHDR;

	or	BYTE PTR [rdi+312], 1
$LN6@pe_create_:

; 713  :     if ( modinfo->g.pe_flags & PEF_MZHDR ) {

	test	BYTE PTR [rdi+312], 1
	je	$LN1@pe_create_

; 714  :         DebugMsg(("pe_create_MZ_header: generate code\n" ));
; 715  :         AddLineQueueX("%r DOTNAME", T_OPTION );

	lea	rcx, OFFSET FLAT:$SG6286
	mov	edx, 452				; 000001c4H
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+80], rsi
	call	AddLineQueueX

; 716  :         AddLineQueueX("%s1 %r USE16 %r %s", hdrname, T_SEGMENT, T_WORD, hdrattr );

	lea	rdx, OFFSET FLAT:hdrattr
	mov	QWORD PTR [rsp+32], rdx
	lea	rcx, OFFSET FLAT:$SG6288
	lea	rdx, OFFSET FLAT:$SG6287
	mov	r9d, 207				; 000000cfH
	mov	r8d, 441				; 000001b9H
	call	AddLineQueueX

; 717  :         for( p = mzcode; p < mzcode + sizeof( mzcode ); p += strlen( p ) + 1 )

	lea	rbx, OFFSET FLAT:mzcode
	lea	rsi, OFFSET FLAT:mzcode+180
	npad	2
$LL4@pe_create_:

; 718  :             AddLineQueue( p );

	mov	rcx, rbx
	call	AddLineQueue
	xor	eax, eax
	mov	rdi, rbx
	mov	rcx, -1
	repne scasb
	not	rcx
	add	rbx, rcx
	cmp	rbx, rsi
	jb	SHORT $LL4@pe_create_

; 719  :         AddLineQueueX("%s1 %r", hdrname, T_ENDS );

	lea	rdx, OFFSET FLAT:$SG6292
	lea	rcx, OFFSET FLAT:$SG6293
	mov	r8d, 442				; 000001baH
	call	AddLineQueueX

; 720  :         RunLineQueue();

	call	RunLineQueue

; 721  :         if ( ( sym = SymSearch( hdrname "1" ) ) && sym->state == SYM_SEG )

	lea	rcx, OFFSET FLAT:$SG6295
	call	SymFind
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+72]
	test	rax, rax
	je	SHORT $LN1@pe_create_
	cmp	DWORD PTR [rax+40], 3
	jne	SHORT $LN1@pe_create_

; 722  :            (( struct dsym *)sym)->e.seginfo->segtype = SEGTYPE_HDR;

	mov	rax, QWORD PTR [rax+104]
	mov	DWORD PTR [rax+72], 6
$LN1@pe_create_:
	mov	rdi, QWORD PTR [rsp+88]

; 723  :     }
; 724  : }

	add	rsp, 56					; 00000038H
	ret	0
pe_create_MZ_header ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$set_file_flags DD 050e01H
	DD	09740eH
	DD	083409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$set_file_flags DD @imagerel(set_file_flags#)
	DD	@imagerel(set_file_flags#+81)
	DD	@imagerel($unwind$set_file_flags#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
opnd$ = 56
set_file_flags PROC NEAR

; 730  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx

; 731  :     struct dsym *pehdr;
; 732  :     struct IMAGE_PE_HEADER32 *pe;
; 733  : 
; 734  :     pehdr = ( struct dsym *)SymSearch( hdrname "2" );

	lea	rcx, OFFSET FLAT:$SG6306
	mov	rbx, rdx
	call	SymFind

; 735  :     if ( !pehdr )

	test	rax, rax
	je	SHORT $LN3@set_file_f

; 736  :         return;
; 737  :     pe = (struct IMAGE_PE_HEADER32 *)pehdr->e.seginfo->CodeBuffer;
; 738  : 
; 739  :     if ( opnd ) /* set the value? */

	test	rbx, rbx
	mov	rax, QWORD PTR [rax+104]
	mov	r8, QWORD PTR [rax+16]
	je	SHORT $LN1@set_file_f

; 740  :         pe->FileHeader.Characteristics = opnd->value;

	movzx	eax, WORD PTR [rbx]
	mov	WORD PTR [r8+22], ax
$LN1@set_file_f:

; 741  : 
; 742  :     sym->value = pe->FileHeader.Characteristics;

	movzx	eax, WORD PTR [r8+22]
	mov	DWORD PTR [rdi+16], eax
$LN3@set_file_f:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 743  :     DebugMsg(("set_file_flags(%s, %X): value=%X\n", sym->name, opnd, sym->value ));
; 744  : }

	add	rsp, 40					; 00000028H
	ret	0
set_file_flags ENDP
_TEXT	ENDS
PUBLIC	pe_create_PE_header
EXTRN	CreateVariable:NEAR
EXTRN	time:NEAR
EXTRN	LclAlloc:NEAR
EXTRN	CreateIntSegment:NEAR
EXTRN	EmitError:NEAR
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$pe_create_PE_header DD 010401H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$pe_create_PE_header DD @imagerel($LN11#)
	DD	@imagerel($LN11#+43)
	DD	@imagerel($unwind$pe_create_PE_header#)
pdata	ENDS
xdata	SEGMENT
$chain$2$pe_create_PE_header DD 063221H
	DD	0b7432H
	DD	0a640aH
	DD	093405H
	DD	@imagerel($LN11#)
	DD	@imagerel($LN11#+43)
	DD	@imagerel($unwind$pe_create_PE_header#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$pe_create_PE_header DD @imagerel($LN11#+43)
	DD	@imagerel($LN11#+330)
	DD	@imagerel($chain$2$pe_create_PE_header#)
pdata	ENDS
xdata	SEGMENT
$chain$3$pe_create_PE_header DD 021H
	DD	@imagerel($LN11#)
	DD	@imagerel($LN11#+43)
	DD	@imagerel($unwind$pe_create_PE_header#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$pe_create_PE_header DD @imagerel($LN11#+330)
	DD	@imagerel($LN11#+350)
	DD	@imagerel($chain$3$pe_create_PE_header#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pe_create_PE_header PROC NEAR

; 748  : {

$LN11:
	sub	rsp, 56					; 00000038H

; 749  :     struct asym *sym;
; 750  :     struct dsym *pehdr;
; 751  :     int size;
; 752  :     void *p;
; 753  : 
; 754  :     DebugMsg(("pe_create_PE_header enter\n" ));
; 755  :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN1@pe_create_@2

; 756  :         if ( ModuleInfo.model != MODEL_FLAT ) {

	cmp	DWORD PTR ModuleInfo+360, 7
	je	SHORT $LN7@pe_create_@2

; 757  :             EmitError( MODEL_MUST_BE_FLAT );

	mov	ecx, 211				; 000000d3H
	call	EmitError
$LN7@pe_create_@2:

; 758  :         }
; 759  : #if AMD64_SUPPORT
; 760  :         if ( ModuleInfo.defOfssize == USE64 ) {

	cmp	BYTE PTR ModuleInfo+405, 2
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+80], rsi
	jne	SHORT $LN6@pe_create_@2

; 761  :             size = sizeof( struct IMAGE_PE_HEADER64 );

	mov	ebx, 264				; 00000108H

; 762  :             p = (void *)&pe64def;

	lea	rsi, OFFSET FLAT:pe64def

; 763  :         } else {

	jmp	SHORT $LN5@pe_create_@2
$LN6@pe_create_@2:

; 764  : #endif
; 765  :             size = sizeof( struct IMAGE_PE_HEADER32 );

	mov	ebx, 248				; 000000f8H

; 766  :             p = (void *)&pe32def;

	lea	rsi, OFFSET FLAT:pe32def
$LN5@pe_create_@2:

; 767  : #if AMD64_SUPPORT
; 768  :         }
; 769  : #endif
; 770  :         pehdr = ( struct dsym *)SymSearch( hdrname "2" );

	lea	rcx, OFFSET FLAT:$SG6325
	mov	QWORD PTR [rsp+88], rdi
	call	SymFind

; 771  :         if ( pehdr == NULL ) {

	test	rax, rax
	jne	SHORT $LN4@pe_create_@2

; 772  :             pehdr = (struct dsym *)CreateIntSegment( hdrname "2", "HDR", 2, ModuleInfo.defOfssize, TRUE );

	movzx	r9d, BYTE PTR ModuleInfo+405
	lea	rdx, OFFSET FLAT:$SG6329
	lea	rcx, OFFSET FLAT:$SG6330
	mov	r8b, 2
	mov	BYTE PTR [rsp+32], 1
	call	CreateIntSegment

; 773  :             pehdr->e.seginfo->group = &ModuleInfo.flat_grp->sym;

	mov	rcx, QWORD PTR ModuleInfo+440
	mov	rdx, QWORD PTR [rax+104]
	mov	QWORD PTR [rdx], rcx

; 774  :             pehdr->e.seginfo->combine = COMB_ADDOFF;  /* PUBLIC */

	mov	rdx, QWORD PTR [rax+104]
	lea	rdi, QWORD PTR [rax+104]
	movzx	ecx, BYTE PTR [rdx+108]
	mov	r11, rax
	and	cl, 250					; 000000faH
	or	cl, 2
	mov	BYTE PTR [rdx+108], cl

; 775  :             pehdr->e.seginfo->characteristics = (IMAGE_SCN_MEM_READ >> 24);

	mov	rcx, QWORD PTR [rdi]
	mov	BYTE PTR [rcx+105], 64			; 00000040H

; 776  :             pehdr->e.seginfo->readonly = 1;

	mov	rcx, QWORD PTR [rdi]
	or	BYTE PTR [rcx+107], 1

; 777  :             pehdr->e.seginfo->bytes_written = size; /* ensure that ORG won't set start_loc (assemble.c, SetCurrOffset) */

	mov	rax, QWORD PTR [rdi]
	mov	DWORD PTR [rax+24], ebx

; 778  :             pehdr->sym.max_offset = size;

	mov	DWORD PTR [r11+64], ebx

; 779  :         } else {

	jmp	SHORT $LN3@pe_create_@2
$LN4@pe_create_@2:

; 780  :             if ( pehdr->sym.max_offset < size )

	cmp	DWORD PTR [rax+64], ebx
	jge	SHORT $LN2@pe_create_@2

; 781  :                 pehdr->sym.max_offset = size;

	mov	DWORD PTR [rax+64], ebx
$LN2@pe_create_@2:

; 782  :             pehdr->e.seginfo->internal = TRUE;

	lea	rdi, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rax+104]
	or	BYTE PTR [rax+107], 16

; 783  :             pehdr->e.seginfo->start_loc = 0;

	mov	rax, QWORD PTR [rdi]
	mov	DWORD PTR [rax+8], 0
$LN3@pe_create_@2:

; 784  :         }
; 785  :         pehdr->e.seginfo->segtype = SEGTYPE_HDR;

	mov	rax, QWORD PTR [rdi]

; 786  :         pehdr->e.seginfo->CodeBuffer = LclAlloc( size );

	movsxd	rbx, ebx
	mov	rcx, rbx
	mov	DWORD PTR [rax+72], 6
	call	LclAlloc
	mov	rcx, QWORD PTR [rdi]

; 787  :         memcpy( pehdr->e.seginfo->CodeBuffer, p, size );

	mov	r8, rbx
	mov	QWORD PTR [rcx+16], rax
	mov	rcx, QWORD PTR [rdi]
	mov	rdx, rsi
	mov	rcx, QWORD PTR [rcx+16]
	call	memcpy

; 788  : #if 0 //def __UNIX__
; 789  :         time((int_32 *)(pehdr->e.seginfo->CodeBuffer+offsetof( struct IMAGE_PE_HEADER32, FileHeader.TimeDateStamp )));
; 790  : #else
; 791  :         time((time_t *)(pehdr->e.seginfo->CodeBuffer+offsetof( struct IMAGE_PE_HEADER32, FileHeader.TimeDateStamp )));

	mov	r11, QWORD PTR [rdi]
	mov	rcx, QWORD PTR [r11+16]
	add	rcx, 8
	call	time

; 792  : #endif
; 793  :         sym = CreateVariable( "@pe_file_flags", ((struct IMAGE_PE_HEADER32 *)p)->FileHeader.Characteristics );

	movzx	edx, WORD PTR [rsi+22]
	lea	rcx, OFFSET FLAT:$SG6338
	call	CreateVariable
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+80]

; 794  :         if ( sym ) {

	test	rax, rax
	mov	rbx, QWORD PTR [rsp+72]
	je	SHORT $LN1@pe_create_@2

; 795  :             DebugMsg(("pe_create_PE_header: CreateVariable(@pe_file_flags)=%X [value=%X]\n", sym, sym ? sym->value : 0 ));
; 796  :             sym->predefined = TRUE;

	or	BYTE PTR [rax+48], 32			; 00000020H

; 797  :             sym->sfunc_ptr = (internal_func)&set_file_flags;

	lea	rcx, OFFSET FLAT:set_file_flags
	mov	QWORD PTR [rax+72], rcx
$LN1@pe_create_@2:

; 798  :         }
; 799  :     }
; 800  : }

	add	rsp, 56					; 00000038H
	ret	0
pe_create_PE_header ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$pe_create_section_table DD 050e01H
	DD	0b740eH
	DD	093409H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$pe_create_section_table DD @imagerel(pe_create_section_table#)
	DD	@imagerel(pe_create_section_table#+37)
	DD	@imagerel($unwind$pe_create_section_table#)
pdata	ENDS
xdata	SEGMENT
$chain$2$pe_create_section_table DD 020521H
	DD	0a6405H
	DD	@imagerel(pe_create_section_table#)
	DD	@imagerel(pe_create_section_table#+37)
	DD	@imagerel($unwind$pe_create_section_table#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$pe_create_section_table DD @imagerel(pe_create_section_table#+37)
	DD	@imagerel(pe_create_section_table#+523)
	DD	@imagerel($chain$2$pe_create_section_table#)
pdata	ENDS
xdata	SEGMENT
$chain$3$pe_create_section_table DD 021H
	DD	@imagerel(pe_create_section_table#)
	DD	@imagerel(pe_create_section_table#+37)
	DD	@imagerel($unwind$pe_create_section_table#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$pe_create_section_table DD @imagerel(pe_create_section_table#+523)
	DD	@imagerel(pe_create_section_table#+538)
	DD	@imagerel($chain$3$pe_create_section_table#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pe_create_section_table PROC NEAR

; 806  : {

	sub	rsp, 56					; 00000038H
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+88], rdi

; 807  :     int i;
; 808  :     struct dsym *objtab;
; 809  :     struct dsym *curr;
; 810  :     int bCreated = FALSE;

	xor	edi, edi

; 811  :     int objs;
; 812  : 
; 813  :     DebugMsg(("pe_create_section table enter\n" ));
; 814  :     if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, edi
	mov	ebx, edi
	jne	$LN1@pe_create_@3

; 815  :         objtab = ( struct dsym *)SymSearch( hdrname "3" );

	lea	rcx, OFFSET FLAT:$SG6351
	mov	QWORD PTR [rsp+80], rsi
	call	SymFind

; 816  :         if ( !objtab ) {

	test	rax, rax
	mov	rsi, rax
	jne	SHORT $LN25@pe_create_@3

; 817  :             bCreated = TRUE;
; 818  :             objtab = (struct dsym *)CreateIntSegment( hdrname "3", "HDR", 2, ModuleInfo.defOfssize, TRUE );

	movzx	r9d, BYTE PTR ModuleInfo+405
	lea	rdx, OFFSET FLAT:$SG6354
	lea	rcx, OFFSET FLAT:$SG6355
	mov	ebx, 1
	mov	r8b, 2
	mov	BYTE PTR [rsp+32], bl
	call	CreateIntSegment

; 819  :             objtab->e.seginfo->group = &ModuleInfo.flat_grp->sym;

	mov	rcx, QWORD PTR [rax+104]
	mov	rsi, rax
	mov	rax, QWORD PTR ModuleInfo+440
	mov	QWORD PTR [rcx], rax

; 820  :             objtab->e.seginfo->combine = COMB_ADDOFF;  /* PUBLIC */

	mov	rcx, QWORD PTR [rsi+104]
	movzx	eax, BYTE PTR [rcx+108]
	and	al, 250					; 000000faH
	or	al, 2
	mov	BYTE PTR [rcx+108], al
$LN25@pe_create_@3:

; 821  :         }
; 822  :         objtab->e.seginfo->segtype = SEGTYPE_HDR;
; 823  : 
; 824  :         if ( !bCreated )

	test	ebx, ebx
	mov	rax, QWORD PTR [rsi+104]
	mov	r11d, 6
	mov	DWORD PTR [rax+72], r11d
	je	$LN42@pe_create_@3

; 825  :             return;
; 826  : 
; 827  :         /* before objects can be counted, the segment types
; 828  :          * SEGTYPE_CDATA ( for readonly segments ) &
; 829  :          * SEGTYPE_RSRC ( for resource segments )
; 830  :          * SEGTYPE_RELOC ( for relocations )
; 831  :          * must be set  - also, init lname_idx field
; 832  :          */
; 833  :         for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	r10, QWORD PTR SymTables+32
	test	r10, r10
	je	$LN21@pe_create_@3
	npad	12
$LL23@pe_create_@3:

; 834  :             curr->e.seginfo->lname_idx = SEGTYPE_ERROR; /* use the highest index possible */

	mov	rax, QWORD PTR [r10+104]
	mov	DWORD PTR [rax+76], 10

; 835  :             if ( curr->e.seginfo->segtype == SEGTYPE_DATA ) {

	mov	rax, QWORD PTR [r10+104]
	cmp	DWORD PTR [rax+72], 2
	jne	SHORT $LN20@pe_create_@3

; 836  :                 if ( curr->e.seginfo->readonly || curr->e.seginfo->characteristics == CHAR_READONLY )

	test	BYTE PTR [rax+107], 1
	mov	r8, rax
	jne	SHORT $LN18@pe_create_@3
	cmp	BYTE PTR [rax+105], 64			; 00000040H
	je	SHORT $LN18@pe_create_@3

; 838  :                 else if ( curr->e.seginfo->clsym && strcmp( curr->e.seginfo->clsym->name, "CONST" ) == 0 )

	mov	rax, QWORD PTR [rax+80]
	test	rax, rax
	je	$LN22@pe_create_@3
	mov	rax, QWORD PTR [rax+8]
	lea	r9, OFFSET FLAT:$SG6365
	sub	r9, rax
	npad	1
$LL40@pe_create_@3:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r9]
	sub	edx, ecx
	jne	SHORT $LN41@pe_create_@3
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL40@pe_create_@3
$LN41@pe_create_@3:
	test	edx, edx
	jne	$LN22@pe_create_@3

; 839  :                     curr->e.seginfo->segtype = SEGTYPE_CDATA;

	mov	DWORD PTR [r8+72], 7
	jmp	SHORT $LN22@pe_create_@3
$LN18@pe_create_@3:

; 837  :                     curr->e.seginfo->segtype = SEGTYPE_CDATA;

	mov	DWORD PTR [rax+72], 7

; 840  :             } else if ( curr->e.seginfo->segtype == SEGTYPE_UNDEF ) {

	jmp	SHORT $LN22@pe_create_@3
$LN20@pe_create_@3:
	cmp	DWORD PTR [rax+72], edi
	mov	r9, rax
	jne	SHORT $LN22@pe_create_@3

; 841  :                 if ( ( memcmp( curr->sym.name, ".rsrc", 5 ) == 0 ) &&
; 842  :                     ( *(curr->sym.name+5) == NULLC || *(curr->sym.name+5) == '$' ) )

	mov	rcx, QWORD PTR [r10+8]
	lea	rdx, OFFSET FLAT:$SG6369
	mov	r8d, DWORD PTR [rcx]
	cmp	r8d, DWORD PTR [rdx]
	jne	SHORT $LN38@pe_create_@3
	mov	r8b, BYTE PTR [rcx+4]
	cmp	r8b, BYTE PTR [rdx+4]
	jne	SHORT $LN38@pe_create_@3
	mov	eax, edi
	jmp	SHORT $LN39@pe_create_@3
$LN38@pe_create_@3:
	sbb	eax, eax
	sbb	eax, -1
$LN39@pe_create_@3:
	test	eax, eax
	jne	SHORT $LN13@pe_create_@3
	movzx	eax, BYTE PTR [rcx+5]
	test	al, al
	je	SHORT $LN12@pe_create_@3
	cmp	al, 36					; 00000024H
	jne	SHORT $LN13@pe_create_@3
$LN12@pe_create_@3:

; 843  :                     curr->e.seginfo->segtype = SEGTYPE_RSRC;

	mov	DWORD PTR [r9+72], 9
	jmp	SHORT $LN22@pe_create_@3
$LN13@pe_create_@3:

; 844  :                 else if ( strcmp( curr->sym.name, ".reloc" ) == 0 )

	lea	r8, OFFSET FLAT:$SG6373
	sub	r8, rcx
$LL36@pe_create_@3:
	movzx	edx, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rcx+r8]
	sub	edx, eax
	jne	SHORT $LN37@pe_create_@3
	inc	rcx
	test	eax, eax
	jne	SHORT $LL36@pe_create_@3
$LN37@pe_create_@3:
	test	edx, edx
	jne	SHORT $LN22@pe_create_@3

; 845  :                     curr->e.seginfo->segtype = SEGTYPE_RELOC;

	mov	DWORD PTR [r9+72], 8
$LN22@pe_create_@3:

; 825  :             return;
; 826  : 
; 827  :         /* before objects can be counted, the segment types
; 828  :          * SEGTYPE_CDATA ( for readonly segments ) &
; 829  :          * SEGTYPE_RSRC ( for resource segments )
; 830  :          * SEGTYPE_RELOC ( for relocations )
; 831  :          * must be set  - also, init lname_idx field
; 832  :          */
; 833  :         for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	r10, QWORD PTR [r10+112]
	test	r10, r10
	jne	$LL23@pe_create_@3
	mov	r10, QWORD PTR SymTables+32
$LN21@pe_create_@3:

; 846  :             }
; 847  :         }
; 848  : 
; 849  :         /* count objects ( without header types ) */
; 850  :         for ( i = 1, objs = 0; i < SIZE_PEFLAT; i++ ) {

	lea	r8, OFFSET FLAT:flat_order+4
	npad	6
$LL9@pe_create_@3:

; 851  :             DebugMsg(("pe_create_section_table: searching type %u\n", flat_order[i] ));
; 852  :             for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	test	r10, r10
	mov	rcx, r10
	je	SHORT $LN8@pe_create_@3
	mov	edx, DWORD PTR [r8]
	npad	5
$LL6@pe_create_@3:

; 853  :                 DebugMsg(("pe_create_section_table: section %s, type=%u, size=%X\n", curr->sym.name, curr->e.seginfo->segtype, curr->sym.max_offset ));
; 854  :                 if ( curr->e.seginfo->segtype != flat_order[i] )

	mov	rax, QWORD PTR [rcx+104]
	cmp	DWORD PTR [rax+72], edx
	jne	SHORT $LN5@pe_create_@3

; 855  :                     continue;
; 856  :                 if ( curr->sym.max_offset ) {

	cmp	DWORD PTR [rcx+64], 0
	jne	SHORT $LN32@pe_create_@3
$LN5@pe_create_@3:

; 851  :             DebugMsg(("pe_create_section_table: searching type %u\n", flat_order[i] ));
; 852  :             for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rcx, QWORD PTR [rcx+112]
	test	rcx, rcx
	jne	SHORT $LL6@pe_create_@3

; 855  :                     continue;
; 856  :                 if ( curr->sym.max_offset ) {

	jmp	SHORT $LN8@pe_create_@3
$LN32@pe_create_@3:

; 857  :                     DebugMsg(("pe_create_section_table: %s, type=%u is object %u\n", curr->sym.name, curr->e.seginfo->segtype, objs ));
; 858  :                     objs++;

	inc	edi
$LN8@pe_create_@3:

; 846  :             }
; 847  :         }
; 848  : 
; 849  :         /* count objects ( without header types ) */
; 850  :         for ( i = 1, objs = 0; i < SIZE_PEFLAT; i++ ) {

	add	r8, 4
	dec	r11
	jne	SHORT $LL9@pe_create_@3

; 859  :                     break;
; 860  :                 }
; 861  :             }
; 862  :         }
; 863  :         if ( objs ) {

	test	edi, edi
	je	SHORT $LN42@pe_create_@3

; 864  :             DebugMsg(("pe_create_section_table: items in object table: %u\n", objs ));
; 865  :             objtab->sym.max_offset = sizeof(struct IMAGE_SECTION_HEADER) * objs;

	lea	eax, DWORD PTR [rdi+rdi*4]
	shl	eax, 3

; 866  :             /* alloc space for 1 more section (.reloc) */
; 867  :             objtab->e.seginfo->CodeBuffer = LclAlloc( objtab->sym.max_offset + sizeof(struct IMAGE_SECTION_HEADER) );

	movsxd	rcx, eax
	mov	DWORD PTR [rsi+64], eax
	add	rcx, 40					; 00000028H
	call	LclAlloc
	mov	rcx, QWORD PTR [rsi+104]
	mov	QWORD PTR [rcx+16], rax
$LN42@pe_create_@3:
	mov	rsi, QWORD PTR [rsp+80]
$LN1@pe_create_@3:
	mov	rdi, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+72]

; 868  :         }
; 869  :     }
; 870  : }

	add	rsp, 56					; 00000038H
	ret	0
pe_create_section_table ENDP
; Function compile flags: /Ogtpy
p1$ = 8
p2$ = 16
compare_exp PROC NEAR

; 896  :     return( strcmp( ((struct expitem *)p1)->name, ((struct expitem *)p2)->name ) );

	mov	rax, QWORD PTR [rcx]
	mov	r8, QWORD PTR [rdx]
	sub	r8, rax
	npad	7
$LL3@compare_ex:
	movzx	ecx, BYTE PTR [rax]
	cmp	cl, BYTE PTR [rax+r8]
	jne	SHORT $LN5@compare_ex
	inc	rax
	test	cl, cl
	jne	SHORT $LL3@compare_ex
	xor	eax, eax

; 897  : }

	ret	0
$LN5@compare_ex:

; 896  :     return( strcmp( ((struct expitem *)p1)->name, ((struct expitem *)p2)->name ) );

	sbb	eax, eax
	sbb	eax, -1

; 897  : }

	ret	0
compare_exp ENDP
_TEXT	ENDS
EXTRN	Options:BYTE
EXTRN	Mangle:NEAR
EXTRN	qsort:NEAR
EXTRN	__chkstk:NEAR
xdata	SEGMENT
$unwind$pe_emit_export_data DD 0750e2e01H
	DD	011d42eH
	DD	017c42aH
	DD	0167421H
	DD	015641dH
	DD	0143419H
	DD	0109730eH
	DD	050020012H
xdata	ENDS
pdata	SEGMENT
$pdata$pe_emit_export_data DD @imagerel(pe_emit_export_data#)
	DD	@imagerel(pe_emit_export_data#+803)
	DD	@imagerel($unwind$pe_emit_export_data#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
timedate$ = 0
pe_emit_export_data PROC NEAR

; 901  : {

	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+112]

; 902  :     struct dsym *curr;
; 903  :     int_32 timedate;
; 904  :     int cnt;
; 905  :     int i;
; 906  :     char *name;
; 907  :     char *fname;
; 908  :     struct expitem *pitems;
; 909  :     struct expitem *pexp;
; 910  : 
; 911  :     DebugMsg(("pe_emit_export_data enter\n" ));
; 912  :     for( curr = SymTables[TAB_PROC].head, cnt = 0; curr; curr = curr->nextproc ) {

	mov	rcx, QWORD PTR SymTables+64
	mov	QWORD PTR [rbp+48], rbx
	mov	QWORD PTR [rbp+56], rsi
	mov	QWORD PTR [rbp+64], rdi
	xor	edi, edi
	test	rcx, rcx
	mov	QWORD PTR [rbp+72], r12
	mov	QWORD PTR [rbp+24], r13
	mov	ebx, edi
	je	$LN24@pe_emit_ex
	npad	10
$LL28@pe_emit_ex:

; 913  :         if( curr->e.procinfo->isexport )

	mov	rax, QWORD PTR [rcx+104]
	test	BYTE PTR [rax+128], 4
	je	SHORT $LN27@pe_emit_ex

; 914  :             cnt++;

	inc	ebx
$LN27@pe_emit_ex:

; 902  :     struct dsym *curr;
; 903  :     int_32 timedate;
; 904  :     int cnt;
; 905  :     int i;
; 906  :     char *name;
; 907  :     char *fname;
; 908  :     struct expitem *pitems;
; 909  :     struct expitem *pexp;
; 910  : 
; 911  :     DebugMsg(("pe_emit_export_data enter\n" ));
; 912  :     for( curr = SymTables[TAB_PROC].head, cnt = 0; curr; curr = curr->nextproc ) {

	mov	rcx, QWORD PTR [rcx+120]
	test	rcx, rcx
	jne	SHORT $LL28@pe_emit_ex

; 915  :     }
; 916  :     if ( cnt ) {

	test	ebx, ebx
	je	$LN24@pe_emit_ex

; 917  :         name = ModuleInfo.name;
; 918  :         AddLineQueueX( "%r DOTNAME", T_OPTION );

	lea	rcx, OFFSET FLAT:$SG6412
	mov	edx, 452				; 000001c4H
	call	AddLineQueueX

; 919  :         /* create .edata segment */
; 920  :         AddLineQueueX( "%s %r %r %s", edataname, T_SEGMENT, T_DWORD, edataattr );

	lea	r11, OFFSET FLAT:edataattr
	lea	rdx, OFFSET FLAT:edataname
	lea	rcx, OFFSET FLAT:$SG6413
	mov	r9d, 209				; 000000d1H
	mov	r8d, 441				; 000001b9H
	mov	QWORD PTR [rsp+32], r11
	call	AddLineQueueX

; 921  : #if 0 //def __UNIX__
; 922  :         time( &timedate );
; 923  : #else
; 924  :         time( (time_t *)&timedate );

	lea	rcx, QWORD PTR timedate$[rbp]
	call	time

; 925  : #endif
; 926  :         /* create export directory: Characteristics, Timedate, MajMin, Name, Base, ... */
; 927  :         AddLineQueueX( "DD 0, 0%xh, 0, %r @%s_name, %u, %u, %u, %r @%s_func, %r @%s_names, %r @%s_nameord",
; 928  :                       timedate, T_IMAGEREL, name, 1, cnt, cnt, T_IMAGEREL, name, T_IMAGEREL, name, T_IMAGEREL, name );

	mov	edx, DWORD PTR timedate$[rbp]
	lea	r13, OFFSET FLAT:ModuleInfo+512
	mov	QWORD PTR [rsp+96], r13
	mov	DWORD PTR [rsp+88], 233			; 000000e9H
	mov	QWORD PTR [rsp+80], r13
	mov	DWORD PTR [rsp+72], 233			; 000000e9H
	mov	QWORD PTR [rsp+64], r13
	mov	DWORD PTR [rsp+56], 233			; 000000e9H
	mov	DWORD PTR [rsp+48], ebx
	lea	rcx, OFFSET FLAT:$SG6415
	mov	r9, r13
	mov	r8d, 233				; 000000e9H
	mov	DWORD PTR [rsp+40], ebx
	mov	DWORD PTR [rsp+32], 1
	call	AddLineQueueX

; 929  : 
; 930  :         /* the name pointer table must be in ascending order!
; 931  :          * so we have to fill an array of exports and sort it.
; 932  :          */
; 933  :         pitems = (struct expitem *)myalloca( cnt * sizeof( struct expitem ) );

	movsxd	rbx, ebx
	mov	rax, rbx
	shl	rax, 4
	add	rax, 15
	and	rax, -16
	call	__chkstk

; 934  :         for( curr = SymTables[TAB_PROC].head, pexp = pitems, i = 0; curr; curr = curr->nextproc ) {

	mov	rcx, QWORD PTR SymTables+64
	sub	rsp, rax
	test	rcx, rcx
	lea	r12, QWORD PTR [rsp+112]
	mov	rdx, r12
	je	SHORT $LN21@pe_emit_ex
	npad	7
$LL23@pe_emit_ex:

; 935  :             if( curr->e.procinfo->isexport ) {

	mov	rax, QWORD PTR [rcx+104]
	test	BYTE PTR [rax+128], 4
	je	SHORT $LN22@pe_emit_ex

; 936  :                 pexp->name = curr->sym.name;

	mov	rax, QWORD PTR [rcx+8]

; 937  :                 pexp->idx  = i++;

	mov	DWORD PTR [rdx+8], edi
	inc	edi
	mov	QWORD PTR [rdx], rax

; 938  :                 pexp++;

	add	rdx, 16
$LN22@pe_emit_ex:
	mov	rcx, QWORD PTR [rcx+120]
	test	rcx, rcx
	jne	SHORT $LL23@pe_emit_ex
$LN21@pe_emit_ex:

; 939  :             }
; 940  :         }
; 941  :         qsort( pitems, cnt, sizeof( struct expitem ), compare_exp );

	lea	r9, OFFSET FLAT:compare_exp
	mov	r8d, 16
	mov	rdx, rbx
	mov	rcx, r12
	call	qsort

; 942  : 
; 943  :         /* emit export address table.
; 944  :          * would be possible to just use the array of sorted names,
; 945  :          * but we want to emit the EAT being sorted by address.
; 946  :          */
; 947  :         AddLineQueueX( "@%s_func %r DWORD", name, T_LABEL );

	lea	rcx, OFFSET FLAT:$SG6423
	mov	r8d, 436				; 000001b4H
	mov	rdx, r13
	call	AddLineQueueX

; 948  :         for( curr = SymTables[TAB_PROC].head; curr; curr = curr->nextproc ) {

	mov	rdi, QWORD PTR SymTables+64
	test	rdi, rdi
	je	SHORT $LN17@pe_emit_ex
	npad	1
$LL19@pe_emit_ex:

; 949  :             if( curr->e.procinfo->isexport )

	mov	rax, QWORD PTR [rdi+104]
	test	BYTE PTR [rax+128], 4
	je	SHORT $LN18@pe_emit_ex

; 950  :                 AddLineQueueX( "DD %r %s", T_IMAGEREL, curr->sym.name );

	mov	r8, QWORD PTR [rdi+8]
	lea	rcx, OFFSET FLAT:$SG6428
	mov	edx, 233				; 000000e9H
	call	AddLineQueueX
$LN18@pe_emit_ex:
	mov	rdi, QWORD PTR [rdi+120]
	test	rdi, rdi
	jne	SHORT $LL19@pe_emit_ex
$LN17@pe_emit_ex:

; 951  :         }
; 952  : 
; 953  :         /* emit the name pointer table */
; 954  :         AddLineQueueX( "@%s_names %r DWORD", name, T_LABEL );

	lea	rcx, OFFSET FLAT:$SG6429
	mov	r8d, 436				; 000001b4H
	mov	rdx, r13
	call	AddLineQueueX

; 955  :         for ( i = 0; i < cnt; i++ )

	test	rbx, rbx
	jle	SHORT $LN13@pe_emit_ex
	mov	rdi, r12
	mov	rsi, rbx
	npad	5
$LL15@pe_emit_ex:

; 956  :             AddLineQueueX( "DD %r @%s", T_IMAGEREL, (pitems+i)->name );

	mov	r8, QWORD PTR [rdi]
	lea	rcx, OFFSET FLAT:$SG6433
	mov	edx, 233				; 000000e9H
	call	AddLineQueueX
	add	rdi, 16
	dec	rsi
	jne	SHORT $LL15@pe_emit_ex
$LN13@pe_emit_ex:

; 957  : 
; 958  :         /* ordinal table. each ordinal is an index into the export address table */
; 959  :         AddLineQueueX( "@%s_nameord %r WORD", name, T_LABEL );

	lea	rcx, OFFSET FLAT:$SG6434
	mov	r8d, 436				; 000001b4H
	mov	rdx, r13
	call	AddLineQueueX

; 960  :         for( i = 0; i < cnt; i++ ) {

	test	rbx, rbx
	jle	SHORT $LN10@pe_emit_ex

; 957  : 
; 958  :         /* ordinal table. each ordinal is an index into the export address table */
; 959  :         AddLineQueueX( "@%s_nameord %r WORD", name, T_LABEL );

	lea	rdi, QWORD PTR [r12+8]
	npad	4
$LL12@pe_emit_ex:

; 961  :             AddLineQueueX( "DW %u", (pitems+i)->idx );

	mov	edx, DWORD PTR [rdi]
	lea	rcx, OFFSET FLAT:$SG6438
	call	AddLineQueueX
	add	rdi, 16
	dec	rbx
	jne	SHORT $LL12@pe_emit_ex
$LN10@pe_emit_ex:

; 962  :         }
; 963  :         /* v2.10: name+ext of dll */
; 964  :         //AddLineQueueX( "@%s_name DB '%s',0", name, name );
; 965  :         for ( fname = CurrFName[OBJ] + strlen( CurrFName[OBJ] ); fname > CurrFName[OBJ]; fname-- )

	mov	rdx, QWORD PTR ModuleInfo+136
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rdx
	repne scasb
	not	rcx
	dec	rcx
	add	rcx, rdx
	cmp	rcx, rdx
	jbe	SHORT $LN40@pe_emit_ex
	npad	6
$LL9@pe_emit_ex:

; 966  :             if ( *fname == '/' || *fname == '\\' || *fname == ':' )

	movzx	eax, BYTE PTR [rcx]
	cmp	al, 47					; 0000002fH
	je	SHORT $LN40@pe_emit_ex
	cmp	al, 92					; 0000005cH
	je	SHORT $LN40@pe_emit_ex
	cmp	al, 58					; 0000003aH
	je	SHORT $LN40@pe_emit_ex
	dec	rcx
	cmp	rcx, rdx
	ja	SHORT $LL9@pe_emit_ex
$LN40@pe_emit_ex:

; 967  :                 break;
; 968  :         AddLineQueueX( "@%s_name DB '%s',0", name, fname );

	mov	r8, rcx
	lea	rcx, OFFSET FLAT:$SG6444
	mov	rdx, r13
	call	AddLineQueueX

; 969  : 
; 970  :         for( curr = SymTables[TAB_PROC].head; curr; curr = curr->nextproc ) {

	mov	rdi, QWORD PTR SymTables+64
	test	rdi, rdi
	je	SHORT $LN2@pe_emit_ex
	npad	11
$LL4@pe_emit_ex:

; 971  :             if( curr->e.procinfo->isexport ) {

	mov	rax, QWORD PTR [rdi+104]
	test	BYTE PTR [rax+128], 4
	je	SHORT $LN3@pe_emit_ex

; 972  :                 Mangle( &curr->sym, StringBufferEnd );

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, rdi
	call	Mangle

; 973  :                 AddLineQueueX( "@%s DB '%s',0", curr->sym.name, Options.no_export_decoration ? curr->sym.name : StringBufferEnd );

	cmp	BYTE PTR Options+127, 0
	je	SHORT $LN31@pe_emit_ex
	mov	r8, QWORD PTR [rdi+8]
	jmp	SHORT $LN32@pe_emit_ex
$LN31@pe_emit_ex:
	mov	r8, QWORD PTR ModuleInfo+488
$LN32@pe_emit_ex:
	mov	rdx, QWORD PTR [rdi+8]
	lea	rcx, OFFSET FLAT:$SG6449
	call	AddLineQueueX
$LN3@pe_emit_ex:
	mov	rdi, QWORD PTR [rdi+120]
	test	rdi, rdi
	jne	SHORT $LL4@pe_emit_ex
$LN2@pe_emit_ex:

; 974  :             }
; 975  :         }
; 976  :         /* exit .edata segment */
; 977  :         AddLineQueueX( "%s %r", edataname, T_ENDS );

	lea	rdx, OFFSET FLAT:edataname
	lea	rcx, OFFSET FLAT:$SG6450
	mov	r8d, 442				; 000001baH
	call	AddLineQueueX

; 978  :         RunLineQueue();

	call	RunLineQueue
$LN24@pe_emit_ex:

; 979  :     }
; 980  : }

	mov	rbx, QWORD PTR [rbp+48]
	mov	rsi, QWORD PTR [rbp+56]
	mov	rdi, QWORD PTR [rbp+64]
	mov	r12, QWORD PTR [rbp+72]
	mov	r13, QWORD PTR [rbp+24]
	lea	rsp, QWORD PTR [rbp+32]
	pop	rbp
	ret	0
pe_emit_export_data ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$pe_emit_import_data DD 010701H
	DD	0c207H
xdata	ENDS
pdata	SEGMENT
$pdata$pe_emit_import_data DD @imagerel(pe_emit_import_data#)
	DD	@imagerel(pe_emit_import_data#+14)
	DD	@imagerel($unwind$pe_emit_import_data#)
pdata	ENDS
xdata	SEGMENT
$chain$4$pe_emit_import_data DD 0a3221H
	DD	09f432H
	DD	0ae41cH
	DD	0bd413H
	DD	0cc40fH
	DD	0117404H
	DD	@imagerel(pe_emit_import_data#)
	DD	@imagerel(pe_emit_import_data#+14)
	DD	@imagerel($unwind$pe_emit_import_data#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$pe_emit_import_data DD @imagerel(pe_emit_import_data#+14)
	DD	@imagerel(pe_emit_import_data#+97)
	DD	@imagerel($chain$4$pe_emit_import_data#)
pdata	ENDS
xdata	SEGMENT
$chain$7$pe_emit_import_data DD 060c21H
	DD	010640cH
	DD	0f5408H
	DD	0e3404H
	DD	@imagerel(pe_emit_import_data#+14)
	DD	@imagerel(pe_emit_import_data#+97)
	DD	@imagerel($chain$4$pe_emit_import_data#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$pe_emit_import_data DD @imagerel(pe_emit_import_data#+97)
	DD	@imagerel(pe_emit_import_data#+865)
	DD	@imagerel($chain$7$pe_emit_import_data#)
pdata	ENDS
xdata	SEGMENT
$chain$8$pe_emit_import_data DD 021H
	DD	@imagerel(pe_emit_import_data#+14)
	DD	@imagerel(pe_emit_import_data#+97)
	DD	@imagerel($chain$4$pe_emit_import_data#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$pe_emit_import_data DD @imagerel(pe_emit_import_data#+865)
	DD	@imagerel(pe_emit_import_data#+898)
	DD	@imagerel($chain$8$pe_emit_import_data#)
pdata	ENDS
xdata	SEGMENT
$chain$9$pe_emit_import_data DD 020021H
	DD	09f400H
	DD	@imagerel(pe_emit_import_data#)
	DD	@imagerel(pe_emit_import_data#+14)
	DD	@imagerel($unwind$pe_emit_import_data#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$pe_emit_import_data DD @imagerel(pe_emit_import_data#+898)
	DD	@imagerel(pe_emit_import_data#+986)
	DD	@imagerel($chain$9$pe_emit_import_data#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pe_emit_import_data PROC NEAR

; 993  : {

	mov	r11, rsp
	sub	rsp, 104				; 00000068H

; 994  :     struct dll_desc *p;
; 995  :     int type = 0;
; 996  : #if AMD64_SUPPORT
; 997  :     int ptrtype = ( ModuleInfo.defOfssize == USE64 ? T_QWORD : T_DWORD );

	movzx	eax, BYTE PTR ModuleInfo+405
	mov	QWORD PTR [r11+32], rdi

; 998  :     char *align = ( ModuleInfo.defOfssize == USE64 ? "ALIGN(8)" : "ALIGN(4)" );
; 999  : #else
; 1000 :     int ptrtype = T_DWORD;
; 1001 :     char *align = "DWORD";
; 1002 : #endif
; 1003 : 
; 1004 :     DebugMsg(("pe_emit_import_data enter\n" ));
; 1005 :     for ( p = ModuleInfo.g.DllQueue; p; p = p->next ) {

	mov	rdi, QWORD PTR ModuleInfo+80
	mov	QWORD PTR [r11-8], r12
	mov	QWORD PTR [r11-16], r13
	xor	r12d, r12d
	cmp	al, 2
	mov	QWORD PTR [r11-24], r14
	mov	ecx, 213				; 000000d5H
	mov	r13d, 209				; 000000d1H
	lea	r14, OFFSET FLAT:$SG6459
	mov	QWORD PTR [r11-32], r15
	cmove	r13d, ecx
	cmp	al, 2
	lea	rcx, OFFSET FLAT:$SG6458
	cmove	r14, rcx
	test	rdi, rdi
	lea	r15, OFFSET FLAT:idataattr
	je	$LN19@pe_emit_im
	mov	QWORD PTR [r11+8], rbx
	mov	QWORD PTR [r11+16], rbp
	mov	QWORD PTR [r11+24], rsi
	npad	3
$LL21@pe_emit_im:

; 1006 :         if ( p->cnt ) {

	cmp	DWORD PTR [rdi+8], 0
	je	$LN20@pe_emit_im

; 1007 :             struct dsym *curr;
; 1008 :             char *pdot;
; 1009 :             if ( !type ) {

	test	r12d, r12d
	jne	SHORT $LN17@pe_emit_im

; 1010 :                 type = 1;
; 1011 :                 AddLineQueueX( "@LPPROC %r %r %r", T_TYPEDEF, T_PTR, T_PROC );

	mov	edx, 425				; 000001a9H
	lea	rcx, OFFSET FLAT:$SG6467
	mov	r8d, 258				; 00000102H
	lea	r9d, QWORD PTR [rdx+8]
	mov	r12d, 1
	call	AddLineQueueX

; 1012 :                 AddLineQueueX( "%r DOTNAME", T_OPTION );

	lea	rcx, OFFSET FLAT:$SG6468
	mov	edx, 452				; 000001c4H
	call	AddLineQueueX
$LN17@pe_emit_im:

; 1013 :             }
; 1014 : 
; 1015 :             /* avoid . in IDs */
; 1016 :             if ( pdot = strchr( p->name, '.') )

	lea	rbp, QWORD PTR [rdi+12]
	mov	edx, 46					; 0000002eH
	mov	rcx, rbp
	call	strchr
	test	rax, rax
	mov	rsi, rax
	je	SHORT $LN16@pe_emit_im

; 1017 :                 *pdot = '_';

	mov	BYTE PTR [rax], 95			; 0000005fH
$LN16@pe_emit_im:

; 1018 : 
; 1019 :             /* import directory entry */
; 1020 :             AddLineQueueX( "%s" IMPDIRSUF " %r %r %s", idataname, T_SEGMENT, T_DWORD, idataattr );

	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG6470
	mov	r9d, 209				; 000000d1H
	mov	r8d, 441				; 000001b9H
	mov	QWORD PTR [rsp+32], r15
	call	AddLineQueueX

; 1021 :             AddLineQueueX( "DD %r @%s_ilt, 0, 0, %r @%s_name, %r @%s_iat", T_IMAGEREL, p->name, T_IMAGEREL, p->name, T_IMAGEREL, p->name );

	mov	r9d, 233				; 000000e9H
	mov	QWORD PTR [rsp+48], rbp
	lea	rcx, OFFSET FLAT:$SG6471
	mov	edx, r9d
	mov	r8, rbp
	mov	DWORD PTR [rsp+40], 233			; 000000e9H
	mov	QWORD PTR [rsp+32], rbp
	call	AddLineQueueX

; 1022 :             AddLineQueueX( "%s" IMPDIRSUF " %r", idataname, T_ENDS );

	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG6472
	mov	r8d, 442				; 000001baH
	call	AddLineQueueX

; 1023 : 
; 1024 :             /* emit ILT */
; 1025 :             AddLineQueueX( "%s" IMPILTSUF " %r %s %s", idataname, T_SEGMENT, align, idataattr );

	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG6473
	mov	r9, r14
	mov	r8d, 441				; 000001b9H
	mov	QWORD PTR [rsp+32], r15
	call	AddLineQueueX

; 1026 :             AddLineQueueX( "@%s_ilt label %r", p->name, ptrtype );

	lea	rcx, OFFSET FLAT:$SG6474
	mov	r8d, r13d
	mov	rdx, rbp
	call	AddLineQueueX

; 1027 :             for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+16
	test	rbx, rbx
	je	SHORT $LN13@pe_emit_im
$LL15@pe_emit_im:

; 1028 :                 if ( curr->sym.iat_used && curr->sym.dll == p ) {

	test	BYTE PTR [rbx+48], 8
	je	SHORT $LN14@pe_emit_im
	cmp	QWORD PTR [rbx+64], rdi
	jne	SHORT $LN14@pe_emit_im

; 1029 :                     AddLineQueueX( "@LPPROC %r @%s_name", T_IMAGEREL, curr->sym.name );

	mov	r8, QWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:$SG6480
	mov	edx, 233				; 000000e9H
	call	AddLineQueueX
$LN14@pe_emit_im:
	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL15@pe_emit_im
$LN13@pe_emit_im:

; 1030 :                 }
; 1031 :             }
; 1032 :             /* ILT termination entry */
; 1033 :             AddLineQueueX( "@LPPROC 0" );

	lea	rcx, OFFSET FLAT:$SG6481
	call	AddLineQueueX

; 1034 :             AddLineQueueX( "%s" IMPILTSUF " %r", idataname, T_ENDS );

	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG6482
	mov	r8d, 442				; 000001baH
	call	AddLineQueueX

; 1035 : 
; 1036 :             /* emit IAT */
; 1037 :             AddLineQueueX( "%s" IMPIATSUF " %r %s %s", idataname, T_SEGMENT, align, idataattr );

	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG6483
	mov	r9, r14
	mov	r8d, 441				; 000001b9H
	mov	QWORD PTR [rsp+32], r15
	call	AddLineQueueX

; 1038 :             AddLineQueueX( "@%s_iat label %r", p->name, ptrtype );

	lea	rcx, OFFSET FLAT:$SG6484
	mov	r8d, r13d
	mov	rdx, rbp
	call	AddLineQueueX

; 1039 : 
; 1040 :             for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+16
	test	rbx, rbx
	je	SHORT $LN9@pe_emit_im
$LL11@pe_emit_im:

; 1041 :                 if ( curr->sym.iat_used && curr->sym.dll == p ) {

	test	BYTE PTR [rbx+48], 8
	je	SHORT $LN10@pe_emit_im
	cmp	QWORD PTR [rbx+64], rdi
	jne	SHORT $LN10@pe_emit_im

; 1042 :                     Mangle( &curr->sym, StringBufferEnd );

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, rbx
	call	Mangle

; 1043 :                     AddLineQueueX( "%s%s @LPPROC %r @%s_name", ModuleInfo.g.imp_prefix, StringBufferEnd, T_IMAGEREL, curr->sym.name );

	mov	r11, QWORD PTR [rbx+8]
	mov	r8, QWORD PTR ModuleInfo+488
	mov	rdx, QWORD PTR ModuleInfo+88
	lea	rcx, OFFSET FLAT:$SG6490
	mov	r9d, 233				; 000000e9H
	mov	QWORD PTR [rsp+32], r11
	call	AddLineQueueX
$LN10@pe_emit_im:
	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL11@pe_emit_im
$LN9@pe_emit_im:

; 1044 :                 }
; 1045 :             }
; 1046 :             /* IAT termination entry */
; 1047 :             AddLineQueueX( "@LPPROC 0" );

	lea	rcx, OFFSET FLAT:$SG6491
	call	AddLineQueueX

; 1048 :             AddLineQueueX( "%s" IMPIATSUF " %r", idataname, T_ENDS );

	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG6492
	mov	r8d, 442				; 000001baH
	call	AddLineQueueX

; 1049 : 
; 1050 :             /* emit name table */
; 1051 :             AddLineQueueX( "%s" IMPSTRSUF " %r %r %s", idataname, T_SEGMENT, T_WORD, idataattr );

	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG6493
	mov	r9d, 207				; 000000cfH
	mov	r8d, 441				; 000001b9H
	mov	QWORD PTR [rsp+32], r15
	call	AddLineQueueX

; 1052 :             for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+16
	test	rbx, rbx
	je	SHORT $LN5@pe_emit_im
$LL7@pe_emit_im:

; 1053 :                 if ( curr->sym.iat_used && curr->sym.dll == p ) {

	test	BYTE PTR [rbx+48], 8
	je	SHORT $LN6@pe_emit_im
	cmp	QWORD PTR [rbx+64], rdi
	jne	SHORT $LN6@pe_emit_im

; 1054 :                     AddLineQueueX( "@%s_name dw 0", curr->sym.name );

	mov	rdx, QWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:$SG6499
	call	AddLineQueueX

; 1055 :                     AddLineQueueX( "db '%s',0", curr->sym.name );

	mov	rdx, QWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:$SG6500
	call	AddLineQueueX

; 1056 :                     AddLineQueue( "even" );

	lea	rcx, OFFSET FLAT:$SG6501
	call	AddLineQueue
$LN6@pe_emit_im:
	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL7@pe_emit_im
$LN5@pe_emit_im:

; 1057 :                 }
; 1058 :             }
; 1059 :             /* dll name table entry */
; 1060 :             if ( pdot ) {

	test	rsi, rsi
	je	SHORT $LN3@pe_emit_im

; 1061 :                 *pdot = NULLC;
; 1062 :                 AddLineQueueX( "@%s_%s_name db '%s.%s',0", p->name, pdot+1, p->name, pdot+1 );

	lea	r8, QWORD PTR [rsi+1]
	lea	rcx, OFFSET FLAT:$SG6503
	mov	r9, rbp
	mov	rdx, rbp
	mov	BYTE PTR [rsi], 0
	mov	QWORD PTR [rsp+32], r8
	call	AddLineQueueX

; 1063 :                 *pdot = '.';  /* restore '.' in dll name */

	mov	BYTE PTR [rsi], 46			; 0000002eH

; 1064 :             } else

	jmp	SHORT $LN2@pe_emit_im
$LN3@pe_emit_im:

; 1065 :                 AddLineQueueX( "@%s_name db '%s',0", p->name, p->name );

	lea	rcx, OFFSET FLAT:$SG6505
	mov	r8, rbp
	mov	rdx, rbp
	call	AddLineQueueX
$LN2@pe_emit_im:

; 1066 : 
; 1067 :             AddLineQueue( "even" );

	lea	rcx, OFFSET FLAT:$SG6506
	call	AddLineQueue

; 1068 :             AddLineQueueX( "%s" IMPSTRSUF " %r", idataname, T_ENDS );

	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG6507
	mov	r8d, 442				; 000001baH
	call	AddLineQueueX
$LN20@pe_emit_im:
	mov	rdi, QWORD PTR [rdi]
	test	rdi, rdi
	jne	$LL21@pe_emit_im
	mov	rsi, QWORD PTR [rsp+128]
	mov	rbp, QWORD PTR [rsp+120]
	mov	rbx, QWORD PTR [rsp+112]
$LN19@pe_emit_im:

; 1069 : 
; 1070 :         }
; 1071 :     }
; 1072 :     if ( is_linequeue_populated() ) {

	cmp	QWORD PTR ModuleInfo+184, 0
	mov	r14, QWORD PTR [rsp+80]
	mov	r13, QWORD PTR [rsp+88]
	mov	r12, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+136]
	je	SHORT $LN1@pe_emit_im

; 1073 :         /* import directory NULL entry */
; 1074 :         AddLineQueueX( "%s" IMPNDIRSUF " %r %r %s", idataname, T_SEGMENT, T_DWORD, idataattr );

	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG6509
	mov	r9d, 209				; 000000d1H
	mov	r8d, 441				; 000001b9H
	mov	QWORD PTR [rsp+32], r15
	call	AddLineQueueX

; 1075 :         AddLineQueueX( "DD 0, 0, 0, 0, 0" );

	lea	rcx, OFFSET FLAT:$SG6510
	call	AddLineQueueX

; 1076 :         AddLineQueueX( "%s" IMPNDIRSUF " %r", idataname, T_ENDS );

	lea	rdx, OFFSET FLAT:idataname
	lea	rcx, OFFSET FLAT:$SG6511
	mov	r8d, 442				; 000001baH
	call	AddLineQueueX

; 1077 :         RunLineQueue();

	call	RunLineQueue
$LN1@pe_emit_im:
	mov	r15, QWORD PTR [rsp+72]

; 1078 :     }
; 1079 : }

	add	rsp, 104				; 00000068H
	ret	0
pe_emit_import_data ENDP
; Function compile flags: /Ogtpy
value$ = 8
get_bit	PROC NEAR

; 1084 :     int rc = -1;
; 1085 :     while( value ) {

	test	ecx, ecx
	mov	eax, -1
	je	SHORT $LN7@get_bit
	npad	7
$LL2@get_bit:

; 1086 :         value = (value >> 1);
; 1087 :         rc++;

	inc	eax
	sar	ecx, 1
	jne	SHORT $LL2@get_bit
$LN7@get_bit:

; 1088 :     }
; 1089 :     return( rc );
; 1090 : }

	ret	0
get_bit	ENDP
; Function compile flags: /Ogtpy
seg$ = 8
pe_get_characteristics PROC NEAR

; 1095 :     uint_32 result = 0;
; 1096 :     //if ( seg->e.seginfo->alignment != MAX_SEGALIGNMENT ) /* ABS not possible */
; 1097 :     //    result |= (uint_32)(seg->e.seginfo->alignment + 1) << 20;
; 1098 : 
; 1099 :     if ( seg->e.seginfo->segtype == SEGTYPE_CODE ) {

	mov	r8, QWORD PTR [rcx+104]
	mov	eax, DWORD PTR [r8+72]
	cmp	eax, 1
	jne	SHORT $LN11@pe_get_cha

; 1100 :         result |= IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ;

	mov	eax, 1610612768				; 60000020H
	jmp	SHORT $LN2@pe_get_cha
$LN11@pe_get_cha:

; 1101 :     } else if ( seg->e.seginfo->segtype == SEGTYPE_BSS ) {

	cmp	eax, 3
	jne	SHORT $LN9@pe_get_cha

; 1102 :         result |= IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

	mov	eax, -1073741696			; c0000080H
	jmp	SHORT $LN2@pe_get_cha
$LN9@pe_get_cha:

; 1103 :         /* ish.SizeOfRawData = 0; */
; 1104 :         //ish.PointerToRawData = 0;
; 1105 :     } else if ( seg->e.seginfo->combine == COMB_STACK && seg->e.seginfo->bytes_written == 0 ) {

	movzx	eax, BYTE PTR [r8+108]
	and	al, 7
	cmp	al, 5
	jne	SHORT $LN7@pe_get_cha
	cmp	DWORD PTR [r8+24], 0
	jne	SHORT $LN7@pe_get_cha

; 1106 :         result |= IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

	mov	eax, -1073741696			; c0000080H
	jmp	SHORT $LN2@pe_get_cha
$LN7@pe_get_cha:

; 1107 :         //ish.SizeOfRawData = 0;
; 1108 :         //ish.PointerToRawData = 0;
; 1109 :     } else if ( seg->e.seginfo->readonly ) {

	test	BYTE PTR [r8+107], 1
	je	SHORT $LN5@pe_get_cha

; 1110 :         result |= IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ;

	mov	eax, 1073741888				; 40000040H
	jmp	SHORT $LN2@pe_get_cha
$LN5@pe_get_cha:

; 1111 :     } else if ( seg->e.seginfo->clsym && strcmp( seg->e.seginfo->clsym->name, "CONST" ) == 0 ) {

	mov	rax, QWORD PTR [r8+80]
	test	rax, rax
	je	SHORT $LN3@pe_get_cha
	mov	rax, QWORD PTR [rax+8]
	lea	r9, OFFSET FLAT:$SG6534
	sub	r9, rax
	npad	2
$LL14@pe_get_cha:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r9]
	sub	edx, ecx
	jne	SHORT $LN15@pe_get_cha
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL14@pe_get_cha
$LN15@pe_get_cha:
	test	edx, edx

; 1112 :         result |= IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ;

	mov	eax, 1073741888				; 40000040H
	je	SHORT $LN2@pe_get_cha
$LN3@pe_get_cha:

; 1113 :     } else
; 1114 :         result |= IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

	mov	eax, -1073741760			; c0000040H
$LN2@pe_get_cha:

; 1115 : 
; 1116 :     /* manual characteristics set? */
; 1117 :     if ( seg->e.seginfo->characteristics ) {

	movzx	edx, BYTE PTR [r8+105]
	test	dl, dl
	je	SHORT $LN16@pe_get_cha

; 1118 :         result &= 0x1FFFFFF; /* clear the IMAGE_SCN_MEM flags */
; 1119 :         result |= (uint_32)(seg->e.seginfo->characteristics & 0xFE) << 24;

	movzx	ecx, dl
	shl	ecx, 24
	xor	ecx, eax
	movzx	eax, dl
	shl	eax, 24
	and	ecx, 33554431				; 01ffffffH
	xor	eax, ecx
$LN16@pe_get_cha:

; 1120 :     }
; 1121 :     return( result );
; 1122 : }

	ret	0
pe_get_characteristics ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$pe_set_base_relocs DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$pe_set_base_relocs DD @imagerel(pe_set_base_relocs#)
	DD	@imagerel(pe_set_base_relocs#+376)
	DD	@imagerel($unwind$pe_set_base_relocs#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
reloc$ = 48
pe_set_base_relocs PROC NEAR

; 1128 : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 1129 :     int cnt1 = 0;
; 1130 :     int cnt2 = 0;
; 1131 :     int ftype;
; 1132 :     uint_32 currpage = -1;
; 1133 :     uint_32 currloc;
; 1134 :     struct dsym *curr;
; 1135 :     struct fixup *fixup;
; 1136 :     struct IMAGE_BASE_RELOCATION *baserel;
; 1137 :     uint_16 *prel;
; 1138 : 
; 1139 :     for ( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	r11, QWORD PTR SymTables+32
	xor	edx, edx
	mov	rbx, rcx
	test	r11, r11
	mov	r9d, edx
	mov	r8d, -1					; ffffffffH
	je	SHORT $LN28@pe_set_bas
$LL30@pe_set_bas:

; 1140 :         if ( curr->e.seginfo->segtype == SEGTYPE_HDR )

	mov	r10, QWORD PTR [r11+104]
	cmp	DWORD PTR [r10+72], 6
	je	SHORT $LN29@pe_set_bas

; 1141 :             continue;
; 1142 :         for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rcx, QWORD PTR [r10+40]
	test	rcx, rcx
	je	SHORT $LN29@pe_set_bas
$LL26@pe_set_bas:

; 1143 :             switch ( fixup->type ) {

	mov	eax, DWORD PTR [rcx+24]
	add	eax, -5					; fffffffbH
	cmp	eax, 2
	ja	SHORT $LN25@pe_set_bas

; 1144 :             case FIX_OFF16:
; 1145 :             case FIX_OFF32:
; 1146 : #if AMD64_SUPPORT
; 1147 :             case FIX_OFF64:
; 1148 : #endif
; 1149 :                 currloc = curr->e.seginfo->start_offset + ( fixup->locofs & 0xFFFFF000 );

	mov	eax, DWORD PTR [rcx+20]
	and	eax, -4096				; fffff000H
	add	eax, DWORD PTR [r10+12]

; 1150 :                 if ( currloc != currpage ) {

	cmp	eax, r8d
	je	SHORT $LN19@pe_set_bas

; 1151 :                     currpage = currloc;
; 1152 :                     cnt2++;

	inc	r9d

; 1153 :                     if ( cnt1 & 1 )

	test	dl, 1
	mov	r8d, eax
	je	SHORT $LN19@pe_set_bas

; 1154 :                         cnt1++;

	inc	edx
$LN19@pe_set_bas:

; 1155 :                 }
; 1156 :                 cnt1++;

	inc	edx
$LN25@pe_set_bas:

; 1141 :             continue;
; 1142 :         for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	jne	SHORT $LL26@pe_set_bas
$LN29@pe_set_bas:

; 1129 :     int cnt1 = 0;
; 1130 :     int cnt2 = 0;
; 1131 :     int ftype;
; 1132 :     uint_32 currpage = -1;
; 1133 :     uint_32 currloc;
; 1134 :     struct dsym *curr;
; 1135 :     struct fixup *fixup;
; 1136 :     struct IMAGE_BASE_RELOCATION *baserel;
; 1137 :     uint_16 *prel;
; 1138 : 
; 1139 :     for ( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	r11, QWORD PTR [r11+112]
	test	r11, r11
	jne	SHORT $LL30@pe_set_bas
$LN28@pe_set_bas:

; 1157 :                 break;
; 1158 :             //case FIX_RELOFF08: /* needs no base reloc */
; 1159 :             //case FIX_RELOFF16: /* needs no base reloc */
; 1160 :             //case FIX_RELOFF32: /* needs no base reloc */
; 1161 :             //case FIX_OFF08:    /* needs no base reloc */
; 1162 :             //case FIX_OFF32_IMGREL: /* needs no base reloc */
; 1163 :             //case FIX_OFF32_SECREL: /* needs no base reloc */
; 1164 :             //case FIX_SEG:   /* segmented fixups have caused an error already */
; 1165 :             //case FIX_PTR16: /* segmented fixups have caused an error already */
; 1166 :             //case FIX_PTR32: /* segmented fixups have caused an error already */
; 1167 :             //case FIX_HIBYTE: /* is an error */
; 1168 :             default:
; 1169 :                 break;
; 1170 :             }
; 1171 :         }
; 1172 :     }
; 1173 :     reloc->sym.max_offset = cnt2 * sizeof( struct IMAGE_BASE_RELOCATION ) + cnt1 * sizeof( uint_16 );

	lea	eax, DWORD PTR [rdx+r9*4]
	add	eax, eax

; 1174 :     reloc->e.seginfo->CodeBuffer = LclAlloc( reloc->sym.max_offset );

	movsxd	rcx, eax
	mov	DWORD PTR [rbx+64], eax
	call	LclAlloc
	mov	rcx, QWORD PTR [rbx+104]
	mov	QWORD PTR [rcx+16], rax

; 1175 : 
; 1176 :     baserel = (struct IMAGE_BASE_RELOCATION *)reloc->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR [rbx+104]
	mov	r8, QWORD PTR [rax+16]

; 1177 :     prel = (uint_16 *)((uint_8 *)baserel + sizeof ( struct IMAGE_BASE_RELOCATION ));
; 1178 : 
; 1179 :     baserel->VirtualAddress = -1;

	mov	DWORD PTR [r8], -1			; ffffffffH

; 1180 :     for ( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	r11, QWORD PTR SymTables+32
	lea	r9, QWORD PTR [r8+8]
	test	r11, r11
	je	$LN15@pe_set_bas
	npad	3
$LL17@pe_set_bas:

; 1181 :         if ( curr->e.seginfo->segtype == SEGTYPE_HDR )

	mov	rdx, QWORD PTR [r11+104]
	cmp	DWORD PTR [rdx+72], 6
	je	$LN16@pe_set_bas

; 1182 :             continue;
; 1183 :         for ( fixup = curr->e.seginfo->FixupList.head; fixup; fixup = fixup->nextrlc ) {

	mov	rdx, QWORD PTR [rdx+40]
	test	rdx, rdx
	je	$LN16@pe_set_bas
	npad	5
$LL13@pe_set_bas:

; 1184 :             switch ( fixup->type ) {

	mov	ecx, DWORD PTR [rdx+24]
	sub	ecx, 5
	je	SHORT $LN8@pe_set_bas
	dec	ecx
	je	SHORT $LN7@pe_set_bas
	dec	ecx
	jne	SHORT $LN12@pe_set_bas

; 1187 : #if AMD64_SUPPORT
; 1188 :             case FIX_OFF64: ftype = IMAGE_REL_BASED_DIR64; break;

	mov	ecx, 10
	jmp	SHORT $LN41@pe_set_bas
$LN7@pe_set_bas:

; 1186 :             case FIX_OFF32: ftype = IMAGE_REL_BASED_HIGHLOW; break;

	mov	ecx, 3
	jmp	SHORT $LN41@pe_set_bas
$LN8@pe_set_bas:

; 1185 :             case FIX_OFF16: ftype = IMAGE_REL_BASED_LOW; break;

	mov	ecx, 2
$LN41@pe_set_bas:

; 1189 : #endif
; 1190 :             default: ftype = 0;
; 1191 :             }
; 1192 :             if ( ftype ) {
; 1193 :                 currloc = curr->e.seginfo->start_offset + ( fixup->locofs & 0xFFFFF000 );

	mov	rax, QWORD PTR [r11+104]
	mov	r10d, DWORD PTR [rdx+20]
	and	r10d, -4096				; fffff000H
	add	r10d, DWORD PTR [rax+12]

; 1194 :                 if ( currloc != baserel->VirtualAddress ) {

	mov	eax, DWORD PTR [r8]
	cmp	r10d, eax
	je	SHORT $LN3@pe_set_bas

; 1195 :                     if ( baserel->VirtualAddress != -1 ) {

	cmp	eax, -1					; ffffffffH
	je	SHORT $LN2@pe_set_bas

; 1196 :                         /* address of relocation header must be DWORD aligned */
; 1197 :                         if ( baserel->SizeOfBlock & 2 ) {

	test	BYTE PTR [r8+4], 2
	je	SHORT $LN1@pe_set_bas

; 1198 :                             *prel++ = 0;

	mov	WORD PTR [r9], 0
	add	r9, 2

; 1199 :                             baserel->SizeOfBlock += sizeof( uint_16 );

	add	DWORD PTR [r8+4], 2
$LN1@pe_set_bas:

; 1200 :                         }
; 1201 :                         baserel = (struct IMAGE_BASE_RELOCATION *)prel;

	mov	r8, r9

; 1202 :                         prel += 4; /* 4*2 = sizeof( struct IMAGE_BASE_RELOCATION ) */

	add	r9, 8
$LN2@pe_set_bas:

; 1203 :                     }
; 1204 :                     baserel->VirtualAddress = currloc;

	mov	DWORD PTR [r8], r10d

; 1205 :                     baserel->SizeOfBlock = sizeof( struct IMAGE_BASE_RELOCATION );

	mov	DWORD PTR [r8+4], 8
$LN3@pe_set_bas:

; 1206 :                 }
; 1207 :                 *prel++ = ( fixup->locofs & 0xfff ) | ( ftype << 12 );

	movzx	eax, WORD PTR [rdx+20]
	shl	cx, 12
	add	r9, 2
	and	ax, 4095				; 00000fffH
	or	ax, cx
	mov	WORD PTR [r9-2], ax

; 1208 :                 baserel->SizeOfBlock += sizeof( uint_16 );

	add	DWORD PTR [r8+4], 2
$LN12@pe_set_bas:
	mov	rdx, QWORD PTR [rdx+8]
	test	rdx, rdx
	jne	$LL13@pe_set_bas
$LN16@pe_set_bas:

; 1180 :     for ( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	r11, QWORD PTR [r11+112]
	test	r11, r11
	jne	$LL17@pe_set_bas
$LN15@pe_set_bas:

; 1209 :             }
; 1210 :         }
; 1211 :     }
; 1212 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
pe_set_base_relocs ENDP
_TEXT	ENDS
EXTRN	strncpy:NEAR
EXTRN	ConvertSectionName:NEAR
EXTRN	SortSegments:NEAR
xdata	SEGMENT
$unwind$pe_set_values DD 020f01H
	DD	033010fH
xdata	ENDS
pdata	SEGMENT
$pdata$pe_set_values DD @imagerel(pe_set_values#)
	DD	@imagerel(pe_set_values#+15)
	DD	@imagerel($unwind$pe_set_values#)
pdata	ENDS
xdata	SEGMENT
$chain$2$pe_set_values DD 060c21H
	DD	032740cH
	DD	0365408H
	DD	0353404H
	DD	@imagerel(pe_set_values#)
	DD	@imagerel(pe_set_values#+15)
	DD	@imagerel($unwind$pe_set_values#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$pe_set_values DD @imagerel(pe_set_values#+15)
	DD	@imagerel(pe_set_values#+29)
	DD	@imagerel($chain$2$pe_set_values#)
pdata	ENDS
xdata	SEGMENT
$chain$5$pe_set_values DD 060c21H
	DD	02fe40cH
	DD	030d408H
	DD	031c404H
	DD	@imagerel(pe_set_values#+15)
	DD	@imagerel(pe_set_values#+29)
	DD	@imagerel($chain$2$pe_set_values#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$pe_set_values DD @imagerel(pe_set_values#+29)
	DD	@imagerel(pe_set_values#+48)
	DD	@imagerel($chain$5$pe_set_values#)
pdata	ENDS
xdata	SEGMENT
$chain$6$pe_set_values DD 020421H
	DD	02ef404H
	DD	@imagerel(pe_set_values#+29)
	DD	@imagerel(pe_set_values#+48)
	DD	@imagerel($chain$5$pe_set_values#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$pe_set_values DD @imagerel(pe_set_values#+48)
	DD	@imagerel(pe_set_values#+456)
	DD	@imagerel($chain$6$pe_set_values#)
pdata	ENDS
xdata	SEGMENT
$chain$7$pe_set_values DD 020821H
	DD	0376408H
	DD	@imagerel(pe_set_values#+48)
	DD	@imagerel(pe_set_values#+456)
	DD	@imagerel($chain$6$pe_set_values#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$pe_set_values DD @imagerel(pe_set_values#+456)
	DD	@imagerel(pe_set_values#+828)
	DD	@imagerel($chain$7$pe_set_values#)
pdata	ENDS
xdata	SEGMENT
$chain$8$pe_set_values DD 020021H
	DD	0376400H
	DD	@imagerel(pe_set_values#+29)
	DD	@imagerel(pe_set_values#+48)
	DD	@imagerel($chain$5$pe_set_values#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$pe_set_values DD @imagerel(pe_set_values#+828)
	DD	@imagerel(pe_set_values#+1537)
	DD	@imagerel($chain$8$pe_set_values#)
pdata	ENDS
xdata	SEGMENT
$chain$9$pe_set_values DD 060021H
	DD	02fe400H
	DD	030d400H
	DD	0376400H
	DD	@imagerel(pe_set_values#+15)
	DD	@imagerel(pe_set_values#+29)
	DD	@imagerel($chain$2$pe_set_values#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$pe_set_values DD @imagerel(pe_set_values#+1537)
	DD	@imagerel(pe_set_values#+1676)
	DD	@imagerel($chain$9$pe_set_values#)
pdata	ENDS
xdata	SEGMENT
$chain$10$pe_set_values DD 080021H
	DD	02fe400H
	DD	030d400H
	DD	0327400H
	DD	0365400H
	DD	@imagerel(pe_set_values#)
	DD	@imagerel(pe_set_values#+15)
	DD	@imagerel($unwind$pe_set_values#)
xdata	ENDS
pdata	SEGMENT
$pdata$10$pe_set_values DD @imagerel(pe_set_values#+1676)
	DD	@imagerel(pe_set_values#+1875)
	DD	@imagerel($chain$10$pe_set_values#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sizehdr$1$ = 48
codesize$1$ = 52
datasize$1$ = 56
database$1$ = 60
i$3$ = 64
ph64$1$ = 72
ph32$ = 80
sizeimg$1$ = 88
mzhdr$1$ = 88
tv1261 = 96
buffer$ = 112
ph64$ = 416
cp$ = 416
pe_set_values PROC NEAR

; 1234 : {

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, rsp
	sub	rsp, 408				; 00000198H
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rbp
	mov	QWORD PTR [rax-8], rdi

; 1235 :     int i;
; 1236 :     int falign;
; 1237 :     int malign;
; 1238 :     uint_16 ff;
; 1239 :     uint_32 codebase = 0;

	xor	edi, edi
	mov	QWORD PTR [rax-16], r12
	mov	QWORD PTR [rax-24], r13
	mov	QWORD PTR [rax-32], r14

; 1240 :     uint_32 database = 0;
; 1241 :     uint_32 codesize = 0;
; 1242 :     uint_32 datasize = 0;
; 1243 :     uint_32 sizehdr  = 0;
; 1244 :     uint_32 sizeimg  = 0;
; 1245 :     struct dsym *curr;
; 1246 :     struct dsym *mzhdr;
; 1247 :     struct dsym *pehdr;
; 1248 :     struct dsym *objtab;
; 1249 :     struct dsym *reloc = NULL;
; 1250 :     struct IMAGE_PE_HEADER32 *ph32;
; 1251 : #if AMD64_SUPPORT
; 1252 :     struct IMAGE_PE_HEADER64 *ph64;
; 1253 : #endif
; 1254 :     struct IMAGE_FILE_HEADER *fh;
; 1255 :     struct IMAGE_SECTION_HEADER *section;
; 1256 :     struct IMAGE_DATA_DIRECTORY *datadir;
; 1257 :     char *secname;
; 1258 :     char buffer[MAX_ID_LEN+1];
; 1259 : 
; 1260 :     mzhdr  = ( struct dsym *)SymSearch( hdrname "1" );

	lea	rcx, OFFSET FLAT:$SG6623
	mov	QWORD PTR [rax-40], r15
	mov	QWORD PTR tv1261[rsp], rdi
	mov	DWORD PTR database$1$[rsp], edi
	mov	DWORD PTR codesize$1$[rsp], edi
	mov	DWORD PTR datasize$1$[rsp], edi
	mov	DWORD PTR sizehdr$1$[rsp], edi
	mov	r12, rdi
	call	SymFind

; 1261 :     pehdr  = ( struct dsym *)SymSearch( hdrname "2" );

	lea	rcx, OFFSET FLAT:$SG6625
	mov	r14, rax
	mov	QWORD PTR mzhdr$1$[rsp], rax
	call	SymFind

; 1262 :     objtab = ( struct dsym *)SymSearch( hdrname "3" );

	lea	rcx, OFFSET FLAT:$SG6627
	mov	r13, rax
	call	SymFind

; 1263 : 
; 1264 :     /* make sure all header objects are in FLAT group */
; 1265 :     mzhdr->e.seginfo->group = &ModuleInfo.flat_grp->sym;

	mov	rcx, QWORD PTR [r14+104]
	mov	r15, rax
	mov	rax, QWORD PTR ModuleInfo+440
	mov	QWORD PTR [rcx], rax

; 1266 : #if AMD64_SUPPORT
; 1267 :     if ( ModuleInfo.defOfssize == USE64 ) {

	movzx	r9d, BYTE PTR ModuleInfo+405
	cmp	r9b, 2
	jne	SHORT $LN49@pe_set_val

; 1268 :         ph64 = ( struct IMAGE_PE_HEADER64 *)pehdr->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR [r13+104]

; 1269 :         ff = ph64->FileHeader.Characteristics;
; 1270 :     } else {

	mov	rbx, QWORD PTR ph32$[rsp]
	mov	rbp, QWORD PTR [rax+16]
	mov	QWORD PTR ph64$1$[rsp], rbp
	movzx	eax, WORD PTR [rbp+22]
	jmp	SHORT $LN48@pe_set_val
$LN49@pe_set_val:

; 1271 : #endif
; 1272 :         ph32 = ( struct IMAGE_PE_HEADER32 *)pehdr->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR [r13+104]

; 1273 :         ff = ph32->FileHeader.Characteristics;

	mov	rbp, QWORD PTR ph64$[rsp]
	mov	rbx, QWORD PTR [rax+16]
	mov	QWORD PTR ph64$1$[rsp], rbp
	mov	ax, WORD PTR [rbx+22]
	mov	QWORD PTR ph32$[rsp], rbx
$LN48@pe_set_val:

; 1274 : #if AMD64_SUPPORT
; 1275 :     }
; 1276 : #endif
; 1277 :     if ( !( ff & IMAGE_FILE_RELOCS_STRIPPED ) ) {

	test	al, 1
	jne	$LN46@pe_set_val

; 1278 :         DebugMsg(("pe_set_values: .reloc section required\n" ));
; 1279 :         reloc = (struct dsym *)CreateIntSegment( ".reloc", "RELOC", 2, ModuleInfo.defOfssize, TRUE );

	lea	rdx, OFFSET FLAT:$SG6634
	lea	rcx, OFFSET FLAT:$SG6635
	mov	r8b, 2
	mov	BYTE PTR [rsp+32], 1
	call	CreateIntSegment

; 1280 :         if ( reloc ) {

	test	rax, rax
	mov	r12, rax
	je	SHORT $LN46@pe_set_val

; 1281 :             reloc->e.seginfo->group = &ModuleInfo.flat_grp->sym;

	mov	rdx, QWORD PTR [rax+104]
	mov	rcx, QWORD PTR ModuleInfo+440
	mov	QWORD PTR [rdx], rcx

; 1282 :             reloc->e.seginfo->combine = COMB_ADDOFF;  /* PUBLIC */

	mov	rdx, QWORD PTR [rax+104]
	movzx	ecx, BYTE PTR [rdx+108]
	and	cl, 250					; 000000faH
	or	cl, 2
	mov	BYTE PTR [rdx+108], cl

; 1283 :             reloc->e.seginfo->segtype = SEGTYPE_RELOC;

	mov	rax, QWORD PTR [rax+104]
	mov	DWORD PTR [rax+72], 8

; 1284 :             reloc->e.seginfo->characteristics = ((IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_READ) >> 24 );

	mov	rax, QWORD PTR [r12+104]
	mov	BYTE PTR [rax+105], 66			; 00000042H

; 1285 :             /* make sure the section isn't empty ( true size will be calculated later ) */
; 1286 :             reloc->sym.max_offset = sizeof( struct IMAGE_BASE_RELOCATION );
; 1287 :             reloc->e.seginfo->bytes_written = reloc->sym.max_offset;

	mov	rax, QWORD PTR [r12+104]
	mov	DWORD PTR [r12+64], 8
	mov	DWORD PTR [rax+24], 8

; 1288 :             /* clear the additionally allocated entry in object table */
; 1289 :             memset( objtab->e.seginfo->CodeBuffer + objtab->sym.max_offset, 0, sizeof( struct IMAGE_SECTION_HEADER ) );

	mov	rax, QWORD PTR [r15+104]
	movsxd	rcx, DWORD PTR [r15+64]
	add	rcx, QWORD PTR [rax+16]
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+32], rax

; 1290 :             objtab->sym.max_offset += sizeof( struct IMAGE_SECTION_HEADER );

	add	DWORD PTR [r15+64], 40			; 00000028H
$LN46@pe_set_val:

; 1291 :         }
; 1292 :     }
; 1293 : 
; 1294 : 
; 1295 :     /* sort: header, executable, readable, read-write segments, resources, relocs */
; 1296 :     for ( i = 0; i < SIZE_PEFLAT; i++ ) {

	mov	r8d, edi
	lea	r9, OFFSET FLAT:flat_order
	npad	4
$LL45@pe_set_val:

; 1297 :         DebugMsg(("pe_set_values: searching segment types %Xh\n", flat_order[i] ));
; 1298 :         for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rcx, QWORD PTR SymTables+32
	test	rcx, rcx
	je	SHORT $LN44@pe_set_val
	npad	4
$LL42@pe_set_val:

; 1299 :             if ( curr->e.seginfo->segtype == flat_order[i] ) {

	mov	rdx, QWORD PTR [rcx+104]
	mov	eax, DWORD PTR [r9]
	cmp	DWORD PTR [rdx+72], eax
	jne	SHORT $LN41@pe_set_val

; 1300 :                 curr->e.seginfo->lname_idx = i;

	mov	DWORD PTR [rdx+76], r8d
$LN41@pe_set_val:

; 1297 :         DebugMsg(("pe_set_values: searching segment types %Xh\n", flat_order[i] ));
; 1298 :         for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rcx, QWORD PTR [rcx+112]
	test	rcx, rcx
	jne	SHORT $LL42@pe_set_val
$LN44@pe_set_val:

; 1291 :         }
; 1292 :     }
; 1293 : 
; 1294 : 
; 1295 :     /* sort: header, executable, readable, read-write segments, resources, relocs */
; 1296 :     for ( i = 0; i < SIZE_PEFLAT; i++ ) {

	inc	r8d
	add	r9, 4
	cmp	r8d, 7
	jb	SHORT $LL45@pe_set_val

; 1301 :             }
; 1302 :         }
; 1303 : 
; 1304 :     }
; 1305 :     SortSegments( 2 );

	mov	ecx, 2
	call	SortSegments

; 1306 :     falign = get_bit( GHF( OptionalHeader.FileAlignment ) );

	movzx	r11d, BYTE PTR ModuleInfo+405
	cmp	r11b, 2
	jne	SHORT $LN52@pe_set_val
	mov	eax, DWORD PTR [rbp+60]
	jmp	SHORT $LN53@pe_set_val
$LN52@pe_set_val:
	mov	eax, DWORD PTR [rbx+60]
$LN53@pe_set_val:
	test	eax, eax
	mov	QWORD PTR [rsp+440], rsi
	mov	esi, -1
	mov	DWORD PTR i$3$[rsp], esi
	mov	edi, esi
	je	SHORT $LN64@pe_set_val
	npad	3
$LL65@pe_set_val:
	inc	edi
	sar	eax, 1
	jne	SHORT $LL65@pe_set_val
$LN64@pe_set_val:

; 1307 :     malign = GHF( OptionalHeader.SectionAlignment );

	cmp	r11b, 2
	jne	SHORT $LN54@pe_set_val
	mov	ebp, DWORD PTR [rbp+56]
	jmp	SHORT $LN55@pe_set_val
$LN54@pe_set_val:
	mov	ebp, DWORD PTR [rbx+56]
$LN55@pe_set_val:

; 1308 : 
; 1309 :     /* assign RVAs to sections */
; 1310 : 
; 1311 :     for ( curr = SymTables[TAB_SEG].head, i = -1; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+32
	test	rbx, rbx
	je	SHORT $LN36@pe_set_val
	mov	r14, QWORD PTR cp$[rsp]
	npad	8
$LL38@pe_set_val:

; 1312 :         if ( curr->e.seginfo->lname_idx == SEGTYPE_ERROR || curr->e.seginfo->lname_idx != i ) {

	mov	rcx, QWORD PTR [rbx+104]
	mov	eax, DWORD PTR [rcx+76]
	cmp	eax, 10
	je	SHORT $LN34@pe_set_val
	cmp	eax, esi
	jne	SHORT $LN34@pe_set_val

; 1316 :         } else {
; 1317 :             uint_32 align = 1 << curr->e.seginfo->alignment;

	movzx	ecx, BYTE PTR [rcx+106]

; 1318 :             cp->alignment = 0;
; 1319 :             cp->rva = (cp->rva + (align - 1)) & (~(align-1));

	mov	eax, DWORD PTR [r14+28]
	mov	edx, 1
	shl	edx, cl
	mov	BYTE PTR [r14+1], 0
	lea	ecx, DWORD PTR [rax+rdx-1]
	lea	eax, DWORD PTR [rdx-1]
	not	eax
	and	ecx, eax
	mov	DWORD PTR [r14+28], ecx
	jmp	SHORT $LN33@pe_set_val
$LN34@pe_set_val:

; 1313 :             i = curr->e.seginfo->lname_idx;

	mov	esi, eax

; 1314 :             cp->alignment = falign;
; 1315 :             cp->rva = (cp->rva + (malign - 1)) & (~(malign-1));

	mov	eax, DWORD PTR [r14+28]
	mov	BYTE PTR [r14+1], dil
	lea	ecx, DWORD PTR [rax+rbp-1]
	lea	eax, DWORD PTR [rbp-1]
	not	eax
	and	ecx, eax
	mov	DWORD PTR [r14+28], ecx
$LN33@pe_set_val:

; 1320 :         }
; 1321 :         CalcOffset( curr, cp );

	mov	rdx, r14
	mov	rcx, rbx
	call	CalcOffset
	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL38@pe_set_val
	mov	r14, QWORD PTR mzhdr$1$[rsp]
$LN36@pe_set_val:

; 1322 :         DebugMsg(("pe_set_values: section %s, start ofs=%" I32_SPEC "Xh, size=%" I32_SPEC "Xh, file ofs=%" I32_SPEC "Xh\n",
; 1323 :                   curr->sym.name, curr->e.seginfo->start_offset, curr->sym.max_offset - curr->e.seginfo->start_loc, curr->e.seginfo->fileoffset ));
; 1324 :     }
; 1325 : 
; 1326 :     if ( reloc ) {

	test	r12, r12
	je	SHORT $LN93@pe_set_val

; 1327 :         pe_set_base_relocs( reloc );

	mov	rcx, r12
	call	pe_set_base_relocs

; 1328 :         cp->rva = reloc->e.seginfo->start_offset + reloc->sym.max_offset;

	mov	r11, QWORD PTR [r12+104]
	mov	rcx, QWORD PTR cp$[rsp]
	mov	eax, DWORD PTR [r11+12]
	add	eax, DWORD PTR [r12+64]
	mov	DWORD PTR [rcx+28], eax
	jmp	SHORT $LN32@pe_set_val
$LN93@pe_set_val:

; 1329 :     }
; 1330 : 
; 1331 :     sizeimg = cp->rva;

	mov	rcx, QWORD PTR cp$[rsp]
$LN32@pe_set_val:

; 1332 : 
; 1333 :     /* set e_lfanew of dosstub to start of PE header */
; 1334 :     if ( mzhdr->sym.max_offset >= 0x40 )

	cmp	DWORD PTR [r14+64], 64			; 00000040H
	mov	r12d, DWORD PTR [rcx+28]
	mov	DWORD PTR sizeimg$1$[rsp], r12d
	jl	SHORT $LN31@pe_set_val

; 1335 :         ((struct IMAGE_DOS_HEADER *)mzhdr->e.seginfo->CodeBuffer)->e_lfanew = pehdr->e.seginfo->fileoffset;

	mov	rax, QWORD PTR [r14+104]
	mov	rdx, QWORD PTR [r13+104]
	mov	rcx, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [rdx+56]
	mov	DWORD PTR [rcx+60], eax
$LN31@pe_set_val:

; 1336 : 
; 1337 :     /* set number of sections in PE file header (doesn't matter if it's 32- or 64-bit) */
; 1338 :     fh = &((struct IMAGE_PE_HEADER32 *)pehdr->e.seginfo->CodeBuffer)->FileHeader;
; 1339 :     fh->NumberOfSections = objtab->sym.max_offset / sizeof( struct IMAGE_SECTION_HEADER );

	movsxd	rcx, DWORD PTR [r15+64]
	mov	rax, -3689348814741910323		; cccccccccccccccdH
	mul	rcx
	mov	rax, QWORD PTR [r13+104]
	shr	rdx, 5
	mov	rcx, QWORD PTR [rax+16]
	mov	WORD PTR [rcx+6], dx

; 1340 : 
; 1341 : #if RAWSIZE_ROUND
; 1342 :     cp->rawpagesize = ( ModuleInfo.defOfssize == USE64 ? ph64->OptionalHeader.FileAlignment : ph32->OptionalHeader.FileAlignment );

	cmp	BYTE PTR ModuleInfo+405, 2
	jne	SHORT $LN56@pe_set_val
	mov	r14, QWORD PTR ph64$1$[rsp]
	mov	rbp, QWORD PTR ph32$[rsp]
	mov	eax, DWORD PTR [r14+60]
	jmp	SHORT $LN57@pe_set_val
$LN56@pe_set_val:
	mov	rbp, QWORD PTR ph32$[rsp]
	mov	r14, QWORD PTR ph64$1$[rsp]
	mov	eax, DWORD PTR [rbp+60]
$LN57@pe_set_val:
	mov	r13, QWORD PTR cp$[rsp]
	mov	DWORD PTR [r13+40], eax

; 1343 : #endif
; 1344 : 
; 1345 :     /* fill object table values */
; 1346 :     section = (struct IMAGE_SECTION_HEADER *)objtab->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR [r15+104]

; 1347 :     for( curr = SymTables[TAB_SEG].head, i = -1; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+32
	test	rbx, rbx
	mov	r15, QWORD PTR [rsp+368]
	mov	rdi, QWORD PTR [rax+16]
	je	$LN28@pe_set_val
	xor	ebp, ebp
	mov	r14d, ebp
	mov	r12d, ebp
	npad	12
$LL30@pe_set_val:

; 1348 :         if ( curr->e.seginfo->segtype == SEGTYPE_HDR )

	mov	rcx, QWORD PTR [rbx+104]
	cmp	DWORD PTR [rcx+72], 6
	je	$LN29@pe_set_val

; 1349 :             continue;
; 1350 :         if ( curr->sym.max_offset == 0 ) /* ignore empty sections */

	cmp	DWORD PTR [rbx+64], 0
	je	$LN29@pe_set_val

; 1351 :             continue;
; 1352 :         if ( curr->e.seginfo->lname_idx != i ) {

	mov	esi, DWORD PTR i$3$[rsp]
	cmp	DWORD PTR [rcx+76], esi
	je	SHORT $LN23@pe_set_val

; 1353 :             i = curr->e.seginfo->lname_idx;
; 1354 :             secname = ( curr->e.seginfo->aliasname ? curr->e.seginfo->aliasname : ConvertSectionName( &curr->sym, NULL, buffer ) );

	cmp	QWORD PTR [rcx+96], 0
	mov	esi, DWORD PTR [rcx+76]
	mov	DWORD PTR i$3$[rsp], esi
	je	SHORT $LN58@pe_set_val
	mov	rax, QWORD PTR [rcx+96]
	jmp	SHORT $LN59@pe_set_val
$LN58@pe_set_val:
	lea	r8, QWORD PTR buffer$[rsp]
	xor	edx, edx
	mov	rcx, rbx
	call	ConvertSectionName
$LN59@pe_set_val:

; 1355 :             strncpy( section->Name, secname, sizeof ( section->Name ) );

	mov	r8d, 8
	mov	rdx, rax
	mov	rcx, rdi
	call	strncpy

; 1356 :             if ( curr->e.seginfo->segtype != SEGTYPE_BSS )

	mov	r11, QWORD PTR [rbx+104]
	cmp	DWORD PTR [r11+72], 3
	je	SHORT $LN24@pe_set_val

; 1357 :                 section->PointerToRawData = curr->e.seginfo->fileoffset;

	mov	eax, DWORD PTR [r11+56]
	mov	DWORD PTR [rdi+20], eax
$LN24@pe_set_val:

; 1358 :             section->VirtualAddress = curr->e.seginfo->start_offset;
; 1359 :             /* file offset of first section in object table defines SizeOfHeader */
; 1360 :             if ( sizehdr == 0 )

	test	r12d, r12d
	mov	rax, QWORD PTR [rbx+104]
	mov	ecx, DWORD PTR [rax+12]
	mov	DWORD PTR [rdi+12], ecx
	jne	SHORT $LN23@pe_set_val

; 1361 :                 sizehdr = curr->e.seginfo->fileoffset;

	mov	rax, QWORD PTR [rbx+104]
	mov	r12d, DWORD PTR [rax+56]
$LN23@pe_set_val:

; 1362 :         }
; 1363 :         section->Characteristics |= pe_get_characteristics( curr );

	mov	r9, QWORD PTR [rbx+104]
	mov	eax, DWORD PTR [r9+72]
	cmp	eax, 1
	jne	SHORT $LN78@pe_set_val
	mov	ecx, 1610612768				; 60000020H
	jmp	SHORT $LN69@pe_set_val
$LN78@pe_set_val:
	cmp	eax, 3
	jne	SHORT $LN76@pe_set_val
	mov	ecx, -1073741696			; c0000080H
	jmp	SHORT $LN69@pe_set_val
$LN76@pe_set_val:
	movzx	eax, BYTE PTR [r9+108]
	and	al, 7
	cmp	al, 5
	jne	SHORT $LN74@pe_set_val
	cmp	DWORD PTR [r9+24], 0
	jne	SHORT $LN74@pe_set_val
	mov	ecx, -1073741696			; c0000080H
	jmp	SHORT $LN69@pe_set_val
$LN74@pe_set_val:
	test	BYTE PTR [r9+107], 1
	je	SHORT $LN72@pe_set_val
	mov	ecx, 1073741888				; 40000040H
	jmp	SHORT $LN69@pe_set_val
$LN72@pe_set_val:
	mov	rax, QWORD PTR [r9+80]
	test	rax, rax
	je	SHORT $LN70@pe_set_val
	mov	rax, QWORD PTR [rax+8]
	lea	r8, OFFSET FLAT:$SG6534
	sub	r8, rax
	npad	4
$LL91@pe_set_val:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN92@pe_set_val
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL91@pe_set_val
$LN92@pe_set_val:
	test	edx, edx
	jne	SHORT $LN70@pe_set_val
	mov	ecx, 1073741888				; 40000040H
	jmp	SHORT $LN69@pe_set_val
$LN70@pe_set_val:
	mov	ecx, -1073741760			; c0000040H
$LN69@pe_set_val:
	movzx	edx, BYTE PTR [r9+105]
	test	dl, dl
	je	SHORT $LN68@pe_set_val
	movzx	eax, dl
	shl	eax, 24
	xor	ecx, eax
	movzx	eax, dl
	shl	eax, 24
	and	ecx, 33554431				; 01ffffffH
	xor	ecx, eax
$LN68@pe_set_val:
	or	DWORD PTR [rdi+36], ecx

; 1364 :         if ( curr->e.seginfo->segtype != SEGTYPE_BSS ) {

	mov	rax, QWORD PTR [rbx+104]
	mov	r8d, DWORD PTR [rdi+36]
	cmp	DWORD PTR [rax+72], 3
	je	SHORT $LN22@pe_set_val

; 1365 :             section->SizeOfRawData += curr->sym.max_offset;

	mov	eax, DWORD PTR [rbx+64]
	add	DWORD PTR [rdi+16], eax
$LN22@pe_set_val:

; 1366 :         }
; 1367 : 
; 1368 :         /* v2.10: this calculation is not correct */
; 1369 :         //section->Misc.VirtualSize += curr->sym.max_offset;
; 1370 :         section->Misc.VirtualSize = curr->sym.max_offset + ( curr->e.seginfo->start_offset - section->VirtualAddress );

	mov	rax, QWORD PTR [rbx+104]
	mov	edx, DWORD PTR [rdi+12]
	mov	ecx, DWORD PTR [rax+12]
	sub	ecx, edx
	add	ecx, DWORD PTR [rbx+64]
	mov	DWORD PTR [rdi+8], ecx

; 1371 : 
; 1372 :         if ( curr->next == NULL || curr->next->e.seginfo->lname_idx != i ) {

	mov	rax, QWORD PTR [rbx+112]
	test	rax, rax
	je	SHORT $LN20@pe_set_val
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+76], esi
	je	SHORT $LN17@pe_set_val
$LN20@pe_set_val:

; 1373 : #if RAWSIZE_ROUND /* AntiVir TR/Crypt.XPACK Gen */
; 1374 :             section->SizeOfRawData += cp->rawpagesize - 1;

	mov	eax, DWORD PTR [r13+40]
	dec	eax
	add	DWORD PTR [rdi+16], eax

; 1375 :             section->SizeOfRawData &= ~(cp->rawpagesize - 1);

	mov	eax, DWORD PTR [r13+40]
	dec	eax
	not	eax
	and	eax, DWORD PTR [rdi+16]

; 1376 : #endif
; 1377 :             if ( section->Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

	bt	r8d, 29
	mov	DWORD PTR [rdi+16], eax
	jae	SHORT $LN19@pe_set_val

; 1378 :                 if ( codebase == 0 )

	test	ebp, ebp
	cmove	ebp, edx

; 1379 :                     codebase = section->VirtualAddress;
; 1380 :                 codesize += section->SizeOfRawData;

	add	DWORD PTR codesize$1$[rsp], eax
$LN19@pe_set_val:

; 1381 :             }
; 1382 :             if ( section->Characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA ) {

	test	r8b, 64					; 00000040H
	je	SHORT $LN17@pe_set_val

; 1383 :                 if ( database == 0 )

	test	r14d, r14d
	cmove	r14d, edx

; 1384 :                     database = section->VirtualAddress;
; 1385 :                 datasize += section->SizeOfRawData;

	add	DWORD PTR datasize$1$[rsp], eax
$LN17@pe_set_val:

; 1386 :             }
; 1387 :         }
; 1388 :         if ( curr->next && curr->next->e.seginfo->lname_idx != i ) {

	mov	rax, QWORD PTR [rbx+112]
	test	rax, rax
	je	SHORT $LN29@pe_set_val
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+76], esi
	je	SHORT $LN29@pe_set_val

; 1389 :             DebugMsg(("pe_set_values: object %.8s, VA=%" I32_SPEC "X size=%" I32_SPEC "X phys ofs/size=%" I32_SPEC "Xh/%" I32_SPEC "Xh\n",
; 1390 :                   section->Name, section->VirtualAddress, section->Misc.VirtualSize, section->PointerToRawData, section->SizeOfRawData ));
; 1391 :             section++;

	add	rdi, 40					; 00000028H
$LN29@pe_set_val:

; 1347 :     for( curr = SymTables[TAB_SEG].head, i = -1; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	$LL30@pe_set_val
	mov	DWORD PTR sizehdr$1$[rsp], r12d
	mov	r12d, DWORD PTR sizeimg$1$[rsp]
	mov	DWORD PTR database$1$[rsp], r14d
	mov	r14, QWORD PTR ph64$1$[rsp]
	mov	QWORD PTR tv1261[rsp], rbp
	mov	rbp, QWORD PTR ph32$[rsp]
$LN28@pe_set_val:

; 1392 :         }
; 1393 :     }
; 1394 : 
; 1395 : 
; 1396 :     if ( ModuleInfo.g.start_label ) {

	mov	rdx, QWORD PTR ModuleInfo+208
	test	rdx, rdx
	je	SHORT $LN14@pe_set_val

; 1397 : #if AMD64_SUPPORT
; 1398 :         if ( ModuleInfo.defOfssize == USE64 )

	cmp	BYTE PTR ModuleInfo+405, 2
	jne	SHORT $LN13@pe_set_val

; 1399 :             ph64->OptionalHeader.AddressOfEntryPoint = ((struct dsym *)ModuleInfo.g.start_label->segment)->e.seginfo->start_offset + ModuleInfo.g.start_label->offset;

	mov	rax, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rcx+12]
	add	eax, DWORD PTR [rdx+16]
	mov	DWORD PTR [r14+40], eax

; 1400 :         else

	jmp	SHORT $LN11@pe_set_val
$LN13@pe_set_val:

; 1401 : #endif
; 1402 :             ph32->OptionalHeader.AddressOfEntryPoint = ((struct dsym *)ModuleInfo.g.start_label->segment)->e.seginfo->start_offset + ModuleInfo.g.start_label->offset;

	mov	rax, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rcx+12]
	add	eax, DWORD PTR [rdx+16]
	mov	DWORD PTR [rbp+40], eax

; 1403 :     } else {

	jmp	SHORT $LN11@pe_set_val
$LN14@pe_set_val:

; 1404 :         DebugMsg(("pe_set_values: warning: not start label found\n" ));
; 1405 :         EmitWarn( 2, NO_START_LABEL );

	mov	edx, 203				; 000000cbH
	mov	ecx, 2
	call	EmitWarn
$LN11@pe_set_val:

; 1406 :     }
; 1407 : 
; 1408 : #if AMD64_SUPPORT
; 1409 :     if ( ModuleInfo.defOfssize == USE64 ) {

	cmp	BYTE PTR ModuleInfo+405, 2
	jne	SHORT $LN10@pe_set_val

; 1410 : #if IMGSIZE_ROUND
; 1411 :         /* round up the SizeOfImage field to page boundary */
; 1412 :         sizeimg = ( sizeimg + ph64->OptionalHeader.SectionAlignment - 1 ) & ~(ph64->OptionalHeader.SectionAlignment - 1);
; 1413 : #endif
; 1414 :         ph64->OptionalHeader.SizeOfCode = codesize;

	mov	eax, DWORD PTR codesize$1$[rsp]

; 1415 :         ph64->OptionalHeader.BaseOfCode = codebase;
; 1416 :         ph64->OptionalHeader.SizeOfImage = sizeimg;
; 1417 :         ph64->OptionalHeader.SizeOfHeaders = sizehdr;
; 1418 :         datadir = &ph64->OptionalHeader.DataDirectory[0];

	lea	rdi, QWORD PTR [r14+136]
	mov	DWORD PTR [r14+28], eax
	mov	rax, QWORD PTR tv1261[rsp]
	mov	DWORD PTR [r14+44], eax
	mov	eax, DWORD PTR [r14+56]
	lea	ecx, DWORD PTR [rax+r12-1]
	dec	eax
	not	eax
	and	ecx, eax
	mov	eax, DWORD PTR sizehdr$1$[rsp]
	mov	DWORD PTR [r14+84], eax
	mov	DWORD PTR [r14+80], ecx

; 1419 :     } else {

	jmp	SHORT $LN9@pe_set_val
$LN10@pe_set_val:

; 1420 : #endif
; 1421 : #if IMGSIZE_ROUND
; 1422 :         /* round up the SizeOfImage field to page boundary */
; 1423 :         sizeimg = ( sizeimg + ph32->OptionalHeader.SectionAlignment - 1 ) & ~(ph32->OptionalHeader.SectionAlignment - 1);
; 1424 : #endif
; 1425 :         ph32->OptionalHeader.SizeOfCode = codesize;

	mov	eax, DWORD PTR codesize$1$[rsp]

; 1426 :         ph32->OptionalHeader.SizeOfInitializedData = datasize;
; 1427 :         ph32->OptionalHeader.BaseOfCode = codebase;
; 1428 :         ph32->OptionalHeader.BaseOfData = database;
; 1429 :         ph32->OptionalHeader.SizeOfImage = sizeimg;
; 1430 :         ph32->OptionalHeader.SizeOfHeaders = sizehdr;
; 1431 :         datadir = &ph32->OptionalHeader.DataDirectory[0];

	lea	rdi, QWORD PTR [rbp+120]
	mov	DWORD PTR [rbp+28], eax
	mov	eax, DWORD PTR datasize$1$[rsp]
	mov	DWORD PTR [rbp+32], eax
	mov	rax, QWORD PTR tv1261[rsp]
	mov	DWORD PTR [rbp+44], eax
	mov	eax, DWORD PTR database$1$[rsp]
	mov	DWORD PTR [rbp+48], eax
	mov	eax, DWORD PTR [rbp+56]
	lea	ecx, DWORD PTR [rax+r12-1]
	dec	eax
	not	eax
	and	ecx, eax
	mov	eax, DWORD PTR sizehdr$1$[rsp]
	mov	DWORD PTR [rbp+84], eax
	mov	DWORD PTR [rbp+80], ecx
$LN9@pe_set_val:

; 1432 : #if AMD64_SUPPORT
; 1433 :     }
; 1434 : #endif
; 1435 : 
; 1436 :     /* set export directory data dir value */
; 1437 :     if ( curr = (struct dsym *)SymSearch( edataname ) ) {

	lea	rcx, OFFSET FLAT:edataname
	call	SymFind
	mov	r12, QWORD PTR [rsp+392]
	test	rax, rax
	je	SHORT $LN8@pe_set_val

; 1438 :         datadir[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = curr->e.seginfo->start_offset;

	mov	rcx, QWORD PTR [rax+104]
	mov	edx, DWORD PTR [rcx+12]
	mov	DWORD PTR [rdi], edx

; 1439 :         datadir[IMAGE_DIRECTORY_ENTRY_EXPORT].Size = curr->sym.max_offset;

	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rdi+4], eax
$LN8@pe_set_val:

; 1440 :     }
; 1441 : 
; 1442 :     /* set import directory and IAT data dir value */
; 1443 :     if ( curr = (struct dsym *)SymSearch( ".idata$" IMPDIRSUF ) ) {

	lea	rcx, OFFSET FLAT:$SG6690
	call	SymFind
	test	rax, rax
	mov	rsi, rax
	je	SHORT $LN7@pe_set_val

; 1444 :         struct dsym *idata_null;
; 1445 :         struct dsym *idata_iat;
; 1446 :         uint_32 size;
; 1447 :         idata_null = (struct dsym *)SymSearch( ".idata$" IMPNDIRSUF ); /* final NULL import directory entry */

	lea	rcx, OFFSET FLAT:$SG6695
	call	SymFind

; 1448 :         idata_iat = (struct dsym *)SymSearch( ".idata$" IMPIATSUF ); /* IAT entries */

	lea	rcx, OFFSET FLAT:$SG6697
	mov	rbx, rax
	call	SymFind

; 1449 :         size = idata_null->e.seginfo->start_offset + idata_null->sym.max_offset - curr->e.seginfo->start_offset;

	mov	rcx, QWORD PTR [rsi+104]
	mov	r8d, DWORD PTR [rcx+12]
	mov	rcx, QWORD PTR [rbx+104]
	mov	edx, DWORD PTR [rcx+12]
	add	edx, DWORD PTR [rbx+64]

; 1450 :         datadir[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = curr->e.seginfo->start_offset;

	mov	DWORD PTR [rdi+8], r8d
	sub	edx, r8d

; 1451 :         datadir[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = size;

	mov	DWORD PTR [rdi+12], edx

; 1452 :         datadir[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress = idata_iat->e.seginfo->start_offset;

	mov	rcx, QWORD PTR [rax+104]
	mov	edx, DWORD PTR [rcx+12]
	mov	DWORD PTR [rdi+96], edx

; 1453 :         datadir[IMAGE_DIRECTORY_ENTRY_IAT].Size = idata_iat->sym.max_offset;

	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rdi+100], eax
$LN7@pe_set_val:

; 1454 :     }
; 1455 : 
; 1456 :     /* set resource directory data dir value */
; 1457 :     if ( curr = (struct dsym *)SymSearch(".rsrc") ) {

	lea	rcx, OFFSET FLAT:$SG6700
	call	SymFind
	mov	rsi, QWORD PTR [rsp+440]
	mov	rbx, QWORD PTR [rsp+424]
	test	rax, rax
	je	SHORT $LN6@pe_set_val

; 1458 :         datadir[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = curr->e.seginfo->start_offset;

	mov	rcx, QWORD PTR [rax+104]
	mov	edx, DWORD PTR [rcx+12]
	mov	DWORD PTR [rdi+16], edx

; 1459 :         datadir[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = curr->sym.max_offset;

	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rdi+20], eax
$LN6@pe_set_val:

; 1460 :     }
; 1461 : 
; 1462 :     /* set relocation data dir value */
; 1463 :     if ( curr = (struct dsym *)SymSearch(".reloc") ) {

	lea	rcx, OFFSET FLAT:$SG6703
	call	SymFind
	test	rax, rax
	je	SHORT $LN5@pe_set_val

; 1464 :         datadir[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = curr->e.seginfo->start_offset;

	mov	rcx, QWORD PTR [rax+104]
	mov	edx, DWORD PTR [rcx+12]
	mov	DWORD PTR [rdi+40], edx

; 1465 :         datadir[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = curr->sym.max_offset;

	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rdi+44], eax
$LN5@pe_set_val:

; 1466 :     }
; 1467 : 
; 1468 :     /* fixme: TLS entry is not written because there exists a segment .tls, but
; 1469 :      * because a _tls_used symbol is found ( type: IMAGE_THREAD_DIRECTORY )
; 1470 :      */
; 1471 :     if ( curr = (struct dsym *)SymSearch(".tls") ) {

	lea	rcx, OFFSET FLAT:$SG6706
	call	SymFind
	test	rax, rax
	je	SHORT $LN4@pe_set_val

; 1472 :         datadir[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = curr->e.seginfo->start_offset;

	mov	rcx, QWORD PTR [rax+104]
	mov	edx, DWORD PTR [rcx+12]
	mov	DWORD PTR [rdi+72], edx

; 1473 :         datadir[IMAGE_DIRECTORY_ENTRY_TLS].Size = curr->sym.max_offset;

	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rdi+76], eax
$LN4@pe_set_val:

; 1474 :     }
; 1475 : 
; 1476 : #if AMD64_SUPPORT
; 1477 :     if ( ModuleInfo.defOfssize == USE64 ) {

	cmp	BYTE PTR ModuleInfo+405, 2
	jne	SHORT $LN62@pe_set_val

; 1478 :         if ( curr = (struct dsym *)SymSearch( ".pdata" ) ) {

	lea	rcx, OFFSET FLAT:$SG6710
	call	SymFind
	test	rax, rax
	je	SHORT $LN2@pe_set_val

; 1479 :             datadir[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress = curr->e.seginfo->start_offset;

	mov	rcx, QWORD PTR [rax+104]
	mov	edx, DWORD PTR [rcx+12]
	mov	DWORD PTR [rdi+24], edx

; 1480 :             datadir[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size = curr->sym.max_offset;

	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rdi+28], eax
$LN2@pe_set_val:

; 1481 :         }
; 1482 :         cp->imagebase64 = GHF( OptionalHeader.ImageBase );

	cmp	BYTE PTR ModuleInfo+405, 2
	jne	SHORT $LN60@pe_set_val
	mov	rax, QWORD PTR [r14+48]
	mov	QWORD PTR [r13+32], rax

; 1483 :     } else

	jmp	SHORT $LN1@pe_set_val
$LN60@pe_set_val:

; 1481 :         }
; 1482 :         cp->imagebase64 = GHF( OptionalHeader.ImageBase );

	mov	eax, DWORD PTR [rbp+52]
	mov	QWORD PTR [r13+32], rax

; 1483 :     } else

	jmp	SHORT $LN1@pe_set_val
$LN62@pe_set_val:

; 1484 : #endif
; 1485 :         cp->imagebase = GHF( OptionalHeader.ImageBase );

	mov	eax, DWORD PTR [rbp+52]
	mov	DWORD PTR [r13+32], eax
$LN1@pe_set_val:
	mov	r14, QWORD PTR [rsp+376]
	mov	r13, QWORD PTR [rsp+384]
	mov	rdi, QWORD PTR [rsp+400]
	mov	rbp, QWORD PTR [rsp+432]

; 1486 : 
; 1487 :     /* remove .hdr$1 from FLAT group again */
; 1488 :     //mzhdr->e.seginfo->group = NULL;
; 1489 : }

	add	rsp, 408				; 00000198H
	ret	0
pe_set_values ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$pe_enddirhook DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$pe_enddirhook DD @imagerel(pe_enddirhook#)
	DD	@imagerel(pe_enddirhook#+44)
	DD	@imagerel($unwind$pe_enddirhook#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
modinfo$ = 48
pe_enddirhook PROC NEAR

; 1497 : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1498 :     pe_create_MZ_header( modinfo );

	call	pe_create_MZ_header

; 1499 :     //pe_create_PE_header(); /* the PE header is created when the .MODEL directive is found */
; 1500 :     pe_emit_export_data();

	call	pe_emit_export_data

; 1501 :     if ( modinfo->g.DllQueue )

	cmp	QWORD PTR [rbx+80], 0
	je	SHORT $LN1@pe_enddirh

; 1502 :         pe_emit_import_data();

	call	pe_emit_import_data
$LN1@pe_enddirh:

; 1503 :     pe_create_section_table();

	call	pe_create_section_table

; 1504 :     return( NOT_ERROR );

	xor	eax, eax

; 1505 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
pe_enddirhook ENDP
_TEXT	ENDS
EXTRN	ftell:NEAR
EXTRN	InOrgRange:NEAR
EXTRN	WriteError:NEAR
EXTRN	fwrite:NEAR
EXTRN	LstPrintf:NEAR
EXTRN	LstNL:NEAR
EXTRN	fseek:NEAR
EXTRN	memset:NEAR
xdata	SEGMENT
$unwind$bin_write_module DD 035125101H
	DD	012f451H
	DD	013e445H
	DD	014d431H
	DD	015c42dH
	DD	01b7427H
	DD	01a6420H
	DD	0193419H
	DD	010d3312H
	DD	050060016H
xdata	ENDS
pdata	SEGMENT
$pdata$bin_write_module DD @imagerel(bin_write_module#)
	DD	@imagerel(bin_write_module#+2971)
	DD	@imagerel($unwind$bin_write_module#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
count$1$ = 0
sizeheap$1$ = 0
hdrbuf$1$ = 8
tv1775 = 16
tv1848 = 24
stack$1$ = 32
cp$ = 40
sizeheap$ = 144
hdrbuf$ = 144
reloccnt$ = 144
modinfo$ = 144
bin_write_module PROC NEAR

; 1515 : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 176				; 000000b0H
	lea	rbp, QWORD PTR [rsp+48]
	mov	QWORD PTR [rbp+152], rbx
	mov	QWORD PTR [rbp+160], rsi
	mov	QWORD PTR [rbp+168], rdi

; 1516 :     struct dsym *curr;
; 1517 :     uint_32 size;
; 1518 :     uint_32 sizetotal;
; 1519 :     //const enum seg_type *segtype;
; 1520 :     int i;
; 1521 :     int first;
; 1522 :     uint_32 sizeheap;
; 1523 : #if MZ_SUPPORT
; 1524 :     struct IMAGE_DOS_HEADER *pMZ;
; 1525 :     uint_16 reloccnt;
; 1526 :     uint_32 sizemem;
; 1527 :     struct dsym *stack = NULL;

	xor	edi, edi
	mov	QWORD PTR [rbp+120], r12
	mov	QWORD PTR [rbp+112], r13
	mov	r13, rcx

; 1528 :     uint_8  *hdrbuf;
; 1529 : #endif
; 1530 :     struct calc_param cp = { TRUE, 0 };

	lea	r8d, QWORD PTR [rdi+44]
	lea	rcx, QWORD PTR cp$[rbp+4]
	mov	rsi, rdi
	xor	edx, edx
	mov	QWORD PTR [rbp+104], r14
	mov	QWORD PTR stack$1$[rbp], rdi
	mov	BYTE PTR cp$[rbp], 1
	mov	QWORD PTR [rbp+96], r15
	mov	BYTE PTR cp$[rbp+1], sil
	call	memset

; 1531 : 	uint_32 origsize;
; 1532 : 	uint_32 writesize;
; 1533 : 	uint_8 *codeptr;
; 1534 : 
; 1535 :     DebugMsg(("bin_write_module: enter\n" ));
; 1536 : 
; 1537 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	r11, QWORD PTR SymTables+32
	test	r11, r11
	je	SHORT $LN74@bin_write_
	npad	10
$LL76@bin_write_:

; 1538 :         /* reset the offset fields of segments */
; 1539 :         /* it was used to store the size in there */
; 1540 :         curr->e.seginfo->start_offset = 0;

	mov	rax, QWORD PTR [r11+104]
	mov	DWORD PTR [rax+12], edi

; 1541 :         /* set STACK segment type */
; 1542 :         if ( curr->e.seginfo->combine == COMB_STACK )

	mov	rax, QWORD PTR [r11+104]
	movzx	ecx, BYTE PTR [rax+108]
	and	cl, 7
	cmp	cl, 5
	jne	SHORT $LN75@bin_write_

; 1543 :             curr->e.seginfo->segtype = SEGTYPE_STACK;

	mov	DWORD PTR [rax+72], 4
$LN75@bin_write_:

; 1531 : 	uint_32 origsize;
; 1532 : 	uint_32 writesize;
; 1533 : 	uint_8 *codeptr;
; 1534 : 
; 1535 :     DebugMsg(("bin_write_module: enter\n" ));
; 1536 : 
; 1537 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	r11, QWORD PTR [r11+112]
	test	r11, r11
	jne	SHORT $LL76@bin_write_
$LN74@bin_write_:

; 1544 :     }
; 1545 : 
; 1546 :     /* calculate size of header */
; 1547 :     switch( modinfo->sub_format ) {

	mov	ecx, DWORD PTR [r13+372]

; 1552 :         DebugMsg(("bin_write_module: MZ format, fixups=%u, sizehdr=%" I32_SPEC "X\n", reloccnt, cp.sizehdr ));
; 1553 :         break;
; 1554 : #endif
; 1555 :     default:
; 1556 :         cp.sizehdr = 0;

	mov	r9d, edi
	dec	ecx
	je	SHORT $LN70@bin_write_
	mov	ax, WORD PTR reloccnt$[rbp]
	mov	DWORD PTR cp$[rbp+8], edi
	mov	DWORD PTR count$1$[rbp], eax
	jmp	$LN71@bin_write_
$LN70@bin_write_:

; 1548 : #if MZ_SUPPORT
; 1549 :     case SFORMAT_MZ:
; 1550 :         reloccnt = GetSegRelocs( NULL );

	mov	r10, rdi
	mov	DWORD PTR count$1$[rbp], edi
	mov	rdi, QWORD PTR SymTables+32
	test	rdi, rdi
	je	$LN98@bin_write_
	npad	3
$LL100@bin_write_:
	mov	r11, QWORD PTR [rdi+104]
	cmp	DWORD PTR [r11+72], 5
	je	$LN99@bin_write_
	mov	r11, QWORD PTR [r11+40]
	test	r11, r11
	je	$LN99@bin_write_
	npad	4
$LL96@bin_write_:
	mov	ebx, DWORD PTR [r11+24]
	lea	eax, DWORD PTR [rbx-8]
	cmp	eax, 2
	ja	$LN95@bin_write_
	mov	rax, QWORD PTR [r11+56]
	test	rax, rax
	je	SHORT $LN90@bin_write_
	mov	rax, QWORD PTR [rax+32]
	test	rax, rax
	je	SHORT $LN90@bin_write_
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+72], 5
	je	$LN95@bin_write_
$LN90@bin_write_:
	inc	r9d
	test	r10, r10
	mov	DWORD PTR count$1$[rbp], r9d
	je	SHORT $LN95@bin_write_
	mov	rax, QWORD PTR [rdi+104]
	mov	r9d, DWORD PTR [rax+12]
	mov	r8d, r9d
	shr	r9d, 4
	and	r8d, 15
	add	r8d, DWORD PTR [r11+20]
	cmp	QWORD PTR [rax], rsi
	je	SHORT $LN88@bin_write_
	mov	rcx, QWORD PTR [rax]
	mov	edx, DWORD PTR [rcx+16]
	mov	eax, edx
	sar	edx, 4
	and	eax, 15
	add	r8d, eax
	add	r9w, dx
$LN88@bin_write_:
	cmp	ebx, 9
	jne	SHORT $LN87@bin_write_
	add	r8d, 2
	jmp	SHORT $LN201@bin_write_
$LN87@bin_write_:
	cmp	ebx, 10
	jne	SHORT $LN201@bin_write_
	add	r8d, 4
$LN201@bin_write_:
	cmp	r8d, 65536				; 00010000H
	jb	SHORT $LN83@bin_write_
	lea	ecx, DWORD PTR [r8-65520]
	shr	rcx, 4
	add	r9w, cx
	npad	7
$LL84@bin_write_:
	add	r8d, -16				; fffffff0H
	dec	rcx
	jne	SHORT $LL84@bin_write_
$LN83@bin_write_:
	mov	WORD PTR [r10], r8w
	mov	WORD PTR [r10+2], r9w
	mov	r9d, DWORD PTR count$1$[rbp]
	add	r10, 4
$LN95@bin_write_:
	mov	r11, QWORD PTR [r11+8]
	test	r11, r11
	jne	$LL96@bin_write_
$LN99@bin_write_:
	mov	rdi, QWORD PTR [rdi+112]
	test	rdi, rdi
	jne	$LL100@bin_write_
$LN98@bin_write_:

; 1551 :         cp.sizehdr = (reloccnt * 4 + modinfo->mz_data.ofs_fixups + (modinfo->mz_data.alignment - 1)) & ~(modinfo->mz_data.alignment-1);

	movzx	r8d, WORD PTR [r13+414]
	movzx	eax, WORD PTR [r13+412]
	movzx	edx, r9w
	lea	ecx, DWORD PTR [r8+rax]
	lea	eax, DWORD PTR [r8-1]
	lea	r9d, DWORD PTR [rcx+rdx*4-1]
	not	eax
	and	r9d, eax
	xor	edi, edi
	mov	DWORD PTR cp$[rbp+8], r9d
$LN71@bin_write_:

; 1557 :     }
; 1558 :     cp.fileoffset = cp.sizehdr;
; 1559 : 
; 1560 :     if ( cp.sizehdr ) {

	test	r9d, r9d
	mov	r12d, r9d
	mov	DWORD PTR cp$[rbp+4], r9d
	je	SHORT $LN247@bin_write_

; 1561 :         hdrbuf = LclAlloc( cp.sizehdr );

	mov	ecx, r9d
	mov	ebx, r9d
	call	LclAlloc

; 1562 :         memset( hdrbuf, 0, cp.sizehdr );

	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	mov	QWORD PTR hdrbuf$1$[rbp], rax
	call	memset
	mov	r9d, DWORD PTR cp$[rbp+8]
	jmp	SHORT $LN68@bin_write_
$LN247@bin_write_:
	mov	rax, QWORD PTR hdrbuf$[rbp]
	mov	QWORD PTR hdrbuf$1$[rbp], rax
$LN68@bin_write_:

; 1563 :     }
; 1564 :     cp.entryoffset = -1;
; 1565 : 
; 1566 :     /* set starting offsets for all sections */
; 1567 : 
; 1568 : #if PE_SUPPORT
; 1569 :     cp.rva = 0;
; 1570 :     if ( modinfo->sub_format == SFORMAT_PE ) {

	cmp	DWORD PTR [r13+372], 2
	mov	r14d, -1				; ffffffffH
	mov	r8d, edi
	mov	DWORD PTR cp$[rbp+12], r14d
	mov	DWORD PTR cp$[rbp+28], edi
	jne	SHORT $LN67@bin_write_

; 1571 :         if ( ModuleInfo.model == MODEL_NONE ) {

	cmp	DWORD PTR ModuleInfo+360, esi
	jne	SHORT $LN66@bin_write_

; 1572 :             return( EmitErr( MODEL_IS_NOT_DECLARED ) );

	mov	ecx, 96					; 00000060H
	call	EmitErr
	jmp	$LN77@bin_write_
$LN66@bin_write_:

; 1573 :         }
; 1574 :         pe_set_values( &cp );

	lea	rcx, QWORD PTR cp$[rbp]
	call	pe_set_values

; 1575 :     } else

	jmp	$LN256@bin_write_
$LN67@bin_write_:

; 1576 : #endif
; 1577 :     if ( modinfo->segorder == SEGORDER_DOSSEG ) {

	mov	eax, DWORD PTR [r13+380]
	cmp	eax, 1
	jne	$LN64@bin_write_

; 1578 :         DebugMsg(("bin_write_module: .DOSSEG active\n" ));
; 1579 :         /* for .DOSSEG, regroup segments (CODE, UNDEF, DATA, BSS) */
; 1580 :         for ( i = 0 ; i < SIZE_DOSSEG; i++ ) {

	movzx	r15d, BYTE PTR cp$[rbp+1]
	movzx	r13d, BYTE PTR cp$[rbp]
	lea	rdx, OFFSET FLAT:dosseg_order
	mov	ecx, 6
	mov	QWORD PTR tv1775[rbp], rdx
	mov	QWORD PTR tv1848[rbp], rcx
	npad	10
$LL63@bin_write_:

; 1581 :             DebugMsg(("bin_write_module: searching segment types %Xh\n", dosseg_order[i] ));
; 1582 :             for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+32
	test	rbx, rbx
	je	$LN62@bin_write_
$LL60@bin_write_:

; 1583 :                 if ( curr->e.seginfo->segtype != dosseg_order[i] )

	mov	rcx, QWORD PTR [rbx+104]
	mov	eax, DWORD PTR [rcx+72]
	cmp	eax, DWORD PTR [rdx]
	jne	$LN59@bin_write_

; 1584 :                     continue;
; 1585 :                 CalcOffset( curr, &cp );

	cmp	eax, 5
	jne	SHORT $LN124@bin_write_
	movzx	eax, WORD PTR [rcx+88]
	shl	eax, 4
	mov	DWORD PTR [rcx+12], eax
	jmp	$LN59@bin_write_
$LN124@bin_write_:
	test	BYTE PTR [rcx+107], 2
	jne	$LN59@bin_write_
	cmp	r15b, BYTE PTR [rcx+106]
	mov	rsi, QWORD PTR [rcx]
	mov	eax, 1
	jbe	SHORT $LN121@bin_write_
	movzx	ecx, r15b
	jmp	SHORT $LN253@bin_write_
$LN121@bin_write_:
	movzx	ecx, BYTE PTR [rcx+106]
$LN253@bin_write_:
	shl	eax, cl
	lea	ecx, DWORD PTR [rax+r12-1]
	neg	eax
	and	ecx, eax
	sub	ecx, r12d
	add	r12d, ecx
	test	rsi, rsi
	mov	DWORD PTR cp$[rbp+4], r12d
	jne	SHORT $LN119@bin_write_
	mov	edi, r12d
	sub	edi, r9d
	jmp	SHORT $LN114@bin_write_
$LN119@bin_write_:
	cmp	DWORD PTR ModuleInfo+372, 2
	jne	SHORT $LN117@bin_write_
	mov	edi, r8d
	jmp	SHORT $LN114@bin_write_
$LN117@bin_write_:
	mov	eax, DWORD PTR [rsi+64]
	test	eax, eax
	jne	SHORT $LN115@bin_write_
	mov	eax, r12d
	sub	eax, r9d
	mov	DWORD PTR [rsi+16], eax
	jmp	SHORT $LN114@bin_write_
$LN115@bin_write_:
	lea	edi, DWORD PTR [rax+rcx]
$LN114@bin_write_:
	test	r13b, r13b
	jne	SHORT $LN112@bin_write_
	test	rsi, rsi
	je	SHORT $LN112@bin_write_
	cmp	rsi, QWORD PTR ModuleInfo+440
	jne	SHORT $LN111@bin_write_
	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, 36					; 00000024H
	call	strchr
	test	rax, rax
	je	SHORT $LN112@bin_write_
$LN111@bin_write_:
	mov	rax, QWORD PTR [rbx+104]
	mov	DWORD PTR [rax+8], 0
$LN112@bin_write_:
	mov	rax, QWORD PTR [rbx+104]
	mov	DWORD PTR [rax+56], r12d
	mov	rax, QWORD PTR [rbx+104]
	mov	DWORD PTR [rax+12], edi
	cmp	DWORD PTR ModuleInfo+372, 0
	mov	edx, DWORD PTR [rbx+64]
	jne	SHORT $LN110@bin_write_
	mov	rax, QWORD PTR [rbx+104]
	mov	ecx, DWORD PTR [rax+8]
	mov	eax, edx
	sub	eax, ecx
	add	r12d, eax
	mov	eax, DWORD PTR cp$[rbp+24]
	test	r13b, r13b
	cmovne	eax, ecx
	cmp	r14d, -1				; ffffffffH
	mov	DWORD PTR cp$[rbp+4], r12d
	mov	DWORD PTR cp$[rbp+24], eax
	jne	SHORT $LN105@bin_write_
	mov	r14d, edi
	mov	QWORD PTR cp$[rbp+16], rbx
	jmp	SHORT $LN105@bin_write_
$LN110@bin_write_:
	mov	rcx, QWORD PTR [rbx+104]
	mov	eax, edx
	sub	eax, DWORD PTR [rcx+8]
	add	DWORD PTR cp$[rbp+28], eax
	cmp	DWORD PTR [rcx+72], 3
	je	SHORT $LN105@bin_write_
	mov	rax, rcx
	mov	ecx, edx
	sub	ecx, DWORD PTR [rax+8]
	add	r12d, ecx
	mov	DWORD PTR cp$[rbp+4], r12d
$LN105@bin_write_:
	test	rsi, rsi
	je	SHORT $LN248@bin_write_
	lea	eax, DWORD PTR [rdx+rdi]
	cmp	eax, 65536				; 00010000H
	mov	DWORD PTR [rsi+64], eax
	jbe	SHORT $LN248@bin_write_
	cmp	BYTE PTR [rsi+52], 0
	jne	SHORT $LN248@bin_write_
	mov	r8, QWORD PTR [rsi+8]
	mov	edx, 276				; 00000114H
	mov	ecx, 2
	call	EmitWarn
$LN248@bin_write_:
	mov	rdx, QWORD PTR tv1775[rbp]
	mov	r8d, DWORD PTR cp$[rbp+28]
	xor	r13b, r13b
	xor	edi, edi
$LN59@bin_write_:
	mov	rbx, QWORD PTR [rbx+112]
	mov	r9d, DWORD PTR cp$[rbp+8]
	test	rbx, rbx
	jne	$LL60@bin_write_
	mov	rcx, QWORD PTR tv1848[rbp]
	mov	BYTE PTR cp$[rbp], r13b
	mov	DWORD PTR cp$[rbp+12], r14d
$LN62@bin_write_:
	mov	r9d, DWORD PTR cp$[rbp+8]
	add	rdx, 4
	dec	rcx
	mov	QWORD PTR tv1848[rbp], rcx
	mov	QWORD PTR tv1775[rbp], rdx
	jne	$LL63@bin_write_

; 1586 :                 DebugMsg(("bin_write_module: section %s, start ofs=%" I32_SPEC "Xh, size=%" I32_SPEC "Xh, file ofs=%" I32_SPEC "Xh\n",
; 1587 :                           curr->sym.name, curr->e.seginfo->start_offset, curr->sym.max_offset - curr->e.seginfo->start_loc, curr->e.seginfo->fileoffset ));
; 1588 :             }
; 1589 :         }
; 1590 :         SortSegments( 0 );

	xor	ecx, ecx
	call	SortSegments

; 1591 :     } else { /* segment order .SEQ (default) and .ALPHA */

	mov	rsi, QWORD PTR stack$1$[rbp]
	mov	r13, QWORD PTR modinfo$[rbp]
	jmp	SHORT $LN249@bin_write_
$LN64@bin_write_:

; 1592 :         
; 1593 :         if ( modinfo->segorder == SEGORDER_ALPHA ) {

	cmp	eax, 2
	jne	SHORT $LN55@bin_write_

; 1594 :             DebugMsg(("bin_write_module: .ALPHA active\n" ));
; 1595 :             SortSegments( 1 );

	lea	ecx, QWORD PTR [rax-1]
	call	SortSegments
$LN55@bin_write_:

; 1596 :         }
; 1597 :         for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+32
	test	rbx, rbx
	je	SHORT $LN249@bin_write_
	npad	1
$LL54@bin_write_:

; 1598 :             /* ignore absolute segments */
; 1599 :             CalcOffset( curr, &cp );

	lea	rdx, QWORD PTR cp$[rbp]
	mov	rcx, rbx
	call	CalcOffset
	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL54@bin_write_
$LN256@bin_write_:

; 1596 :         }
; 1597 :         for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	r14d, DWORD PTR cp$[rbp+12]
$LN249@bin_write_:

; 1600 :             DebugMsg(("bin_write_module(%s): start ofs=%" I32_SPEC "Xh, size=%" I32_SPEC "Xh, file ofs=%" I32_SPEC "Xh, grp=%s\n",
; 1601 :                       curr->sym.name, curr->e.seginfo->start_offset, curr->sym.max_offset - curr->e.seginfo->start_loc, curr->e.seginfo->fileoffset, (curr->e.seginfo->group ? curr->e.seginfo->group->name : "NULL" )));
; 1602 :         }
; 1603 :     }
; 1604 :     DebugMsg(("bin_write_module: all CalcOffset() done\n" ));
; 1605 : 
; 1606 :     /* handle relocs */
; 1607 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+32
	mov	r15d, DWORD PTR cp$[rbp+8]
	test	rbx, rbx
	je	SHORT $LN49@bin_write_
	npad	7
$LL51@bin_write_:

; 1608 :         /* v2.04: scan ALL fixups! */
; 1609 :         //if ( DoFixup( curr ) == ERROR )
; 1610 :         //    return( ERROR );
; 1611 :         DoFixup( curr, &cp );

	lea	rdx, QWORD PTR cp$[rbp]
	mov	rcx, rbx
	call	DoFixup

; 1612 : #if MZ_SUPPORT
; 1613 :         if ( stack == NULL &&
; 1614 :             curr->e.seginfo->combine == COMB_STACK )

	test	rsi, rsi
	jne	SHORT $LN50@bin_write_
	mov	rax, QWORD PTR [rbx+104]
	movzx	ecx, BYTE PTR [rax+108]
	and	cl, 7
	cmp	cl, 5
	cmove	rsi, rbx
$LN50@bin_write_:
	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL51@bin_write_
$LN49@bin_write_:

; 1615 :             stack = curr;
; 1616 : #endif
; 1617 :     }
; 1618 :     /* v2.04: return if any errors occured during fixup handling */
; 1619 :     if ( modinfo->g.error_count )

	cmp	DWORD PTR [r13], 0
	je	SHORT $LN47@bin_write_

; 1620 :         return( ERROR );

	mov	eax, -1
	jmp	$LN77@bin_write_
$LN47@bin_write_:

; 1621 : 
; 1622 :     /* for plain binaries make sure the start label is at
; 1623 :      * the beginning of the first segment */
; 1624 :     if ( modinfo->sub_format == SFORMAT_NONE ) {

	mov	r8d, DWORD PTR [r13+372]
	test	r8d, r8d
	jne	SHORT $LN44@bin_write_

; 1625 :         if ( modinfo->g.start_label ) {

	mov	rax, QWORD PTR [r13+208]
	test	rax, rax
	je	SHORT $LN44@bin_write_

; 1626 :             if ( cp.entryoffset == -1 || cp.entryseg != modinfo->g.start_label->segment ) {

	cmp	r14d, -1				; ffffffffH
	je	SHORT $LN43@bin_write_
	mov	rax, QWORD PTR [rax+32]
	cmp	QWORD PTR cp$[rbp+16], rax
	je	SHORT $LN44@bin_write_
$LN43@bin_write_:

; 1627 :                 return( EmitError( START_LABEL_INVALID ) );

	mov	ecx, 202				; 000000caH
	call	EmitError
	jmp	$LN77@bin_write_
$LN44@bin_write_:

; 1628 :             }
; 1629 :         }
; 1630 :     }
; 1631 : 
; 1632 :     sizetotal = GetImageSize( FALSE );

	mov	rdx, QWORD PTR SymTables+32
	mov	r13d, edi
	test	rdx, rdx
	je	SHORT $LN246@bin_write_
$LL141@bin_write_:
	mov	rax, QWORD PTR [rdx+104]
	cmp	DWORD PTR [rax+72], 5
	je	SHORT $LN140@bin_write_
	test	BYTE PTR [rax+107], 2
	jne	SHORT $LN140@bin_write_
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN218@bin_write_
	mov	rcx, QWORD PTR [rdx+112]
$LN255@bin_write_:
	test	rcx, rcx
	je	SHORT $LN246@bin_write_
	mov	rax, QWORD PTR [rcx+104]
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN218@bin_write_
	mov	rcx, QWORD PTR [rcx+112]
	jmp	SHORT $LN255@bin_write_
$LN218@bin_write_:
	mov	rax, QWORD PTR [rdx+104]
	mov	ecx, DWORD PTR [rax+56]
	sub	ecx, DWORD PTR [rax+8]
	add	ecx, DWORD PTR [rdx+64]
	cmp	r13d, ecx
	cmovb	r13d, ecx
$LN140@bin_write_:
	mov	rdx, QWORD PTR [rdx+112]
	test	rdx, rdx
	jne	SHORT $LL141@bin_write_
$LN246@bin_write_:

; 1633 : 
; 1634 :     /* for MZ|PE format, initialize the header */
; 1635 : 
; 1636 :     switch ( modinfo->sub_format ) {

	dec	r8d

; 1637 : #if MZ_SUPPORT
; 1638 :     case SFORMAT_MZ:
; 1639 :         /* set fields in MZ header */
; 1640 :         pMZ = (struct IMAGE_DOS_HEADER *)hdrbuf;
; 1641 :         pMZ->e_magic   = 'M' + ('Z' << 8);

	mov	r14, QWORD PTR hdrbuf$1$[rbp]
	jne	$LN250@bin_write_

; 1642 :         pMZ->e_cblp    = sizetotal % 512; /* bytes last page */

	movzx	eax, r13w

; 1643 :         pMZ->e_cp      = sizetotal / 512 + (sizetotal % 512 ? 1 : 0); /* pages */

	mov	ecx, edi
	mov	WORD PTR [r14], 23117			; 00005a4dH
	and	ax, 511					; 000001ffH
	test	r13d, 511				; 000001ffH

; 1644 :         pMZ->e_crlc    = reloccnt;
; 1645 :         pMZ->e_cparhdr = cp.sizehdr >> 4; /* size header in paras */
; 1646 :         sizeheap = GetImageSize( TRUE ) - sizetotal;

	mov	r9d, edi
	mov	WORD PTR [r14+2], ax
	setne	cl
	mov	eax, r13d
	shr	eax, 9
	mov	r12d, edi
	mov	r10b, 1
	add	cx, ax
	mov	eax, DWORD PTR count$1$[rbp]
	mov	WORD PTR [r14+6], ax
	mov	eax, r15d
	mov	WORD PTR [r14+4], cx
	shr	eax, 4
	mov	WORD PTR [r14+8], ax
	mov	rdx, QWORD PTR SymTables+32
	test	rdx, rdx
	je	SHORT $LN221@bin_write_
$LL158@bin_write_:
	mov	r8, QWORD PTR [rdx+104]
	cmp	DWORD PTR [r8+72], 5
	je	SHORT $LN157@bin_write_
	test	BYTE PTR [r8+107], 2
	jne	SHORT $LN157@bin_write_
	mov	ecx, DWORD PTR [r8+56]
	sub	ecx, DWORD PTR [r8+8]
	add	ecx, DWORD PTR [rdx+64]
	test	r10b, r10b
	jne	SHORT $LN146@bin_write_
	add	r9d, DWORD PTR [r8+8]
$LN146@bin_write_:
	add	ecx, r9d
	cmp	r12d, ecx
	cmovb	r12d, ecx
	xor	r10b, r10b
$LN157@bin_write_:
	mov	rdx, QWORD PTR [rdx+112]
	test	rdx, rdx
	jne	SHORT $LL158@bin_write_
$LN221@bin_write_:

; 1647 :         DebugMsg(( "bin_write_module: MZ, sizetotal=%" I32_SPEC "Xh sizeheap=%" I32_SPEC "Xh\n", sizetotal, sizeheap ));
; 1648 :         pMZ->e_minalloc = sizeheap / 16 + ((sizeheap % 16) ? 1 : 0); /* heap min */
; 1649 :         if ( pMZ->e_minalloc < modinfo->mz_data.heapmin )

	mov	rbx, QWORD PTR modinfo$[rbp]
	sub	r12d, r13d
	mov	ecx, edi
	test	r12b, 15
	mov	eax, r12d
	mov	DWORD PTR sizeheap$1$[rbp], r12d
	setne	cl
	shr	eax, 4
	add	cx, ax
	mov	WORD PTR [r14+10], cx
	movzx	eax, WORD PTR [rbx+416]
	cmp	cx, ax
	jae	SHORT $LN39@bin_write_

; 1650 :             pMZ->e_minalloc = modinfo->mz_data.heapmin;

	mov	WORD PTR [r14+10], ax
$LN39@bin_write_:

; 1651 :         pMZ->e_maxalloc = modinfo->mz_data.heapmax; /* heap max */

	movzx	eax, WORD PTR [rbx+418]

; 1652 :         if ( pMZ->e_maxalloc < pMZ->e_minalloc )

	movzx	ecx, WORD PTR [r14+10]
	cmp	ax, cx
	mov	WORD PTR [r14+12], ax
	jae	SHORT $LN38@bin_write_

; 1653 :             pMZ->e_maxalloc = pMZ->e_minalloc;

	mov	WORD PTR [r14+12], cx
$LN38@bin_write_:

; 1654 : 
; 1655 :         /* set stack if there's one defined */
; 1656 : 
; 1657 :         if ( stack ) {

	test	rsi, rsi
	je	SHORT $LN37@bin_write_

; 1658 :             uint_32 addr = stack->e.seginfo->start_offset;

	mov	rax, QWORD PTR [rsi+104]

; 1659 :             if ( stack->e.seginfo->group )

	cmp	QWORD PTR [rax], 0
	mov	edx, DWORD PTR [rax+12]
	je	SHORT $LN36@bin_write_

; 1660 :                 addr += stack->e.seginfo->group->offset;

	mov	rcx, QWORD PTR [rax]
	add	edx, DWORD PTR [rcx+16]
$LN36@bin_write_:

; 1661 :             DebugMsg(("bin_write_module: MZ, stack=%" I32_SPEC "Xh ofs=%" I32_SPEC "Xh\n", addr, stack->sym.max_offset ));
; 1662 :             pMZ->e_ss = (addr >> 4) + ((addr & 0xF) ? 1 : 0); /* SS */

	test	dl, 15
	mov	eax, edi
	setne	al
	shr	edx, 4
	add	ax, dx
	mov	WORD PTR [r14+14], ax

; 1663 :             /* v2.11: changed sym.offset to sym.max_offset */
; 1664 :             pMZ->e_sp = stack->sym.max_offset; /* SP */

	movzx	eax, WORD PTR [rsi+64]
	mov	WORD PTR [r14+16], ax

; 1665 :         } else {

	jmp	SHORT $LN35@bin_write_
$LN37@bin_write_:

; 1666 :             EmitWarn( 2, NO_STACK );

	mov	edx, 204				; 000000ccH
	mov	ecx, 2
	call	EmitWarn
$LN35@bin_write_:

; 1667 :         }
; 1668 :         pMZ->e_csum = 0; /* checksum */

	mov	WORD PTR [r14+18], 0

; 1669 : 
; 1670 :         /* set entry CS:IP if defined */
; 1671 : 
; 1672 :         if ( modinfo->g.start_label ) {

	mov	r8, QWORD PTR [rbx+208]
	test	r8, r8
	je	SHORT $LN34@bin_write_

; 1673 :             uint_32 addr;
; 1674 :             curr = (struct dsym *)modinfo->g.start_label->segment;

	mov	rcx, QWORD PTR [r8+32]

; 1675 :             DebugMsg(("bin_write_module, start_label: offs=%" I32_SPEC "Xh, seg.offs=%" I32_SPEC "Xh, group.offs=%" I32_SPEC "Xh\n",
; 1676 :                       modinfo->g.start_label->offset, curr->e.seginfo->start_offset, curr->e.seginfo->group ? curr->e.seginfo->group->offset : 0 ));
; 1677 :             if ( curr->e.seginfo->group ) {

	mov	rax, QWORD PTR [rcx+104]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN33@bin_write_

; 1678 :                 addr = curr->e.seginfo->group->offset;
; 1679 :                 pMZ->e_ip = (addr & 0xF ) + curr->e.seginfo->start_offset + modinfo->g.start_label->offset; /* IP */

	movzx	ecx, WORD PTR [rax+12]
	mov	rax, QWORD PTR [rax]
	mov	edx, DWORD PTR [rax+16]
	mov	al, dl
	and	ax, 15
	add	cx, ax
	add	cx, WORD PTR [r8+16]

; 1680 :                 pMZ->e_cs = addr >> 4; /* CS */

	shr	edx, 4
	mov	WORD PTR [r14+20], cx
	mov	WORD PTR [r14+22], dx

; 1681 :             } else {

	jmp	SHORT $LN31@bin_write_
$LN33@bin_write_:

; 1682 :                 addr = curr->e.seginfo->start_offset;

	mov	ecx, DWORD PTR [rax+12]

; 1683 :                 pMZ->e_ip = (addr & 0xF ) + modinfo->g.start_label->offset; /* IP */

	mov	al, cl
	and	ax, 15
	add	ax, WORD PTR [r8+16]

; 1684 :                 pMZ->e_cs = addr >> 4; /* CS */

	shr	ecx, 4
	mov	WORD PTR [r14+20], ax
	mov	WORD PTR [r14+22], cx

; 1685 :             }
; 1686 :         } else {

	jmp	SHORT $LN31@bin_write_
$LN34@bin_write_:

; 1687 :             DebugMsg(("bin_write_module, ModuleInfo->start_label=%p\n", modinfo->g.start_label ));
; 1688 :             EmitWarn( 2, NO_START_LABEL );

	mov	edx, 203				; 000000cbH
	mov	ecx, 2
	call	EmitWarn
$LN31@bin_write_:

; 1689 :         }
; 1690 :         pMZ->e_lfarlc = modinfo->mz_data.ofs_fixups;

	movzx	eax, WORD PTR [rbx+412]
	mov	WORD PTR [r14+24], ax

; 1691 :         DebugMsg(("bin_write_module: MZ, mzdata ofs_fixups=%Xh, alignment=%Xh\n", modinfo->mz_data.ofs_fixups, modinfo->mz_data.alignment ));
; 1692 :         GetSegRelocs( (uint_16 *)( hdrbuf + pMZ->e_lfarlc ) );

	mov	rdi, QWORD PTR SymTables+32
	test	rdi, rdi
	lea	r10, QWORD PTR [r14+rax]
	je	$LN252@bin_write_
	npad	9
$LL178@bin_write_:
	mov	r11, QWORD PTR [rdi+104]
	cmp	DWORD PTR [r11+72], 5
	je	$LN177@bin_write_
	mov	r11, QWORD PTR [r11+40]
	test	r11, r11
	je	$LN177@bin_write_
	npad	4
$LL174@bin_write_:
	mov	ebx, DWORD PTR [r11+24]
	lea	eax, DWORD PTR [rbx-8]
	cmp	eax, 2
	ja	$LN173@bin_write_
	mov	rax, QWORD PTR [r11+56]
	test	rax, rax
	je	SHORT $LN168@bin_write_
	mov	rax, QWORD PTR [rax+32]
	test	rax, rax
	je	SHORT $LN168@bin_write_
	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+72], 5
	je	SHORT $LN173@bin_write_
$LN168@bin_write_:
	test	r10, r10
	je	SHORT $LN173@bin_write_
	mov	rax, QWORD PTR [rdi+104]
	mov	r9d, DWORD PTR [rax+12]
	mov	r8d, r9d
	shr	r9d, 4
	and	r8d, 15
	add	r8d, DWORD PTR [r11+20]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN166@bin_write_
	mov	rcx, QWORD PTR [rax]
	mov	edx, DWORD PTR [rcx+16]
	mov	eax, edx
	sar	edx, 4
	and	eax, 15
	add	r8d, eax
	add	r9w, dx
$LN166@bin_write_:
	cmp	ebx, 9
	jne	SHORT $LN165@bin_write_
	add	r8d, 2
	jmp	SHORT $LN212@bin_write_
$LN165@bin_write_:
	cmp	ebx, 10
	jne	SHORT $LN212@bin_write_
	add	r8d, 4
$LN212@bin_write_:
	cmp	r8d, 65536				; 00010000H
	jb	SHORT $LN161@bin_write_
	lea	ecx, DWORD PTR [r8-65520]
	shr	rcx, 4
	add	r9w, cx
	npad	1
$LL162@bin_write_:
	add	r8d, -16				; fffffff0H
	dec	rcx
	jne	SHORT $LL162@bin_write_
$LN161@bin_write_:
	mov	WORD PTR [r10], r8w
	mov	WORD PTR [r10+2], r9w
	add	r10, 4
$LN173@bin_write_:
	mov	r11, QWORD PTR [r11+8]
	test	r11, r11
	jne	$LL174@bin_write_
$LN177@bin_write_:
	mov	rdi, QWORD PTR [rdi+112]
	test	rdi, rdi
	jne	$LL178@bin_write_
$LN252@bin_write_:

; 1562 :         memset( hdrbuf, 0, cp.sizehdr );

	xor	edi, edi

; 1691 :         DebugMsg(("bin_write_module: MZ, mzdata ofs_fixups=%Xh, alignment=%Xh\n", modinfo->mz_data.ofs_fixups, modinfo->mz_data.alignment ));
; 1692 :         GetSegRelocs( (uint_16 *)( hdrbuf + pMZ->e_lfarlc ) );

$LN176@bin_write_:

; 1693 :         break;
; 1694 : #endif
; 1695 :     }
; 1696 : 
; 1697 : #if SECTORMAP
; 1698 :     if( CurrFile[LST] ) {

	mov	rcx, QWORD PTR ModuleInfo+112
	test	rcx, rcx
	je	SHORT $LN30@bin_write_

; 1699 :         /* go to EOF */
; 1700 :         fseek( CurrFile[LST], 0, SEEK_END );

	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+2]
	call	fseek

; 1701 :         LstNL();

	call	LstNL

; 1702 :         LstNL();

	call	LstNL

; 1703 :         LstPrintf( szCaption );

	lea	rcx, OFFSET FLAT:szCaption
	call	LstPrintf

; 1704 :         LstNL();

	call	LstNL

; 1705 :         LstNL();

	call	LstNL

; 1706 :         LstPrintf( szCaption2 );

	lea	rcx, OFFSET FLAT:szCaption2
	call	LstPrintf

; 1707 :         LstNL();

	call	LstNL

; 1708 :         LstPrintf( szSep );

	lea	rcx, OFFSET FLAT:szSep
	call	LstPrintf

; 1709 :         LstNL();

	call	LstNL
$LN30@bin_write_:

; 1710 :     }
; 1711 : #endif
; 1712 : 
; 1713 :     if ( cp.sizehdr ) {

	test	r15d, r15d
	je	SHORT $LN29@bin_write_

; 1714 :         if ( fwrite( hdrbuf, 1, cp.sizehdr, CurrFile[OBJ] ) != cp.sizehdr )

	mov	r9, QWORD PTR ModuleInfo+104
	mov	r8d, r15d
	mov	edx, 1
	mov	rcx, r14
	mov	ebx, r15d
	call	fwrite
	cmp	rax, rbx
	je	SHORT $LN28@bin_write_

; 1715 :             WriteError();

	call	WriteError
$LN28@bin_write_:

; 1716 : #if SECTORMAP
; 1717 :         LstPrintf( szSegLine, szHeader, 0, 0, cp.sizehdr, 0 );

	lea	rdx, OFFSET FLAT:szHeader
	lea	rcx, OFFSET FLAT:szSegLine
	xor	r9d, r9d
	xor	r8d, r8d
	mov	QWORD PTR [rsp+40], rdi
	mov	DWORD PTR [rsp+32], r15d
	call	LstPrintf

; 1718 :         LstNL();

	call	LstNL
$LN29@bin_write_:

; 1719 : #endif
; 1720 :         LclFree( hdrbuf );
; 1721 :     }
; 1722 : 
; 1723 : #ifdef DEBUG_OUT
; 1724 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {
; 1725 :         DebugMsg(("bin_write_module(%s): type=%u written=%" I32_SPEC "X max=%" I32_SPEC "X start=%" I32_SPEC "X fileofs=%" I32_SPEC "X\n",
; 1726 :                 curr->sym.name, curr->e.seginfo->segtype,
; 1727 :                 curr->e.seginfo->bytes_written,
; 1728 :                 curr->sym.max_offset,
; 1729 :                 curr->e.seginfo->start_loc,
; 1730 :                 curr->e.seginfo->fileoffset ));
; 1731 :     }
; 1732 : #endif
; 1733 : 
; 1734 :     /* write sections */
; 1735 :     for( curr = SymTables[TAB_SEG].head, first = TRUE; curr; curr = curr->next ) {

	mov	rdi, QWORD PTR SymTables+32
	mov	r8d, 1
	test	rdi, rdi
	je	$LN25@bin_write_
	xor	r12d, r12d
	npad	11
$LL27@bin_write_:

; 1736 :         if ( curr->e.seginfo->segtype == SEGTYPE_ABS ) {

	mov	rdx, QWORD PTR [rdi+104]
	mov	eax, DWORD PTR [rdx+72]
	cmp	eax, 5
	je	$LN26@bin_write_

; 1737 :             DebugMsg(("bin_write_module(%s): ABS segment not written\n", curr->sym.name ));
; 1738 :             continue;
; 1739 :         }
; 1740 : #if PE_SUPPORT
; 1741 :         if ( ModuleInfo.sub_format == SFORMAT_PE &&
; 1742 :             ( curr->e.seginfo->segtype == SEGTYPE_BSS || curr->e.seginfo->info ) )

	cmp	DWORD PTR ModuleInfo+372, 2
	jne	SHORT $LN23@bin_write_
	cmp	eax, 3
	je	SHORT $LN22@bin_write_
	test	BYTE PTR [rdx+107], 2
	je	SHORT $LN23@bin_write_
$LN22@bin_write_:

; 1743 :             size = 0;

	mov	esi, r12d

; 1744 :         else

	jmp	SHORT $LN21@bin_write_
$LN250@bin_write_:

; 1691 :         DebugMsg(("bin_write_module: MZ, mzdata ofs_fixups=%Xh, alignment=%Xh\n", modinfo->mz_data.ofs_fixups, modinfo->mz_data.alignment ));
; 1692 :         GetSegRelocs( (uint_16 *)( hdrbuf + pMZ->e_lfarlc ) );

	mov	r12d, DWORD PTR sizeheap$[rbp]
	mov	DWORD PTR sizeheap$1$[rbp], r12d
	jmp	$LN176@bin_write_
$LN23@bin_write_:

; 1745 : #endif
; 1746 :             /* v2.05: changed */
; 1747 :             size = curr->sym.max_offset - curr->e.seginfo->start_loc;

	mov	esi, DWORD PTR [rdi+64]
	sub	esi, DWORD PTR [rdx+8]
$LN21@bin_write_:

; 1748 :         //size = sizemem;
; 1749 :         sizemem = first ? size : curr->sym.max_offset;

	test	r8d, r8d
	mov	r10d, esi
	jne	SHORT $LN80@bin_write_
	mov	r10d, DWORD PTR [rdi+64]
$LN80@bin_write_:

; 1750 :         /* if no bytes have been written to the segment, check if there's
; 1751 :          * any further segments with bytes set. If no, skip write! */
; 1752 :         if ( curr->e.seginfo->bytes_written == 0 ) {

	cmp	DWORD PTR [rdx+24], r12d
	jne	SHORT $LN15@bin_write_

; 1753 :             struct dsym *dir;
; 1754 :             for ( dir = curr->next; dir; dir = dir->next )

	mov	rcx, QWORD PTR [rdi+112]
	test	rcx, rcx
	je	SHORT $LN245@bin_write_
	npad	6
$LL19@bin_write_:

; 1755 :                 if ( dir->e.seginfo->bytes_written )

	mov	rax, QWORD PTR [rcx+104]
	cmp	DWORD PTR [rax+24], r12d
	jne	SHORT $LN15@bin_write_
	mov	rcx, QWORD PTR [rcx+112]
	test	rcx, rcx
	jne	SHORT $LL19@bin_write_
$LN245@bin_write_:

; 1756 :                     break;
; 1757 :             if ( !dir ) {
; 1758 :                 DebugMsg(("bin_write_module(%s): segment not written, size=% " I32_SPEC "Xh sizemem=%" I32_SPEC "X\n",
; 1759 :                           curr->sym.name, size, sizemem ));
; 1760 :                 size = 0;

	mov	esi, r12d
$LN15@bin_write_:

; 1761 :             }
; 1762 :         }
; 1763 : #if SECTORMAP
; 1764 :         /* v2.05: changed
; 1765 :          * print name, fileoffset, objoffset, filesize, memsize
; 1766 :          */
; 1767 :         //LstPrintf( szSegLine, curr->sym.name, curr->e.seginfo->fileoffset, curr->e.seginfo->start_offset + curr->e.seginfo->start_loc, size, sizemem );
; 1768 :         LstPrintf( szSegLine, curr->sym.name, curr->e.seginfo->fileoffset, first ? curr->e.seginfo->start_offset + curr->e.seginfo->start_loc : curr->e.seginfo->start_offset, size, sizemem );

	test	r8d, r8d
	mov	r9d, DWORD PTR [rdx+12]
	je	SHORT $LN82@bin_write_
	add	r9d, DWORD PTR [rdx+8]
$LN82@bin_write_:
	mov	r8d, DWORD PTR [rdx+56]
	mov	rdx, QWORD PTR [rdi+8]
	mov	DWORD PTR [rsp+40], r10d
	lea	rcx, OFFSET FLAT:szSegLine
	mov	DWORD PTR [rsp+32], esi
	call	LstPrintf

; 1769 :         LstNL();

	call	LstNL

; 1770 : #endif
; 1771 : 		if (size != 0 && curr->e.seginfo->CodeBuffer) {

	test	esi, esi
	je	$LN7@bin_write_
	mov	rax, QWORD PTR [rdi+104]
	cmp	QWORD PTR [rax+16], r12
	je	$LN7@bin_write_

; 1772 : 			DebugMsg(("bin_write_module(%s): write %" I32_SPEC "Xh bytes at offset %" I32_SPEC "Xh, initialized bytes=%" I32_SPEC "u, buffer=%p\n",
; 1773 : 				curr->sym.name, size, curr->e.seginfo->fileoffset, curr->e.seginfo->bytes_written, curr->e.seginfo->CodeBuffer));
; 1774 : 			fseek(CurrFile[OBJ], curr->e.seginfo->fileoffset, SEEK_SET);

	mov	edx, DWORD PTR [rax+56]
	mov	rcx, QWORD PTR ModuleInfo+104
	xor	r8d, r8d
	call	fseek

; 1775 : #ifdef __I86__
; 1776 : 			if (hfwrite(curr->e.seginfo->CodeBuffer, 1, size, CurrFile[OBJ]) != size)
; 1777 : 				WriteError();
; 1778 : #else
; 1779 : 			if (ModuleInfo.flat)

	cmp	BYTE PTR ModuleInfo+772, r12b
	je	SHORT $LN13@bin_write_

; 1780 : 			{
; 1781 : 				/* For flat type we have to write out one byte at a time and verify it against the org fixup list */
; 1782 : 				origsize = size;
; 1783 : 				codeptr = curr->e.seginfo->CodeBuffer;

	mov	rdx, QWORD PTR [rdi+104]
	mov	rbx, QWORD PTR [rdx+16]
	add	rdx, 16

; 1784 : 				while (codeptr < (curr->e.seginfo->CodeBuffer+size))

	lea	rax, QWORD PTR [rsi+rbx]
	cmp	rbx, rax
	jae	SHORT $LN7@bin_write_
	npad	5
$LL12@bin_write_:

; 1785 : 				{
; 1786 : 					if (!InOrgRange(codeptr - curr->e.seginfo->CodeBuffer))

	mov	ecx, ebx
	sub	ecx, DWORD PTR [rdx]
	call	InOrgRange
	test	al, al
	jne	SHORT $LN9@bin_write_

; 1787 : 					{
; 1788 : 						writesize = fwrite(codeptr, 1, 1, CurrFile[OBJ]);

	mov	r9, QWORD PTR ModuleInfo+104
	mov	edx, 1
	mov	rcx, rbx
	mov	r8, rdx
	call	fwrite

; 1789 : 						if (writesize != 1)

	cmp	eax, 1
	je	SHORT $LN9@bin_write_

; 1790 : 							WriteError();

	call	WriteError
$LN9@bin_write_:

; 1784 : 				while (codeptr < (curr->e.seginfo->CodeBuffer+size))

	mov	rdx, QWORD PTR [rdi+104]

; 1791 : 					}
; 1792 : 					codeptr++;

	inc	rbx
	mov	rax, QWORD PTR [rdx+16]
	add	rdx, 16
	lea	rcx, QWORD PTR [rsi+rax]
	cmp	rbx, rcx
	jb	SHORT $LL12@bin_write_

; 1793 : 				}
; 1794 : 			}
; 1795 : 			else

	jmp	SHORT $LN7@bin_write_
$LN13@bin_write_:

; 1796 : 			{
; 1797 : 				if (fwrite(curr->e.seginfo->CodeBuffer, 1, size, CurrFile[OBJ]) != size)

	mov	rcx, QWORD PTR [rdi+104]
	mov	r9, QWORD PTR ModuleInfo+104
	mov	r8d, esi
	mov	rcx, QWORD PTR [rcx+16]
	mov	edx, 1
	mov	ebx, esi
	call	fwrite
	cmp	rax, rbx
	je	SHORT $LN7@bin_write_

; 1798 : 					WriteError();

	call	WriteError
$LN7@bin_write_:

; 1799 : 			}
; 1800 : #endif
; 1801 :         }
; 1802 : #ifdef DEBUG_OUT
; 1803 :         else DebugMsg(("bin_write_module(%s): nothing written\n", curr->sym.name ));
; 1804 : #endif
; 1805 :         first = FALSE;

	mov	r8d, r12d
$LN26@bin_write_:

; 1719 : #endif
; 1720 :         LclFree( hdrbuf );
; 1721 :     }
; 1722 : 
; 1723 : #ifdef DEBUG_OUT
; 1724 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {
; 1725 :         DebugMsg(("bin_write_module(%s): type=%u written=%" I32_SPEC "X max=%" I32_SPEC "X start=%" I32_SPEC "X fileofs=%" I32_SPEC "X\n",
; 1726 :                 curr->sym.name, curr->e.seginfo->segtype,
; 1727 :                 curr->e.seginfo->bytes_written,
; 1728 :                 curr->sym.max_offset,
; 1729 :                 curr->e.seginfo->start_loc,
; 1730 :                 curr->e.seginfo->fileoffset ));
; 1731 :     }
; 1732 : #endif
; 1733 : 
; 1734 :     /* write sections */
; 1735 :     for( curr = SymTables[TAB_SEG].head, first = TRUE; curr; curr = curr->next ) {

	mov	rdi, QWORD PTR [rdi+112]
	test	rdi, rdi
	jne	$LL27@bin_write_
	mov	r12d, DWORD PTR sizeheap$1$[rbp]
$LN25@bin_write_:

; 1806 :     }
; 1807 : #if PE_SUPPORT && RAWSIZE_ROUND
; 1808 :     if ( modinfo->sub_format == SFORMAT_PE ) {

	mov	rsi, QWORD PTR modinfo$[rbp]
	cmp	DWORD PTR [rsi+372], 2
	jne	SHORT $LN5@bin_write_

; 1809 :         size = ftell( CurrFile[OBJ] );

	mov	rcx, QWORD PTR ModuleInfo+104
	call	ftell

; 1810 :         if ( size & ( cp.rawpagesize - 1 ) ) {

	mov	edx, DWORD PTR cp$[rbp+40]
	lea	ecx, DWORD PTR [rdx-1]
	and	ecx, eax
	je	SHORT $LN5@bin_write_

; 1811 :             char *tmp;
; 1812 :             size = cp.rawpagesize - ( size & ( cp.rawpagesize - 1 ) );

	sub	edx, ecx

; 1813 :             tmp = myalloca( size );

	mov	edi, edx
	lea	rax, QWORD PTR [rdx+15]
	and	rax, -16
	call	__chkstk
	sub	rsp, rax

; 1814 :             memset( tmp, 0, size );

	mov	r8d, edx
	lea	rbx, QWORD PTR [rsp+48]
	xor	edx, edx
	mov	rcx, rbx
	call	memset

; 1815 :             fwrite( tmp, 1, size, CurrFile[OBJ] );

	mov	r9, QWORD PTR ModuleInfo+104
	mov	r8, rdi
	mov	edx, 1
	mov	rcx, rbx
	call	fwrite
$LN5@bin_write_:

; 1816 :         }
; 1817 :     }
; 1818 : #endif
; 1819 : #if SECTORMAP
; 1820 :     LstPrintf( szSep );

	lea	rcx, OFFSET FLAT:szSep
	call	LstPrintf

; 1821 :     LstNL();

	call	LstNL

; 1822 : #if MZ_SUPPORT
; 1823 :     if ( modinfo->sub_format == SFORMAT_MZ )

	mov	r11d, DWORD PTR [rsi+372]
	cmp	r11d, 1
	jne	SHORT $LN4@bin_write_

; 1824 :         sizeheap += sizetotal - cp.sizehdr;

	mov	eax, r13d
	sub	eax, r15d
	add	r12d, eax

; 1825 :     else

	jmp	SHORT $LN1@bin_write_
$LN4@bin_write_:

; 1826 : #endif
; 1827 : #if PE_SUPPORT
; 1828 :     if ( modinfo->sub_format == SFORMAT_PE )

	cmp	r11d, 2
	jne	SHORT $LN2@bin_write_

; 1829 :         sizeheap = cp.rva;

	mov	r12d, DWORD PTR cp$[rbp+28]

; 1830 :     else

	jmp	SHORT $LN1@bin_write_
$LN2@bin_write_:

; 1831 : #endif
; 1832 :         sizeheap = GetImageSize( TRUE );

	mov	rdx, QWORD PTR SymTables+32
	xor	r10d, r10d
	mov	r9b, 1
	test	rdx, rdx
	mov	r12d, r10d
	je	SHORT $LN1@bin_write_
$LL195@bin_write_:
	mov	r8, QWORD PTR [rdx+104]
	cmp	DWORD PTR [r8+72], 5
	je	SHORT $LN194@bin_write_
	test	BYTE PTR [r8+107], 2
	jne	SHORT $LN194@bin_write_
	mov	ecx, DWORD PTR [r8+56]
	sub	ecx, DWORD PTR [r8+8]
	add	ecx, DWORD PTR [rdx+64]
	test	r9b, r9b
	jne	SHORT $LN183@bin_write_
	add	r10d, DWORD PTR [r8+8]
$LN183@bin_write_:
	add	ecx, r10d
	cmp	r12d, ecx
	cmovb	r12d, ecx
	xor	r9b, r9b
$LN194@bin_write_:
	mov	rdx, QWORD PTR [rdx+112]
	test	rdx, rdx
	jne	SHORT $LL195@bin_write_
$LN1@bin_write_:

; 1833 :     LstPrintf( szTotal, " ", sizetotal, sizeheap );

	lea	rdx, OFFSET FLAT:$SG6827
	lea	rcx, OFFSET FLAT:szTotal
	mov	r9d, r12d
	mov	r8d, r13d
	call	LstPrintf

; 1834 :     LstNL();

	call	LstNL

; 1835 : #endif
; 1836 :     DebugMsg(("bin_write_module: exit\n"));
; 1837 : 
; 1838 :     return( NOT_ERROR );

	xor	eax, eax
$LN77@bin_write_:

; 1839 : }

	mov	rbx, QWORD PTR [rbp+152]
	mov	rsi, QWORD PTR [rbp+160]
	mov	rdi, QWORD PTR [rbp+168]
	mov	r12, QWORD PTR [rbp+120]
	mov	r13, QWORD PTR [rbp+112]
	mov	r14, QWORD PTR [rbp+104]
	mov	r15, QWORD PTR [rbp+96]
	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
bin_write_module ENDP
; Function compile flags: /Ogtpy
modinfo$ = 8
bin_check_external PROC NEAR

; 1845 :     struct dsym *curr;
; 1846 :     for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next )

	mov	rdx, QWORD PTR SymTables+16
	test	rdx, rdx
	je	SHORT $LN3@bin_check_
	npad	4
$LL5@bin_check_:

; 1847 :         if( curr->sym.weak == FALSE || curr->sym.used == TRUE ) {

	test	BYTE PTR [rdx+55], 8
	je	SHORT $LN9@bin_check_
	test	BYTE PTR [rdx+48], 1
	jne	SHORT $LN9@bin_check_
	mov	rdx, QWORD PTR [rdx+112]
	test	rdx, rdx
	jne	SHORT $LL5@bin_check_
$LN3@bin_check_:

; 1850 :         }
; 1851 :     return( NOT_ERROR );

	xor	eax, eax

; 1852 : }

	ret	0
$LN9@bin_check_:

; 1848 :             DebugMsg(("CheckExternal: error, %s weak=%u\n", curr->sym.name, curr->sym.weak ));
; 1849 :             return( EmitErr( FORMAT_DOESNT_SUPPORT_EXTERNALS, curr->sym.name ) );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 201				; 000000c9H

; 1852 : }

	jmp	EmitErr
bin_check_external ENDP
_TEXT	ENDS
PUBLIC	bin_init
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
modinfo$ = 8
bin_init PROC NEAR

; 1858 :     modinfo->g.WriteModule = bin_write_module;
; 1859 :     modinfo->g.Pass1Checks = bin_check_external;
; 1860 :     switch ( modinfo->sub_format ) {

	mov	edx, DWORD PTR [rcx+372]
	lea	rax, OFFSET FLAT:bin_write_module
	dec	edx
	mov	QWORD PTR [rcx+288], rax
	lea	rax, OFFSET FLAT:bin_check_external
	mov	QWORD PTR [rcx+304], rax
	je	SHORT $LN2@bin_init
	dec	edx
	jne	SHORT $LN3@bin_init

; 1864 :         break;
; 1865 : #endif
; 1866 : #if PE_SUPPORT
; 1867 :     case SFORMAT_PE:
; 1868 :         modinfo->g.EndDirHook = pe_enddirhook; /* v2.11 */

	lea	rax, OFFSET FLAT:pe_enddirhook
	mov	QWORD PTR [rcx+296], rax

; 1869 :         break;
; 1870 : #endif
; 1871 :     }
; 1872 :     return;
; 1873 : }

	ret	0
$LN2@bin_init:

; 1861 : #if MZ_SUPPORT
; 1862 :     case SFORMAT_MZ:
; 1863 :         memcpy( &modinfo->mz_data, &mzdata, sizeof( struct MZDATA ) );

	mov	rax, QWORD PTR mzdata
	mov	QWORD PTR [rcx+412], rax
$LN3@bin_init:

; 1869 :         break;
; 1870 : #endif
; 1871 :     }
; 1872 :     return;
; 1873 : }

	ret	0
bin_init ENDP
_TEXT	ENDS
END
