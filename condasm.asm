; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	CurrIfState:DWORD
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
$SG5885	DB	'if-else', 00H
_DATA	ENDS
PUBLIC	conditional_assembly_prepare
EXTRN	EmitError:NEAR
EXTRN	EmitErr:NEAR
EXTRN	GetResWName:NEAR
_BSS	SEGMENT
elseoccured DD	01H DUP (?)
falseblocknestlevel DD 01H DUP (?)
blocknestlevel DD 01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$conditional_assembly_prepare DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$conditional_assembly_prepare DD @imagerel($LN22#)
	DD	@imagerel($LN22#+320)
	DD	@imagerel($unwind$conditional_assembly_prepare#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\condasm.c
pdata	ENDS
_TEXT	SEGMENT
directive$ = 48
conditional_assembly_prepare PROC NEAR

; 92   : {

$LN22:
	sub	rsp, 40					; 00000028H

; 93   :     DebugMsg1(("condasm_prepare(%s), old status: %s, lvl=%u, falselvl=%u\n",
; 94   :                GetResWName( directive, NULL), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 95   :     switch( directive ) {

	cmp	ecx, 364				; 0000016cH
	mov	r8d, ecx
	jl	$LN14@conditiona
	cmp	ecx, 375				; 00000177H
	jle	$LN13@conditiona
	cmp	ecx, 388				; 00000184H
	jle	SHORT $LN10@conditiona
	cmp	ecx, 389				; 00000185H
	jne	$LN14@conditiona

; 153  :     case T_ENDIF:
; 154  :         if ( blocknestlevel ) {

	mov	ecx, DWORD PTR blocknestlevel
	test	ecx, ecx
	je	SHORT $LN3@conditiona

; 155  :             if ( falseblocknestlevel > 0 ) {

	mov	eax, DWORD PTR falseblocknestlevel
	test	eax, eax
	jle	SHORT $LN2@conditiona

; 156  :                 falseblocknestlevel--;

	dec	eax
	mov	DWORD PTR falseblocknestlevel, eax

; 163  :         }
; 164  :         break;
; 165  :     }
; 166  :     DebugMsg1(("condasm_prepare(%s), new status: %s, lvl=%u, falselvl=%u\n",
; 167  :                GetResWName( directive, NULL ), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 168  :     return;
; 169  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@conditiona:

; 157  :                 break;
; 158  :             }
; 159  :             blocknestlevel--;

	dec	ecx

; 160  :             CurrIfState = BLOCK_ACTIVE; /* v2.04: added */

	xor	r9d, r9d
	mov	DWORD PTR CurrIfState, r9d
	mov	DWORD PTR blocknestlevel, ecx

; 163  :         }
; 164  :         break;
; 165  :     }
; 166  :     DebugMsg1(("condasm_prepare(%s), new status: %s, lvl=%u, falselvl=%u\n",
; 167  :                GetResWName( directive, NULL ), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 168  :     return;
; 169  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@conditiona:

; 161  :         } else {
; 162  :             EmitErr( BLOCK_NESTING_ERROR, GetResWName( directive, NULL ) );

	mov	ecx, 389				; 00000185H
$LN21@conditiona:
	xor	edx, edx
	call	GetResWName
	mov	ecx, 80					; 00000050H
	mov	rdx, rax

; 163  :         }
; 164  :         break;
; 165  :     }
; 166  :     DebugMsg1(("condasm_prepare(%s), new status: %s, lvl=%u, falselvl=%u\n",
; 167  :                GetResWName( directive, NULL ), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 168  :     return;
; 169  : }

	add	rsp, 40					; 00000028H
	jmp	EmitErr
$LN10@conditiona:

; 118  :         break;
; 119  :     case T_ELSE:
; 120  :     case T_ELSEIF:
; 121  :     case T_ELSEIF1:
; 122  :     case T_ELSEIF2:
; 123  :     case T_ELSEIFB:
; 124  :     case T_ELSEIFDEF:
; 125  :     case T_ELSEIFDIF:
; 126  :     case T_ELSEIFDIFI:
; 127  :     case T_ELSEIFE:
; 128  :     case T_ELSEIFIDN:
; 129  :     case T_ELSEIFIDNI:
; 130  :     case T_ELSEIFNB:
; 131  :     case T_ELSEIFNDEF:
; 132  :         if ( blocknestlevel ) { /* v2.04: do nothing if there was no IFx */

	mov	ecx, DWORD PTR blocknestlevel
	test	ecx, ecx
	je	SHORT $LN9@conditiona

; 133  :             if ( falseblocknestlevel > 0 ) {

	cmp	DWORD PTR falseblocknestlevel, 0
	jg	$LN14@conditiona

; 134  :                 break;
; 135  :             }
; 136  :             /* v2.06: check added to detect multiple ELSE branches */
; 137  :             if ( elseoccured & ( 1 << ( blocknestlevel - 1 ) ) ) {

	dec	ecx
	mov	edx, 1
	shl	edx, cl
	mov	ecx, DWORD PTR elseoccured
	test	edx, ecx
	je	SHORT $LN7@conditiona

; 138  :                 EmitError( ELSE_CLAUSE_ALREADY_OCCURED_IN_THIS_IF_BLOCK );

	mov	ecx, 274				; 00000112H

; 163  :         }
; 164  :         break;
; 165  :     }
; 166  :     DebugMsg1(("condasm_prepare(%s), new status: %s, lvl=%u, falselvl=%u\n",
; 167  :                GetResWName( directive, NULL ), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 168  :     return;
; 169  : }

	add	rsp, 40					; 00000028H
	jmp	EmitError
$LN7@conditiona:

; 139  :                 break;
; 140  :             }
; 141  :             /* status may change:
; 142  :              * inactive -> active
; 143  :              * active   -> done
; 144  :              */
; 145  :             CurrIfState = (( CurrIfState == BLOCK_INACTIVE ) ? BLOCK_ACTIVE : BLOCK_DONE );

	xor	r9d, r9d
	cmp	DWORD PTR CurrIfState, 1
	mov	eax, 2
	cmove	eax, r9d

; 146  :             /* v2.06: no further ELSEx once ELSE was detected */
; 147  :             if ( directive == T_ELSE )

	cmp	r8d, 376				; 00000178H
	mov	DWORD PTR CurrIfState, eax
	jne	SHORT $LN14@conditiona

; 148  :                 elseoccured |= ( 1 << ( blocknestlevel - 1 ) );

	or	ecx, edx
	mov	DWORD PTR elseoccured, ecx

; 163  :         }
; 164  :         break;
; 165  :     }
; 166  :     DebugMsg1(("condasm_prepare(%s), new status: %s, lvl=%u, falselvl=%u\n",
; 167  :                GetResWName( directive, NULL ), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 168  :     return;
; 169  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN9@conditiona:

; 149  :         } else {
; 150  :             EmitErr( BLOCK_NESTING_ERROR, GetResWName( directive, NULL ) );

	mov	ecx, r8d

; 151  :         }
; 152  :         break;

	jmp	$LN21@conditiona
$LN13@conditiona:

; 96   :     case T_IF:
; 97   :     case T_IF1:
; 98   :     case T_IF2:
; 99   :     case T_IFB:
; 100  :     case T_IFDEF:
; 101  :     case T_IFDIF:
; 102  :     case T_IFDIFI:
; 103  :     case T_IFE:
; 104  :     case T_IFIDN:
; 105  :     case T_IFIDNI:
; 106  :     case T_IFNB:
; 107  :     case T_IFNDEF:
; 108  :         if( CurrIfState != BLOCK_ACTIVE ) {

	cmp	DWORD PTR CurrIfState, 0
	je	SHORT $LN12@conditiona

; 109  :             falseblocknestlevel++;

	inc	DWORD PTR falseblocknestlevel

; 163  :         }
; 164  :         break;
; 165  :     }
; 166  :     DebugMsg1(("condasm_prepare(%s), new status: %s, lvl=%u, falselvl=%u\n",
; 167  :                GetResWName( directive, NULL ), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 168  :     return;
; 169  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN12@conditiona:

; 110  :             break;
; 111  :         }
; 112  :         if( blocknestlevel == MAX_IF_NESTING ) {

	mov	ecx, DWORD PTR blocknestlevel
	cmp	ecx, 20
	jne	SHORT $LN11@conditiona

; 113  :             EmitError( NESTING_LEVEL_TOO_DEEP );

	mov	ecx, 100				; 00000064H

; 163  :         }
; 164  :         break;
; 165  :     }
; 166  :     DebugMsg1(("condasm_prepare(%s), new status: %s, lvl=%u, falselvl=%u\n",
; 167  :                GetResWName( directive, NULL ), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 168  :     return;
; 169  : }

	add	rsp, 40					; 00000028H
	jmp	EmitError
$LN11@conditiona:

; 114  :             break;
; 115  :         }
; 116  :         elseoccured &= ~( 1 << blocknestlevel ); /* v2.06: added */

	mov	edx, 1
	shl	edx, cl
	not	edx
	and	DWORD PTR elseoccured, edx

; 117  :         blocknestlevel++;

	inc	ecx
	mov	DWORD PTR blocknestlevel, ecx
$LN14@conditiona:

; 163  :         }
; 164  :         break;
; 165  :     }
; 166  :     DebugMsg1(("condasm_prepare(%s), new status: %s, lvl=%u, falselvl=%u\n",
; 167  :                GetResWName( directive, NULL ), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 168  :     return;
; 169  : }

	add	rsp, 40					; 00000028H
	ret	0
conditional_assembly_prepare ENDP
_TEXT	ENDS
EXTRN	SymFind:NEAR
xdata	SEGMENT
$unwind$check_defd DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$check_defd DD @imagerel(check_defd#)
	DD	@imagerel(check_defd#+39)
	DD	@imagerel($unwind$check_defd#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
check_defd PROC NEAR

; 179  : {

	sub	rsp, 40					; 00000028H

; 180  :     struct asym      *sym;
; 181  :     if ( *name ) {

	cmp	BYTE PTR [rcx], 0
	je	SHORT $LN1@check_defd

; 182  :         sym = SymSearch( name );

	call	SymFind

; 183  :         if( sym ) {

	test	rax, rax
	je	SHORT $LN1@check_defd

; 184  :             DebugMsg1(("check_defd(%s): state=%u defined=%u\n", name, sym->state, sym->isdefined ));
; 185  :             /* v2.04: changed. the "defined" flag is active for ALL symbols */
; 186  :             //if ( sym->state == SYM_INTERNAL || sym->state == SYM_MACRO || sym->state == SYM_TMACRO || sym->state == SYM_UNDEFINED ) {
; 187  :             return( sym->isdefined );

	movzx	eax, BYTE PTR [rax+48]
	shr	al, 1
	and	al, 1

; 192  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN1@check_defd:

; 188  :         }
; 189  :         DebugMsg1(("check_defd(%s): sym=NULL\n", name ));
; 190  :     }
; 191  :     return( FALSE );

	xor	al, al

; 192  : }

	add	rsp, 40					; 00000028H
	ret	0
check_defd ENDP
_TEXT	ENDS
EXTRN	isspace:NEAR
xdata	SEGMENT
$unwind$check_blank DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$check_blank DD @imagerel(check_blank#)
	DD	@imagerel(check_blank#+54)
	DD	@imagerel($unwind$check_blank#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
string$ = 48
check_blank PROC NEAR

; 198  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 199  :     for ( ;*string; string++ )

	movzx	eax, BYTE PTR [rcx]
	mov	rbx, rcx
	test	al, al
	je	SHORT $LN2@check_blan
$LL4@check_blan:

; 200  :         if ( isspace(*string) == FALSE )

	movsx	ecx, al
	call	isspace
	test	eax, eax
	je	SHORT $LN8@check_blan
	mov	al, BYTE PTR [rbx+1]
	inc	rbx
	test	al, al
	jne	SHORT $LL4@check_blan
$LN2@check_blan:

; 202  :     return( TRUE );

	mov	al, 1

; 203  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN8@check_blan:

; 201  :             return FALSE;

	xor	al, al

; 203  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
check_blank ENDP
_TEXT	ENDS
EXTRN	_stricmp:NEAR
xdata	SEGMENT
$unwind$check_dif DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$check_dif DD @imagerel(check_dif#)
	DD	@imagerel(check_dif#+62)
	DD	@imagerel($unwind$check_dif#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
string1$ = 48
string2$ = 56
sensitive$ = 64
check_dif PROC NEAR

; 211  : {

	sub	rsp, 40					; 00000028H

; 212  :     if( sensitive ) {

	test	r8b, r8b
	je	SHORT $LN2@check_dif

; 213  :         return( strcmp( string1, string2 ) != 0 );

	sub	rdx, rcx
	npad	4
$LL5@check_dif:
	movzx	r8d, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rcx+rdx]
	sub	r8d, eax
	jne	SHORT $LN6@check_dif
	inc	rcx
	test	eax, eax
	jne	SHORT $LL5@check_dif
$LN6@check_dif:
	test	r8d, r8d

; 214  :     } else {
; 215  :         return( _stricmp( string1, string2 ) != 0 );

	setne	al

; 216  :     }
; 217  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@check_dif:

; 214  :     } else {
; 215  :         return( _stricmp( string1, string2 ) != 0 );

	call	_stricmp
	test	eax, eax
	setne	al

; 216  :     }
; 217  : }

	add	rsp, 40					; 00000028H
	ret	0
check_dif ENDP
_TEXT	ENDS
PUBLIC	CondAsmDirective
EXTRN	SearchNameInStruct:NEAR
EXTRN	Options:BYTE
EXTRN	EmitWarn:NEAR
EXTRN	EvalOperand:NEAR
EXTRN	SpecialTable:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	MacroLevel:BYTE
EXTRN	LstWriteSrcLine:NEAR
EXTRN	ModuleInfo:BYTE
xdata	SEGMENT
$unwind$CondAsmDirective DD 061601H
	DD	0166416H
	DD	01b5412H
	DD	017010eH
xdata	ENDS
pdata	SEGMENT
$pdata$CondAsmDirective DD @imagerel($LN102#)
	DD	@imagerel($LN102#+153)
	DD	@imagerel($unwind$CondAsmDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$3$CondAsmDirective DD 041021H
	DD	0157410H
	DD	01a3408H
	DD	@imagerel($LN102#)
	DD	@imagerel($LN102#+153)
	DD	@imagerel($unwind$CondAsmDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$CondAsmDirective DD @imagerel($LN102#+153)
	DD	@imagerel($LN102#+1580)
	DD	@imagerel($chain$3$CondAsmDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$4$CondAsmDirective DD 021H
	DD	@imagerel($LN102#)
	DD	@imagerel($LN102#+153)
	DD	@imagerel($unwind$CondAsmDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$CondAsmDirective DD @imagerel($LN102#+1580)
	DD	@imagerel($LN102#+1604)
	DD	@imagerel($chain$4$CondAsmDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$5$CondAsmDirective DD 040021H
	DD	0157400H
	DD	01a3400H
	DD	@imagerel($LN102#)
	DD	@imagerel($LN102#+153)
	DD	@imagerel($unwind$CondAsmDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$CondAsmDirective DD @imagerel($LN102#+1604)
	DD	@imagerel($LN102#+1692)
	DD	@imagerel($chain$5$CondAsmDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
opndx$ = 48
NextIfState$ = 192
i$ = 192
value$5758 = 200
tokenarray$ = 200
CondAsmDirective PROC NEAR

; 221  : {

$LN102:
	mov	DWORD PTR [rsp+8], ecx
	mov	rax, rsp
	sub	rsp, 184				; 000000b8H
	mov	QWORD PTR [rax+32], rbp
	mov	QWORD PTR [rax-8], rsi
	movsxd	r8, ecx

; 222  :     int directive = tokenarray[i].tokval;

	mov	rax, r8
	mov	rsi, rdx
	shl	rax, 5

; 223  :     const char *string1;
; 224  :     const char *string2;
; 225  :     enum if_state NextIfState;
; 226  :     struct expr opndx;
; 227  : 
; 228  :     if ( CurrIfState != BLOCK_ACTIVE ) {

	cmp	DWORD PTR CurrIfState, 0
	movsxd	rbp, DWORD PTR [rax+rdx+16]
	je	SHORT $LN68@CondAsmDir

; 229  :         DebugMsg1(("CondAsmDirective(%s), CurrIfState=%u(%s), lvl=%u, falselvl=%u\n",
; 230  :                    GetResWName(directive, NULL), CurrIfState, GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 231  :         if ( i || ModuleInfo.listif ) {

	test	ecx, ecx
	jne	SHORT $LN66@CondAsmDir
	bt	DWORD PTR ModuleInfo+408, 14
	jae	SHORT $LN67@CondAsmDir
$LN66@CondAsmDir:

; 232  :             LstWriteSrcLine();

	call	LstWriteSrcLine
$LN67@CondAsmDir:

; 233  :         }
; 234  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN69@CondAsmDir
$LN68@CondAsmDir:

; 235  :     }
; 236  : 
; 237  :     if ( ModuleInfo.list == TRUE ) {

	mov	edx, DWORD PTR ModuleInfo+408
	bt	edx, 12
	jae	SHORT $LN64@CondAsmDir

; 238  :         if ( MacroLevel == 0 ||
; 239  :             ModuleInfo.list_macro == LM_LISTMACROALL ||
; 240  :             ModuleInfo.listif )

	cmp	BYTE PTR MacroLevel, 0
	je	SHORT $LN63@CondAsmDir
	cmp	DWORD PTR ModuleInfo+400, 2
	je	SHORT $LN63@CondAsmDir
	bt	edx, 14
	jae	SHORT $LN64@CondAsmDir
$LN63@CondAsmDir:

; 241  :             LstWriteSrcLine();

	call	LstWriteSrcLine
	mov	r8d, DWORD PTR i$[rsp]
	mov	edx, DWORD PTR ModuleInfo+408
$LN64@CondAsmDir:

; 242  :     }
; 243  : 
; 244  :     DebugMsg1(("CondAsmDirective(%s), BLOCK_ACTIVE, lvl=%u, falselvl=%u [%s]\n", GetResWName(directive, NULL), blocknestlevel, falseblocknestlevel, tokenarray[i].tokpos ));
; 245  : 
; 246  :     i++; /* go past IFx, ELSEx, ENDIF */

	inc	r8d

; 247  : 
; 248  :     /* check params and call appropriate test routine */
; 249  : 
; 250  :     switch( GetSflagsSp(directive) ) {

	lea	rcx, QWORD PTR [rbp+rbp*2]
	lea	r9, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR SpecialTable[r9+rcx*4+4]
	mov	QWORD PTR [rsp+208], rbx
	mov	QWORD PTR [rsp+168], rdi
	dec	eax
	mov	DWORD PTR i$[rsp], r8d
	cmp	eax, 5
	ja	$LN2@CondAsmDir
	mov	ecx, DWORD PTR $LN97@CondAsmDir[r9+rax*4]
	add	rcx, r9
	jmp	rcx
$LN60@CondAsmDir:

; 251  :     case CC_NUMARG: /* [ELSE]IF[E] */
; 252  :         /* no forward reference allowed, symbol must be defined */
; 253  :         if ( ( ERROR == EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) ) ) {

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rsi
	mov	BYTE PTR [rsp+32], 2
	call	EvalOperand
	xor	edi, edi
	cmp	eax, -1
	jne	SHORT $LN59@CondAsmDir

; 254  :             DebugMsg(("CondAsmDirective(%s), EvalOperand returned with ERROR\n", GetResWName(directive, NULL) ));
; 255  :             /* v2.11: don't exit, assume 0 */
; 256  :             //return( ERROR );
; 257  :             opndx.kind = EXPR_CONST;
; 258  :             opndx.value = 0;
; 259  :             i = Token_Count;

	mov	r8d, DWORD PTR ModuleInfo+496
	mov	DWORD PTR opndx$[rsp+60], edi
	mov	eax, edi
	mov	DWORD PTR i$[rsp], r8d
	mov	DWORD PTR opndx$[rsp], edi

; 260  :         }
; 261  : #if 0 /* v2.05: obsolete */
; 262  :         if ( opndx.sym && opndx.sym->state == SYM_UNDEFINED ) {
; 263  :             EmitErr( SYMBOL_NOT_DEFINED, opndx.sym->name );
; 264  :         } else
; 265  : #endif
; 266  :         if ( opndx.kind == EXPR_CONST )

	jmp	SHORT $LN55@CondAsmDir
$LN59@CondAsmDir:
	mov	eax, DWORD PTR opndx$[rsp+60]
	test	eax, eax
	je	SHORT $LN98@CondAsmDir

; 267  :             ;
; 268  :         else if ( opndx.kind == EXPR_ADDR && opndx.indirect == FALSE ) {

	cmp	eax, 1
	jne	SHORT $LN56@CondAsmDir
	test	BYTE PTR opndx$[rsp+72], al
	jne	SHORT $LN56@CondAsmDir

; 269  :             opndx.value += opndx.sym->offset;

	mov	rax, QWORD PTR opndx$[rsp+80]

; 270  :             /* v2.07: Masm doesn't accept a relocatable item,
; 271  :              * so emit at least a warning!
; 272  :              */
; 273  :             EmitWarn( 2, CONSTANT_EXPECTED );

	mov	edx, 65					; 00000041H
	mov	ecx, DWORD PTR [rax+16]
	add	DWORD PTR opndx$[rsp], ecx
	lea	ecx, QWORD PTR [rdx-63]
	call	EmitWarn
	mov	r8d, DWORD PTR i$[rsp]
	mov	eax, DWORD PTR opndx$[rsp]
	jmp	SHORT $LN55@CondAsmDir
$LN98@CondAsmDir:
	mov	r8d, DWORD PTR i$[rsp]
	mov	eax, DWORD PTR opndx$[rsp]
$LN55@CondAsmDir:

; 276  :         }
; 277  :         if ( directive == T_IF || directive == T_ELSEIF )

	cmp	ebp, 364				; 0000016cH
	je	SHORT $LN53@CondAsmDir
	cmp	ebp, 377				; 00000179H
	je	SHORT $LN53@CondAsmDir

; 279  :         else
; 280  :             NextIfState = ( !opndx.value ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	test	eax, eax
	setne	dil
	mov	ebx, edi
	jmp	$LN61@CondAsmDir
$LN53@CondAsmDir:

; 278  :             NextIfState = ( opndx.value ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	test	eax, eax
	mov	ebx, edi
	sete	bl

; 281  :         break;

	jmp	$LN61@CondAsmDir
$LN56@CondAsmDir:

; 274  :         } else {
; 275  :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	$LN101@CondAsmDir
$LN51@CondAsmDir:

; 282  :     case CC_LITARG: /*  [ELSE]IFDIF[I], [ELSE]IFIDN[I] */
; 283  :         string1 = tokenarray[i].string_ptr;

	movsxd	rax, r8d
	shl	rax, 5

; 284  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movzx	ecx, BYTE PTR [rax+rsi]
	mov	rbx, QWORD PTR [rax+rsi+8]
	cmp	cl, 9
	jne	$LN49@CondAsmDir
	cmp	BYTE PTR [rax+rsi+1], 60		; 0000003cH
	jne	$LN49@CondAsmDir

; 287  :             else
; 288  :                 EmitError( TEXT_ITEM_REQUIRED );
; 289  :             return( ERROR );
; 290  :         }
; 291  :         i++;

	inc	r8d

; 292  :         if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rdx, r8d
	mov	DWORD PTR i$[rsp], r8d
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rsi], 44			; 0000002cH
	je	SHORT $LN46@CondAsmDir

; 293  :             return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rsi+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	$LN101@CondAsmDir
$LN46@CondAsmDir:

; 294  :         }
; 295  :         i++;

	inc	r8d
	mov	DWORD PTR i$[rsp], r8d

; 296  :         string2 = tokenarray[i].string_ptr;

	movsxd	rax, r8d
	shl	rax, 5

; 297  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movzx	ecx, BYTE PTR [rax+rsi]
	mov	rdi, QWORD PTR [rax+rsi+8]
	cmp	cl, 9
	jne	$LN44@CondAsmDir
	cmp	BYTE PTR [rax+rsi+1], 60		; 0000003cH
	jne	$LN44@CondAsmDir

; 303  :         }
; 304  :         i++;

	inc	r8d

; 305  :         DebugMsg1(("CondAsmDirective(%s), cmp >%s< and >%s<\n", GetResWName(directive, NULL), string1, string2 ));
; 306  :         switch ( directive ) {

	lea	eax, DWORD PTR [rbp-368]
	cmp	eax, 15
	mov	DWORD PTR i$[rsp], r8d
	ja	SHORT $LN36@CondAsmDir
	cdqe
	mov	ecx, DWORD PTR $LN96@CondAsmDir[r9+rax*4]
	add	rcx, r9
	jmp	rcx
$LN39@CondAsmDir:

; 307  :         case T_IFDIF:
; 308  :         case T_ELSEIFDIF:
; 309  :             NextIfState = check_dif( string1, string2, TRUE ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	sub	rdi, rbx
$LL94@CondAsmDir:
	movzx	ecx, BYTE PTR [rbx]
	movzx	eax, BYTE PTR [rbx+rdi]
	sub	ecx, eax
	jne	SHORT $LN95@CondAsmDir
	inc	rbx
	test	eax, eax
	jne	SHORT $LL94@CondAsmDir
$LN95@CondAsmDir:
	xor	edi, edi
	test	ecx, ecx
	mov	ebx, edi
	sete	bl

; 310  :             break;

	jmp	$LN61@CondAsmDir
$LN38@CondAsmDir:

; 311  :         case T_IFDIFI:
; 312  :         case T_ELSEIFDIFI:
; 313  :             NextIfState = check_dif( string1, string2, FALSE ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	mov	rdx, rdi
	mov	rcx, rbx
	call	_stricmp

; 314  :             break;

	mov	r8d, DWORD PTR i$[rsp]
	xor	edi, edi
	test	eax, eax
	mov	ebx, edi
	sete	bl
	jmp	$LN61@CondAsmDir
$LN37@CondAsmDir:

; 315  :         case T_IFIDN:
; 316  :         case T_ELSEIFIDN:
; 317  :             NextIfState = !check_dif( string1, string2, TRUE ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	sub	rdi, rbx
	npad	8
$LL92@CondAsmDir:
	movzx	ecx, BYTE PTR [rbx]
	movzx	eax, BYTE PTR [rbx+rdi]
	sub	ecx, eax
	jne	SHORT $LN93@CondAsmDir
	inc	rbx
	test	eax, eax
	jne	SHORT $LL92@CondAsmDir
$LN93@CondAsmDir:
	xor	edi, edi
	test	ecx, ecx
	mov	ebx, edi
	setne	bl

; 318  :             break;

	jmp	$LN61@CondAsmDir
$LN36@CondAsmDir:

; 319  :         default:
; 320  :             NextIfState = !check_dif( string1, string2, FALSE ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	mov	rdx, rdi
	mov	rcx, rbx
	call	_stricmp

; 321  :         }
; 322  :         break;

	mov	r8d, DWORD PTR i$[rsp]
	xor	edi, edi
	test	eax, eax
	mov	ebx, edi
	setne	bl
	jmp	$LN61@CondAsmDir
$LN44@CondAsmDir:

; 298  :             if ( tokenarray[i].token == T_ID && SymSearch( string2 ) == NULL )

	cmp	cl, 8
	jne	SHORT $LN43@CondAsmDir
	mov	rcx, rdi
	call	SymFind
	test	rax, rax
	jne	SHORT $LN43@CondAsmDir

; 299  :                 EmitErr( SYMBOL_NOT_DEFINED, string2 );

	lea	ecx, QWORD PTR [rax+102]
	mov	rdx, rdi
	call	EmitErr

; 302  :             return( ERROR );

	mov	eax, -1
	jmp	$LN101@CondAsmDir
$LN43@CondAsmDir:

; 300  :             else
; 301  :                 EmitError( TEXT_ITEM_REQUIRED );

	mov	ecx, 144				; 00000090H
	call	EmitError

; 302  :             return( ERROR );

	mov	eax, -1
	jmp	$LN101@CondAsmDir
$LN49@CondAsmDir:

; 285  :             if ( tokenarray[i].token == T_ID && SymSearch( string1 ) == NULL )

	cmp	cl, 8
	jne	SHORT $LN43@CondAsmDir
	mov	rcx, rbx
	call	SymFind
	test	rax, rax
	jne	SHORT $LN43@CondAsmDir

; 286  :                 EmitErr( SYMBOL_NOT_DEFINED, string1 );

	lea	ecx, QWORD PTR [rax+102]
	mov	rdx, rbx
	call	EmitErr

; 302  :             return( ERROR );

	mov	eax, -1
	jmp	$LN101@CondAsmDir
$LN35@CondAsmDir:

; 323  :     case CC_BLKARG: /* [ELSE]IF[N]B */
; 324  :         string1 = tokenarray[i].string_ptr;

	movsxd	rax, r8d
	shl	rax, 5

; 325  : 
; 326  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movzx	ecx, BYTE PTR [rax+rsi]
	mov	rbx, QWORD PTR [rax+rsi+8]
	cmp	cl, 9
	jne	SHORT $LN33@CondAsmDir
	cmp	BYTE PTR [rax+rsi+1], 60		; 0000003cH
	jne	SHORT $LN33@CondAsmDir

; 329  :             else
; 330  :                 EmitError( TEXT_ITEM_REQUIRED );
; 331  :             return( ERROR );
; 332  :         }
; 333  :         i++;

	inc	r8d

; 334  :         if ( directive == T_IFB || directive == T_ELSEIFB ) {

	cmp	ebp, 372				; 00000174H
	mov	DWORD PTR i$[rsp], r8d
	je	SHORT $LN29@CondAsmDir
	cmp	ebp, 385				; 00000181H
	je	SHORT $LN29@CondAsmDir

; 336  :         } else {
; 337  :             NextIfState = !check_blank( string1 ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	mov	rcx, rbx
	call	check_blank
	mov	r8d, DWORD PTR i$[rsp]
	xor	edi, edi
	test	al, al
	mov	ebx, edi
	setne	bl
	jmp	$LN61@CondAsmDir
$LN29@CondAsmDir:

; 335  :             NextIfState = check_blank( string1 ) ? BLOCK_ACTIVE : BLOCK_INACTIVE;

	mov	rcx, rbx
	call	check_blank

; 338  :         }
; 339  :         break;

	mov	r8d, DWORD PTR i$[rsp]
	xor	edi, edi
	test	al, al
	mov	ebx, edi
	sete	bl
	jmp	$LN61@CondAsmDir
$LN33@CondAsmDir:

; 327  :             if ( tokenarray[i].token == T_ID && SymSearch( string1 ) == NULL )

	cmp	cl, 8
	jne	$LN43@CondAsmDir
	mov	rcx, rbx
	call	SymFind
	test	rax, rax
	jne	$LN43@CondAsmDir

; 328  :                 EmitErr( SYMBOL_NOT_DEFINED, string1 );

	lea	ecx, QWORD PTR [rax+102]
	mov	rdx, rbx
	call	EmitErr
	mov	eax, -1
	jmp	$LN101@CondAsmDir
$LN27@CondAsmDir:

; 340  :     case CC_PASS1: /* [ELSE]IF1 */
; 341  :         /* v2.04: changed */
; 342  :         //NextIfState = ((Parse_Pass == PASS_1) ? BLOCK_ACTIVE : BLOCK_INACTIVE);
; 343  :         NextIfState = BLOCK_ACTIVE;

	xor	edi, edi
	mov	ebx, edi

; 344  :         break;

	jmp	$LN61@CondAsmDir
$LN26@CondAsmDir:

; 345  :     case CC_PASS2: /* [ELSE]IF2 */
; 346  :         if ( ModuleInfo.setif2 == FALSE ) {

	bt	edx, 11
	jb	SHORT $LN25@CondAsmDir

; 347  :             EmitError( IF2_NOT_ALLOWED );

	mov	ecx, 190				; 000000beH
	call	EmitError

; 348  :             break;

	mov	r8d, DWORD PTR i$[rsp]
	mov	ebx, DWORD PTR NextIfState$[rsp]
	jmp	$LN61@CondAsmDir
$LN25@CondAsmDir:

; 349  :         }
; 350  :         /* v2.04: changed */
; 351  :         //NextIfState = ((Parse_Pass == PASS_1) ? BLOCK_INACTIVE : BLOCK_ACTIVE);
; 352  :         NextIfState = BLOCK_ACTIVE;

	xor	edi, edi
	mov	ebx, edi

; 353  :         break;

	jmp	$LN61@CondAsmDir
$LN24@CondAsmDir:

; 354  :     case CC_SYMARG: /* [ELSE]IF[N]DEF */
; 355  :         NextIfState = BLOCK_INACTIVE;
; 356  :         /* Masm's implementation works with IDs as arguments only. The rest
; 357  :          * will return FALSE. However, it's nice to be able to check whether
; 358  :          * a reserved word is defined or not.
; 359  :          */
; 360  :         /* v2.0: [ELSE]IF[N]DEF is valid *without* an argument! */
; 361  :         //if ( tokenarray[i].token == T_ID && tokenarray[i+1].token == T_FINAL) {
; 362  :         if ( tokenarray[i].token == T_FINAL ) {

	movsxd	rdx, r8d
	xor	edi, edi
	mov	ebx, 1
	mov	rcx, rdx
	shl	rcx, 5
	movzx	eax, BYTE PTR [rcx+rsi]
	test	al, al
	je	$LN9@CondAsmDir

; 363  :         } else if ( tokenarray[i].token == T_ID  ) {

	cmp	al, 8
	jne	$LN21@CondAsmDir

; 364  :             /* v2.07: handle structs + members (if -Zne is NOT set) */
; 365  :             struct asym *sym;
; 366  :             if ( Options.strict_masm_compat == FALSE &&
; 367  :                 tokenarray[i+1].token == T_DOT &&
; 368  :                 ( sym = SymSearch( tokenarray[i].string_ptr ) ) &&
; 369  :                 ( ( sym->state == SYM_TYPE ) || sym->type ) ) {

	cmp	BYTE PTR Options+136, dil
	jne	$LN20@CondAsmDir
	lea	rax, QWORD PTR [rdx+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 46			; 0000002eH
	jne	$LN20@CondAsmDir
	mov	rcx, QWORD PTR [rcx+rsi+8]
	call	SymFind
	test	rax, rax
	mov	r11, rax
	je	$LN99@CondAsmDir
	cmp	DWORD PTR [rax+40], 7
	je	SHORT $LN19@CondAsmDir
	cmp	QWORD PTR [rax+88], rdi
	je	SHORT $LN99@CondAsmDir
$LN19@CondAsmDir:

; 370  :                 uint_32 value;
; 371  :                 value = 0;

	mov	r8d, DWORD PTR i$[rsp]
	mov	DWORD PTR value$5758[rsp], edi
$LL18@CondAsmDir:

; 372  :                 do {
; 373  :                     i += 2;

	add	r8d, 2
	mov	DWORD PTR i$[rsp], r8d

; 374  :                     /* if it's a structured variable, use its type! */
; 375  :                     if ( sym->state != SYM_TYPE )

	cmp	DWORD PTR [r11+40], 7
	je	SHORT $LN15@CondAsmDir

; 376  :                         sym = sym->type;

	mov	r11, QWORD PTR [r11+88]
$LN15@CondAsmDir:

; 377  :                     sym = SearchNameInStruct( sym, tokenarray[i].string_ptr, &value, 0 );

	movsxd	rdx, r8d
	lea	r8, QWORD PTR value$5758[rsp]
	xor	r9d, r9d
	shl	rdx, 5
	mov	rcx, r11
	mov	rdx, QWORD PTR [rdx+rsi+8]
	call	SearchNameInStruct

; 378  :                 } while ( sym && tokenarray[i+1].token == T_DOT );

	movsxd	r8, DWORD PTR i$[rsp]
	test	rax, rax
	mov	r11, rax
	je	SHORT $LN14@CondAsmDir
	lea	rax, QWORD PTR [r8+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 46			; 0000002eH
	je	SHORT $LL18@CondAsmDir
$LN14@CondAsmDir:

; 379  :                 NextIfState = ( sym ? BLOCK_ACTIVE : BLOCK_INACTIVE );

	test	r11, r11
	mov	ebx, edi
	sete	bl

; 382  :             }
; 383  :             i++;

	inc	r8d
	mov	DWORD PTR i$[rsp], r8d
	jmp	$LN9@CondAsmDir
$LN99@CondAsmDir:

; 380  :             } else {

	mov	r8d, DWORD PTR i$[rsp]
$LN20@CondAsmDir:

; 381  :                 NextIfState = ( check_defd( tokenarray[i].string_ptr )  ? BLOCK_ACTIVE : BLOCK_INACTIVE );

	movsxd	rcx, r8d
	shl	rcx, 5
	mov	rcx, QWORD PTR [rcx+rsi+8]
	call	check_defd
	mov	r8d, DWORD PTR i$[rsp]
	mov	ebx, edi
	test	al, al
	sete	bl

; 382  :             }
; 383  :             i++;

	inc	r8d
	mov	DWORD PTR i$[rsp], r8d
	jmp	SHORT $LN9@CondAsmDir
$LN21@CondAsmDir:

; 384  :         } else if ( tokenarray[i].token == T_RES_ID && tokenarray[i].tokval == T_FLAT ) {

	cmp	al, 7
	jne	SHORT $LN11@CondAsmDir
	cmp	DWORD PTR [rcx+rsi+16], 261		; 00000105H
	jne	SHORT $LN11@CondAsmDir

; 385  :             /* v2.09: special treatment of FLAT added */
; 386  :             NextIfState = (( ModuleInfo.flat_grp && ModuleInfo.flat_grp->sym.isdefined ) ? BLOCK_ACTIVE : BLOCK_INACTIVE );

	mov	rax, QWORD PTR ModuleInfo+440
	test	rax, rax
	je	SHORT $LN71@CondAsmDir
	test	BYTE PTR [rax+48], 2
	je	SHORT $LN71@CondAsmDir
	mov	ebx, edi
$LN71@CondAsmDir:

; 387  :             i++;

	inc	r8d
	mov	DWORD PTR i$[rsp], r8d

; 388  :         } else if ( Options.strict_masm_compat == FALSE && (

	jmp	SHORT $LN9@CondAsmDir
$LN11@CondAsmDir:

; 389  :                     tokenarray[i].token == T_RES_ID ||
; 390  :                     tokenarray[i].token == T_STYPE ||
; 391  :                     tokenarray[i].token == T_INSTRUCTION ||
; 392  :                     tokenarray[i].token == T_DIRECTIVE ||
; 393  :                     //tokenarray[i].token == T_UNARY_OP ||
; 394  :                     //tokenarray[i].token == T_BINARY_OP ||
; 395  :                     tokenarray[i].token == T_REG ) &&
; 396  :                    tokenarray[i+1].token == T_FINAL ) {

	cmp	BYTE PTR Options+136, dil
	jne	SHORT $LN9@CondAsmDir
	cmp	al, 7
	je	SHORT $LN8@CondAsmDir
	cmp	al, 6
	je	SHORT $LN8@CondAsmDir
	cmp	al, bl
	je	SHORT $LN8@CondAsmDir
	cmp	al, 3
	je	SHORT $LN8@CondAsmDir
	cmp	al, 2
	jne	SHORT $LN9@CondAsmDir
$LN8@CondAsmDir:
	lea	rax, QWORD PTR [rdx+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], dil
	jne	SHORT $LN9@CondAsmDir

; 397  :             NextIfState = BLOCK_ACTIVE;
; 398  :             i++;

	inc	r8d
	mov	ebx, edi
	mov	DWORD PTR i$[rsp], r8d
$LN9@CondAsmDir:

; 399  :         }
; 400  :         if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rcx, r8d
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], dil
	je	SHORT $LN5@CondAsmDir

; 401  :             EmitWarn( 2, IFDEF_EXPECTS_SYMBOL_ARGUMENT, tokenarray[i-1].tokpos );

	shl	rcx, 5
	mov	edx, 248				; 000000f8H
	mov	r8, QWORD PTR [rcx+rsi-8]
	mov	ecx, 2
	call	EmitWarn

; 402  :             while ( tokenarray[i].token != T_FINAL ) i++;

	movsxd	r8, DWORD PTR i$[rsp]
	mov	rax, r8
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], dil
	je	SHORT $LN5@CondAsmDir
	npad	11
$LL6@CondAsmDir:
	inc	r8d
	movsxd	rax, r8d
	mov	DWORD PTR i$[rsp], r8d
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], dil
	jne	SHORT $LL6@CondAsmDir
$LN5@CondAsmDir:

; 403  :         }
; 404  :         if ( directive == T_IFNDEF || directive == T_ELSEIFNDEF )

	cmp	ebp, 375				; 00000177H
	je	SHORT $LN3@CondAsmDir
	cmp	ebp, 388				; 00000184H
	jne	SHORT $LN61@CondAsmDir
$LN3@CondAsmDir:

; 405  :             NextIfState = ( ( NextIfState == BLOCK_ACTIVE ) ? BLOCK_INACTIVE : BLOCK_ACTIVE );

	test	ebx, ebx
	sete	dil
	mov	ebx, edi

; 406  :         break;

	jmp	SHORT $LN61@CondAsmDir
$LN2@CondAsmDir:

; 407  :     default: /* ELSE and ENDIF */
; 408  :         NextIfState = BLOCK_ACTIVE;

	xor	edi, edi
	mov	ebx, edi
$LN61@CondAsmDir:

; 409  :         break;
; 410  :     }
; 411  : 
; 412  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, r8d
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rsi], 0
	je	SHORT $LN1@CondAsmDir

; 413  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+rsi+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN101@CondAsmDir
$LN1@CondAsmDir:

; 414  :     }
; 415  : 
; 416  :     CurrIfState = NextIfState;

	mov	DWORD PTR CurrIfState, ebx

; 417  : 
; 418  :     DebugMsg1(("CondAsmDirective(%s) exit, state=%s, lvl=%u, falselvl=%u\n",
; 419  :                GetResWName(directive, NULL), GetCurrIfStatString(), blocknestlevel, falseblocknestlevel));
; 420  :     return( NOT_ERROR );

	xor	eax, eax
$LN101@CondAsmDir:
	mov	rbx, QWORD PTR [rsp+208]
	mov	rdi, QWORD PTR [rsp+168]
$LN69@CondAsmDir:
	mov	rsi, QWORD PTR [rsp+176]
	mov	rbp, QWORD PTR [rsp+216]

; 421  : }

	add	rsp, 184				; 000000b8H
	ret	0
$LN97@CondAsmDir:
	DD	$LN60@CondAsmDir
	DD	$LN51@CondAsmDir
	DD	$LN35@CondAsmDir
	DD	$LN24@CondAsmDir
	DD	$LN27@CondAsmDir
	DD	$LN26@CondAsmDir
$LN96@CondAsmDir:
	DD	$LN39@CondAsmDir
	DD	$LN38@CondAsmDir
	DD	$LN37@CondAsmDir
	DD	$LN36@CondAsmDir
	DD	$LN36@CondAsmDir
	DD	$LN36@CondAsmDir
	DD	$LN36@CondAsmDir
	DD	$LN36@CondAsmDir
	DD	$LN36@CondAsmDir
	DD	$LN36@CondAsmDir
	DD	$LN36@CondAsmDir
	DD	$LN36@CondAsmDir
	DD	$LN36@CondAsmDir
	DD	$LN39@CondAsmDir
	DD	$LN38@CondAsmDir
	DD	$LN37@CondAsmDir
CondAsmDirective ENDP
_TEXT	ENDS
EXTRN	TextItemError:NEAR
xdata	SEGMENT
$unwind$GetErrText DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$GetErrText DD @imagerel(GetErrText#)
	DD	@imagerel(GetErrText#+125)
	DD	@imagerel($unwind$GetErrText#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
GetErrText PROC NEAR

; 425  : {

	sub	rsp, 40					; 00000028H

; 426  :     *StringBufferEnd = NULLC;
; 427  :     if ( i ) {

	test	ecx, ecx
	mov	rax, QWORD PTR ModuleInfo+488
	mov	BYTE PTR [rax], 0
	je	SHORT $LN9@GetErrText

; 428  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rcx, ecx
	shl	rcx, 5
	add	rcx, rdx
	cmp	BYTE PTR [rcx], 9
	jne	SHORT $LN2@GetErrText
	cmp	BYTE PTR [rcx+1], 60			; 0000003cH
	jne	SHORT $LN2@GetErrText

; 430  :         } else {
; 431  :             *(StringBufferEnd+0) = ':';

	mov	rax, QWORD PTR ModuleInfo+488
	mov	BYTE PTR [rax], 58			; 0000003aH

; 432  :             *(StringBufferEnd+1) = ' ';

	mov	rax, QWORD PTR ModuleInfo+488
	mov	BYTE PTR [rax+1], 32			; 00000020H

; 433  :             //GetLiteralValue( buffer+2, text->string_ptr );
; 434  :             strcpy( StringBufferEnd+2, tokenarray[i].string_ptr );

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, QWORD PTR [rcx+8]
	add	rdx, 2
	npad	5
$LL7@GetErrText:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL7@GetErrText

; 435  :         }
; 436  :     }
; 437  :     return( StringBufferEnd );

	mov	rax, QWORD PTR ModuleInfo+488

; 438  : 
; 439  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@GetErrText:

; 429  :             TextItemError( &tokenarray[i] );

	call	TextItemError
$LN9@GetErrText:

; 435  :         }
; 436  :     }
; 437  :     return( StringBufferEnd );

	mov	rax, QWORD PTR ModuleInfo+488

; 438  : 
; 439  : }

	add	rsp, 40					; 00000028H
	ret	0
GetErrText ENDP
_TEXT	ENDS
PUBLIC	ErrorDirective
EXTRN	Parse_Pass:DWORD
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$ErrorDirective DD 0104601H
	DD	014e446H
	DD	015d42dH
	DD	016c422H
	DD	017741eH
	DD	018641aH
	DD	01d5416H
	DD	01c3412H
	DD	019010eH
xdata	ENDS
pdata	SEGMENT
$pdata$ErrorDirective DD @imagerel($LN112#)
	DD	@imagerel($LN112#+1792)
	DD	@imagerel($unwind$ErrorDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
opndx$ = 48
i$ = 208
value$5827 = 216
tokenarray$ = 216
ErrorDirective PROC NEAR

; 453  : {

$LN112:
	mov	DWORD PTR [rsp+8], ecx
	mov	r11, rsp
	sub	rsp, 200				; 000000c8H
	mov	QWORD PTR [r11+24], rbx
	mov	QWORD PTR [r11+32], rbp
	mov	QWORD PTR [r11-8], rsi
	mov	QWORD PTR [r11-16], rdi
	mov	QWORD PTR [r11-24], r12

; 454  :     struct expr opndx;
; 455  :     unsigned direct;
; 456  :     const char *string1;
; 457  :     const char *string2;
; 458  :     int errmsg = EMPTY;
; 459  :     int erridx = 0;
; 460  :     struct asym *sym;
; 461  :     int idloc;
; 462  : 
; 463  :     direct = tokenarray[i].tokval;

	movsxd	rax, ecx
	shl	rax, 5
	mov	QWORD PTR [r11-32], r13

; 464  : 
; 465  :     i++; /* go past directive */

	inc	ecx
	mov	r12d, DWORD PTR [rax+rdx+16]

; 466  : 
; 467  :     /* get an expression if necessary */
; 468  :     switch( GetSflagsSp( direct) ) {

	lea	rax, OFFSET FLAT:SpecialTable+4
	xor	r13d, r13d
	lea	r8, QWORD PTR [r12+r12*2]
	mov	QWORD PTR [r11-40], r14
	mov	rsi, rdx
	mov	eax, DWORD PTR [rax+r8*4]
	mov	DWORD PTR [r11+8], ecx
	dec	eax
	je	$LN68@ErrorDirec
	dec	eax
	je	$LN25@ErrorDirec
	dec	eax
	je	$LN34@ErrorDirec
	dec	eax
	je	$LN56@ErrorDirec
	cmp	eax, 2
	jne	SHORT $LN5@ErrorDirec

; 621  :     case CC_PASS2: /* .ERR2 */
; 622  :         if ( ModuleInfo.setif2 == FALSE ) {

	bt	DWORD PTR ModuleInfo+408, 11
	jb	SHORT $LN5@ErrorDirec

; 623  :             return( EmitError( IF2_NOT_ALLOWED ) );

	mov	ecx, 190				; 000000beH
	jmp	$LN111@ErrorDirec
$LN5@ErrorDirec:

; 624  :         }
; 625  :     case CC_PASS1: /* .ERR1 */
; 626  :     default: /* .ERR */
; 627  :         if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rax, ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], r13b
	je	SHORT $LN3@ErrorDirec

; 628  :             erridx = i++;

	mov	r13d, ecx
	inc	ecx
	mov	DWORD PTR i$[rsp], ecx
$LN3@ErrorDirec:

; 629  :         }
; 630  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	je	$LN57@ErrorDirec

; 631  :             break;
; 632  :         EmitErr( FORCED_ERR, GetErrText( erridx, tokenarray ) );

	test	r13d, r13d
	mov	rax, QWORD PTR ModuleInfo+488
	mov	BYTE PTR [rax], 0
	je	SHORT $LN90@ErrorDirec
	movsxd	rcx, r13d
	shl	rcx, 5
	add	rcx, rdx
	cmp	BYTE PTR [rcx], 9
	jne	SHORT $LN91@ErrorDirec
	cmp	BYTE PTR [rcx+1], 60			; 0000003cH
	jne	SHORT $LN91@ErrorDirec
	mov	rax, QWORD PTR ModuleInfo+488
	mov	BYTE PTR [rax], 58			; 0000003aH
	mov	rax, QWORD PTR ModuleInfo+488
	mov	BYTE PTR [rax+1], 32			; 00000020H
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, QWORD PTR [rcx+8]
	add	rdx, 2
	npad	8
$LL96@ErrorDirec:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL96@ErrorDirec
	jmp	SHORT $LN90@ErrorDirec
$LN91@ErrorDirec:
	call	TextItemError
$LN90@ErrorDirec:
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	ecx, 114				; 00000072H
	call	EmitErr

; 633  :         break;

	mov	ecx, DWORD PTR i$[rsp]
	jmp	$LN57@ErrorDirec
$LN56@ErrorDirec:

; 494  :         break;
; 495  :     case CC_SYMARG: /* .ERR[N]DEF */
; 496  :         /* there's a special handling of these directives in ExpandLine()! */
; 497  :         if ( tokenarray[i].token != T_ID ) {

	movsxd	rdx, ecx
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rsi], 8

; 498  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	jne	$LN110@ErrorDirec

; 499  :         }
; 500  :         idloc = i;

	movsxd	rbp, ecx
	npad	8
$LL54@ErrorDirec:

; 501  :         /* skip the next param */
; 502  :         do {
; 503  :             i++;

	inc	ecx

; 504  :         } while ( tokenarray[i].token == T_DOT || tokenarray[i].token == T_ID );

	movsxd	rax, ecx
	mov	DWORD PTR i$[rsp], ecx
	shl	rax, 5
	movzx	edx, BYTE PTR [rax+rsi]
	cmp	dl, 46					; 0000002eH
	je	SHORT $LL54@ErrorDirec
	cmp	dl, 8
	je	SHORT $LL54@ErrorDirec

; 505  :         if ( tokenarray[i].token == T_COMMA && tokenarray[i+1].token != T_FINAL ) {

	movsxd	rdx, ecx
	mov	rax, rdx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 44			; 0000002cH
	jne	SHORT $LN51@ErrorDirec
	lea	rax, QWORD PTR [rdx+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], r13b
	je	SHORT $LN51@ErrorDirec

; 506  :             /* v2.05: added */
; 507  :             /* v2.08: obsolete, the expansion occurs in the preprocessor.
; 508  :              * See ExpandLine() in expans.c
; 509  :              */
; 510  :             //ExpandLineItems( tokenarray[i].tokpos, i, tokenarray, TRUE, FALSE );
; 511  :             i++;
; 512  :             erridx = i++;  /* Masm seems to accept anything as text */

	add	ecx, 2
	mov	DWORD PTR i$[rsp], ecx
$LN51@ErrorDirec:

; 513  :         }
; 514  : 
; 515  :         //if ( tokenarray[i].token != T_FINAL )
; 516  :         //    break;
; 517  : 
; 518  :         /* should run on pass 2 only! */
; 519  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, r13d
	je	$LN57@ErrorDirec

; 520  :             break;
; 521  : 
; 522  :         /* don't use check_defd()! */
; 523  :         /* v2.07: check for structured variables */
; 524  :         if ( Options.strict_masm_compat == FALSE &&
; 525  :             tokenarray[idloc+1].token == T_DOT &&
; 526  :             ( sym = SymSearch( tokenarray[idloc].string_ptr ) ) &&
; 527  :             ( ( sym->state == SYM_TYPE ) || sym->type ) ) {

	cmp	BYTE PTR Options+136, r13b
	jne	$LN49@ErrorDirec
	lea	rax, QWORD PTR [rbp+1]
	mov	rbx, rbp
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 46			; 0000002eH
	jne	$LN49@ErrorDirec
	mov	r14, rbp
	shl	r14, 5
	mov	rcx, QWORD PTR [r14+rsi+8]
	call	SymFind
	test	rax, rax
	mov	rdi, rax
	je	$LN49@ErrorDirec
	cmp	DWORD PTR [rax+40], 7
	je	SHORT $LN48@ErrorDirec
	cmp	QWORD PTR [rax+88], r13
	je	$LN49@ErrorDirec
$LN48@ErrorDirec:

; 528  :             uint_32 value;
; 529  :             int j = idloc;

	inc	rbx

; 530  :             int size;
; 531  :             value = 0;

	mov	DWORD PTR value$5827[rsp], r13d
	shl	rbx, 5
	add	rbx, rsi
	npad	12
$LL47@ErrorDirec:

; 532  :             do {
; 533  :                 j += 2;

	add	ebp, 2
	add	rbx, 64					; 00000040H

; 534  :                 /* if it's a structured variable, use its type! */
; 535  :                 if ( sym->state != SYM_TYPE )

	cmp	DWORD PTR [rdi+40], 7
	je	SHORT $LN44@ErrorDirec

; 536  :                     sym = sym->type;

	mov	rdi, QWORD PTR [rdi+88]
$LN44@ErrorDirec:

; 537  :                 sym = SearchNameInStruct( sym, tokenarray[j].string_ptr, &value, 0 );

	mov	rdx, QWORD PTR [rbx-24]
	lea	r8, QWORD PTR value$5827[rsp]
	xor	r9d, r9d
	mov	rcx, rdi
	call	SearchNameInStruct

; 538  :             } while ( sym && tokenarray[j+1].token == T_DOT );

	test	rax, rax
	mov	rdi, rax
	je	SHORT $LN43@ErrorDirec
	cmp	BYTE PTR [rbx], 46			; 0000002eH
	je	SHORT $LL47@ErrorDirec
$LN43@ErrorDirec:

; 539  :             if ( tokenarray[j].token == T_ID )

	movsxd	rdx, ebp
	shl	rdx, 5
	movzx	eax, BYTE PTR [rdx+rsi]
	cmp	al, 8
	jne	SHORT $LN42@ErrorDirec

; 540  :                 j++;

	inc	ebp
$LN40@ErrorDirec:

; 543  :             }
; 544  :             size = tokenarray[j].tokpos - tokenarray[idloc].tokpos;
; 545  :             memcpy( StringBufferEnd, tokenarray[idloc].tokpos, size );

	mov	rdx, QWORD PTR [r14+rsi+24]
	movsxd	rax, ebp
	shl	rax, 5
	mov	ecx, DWORD PTR [rax+rsi+24]
	sub	ecx, DWORD PTR [r14+rsi+24]
	movsxd	rbx, ecx
	mov	rcx, QWORD PTR ModuleInfo+488
	mov	r8, rbx
	call	memcpy

; 546  :             *(StringBufferEnd+size) = NULLC;

	mov	r11, QWORD PTR ModuleInfo+488
	mov	BYTE PTR [rbx+r11], r13b

; 547  :         } else {

	jmp	SHORT $LN39@ErrorDirec
$LN42@ErrorDirec:

; 541  :             else if ( tokenarray[j].token != T_FINAL && tokenarray[j].token != T_COMMA ) {

	test	al, al
	je	SHORT $LN40@ErrorDirec
	cmp	al, 44					; 0000002cH
	je	SHORT $LN40@ErrorDirec
$LN110@ErrorDirec:

; 542  :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[j].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+rsi+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN71@ErrorDirec
$LN49@ErrorDirec:

; 548  :             sym = SymSearch( tokenarray[idloc].string_ptr );

	mov	rbx, rbp
	shl	rbx, 5
	mov	rcx, QWORD PTR [rbx+rsi+8]
	call	SymFind

; 549  :             strcpy( StringBufferEnd, tokenarray[idloc].string_ptr );

	mov	rcx, QWORD PTR [rbx+rsi+8]
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rdi, rax
	npad	10
$LL73@ErrorDirec:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL73@ErrorDirec
$LN39@ErrorDirec:

; 550  :         }
; 551  :         if ( sym && sym->state == SYM_UNDEFINED )

	test	rdi, rdi
	je	SHORT $LN38@ErrorDirec
	cmp	DWORD PTR [rdi+40], r13d
	cmove	rdi, r13
$LN38@ErrorDirec:

; 552  :             sym = NULL;
; 553  : 
; 554  :         /* Masm "usually" ignores the optional errtxt! */
; 555  :         if( direct == T_DOT_ERRDEF && sym != NULL )

	cmp	r12d, 361				; 00000169H
	jne	SHORT $LN37@ErrorDirec
	test	rdi, rdi
	je	$LN109@ErrorDirec

; 556  :             EmitErr( FORCED_DEF, StringBufferEnd );

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	ecx, 117				; 00000075H
	call	EmitErr
	mov	ecx, DWORD PTR i$[rsp]
	jmp	$LN57@ErrorDirec
$LN37@ErrorDirec:

; 557  :         else if( direct == T_DOT_ERRNDEF && sym == NULL )

	cmp	r12d, 362				; 0000016aH
	jne	$LN109@ErrorDirec
	test	rdi, rdi
	jne	$LN109@ErrorDirec

; 558  :             EmitErr( FORCED_NOT_DEF, StringBufferEnd );

	mov	rdx, QWORD PTR ModuleInfo+488
	lea	ecx, QWORD PTR [rdi+118]
	call	EmitErr

; 559  :         break;

	mov	ecx, DWORD PTR i$[rsp]
	jmp	$LN57@ErrorDirec
$LN34@ErrorDirec:

; 560  :     case CC_BLKARG: /* .ERR[N]B */
; 561  :         string1 = tokenarray[i].string_ptr;

	movsxd	rdx, ecx
	shl	rdx, 5
	add	rdx, rsi

; 562  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	cmp	BYTE PTR [rdx], 9
	mov	rbx, QWORD PTR [rdx+8]
	jne	$LN20@ErrorDirec
	cmp	BYTE PTR [rdx+1], 60			; 0000003cH
	jne	$LN20@ErrorDirec

; 563  :             return( TextItemError( &tokenarray[i] ) );
; 564  :         }
; 565  :         i++;

	inc	ecx

; 566  :         if ( tokenarray[i].token == T_COMMA && tokenarray[i+1].token != T_FINAL ) {

	movsxd	rdx, ecx
	mov	DWORD PTR i$[rsp], ecx
	mov	rax, rdx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 44			; 0000002cH
	jne	SHORT $LN31@ErrorDirec
	lea	rax, QWORD PTR [rdx+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], r13b
	je	SHORT $LN31@ErrorDirec

; 567  :             i++;
; 568  :             erridx = i++;

	lea	r13d, DWORD PTR [rcx+1]
	add	ecx, 2
	mov	DWORD PTR i$[rsp], ecx
$LN31@ErrorDirec:

; 569  :         }
; 570  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	je	$LN57@ErrorDirec

; 571  :             break;
; 572  :         if ( direct == T_DOT_ERRB && check_blank( string1 ) )

	cmp	r12d, 359				; 00000167H
	jne	SHORT $LN29@ErrorDirec
	mov	rcx, rbx
	call	check_blank
	test	al, al
	je	$LN109@ErrorDirec

; 573  :             errmsg = FORCED_BLANK;

	mov	edi, 119				; 00000077H
	jmp	SHORT $LN102@ErrorDirec
$LN29@ErrorDirec:

; 574  :         else if ( direct == T_DOT_ERRNB && !check_blank( string1 ) )

	cmp	r12d, 360				; 00000168H
	jne	$LN57@ErrorDirec
	mov	rcx, rbx
	call	check_blank
	test	al, al
	jne	$LN109@ErrorDirec

; 575  :             errmsg = FORCED_NOT_BLANK;

	mov	edi, 120				; 00000078H
$LN102@ErrorDirec:

; 576  :         if ( errmsg != EMPTY )
; 577  :             EmitErr( errmsg, string1, GetErrText( erridx, tokenarray ) );

	mov	rdx, rsi
	mov	ecx, r13d
	call	GetErrText
	mov	rdx, rbx
	mov	ecx, edi
	mov	r8, rax
	call	EmitErr

; 578  :         break;

	mov	ecx, DWORD PTR i$[rsp]
	jmp	$LN57@ErrorDirec
$LN25@ErrorDirec:

; 579  :     case CC_LITARG: /* .ERRDIF[I], .ERRIDN[I] */
; 580  :         string1 = tokenarray[i].string_ptr;

	movsxd	rdx, ecx
	shl	rdx, 5
	add	rdx, rsi

; 581  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	cmp	BYTE PTR [rdx], 9
	mov	rbp, QWORD PTR [rdx+8]
	jne	$LN20@ErrorDirec
	cmp	BYTE PTR [rdx+1], 60			; 0000003cH
	jne	$LN20@ErrorDirec

; 582  :             return( TextItemError( &tokenarray[i] ) );
; 583  :         }
; 584  :         i++;

	inc	ecx

; 585  :         if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rdx, ecx
	mov	DWORD PTR i$[rsp], ecx
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rsi], 44			; 0000002cH
	je	SHORT $LN22@ErrorDirec

; 586  :             return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rsi+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	$LN71@ErrorDirec
$LN22@ErrorDirec:

; 587  :         }
; 588  :         i++;

	inc	ecx
	mov	DWORD PTR i$[rsp], ecx

; 589  :         string2 = tokenarray[i].string_ptr;

	movsxd	rdx, ecx
	shl	rdx, 5
	add	rdx, rsi

; 590  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	cmp	BYTE PTR [rdx], 9
	mov	rdi, QWORD PTR [rdx+8]
	jne	$LN20@ErrorDirec
	cmp	BYTE PTR [rdx+1], 60			; 0000003cH
	jne	$LN20@ErrorDirec

; 592  :         }
; 593  :         i++;

	inc	ecx

; 594  :         if ( tokenarray[i].token == T_COMMA && tokenarray[i+1].token != T_FINAL ) {

	movsxd	rdx, ecx
	mov	DWORD PTR i$[rsp], ecx
	mov	rax, rdx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 44			; 0000002cH
	jne	SHORT $LN19@ErrorDirec
	lea	rax, QWORD PTR [rdx+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], r13b
	je	SHORT $LN19@ErrorDirec

; 595  :             i++;
; 596  :             erridx = i++;

	lea	r13d, DWORD PTR [rcx+1]
	add	ecx, 2
	mov	DWORD PTR i$[rsp], ecx
$LN19@ErrorDirec:

; 597  :         }
; 598  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	je	$LN57@ErrorDirec

; 599  :             break;
; 600  : 
; 601  :         switch ( direct ) {

	sub	r12d, 355				; 00000163H
	je	SHORT $LN15@ErrorDirec
	dec	r12d
	je	SHORT $LN13@ErrorDirec
	dec	r12d
	je	SHORT $LN11@ErrorDirec

; 614  :         default:
; 615  :             if ( !check_dif( string1, string2, FALSE ) )

	mov	rdx, rdi
	mov	rcx, rbp
	call	_stricmp
	test	eax, eax
	jne	$LN109@ErrorDirec

; 616  :                 errmsg = FORCED_IDN;

	lea	ebx, QWORD PTR [rax+122]
	jmp	SHORT $LN103@ErrorDirec
$LN11@ErrorDirec:

; 610  :         case T_DOT_ERRIDN:
; 611  :             if ( !check_dif( string1, string2, TRUE ) )

	mov	r9, rdi
	mov	rax, rbp
	sub	r9, rbp
$LL107@ErrorDirec:
	movzx	r8d, BYTE PTR [rax]
	movzx	edx, BYTE PTR [rax+r9]
	sub	r8d, edx
	jne	SHORT $LN108@ErrorDirec
	inc	rax
	test	edx, edx
	jne	SHORT $LL107@ErrorDirec
$LN108@ErrorDirec:
	test	r8d, r8d
	jne	$LN57@ErrorDirec

; 612  :                 errmsg = FORCED_IDN;

	lea	ebx, QWORD PTR [r8+122]

; 613  :             break;

	jmp	SHORT $LN103@ErrorDirec
$LN13@ErrorDirec:

; 605  :             break;
; 606  :         case T_DOT_ERRDIFI:
; 607  :             if ( check_dif( string1, string2, FALSE ) )

	mov	rdx, rdi
	mov	rcx, rbp
	call	_stricmp
	test	eax, eax
	je	$LN109@ErrorDirec

; 608  :                 errmsg = FORCED_DIF;

	mov	ebx, 121				; 00000079H

; 609  :             break;

	jmp	SHORT $LN103@ErrorDirec
$LN15@ErrorDirec:

; 602  :         case T_DOT_ERRDIF:
; 603  :             if ( check_dif( string1, string2, TRUE ) )

	mov	r10, rdi
	mov	rax, rbp
	sub	r10, rbp
	npad	8
$LL105@ErrorDirec:
	movzx	r9d, BYTE PTR [rax]
	movzx	edx, BYTE PTR [rax+r10]
	sub	r9d, edx
	jne	SHORT $LN106@ErrorDirec
	inc	rax
	test	edx, edx
	jne	SHORT $LL105@ErrorDirec
$LN106@ErrorDirec:
	test	r9d, r9d
	je	$LN57@ErrorDirec

; 604  :                 errmsg = FORCED_DIF;

	mov	ebx, 121				; 00000079H
$LN103@ErrorDirec:

; 617  :         }
; 618  :         if ( errmsg != EMPTY )
; 619  :             EmitErr( errmsg, string1, string2, GetErrText( erridx, tokenarray ) );

	mov	rdx, rsi
	mov	ecx, r13d
	call	GetErrText
	mov	r8, rdi
	mov	rdx, rbp
	mov	r9, rax
	mov	ecx, ebx
	call	EmitErr

; 620  :         break;

	mov	ecx, DWORD PTR i$[rsp]
	jmp	$LN57@ErrorDirec
$LN20@ErrorDirec:

; 591  :             return( TextItemError( &tokenarray[i] ) );

	mov	rcx, rdx
	call	TextItemError
	jmp	$LN71@ErrorDirec
$LN68@ErrorDirec:

; 469  :     case CC_NUMARG: /* .ERR[E|NZ] */
; 470  : 
; 471  :         if (( ERROR == EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) ))

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	BYTE PTR [rsp+32], r13b
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN67@ErrorDirec

; 472  :             return( ERROR );

	jmp	$LN71@ErrorDirec
$LN67@ErrorDirec:

; 473  :         if ( opndx.kind == EXPR_CONST )

	mov	eax, DWORD PTR opndx$[rsp+60]
	test	eax, eax
	je	SHORT $LN63@ErrorDirec

; 474  :             ;
; 475  :         else if ( opndx.kind == EXPR_ADDR && opndx.indirect == FALSE && opndx.sym && opndx.sym->state == SYM_UNDEFINED )

	cmp	eax, 1
	jne	$LN64@ErrorDirec
	test	BYTE PTR opndx$[rsp+72], al
	jne	$LN64@ErrorDirec
	mov	rax, QWORD PTR opndx$[rsp+80]
	test	rax, rax
	je	$LN64@ErrorDirec
	cmp	DWORD PTR [rax+40], r13d
	jne	$LN64@ErrorDirec
$LN63@ErrorDirec:

; 479  :         }
; 480  :         if ( tokenarray[i].token == T_COMMA && tokenarray[i+1].token != T_FINAL ) {

	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 44			; 0000002cH
	jne	SHORT $LN62@ErrorDirec
	lea	rax, QWORD PTR [rcx+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], r13b
	je	SHORT $LN62@ErrorDirec

; 481  :             i++;
; 482  :             erridx = i++;

	lea	r13d, DWORD PTR [rcx+1]
	add	ecx, 2
	mov	DWORD PTR i$[rsp], ecx
$LN62@ErrorDirec:

; 483  :         }
; 484  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN57@ErrorDirec

; 485  :             break;
; 486  :         if ( direct == T_DOT_ERRNZ && opndx.value ) {

	cmp	r12d, 354				; 00000162H
	jne	SHORT $LN60@ErrorDirec
	cmp	DWORD PTR opndx$[rsp], 0
	je	SHORT $LN57@ErrorDirec

; 487  :             errmsg = FORCED_NOT_ZERO;

	mov	ebx, 115				; 00000073H
	jmp	SHORT $LN104@ErrorDirec
$LN60@ErrorDirec:

; 488  :         } else if ( direct == T_DOT_ERRE && !opndx.value ) {

	cmp	r12d, 353				; 00000161H
	jne	SHORT $LN57@ErrorDirec
	cmp	DWORD PTR opndx$[rsp], 0
	jne	SHORT $LN57@ErrorDirec

; 489  :             errmsg = FORCED_EQUAL;

	mov	ebx, 116				; 00000074H
$LN104@ErrorDirec:

; 490  :         }
; 491  : 
; 492  :         if ( errmsg != EMPTY )
; 493  :             EmitErr( errmsg, opndx.value, GetErrText( erridx, tokenarray ) );

	mov	rdx, rsi
	mov	ecx, r13d
	call	GetErrText
	mov	edx, DWORD PTR opndx$[rsp]
	mov	ecx, ebx
	mov	r8, rax
	call	EmitErr
	mov	ecx, DWORD PTR i$[rsp]
	jmp	SHORT $LN57@ErrorDirec
$LN109@ErrorDirec:

; 633  :         break;

	mov	ecx, DWORD PTR i$[rsp]
$LN57@ErrorDirec:

; 634  :     }
; 635  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, ecx
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rsi], 0
	je	SHORT $LN1@ErrorDirec

; 636  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rsi+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN71@ErrorDirec
$LN1@ErrorDirec:

; 637  :     }
; 638  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN71@ErrorDirec
$LN64@ErrorDirec:

; 476  :             ;//opndx.value += opndx.sym->offset;
; 477  :         else {
; 478  :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
$LN111@ErrorDirec:
	call	EmitError
$LN71@ErrorDirec:
	mov	r14, QWORD PTR [rsp+160]
	mov	r13, QWORD PTR [rsp+168]
	mov	r12, QWORD PTR [rsp+176]
	mov	rdi, QWORD PTR [rsp+184]
	mov	rsi, QWORD PTR [rsp+192]
	mov	rbp, QWORD PTR [rsp+232]
	mov	rbx, QWORD PTR [rsp+224]

; 639  : }

	add	rsp, 200				; 000000c8H
	ret	0
ErrorDirective ENDP
_TEXT	ENDS
PUBLIC	CondCheckOpen
xdata	SEGMENT
$unwind$CondCheckOpen DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$CondCheckOpen DD @imagerel($LN4#)
	DD	@imagerel($LN4#+35)
	DD	@imagerel($unwind$CondCheckOpen#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
CondCheckOpen PROC NEAR

; 643  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 644  :     if( blocknestlevel > 0 ) {

	cmp	DWORD PTR blocknestlevel, 0
	jle	SHORT $LN1@CondCheckO

; 645  :         EmitErr( BLOCK_NESTING_ERROR, "if-else" );

	lea	rdx, OFFSET FLAT:$SG5885
	mov	ecx, 80					; 00000050H
	call	EmitErr
$LN1@CondCheckO:

; 646  :     }
; 647  :     return;
; 648  : }

	add	rsp, 40					; 00000028H
	ret	0
CondCheckOpen ENDP
_TEXT	ENDS
PUBLIC	GetIfNestLevel
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
GetIfNestLevel PROC NEAR

; 653  :     return( blocknestlevel );

	mov	eax, DWORD PTR blocknestlevel

; 654  : }

	ret	0
GetIfNestLevel ENDP
_TEXT	ENDS
PUBLIC	SetIfNestLevel
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
newlevel$ = 8
SetIfNestLevel PROC NEAR

; 659  :     blocknestlevel = newlevel;

	mov	DWORD PTR blocknestlevel, ecx

; 660  :     return;
; 661  : }

	ret	0
SetIfNestLevel ENDP
_TEXT	ENDS
PUBLIC	CondInit
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
CondInit PROC NEAR

; 668  :     CurrIfState = BLOCK_ACTIVE;

	xor	eax, eax
	mov	DWORD PTR CurrIfState, eax

; 669  :     blocknestlevel = 0;

	mov	DWORD PTR blocknestlevel, eax

; 670  :     falseblocknestlevel = 0;

	mov	DWORD PTR falseblocknestlevel, eax

; 671  : }

	ret	0
CondInit ENDP
_TEXT	ENDS
END
