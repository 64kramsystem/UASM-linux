; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
cv_idx_type DW	012H
	ORG $+2
cv_void	DW	03H
	ORG $+2
cv_abs_type DW	01H
	ORG $+2
?padtab@?1??PadBytes@@9@9 DB 0f1H			; `PadBytes'::`2'::padtab
	DB	0f2H
	DB	0f3H
CONST	ENDS
_DATA	SEGMENT
$SG5979	DB	'@@%u', 00H
	ORG $+3
$SG6042	DB	'__unnamed', 00H
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
reg64	DB	00H
	DB	02H
	DB	03H
	DB	01H
	DB	07H
	DB	06H
	DB	04H
	DB	05H
CONST	ENDS
_DATA	SEGMENT
	ORG $+2
$SG6156	DB	'TLS', 00H
_DATA	ENDS
EXTRN	SizeFromMemtype:NEAR
xdata	SEGMENT
$unwind$GetTyperef DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$GetTyperef DD @imagerel(GetTyperef#)
	DD	@imagerel(GetTyperef#+529)
	DD	@imagerel($unwind$GetTyperef#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\dbgcv.c
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
Ofssize$ = 56
GetTyperef PROC NEAR

; 92   : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 93   :     union cv_typeref_u value = { CV_PDS_SPECIAL_NO_TYPE, 0, CV_PDT_SPECIAL, CV_PDM_DIRECT, 0 };

	xor	cx, cx

; 94   : 
; 95   :     if ( ( sym->mem_type & MT_SPECIAL ) == 0 ) {

	mov	r8d, DWORD PTR [rbx+44]
	test	r8b, r8b
	jns	SHORT $LN43@GetTyperef
	npad	11
$LL40@GetTyperef:

; 128  :         }
; 129  :     } else {
; 130  :         switch ( sym->mem_type ) {

	sub	r8d, 129				; 00000081H
	je	$LN7@GetTyperef
	dec	r8d
	je	$LN6@GetTyperef
	sub	r8d, 63					; 0000003fH
	je	$LN9@GetTyperef
	sub	r8d, 2
	je	$LN15@GetTyperef
	dec	r8d
	jne	$LN16@GetTyperef

; 156  :         case MT_TYPE:
; 157  :             for ( sym = sym->type; sym->type; sym = sym->type );

	mov	rbx, QWORD PTR [rbx+88]
	mov	rax, QWORD PTR [rbx+88]
	test	rax, rax
	je	SHORT $LN2@GetTyperef
$LL4@GetTyperef:
	mov	rbx, rax
	mov	rax, QWORD PTR [rax+88]
	test	rax, rax
	jne	SHORT $LL4@GetTyperef
$LN2@GetTyperef:

; 158  :             if ( sym->cvtyperef )

	cmp	WORD PTR [rbx+72], 0
	jne	$LN44@GetTyperef
	mov	r8d, DWORD PTR [rbx+44]
	xor	cx, cx
	test	r8b, r8b
	js	SHORT $LL40@GetTyperef
$LN43@GetTyperef:

; 96   :         int size = SizeFromMemtype( sym->mem_type, Ofssize, sym->type );

	mov	r8, QWORD PTR [rbx+88]
	mov	ecx, DWORD PTR [rbx+44]
	movzx	edx, dl
	call	SizeFromMemtype
	mov	r11d, eax

; 97   :         if ( sym->mem_type & MT_FLOAT ) {

	mov	eax, DWORD PTR [rbx+44]
	test	al, 32					; 00000020H
	je	SHORT $LN36@GetTyperef

; 98   :             value.s.type = CV_PDT_REAL;
; 99   :             switch ( size ) {

	cmp	r11d, 4
	mov	cx, 64					; 00000040H
	je	SHORT $LN33@GetTyperef
	cmp	r11d, 8
	je	SHORT $LN32@GetTyperef
	cmp	r11d, 10
	jne	$LN16@GetTyperef

; 102  :             case 10: value.s.size = CV_PDS_REAL_80BIT; break;

	mov	cx, 66					; 00000042H

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	mov	ax, cx

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN32@GetTyperef:

; 101  :             case 8:  value.s.size = CV_PDS_REAL_64BIT; break;

	mov	cx, 65					; 00000041H

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	mov	ax, cx

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN33@GetTyperef:

; 100  :             case 4:  value.s.size = CV_PDS_REAL_32BIT; break;

	mov	cx, 64					; 00000040H

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	mov	ax, cx

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN36@GetTyperef:

; 103  :             }
; 104  :         } else if ( size <= 8 ) {

	cmp	r11d, 8
	jg	$LN29@GetTyperef

; 105  :             if ( sym->mem_type & MT_SIGNED )

	test	al, 64					; 00000040H
	mov	ecx, 32					; 00000020H
	mov	eax, 16
	cmovne	cx, ax

; 106  :                 value.s.type = CV_PDT_SIGNED_INTEGRAL;
; 107  :             else
; 108  :                 value.s.type = CV_PDT_UNSIGNED_INTEGRAL;
; 109  :             switch ( size ) {

	dec	r11d
	je	SHORT $LN24@GetTyperef
	dec	r11d
	je	SHORT $LN23@GetTyperef
	sub	r11d, 2
	je	SHORT $LN22@GetTyperef
	sub	r11d, 2
	je	SHORT $LN20@GetTyperef
	cmp	r11d, 2
	jne	$LN16@GetTyperef

; 113  :             case 8:  value.s.size = CV_PDS_INTEGRAL_8BYTE; break;

	and	cx, 65531				; 0000fffbH
	or	cx, 3

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	mov	ax, cx

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN20@GetTyperef:
	and	cx, 64779				; 0000fd0bH

; 114  :             case 6: /* v2.11: added ( FWORD ) */
; 115  :                 value.s.type = CV_PDT_SPECIAL;
; 116  :                 value.s.size = CV_PDS_SPECIAL_VOID;
; 117  :                 value.s.mode = CV_PDM_FAR32PTR;

	or	cx, 1283				; 00000503H

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	mov	ax, cx

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN22@GetTyperef:

; 112  :             case 4:  value.s.size = CV_PDS_INTEGRAL_4BYTE; break;

	and	cx, 65530				; 0000fffaH
	or	cx, 2

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	mov	ax, cx

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN23@GetTyperef:

; 111  :             case 2:  value.s.size = CV_PDS_INTEGRAL_2BYTE; break;

	and	cx, 65529				; 0000fff9H
	or	cx, 1

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	mov	ax, cx

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN24@GetTyperef:

; 110  :             case 1:  value.s.size = CV_PDS_INTEGRAL_1BYTE; break;

	and	cx, 65528				; 0000fff8H

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	mov	ax, cx

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN29@GetTyperef:

; 118  :                 break;
; 119  :             }
; 120  :         } else { /* v2.11: branch added */
; 121  :             /* problem: there's no integral size > 8 bytes.
; 122  :              * Masm v8+ sets 79h (=?) for 16-byte and 3h (=void) for 32-byte.
; 123  :              * jwasm sets uint64, which allows to view at least
; 124  :              * the lower 8 bytes.
; 125  :              */
; 126  :             value.s.type = CV_PDT_REAL_INT_VALUE;
; 127  :             value.s.size = CV_PDS_REAL_INT_UINT64;

	mov	cx, 119					; 00000077H

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	mov	ax, cx

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN44@GetTyperef:

; 159  :                 return( sym->cvtyperef );

	mov	ax, WORD PTR [rbx+72]

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN15@GetTyperef:

; 131  :         //case MT_ABS:  break;  /* v2.07: MT_ABS obsolete */
; 132  :         case MT_PTR:
; 133  :             /* v2.10 */
; 134  :             value.s.size = CV_PDS_SPECIAL_VOID;
; 135  :             value.s.type = CV_PDT_SPECIAL;
; 136  :             switch ( sym->Ofssize ) {

	movzx	edx, BYTE PTR [rbx+52]
	mov	cx, 3
	test	edx, edx
	je	SHORT $LN12@GetTyperef
	dec	edx
	je	SHORT $LN11@GetTyperef
	dec	edx
	jne	SHORT $LN16@GetTyperef

; 142  :                 break;
; 143  : #if AMD64_SUPPORT
; 144  :             case USE64:
; 145  :                 value.s.mode = CV_PDM_NEAR64PTR;

	mov	cx, 1539				; 00000603H

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	mov	ax, cx

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN11@GetTyperef:

; 139  :                 break;
; 140  :             case USE32:
; 141  :                 value.s.mode = ( sym->isfar ? CV_PDM_FAR32PTR : CV_PDM_NEAR32PTR );

	movzx	eax, BYTE PTR [rbx+55]
	shr	al, 4
	and	al, 1
	movzx	ecx, al
	shl	cx, 8
	or	cx, 1027				; 00000403H

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	mov	ax, cx

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN12@GetTyperef:

; 137  :             case USE16:
; 138  :                 value.s.mode = ( sym->isfar ? CV_PDM_FARPTR : CV_PDM_NEARPTR );

	test	BYTE PTR [rbx+55], 16
	mov	eax, 0
	setne	al
	inc	ax
	and	ax, 7
	shl	ax, 8
	or	ax, 3
	mov	cx, ax

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN9@GetTyperef:

; 146  :                 break;
; 147  : #endif
; 148  :             }
; 149  :             break;
; 150  :         case MT_BITS:
; 151  :             if ( sym->cvtyperef )

	movzx	eax, WORD PTR [rbx+72]
	test	ax, ax
	je	SHORT $LN16@GetTyperef

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN6@GetTyperef:

; 155  :         case MT_FAR:  value.s.mode = CV_PDM_FARPTR; break;

	mov	cx, 512					; 00000200H

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	mov	ax, cx

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN7@GetTyperef:

; 152  :                 return( sym->cvtyperef );
; 153  :             break;
; 154  :         case MT_NEAR: value.s.mode = CV_PDM_NEARPTR; break;

	mov	cx, 256					; 00000100H
$LN16@GetTyperef:

; 160  :             DebugMsg(( "GetTypeRef, MT_TYPE: sym=%s state=%X memt=%X\n", sym->name, sym->state, sym->mem_type ));
; 161  :             return( GetTyperef( sym, Ofssize ) );
; 162  :             break;
; 163  :         }
; 164  :     }
; 165  : 
; 166  :     return( value.uvalue );

	mov	ax, cx

; 167  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
GetTyperef ENDP
_TEXT	ENDS
EXTRN	Options:BYTE
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
sym$ = 8
Ofssize$ = 16
GetCVStructLen PROC NEAR

; 174  :     uint_16 len;
; 175  :     switch ( sym->state ) {

	cmp	DWORD PTR [rcx+40], 7
	je	SHORT $LN9@GetCVStruc

; 176  :     case SYM_TYPE:
; 177  :         len = sizeof( struct cv_symrec_udt );
; 178  :         break;
; 179  :     default:
; 180  :         if ( sym->isproc && Options.debug_ext >= CVEX_REDUCED ) {

	test	BYTE PTR [rcx+49], 8
	je	SHORT $LN7@GetCVStruc
	cmp	BYTE PTR Options+3, 1
	jb	SHORT $LN7@GetCVStruc

; 181  :             len = ( Ofssize == USE16 ? sizeof( struct cv_symrec_lproc16 ) : sizeof( struct cv_symrec_lproc32 ) );

	mov	eax, 37					; 00000025H
	mov	ecx, 29
	test	dl, dl
	cmove	ax, cx

; 193  : }

	ret	0
$LN7@GetCVStruc:

; 182  :         } else if ( sym->mem_type == MT_NEAR || sym->mem_type == MT_FAR ) {

	mov	eax, DWORD PTR [rcx+44]
	cmp	eax, 129				; 00000081H
	je	SHORT $LN4@GetCVStruc
	cmp	eax, 130				; 00000082H
	je	SHORT $LN4@GetCVStruc

; 184  : #if EQUATESYMS
; 185  :         } else if ( sym->isequate ) {

	test	BYTE PTR [rcx+48], 16
	je	SHORT $LN2@GetCVStruc

; 186  :             len = sizeof( struct cv_symrec_constant ) + ( sym->value >= LF_NUMERIC ? 2 : 0 );

	xor	eax, eax
	cmp	DWORD PTR [rcx+16], 32768		; 00008000H
	mov	edx, 2
	cmovge	ax, dx
	add	ax, 8

; 193  : }

	ret	0
$LN2@GetCVStruc:

; 187  : #endif
; 188  :         } else {
; 189  :             len = ( Ofssize == USE16 ? sizeof( struct cv_symrec_ldata16 ) : sizeof( struct cv_symrec_ldata32 ) );

	mov	eax, 12
	mov	ecx, 10
	test	dl, dl
	cmove	ax, cx

; 193  : }

	ret	0
$LN4@GetCVStruc:

; 183  :             len = ( Ofssize == USE16 ? sizeof( struct cv_symrec_label16 ) : sizeof( struct cv_symrec_label32 ) );

	mov	eax, 11
	mov	ecx, 9
	test	dl, dl
	cmove	ax, cx

; 193  : }

	ret	0
$LN9@GetCVStruc:

; 190  :         }
; 191  :     }
; 192  :     return( len );

	mov	ax, 6

; 193  : }

	ret	0
GetCVStructLen ENDP
; Function compile flags: /Ogtpy
curr$ = 8
base$ = 16
PadBytes PROC NEAR

; 207  :     static const char padtab[] = { LF_PAD1, LF_PAD2, LF_PAD3 };
; 208  :     while( ( curr - base ) & 3 )

	mov	r8, rcx
	sub	r8, rdx
	mov	rdx, r8
	and	edx, 3
	je	SHORT $LN1@PadBytes
	lea	r9, OFFSET FLAT:?padtab@?1??PadBytes@@9@9+3
	npad	11
$LL2@PadBytes:

; 209  :         *curr++ = padtab[3-((curr - base) & 3)];

	inc	r8
	mov	rax, r9
	inc	rcx
	sub	rax, rdx
	mov	rdx, r8
	and	edx, 3
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx-1], al
	jne	SHORT $LL2@PadBytes
$LN1@PadBytes:

; 210  : }

	ret	0
PadBytes ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$cv_write_bitfield DD 072501H
	DD	097425H
	DD	08640eH
	DD	073409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$cv_write_bitfield DD @imagerel(cv_write_bitfield#)
	DD	@imagerel(cv_write_bitfield#+153)
	DD	@imagerel($unwind$cv_write_bitfield#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
cv$ = 48
type$ = 56
sym$ = 64
cv_write_bitfield PROC NEAR

; 216  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, rcx

; 217  :     cv->pt = checkflush( cv->types, cv->pt, sizeof( struct cv_typerec_bitfield ), cv->param );

	mov	rcx, QWORD PTR [rcx+24]
	mov	r9, QWORD PTR [rsi+32]
	mov	rbx, r8
	mov	rax, QWORD PTR [rcx+104]
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rdx
	mov	rdx, QWORD PTR [rsi+16]
	mov	r8d, 8
	call	QWORD PTR [rax+32]

; 218  :     sym->cvtyperef = cv->currtype++;
; 219  :     cv->pt_bf->tr.size = sizeof( struct cv_typerec_bitfield ) - sizeof(uint_16);
; 220  :     cv->pt_bf->tr.leaf = LF_BITFIELD;
; 221  :     cv->pt_bf->length = sym->total_size;
; 222  :     cv->pt_bf->position = sym->offset;
; 223  :     cv->pt_bf->type = GetTyperef( (struct asym *)type, USE16 );

	xor	edx, edx
	mov	QWORD PTR [rsi+16], rax
	movzx	eax, WORD PTR [rsi+44]
	mov	WORD PTR [rbx+72], ax
	inc	WORD PTR [rsi+44]
	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax], 6
	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+2], 518			; 00000206H
	mov	rcx, QWORD PTR [rsi+16]
	movzx	eax, BYTE PTR [rbx+64]
	mov	BYTE PTR [rcx+4], al
	mov	rcx, QWORD PTR [rsi+16]
	movzx	eax, BYTE PTR [rbx+16]
	mov	BYTE PTR [rcx+5], al
	mov	rcx, rdi
	call	GetTyperef
	mov	rcx, QWORD PTR [rsi+16]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+56]
	mov	WORD PTR [rcx+6], ax

; 224  :     cv->pt += sizeof( struct cv_typerec_bitfield );

	add	QWORD PTR [rsi+16], 8
	mov	rsi, QWORD PTR [rsp+64]

; 225  :     return;
; 226  : }

	add	rsp, 40					; 00000028H
	ret	0
cv_write_bitfield ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$cv_write_array_type DD 030901H
	DD	083409H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$cv_write_array_type DD @imagerel(cv_write_array_type#)
	DD	@imagerel(cv_write_array_type#+9)
	DD	@imagerel($unwind$cv_write_array_type#)
pdata	ENDS
xdata	SEGMENT
$chain$5$cv_write_array_type DD 0a3521H
	DD	05d435H
	DD	06c430H
	DD	0b7416H
	DD	0a640aH
	DD	095405H
	DD	@imagerel(cv_write_array_type#)
	DD	@imagerel(cv_write_array_type#+9)
	DD	@imagerel($unwind$cv_write_array_type#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$cv_write_array_type DD @imagerel(cv_write_array_type#+9)
	DD	@imagerel(cv_write_array_type#+186)
	DD	@imagerel($chain$5$cv_write_array_type#)
pdata	ENDS
xdata	SEGMENT
$chain$6$cv_write_array_type DD 040021H
	DD	05d400H
	DD	0b7400H
	DD	@imagerel(cv_write_array_type#)
	DD	@imagerel(cv_write_array_type#+9)
	DD	@imagerel($unwind$cv_write_array_type#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$cv_write_array_type DD @imagerel(cv_write_array_type#+186)
	DD	@imagerel(cv_write_array_type#+248)
	DD	@imagerel($chain$6$cv_write_array_type#)
pdata	ENDS
xdata	SEGMENT
$chain$7$cv_write_array_type DD 020021H
	DD	05d400H
	DD	@imagerel(cv_write_array_type#)
	DD	@imagerel(cv_write_array_type#+9)
	DD	@imagerel($unwind$cv_write_array_type#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$cv_write_array_type DD @imagerel(cv_write_array_type#+248)
	DD	@imagerel(cv_write_array_type#+309)
	DD	@imagerel($chain$7$cv_write_array_type#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
cv$ = 64
sym$ = 72
elemtype$ = 80
Ofssize$ = 88
cv_write_array_type PROC NEAR

; 234  : {

	sub	rsp, 56					; 00000038H
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+80], rsi
	mov	rbx, rcx

; 235  :     uint_8      *tmp;
; 236  :     int         typelen;
; 237  :     int         size;
; 238  : 
; 239  :     typelen = ( sym->total_size >= LF_NUMERIC ? sizeof( uint_32 ) : 0 );
; 240  :     size = ( sizeof( struct cv_typerec_array ) + 2 + typelen + 1 + 3 ) & ~3;
; 241  :     cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+88], rdi
	xor	ebp, ebp
	cmp	DWORD PTR [rdx+64], 32768		; 00008000H
	mov	eax, 4
	cmovae	ebp, eax
	mov	rax, QWORD PTR [rcx+104]
	mov	QWORD PTR [rsp+48], r12
	mov	QWORD PTR [rsp+40], r13
	movzx	r12d, r9b
	mov	r9, QWORD PTR [rbx+32]
	mov	rdi, rdx
	mov	rdx, QWORD PTR [rbx+16]
	movzx	esi, r8w
	lea	r13d, DWORD PTR [rbp+16]
	and	r13d, -4
	mov	r8d, r13d
	call	QWORD PTR [rax+32]

; 242  :     cv->pt_ar->tr.size = size - sizeof(uint_16);
; 243  :     cv->pt_ar->tr.leaf = LF_ARRAY;
; 244  :     cv->pt_ar->elemtype = ( elemtype ? elemtype : GetTyperef( sym, Ofssize ) );

	test	si, si
	lea	ecx, DWORD PTR [r13-2]
	mov	QWORD PTR [rbx+16], rax
	mov	WORD PTR [rax], cx
	mov	rax, QWORD PTR [rbx+16]
	mov	WORD PTR [rax+2], 3
	je	SHORT $LN5@cv_write_a
	movzx	ecx, si
	jmp	SHORT $LN6@cv_write_a
$LN5@cv_write_a:
	movzx	edx, r12b
	mov	rcx, rdi
	call	GetTyperef
	movzx	ecx, ax
$LN6@cv_write_a:
	mov	rax, QWORD PTR [rbx+16]
	mov	r12, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+80]
	mov	WORD PTR [rax+4], cx

; 245  :     cv->pt_ar->idxtype = cv_idx_type.uvalue; /* ok? */

	mov	rax, QWORD PTR [rbx+16]

; 246  :     tmp = cv->pt + sizeof( struct cv_typerec_array );
; 247  :     if ( typelen ) {

	test	ebp, ebp
	mov	rbp, QWORD PTR [rsp+72]
	mov	WORD PTR [rax+6], 18
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rcx+10]
	je	SHORT $LN2@cv_write_a

; 248  :         cv->pt_ar->length = LF_ULONG;

	mov	WORD PTR [rcx+8], 32772			; 00008004H

; 249  :         *(uint_32 *)tmp = sym->total_size;

	mov	eax, DWORD PTR [rdi+64]

; 250  :         tmp += sizeof( uint_32 );

	add	r8, 4
	mov	DWORD PTR [r8-4], eax

; 251  :     } else {

	jmp	SHORT $LN1@cv_write_a
$LN2@cv_write_a:

; 252  :         cv->pt_ar->length = sym->total_size;

	movzx	eax, WORD PTR [rdi+64]
	mov	WORD PTR [rcx+8], ax
$LN1@cv_write_a:
	mov	rdi, QWORD PTR [rsp+88]

; 253  :     }
; 254  :     *tmp++ = NULLC; /* the array type name is empty */

	mov	BYTE PTR [r8], 0

; 255  :     PadBytes( tmp, cv->types->e.seginfo->CodeBuffer );

	mov	rax, QWORD PTR [rbx+24]
	mov	rcx, QWORD PTR [rax+104]
	inc	r8
	mov	rdx, r8
	sub	rdx, QWORD PTR [rcx+16]
	mov	rcx, rdx
	and	ecx, 3
	je	SHORT $LN7@cv_write_a

; 253  :     }
; 254  :     *tmp++ = NULLC; /* the array type name is empty */

	lea	r9, OFFSET FLAT:?padtab@?1??PadBytes@@9@9+3
	npad	1

; 255  :     PadBytes( tmp, cv->types->e.seginfo->CodeBuffer );

$LL8@cv_write_a:
	inc	rdx
	mov	rax, r9
	inc	r8
	sub	rax, rcx
	mov	rcx, rdx
	and	ecx, 3
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [r8-1], al
	jne	SHORT $LL8@cv_write_a
$LN7@cv_write_a:

; 256  :     cv->pt += size;

	movsxd	rax, r13d
	mov	r13, QWORD PTR [rsp+40]
	add	QWORD PTR [rbx+16], rax

; 257  :     cv->currtype++;

	inc	WORD PTR [rbx+44]
	mov	rbx, QWORD PTR [rsp+64]

; 258  :     return;
; 259  : }

	add	rsp, 56					; 00000038H
	ret	0
cv_write_array_type ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$cv_write_ptr_type DD 051201H
	DD	097412H
	DD	08640dH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$cv_write_ptr_type DD @imagerel(cv_write_ptr_type#)
	DD	@imagerel(cv_write_ptr_type#+223)
	DD	@imagerel($unwind$cv_write_ptr_type#)
pdata	ENDS
xdata	SEGMENT
$chain$2$cv_write_ptr_type DD 020521H
	DD	073405H
	DD	@imagerel(cv_write_ptr_type#)
	DD	@imagerel(cv_write_ptr_type#+223)
	DD	@imagerel($unwind$cv_write_ptr_type#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$cv_write_ptr_type DD @imagerel(cv_write_ptr_type#+223)
	DD	@imagerel(cv_write_ptr_type#+258)
	DD	@imagerel($chain$2$cv_write_ptr_type#)
pdata	ENDS
xdata	SEGMENT
$chain$3$cv_write_ptr_type DD 021H
	DD	@imagerel(cv_write_ptr_type#)
	DD	@imagerel(cv_write_ptr_type#+223)
	DD	@imagerel($unwind$cv_write_ptr_type#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$cv_write_ptr_type DD @imagerel(cv_write_ptr_type#+258)
	DD	@imagerel(cv_write_ptr_type#+300)
	DD	@imagerel($chain$3$cv_write_ptr_type#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
cv$ = 48
sym$ = 56
cv_write_ptr_type PROC NEAR

; 267  : {

	sub	rsp, 40					; 00000028H

; 268  :     int size = ( sizeof( struct cv_typerec_pointer ) + sizeof( uint_32 ) );
; 269  : 
; 270  :     /* for untyped pointers & for function pointers don't create a type, just
; 271  :      * return a void ptr.
; 272  :      */
; 273  :     if ( ( sym->ptr_memtype == MT_EMPTY && sym->target_type == NULL ) || sym->ptr_memtype == MT_PROC )

	movzx	eax, BYTE PTR [rdx+54]
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	cmp	al, 192					; 000000c0H
	mov	rdi, rdx
	mov	rsi, rcx
	jne	SHORT $LN9@cv_write_p
	cmp	QWORD PTR [rdx+56], 0
	je	SHORT $LN10@cv_write_p
$LN9@cv_write_p:
	cmp	al, 128					; 00000080H
	jne	SHORT $LN11@cv_write_p
$LN10@cv_write_p:

; 274  :         return( GetTyperef( sym, sym->Ofssize ) );

	movzx	edx, BYTE PTR [rdx+52]
	mov	rcx, rdi
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]

; 304  : }

	add	rsp, 40					; 00000028H
	jmp	GetTyperef
$LN11@cv_write_p:

; 275  : 
; 276  :     cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	mov	rcx, QWORD PTR [rcx+24]
	mov	r9, QWORD PTR [rsi+32]
	mov	rdx, QWORD PTR [rsi+16]
	mov	rax, QWORD PTR [rcx+104]
	mov	r8d, 12
	call	QWORD PTR [rax+32]
	mov	QWORD PTR [rsi+16], rax

; 277  :     cv->pt_ptr->tr.size = size - sizeof(uint_16);

	mov	WORD PTR [rax], 10

; 278  :     cv->pt_ptr->tr.leaf = LF_POINTER;

	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+2], 2

; 279  :     if ( sym->Ofssize == USE16 ) {

	cmp	BYTE PTR [rdi+52], 0
	jne	SHORT $LN8@cv_write_p

; 280  :         cv->pt_ptr->attribute = ( sym->isfar ? CV_TYPE_PTRTYPE_FAR : CV_TYPE_PTRTYPE_NEAR );

	movzx	eax, BYTE PTR [rdi+55]
	shr	al, 4
	and	al, 1
	movzx	ecx, al
	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+4], cx

; 281  :     } else {

	jmp	SHORT $LN7@cv_write_p
$LN8@cv_write_p:

; 282  :         cv->pt_ptr->attribute = ( sym->isfar ? CV_TYPE_PTRTYPE_FAR32 : CV_TYPE_PTRTYPE_NEAR32 );

	movzx	eax, BYTE PTR [rdi+55]
	and	al, 16
	or	al, 175					; 000000afH
	shr	al, 4
	movzx	ecx, al
	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+4], cx
$LN7@cv_write_p:

; 283  :     }
; 284  :     /* if indirection is > 1, define an untyped pointer - to be improved */
; 285  :     if ( sym->is_ptr > 1 ) {

	cmp	BYTE PTR [rdi+53], 1
	jbe	SHORT $LN6@cv_write_p
$LN3@cv_write_p:

; 286  :         cv->pt_ptr->type = GetTyperef( sym, sym->Ofssize );

	movzx	edx, BYTE PTR [rdi+52]
	mov	rcx, rdi
	call	GetTyperef
	mov	rcx, QWORD PTR [rsi+16]
	mov	WORD PTR [rcx+6], ax
	jmp	SHORT $LN1@cv_write_p
$LN6@cv_write_p:

; 287  :     } else if ( sym->target_type ) {

	mov	rax, QWORD PTR [rdi+56]
	test	rax, rax
	je	SHORT $LN4@cv_write_p

; 288  :         /* the target's typeref must have been set here */
; 289  :         if ( sym->target_type->cvtyperef )

	movzx	ecx, WORD PTR [rax+72]
	test	cx, cx
	je	SHORT $LN3@cv_write_p

; 290  :             cv->pt_ptr->type = sym->target_type->cvtyperef;

	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+6], cx

; 291  :         else

	jmp	SHORT $LN1@cv_write_p
$LN4@cv_write_p:

; 292  :             cv->pt_ptr->type = GetTyperef( sym, sym->Ofssize );
; 293  :     } else { /* pointer to simple type */
; 294  :         enum memtype tmpmt = sym->mem_type; /* the target type is tmp. copied to mem_type */
; 295  :         sym->mem_type = sym->ptr_memtype;   /* thus GetTyperef() can be used */

	movzx	eax, BYTE PTR [rdi+54]

; 296  :         cv->pt_ptr->type = GetTyperef( sym, sym->Ofssize );

	movzx	edx, BYTE PTR [rdi+52]
	mov	QWORD PTR [rsp+56], rbx
	mov	ebx, DWORD PTR [rdi+44]
	mov	rcx, rdi
	mov	DWORD PTR [rdi+44], eax
	call	GetTyperef
	mov	rcx, QWORD PTR [rsi+16]
	mov	WORD PTR [rcx+6], ax

; 297  :         sym->mem_type = tmpmt;

	mov	DWORD PTR [rdi+44], ebx
	mov	rbx, QWORD PTR [rsp+56]
$LN1@cv_write_p:

; 298  :     }
; 299  :     *(uint_32 *)( cv->pt + sizeof( struct cv_typerec_pointer ) ) = 0; /* variant */

	mov	rax, QWORD PTR [rsi+16]
	mov	rdi, QWORD PTR [rsp+72]
	mov	DWORD PTR [rax+8], 0

; 300  :     DebugMsg(( "%u cv_write_ptr_type(%Xh, typeref=%X ): name=%s [memt=%X ptr_memt=%X target_type=%s] reftype=%X\n",
; 301  :               cv->level, GetPos(cv->types, cv->pt), cv->currtype, sym->name, sym->mem_type, sym->ptr_memtype, sym->target_type ? sym->target_type->name : "NULL", cv->pt_ptr->type ));
; 302  :     cv->pt += size;
; 303  :     return( cv->currtype++ );

	movzx	eax, WORD PTR [rsi+44]
	add	QWORD PTR [rsi+16], 12
	lea	ecx, DWORD PTR [rax+1]
	mov	WORD PTR [rsi+44], cx
	mov	rsi, QWORD PTR [rsp+64]

; 304  : }

	add	rsp, 40					; 00000028H
	ret	0
cv_write_ptr_type ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$cv_cntproc DD 030c01H
	DD	07340cH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$cv_cntproc DD @imagerel(cv_cntproc#)
	DD	@imagerel(cv_cntproc#+12)
	DD	@imagerel($unwind$cv_cntproc#)
pdata	ENDS
xdata	SEGMENT
$chain$2$cv_cntproc DD 040a21H
	DD	09740aH
	DD	086405H
	DD	@imagerel(cv_cntproc#)
	DD	@imagerel(cv_cntproc#+12)
	DD	@imagerel($unwind$cv_cntproc#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$cv_cntproc DD @imagerel(cv_cntproc#+12)
	DD	@imagerel(cv_cntproc#+257)
	DD	@imagerel($chain$2$cv_cntproc#)
pdata	ENDS
xdata	SEGMENT
$chain$3$cv_cntproc DD 020021H
	DD	097400H
	DD	@imagerel(cv_cntproc#)
	DD	@imagerel(cv_cntproc#+12)
	DD	@imagerel($unwind$cv_cntproc#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$cv_cntproc DD @imagerel(cv_cntproc#+257)
	DD	@imagerel(cv_cntproc#+297)
	DD	@imagerel($chain$3$cv_cntproc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
type$ = 48
mbr$ = 56
cv$ = 64
cc$ = 72
cv_cntproc PROC NEAR

; 326  : {

	sub	rsp, 40					; 00000028H

; 327  :     int      numsize;
; 328  :     uint_32  offset;
; 329  : 
; 330  :     cc->cnt++;

	inc	DWORD PTR [r9]
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, r8

; 331  :     offset = ( type->sym.typekind == TYPE_RECORD ? 0 : mbr->offset + cc->ofs );

	xor	r8d, r8d
	cmp	BYTE PTR [rcx+74], 4
	mov	rbx, rdx
	mov	rsi, rcx
	jne	SHORT $LN7@cv_cntproc
	mov	edx, r8d
	jmp	SHORT $LN8@cv_cntproc
$LN7@cv_cntproc:
	mov	edx, DWORD PTR [rdx+16]
	add	edx, DWORD PTR [r9+8]
$LN8@cv_cntproc:

; 332  :     numsize = ( offset >= LF_NUMERIC ? sizeof( uint_32 ) : 0 );
; 333  :     cc->size += ( sizeof( struct cv_typerec_member ) + numsize + mbr->name_size + 1 + 3 ) & ~3;

	movzx	eax, BYTE PTR [rbx+80]
	mov	ecx, 4
	cmp	edx, 32768				; 00008000H
	cmovae	r8d, ecx
	lea	eax, DWORD PTR [rax+r8+12]
	and	eax, -4					; fffffffcH
	add	DWORD PTR [r9+4], eax

; 334  : 
; 335  :     /* field cv_typeref can only be queried from SYM_TYPE items! */
; 336  : 
; 337  :     if ( mbr->mem_type == MT_TYPE && mbr->type->cvtyperef == 0 ) {

	mov	ecx, DWORD PTR [rbx+44]
	cmp	ecx, 196				; 000000c4H
	jne	SHORT $LN4@cv_cntproc
	mov	rax, QWORD PTR [rbx+88]
	cmp	WORD PTR [rax+72], 0
	jne	SHORT $LN4@cv_cntproc

; 338  :         cv->level++;

	inc	DWORD PTR [rdi+40]

; 339  :         cv_write_type( cv, mbr->type );

	mov	rdx, QWORD PTR [rbx+88]
	mov	rcx, rdi
	call	cv_write_type

; 340  :         cv->level--;

	add	DWORD PTR [rdi+40], -1			; ffffffffH
	jmp	SHORT $LN32@cv_cntproc
$LN4@cv_cntproc:

; 341  :     } else if ( mbr->mem_type == MT_BITS && mbr->cvtyperef == 0 ) {

	cmp	ecx, 193				; 000000c1H
	jne	SHORT $LN32@cv_cntproc
	cmp	WORD PTR [rbx+72], 0
	jne	SHORT $LN32@cv_cntproc

; 342  :         cv_write_bitfield( cv, type, mbr );

	mov	rcx, QWORD PTR [rdi+24]
	mov	r9, QWORD PTR [rdi+32]
	mov	rdx, QWORD PTR [rdi+16]
	mov	rax, QWORD PTR [rcx+104]
	mov	r8d, 8
	call	QWORD PTR [rax+32]
	xor	edx, edx
	mov	QWORD PTR [rdi+16], rax
	movzx	eax, WORD PTR [rdi+44]
	mov	WORD PTR [rbx+72], ax
	inc	WORD PTR [rdi+44]
	mov	rax, QWORD PTR [rdi+16]
	mov	WORD PTR [rax], 6
	mov	rax, QWORD PTR [rdi+16]
	mov	WORD PTR [rax+2], 518			; 00000206H
	mov	rcx, QWORD PTR [rdi+16]
	movzx	eax, BYTE PTR [rbx+64]
	mov	BYTE PTR [rcx+4], al
	mov	rcx, QWORD PTR [rdi+16]
	movzx	eax, BYTE PTR [rbx+16]
	mov	BYTE PTR [rcx+5], al
	mov	rcx, rsi
	call	GetTyperef
	mov	rcx, QWORD PTR [rdi+16]
	mov	WORD PTR [rcx+6], ax
	add	QWORD PTR [rdi+16], 8
$LN32@cv_cntproc:

; 343  :     }
; 344  :     //DebugMsg(( "%u cv_cntproc(%Xh, %u): struct=%s MEMBER=%s [memt=%X type=%s]\n", cv->level, GetPos(cv->types, cv->pt), cc->cnt++, type->sym.name, mbr->name, mbr->mem_type, mbr->type ? mbr->type->name : "NULL" ));
; 345  :     if ( mbr->isarray ) {

	test	BYTE PTR [rbx+49], 2
	mov	rsi, QWORD PTR [rsp+64]
	je	SHORT $LN1@cv_cntproc

; 346  :         /* temporarily (mis)use ext_idx1 member to store the type;
; 347  :          * this field usually isn't used by struct fields */
; 348  :         mbr->ext_idx1 = cv->currtype;

	movzx	eax, WORD PTR [rdi+44]

; 349  :         cv_write_array_type( cv, mbr, 0, USE16 );

	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, rbx
	mov	rcx, rdi
	mov	WORD PTR [rbx+96], ax
	call	cv_write_array_type
$LN1@cv_cntproc:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+56]

; 350  :     }
; 351  : }

	add	rsp, 40					; 00000028H
	ret	0
cv_cntproc ENDP
_TEXT	ENDS
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$cv_memberproc DD 030901H
	DD	083409H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$cv_memberproc DD @imagerel(cv_memberproc#)
	DD	@imagerel(cv_memberproc#+9)
	DD	@imagerel($unwind$cv_memberproc#)
pdata	ENDS
xdata	SEGMENT
$chain$2$cv_memberproc DD 040a21H
	DD	0b740aH
	DD	0a6405H
	DD	@imagerel(cv_memberproc#)
	DD	@imagerel(cv_memberproc#+9)
	DD	@imagerel($unwind$cv_memberproc#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$cv_memberproc DD @imagerel(cv_memberproc#+9)
	DD	@imagerel(cv_memberproc#+19)
	DD	@imagerel($chain$2$cv_memberproc#)
pdata	ENDS
xdata	SEGMENT
$chain$5$cv_memberproc DD 069521H
	DD	095495H
	DD	05d432H
	DD	06c405H
	DD	@imagerel(cv_memberproc#+9)
	DD	@imagerel(cv_memberproc#+19)
	DD	@imagerel($chain$2$cv_memberproc#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$cv_memberproc DD @imagerel(cv_memberproc#+19)
	DD	@imagerel(cv_memberproc#+239)
	DD	@imagerel($chain$5$cv_memberproc#)
pdata	ENDS
xdata	SEGMENT
$chain$6$cv_memberproc DD 040021H
	DD	05d400H
	DD	095400H
	DD	@imagerel(cv_memberproc#+9)
	DD	@imagerel(cv_memberproc#+19)
	DD	@imagerel($chain$2$cv_memberproc#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$cv_memberproc DD @imagerel(cv_memberproc#+239)
	DD	@imagerel(cv_memberproc#+331)
	DD	@imagerel($chain$6$cv_memberproc#)
pdata	ENDS
xdata	SEGMENT
$chain$7$cv_memberproc DD 020021H
	DD	05d400H
	DD	@imagerel(cv_memberproc#)
	DD	@imagerel(cv_memberproc#+9)
	DD	@imagerel($unwind$cv_memberproc#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$cv_memberproc DD @imagerel(cv_memberproc#+331)
	DD	@imagerel(cv_memberproc#+401)
	DD	@imagerel($chain$7$cv_memberproc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
type$ = 64
mbr$ = 72
cv$ = 80
cc$ = 88
cv_memberproc PROC NEAR

; 359  : {

	sub	rsp, 56					; 00000038H
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+88], rdi
	mov	QWORD PTR [rsp+48], r12

; 360  :     uint_32     offset;
; 361  :     int         typelen;
; 362  :     int         size;
; 363  :     uint_8      *tmp;
; 364  : 
; 365  :     offset = ( type->sym.typekind == TYPE_RECORD ? 0 : mbr->offset + cc->ofs );

	xor	r12d, r12d
	cmp	BYTE PTR [rcx+74], 4
	mov	rbx, r8
	mov	rsi, rdx
	jne	SHORT $LN7@cv_memberp
	mov	edi, r12d
	jmp	SHORT $LN8@cv_memberp
$LN7@cv_memberp:
	mov	edi, DWORD PTR [rdx+16]
	add	edi, DWORD PTR [r9+8]
$LN8@cv_memberp:

; 366  :     typelen = ( offset >= LF_NUMERIC ? sizeof( uint_32 ) : 0 );
; 367  :     size = ( sizeof( struct cv_typerec_member ) + typelen + 1 + mbr->name_size + 3 ) & ~3;
; 368  :     cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	mov	rcx, QWORD PTR [r8+24]
	mov	r9, QWORD PTR [r8+32]
	mov	eax, 4
	mov	QWORD PTR [rsp+40], r13
	cmp	edi, 32768				; 00008000H
	cmovae	r12d, eax
	movzx	eax, BYTE PTR [rdx+80]
	mov	rdx, QWORD PTR [rbx+16]
	lea	r13d, DWORD PTR [rax+r12+12]
	mov	rax, QWORD PTR [rcx+104]
	and	r13d, -4
	mov	r8d, r13d
	call	QWORD PTR [rax+32]
	mov	QWORD PTR [rbx+16], rax

; 369  :     cv->pt_mbr->leaf = LF_MEMBER;

	mov	WORD PTR [rax], 1030			; 00000406H

; 370  :     if ( mbr->isarray ) {

	test	BYTE PTR [rsi+49], 2
	je	SHORT $LN4@cv_memberp

; 371  :         cv->pt_mbr->type = mbr->ext_idx1;

	mov	rcx, QWORD PTR [rbx+16]
	movzx	eax, WORD PTR [rsi+96]
	mov	WORD PTR [rcx+2], ax

; 372  :         mbr->ext_idx1 = 0; /* reset the temporarily used field */

	mov	WORD PTR [rsi+96], 0

; 373  :     } else

	jmp	SHORT $LN3@cv_memberp
$LN4@cv_memberp:

; 374  :         cv->pt_mbr->type = GetTyperef( mbr, USE16 );

	xor	edx, edx
	mov	rcx, rsi
	call	GetTyperef
	mov	rcx, QWORD PTR [rbx+16]
	mov	WORD PTR [rcx+2], ax
$LN3@cv_memberp:

; 375  : 
; 376  :     cv->pt_mbr->attribute.access = CV_ATTR_ACC_PUBLIC;

	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [rsp+72], rbp
	or	WORD PTR [rax+4], 3

; 377  :     cv->pt_mbr->attribute.mprop = CV_ATTR_MPR_VANILLA;

	mov	rax, QWORD PTR [rbx+16]
	and	WORD PTR [rax+4], 65507			; 0000ffe3H

; 378  :     cv->pt_mbr->attribute.pseudo = 0;

	mov	rax, QWORD PTR [rbx+16]
	and	WORD PTR [rax+4], 65503			; 0000ffdfH

; 379  :     cv->pt_mbr->attribute.noinherit = 0;

	mov	rax, QWORD PTR [rbx+16]
	and	WORD PTR [rax+4], 65471			; 0000ffbfH

; 380  :     cv->pt_mbr->attribute.noconstruct = 0;

	mov	rax, QWORD PTR [rbx+16]
	and	WORD PTR [rax+4], 65407			; 0000ff7fH

; 381  :     cv->pt_mbr->attribute.reserved = 0;

	mov	rax, QWORD PTR [rbx+16]

; 382  :     tmp = cv->pt + sizeof( struct cv_typerec_member );
; 383  :     if ( typelen == 0 ) {

	test	r12d, r12d
	mov	r12, QWORD PTR [rsp+48]
	mov	BYTE PTR [rax+5], 0
	mov	rax, QWORD PTR [rbx+16]
	lea	rbp, QWORD PTR [rax+8]
	jne	SHORT $LN2@cv_memberp

; 384  :         cv->pt_mbr->offset = offset;

	mov	WORD PTR [rax+6], di

; 385  :     } else {

	jmp	SHORT $LN1@cv_memberp
$LN2@cv_memberp:

; 386  :         cv->pt_mbr->offset = LF_ULONG;

	mov	WORD PTR [rax+6], 32772			; 00008004H

; 387  :         *(uint_32 *)tmp = offset;

	mov	DWORD PTR [rbp], edi

; 388  :         tmp += sizeof( uint_32 );

	add	rbp, 4
$LN1@cv_memberp:

; 389  :     }
; 390  :     DebugMsg(( "%u cv_memberproc(%Xh, %u): struct=%s MEMBER=%s [memt=%X], typeref=%X\n", cv->level, GetPos(cv->types, cv->pt), cc->cnt++, type->sym.name, mbr->name, mbr->mem_type, cv->pt_mbr->type ));
; 391  :     SetPrefixName( tmp, mbr->name, mbr->name_size );

	movzx	eax, BYTE PTR [rsi+80]
	inc	rbp
	mov	BYTE PTR [rbp-1], al
	movzx	r8d, BYTE PTR [rsi+80]
	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, rbp
	call	memcpy

; 392  :     PadBytes( tmp, cv->types->e.seginfo->CodeBuffer );

	movzx	r11d, BYTE PTR [rsi+80]
	mov	rax, QWORD PTR [rbx+24]
	mov	rcx, QWORD PTR [rax+104]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+80]
	add	r11, rbp
	mov	rbp, QWORD PTR [rsp+72]
	mov	rdx, r11
	sub	rdx, QWORD PTR [rcx+16]
	mov	rcx, rdx
	and	ecx, 3
	je	SHORT $LN15@cv_memberp

; 389  :     }
; 390  :     DebugMsg(( "%u cv_memberproc(%Xh, %u): struct=%s MEMBER=%s [memt=%X], typeref=%X\n", cv->level, GetPos(cv->types, cv->pt), cc->cnt++, type->sym.name, mbr->name, mbr->mem_type, cv->pt_mbr->type ));
; 391  :     SetPrefixName( tmp, mbr->name, mbr->name_size );

	lea	r8, OFFSET FLAT:?padtab@?1??PadBytes@@9@9+3
	npad	14

; 392  :     PadBytes( tmp, cv->types->e.seginfo->CodeBuffer );

$LL10@cv_memberp:
	inc	rdx
	mov	rax, r8
	inc	r11
	sub	rax, rcx
	mov	rcx, rdx
	and	ecx, 3
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [r11-1], al
	jne	SHORT $LL10@cv_memberp
$LN15@cv_memberp:

; 393  :     cv->pt += size;

	movsxd	rax, r13d
	mov	r13, QWORD PTR [rsp+40]
	add	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+64]

; 394  :     return;
; 395  : }

	add	rsp, 56					; 00000038H
	ret	0
cv_memberproc ENDP
_TEXT	ENDS
EXTRN	sprintf:NEAR
xdata	SEGMENT
$unwind$cv_enum_fields DD 072101H
	DD	077421H
	DD	08641cH
	DD	095417H
	DD	0a20eH
xdata	ENDS
pdata	SEGMENT
$pdata$cv_enum_fields DD @imagerel(cv_enum_fields#)
	DD	@imagerel(cv_enum_fields#+60)
	DD	@imagerel($unwind$cv_enum_fields#)
pdata	ENDS
xdata	SEGMENT
$chain$3$cv_enum_fields DD 020521H
	DD	0a3405H
	DD	@imagerel(cv_enum_fields#)
	DD	@imagerel(cv_enum_fields#+60)
	DD	@imagerel($unwind$cv_enum_fields#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$cv_enum_fields DD @imagerel(cv_enum_fields#+60)
	DD	@imagerel(cv_enum_fields#+260)
	DD	@imagerel($chain$3$cv_enum_fields#)
pdata	ENDS
xdata	SEGMENT
$chain$4$cv_enum_fields DD 021H
	DD	@imagerel(cv_enum_fields#)
	DD	@imagerel(cv_enum_fields#+60)
	DD	@imagerel($unwind$cv_enum_fields#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$cv_enum_fields DD @imagerel(cv_enum_fields#+260)
	DD	@imagerel(cv_enum_fields#+280)
	DD	@imagerel($chain$4$cv_enum_fields#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
tmpname$5978 = 32
i$1$ = 96
sym$ = 96
enumfunc$ = 104
cv$ = 112
cc$ = 120
cv_enum_fields PROC NEAR

; 408  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	sub	rsp, 88					; 00000058H

; 409  :     unsigned i;
; 410  :     struct sfield  *curr;
; 411  :     for ( curr = sym->e.structinfo->head, i = 0; curr; curr = curr->next ) {

	mov	rax, QWORD PTR [rcx+104]
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+56], rdi
	mov	rdi, QWORD PTR [rax]
	xor	eax, eax
	test	rdi, rdi
	mov	rsi, r9
	mov	r10, rdx
	mov	rbp, rcx
	mov	DWORD PTR i$1$[rsp], eax
	je	$LN6@cv_enum_fi
	mov	QWORD PTR [rsp+80], rbx
$LL8@cv_enum_fi:

; 412  :         if ( curr->sym.name_size ) { /* has member a name? */

	cmp	BYTE PTR [rdi+80], 0
	je	SHORT $LN5@cv_enum_fi

; 413  :             enumfunc( sym, &curr->sym, cv, cc );

	mov	r9, rsi
	mov	rdx, rdi
	mov	rcx, rbp
	call	r10
	mov	r8, QWORD PTR cv$[rsp]
	mov	r10, QWORD PTR enumfunc$[rsp]
	mov	eax, DWORD PTR i$1$[rsp]
	jmp	$LN7@cv_enum_fi
$LN5@cv_enum_fi:

; 414  :         } else if ( curr->sym.type ) { /* is member a type (struct, union, record)? */

	cmp	QWORD PTR [rdi+88], 0
	je	SHORT $LN3@cv_enum_fi

; 415  :             cc->ofs += curr->sym.offset;

	mov	eax, DWORD PTR [rdi+16]

; 416  :             cv_enum_fields( (struct dsym *)curr->sym.type, enumfunc, cv, cc );

	mov	r9, rsi
	mov	rdx, r10
	add	DWORD PTR [rsi+8], eax
	mov	rcx, QWORD PTR [rdi+88]
	call	cv_enum_fields

; 417  :             cc->ofs -= curr->sym.offset;

	mov	r11d, DWORD PTR [rdi+16]
	mov	r8, QWORD PTR cv$[rsp]
	sub	DWORD PTR [rsi+8], r11d
	mov	r10, QWORD PTR enumfunc$[rsp]
	mov	eax, DWORD PTR i$1$[rsp]
	jmp	SHORT $LN7@cv_enum_fi
$LN3@cv_enum_fi:

; 418  :         } else if ( sym->sym.typekind == TYPE_UNION ) {

	cmp	BYTE PTR [rbp+74], 2
	jne	SHORT $LN7@cv_enum_fi

; 419  :             /* v2.11: include anonymous union members.
; 420  :              * to make the MS debugger work with those members, they must have a name -
; 421  :              * a temporary name is generated below which starts with "@@".
; 422  :              */
; 423  :             char *pold = curr->sym.name;

	mov	rbx, QWORD PTR [rdi+8]

; 424  :             char tmpname[8];
; 425  :             curr->sym.name_size = sprintf( tmpname, "@@%u", ++i );

	inc	eax
	lea	rdx, OFFSET FLAT:$SG5979
	lea	rcx, QWORD PTR tmpname$5978[rsp]
	mov	r8d, eax
	mov	DWORD PTR i$1$[rsp], eax
	call	sprintf

; 426  :             curr->sym.name = tmpname;
; 427  :             enumfunc( sym, &curr->sym, cv, cc );

	mov	r8, QWORD PTR cv$[rsp]
	mov	r9, rsi
	mov	BYTE PTR [rdi+80], al
	lea	rax, QWORD PTR tmpname$5978[rsp]
	mov	rdx, rdi
	mov	rcx, rbp
	mov	QWORD PTR [rdi+8], rax
	call	QWORD PTR enumfunc$[rsp]
	mov	r8, QWORD PTR cv$[rsp]
	mov	r10, QWORD PTR enumfunc$[rsp]
	mov	eax, DWORD PTR i$1$[rsp]

; 428  :             curr->sym.name = pold;

	mov	QWORD PTR [rdi+8], rbx

; 429  :             curr->sym.name_size = 0;

	mov	BYTE PTR [rdi+80], 0
$LN7@cv_enum_fi:
	mov	rdi, QWORD PTR [rdi+104]
	test	rdi, rdi
	jne	$LL8@cv_enum_fi
	mov	rbx, QWORD PTR [rsp+80]
$LN6@cv_enum_fi:
	mov	rdi, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]

; 430  :         }
; 431  :     }
; 432  :     return;
; 433  : }

	add	rsp, 88					; 00000058H
	ret	0
cv_enum_fields ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$cv_write_type_procedure DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$cv_write_type_procedure DD @imagerel(cv_write_type_procedure#)
	DD	@imagerel(cv_write_type_procedure#+4)
	DD	@imagerel($unwind$cv_write_type_procedure#)
pdata	ENDS
xdata	SEGMENT
$chain$3$cv_write_type_procedure DD 082621H
	DD	097426H
	DD	08640fH
	DD	07540aH
	DD	063405H
	DD	@imagerel(cv_write_type_procedure#)
	DD	@imagerel(cv_write_type_procedure#+4)
	DD	@imagerel($unwind$cv_write_type_procedure#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$cv_write_type_procedure DD @imagerel(cv_write_type_procedure#+4)
	DD	@imagerel(cv_write_type_procedure#+224)
	DD	@imagerel($chain$3$cv_write_type_procedure#)
pdata	ENDS
xdata	SEGMENT
$chain$4$cv_write_type_procedure DD 040021H
	DD	086400H
	DD	075400H
	DD	@imagerel(cv_write_type_procedure#)
	DD	@imagerel(cv_write_type_procedure#+4)
	DD	@imagerel($unwind$cv_write_type_procedure#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$cv_write_type_procedure DD @imagerel(cv_write_type_procedure#+224)
	DD	@imagerel(cv_write_type_procedure#+271)
	DD	@imagerel($chain$4$cv_write_type_procedure#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
cv$ = 48
sym$ = 56
cnt$ = 64
cv_write_type_procedure PROC NEAR

; 439  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, rcx

; 440  :     int         size;
; 441  :     cv_typeref  *ptr;
; 442  :     struct dsym *param;
; 443  : 
; 444  :     size = sizeof( struct cv_typerec_procedure );
; 445  :     cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	mov	rcx, QWORD PTR [rcx+24]
	mov	ebx, r8d
	mov	rax, QWORD PTR [rcx+104]
	mov	r9, QWORD PTR [rsi+32]
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rdx
	mov	rdx, QWORD PTR [rsi+16]
	mov	r8d, 12
	call	QWORD PTR [rax+32]

; 446  :     cv->pt_pr->tr.size = size - sizeof(uint_16);
; 447  :     cv->pt_pr->tr.leaf = LF_PROCEDURE;
; 448  :     cv->pt_pr->rvtype = cv_void.uvalue;
; 449  :     cv->pt_pr->call = 0;
; 450  :     cv->pt_pr->rsvd = 0;
; 451  :     cv->pt_pr->numparams = cnt;
; 452  :     cv->pt_pr->arglist = ++cv->currtype;
; 453  :     cv->pt += size;
; 454  :     size = sizeof( struct cv_typerec_arglist ) + cnt * sizeof( cv_typeref );

	lea	ebp, DWORD PTR [rbx+rbx+6]
	mov	QWORD PTR [rsi+16], rax
	mov	WORD PTR [rax], 10
	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+2], 8
	mov	rax, QWORD PTR [rsi+16]

; 455  :     cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	mov	r8d, ebp
	mov	WORD PTR [rax+4], 3
	mov	rax, QWORD PTR [rsi+16]
	mov	BYTE PTR [rax+6], 0
	mov	rax, QWORD PTR [rsi+16]
	mov	BYTE PTR [rax+7], 0
	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+8], bx
	inc	WORD PTR [rsi+44]
	mov	rax, QWORD PTR [rsi+16]
	movzx	ecx, WORD PTR [rsi+44]
	mov	WORD PTR [rax+10], cx
	add	QWORD PTR [rsi+16], 12
	mov	rcx, QWORD PTR [rsi+24]
	mov	rax, QWORD PTR [rcx+104]
	mov	r9, QWORD PTR [rsi+32]
	mov	rdx, QWORD PTR [rsi+16]
	call	QWORD PTR [rax+32]

; 456  :     cv->pt_al->tr.size = size - sizeof(uint_16);

	lea	ecx, DWORD PTR [rbp-2]
	mov	QWORD PTR [rsi+16], rax
	mov	WORD PTR [rax], cx

; 457  :     cv->pt_al->tr.leaf = LF_ARGLIST;

	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+2], 513			; 00000201H

; 458  :     cv->pt_al->argcount = cnt;

	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+4], bx

; 459  :     ptr = (cv_typeref *)(cv->pt + sizeof( struct cv_typerec_arglist ) );
; 460  :     /* fixme: order might be wrong ( is "push" order ) */
; 461  :     for ( param = ((struct dsym *)sym)->e.procinfo->paralist; param; param = param->nextparam ) {

	mov	rax, QWORD PTR [rdi+104]
	mov	rdx, QWORD PTR [rsi+16]
	mov	rcx, QWORD PTR [rax+8]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+48]
	add	rdx, 6
	test	rcx, rcx
	je	SHORT $LN1@cv_write_t
	npad	7
$LL3@cv_write_t:

; 462  :         *ptr++ = param->sym.ext_idx1;

	movzx	eax, WORD PTR [rcx+96]
	add	rdx, 2
	mov	WORD PTR [rdx-2], ax
	mov	rcx, QWORD PTR [rcx+120]
	test	rcx, rcx
	jne	SHORT $LL3@cv_write_t
$LN1@cv_write_t:

; 463  :     }
; 464  :     cv->pt += size;

	movsxd	rax, ebp
	mov	rbp, QWORD PTR [rsp+56]
	add	QWORD PTR [rsi+16], rax

; 465  :     cv->currtype++;

	inc	WORD PTR [rsi+44]
	mov	rsi, QWORD PTR [rsp+64]

; 466  :     return;
; 467  : }

	add	rsp, 40					; 00000028H
	ret	0
cv_write_type_procedure ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$cv_write_type DD 051201H
	DD	0d7412H
	DD	0c640dH
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$cv_write_type DD @imagerel(cv_write_type#)
	DD	@imagerel(cv_write_type#+121)
	DD	@imagerel($unwind$cv_write_type#)
pdata	ENDS
xdata	SEGMENT
$chain$3$cv_write_type DD 040f21H
	DD	0b540fH
	DD	0a3405H
	DD	@imagerel(cv_write_type#)
	DD	@imagerel(cv_write_type#+121)
	DD	@imagerel($unwind$cv_write_type#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$cv_write_type DD @imagerel(cv_write_type#+121)
	DD	@imagerel(cv_write_type#+609)
	DD	@imagerel($chain$3$cv_write_type#)
pdata	ENDS
xdata	SEGMENT
$chain$4$cv_write_type DD 021H
	DD	@imagerel(cv_write_type#)
	DD	@imagerel(cv_write_type#+121)
	DD	@imagerel($unwind$cv_write_type#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$cv_write_type DD @imagerel(cv_write_type#+609)
	DD	@imagerel(cv_write_type#+762)
	DD	@imagerel($chain$4$cv_write_type#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
size$1$ = 32
namesize$1$ = 36
typelen$1$ = 40
tmp$ = 40
size$ = 40
count$ = 48
cv$ = 80
sym$ = 88
cv_write_type PROC NEAR

; 475  : {

	sub	rsp, 72					; 00000048H

; 476  :     struct dsym *type = (struct dsym *)sym;
; 477  :     uint_8      *tmp;
; 478  :     int         namesize;
; 479  :     int         typelen;
; 480  :     int         size;
; 481  :     uint_16     property;
; 482  :     struct cv_counters count;
; 483  : 
; 484  :     /* v2.10: handle typedefs. when the types are enumerated,
; 485  :      * typedefs are ignored.
; 486  :      */
; 487  :     if ( sym->typekind == TYPE_TYPEDEF ) {

	movzx	eax, BYTE PTR [rdx+74]
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+104], rdi
	cmp	al, 3
	mov	rdi, rdx
	mov	rsi, rcx
	jne	SHORT $LN13@cv_write_t@2

; 488  :         //if ( sym->is_ptr ) {
; 489  :         if ( sym->mem_type == MT_PTR ) {

	cmp	DWORD PTR [rdx+44], 195			; 000000c3H
	jne	$LN14@cv_write_t@2

; 490  : #if GENPTRTYPE
; 491  :             /* for untyped void pointers use ONE generic definition */
; 492  :             if ( !sym->isfar ) {
; 493  :                 if ( cv->ptrtype[sym->Ofssize] ) {
; 494  :                     sym->cv_typeref = cv->ptrtype[sym->Ofssize];
; 495  :                     return;
; 496  :                 }
; 497  :                 cv->ptrtype[sym->Ofssize] = cv->currtype;
; 498  :             }
; 499  : #endif
; 500  : #if 1
; 501  :             if ( sym->ptr_memtype != MT_PROC && sym->target_type && sym->target_type->cvtyperef == 0 ) {

	cmp	BYTE PTR [rdx+54], 128			; 00000080H
	je	SHORT $LN10@cv_write_t@2
	mov	rdx, QWORD PTR [rdx+56]
	test	rdx, rdx
	je	SHORT $LN10@cv_write_t@2
	cmp	WORD PTR [rdx+72], 0
	jne	SHORT $LN10@cv_write_t@2

; 502  :                 DebugMsg(( "%u cv_write_type(%Xh): TYPEDEF=%s target type=%s [kind=%u memt=%X] not defined yet\n",
; 503  :                           cv->level, GetPos(cv->types, cv->pt), sym->name, sym->target_type->name, sym->target_type->typekind, sym->target_type->mem_type ));
; 504  :                 //cv->level++;
; 505  :                 //sym->cv_typeref = GetTyperef( sym, sym->Ofssize ); /* to avoid circular references! */
; 506  :                 if ( cv->level == 0 ) /* avoid circles */

	cmp	DWORD PTR [rcx+40], 0
	jne	SHORT $LN10@cv_write_t@2

; 507  :                     cv_write_type( cv, sym->target_type );

	call	cv_write_type
$LN10@cv_write_t@2:

; 508  :                 //cv->level--;
; 509  :             }
; 510  :             sym->cvtyperef = cv_write_ptr_type( cv, sym );

	mov	rdx, rdi
	mov	rcx, rsi
	call	cv_write_ptr_type
	mov	WORD PTR [rdi+72], ax
	mov	rdi, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+96]

; 605  :     return;
; 606  : }

	add	rsp, 72					; 00000048H
	ret	0
$LN13@cv_write_t@2:

; 511  :             DebugMsg(( "%u cv_write_type(%Xh): TYPEDEF=%s typeref=%X\n", cv->level, GetPos(cv->types, cv->pt), sym->name, sym->cvtyperef ));
; 512  : #else
; 513  :             sym->cv_typeref = cv->currtype++;
; 514  :             size = ( sizeof( struct cv_typerec_pointer ) + sizeof( uint_32 ) );
; 515  :             cv->pt = checkflush( cv->types, cv->pt, size );
; 516  :             cv->pt_ptr->tr.size = size - sizeof(uint_16);
; 517  :             cv->pt_ptr->tr.leaf = LF_POINTER;
; 518  :             if ( sym->Ofssize == USE16 ) {
; 519  :                 cv->pt_ptr->attribute = ( sym->isfar ? CV_TYPE_POINTER_FAR : CV_TYPE_POINTER_NEAR );
; 520  :             } else {
; 521  :                 cv->pt_ptr->attribute = ( sym->isfar ? CV_TYPE_POINTER_FAR32 : CV_TYPE_POINTER_NEAR32 );
; 522  :             }
; 523  :             cv->pt_ptr->pptype = cv_pvoid.s;
; 524  :             *(uint_32 *)( cv->pt + sizeof( struct cv_typerec_pointer ) ) = 0; /* variant */
; 525  :             DebugMsg(( "%u cv_write_type(%Xh, ref=%X): POINTER, attr=%X\n", cv->level, GetPos(cv->types, cv->pt), cv->currtype-1, cv->pt_ptr->attribute ));
; 526  :             cv->pt += size;
; 527  : #endif
; 528  :         }
; 529  :         return;
; 530  :     } else if ( sym->typekind == TYPE_NONE ) {

	test	al, al
	je	$LN14@cv_write_t@2

; 531  :         DebugMsg(( "cv_write_type: %s has typekind=TYPE_NONE, ignored!\n", sym->name ));
; 532  :         return;
; 533  :     }
; 534  : 
; 535  :     typelen = ( sym->total_size >= LF_NUMERIC ? sizeof( uint_32 ) : 0 );

	xor	ecx, ecx
	cmp	DWORD PTR [rdx+64], 32768		; 00008000H
	mov	QWORD PTR [rsp+80], rbx
	mov	eax, 4
	mov	QWORD PTR [rsp+88], rbp
	mov	ebp, ecx
	cmovae	ebp, eax

; 536  : 
; 537  :     property = ( cv->level ? CVTSP_ISNESTED : 0 );

	mov	eax, DWORD PTR [rsi+40]

; 538  : 
; 539  :     /* Count the member fields. If a member's type is unknown, create it! */
; 540  :     count.cnt = 0;

	mov	DWORD PTR count$[rsp], ecx
	neg	eax

; 541  :     count.size = 0;

	mov	DWORD PTR count$[rsp+4], ecx

; 542  :     count.ofs = 0;

	mov	DWORD PTR count$[rsp+8], ecx
	sbb	bx, bx

; 543  :     cv_enum_fields( type, cv_cntproc, cv, &count );

	lea	r9, QWORD PTR count$[rsp]
	lea	rdx, OFFSET FLAT:cv_cntproc
	mov	r8, rsi
	mov	rcx, rdi
	mov	DWORD PTR typelen$1$[rsp], ebp
	and	bx, 8
	call	cv_enum_fields

; 544  : 
; 545  :     /* WinDbg wants embedded structs to have a name - else it won't allow to "open" it. */
; 546  :     namesize = ( sym->name_size ? sym->name_size : 9 );  /* 9 is sizeof("__unnamed") */

	movzx	eax, BYTE PTR [rdi+80]
	test	al, al
	je	SHORT $LN16@cv_write_t@2
	movzx	edx, al
	mov	DWORD PTR namesize$1$[rsp], edx
	jmp	SHORT $LN17@cv_write_t@2
$LN16@cv_write_t@2:
	mov	edx, 9
	mov	DWORD PTR namesize$1$[rsp], edx
$LN17@cv_write_t@2:

; 547  : 
; 548  :     sym->cvtyperef = cv->currtype++;

	movzx	eax, WORD PTR [rsi+44]
	mov	WORD PTR [rdi+72], ax
	inc	WORD PTR [rsi+44]

; 549  :     switch ( type->sym.typekind ) {

	movzx	ecx, BYTE PTR [rdi+74]
	dec	ecx
	je	SHORT $LN3@cv_write_t@2
	dec	ecx
	je	$LN5@cv_write_t@2
	cmp	ecx, 2
	jne	$LN26@cv_write_t@2

; 561  :     case TYPE_RECORD:
; 562  :         property |= CVTSP_PACKED; /* is "packed" */

	or	bx, 1
$LN3@cv_write_t@2:

; 563  :         /* no break */
; 564  :     case TYPE_STRUCT:
; 565  :         DebugMsg(( "%u cv_write_type(%Xh, ref=%X): STRUCT=%s\n", cv->level, GetPos(cv->types, cv->pt), sym->cvtyperef, sym->name ));
; 566  :         size = ( sizeof( struct cv_typerec_structure ) + typelen + 1 + namesize + 3 ) & ~3;
; 567  :         cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	mov	rcx, QWORD PTR [rsi+24]
	mov	r9, QWORD PTR [rsi+32]
	lea	ebp, DWORD PTR [rdx+rbp+20]
	mov	rax, QWORD PTR [rcx+104]
	mov	rdx, QWORD PTR [rsi+16]
	and	ebp, -4
	mov	r8d, ebp
	mov	DWORD PTR size$1$[rsp], ebp
	call	QWORD PTR [rax+32]

; 568  :         cv->pt_st->tr.size = size - sizeof(uint_16);

	lea	ecx, DWORD PTR [rbp-2]
	mov	QWORD PTR [rsi+16], rax
	mov	WORD PTR [rax], cx

; 569  :         cv->pt_st->tr.leaf = LF_STRUCTURE;

	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+2], 5

; 570  :         cv->pt_st->count = count.cnt;

	movzx	eax, WORD PTR count$[rsp]
	mov	rcx, QWORD PTR [rsi+16]
	mov	WORD PTR [rcx+4], ax

; 571  :         cv->pt_st->field = cv->currtype++;

	movzx	eax, WORD PTR [rsi+44]
	mov	rcx, QWORD PTR [rsi+16]
	mov	WORD PTR [rcx+6], ax

; 572  :         cv->pt_st->property = property;

	mov	rax, QWORD PTR [rsi+16]
	inc	WORD PTR [rsi+44]
	mov	WORD PTR [rax+8], bx

; 573  :         cv->pt_st->dList = 0;

	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+10], 0

; 574  :         cv->pt_st->vshape = 0;

	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+12], 0

; 575  :         tmp = (uint_8 *)&cv->pt_st->length;

	mov	rbp, QWORD PTR [rsi+16]
	add	rbp, 14
	jmp	SHORT $LN6@cv_write_t@2
$LN5@cv_write_t@2:

; 550  :     case TYPE_UNION:
; 551  :         DebugMsg(( "%u cv_write_type(%Xh, ref=%X): UNION=%s\n", cv->level, GetPos(cv->types, cv->pt), sym->cvtyperef, sym->name ));
; 552  :         size = ( sizeof( struct cv_typerec_union ) + typelen + 1 + namesize + 3 ) & ~3;
; 553  :         cv->pt = checkflush( cv->types, cv->pt, size, cv->param );

	mov	rcx, QWORD PTR [rsi+24]
	mov	r9, QWORD PTR [rsi+32]
	lea	ebp, DWORD PTR [rdx+rbp+16]
	mov	rax, QWORD PTR [rcx+104]
	mov	rdx, QWORD PTR [rsi+16]
	and	ebp, -4
	mov	r8d, ebp
	mov	DWORD PTR size$1$[rsp], ebp
	call	QWORD PTR [rax+32]

; 554  :         cv->pt_un->tr.size = size - sizeof(uint_16);

	lea	ecx, DWORD PTR [rbp-2]
	mov	QWORD PTR [rsi+16], rax
	mov	WORD PTR [rax], cx

; 555  :         cv->pt_un->tr.leaf = LF_UNION;

	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+2], 6

; 556  :         cv->pt_un->count = count.cnt;

	movzx	eax, WORD PTR count$[rsp]
	mov	rcx, QWORD PTR [rsi+16]
	mov	WORD PTR [rcx+4], ax

; 557  :         cv->pt_un->field = cv->currtype++;

	movzx	eax, WORD PTR [rsi+44]
	mov	rcx, QWORD PTR [rsi+16]
	mov	WORD PTR [rcx+6], ax
	inc	WORD PTR [rsi+44]

; 558  :         cv->pt_un->property = property;

	mov	rax, QWORD PTR [rsi+16]
	mov	WORD PTR [rax+8], bx

; 559  :         tmp = (uint_8 *)&cv->pt_un->length;

	mov	rbp, QWORD PTR [rsi+16]
	add	rbp, 10

; 560  :         break;

	jmp	SHORT $LN6@cv_write_t@2
$LN26@cv_write_t@2:

; 575  :         tmp = (uint_8 *)&cv->pt_st->length;

	mov	eax, DWORD PTR size$[rsp]
	mov	rbp, QWORD PTR tmp$[rsp]
	mov	DWORD PTR size$1$[rsp], eax
$LN6@cv_write_t@2:

; 576  :         break;
; 577  :     }
; 578  :     if ( typelen ) {

	cmp	DWORD PTR typelen$1$[rsp], 0
	je	SHORT $LN2@cv_write_t@2

; 579  :         ((struct leaf32 *)tmp)->leaf = LF_ULONG;

	mov	WORD PTR [rbp], 32772			; 00008004H

; 580  :         ((struct leaf32 *)tmp)->value32 = sym->total_size;

	mov	eax, DWORD PTR [rdi+64]

; 581  :         tmp += sizeof( struct leaf32 );

	add	rbp, 8
	mov	DWORD PTR [rbp-4], eax

; 582  :     } else {

	jmp	SHORT $LN1@cv_write_t@2
$LN2@cv_write_t@2:

; 583  :         *(uint_16 *)tmp = sym->total_size;

	movzx	eax, WORD PTR [rdi+64]

; 584  :         tmp += sizeof( uint_16 );

	add	rbp, 2
	mov	WORD PTR [rbp-2], ax
$LN1@cv_write_t@2:

; 585  :     }
; 586  :     SetPrefixName( tmp, sym->name_size ? sym->name : "__unnamed", namesize );

	movsxd	rax, DWORD PTR namesize$1$[rsp]
	mov	BYTE PTR [rbp], al
	cmp	BYTE PTR [rdi+80], 0
	je	SHORT $LN18@cv_write_t@2
	mov	rdx, QWORD PTR [rdi+8]
	jmp	SHORT $LN19@cv_write_t@2
$LN18@cv_write_t@2:
	lea	rdx, OFFSET FLAT:$SG6042
$LN19@cv_write_t@2:
	lea	rcx, QWORD PTR [rbp+1]
	mov	r8, rax
	mov	rbx, rax
	call	memcpy

; 587  : 
; 588  :     PadBytes( tmp, cv->types->e.seginfo->CodeBuffer );

	mov	rax, QWORD PTR [rsi+24]
	lea	r11, QWORD PTR [rbx+rbp+1]
	mov	rcx, QWORD PTR [rax+104]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]
	mov	rdx, r11
	sub	rdx, QWORD PTR [rcx+16]
	mov	rcx, rdx
	and	ecx, 3
	je	SHORT $LN20@cv_write_t@2

; 585  :     }
; 586  :     SetPrefixName( tmp, sym->name_size ? sym->name : "__unnamed", namesize );

	lea	r9, OFFSET FLAT:?padtab@?1??PadBytes@@9@9+3
	npad	8

; 587  : 
; 588  :     PadBytes( tmp, cv->types->e.seginfo->CodeBuffer );

$LL21@cv_write_t@2:
	inc	rdx
	mov	rax, r9
	inc	r11
	sub	rax, rcx
	mov	rcx, rdx
	and	ecx, 3
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [r11-1], al
	jne	SHORT $LL21@cv_write_t@2
$LN20@cv_write_t@2:

; 589  :     cv->pt += size;

	movsxd	rax, DWORD PTR size$1$[rsp]

; 590  : 
; 591  :     /* write the fieldlist record */
; 592  :     cv->pt = checkflush( cv->types, cv->pt, sizeof( struct cv_typerec_fieldlist ), cv->param );

	mov	rcx, QWORD PTR [rsi+24]
	mov	r9, QWORD PTR [rsi+32]
	add	QWORD PTR [rsi+16], rax
	mov	rax, QWORD PTR [rcx+104]
	mov	rdx, QWORD PTR [rsi+16]
	mov	r8d, 4
	call	QWORD PTR [rax+32]

; 593  :     size = sizeof( struct cv_typerec_fieldlist) + count.size;
; 594  :     cv->pt_fl->tr.size = size - sizeof(uint_16);

	movzx	ecx, WORD PTR count$[rsp+4]

; 595  :     cv->pt_fl->tr.leaf = LF_FIELDLIST;
; 596  :     DebugMsg(( "%u cv_write_type(%Xh, ref=%X): FIELDLIST, size=%u\n", cv->level, GetPos(cv->types, cv->pt), cv->currtype-1, size ));
; 597  :     cv->pt += sizeof( struct cv_typerec_fieldlist );
; 598  : 
; 599  :     /* add the struct's members to the fieldlist. */
; 600  :     count.ofs = 0;
; 601  : #ifdef DEBUG_OUT
; 602  :     count.cnt = 0;
; 603  : #endif
; 604  :     cv_enum_fields( type, cv_memberproc, cv, &count );

	lea	r9, QWORD PTR count$[rsp]
	mov	QWORD PTR [rsi+16], rax
	add	cx, 2
	lea	rdx, OFFSET FLAT:cv_memberproc
	mov	WORD PTR [rax], cx
	mov	rax, QWORD PTR [rsi+16]
	mov	r8, rsi
	mov	WORD PTR [rax+2], 516			; 00000204H
	add	QWORD PTR [rsi+16], 4
	mov	rcx, rdi
	mov	DWORD PTR count$[rsp+8], 0
	call	cv_enum_fields
$LN14@cv_write_t@2:
	mov	rdi, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+96]

; 605  :     return;
; 606  : }

	add	rsp, 72					; 00000048H
	ret	0
cv_write_type ENDP
_TEXT	ENDS
EXTRN	SpecialTable:BYTE
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
sym$ = 8
cv_get_register PROC NEAR

; 613  :     uint_16 regno;
; 614  :     uint_16 rc = 0;

	xor	r10w, r10w
	lea	r8, QWORD PTR [rcx+56]
	lea	r11, OFFSET FLAT:SpecialTable
	xor	edx, edx
$LL9@cv_get_reg:

; 615  :     unsigned flags;
; 616  :     int i;
; 617  : 
; 618  :     for ( i = 0; i < 2; i++ ) {
; 619  :         if ( sym->regist[i] ) {

	cmp	WORD PTR [r8], 0
	je	SHORT $LN8@cv_get_reg

; 620  :             flags = GetValueSp( sym->regist[i] );

	movzx	eax, WORD PTR [r8]
	lea	rcx, QWORD PTR [rax+rax*2]

; 621  :             regno = 1 + GetRegNo( sym->regist[i] );

	movzx	eax, BYTE PTR [r11+rcx*4+10]
	mov	r9d, DWORD PTR [r11+rcx*4]
	inc	ax

; 622  :             if ( flags & OP_R16 )

	test	r9b, 2
	je	SHORT $LN5@cv_get_reg

; 623  :                 regno += 8;

	add	ax, 8
	jmp	SHORT $LN1@cv_get_reg
$LN5@cv_get_reg:

; 624  :             else if ( flags & OP_R32 )

	test	r9b, 4
	je	SHORT $LN3@cv_get_reg

; 625  :                 regno += 16;

	add	ax, 16
	jmp	SHORT $LN1@cv_get_reg
$LN3@cv_get_reg:

; 626  :             else if ( flags & OP_SR )

	test	r9d, 24576				; 00006000H
	je	SHORT $LN1@cv_get_reg

; 627  :                 regno += 24;

	add	ax, 24
$LN1@cv_get_reg:

; 628  :             rc |= regno << ( i * 8 );

	mov	ecx, edx
	shl	ax, cl
	or	r10w, ax
$LN8@cv_get_reg:
	add	edx, 8
	add	r8, 2
	cmp	edx, 16
	jl	SHORT $LL9@cv_get_reg

; 629  :         }
; 630  :     }
; 631  :     return( rc );

	mov	ax, r10w

; 632  : }

	ret	0
cv_get_register ENDP
; Function compile flags: /Ogtpy
regno$ = 8
cv_get_x64_regno PROC NEAR

; 648  :     if ( regno >= T_RAX && regno <= T_RDI )

	lea	eax, DWORD PTR [rcx-115]
	cmp	ax, 7
	ja	SHORT $LN2@cv_get_x64

; 649  :         return( reg64[ regno - T_RAX ] + CV_REG_AMD64_START64 );

	movzx	eax, cx
	lea	rcx, OFFSET FLAT:reg64
	movzx	eax, BYTE PTR [rax+rcx-115]
	add	eax, 328				; 00000148H

; 654  : 
; 655  : }

	ret	0
$LN2@cv_get_x64:

; 650  :     if ( regno >= T_R8 && regno <= T_R15 )

	lea	eax, DWORD PTR [rcx-123]
	cmp	ax, 7

; 651  :         return( regno - T_R8 + CV_REG_AMD64_START64 + 8 );

	mov	ax, cx
	ja	SHORT $LN1@cv_get_x64
	add	eax, 213				; 000000d5H

; 654  : 
; 655  : }

	ret	0
$LN1@cv_get_x64:

; 652  :     /* it's a 32-bit register r8d-r15d */
; 653  :     return( regno - T_R8D + CV_REG_AMD64_START32 );

	add	eax, 253				; 000000fdH

; 654  : 
; 655  : }

	ret	0
cv_get_x64_regno ENDP
_TEXT	ENDS
EXTRN	__ImageBase:BYTE
EXTRN	store_fixup:NEAR
EXTRN	CreateFixup:NEAR
EXTRN	ModuleInfo:BYTE
EXTRN	GetSymOfssize:NEAR
xdata	SEGMENT
$unwind$cv_write_symbol DD 011cf01H
	DD	0bf4cfH
	DD	0ce42cH
	DD	0dd422H
	DD	0ec41bH
	DD	0137417H
	DD	0126413H
	DD	011540fH
	DD	010340bH
	DD	0e207H
xdata	ENDS
pdata	SEGMENT
$pdata$cv_write_symbol DD @imagerel(cv_write_symbol#)
	DD	@imagerel(cv_write_symbol#+2623)
	DD	@imagerel($unwind$cv_write_symbol#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
tv64 = 32
len$1$ = 40
proc$ = 40
cnt$ = 48
locals$ = 56
cv$ = 128
sym$ = 136
cv_write_symbol PROC NEAR

; 666  : {

	mov	rax, rsp
	sub	rsp, 120				; 00000078H
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	QWORD PTR [rax-8], r12
	mov	rbx, rcx
	mov	QWORD PTR [rax-16], r13

; 667  :     int        len;
; 668  :     unsigned   ofs;
; 669  :     enum fixup_types rlctype;
; 670  :     uint_8     Ofssize;
; 671  :     struct fixup *fixup;
; 672  :     struct dsym *proc;
; 673  :     struct dsym *lcl;
; 674  :     int        i;
; 675  :     int        cnt[2];
; 676  :     struct     dsym *locals[2];
; 677  : 
; 678  :     Ofssize = GetSymOfssize( sym );

	mov	rcx, rdx
	mov	rsi, rdx
	mov	QWORD PTR [rax-24], r14
	call	GetSymOfssize

; 679  :     len = GetCVStructLen( sym, Ofssize );

	mov	edi, 10
	xor	r12d, r12d
	cmp	DWORD PTR [rsi+40], 7
	mov	r13d, eax
	mov	DWORD PTR tv64[rsp], eax
	lea	r14d, QWORD PTR [rdi-1]
	lea	ebp, QWORD PTR [rdi-8]
	je	SHORT $LN65@cv_write_s
	test	BYTE PTR [rsi+49], 8
	je	SHORT $LN63@cv_write_s
	cmp	BYTE PTR Options+3, 1
	jb	SHORT $LN63@cv_write_s
	mov	eax, 37					; 00000025H
	mov	ecx, 29
	test	r13b, r13b
	cmove	ax, cx
	jmp	SHORT $LN57@cv_write_s
$LN63@cv_write_s:
	mov	eax, DWORD PTR [rsi+44]
	cmp	eax, 129				; 00000081H
	je	SHORT $LN60@cv_write_s
	cmp	eax, 130				; 00000082H
	je	SHORT $LN60@cv_write_s
	test	BYTE PTR [rsi+48], 16
	je	SHORT $LN58@cv_write_s
	cmp	DWORD PTR [rsi+16], 32768		; 00008000H
	mov	eax, r12d
	cmovge	ax, bp
	add	ax, 8
	jmp	SHORT $LN57@cv_write_s
$LN58@cv_write_s:
	mov	eax, 12
	test	r13b, r13b
	cmove	ax, di
	jmp	SHORT $LN57@cv_write_s
$LN60@cv_write_s:
	mov	eax, 11
	test	r13b, r13b
	cmove	ax, r14w
	jmp	SHORT $LN57@cv_write_s
$LN65@cv_write_s:
	mov	ax, 6
$LN57@cv_write_s:

; 680  :     cv->ps = checkflush( cv->symbols, cv->ps, 1 + sym->name_size + len, cv->param );

	mov	rcx, QWORD PTR [rbx+8]
	mov	r9, QWORD PTR [rbx+32]
	mov	rdx, QWORD PTR [rbx]
	mov	r10, QWORD PTR [rcx+104]
	mov	QWORD PTR [rsp+88], r15
	movzx	r15d, ax
	movzx	eax, BYTE PTR [rsi+80]
	mov	DWORD PTR len$1$[rsp], r15d
	lea	r8d, DWORD PTR [rax+r15+1]
	call	QWORD PTR [r10+32]
	mov	QWORD PTR [rbx], rax

; 681  : 
; 682  :     if ( sym->state == SYM_TYPE ) {

	cmp	DWORD PTR [rsi+40], 7
	mov	r11, rax
	jne	SHORT $LN52@cv_write_s

; 683  :         /* Masm does only generate an UDT for typedefs
; 684  :          * if the underlying type is "used" somewhere.
; 685  :          * example:
; 686  :          * LPSTR typedef ptr BYTE
; 687  :          * will only generate an S_UDT for LPSTR if either
; 688  :          * "LPSTR" or "ptr BYTE" is used in the source.
; 689  :          */
; 690  :         cv->ps_udt->sr.size = sizeof( struct cv_symrec_udt ) - sizeof(uint_16) + 1 + sym->name_size;

	movzx	ecx, BYTE PTR [rsi+80]
	add	cx, 5
	mov	WORD PTR [rax], cx

; 691  :         cv->ps_udt->sr.type = S_UDT;

	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+2], 4

; 692  :         /* v2.10: pointer typedefs will now have a cv_typeref */
; 693  :         //if ( sym->typekind != TYPE_TYPEDEF ) {
; 694  :         if ( sym->cvtyperef ) {

	movzx	ecx, WORD PTR [rsi+72]
	test	cx, cx
	je	SHORT $LN51@cv_write_s

; 695  :             cv->ps_udt->type = sym->cvtyperef;

	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+4], cx

; 696  :         } else {

	jmp	SHORT $LN50@cv_write_s
$LN51@cv_write_s:

; 697  :             cv->ps_udt->type = GetTyperef( sym, Ofssize );

	movzx	edx, r13b
	mov	rcx, rsi
	call	GetTyperef
	mov	rcx, QWORD PTR [rbx]
	mov	WORD PTR [rcx+4], ax
$LN50@cv_write_s:

; 698  :         }
; 699  : 
; 700  :         /* Some typedefs won't get a valid type (<name> TYPEDEF PROTO ...).
; 701  :          * In such cases just skip the type!
; 702  :          */
; 703  :         if ( cv->ps_udt->type == 0 )

	mov	rcx, QWORD PTR [rbx]
	cmp	WORD PTR [rcx+4], r12w
	je	$LN20@cv_write_s

; 704  :             return;
; 705  : 
; 706  :         DebugMsg(( "cv_write_symbol(%X): TYPE=%s typeref=%Xh\n", GetPos(cv->symbols, cv->ps), sym->name, cv->ps_udt->type ));
; 707  :         cv->ps += len;

	movsxd	rax, r15d
	add	rcx, rax
	mov	QWORD PTR [rbx], rcx

; 708  :         SetPrefixName( cv->ps, sym->name, sym->name_size );

	movzx	eax, BYTE PTR [rsi+80]
	mov	BYTE PTR [rcx], al
	inc	QWORD PTR [rbx]
	movzx	r8d, BYTE PTR [rsi+80]
	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rbx]
	call	memcpy
	movzx	r11d, BYTE PTR [rsi+80]
	add	QWORD PTR [rbx], r11

; 709  :         return;

	jmp	$LN20@cv_write_s
$LN52@cv_write_s:

; 710  :     }
; 711  : 
; 712  :     /* rest is SYM_INTERNAL */
; 713  :     /* there are 3 types of INTERNAL symbols:
; 714  :      * - numeric constants ( equates, memtype MT_EMPTY )
; 715  :      * - code labels, memtype == MT_NEAR | MT_FAR
; 716  :      *   - procs
; 717  :      *   - simple labels
; 718  :      * - data labels, memtype != MT_NEAR | MT_FAR
; 719  :      */
; 720  : 
; 721  :     if ( sym->isproc && Options.debug_ext >= CVEX_REDUCED ) { /* v2.10: no locals for -Zi0 */

	movzx	ecx, BYTE PTR [rsi+49]
	test	cl, 8
	je	$LN48@cv_write_s
	cmp	BYTE PTR Options+3, 1
	jb	$LN48@cv_write_s

; 722  : 
; 723  :         proc = (struct dsym *)sym;
; 724  : 
; 725  :         /* for PROCs, scan parameters and locals and create their types. */
; 726  : 
; 727  :         /* scan local symbols */
; 728  :         locals[0] = proc->e.procinfo->paralist;

	mov	rcx, QWORD PTR [rsi+104]
	mov	r15d, DWORD PTR tv64[rsp]

; 729  :         locals[1] = proc->e.procinfo->locallist;
; 730  :         for ( i = 0; i < 2; i++ ) {

	xor	edx, edx
	mov	rax, QWORD PTR [rcx+8]
	mov	r13, rdx
	lea	r12, QWORD PTR cnt$[rsp]
	mov	QWORD PTR locals$[rsp], rax
	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR locals$[rsp+8], rax
	npad	9
$LL47@cv_write_s:

; 731  :             cnt[i] = 0;
; 732  :             for ( lcl = locals[i]; lcl; lcl = lcl->nextparam ) {

	mov	rdi, QWORD PTR locals$[rsp+r13*8]
	mov	DWORD PTR [r12], edx
	test	rdi, rdi
	je	SHORT $LN46@cv_write_s
	mov	ebp, edx
$LL44@cv_write_s:

; 733  :                 cv_typeref typeref;
; 734  :                 cnt[i]++;

	inc	ebp

; 735  :                 typeref = ( lcl->sym.mem_type == MT_PTR ? cv_write_ptr_type( cv, &lcl->sym ) : GetTyperef( &lcl->sym, Ofssize ) );

	cmp	DWORD PTR [rdi+44], 195			; 000000c3H
	jne	SHORT $LN55@cv_write_s
	mov	rdx, rdi
	mov	rcx, rbx
	call	cv_write_ptr_type
	jmp	SHORT $LN56@cv_write_s
$LN55@cv_write_s:
	movzx	edx, r15b
	mov	rcx, rdi
	call	GetTyperef
$LN56@cv_write_s:

; 736  :                 if ( lcl->sym.isarray ) {

	test	BYTE PTR [rdi+49], 2
	je	SHORT $LN41@cv_write_s

; 737  :                     cv_write_array_type( cv, &lcl->sym, typeref, Ofssize );

	movzx	r9d, r15b
	movzx	r8d, ax
	mov	rdx, rdi
	mov	rcx, rbx
	call	cv_write_array_type

; 738  :                     typeref = cv->currtype - 1;

	movzx	eax, WORD PTR [rbx+44]
	dec	ax
$LN41@cv_write_s:

; 739  :                 }
; 740  :                 lcl->sym.ext_idx1 = typeref;

	mov	WORD PTR [rdi+96], ax
	mov	rdi, QWORD PTR [rdi+120]
	test	rdi, rdi
	jne	SHORT $LL44@cv_write_s
	mov	DWORD PTR [r12], ebp
	xor	edx, edx
$LN46@cv_write_s:
	inc	r13
	add	r12, 4
	cmp	r13, 2
	jl	SHORT $LL47@cv_write_s

; 741  :             }
; 742  :         }
; 743  : 
; 744  :         DebugMsg(( "cv_write_symbol(%X): PROC=%s\n", GetPos(cv->symbols, cv->ps), sym->name ));
; 745  :         if ( Ofssize == USE16 ) {

	mov	r13d, DWORD PTR tv64[rsp]
	test	r13b, r13b
	jne	$LN40@cv_write_s

; 746  :             cv->ps_p16->sr.size = sizeof( struct cv_symrec_lproc16 ) - sizeof(uint_16) + 1 + sym->name_size;

	movzx	ecx, BYTE PTR [rsi+80]
	mov	rax, QWORD PTR [rbx]

; 747  :             cv->ps_p16->sr.type = (sym->ispublic ? S_GPROC16 : S_LPROC16);
; 748  :             cv->ps_p16->pParent = 0;  /* filled by CVPACK */
; 749  :             cv->ps_p16->pEnd = 0;     /* filled by CVPACK */
; 750  :             cv->ps_p16->pNext = 0;    /* filled by CVPACK */
; 751  :             cv->ps_p16->proc_length = sym->total_size;
; 752  :             cv->ps_p16->debug_start = ((struct dsym *)sym)->e.procinfo->size_prolog;
; 753  :             cv->ps_p16->debug_end = sym->total_size;
; 754  :             cv->ps_p16->offset = 0;
; 755  :             cv->ps_p16->segment = 0;
; 756  :             cv->ps_p16->proctype = cv->currtype; /* typeref LF_PROCEDURE */
; 757  :             cv->ps_p16->flags = ( sym->mem_type == MT_FAR ? CV_PROCF_FAR : 0 );

	mov	ebp, 4
	add	cx, 28

; 758  :             rlctype = FIX_PTR16;
; 759  :             ofs = offsetof( struct cv_symrec_lproc16, offset );

	lea	edi, QWORD PTR [rbp+18]
	mov	WORD PTR [rax], cx
	movzx	eax, BYTE PTR [rsi+48]
	and	al, 128					; 00000080H
	movzx	ecx, al
	mov	rax, QWORD PTR [rbx]
	or	cx, 33407				; 0000827fH
	shr	cx, 7
	mov	WORD PTR [rax+2], cx
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+4], edx
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+8], edx
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+12], edx
	mov	rcx, QWORD PTR [rbx]
	movzx	eax, WORD PTR [rsi+64]
	mov	WORD PTR [rcx+16], ax
	mov	rax, QWORD PTR [rsi+104]
	movzx	ecx, BYTE PTR [rax+129]
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+18], cx
	mov	rcx, QWORD PTR [rbx]
	movzx	eax, WORD PTR [rsi+64]
	mov	WORD PTR [rcx+20], ax
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+22], 0
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+24], 0
	mov	rcx, QWORD PTR [rbx]
	movzx	eax, WORD PTR [rbx+44]
	mov	WORD PTR [rcx+26], ax
	cmp	DWORD PTR [rsi+44], 130			; 00000082H
	mov	rax, QWORD PTR [rbx]
	mov	ecx, edx
	cmove	ecx, ebp
	mov	BYTE PTR [rax+28], cl

; 760  :         } else {

	jmp	$LN39@cv_write_s
$LN40@cv_write_s:

; 761  :             cv->ps_p32->sr.size = sizeof( struct cv_symrec_lproc32 ) - sizeof(uint_16) + 1 + sym->name_size;

	movzx	ecx, BYTE PTR [rsi+80]
	mov	rax, QWORD PTR [rbx]

; 762  :             cv->ps_p32->sr.type = (sym->ispublic ? S_GPROC32 : S_LPROC32 );
; 763  :             cv->ps_p32->pParent = 0; /* filled by CVPACK */
; 764  :             cv->ps_p32->pEnd = 0;    /* filled by CVPACK */
; 765  :             cv->ps_p32->pNext = 0;   /* filled by CVPACK */
; 766  :             cv->ps_p32->proc_length = sym->total_size;
; 767  :             cv->ps_p32->debug_start = ((struct dsym *)sym)->e.procinfo->size_prolog;
; 768  :             cv->ps_p32->debug_end = sym->total_size;
; 769  :             cv->ps_p32->offset = 0;
; 770  :             cv->ps_p32->segment = 0;
; 771  :             cv->ps_p32->proctype = cv->currtype; /* typeref LF_PROCEDURE */
; 772  : #if STACKBASESUPP
; 773  :             cv->ps_p32->flags = ( ( sym->mem_type == MT_FAR ? CV_PROCF_FAR : 0 ) | ( proc->e.procinfo->fpo ? CV_PROCF_FPO : 0 ) );
; 774  : #else
; 775  :             cv->ps_p32->flags = ( sym->mem_type == MT_FAR ? CV_PROCF_FAR : 0 );
; 776  : #endif
; 777  :             rlctype = FIX_PTR32;
; 778  :             ofs = offsetof( struct cv_symrec_lproc32, offset );

	mov	edi, 28
	add	cx, 36					; 00000024H
	lea	r14d, QWORD PTR [rdi-18]
	mov	WORD PTR [rax], cx
	movzx	eax, BYTE PTR [rsi+48]
	shr	al, 7
	movzx	ecx, al
	mov	rax, QWORD PTR [rbx]
	or	cx, 516					; 00000204H
	mov	WORD PTR [rax+2], cx
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+4], edx
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+8], edx
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+12], edx
	mov	rcx, QWORD PTR [rbx]
	mov	eax, DWORD PTR [rsi+64]
	mov	DWORD PTR [rcx+16], eax
	mov	rax, QWORD PTR [rsi+104]
	movzx	ecx, BYTE PTR [rax+129]
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+20], ecx
	mov	rcx, QWORD PTR [rbx]
	mov	eax, DWORD PTR [rsi+64]
	mov	DWORD PTR [rcx+24], eax
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+28], edx
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+32], 0
	movzx	eax, WORD PTR [rbx+44]
	mov	rcx, QWORD PTR [rbx]
	mov	WORD PTR [rcx+34], ax
	cmp	DWORD PTR [rsi+44], 130			; 00000082H
	mov	eax, 4
	cmove	edx, eax
	mov	rax, QWORD PTR [rsi+104]
	movzx	ecx, BYTE PTR [rax+128]
	mov	rax, QWORD PTR [rbx]
	shr	cl, 7
	or	dl, cl
	mov	BYTE PTR [rax+36], dl
$LN39@cv_write_s:

; 779  :         }
; 780  :         cv_write_type_procedure( cv, sym, cnt[0] );

	mov	r8d, DWORD PTR cnt$[rsp]
	mov	rdx, rsi
	mov	rcx, rbx
	call	cv_write_type_procedure
	mov	r15d, DWORD PTR len$1$[rsp]
	mov	ebp, 2
	mov	r12, rsi
	jmp	$LN34@cv_write_s
$LN48@cv_write_s:

; 781  : 
; 782  :     } else if ( sym->mem_type == MT_NEAR || sym->mem_type == MT_FAR ) {

	mov	eax, DWORD PTR [rsi+44]
	cmp	eax, 129				; 00000081H
	je	$LN36@cv_write_s
	cmp	eax, 130				; 00000082H
	je	$LN36@cv_write_s

; 801  :             DebugMsg(( "cv_write_symbol(%X): LABEL32=%s\n", GetPos(cv->symbols,cv->ps), sym->name ));
; 802  :         }
; 803  : #if EQUATESYMS
; 804  :     } else if ( sym->isequate ) {

	test	BYTE PTR [rsi+48], 16
	je	SHORT $LN32@cv_write_s

; 805  :         cv->ps_con->sr.size = len - sizeof(uint_16) + 1 + sym->name_size;

	movzx	eax, BYTE PTR [rsi+80]
	add	ax, r15w
	dec	ax
	mov	WORD PTR [r11], ax

; 806  :         cv->ps_con->sr.type = S_CONSTANT;

	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+2], 3

; 807  :         cv->ps_con->type = cv_abs_type.uvalue;

	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+4], 1

; 808  :         if ( sym->value >= LF_NUMERIC ) {

	cmp	DWORD PTR [rsi+16], 32768		; 00008000H
	jl	SHORT $LN31@cv_write_s

; 809  :             uint_8 *tmp;
; 810  :             cv->ps_con->value = LF_ULONG;

	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+6], 32772			; 00008004H

; 811  :             tmp = (uint_8 *)&cv->ps_con->value;
; 812  :             *(uint_32 *)tmp = sym->value;

	mov	rcx, QWORD PTR [rbx]
	mov	eax, DWORD PTR [rsi+16]
	mov	DWORD PTR [rcx+6], eax

; 813  :         } else {

	jmp	SHORT $LN30@cv_write_s
$LN31@cv_write_s:

; 814  :             cv->ps_con->value = sym->value;

	mov	rcx, QWORD PTR [rbx]
	movzx	eax, WORD PTR [rsi+16]
	mov	WORD PTR [rcx+6], ax
$LN30@cv_write_s:

; 815  :         }
; 816  :         cv->ps += len;

	add	QWORD PTR [rbx], r15
	mov	rcx, QWORD PTR [rbx]

; 817  :         SetPrefixName( cv->ps, sym->name, sym->name_size );

	movzx	eax, BYTE PTR [rsi+80]
	mov	BYTE PTR [rcx], al
	inc	QWORD PTR [rbx]
	movzx	r8d, BYTE PTR [rsi+80]
	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rbx]
	call	memcpy
	movzx	r11d, BYTE PTR [rsi+80]
	add	QWORD PTR [rbx], r11

; 818  :         return;

	jmp	$LN20@cv_write_s
$LN32@cv_write_s:

; 819  : #endif
; 820  :     } else {
; 821  :         /* v2.10: set S_GDATA[16|32] if symbol is public */
; 822  :         cv_typeref typeref;
; 823  : 
; 824  :         if ( sym->isarray ) {

	test	cl, bpl
	je	SHORT $LN28@cv_write_s

; 825  :             typeref = cv->currtype;

	movzx	edi, WORD PTR [rbx+44]

; 826  :             cv_write_array_type( cv, sym, 0, Ofssize );

	movzx	r9d, r13b
	xor	r8d, r8d
	mov	rdx, rsi
	mov	rcx, rbx
	call	cv_write_array_type

; 827  :         } else

	jmp	SHORT $LN27@cv_write_s
$LN28@cv_write_s:

; 828  :             typeref = GetTyperef( sym, Ofssize );

	movzx	edx, r13b
	mov	rcx, rsi
	call	GetTyperef
	mov	di, ax
$LN27@cv_write_s:

; 829  : 
; 830  :         if ( Ofssize == USE16 ) {

	test	r13b, r13b
	jne	SHORT $LN26@cv_write_s

; 831  :             cv->ps_d16->sr.size = sizeof( struct cv_symrec_ldata16 ) - sizeof(uint_16) + 1 + sym->name_size;

	movzx	edx, BYTE PTR [rsi+80]
	mov	rcx, QWORD PTR [rbx]
	add	dx, r14w
	mov	WORD PTR [rcx], dx

; 832  :             cv->ps_d16->sr.type = (sym->ispublic ? S_GDATA16 : S_LDATA16 );

	test	BYTE PTR [rsi+48], 128			; 00000080H
	mov	rax, QWORD PTR [rbx]
	mov	ecx, r12d
	setne	cl
	add	cx, 257					; 00000101H
	mov	WORD PTR [rax+2], cx

; 833  :             cv->ps_d16->offset = 0;

	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+4], r12w

; 834  :             cv->ps_d16->segment = 0;

	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+6], r12w

; 835  :             cv->ps_d16->type = typeref;

	mov	rax, QWORD PTR [rbx]

; 836  :             rlctype = FIX_PTR16;
; 837  :             ofs = offsetof( struct cv_symrec_ldata16, offset );
; 838  :             DebugMsg(( "cv_write_symbol(%X): INTERN16=%s typeref=%Xh\n", GetPos(cv->symbols,cv->ps), sym->name, cv->ps_d16->type ));
; 839  :         } else {

	mov	r12, QWORD PTR proc$[rsp]
	mov	WORD PTR [rax+8], di
	mov	edi, 4
	jmp	$LN34@cv_write_s
$LN26@cv_write_s:

; 840  :             cv->ps_d32->sr.size = sizeof( struct cv_symrec_ldata32 ) - sizeof(uint_16) + 1 + sym->name_size;

	movzx	ecx, BYTE PTR [rsi+80]
	mov	rax, QWORD PTR [rbx]
	add	cx, 11
	mov	WORD PTR [rax], cx

; 841  : #if CVOSUPP
; 842  :             if ( ( ModuleInfo.cv_opt & CVO_STATICTLS ) && ((struct dsym *)sym->segment)->e.seginfo->clsym &&
; 843  :                 strcmp( ((struct dsym *)sym->segment)->e.seginfo->clsym->name, "TLS" ) == 0 )

	test	BYTE PTR ModuleInfo+427, 1
	je	SHORT $LN24@cv_write_s
	mov	rax, QWORD PTR [rsi+32]
	mov	rcx, QWORD PTR [rax+104]
	mov	rax, QWORD PTR [rcx+80]
	test	rax, rax
	je	SHORT $LN24@cv_write_s
	mov	rax, QWORD PTR [rax+8]
	lea	r8, OFFSET FLAT:$SG6156
	sub	r8, rax
	npad	8
$LL95@cv_write_s:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN96@cv_write_s
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL95@cv_write_s
$LN96@cv_write_s:
	test	edx, edx
	jne	SHORT $LN24@cv_write_s

; 844  :                 cv->ps_d32->sr.type = (sym->ispublic ? S_GTHREAD32 : S_LTHREAD32 );

	test	BYTE PTR [rsi+48], 128			; 00000080H
	mov	rax, QWORD PTR [rbx]
	mov	ecx, r12d
	setne	cl
	add	cx, 525					; 0000020dH
	mov	WORD PTR [rax+2], cx

; 845  :             else

	jmp	SHORT $LN23@cv_write_s
$LN24@cv_write_s:

; 846  : #endif
; 847  :             cv->ps_d32->sr.type = (sym->ispublic ? S_GDATA32 : S_LDATA32 );

	test	BYTE PTR [rsi+48], 128			; 00000080H
	mov	rax, QWORD PTR [rbx]
	mov	ecx, r12d
	setne	cl
	add	cx, 513					; 00000201H
	mov	WORD PTR [rax+2], cx
$LN23@cv_write_s:

; 848  :             cv->ps_d32->offset = 0;

	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+4], r12d

; 849  :             cv->ps_d32->segment = 0;

	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+8], r12w

; 850  :             cv->ps_d32->type = typeref;

	mov	rax, QWORD PTR [rbx]

; 851  :             rlctype = FIX_PTR32;
; 852  :             ofs = offsetof( struct cv_symrec_ldata32, offset );

	mov	r12, QWORD PTR proc$[rsp]
	mov	WORD PTR [rax+10], di
	mov	edi, 4
	lea	r14d, QWORD PTR [rdi+6]
	jmp	$LN34@cv_write_s
$LN36@cv_write_s:

; 783  : 
; 784  :         if ( Ofssize == USE16 ) {

	test	r13b, r13b
	jne	SHORT $LN35@cv_write_s

; 785  :             cv->ps_l16->sr.size = sizeof( struct cv_symrec_label16 ) - sizeof(uint_16) + 1 + sym->name_size;

	movzx	eax, BYTE PTR [rsi+80]

; 786  :             cv->ps_l16->sr.type = S_LABEL16;
; 787  :             cv->ps_l16->offset = 0;
; 788  :             cv->ps_l16->segment = 0;
; 789  :             cv->ps_l16->flags = ( sym->mem_type == MT_FAR ? CV_PROCF_FAR : 0 );

	mov	ecx, r12d
	mov	edx, 4
	add	ax, 8

; 790  :             rlctype = FIX_PTR16;
; 791  :             ofs = offsetof( struct cv_symrec_label16, offset );

	mov	edi, edx
	mov	WORD PTR [r11], ax
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+2], 265			; 00000109H
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+4], r12w
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+6], r12w
	cmp	DWORD PTR [rsi+44], 130			; 00000082H
	mov	rax, QWORD PTR [rbx]

; 792  :             DebugMsg(( "cv_write_symbol(%X): LABEL16=%s\n", GetPos(cv->symbols,cv->ps), sym->name ));
; 793  :         } else {

	mov	r12, QWORD PTR proc$[rsp]
	cmove	ecx, edx
	mov	BYTE PTR [rax+8], cl
	jmp	SHORT $LN34@cv_write_s
$LN35@cv_write_s:

; 794  :             cv->ps_l32->sr.size = sizeof( struct cv_symrec_label32 ) - sizeof(uint_16) + 1 + sym->name_size;

	movzx	eax, BYTE PTR [rsi+80]

; 795  :             cv->ps_l32->sr.type = S_LABEL32;
; 796  :             cv->ps_l32->offset = 0;
; 797  :             cv->ps_l32->segment = 0;
; 798  :             cv->ps_l32->flags = ( sym->mem_type == MT_FAR ? CV_PROCF_FAR : 0 );

	mov	ecx, r12d
	mov	edx, 4
	add	ax, di

; 799  :             rlctype = FIX_PTR32;

	mov	r14d, edi

; 800  :             ofs = offsetof( struct cv_symrec_label32, offset );

	mov	edi, edx
	mov	WORD PTR [r11], ax
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+2], 521			; 00000209H
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+4], r12d
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+8], r12w
	cmp	DWORD PTR [rsi+44], 130			; 00000082H
	mov	rax, QWORD PTR [rbx]
	mov	r12, QWORD PTR proc$[rsp]
	cmove	ecx, edx
	mov	BYTE PTR [rax+10], cl
$LN34@cv_write_s:

; 853  :             DebugMsg(( "cv_write_symbol(%X): INTERN32=%s typeref=%Xh\n", GetPos(cv->symbols,cv->ps), sym->name, cv->ps_d16->type ));
; 854  :         }
; 855  :     }
; 856  :     cv->ps += ofs;

	mov	eax, edi
	add	QWORD PTR [rbx], rax

; 857  :     cv->symbols->e.seginfo->current_loc = cv->symbols->e.seginfo->start_loc + ( cv->ps - cv->symbols->e.seginfo->CodeBuffer );

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rcx+8]
	sub	eax, DWORD PTR [rcx+16]
	add	eax, DWORD PTR [rbx]
	mov	DWORD PTR [rcx+12], eax

; 858  : #if COFF_SUPPORT
; 859  :     /* v2.10: also handle FIX_PTR16 for COFF */
; 860  :     //if ( rlctype == FIX_PTR32 && Options.output_format == OFORMAT_COFF ) {
; 861  :     if ( Options.output_format == OFORMAT_COFF ) {

	cmp	DWORD PTR Options+156, 2
	jne	SHORT $LN22@cv_write_s

; 862  :         /* COFF has no "far" fixups. Instead Masm creates a
; 863  :          * section-relative fixup + a section fixup.
; 864  :          */
; 865  :         fixup = CreateFixup( sym, FIX_OFF32_SECREL, OPTJ_NONE );

	xor	r8d, r8d
	mov	rcx, rsi
	lea	edx, QWORD PTR [r8+13]
	call	CreateFixup

; 866  :         fixup->locofs = cv->symbols->e.seginfo->current_loc;

	mov	rcx, QWORD PTR [rbx+8]
	mov	rdx, QWORD PTR [rcx+104]
	mov	ecx, DWORD PTR [rdx+12]
	mov	DWORD PTR [rax+20], ecx

; 867  :         store_fixup( fixup, cv->symbols, (int_32 *)cv->ps );

	mov	r8, QWORD PTR [rbx]
	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, rax
	call	store_fixup

; 868  :         fixup = CreateFixup( sym, FIX_SEG, OPTJ_NONE );

	xor	r8d, r8d
	mov	rcx, rsi
	lea	edx, QWORD PTR [r8+8]
	call	CreateFixup

; 869  :         //fixup->locofs += sizeof( int_32 );
; 870  :         fixup->locofs = cv->symbols->e.seginfo->current_loc + ( rlctype == FIX_PTR32 ? sizeof( int_32 ) : sizeof ( int_16 ) );

	mov	rcx, QWORD PTR [rbx+8]
	cmp	r14d, 10
	mov	rdx, QWORD PTR [rcx+104]
	mov	r14d, 4

; 871  :         store_fixup( fixup, cv->symbols, (int_32 *)cv->ps );

	mov	rcx, rax
	cmove	ebp, r14d
	add	ebp, DWORD PTR [rdx+12]
	mov	DWORD PTR [rax+20], ebp
	mov	r8, QWORD PTR [rbx]
	mov	rdx, QWORD PTR [rbx+8]
	call	store_fixup

; 872  :     } else {

	jmp	SHORT $LN21@cv_write_s
$LN22@cv_write_s:

; 873  : #endif
; 874  :         fixup = CreateFixup( sym, rlctype, OPTJ_NONE );

	xor	r8d, r8d
	mov	edx, r14d
	mov	rcx, rsi
	call	CreateFixup

; 875  :         fixup->locofs = cv->symbols->e.seginfo->current_loc;

	mov	rcx, QWORD PTR [rbx+8]
	mov	rdx, QWORD PTR [rcx+104]
	mov	ecx, DWORD PTR [rdx+12]
	mov	DWORD PTR [rax+20], ecx

; 876  :         /* todo: for OMF, delay fixup store until checkflush has been called! */
; 877  :         store_fixup( fixup, cv->symbols, (int_32 *)cv->ps );

	mov	r8, QWORD PTR [rbx]
	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, rax
	call	store_fixup
	mov	r14d, 4
$LN21@cv_write_s:

; 878  : #if COFF_SUPPORT
; 879  :     }
; 880  : #endif
; 881  :     cv->ps += len - ofs;

	sub	r15d, edi
	mov	eax, r15d
	add	QWORD PTR [rbx], rax
	mov	rcx, QWORD PTR [rbx]

; 882  : 
; 883  :     SetPrefixName( cv->ps, sym->name, sym->name_size );

	movzx	eax, BYTE PTR [rsi+80]
	mov	BYTE PTR [rcx], al
	inc	QWORD PTR [rbx]
	movzx	r8d, BYTE PTR [rsi+80]
	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rbx]
	call	memcpy
	movzx	r11d, BYTE PTR [rsi+80]
	add	QWORD PTR [rbx], r11

; 884  : 
; 885  :     /* for PROCs, scan parameters and locals.
; 886  :      * to mark the block's end, write an ENDBLK item.
; 887  :      */
; 888  :     if ( sym->isproc && Options.debug_ext >= CVEX_REDUCED ) { /* v2.10: no locals for -Zi0 */

	test	BYTE PTR [rsi+49], 8
	je	$LN20@cv_write_s
	cmp	BYTE PTR Options+3, 1
	jb	$LN20@cv_write_s

; 889  : 
; 890  :         /* scan local symbols again */
; 891  :         for ( i = 0; i < 2 ; i++ ) {

	xor	ebp, ebp
	lea	r15, OFFSET FLAT:__ImageBase
	npad	10
$LL19@cv_write_s:

; 892  :             for ( lcl = locals[i]; lcl; lcl = lcl->nextparam ) {

	mov	rdi, QWORD PTR locals$[rsp+rbp*8]
	test	rdi, rdi
	je	$LN18@cv_write_s
	npad	2
$LL16@cv_write_s:

; 893  : 
; 894  :                 /* FASTCALL register argument? */
; 895  :                 if ( lcl->sym.state == SYM_TMACRO ) {

	cmp	DWORD PTR [rdi+40], 10
	jne	$LN13@cv_write_s

; 896  :                     len = sizeof( struct cv_symrec_register );
; 897  :                     cv->ps = checkflush( cv->symbols, cv->ps, 1 + lcl->sym.name_size + len, cv->param );

	mov	rcx, QWORD PTR [rbx+8]
	movzx	r8d, BYTE PTR [rdi+80]
	mov	r9, QWORD PTR [rbx+32]
	mov	rax, QWORD PTR [rcx+104]
	mov	rdx, QWORD PTR [rbx]
	add	r8d, 9
	mov	esi, 8
	call	QWORD PTR [rax+32]

; 898  :                     cv->ps_reg->sr.size = sizeof( struct cv_symrec_register ) - sizeof(uint_16) + 1 + lcl->sym.name_size;
; 899  :                     cv->ps_reg->sr.type = S_REGISTER;
; 900  :                     cv->ps_reg->type = lcl->sym.ext_idx1;
; 901  :                     cv->ps_reg->registr = cv_get_register( &lcl->sym );

	xor	r10w, r10w
	mov	QWORD PTR [rbx], rax
	movzx	ecx, BYTE PTR [rdi+80]
	lea	r8, QWORD PTR [rdi+56]
	add	cx, 7
	xor	edx, edx
	mov	WORD PTR [rax], cx
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+2], 2
	mov	rcx, QWORD PTR [rbx]
	movzx	eax, WORD PTR [rdi+96]
	mov	WORD PTR [rcx+4], ax
$LL78@cv_write_s:
	cmp	WORD PTR [r8], 0
	je	SHORT $LN77@cv_write_s
	movzx	eax, WORD PTR [r8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR SpecialTable[r15+rcx*4+10]
	mov	r9d, DWORD PTR SpecialTable[r15+rcx*4]
	inc	ax
	test	r9b, 2
	je	SHORT $LN74@cv_write_s
	add	ax, si
	jmp	SHORT $LN70@cv_write_s
$LN74@cv_write_s:
	test	r9b, 4
	je	SHORT $LN72@cv_write_s
	add	ax, 16
	jmp	SHORT $LN70@cv_write_s
$LN72@cv_write_s:
	test	r9d, 24576				; 00006000H
	je	SHORT $LN70@cv_write_s
	add	ax, 24
$LN70@cv_write_s:
	mov	ecx, edx
	shl	ax, cl
	or	r10w, ax
$LN77@cv_write_s:
	add	edx, esi
	add	r8, 2
	cmp	edx, 16
	jl	SHORT $LL78@cv_write_s
	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+6], r10w
	jmp	$LN2@cv_write_s
$LN13@cv_write_s:

; 902  :                 } else if ( Ofssize == USE16 ) {

	test	r13b, r13b
	jne	SHORT $LN11@cv_write_s

; 903  :                     len = sizeof( struct cv_symrec_bprel16 );
; 904  :                     cv->ps = checkflush( cv->symbols, cv->ps, 1 + lcl->sym.name_size + len, cv->param );

	mov	rcx, QWORD PTR [rbx+8]
	movzx	r8d, BYTE PTR [rdi+80]
	mov	r9, QWORD PTR [rbx+32]
	mov	rax, QWORD PTR [rcx+104]
	mov	rdx, QWORD PTR [rbx]
	add	r8d, 9
	mov	esi, 8
	call	QWORD PTR [rax+32]
	mov	QWORD PTR [rbx], rax

; 905  :                     cv->ps_br16->sr.size = sizeof( struct cv_symrec_bprel16 ) - sizeof(uint_16) + 1 + lcl->sym.name_size;

	movzx	ecx, BYTE PTR [rdi+80]
	add	cx, 7
	mov	WORD PTR [rax], cx

; 906  :                     cv->ps_br16->sr.type = S_BPREL16;

	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+2], 256			; 00000100H

; 907  :                     cv->ps_br16->offset = lcl->sym.offset;

	mov	rcx, QWORD PTR [rbx]
	movzx	eax, WORD PTR [rdi+16]
	mov	WORD PTR [rcx+4], ax

; 908  :                     cv->ps_br16->type = lcl->sym.ext_idx1;

	mov	rcx, QWORD PTR [rbx]
	movzx	eax, WORD PTR [rdi+96]
	mov	WORD PTR [rcx+6], ax

; 909  :                     DebugMsg(( "cv_write_symbol(%X): proc=%s, S_BPREL16, var=%s [memt=%X typeref=%X]\n",
; 910  :                               GetPos(cv->symbols,cv->ps), proc->sym.name, lcl->sym.name, lcl->sym.mem_type, cv->ps_br16->type ));
; 911  :                 } else {

	jmp	$LN2@cv_write_s
$LN11@cv_write_s:

; 912  : #if STACKBASESUPP || AMD64_SUPPORT
; 913  :                     /* v2.11: use S_REGREL if 64-bit or frame reg != [E|BP */
; 914  :                     if (
; 915  : #if AMD64_SUPPORT
; 916  :                         Ofssize == USE64
; 917  : #if STACKBASESUPP
; 918  :                         || ( GetRegNo( proc->e.procinfo->basereg ) != 5 )
; 919  : #endif
; 920  : #else
; 921  :                         GetRegNo( proc->e.procinfo->basereg ) != 5
; 922  : #endif
; 923  :                        ) {

	cmp	r13b, 2
	je	SHORT $LN8@cv_write_s
	mov	rax, QWORD PTR [r12+104]
	movzx	ecx, WORD PTR [rax+130]
	lea	rax, QWORD PTR [rcx+rcx*2]
	cmp	BYTE PTR SpecialTable[r15+rax*4+10], 5
	jne	SHORT $LN8@cv_write_s

; 952  :                         DebugMsg(( "cv_write_symbol(%X): proc=%s, S_REGREL32, var=%s [memt=%X typeref=%X]\n",
; 953  :                                   GetPos(cv->symbols,cv->ps), proc->sym.name, lcl->sym.name, lcl->sym.mem_type, cv->ps_rr32->type ));
; 954  :                     } else {
; 955  : #endif
; 956  :                         len = sizeof( struct cv_symrec_bprel32 );
; 957  :                         cv->ps = checkflush( cv->symbols, cv->ps, 1 + lcl->sym.name_size + len, cv->param );

	mov	rcx, QWORD PTR [rbx+8]
	movzx	r8d, BYTE PTR [rdi+80]
	mov	r9, QWORD PTR [rbx+32]
	mov	rax, QWORD PTR [rcx+104]
	mov	rdx, QWORD PTR [rbx]
	add	r8d, 11
	mov	esi, 10
	call	QWORD PTR [rax+32]
	mov	QWORD PTR [rbx], rax

; 958  :                         cv->ps_br32->sr.size = sizeof( struct cv_symrec_bprel32 ) - sizeof(uint_16) + 1 + lcl->sym.name_size;

	movzx	ecx, BYTE PTR [rdi+80]
	add	cx, 9
	mov	WORD PTR [rax], cx

; 959  :                         cv->ps_br32->sr.type = S_BPREL32;

	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+2], 512			; 00000200H

; 960  :                         cv->ps_br32->offset = lcl->sym.offset;

	mov	rcx, QWORD PTR [rbx]
	mov	eax, DWORD PTR [rdi+16]
	mov	DWORD PTR [rcx+4], eax

; 961  :                         cv->ps_br32->type = lcl->sym.ext_idx1;

	mov	rcx, QWORD PTR [rbx]
	movzx	eax, WORD PTR [rdi+96]
	mov	WORD PTR [rcx+8], ax
	jmp	$LN2@cv_write_s
$LN8@cv_write_s:

; 924  : 
; 925  :                         len = sizeof( struct cv_symrec_regrel32 );
; 926  :                         cv->ps = checkflush( cv->symbols, cv->ps, 1 + lcl->sym.name_size + len, cv->param );

	mov	rcx, QWORD PTR [rbx+8]
	movzx	r8d, BYTE PTR [rdi+80]
	mov	r9, QWORD PTR [rbx+32]
	mov	rax, QWORD PTR [rcx+104]
	mov	rdx, QWORD PTR [rbx]
	add	r8d, 13
	mov	esi, 12
	call	QWORD PTR [rax+32]
	mov	QWORD PTR [rbx], rax

; 927  :                         cv->ps_rr32->sr.size = sizeof( struct cv_symrec_regrel32 ) - sizeof(uint_16) + 1 + lcl->sym.name_size;

	movzx	ecx, BYTE PTR [rdi+80]
	add	cx, 11
	mov	WORD PTR [rax], cx

; 928  :                         cv->ps_rr32->sr.type = S_REGREL32;

	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+2], 524			; 0000020cH

; 929  :                         cv->ps_rr32->offset = lcl->sym.offset ;

	mov	rcx, QWORD PTR [rbx]
	mov	eax, DWORD PTR [rdi+16]
	mov	DWORD PTR [rcx+4], eax

; 930  :                         cv->ps_rr32->type = lcl->sym.ext_idx1;

	mov	rcx, QWORD PTR [rbx]
	movzx	eax, WORD PTR [rdi+96]
	mov	WORD PTR [rcx+10], ax

; 931  : #if AMD64_SUPPORT
; 932  :                         //if W64F_HABRAN recalculate parameters positions
; 933  :                         if (ModuleInfo.win64_flags & W64F_SMART){

	test	BYTE PTR ModuleInfo+413, 8
	je	SHORT $LN6@cv_write_s

; 934  :                           if (lcl->sym.isparam){

	test	BYTE PTR [rdi+49], 128			; 00000080H
	je	SHORT $LN6@cv_write_s

; 935  :                             int cnt = proc->e.procinfo->pushed_reg;

	mov	rdx, QWORD PTR [r12+104]

; 936  :                             cnt = cnt * 8;

	mov	ecx, DWORD PTR [rdx+104]

; 937  :                             cnt += lcl->sym.offset + proc->e.procinfo->localsize + proc->e.procinfo->xmmsize; //pointing to RSP

	mov	eax, DWORD PTR [rdx+112]
	lea	r8d, DWORD PTR [rax+rcx*8]
	add	r8d, DWORD PTR [rdx+36]
	add	r8d, DWORD PTR [rdi+16]

; 938  :                             if (proc->sym.langtype == LANG_VECTORCALL)

	cmp	DWORD PTR [r12+84], 8
	jne	SHORT $LN5@cv_write_s

; 939  :                             cnt += proc->e.procinfo->vsize;     //pointing abowe RSP to the shadow space off RCX RDX R8 R9

	add	r8d, DWORD PTR [rdx+44]
$LN5@cv_write_s:

; 940  :                             //else 
; 941  :                               cnt -= 8;

	sub	r8d, 8

; 942  :                               if ((cnt & 7) != 0) cnt = (cnt + 7)&(-8);

	test	r8b, 7
	je	SHORT $LN4@cv_write_s
	add	r8d, 7
	and	r8d, -8
$LN4@cv_write_s:

; 943  :                             cv->ps_rr32->offset = cnt;

	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+4], r8d
$LN6@cv_write_s:

; 944  :                           }
; 945  :                         }
; 946  :                         /* x64 register numbers are different */
; 947  :                         if ( SpecialTable[ proc->e.procinfo->basereg ].cpu == P_64 )

	mov	rax, QWORD PTR [r12+104]
	movzx	ecx, WORD PTR [rax+130]
	lea	rax, QWORD PTR [rcx+rcx*2]
	cmp	WORD PTR SpecialTable[r15+rax*4+8], 112	; 00000070H
	jne	SHORT $LN3@cv_write_s

; 948  :                             cv->ps_rr32->reg = cv_get_x64_regno( proc->e.procinfo->basereg );

	lea	eax, DWORD PTR [rcx-115]
	cmp	ax, 7
	ja	SHORT $LN82@cv_write_s
	movzx	ecx, BYTE PTR reg64[rcx+r15-115]
	mov	rax, QWORD PTR [rbx]
	add	cx, 328					; 00000148H
	mov	WORD PTR [rax+8], cx

; 949  :                         else

	jmp	SHORT $LN2@cv_write_s

; 948  :                             cv->ps_rr32->reg = cv_get_x64_regno( proc->e.procinfo->basereg );

$LN82@cv_write_s:
	lea	eax, DWORD PTR [rcx-123]
	cmp	ax, 7
	ja	SHORT $LN81@cv_write_s
	mov	rax, QWORD PTR [rbx]
	add	cx, 213					; 000000d5H
	mov	WORD PTR [rax+8], cx

; 949  :                         else

	jmp	SHORT $LN2@cv_write_s

; 948  :                             cv->ps_rr32->reg = cv_get_x64_regno( proc->e.procinfo->basereg );

$LN81@cv_write_s:
	mov	rax, QWORD PTR [rbx]
	add	cx, 253					; 000000fdH
	mov	WORD PTR [rax+8], cx

; 949  :                         else

	jmp	SHORT $LN2@cv_write_s
$LN3@cv_write_s:

; 950  : #endif
; 951  :                             cv->ps_rr32->reg = GetRegNo( proc->e.procinfo->basereg ) + CV_REG_START32;

	movzx	ecx, BYTE PTR SpecialTable[r15+rax*4+10]
	mov	rax, QWORD PTR [rbx]
	add	cx, 17
	mov	WORD PTR [rax+8], cx
$LN2@cv_write_s:

; 962  :                         DebugMsg(( "cv_write_symbol(%X): proc=%s, S_BPREL32, var=%s [memt=%X typeref=%X]\n",
; 963  :                                   GetPos(cv->symbols,cv->ps), proc->sym.name, lcl->sym.name, lcl->sym.mem_type, cv->ps_br32->type ));
; 964  : #if STACKBASESUPP || AMD64_SUPPORT
; 965  :                     }
; 966  : #endif
; 967  :                 }
; 968  :                 lcl->sym.ext_idx1 = 0; /* to be safe, clear the temp. used field */

	mov	WORD PTR [rdi+96], 0

; 969  :                 cv->ps += len;

	movsxd	rax, esi
	add	QWORD PTR [rbx], rax
	mov	rcx, QWORD PTR [rbx]

; 970  :                 SetPrefixName( cv->ps, lcl->sym.name, lcl->sym.name_size );

	movzx	eax, BYTE PTR [rdi+80]
	mov	BYTE PTR [rcx], al
	inc	QWORD PTR [rbx]
	movzx	r8d, BYTE PTR [rdi+80]
	mov	rdx, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rbx]
	call	memcpy
	movzx	r11d, BYTE PTR [rdi+80]
	add	QWORD PTR [rbx], r11
	mov	rdi, QWORD PTR [rdi+120]
	test	rdi, rdi
	jne	$LL16@cv_write_s
$LN18@cv_write_s:

; 889  : 
; 890  :         /* scan local symbols again */
; 891  :         for ( i = 0; i < 2 ; i++ ) {

	inc	rbp
	cmp	rbp, 2
	jl	$LL19@cv_write_s

; 971  :             }
; 972  :         }
; 973  : 
; 974  :         cv->ps = checkflush( cv->symbols, cv->ps, sizeof( struct cv_symrec_endblk ), cv->param );

	mov	rcx, QWORD PTR [rbx+8]
	mov	r9, QWORD PTR [rbx+32]
	mov	rdx, QWORD PTR [rbx]
	mov	rax, QWORD PTR [rcx+104]
	mov	r8d, r14d
	call	QWORD PTR [rax+32]
	mov	QWORD PTR [rbx], rax

; 975  :         cv->ps_eb->sr.size = sizeof( struct cv_symrec_endblk ) - sizeof(uint_16);

	mov	WORD PTR [rax], 2

; 976  :         cv->ps_eb->sr.type = S_ENDBLK;

	mov	rax, QWORD PTR [rbx]
	mov	WORD PTR [rax+2], 6

; 977  :         cv->ps += sizeof( struct cv_symrec_endblk );

	add	QWORD PTR [rbx], 4
$LN20@cv_write_s:
	mov	r15, QWORD PTR [rsp+88]
	mov	r14, QWORD PTR [rsp+96]
	mov	r13, QWORD PTR [rsp+104]
	mov	r12, QWORD PTR [rsp+112]
	mov	rdi, QWORD PTR [rsp+152]
	mov	rsi, QWORD PTR [rsp+144]
	mov	rbp, QWORD PTR [rsp+136]
	mov	rbx, QWORD PTR [rsp+128]

; 978  :     }
; 979  :     return;
; 980  : }

	add	rsp, 120				; 00000078H
	ret	0
cv_write_symbol ENDP
_TEXT	ENDS
PUBLIC	cv_write_debug_tables
EXTRN	SymEnum:NEAR
EXTRN	szCVCompiler:BYTE
xdata	SEGMENT
$unwind$cv_write_debug_tables DD 072a01H
	DD	011742aH
	DD	010641eH
	DD	0f540fH
	DD	0c207H
xdata	ENDS
pdata	SEGMENT
$pdata$cv_write_debug_tables DD @imagerel($LN34#)
	DD	@imagerel($LN34#+197)
	DD	@imagerel($unwind$cv_write_debug_tables#)
pdata	ENDS
xdata	SEGMENT
$chain$3$cv_write_debug_tables DD 020521H
	DD	0e3405H
	DD	@imagerel($LN34#)
	DD	@imagerel($LN34#+197)
	DD	@imagerel($unwind$cv_write_debug_tables#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$cv_write_debug_tables DD @imagerel($LN34#+197)
	DD	@imagerel($LN34#+582)
	DD	@imagerel($chain$3$cv_write_debug_tables#)
pdata	ENDS
xdata	SEGMENT
$chain$4$cv_write_debug_tables DD 021H
	DD	@imagerel($LN34#)
	DD	@imagerel($LN34#+197)
	DD	@imagerel($unwind$cv_write_debug_tables#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$cv_write_debug_tables DD @imagerel($LN34#+582)
	DD	@imagerel($LN34#+869)
	DD	@imagerel($chain$4$cv_write_debug_tables#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 32
cv$ = 40
symbols$ = 112
types$ = 120
pv$ = 128
cv_write_debug_tables PROC NEAR

; 991  : {

$LN34:
	mov	r11, rsp
	sub	rsp, 104				; 00000068H

; 992  :     struct asym *sym;
; 993  :     int        i;
; 994  :     int        len;
; 995  :     char       *objname;
; 996  :     struct dbgcv cv;
; 997  : 
; 998  :     DebugMsg(( "cv_write_debug_tables enter\n"));
; 999  : 
; 1000 :     /**/myassert( types && symbols && types->sym.state == SYM_SEG &&  symbols->sym.state == SYM_SEG );
; 1001 : 
; 1002 :     cv.ps = symbols->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR [rcx+104]
	mov	QWORD PTR [r11+16], rbp
	mov	rbp, rcx
	mov	rax, QWORD PTR [rax+16]

; 1003 :     cv.symbols = symbols;

	mov	QWORD PTR [r11-56], rcx
	mov	QWORD PTR [r11+24], rsi
	mov	QWORD PTR [r11-64], rax

; 1004 :     cv.pt = types->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR [rdx+104]
	mov	QWORD PTR [r11+32], rdi
	mov	rcx, QWORD PTR [rax+16]

; 1005 :     cv.types   = types;
; 1006 :     cv.currtype = 0x1000; /* user-defined types start at 0x1000 */
; 1007 :     cv.level   = 0;
; 1008 :     cv.param = pv;
; 1009 : #if GENPTRTYPE
; 1010 :     cv.ptrtype[0] = 0;
; 1011 :     cv.ptrtype[1] = 0;
; 1012 :     cv.ptrtype[2] = 0;
; 1013 : #endif
; 1014 :     /* init types */
; 1015 :     //memset( pt, 0, 1024 ); /* it's ensured to have at least size 1024 */
; 1016 :     *(uint_32 *)cv.pt = Options.debug_symbols; /* "signature" */

	movzx	eax, BYTE PTR Options+2
	mov	QWORD PTR [r11-40], rdx
	mov	QWORD PTR [r11-48], rcx
	mov	WORD PTR cv$[rsp+44], 4096		; 00001000H
	mov	DWORD PTR cv$[rsp+40], 0
	mov	QWORD PTR [r11-32], r8
	mov	DWORD PTR [rcx], eax

; 1017 :     cv.pt += sizeof( uint_32 );
; 1018 : 
; 1019 :     /* init symbols */
; 1020 :     //memset( ps, 0, 1024 ); /* it's ensured to has at least size 1024 */
; 1021 :     *(uint_32 *)cv.ps = Options.debug_symbols; /* "signature" */

	mov	rax, QWORD PTR [r11-64]
	add	QWORD PTR [r11-48], 4
	movzx	ecx, BYTE PTR Options+2
	mov	rsi, rdx
	mov	DWORD PTR [rax], ecx

; 1022 :     cv.ps += sizeof(uint_32);

	mov	r8, QWORD PTR [r11-64]

; 1023 : 
; 1024 :     /* 1. symbol record: object name */
; 1025 :     objname = CurrFName[OBJ];

	mov	r9, QWORD PTR ModuleInfo+136
	add	r8, 4

; 1026 :     for ( i = strlen( objname ); i; i-- )

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, r9
	mov	QWORD PTR [r11-64], r8
	repne scasb
	not	rcx
	dec	rcx
	test	ecx, ecx
	mov	DWORD PTR i$[rsp], ecx
	je	SHORT $LN33@cv_write_d
	npad	10
$LL21@cv_write_d:

; 1027 :         if ( *(objname+i-1) == '/' || *(objname+i-1) == '\\' )

	movsxd	rax, ecx
	movzx	edx, BYTE PTR [rax+r9-1]
	cmp	dl, 47					; 0000002fH
	je	SHORT $LN33@cv_write_d
	cmp	dl, 92					; 0000005cH
	je	SHORT $LN33@cv_write_d
	dec	ecx
	mov	DWORD PTR i$[rsp], ecx
	jne	SHORT $LL21@cv_write_d
$LN33@cv_write_d:

; 1028 :             break;
; 1029 :     objname += i;

	movsxd	rax, ecx

; 1030 :     len = strlen( objname );

	mov	rcx, -1
	mov	QWORD PTR [rsp+112], rbx
	add	r9, rax
	xor	eax, eax

; 1031 :     cv.ps_on->sr.size = sizeof( struct cv_symrec_objname ) - sizeof(uint_16) + 1 + len;
; 1032 :     cv.ps_on->sr.type = S_OBJNAME;
; 1033 :     cv.ps_on->Signature = 1;

	mov	ebx, 1
	mov	rdi, r9

; 1034 :     DebugMsg(( "cv_write_debug_tables: at %X objname=%s\n", GetPos(cv.symbols,cv.ps), objname ));
; 1035 :     cv.ps += sizeof( struct cv_symrec_objname );
; 1036 :     SetPrefixName( cv.ps, objname, len );

	mov	rdx, r9
	repne scasb
	not	rcx
	dec	rcx
	movsxd	rdi, ecx
	lea	eax, DWORD PTR [rcx+7]
	mov	WORD PTR [r8], ax
	mov	rax, QWORD PTR cv$[rsp]
	mov	r8, rdi
	mov	WORD PTR [rax+2], 9
	mov	rax, QWORD PTR cv$[rsp]
	mov	DWORD PTR [rax+4], ebx
	mov	rax, QWORD PTR cv$[rsp]
	add	rax, 8
	mov	QWORD PTR cv$[rsp], rax
	mov	BYTE PTR [rax], cl
	mov	rcx, QWORD PTR cv$[rsp]
	inc	rcx
	mov	QWORD PTR cv$[rsp], rcx
	call	memcpy
	mov	r11, QWORD PTR cv$[rsp]
	add	r11, rdi

; 1037 : 
; 1038 :     /* 2. symbol record: compiler */
; 1039 :     len = strlen( szCVCompiler );

	xor	eax, eax
	lea	rdi, OFFSET FLAT:szCVCompiler
	mov	QWORD PTR cv$[rsp], r11
	mov	rcx, -1
	repne scasb
	not	rcx

; 1040 :     cv.ps_cp->sr.size = sizeof( struct cv_symrec_compile ) - sizeof(uint_16) + 1 + len;

	lea	eax, DWORD PTR [rcx+6]
	lea	rdi, QWORD PTR [rcx-1]
	mov	WORD PTR [r11], ax

; 1041 :     cv.ps_cp->sr.type = S_COMPILE;

	mov	rax, QWORD PTR cv$[rsp]
	mov	WORD PTR [rax+2], bx

; 1042 : #if AMD64_SUPPORT
; 1043 :     /* v2.11: use a valid 64-bit value */
; 1044 :     cv.ps_cp->machine = ( ModuleInfo.defOfssize == USE64 ? CV_MACH_AMD64 : ( ModuleInfo.curr_cpu & P_CPU_MASK ) >> 4 );

	cmp	BYTE PTR ModuleInfo+405, 2
	jne	SHORT $LN24@cv_write_d
	mov	edx, 208				; 000000d0H
	jmp	SHORT $LN25@cv_write_d
$LN24@cv_write_d:
	mov	edx, DWORD PTR ModuleInfo+392
	sar	edx, 4
	and	edx, 15
$LN25@cv_write_d:
	mov	rax, QWORD PTR cv$[rsp]
	mov	BYTE PTR [rax+4], dl

; 1045 : #else
; 1046 :     cv.ps_cp->machine = ( ModuleInfo.curr_cpu & P_CPU_MASK ) >> 4;
; 1047 : #endif
; 1048 :     /* 0 isnt possible, 1 is 8086 and 80186 */
; 1049 :     if ( cv.ps_cp->machine == 0 )

	mov	rax, QWORD PTR cv$[rsp]
	cmp	BYTE PTR [rax+4], 0
	jne	SHORT $LN16@cv_write_d

; 1050 :         cv.ps_cp->machine = CV_MACH_8086;

	mov	BYTE PTR [rax+4], bl
	mov	rax, QWORD PTR cv$[rsp]
$LN16@cv_write_d:

; 1051 :     cv.ps_cp->Language = CV_LANG_MASM;

	mov	BYTE PTR [rax+5], 3

; 1052 :     cv.ps_cp->flags = 0;

	mov	rax, QWORD PTR cv$[rsp]
	mov	WORD PTR [rax+6], 0

; 1053 :     if ( ModuleInfo.model ) {

	mov	ecx, DWORD PTR ModuleInfo+360
	test	ecx, ecx
	je	SHORT $LN15@cv_write_d

; 1054 :         if ( ModuleInfo.model == MODEL_HUGE )

	cmp	ecx, 6
	jne	SHORT $LN14@cv_write_d

; 1055 :             cv.ps_cp->AmbientData = CV_AMB_HUGE;

	mov	rcx, QWORD PTR cv$[rsp]
	movzx	eax, BYTE PTR [rcx+6]
	and	al, 31
	or	al, 64					; 00000040H
	mov	BYTE PTR [rcx+6], al

; 1056 :         else

	jmp	SHORT $LN13@cv_write_d
$LN14@cv_write_d:

; 1057 :             cv.ps_cp->AmbientData = ( SIZE_DATAPTR & ( 1 << ModuleInfo.model ) ? CV_AMB_FAR : CV_AMB_NEAR );

	mov	rdx, QWORD PTR cv$[rsp]
	mov	eax, ebx
	shl	eax, cl
	test	al, 104					; 00000068H
	movzx	eax, BYTE PTR [rdx+6]
	setne	cl
	and	al, 31
	shl	cl, 5
	or	cl, al
	mov	BYTE PTR [rdx+6], cl
$LN13@cv_write_d:

; 1058 :         cv.ps_cp->AmbientCode = ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ? CV_AMB_FAR : CV_AMB_NEAR );

	mov	ecx, DWORD PTR ModuleInfo+360
	mov	rdx, QWORD PTR cv$[rsp]
	shl	ebx, cl
	test	bl, 112					; 00000070H
	setne	al
	xor	al, BYTE PTR [rdx+7]
	and	al, 7
	xor	BYTE PTR [rdx+7], al
$LN15@cv_write_d:

; 1059 :     }
; 1060 :     DebugMsg(( "cv_write_debug_tables: at %X compiler=%s\n", GetPos(cv.symbols,cv.ps), szCVCompiler ));
; 1061 :     cv.ps += sizeof( struct cv_symrec_compile );

	mov	rax, QWORD PTR cv$[rsp]

; 1062 :     SetPrefixName( cv.ps, szCVCompiler, len );

	lea	rdx, OFFSET FLAT:szCVCompiler
	add	rax, 8
	mov	QWORD PTR cv$[rsp], rax
	mov	BYTE PTR [rax], dil
	mov	rcx, QWORD PTR cv$[rsp]
	movsxd	rdi, edi
	inc	rcx
	mov	r8, rdi
	mov	QWORD PTR cv$[rsp], rcx
	call	memcpy
	add	QWORD PTR cv$[rsp], rdi

; 1063 : 
; 1064 :     /* CurrSeg must be set for store_fixup(); v2.12: obsolete */
; 1065 :     //CurrSeg = symbols;
; 1066 : 
; 1067 :     /* scan symbol table for types */
; 1068 : 
; 1069 :     sym = NULL;
; 1070 :     while ( sym = SymEnum( sym, &i ) ) {

	lea	rdx, QWORD PTR i$[rsp]
	xor	ecx, ecx
	call	SymEnum
	mov	rbx, QWORD PTR [rsp+112]
	test	rax, rax
	mov	rdi, rax
	je	SHORT $LN11@cv_write_d
$LL12@cv_write_d:

; 1071 :         if ( sym->state == SYM_TYPE && sym->typekind != TYPE_TYPEDEF && sym->cvtyperef == 0 ) {

	cmp	DWORD PTR [rdi+40], 7
	jne	SHORT $LN10@cv_write_d
	cmp	BYTE PTR [rdi+74], 3
	je	SHORT $LN10@cv_write_d
	cmp	WORD PTR [rdi+72], 0
	jne	SHORT $LN10@cv_write_d

; 1072 :             /**/myassert( cv.currtype >= 0x1000 ); /* check for overflow */
; 1073 :             cv_write_type( &cv, sym );

	lea	rcx, QWORD PTR cv$[rsp]
	mov	rdx, rdi
	call	cv_write_type
$LN10@cv_write_d:
	lea	rdx, QWORD PTR i$[rsp]
	mov	rcx, rdi
	call	SymEnum
	test	rax, rax
	mov	rdi, rax
	jne	SHORT $LL12@cv_write_d
$LN11@cv_write_d:

; 1074 :         }
; 1075 :     }
; 1076 : 
; 1077 :     /* scan symbol table for SYM_TYPE, SYM_INTERNAL */
; 1078 : 
; 1079 :     sym = NULL;
; 1080 :     while ( sym = SymEnum( sym, &i ) ) {

	lea	rdx, QWORD PTR i$[rsp]
	xor	ecx, ecx
	call	SymEnum
	test	rax, rax
	mov	rdi, rax
	je	SHORT $LN8@cv_write_d
	npad	1
$LL9@cv_write_d:

; 1081 :         switch ( sym->state ) {

	mov	eax, DWORD PTR [rdi+40]
	movzx	ecx, BYTE PTR Options+3
	dec	eax
	je	SHORT $LN4@cv_write_d
	sub	eax, 6
	jne	SHORT $LN1@cv_write_d

; 1082 :         case SYM_TYPE: /* may create an S_UDT entry in the symbols table */
; 1083 :             if ( Options.debug_ext < CVEX_NORMAL ) /* v2.10: no UDTs for -Zi0 and -Zi1 */

	cmp	cl, 2
	jb	SHORT $LN1@cv_write_d
$LN4@cv_write_d:

; 1084 :                 break;
; 1085 :         case SYM_INTERNAL:
; 1086 :             if (
; 1087 : #if EQUATESYMS
; 1088 :                 /* emit constants if -Zi3 */
; 1089 :                 ( Options.debug_ext < CVEX_MAX ? sym->isequate : sym->variable )
; 1090 : #else
; 1091 :                 sym->isequate
; 1092 : #endif
; 1093 :                 || sym->predefined ) { /* EQUates? */

	cmp	cl, 3
	jae	SHORT $LN26@cv_write_d
	movzx	ecx, BYTE PTR [rdi+48]
	mov	al, cl
	shr	eax, 4
	and	eax, 1
	jmp	SHORT $LN27@cv_write_d
$LN26@cv_write_d:
	mov	cl, BYTE PTR [rdi+48]
	mov	al, cl
	shr	eax, 6
	and	eax, 1
$LN27@cv_write_d:
	test	eax, eax
	jne	SHORT $LN1@cv_write_d
	test	cl, 32					; 00000020H
	jne	SHORT $LN1@cv_write_d

; 1094 :                 break;
; 1095 :             }
; 1096 :             /**/myassert( cv.currtype >= 0x1000 ); /* check for overflow */
; 1097 :             cv_write_symbol( &cv, sym );

	lea	rcx, QWORD PTR cv$[rsp]
	mov	rdx, rdi
	call	cv_write_symbol
$LN1@cv_write_d:
	lea	rdx, QWORD PTR i$[rsp]
	mov	rcx, rdi
	call	SymEnum
	test	rax, rax
	mov	rdi, rax
	jne	SHORT $LL9@cv_write_d
$LN8@cv_write_d:

; 1098 :             break;
; 1099 :         }
; 1100 :     }
; 1101 : 
; 1102 :     /* final flush for both types and symbols.
; 1103 :      * use 'fictional' size of MAX_LINE_LEN * 2!
; 1104 :      */
; 1105 :     checkflush( cv.types, cv.pt, SIZE_CV_SEGBUF, cv.param );

	mov	rcx, QWORD PTR cv$[rsp+24]
	mov	r9, QWORD PTR cv$[rsp+32]
	mov	rdx, QWORD PTR cv$[rsp+16]
	mov	rax, QWORD PTR [rcx+104]
	mov	r8d, 2048				; 00000800H
	call	QWORD PTR [rax+32]

; 1106 :     checkflush( cv.symbols, cv.ps, SIZE_CV_SEGBUF, cv.param );

	mov	rcx, QWORD PTR cv$[rsp+8]
	mov	r9, QWORD PTR cv$[rsp+32]
	mov	rax, QWORD PTR [rcx+104]
	mov	rdx, QWORD PTR cv$[rsp]
	mov	r8d, 2048				; 00000800H
	call	QWORD PTR [rax+32]

; 1107 :     types->sym.max_offset = types->e.seginfo->current_loc;

	mov	rdx, QWORD PTR [rsi+104]
	mov	rdi, QWORD PTR [rsp+136]
	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR [rsi+64], eax
	mov	rsi, QWORD PTR [rsp+128]

; 1108 :     types->e.seginfo->start_loc = 0; /* required for COFF */

	mov	DWORD PTR [rdx+8], 0

; 1109 :     symbols->sym.max_offset = symbols->e.seginfo->current_loc;

	mov	rcx, QWORD PTR [rbp+104]
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rbp+64], eax
	mov	rbp, QWORD PTR [rsp+120]

; 1110 :     symbols->e.seginfo->start_loc = 0; /* required for COFF */

	mov	DWORD PTR [rcx+8], 0

; 1111 : 
; 1112 :     //CurrSeg = NULL;
; 1113 :     //Modend = TRUE;
; 1114 : 
; 1115 :     DebugMsg(( "cv_write_debug_tables exit, max type=%Xh\n", cv.currtype - 1 ));
; 1116 :     return;
; 1117 : }

	add	rsp, 104				; 00000068H
	ret	0
cv_write_debug_tables ENDP
_TEXT	ENDS
END
