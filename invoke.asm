; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	literalCnt
_BSS	SEGMENT
$SG6890	DB	01H DUP (?)
	ALIGN	4

$SG6873	DB	01H DUP (?)
	ALIGN	4

vcallpass DD	01H DUP (?)
literalCnt DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
fastcall_tab DQ	FLAT:ms32_fcstart
	DQ	FLAT:ms32_fcend
	DQ	FLAT:ms32_param
	DQ	FLAT:watc_fcstart
	DQ	FLAT:watc_fcend
	DQ	FLAT:watc_param
	DQ	FLAT:ms64_fcstart
	DQ	FLAT:ms64_fcend
	DQ	FLAT:ms64_param
	ORG $+8
vectorcall_tab DQ FLAT:ms32_fcstart
	DQ	FLAT:ms32_fcend
	DQ	FLAT:ms32_param
	DQ	FLAT:watc_fcstart
	DQ	FLAT:watc_fcend
	DQ	FLAT:watc_param
	DQ	FLAT:ms64_fcstart
	DQ	FLAT:ms64_fcend
	DQ	FLAT:ms64_param
regax	DD	09H
	DD	011H
	DD	073H
	ORG $+4
ms16_regs DD	09H
	DD	0bH
	DD	0cH
	ORG $+4
ms32_regs DD	012H
	DD	013H
ms64_regs DD	02H
	DD	03H
	DD	05bH
	DD	05cH
	DD	0aH
	DD	0bH
	DD	063H
	DD	064H
	DD	012H
	DD	013H
	DD	06bH
	DD	06cH
	DD	074H
	DD	075H
	DD	07bH
	DD	07cH
CONST	ENDS
_DATA	SEGMENT
$SG5775	DB	' lea %r, %s', 00H
$SG5781	DB	'movsx', 00H
	ORG $+2
$SG5782	DB	'movzx', 00H
	ORG $+6
$SG5783	DB	' %s %r, %s', 00H
	ORG $+5
$SG5785	DB	' mov %r, %s', 00H
	ORG $+4
$SG5786	DB	' mov %r, 0', 00H
	ORG $+5
$SG5790	DB	' mov %r, %s', 00H
	ORG $+4
$SG5818	DB	' sub %r, %d', 00H
	ORG $+4
$SG5827	DB	' add %r, %d', 00H
	ORG $+4
$SG5898	DB	' lea %r, %s', 00H
	ORG $+4
$SG5899	DB	' mov [%r+%u], %r', 00H
	ORG $+7
$SG5904	DB	' mov %r ptr [%r+%u], %r ( %s )', 00H
	ORG $+1
$SG5905	DB	' mov %r ptr [%r+%u], %r ( %s )', 00H
	ORG $+1
$SG5916	DB	' mov %r ptr [%r+%u], %s', 00H
$SG5920	DB	' mov %r ptr [%r+%u+0], %r (%s)', 00H
	ORG $+1
$SG5921	DB	' mov %r ptr [%r+%u+4], %r (%s)', 00H
	ORG $+1
$SG5923	DB	' mov %r ptr [%r+%u], %s', 00H
$SG5955	DB	' movsxd %r, %s', 00H
	ORG $+1
$SG5957	DB	' mov %r, %s', 00H
$SG5959	DB	's', 00H
	ORG $+2
$SG5960	DB	'z', 00H
	ORG $+6
$SG5961	DB	' mov%sx %r, %s', 00H
	ORG $+1
$SG5965	DB	' mov %r, %s', 00H
	ORG $+4
$SG5966	DB	' mov [%r+%u], %r', 00H
	ORG $+7
$SG5976	DB	' %s %r, %s', 00H
	ORG $+5
$SG5978	DB	' %s %r, %s', 00H
	ORG $+5
$SG5984	DB	' %s %r, %s', 00H
	ORG $+5
$SG5986	DB	' %s %r, %s', 00H
	ORG $+5
$SG5990	DB	'mov %r, %s', 00H
	ORG $+5
$SG5991	DB	'%s %r, %r', 00H
	ORG $+6
$SG5993	DB	'mov %r, %r ptr %s', 00H
	ORG $+6
$SG5994	DB	'%s %r, %r', 00H
	ORG $+6
$SG5998	DB	'%s %r,qword ptr %s', 00H
	ORG $+5
$SG6000	DB	'%s %r,dword ptr %s', 00H
	ORG $+5
$SG6003	DB	'%s %r,qword ptr %s', 00H
	ORG $+5
$SG6006	DB	'%s %r,dword ptr %s', 00H
	ORG $+5
$SG6022	DB	'%s %r,dword ptr [%s+%d]', 00H
$SG6037	DB	'%s %r,qword ptr [%s+%d]', 00H
$SG6044	DB	'%s %r,dword ptr [%s+%d]', 00H
$SG6058	DB	'%s %r,dword ptr [%s+%d]', 00H
$SG6072	DB	'%s %r,qword ptr [%s+%d]', 00H
$SG6086	DB	'%s %r,qword ptr [%s+%d]', 00H
$SG6100	DB	'%s %r,oword ptr %s', 00H
	ORG $+5
$SG6107	DB	'vmovaps %r,ymmword ptr %s', 00H
	ORG $+6
$SG6147	DB	'%s %r,dword ptr %s', 00H
	ORG $+5
$SG6149	DB	'%s %r,dword ptr [%s+%d]', 00H
$SG6158	DB	'%s %r,oword ptr %s', 00H
	ORG $+5
$SG6160	DB	'%s %r,oword ptr [%s+%d]', 00H
$SG6163	DB	'%s %r,oword ptr %s', 00H
	ORG $+5
$SG6174	DB	'%s %r,oword ptr %s', 00H
	ORG $+5
$SG6176	DB	'%s %r,oword ptr [%s+%d]', 00H
$SG6179	DB	'vmovups %r,oword ptr %s', 00H
$SG6190	DB	'vmovups %r,ymmword ptr %s', 00H
	ORG $+6
$SG6192	DB	'vmovups %r,ymmword ptr [%s+%d]', 00H
	ORG $+1
$SG6201	DB	'%s %r,dword ptr %s', 00H
	ORG $+5
$SG6203	DB	'mov %r, qword ptr %s', 00H
	ORG $+3
$SG6206	DB	'%s %r,qword ptr %s', 00H
	ORG $+5
$SG6208	DB	'mov %r, qword ptr %s', 00H
	ORG $+3
$SG6214	DB	'%s %r,oword ptr %s', 00H
	ORG $+5
$SG6216	DB	'%s %r,oword ptr %s', 00H
	ORG $+5
$SG6218	DB	'vmovups %r,oword ptr %s', 00H
$SG6222	DB	' lea %r, %s', 00H
	ORG $+4
$SG6224	DB	' lea %r, %s', 00H
	ORG $+4
$SG6225	DB	' mov qword ptr [%r+%u], %r', 00H
	ORG $+5
$SG6227	DB	' lea %r, %s', 00H
	ORG $+4
$SG6263	DB	' movsxd %r, %s', 00H
	ORG $+1
$SG6265	DB	' mov %r, %s', 00H
$SG6267	DB	's', 00H
	ORG $+2
$SG6268	DB	'z', 00H
	ORG $+6
$SG6269	DB	' mov%sx %r, %s', 00H
	ORG $+1
$SG6273	DB	'0', 00H
	ORG $+2
$SG6274	DB	'NULL', 00H
	ORG $+3
$SG6275	DB	'FALSE', 00H
	ORG $+6
$SG6277	DB	' xor %r, %r', 00H
	ORG $+4
$SG6288	DB	' mov %r ptr [%r+%u], %s', 00H
$SG6290	DB	' mov %r, %s', 00H
$SG6323	DB	'seg ', 00H
	ORG $+3
$SG6327	DB	'seg ', 00H
	ORG $+7
$SG6347	DB	' add %r, %u', 00H
	ORG $+4
$SG6350	DB	' add %r, %u', 00H
	ORG $+4
$SG6392	DB	'%r %s, %r', 00H
	ORG $+6
$SG6394	DB	'%r %s, %s', 00H
	ORG $+6
$SG6395	DB	'%r %s, %r %s', 00H
	ORG $+3
$SG6407	DB	'mov %s, %r (%s)', 00H
$SG6409	DB	'mov %s, %s', 00H
	ORG $+5
$SG6412	DB	'mov %s, %s', 00H
	ORG $+5
$SG6416	DB	'mov %s, %s', 00H
	ORG $+5
$SG6420	DB	'mov %s, %r %r %s[%u]', 00H
	ORG $+3
$SG6438	DB	' ', 00H
	ORG $+2
$SG6497	DB	'__ls', 00H
	ORG $+3
$SG6512	DB	'_DATA', 00H
	ORG $+2
$SG6514	DB	'%s%d', 00H
	ORG $+3
$SG6524	DB	'%s', 00H
	ORG $+1
$SG6527	DB	'L', 00H
	ORG $+2
$SG6534	DB	'_DATA', 00H
	ORG $+2
$SG6536	DB	'%s%d', 00H
	ORG $+3
$SG6546	DB	'%s', 00H
	ORG $+1
$SG6575	DB	' push %s', 00H
	ORG $+7
$SG6576	DB	' lea %r, %s', 00H
	ORG $+4
$SG6577	DB	' push %r', 00H
	ORG $+7
$SG6586	DB	' db 66h', 00H
$SG6587	DB	' push %r', 00H
	ORG $+7
$SG6589	DB	' push %s', 00H
	ORG $+7
$SG6591	DB	' mov %r, offset %s', 00H
	ORG $+5
$SG6592	DB	' push %r', 00H
	ORG $+7
$SG6598	DB	' pushd %r %s', 00H
	ORG $+3
$SG6602	DB	' pushw %r %s', 00H
	ORG $+3
$SG6604	DB	' push %r %s', 00H
	ORG $+4
$SG6613	DB	' db 66h', 00H
$SG6615	DB	' push %r', 00H
	ORG $+7
$SG6669	DB	' sub %r, 2', 00H
	ORG $+5
$SG6670	DB	' push word ptr %s+%u', 00H
	ORG $+3
$SG6672	DB	' push %r ptr %s+%u', 00H
	ORG $+5
$SG6677	DB	' movsx %r, %s', 00H
	ORG $+2
$SG6678	DB	' push %r', 00H
	ORG $+7
$SG6686	DB	' mov %r, %s', 00H
	ORG $+4
$SG6687	DB	' push %r', 00H
	ORG $+7
$SG6694	DB	' xor %r, %r', 00H
	ORG $+4
$SG6695	DB	' push %r', 00H
	ORG $+7
$SG6697	DB	' push 0', 00H
$SG6698	DB	' mov %r, %s', 00H
	ORG $+4
$SG6700	DB	' mov %r, 0', 00H
	ORG $+5
$SG6702	DB	' mov %r, %s', 00H
$SG6703	DB	' cbw', 00H
	ORG $+3
$SG6705	DB	' cwd', 00H
	ORG $+7
$SG6706	DB	' push %r', 00H
	ORG $+7
$SG6707	DB	' push %r', 00H
	ORG $+3
$SG6709	DB	'z', 00H
	ORG $+2
$SG6710	DB	's', 00H
	ORG $+6
$SG6711	DB	' mov%sx %r, %s', 00H
	ORG $+1
$SG6712	DB	' push %r', 00H
	ORG $+7
$SG6718	DB	' pushw 0', 00H
	ORG $+7
$SG6720	DB	' sub %r, 2', 00H
	ORG $+5
$SG6721	DB	' push %s', 00H
	ORG $+3
$SG6723	DB	'z', 00H
	ORG $+2
$SG6724	DB	's', 00H
	ORG $+6
$SG6725	DB	' mov%sx %r, %s', 00H
	ORG $+1
$SG6726	DB	' push %r', 00H
	ORG $+7
$SG6728	DB	' push %s', 00H
	ORG $+7
$SG6732	DB	' movsx %r, %s', 00H
	ORG $+2
$SG6733	DB	' push %r', 00H
	ORG $+7
$SG6736	DB	' mov %r, %s', 00H
$SG6737	DB	' cwd', 00H
	ORG $+7
$SG6738	DB	' push %r', 00H
	ORG $+7
$SG6739	DB	' push %r', 00H
	ORG $+7
$SG6741	DB	' push %s', 00H
	ORG $+7
$SG6746	DB	' xor %r, %r', 00H
	ORG $+4
$SG6747	DB	' push %r', 00H
	ORG $+7
$SG6749	DB	' pushw 0', 00H
	ORG $+7
$SG6750	DB	' push %s', 00H
	ORG $+7
$SG6772	DB	' mov %r, %s', 00H
	ORG $+4
$SG6776	DB	' movsx %r, %s', 00H
	ORG $+2
$SG6780	DB	' mov %r, %s', 00H
$SG6781	DB	' cbw', 00H
	ORG $+7
$SG6784	DB	' mov %r, %s', 00H
$SG6785	DB	' cwd', 00H
	ORG $+7
$SG6786	DB	' push %r', 00H
	ORG $+7
$SG6793	DB	' sub %r, 2', 00H
	ORG $+5
$SG6796	DB	' movsx %r, %s', 00H
	ORG $+2
$SG6798	DB	' pushw 0', 00H
	ORG $+7
$SG6800	DB	' pushw 0', 00H
	ORG $+7
$SG6805	DB	' xor %r, %r', 00H
	ORG $+4
$SG6806	DB	' push %r', 00H
	ORG $+3
$SG6812	DB	's', 00H
	ORG $+2
$SG6813	DB	'z', 00H
	ORG $+6
$SG6814	DB	' mov%sx %r, %s', 00H
	ORG $+1
$SG6817	DB	' mov %r, %s', 00H
$SG6820	DB	' cbw', 00H
	ORG $+7
$SG6823	DB	' mov %r, 0', 00H
	ORG $+5
$SG6828	DB	' push %r', 00H
	ORG $+7
$SG6855	DB	' mov %r, %s', 00H
	ORG $+4
$SG6858	DB	' xor %r, %r', 00H
	ORG $+4
$SG6861	DB	' xor %r, %r', 00H
	ORG $+4
$SG6863	DB	' mov %r, %r (%s)', 00H
	ORG $+7
$SG6864	DB	' push %r', 00H
	ORG $+7
$SG6867	DB	' mov %r, %r (%s)', 00H
	ORG $+7
$SG6870	DB	' push %r', 00H
	ORG $+3
$SG6882	DB	'w', 00H
	ORG $+2
$SG6885	DB	'w', 00H
	ORG $+2
$SG6888	DB	'd', 00H
	ORG $+2
$SG6891	DB	' push%s (%s) shr 32t', 00H
	ORG $+3
$SG6894	DB	'd', 00H
	ORG $+6
$SG6896	DB	' pushw %r (%s)', 00H
	ORG $+1
$SG6897	DB	'w', 00H
	ORG $+6
$SG6902	DB	' pushd %r (%s)', 00H
	ORG $+1
$SG6903	DB	'd', 00H
	ORG $+6
$SG6906	DB	' push%s %r (%s)', 00H
$SG6908	DB	' push%s %s', 00H
	ORG $+1
$SG7028	DB	' call ', 00H
	ORG $+5
$SG7033	DB	' externdef %r %s: %r %r', 00H
$SG7035	DB	' externdef %s: %r %r', 00H
	ORG $+3
$SG7040	DB	' add %r, %u', 00H
	ORG $+4
$SG7042	DB	' add %r, %u', 00H
_DATA	ENDS
EXTRN	GetSymOfssize:NEAR
_BSS	SEGMENT
fcscratch DD	01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$ms32_fcstart DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$ms32_fcstart DD @imagerel(ms32_fcstart#)
	DD	@imagerel(ms32_fcstart#+82)
	DD	@imagerel($unwind$ms32_fcstart#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\invoke.c
pdata	ENDS
_TEXT	SEGMENT
proc$ = 48
numparams$ = 56
start$ = 64
tokenarray$ = 72
value$ = 80
ms32_fcstart PROC NEAR

; 149  : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 150  :     struct dsym *param;
; 151  :     DebugMsg1(("ms32_fcstart(proc=%s, ofs=%u)\n", proc->sym.name, GetSymOfssize( &proc->sym ) ));
; 152  :     if ( GetSymOfssize( &proc->sym ) == USE16 )

	call	GetSymOfssize
	test	eax, eax
	jne	SHORT $LN5@ms32_fcsta

; 159  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN5@ms32_fcsta:

; 153  :         return( 0 );
; 154  :     /* v2.07: count number of register params */
; 155  :     for ( param = proc->e.procinfo->paralist ; param ; param = param->nextparam )

	mov	rax, QWORD PTR [rbx+104]
	mov	rcx, QWORD PTR [rax+8]
	test	rcx, rcx
	je	SHORT $LN2@ms32_fcsta
	mov	eax, DWORD PTR fcscratch
	npad	5
$LL4@ms32_fcsta:

; 156  :         if ( param->sym.state == SYM_TMACRO )

	cmp	DWORD PTR [rcx+40], 10
	jne	SHORT $LN3@ms32_fcsta

; 157  :             fcscratch++;

	inc	eax
$LN3@ms32_fcsta:

; 153  :         return( 0 );
; 154  :     /* v2.07: count number of register params */
; 155  :     for ( param = proc->e.procinfo->paralist ; param ; param = param->nextparam )

	mov	rcx, QWORD PTR [rcx+120]
	test	rcx, rcx
	jne	SHORT $LL4@ms32_fcsta

; 157  :             fcscratch++;

	mov	DWORD PTR fcscratch, eax
$LN2@ms32_fcsta:

; 158  :     return( 1 );

	mov	eax, 1

; 159  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ms32_fcstart ENDP
; Function compile flags: /Ogtpy
proc$ = 8
numparams$ = 16
value$ = 24
ms32_fcend PROC NEAR

; 164  :     /* nothing to do */
; 165  :     return;
; 166  : }

	ret	0
ms32_fcend ENDP
_TEXT	ENDS
EXTRN	SpecialTable:BYTE
EXTRN	ModuleInfo:BYTE
EXTRN	SizeFromRegister:NEAR
EXTRN	SizeFromMemtype:NEAR
EXTRN	AddLineQueueX:NEAR
EXTRN	__ImageBase:BYTE
xdata	SEGMENT
$unwind$ms32_param DD 0d8c01H
	DD	07748cH
	DD	095487H
	DD	06c437H
	DD	086432H
	DD	05d413H
	DD	0a340eH
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$ms32_param DD @imagerel(ms32_param#)
	DD	@imagerel(ms32_param#+451)
	DD	@imagerel($unwind$ms32_param#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
proc$ = 96
index$ = 104
param$ = 112
addr$ = 120
opnd$ = 128
paramvalue$ = 136
r0used$ = 144
ms32_param PROC NEAR

; 170  : {

	sub	rsp, 88					; 00000058H

; 171  :     enum special_token const *pst;
; 172  : 
; 173  :     DebugMsg1(("ms32_param(proc=%s, ofs=%u, index=%u, param=%s) fcscratch=%u\n", proc->sym.name, proc->sym.Ofssize, index, param->sym.name, fcscratch ));
; 174  :     if ( param->sym.state != SYM_TMACRO )

	cmp	DWORD PTR [r8+40], 10
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+40], r13
	mov	r13, r8
	movzx	ebx, r9b
	je	SHORT $LN12@ms32_param

; 175  :         return( 0 );

	xor	eax, eax
	mov	r13, QWORD PTR [rsp+40]
	mov	rbx, QWORD PTR [rsp+80]

; 210  : }

	add	rsp, 88					; 00000058H
	ret	0
$LN12@ms32_param:
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+48], r12

; 176  :     if ( GetSymOfssize( &proc->sym ) == USE16 ) {

	call	GetSymOfssize
	test	eax, eax
	jne	SHORT $LN11@ms32_param

; 177  :         pst = ms16_regs + fcscratch;

	movsxd	rcx, DWORD PTR fcscratch
	lea	r12, OFFSET FLAT:__ImageBase
	lea	rsi, QWORD PTR ms16_regs[r12+rcx*4]

; 178  :         fcscratch++;

	inc	ecx
	mov	DWORD PTR fcscratch, ecx

; 179  :     } else {

	jmp	SHORT $LN10@ms32_param
$LN11@ms32_param:

; 180  :         fcscratch--;

	mov	eax, DWORD PTR fcscratch

; 181  :         pst = ms32_regs + fcscratch;

	lea	r12, OFFSET FLAT:__ImageBase
	dec	eax
	movsxd	rcx, eax
	mov	DWORD PTR fcscratch, eax
	lea	rsi, QWORD PTR ms32_regs[r12+rcx*4]
$LN10@ms32_param:

; 182  :     }
; 183  :     if ( addr )

	test	bl, bl
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+56], rdi
	je	SHORT $LN9@ms32_param

; 184  :         AddLineQueueX( " lea %r, %s", *pst, paramvalue );

	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, DWORD PTR [rsi]
	lea	rcx, OFFSET FLAT:$SG5775
	call	AddLineQueueX

; 185  :     else {

	jmp	$LN4@ms32_param
$LN9@ms32_param:

; 186  :         enum special_token reg = *pst;
; 187  :         int size;
; 188  :         /* v2.08: adjust register if size of operand won't require the full register */
; 189  :         if ( ( opnd->kind != EXPR_CONST ) &&
; 190  :             ( size = SizeFromMemtype( param->sym.mem_type, USE_EMPTY, param->sym.type ) ) < SizeFromRegister( *pst ) ) {

	mov	rdi, QWORD PTR opnd$[rsp]
	movsxd	rbp, DWORD PTR [rsi]
	cmp	DWORD PTR [rdi+60], 0
	je	$LN7@ms32_param
	mov	r8, QWORD PTR [r13+88]
	mov	ecx, DWORD PTR [r13+44]
	mov	edx, 254				; 000000feH
	call	SizeFromMemtype
	mov	ecx, DWORD PTR [rsi]
	mov	ebx, eax
	call	SizeFromRegister
	cmp	ebx, eax
	jge	SHORT $LN7@ms32_param

; 191  :             if (( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN6@ms32_param

; 192  :                 AddLineQueueX( " %s %r, %s", ( param->sym.mem_type & MT_SIGNED ) ? "movsx" : "movzx", reg, paramvalue );

	test	BYTE PTR [r13+44], 64			; 00000040H
	mov	r9, QWORD PTR paramvalue$[rsp]
	lea	rax, OFFSET FLAT:$SG5781
	lea	rdx, OFFSET FLAT:$SG5782
	lea	rcx, OFFSET FLAT:$SG5783
	mov	r8d, ebp
	cmovne	rdx, rax
	call	AddLineQueueX

; 193  :             } else {

	jmp	SHORT $LN4@ms32_param
$LN6@ms32_param:

; 194  :                 /* this is currently always UNSIGNED */
; 195  :                 AddLineQueueX( " mov %r, %s", T_AL + GetRegNo( reg ), paramvalue );

	mov	r8, QWORD PTR paramvalue$[rsp]
	lea	rbx, QWORD PTR [rbp+rbp*2]
	lea	rcx, OFFSET FLAT:$SG5785
	movzx	edx, BYTE PTR SpecialTable[r12+rbx*4+10]
	inc	edx
	call	AddLineQueueX

; 196  :                 AddLineQueueX( " mov %r, 0", T_AH + GetRegNo( reg ) );

	movzx	edx, BYTE PTR SpecialTable[r12+rbx*4+10]
	lea	rcx, OFFSET FLAT:$SG5786
	add	edx, 5
	call	AddLineQueueX

; 197  :             }
; 198  :         } else {

	jmp	SHORT $LN4@ms32_param
$LN7@ms32_param:

; 199  :             /* v2.08: optimization */
; 200  :             if ( opnd->kind == EXPR_REG && opnd->indirect == 0 && opnd->base_reg ) {

	cmp	DWORD PTR [rdi+60], 2
	jne	SHORT $LN2@ms32_param
	test	BYTE PTR [rdi+72], 1
	jne	SHORT $LN2@ms32_param
	mov	rax, QWORD PTR [rdi+24]
	test	rax, rax
	je	SHORT $LN2@ms32_param

; 201  :                 if ( opnd->base_reg->tokval == reg )

	cmp	DWORD PTR [rax+16], ebp

; 202  :                     return( 1 );

	je	SHORT $LN1@ms32_param
$LN2@ms32_param:

; 203  :             }
; 204  :             AddLineQueueX( " mov %r, %s", reg, paramvalue );

	mov	r8, QWORD PTR paramvalue$[rsp]
	lea	rcx, OFFSET FLAT:$SG5790
	mov	edx, ebp
	call	AddLineQueueX
$LN4@ms32_param:

; 205  :         }
; 206  :     }
; 207  :     if ( *pst == T_AX )

	cmp	DWORD PTR [rsi], 9
	jne	SHORT $LN1@ms32_param

; 208  :         *r0used |= R0_USED;

	mov	rax, QWORD PTR r0used$[rsp]
	or	BYTE PTR [rax], 1
$LN1@ms32_param:
	mov	rdi, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	r12, QWORD PTR [rsp+48]
	mov	r13, QWORD PTR [rsp+40]
	mov	rbx, QWORD PTR [rsp+80]

; 209  :     return( 1 );

	mov	eax, 1

; 210  : }

	add	rsp, 88					; 00000058H
	ret	0
ms32_param ENDP
_TEXT	ENDS
EXTRN	sym_ReservedStack:QWORD
xdata	SEGMENT
$unwind$ms64_fcstart DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$ms64_fcstart DD @imagerel(ms64_fcstart#)
	DD	@imagerel(ms64_fcstart#+191)
	DD	@imagerel($unwind$ms64_fcstart#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
proc$ = 48
numparams$ = 56
start$ = 64
tokenarray$ = 72
value$ = 80
ms64_fcstart PROC NEAR

; 215  : {

	sub	rsp, 40					; 00000028H

; 216  :     /* v2.04: VARARG didn't work */
; 217  :     if ( proc->e.procinfo->has_vararg ) {

	mov	rax, QWORD PTR [rcx+104]
	test	BYTE PTR [rax+128], 1
	je	SHORT $LN9@ms64_fcsta

; 218  :         //numparams = ( tokenarray[start].token != T_FINAL ? 1 : 0 );
; 219  :         for ( numparams = 0; tokenarray[start].token != T_FINAL; start++ )

	movsxd	rax, r8d
	xor	edx, edx
	shl	rax, 5
	cmp	BYTE PTR [rax+r9], dl
	je	SHORT $LN9@ms64_fcsta
	lea	rcx, QWORD PTR [rax+r9]
	movzx	eax, BYTE PTR [rax+r9]
	npad	7
$LL11@ms64_fcsta:

; 220  :         if (tokenarray[start].token == T_COMMA) {

	cmp	al, 44					; 0000002cH
	jne	SHORT $LN10@ms64_fcsta

; 221  :           numparams++;

	inc	edx
$LN10@ms64_fcsta:

; 218  :         //numparams = ( tokenarray[start].token != T_FINAL ? 1 : 0 );
; 219  :         for ( numparams = 0; tokenarray[start].token != T_FINAL; start++ )

	mov	al, BYTE PTR [rcx+32]
	add	rcx, 32					; 00000020H
	test	al, al
	jne	SHORT $LL11@ms64_fcsta
$LN9@ms64_fcsta:

; 222  : 
; 223  :         }
; 224  :     }
; 225  : 	if(sym_ReservedStack)

	mov	rax, QWORD PTR sym_ReservedStack
	test	rax, rax
	je	SHORT $LN7@ms64_fcsta

; 226  : 		sym_ReservedStack->hasinvoke = 1;  //added by habran

	mov	DWORD PTR [rax+24], 1
$LN7@ms64_fcsta:

; 227  : 	DebugMsg1(("ms64_fcstart(%s, numparams=%u) vararg=%u\n", proc->sym.name, numparams, proc->e.procinfo->has_vararg ));
; 228  :     if ( numparams < 4 )

	cmp	edx, 4
	jge	SHORT $LN6@ms64_fcsta

; 229  :         numparams = 4;

	mov	edx, 4
	jmp	SHORT $LN4@ms64_fcsta
$LN6@ms64_fcsta:

; 230  :     else if ( numparams & 1 )

	test	dl, 1
	je	SHORT $LN4@ms64_fcsta

; 231  :         numparams++;

	inc	edx
$LN4@ms64_fcsta:

; 232  :     *value = numparams;

	mov	rax, QWORD PTR value$[rsp]
	mov	DWORD PTR [rax], edx

; 233  :     if ( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) {

	test	BYTE PTR ModuleInfo+413, 2
	je	SHORT $LN3@ms64_fcsta

; 234  :         if ( ( numparams * sizeof( uint_64 ) ) > sym_ReservedStack->value )

	mov	r8, QWORD PTR sym_ReservedStack
	movsxd	rcx, edx
	movsxd	rax, DWORD PTR [r8+16]
	shl	rcx, 3
	cmp	rcx, rax
	jbe	SHORT $LN17@ms64_fcsta

; 235  :             sym_ReservedStack->value = numparams * sizeof( uint_64 );

	lea	eax, DWORD PTR [rdx*8]
	mov	DWORD PTR [r8+16], eax

; 238  :     /* since Win64 fastcall doesn't push, it's a better/faster strategy to
; 239  :      * handle the arguments from left to right.
; 240  :      */
; 241  :     return( 0 );

	xor	eax, eax

; 242  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@ms64_fcsta:

; 236  :     } else
; 237  :         AddLineQueueX( " sub %r, %d", T_RSP, numparams * sizeof( uint_64 ) );

	movsxd	r8, edx
	lea	rcx, OFFSET FLAT:$SG5818
	mov	edx, 119				; 00000077H
	shl	r8, 3
	call	AddLineQueueX
$LN17@ms64_fcsta:

; 238  :     /* since Win64 fastcall doesn't push, it's a better/faster strategy to
; 239  :      * handle the arguments from left to right.
; 240  :      */
; 241  :     return( 0 );

	xor	eax, eax

; 242  : }

	add	rsp, 40					; 00000028H
	ret	0
ms64_fcstart ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$ms64_fcend DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$ms64_fcend DD @imagerel(ms64_fcend#)
	DD	@imagerel(ms64_fcend#+39)
	DD	@imagerel($unwind$ms64_fcend#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
proc$ = 48
numparams$ = 56
value$ = 64
ms64_fcend PROC NEAR

; 246  : {

	sub	rsp, 40					; 00000028H

; 247  :     /* use <value>, which has been set by ms64_fcstart() */
; 248  :     if ( !( ModuleInfo.win64_flags & W64F_AUTOSTACKSP ) )

	test	BYTE PTR ModuleInfo+413, 2
	jne	SHORT $LN1@ms64_fcend

; 249  :         AddLineQueueX( " add %r, %d", T_RSP, value * 8 );

	lea	rcx, OFFSET FLAT:$SG5827
	shl	r8d, 3
	mov	edx, 119				; 00000077H
	call	AddLineQueueX
$LN1@ms64_fcend:

; 250  :     return;
; 251  : }

	add	rsp, 40					; 00000028H
	ret	0
ms64_fcend ENDP
_TEXT	ENDS
EXTRN	_stricmp:NEAR
EXTRN	MOVE_SINGLE:QWORD
EXTRN	MOVE_DOUBLE:QWORD
EXTRN	MOVE_SIMD_QWORD:QWORD
EXTRN	MOVE_SIMD_DWORD:QWORD
EXTRN	MOVE_ALIGNED_FLOAT:QWORD
EXTRN	EmitErr:NEAR
xdata	SEGMENT
$unwind$ms64_param DD 011dd01H
	DD	0c64ddH
	DD	07f439H
	DD	08e435H
	DD	09d431H
	DD	0ac425H
	DD	0b741dH
	DD	0d5419H
	DD	0e3415H
	DD	0e211H
xdata	ENDS
pdata	SEGMENT
$pdata$ms64_param DD @imagerel(ms64_param#)
	DD	@imagerel(ms64_param#+6777)
	DD	@imagerel($unwind$ms64_param#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
membersize$5$ = 128
reg$ = 128
proc$ = 128
index$ = 136
param$ = 144
addr$ = 152
opnd$ = 160
paramvalue$ = 168
regs_used$ = 176
ms64_param PROC NEAR

; 270  : {

	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, rsp
	sub	rsp, 120				; 00000078H
	mov	QWORD PTR [rax-8], rbx
	mov	QWORD PTR [rax-16], rbp
	mov	QWORD PTR [rax-32], rdi

; 271  :     uint_32 size;
; 272  :     uint_32 psize;
; 273  :     char name[256];
; 274  :     char buff[256];
; 275  :     uint_64 fvalue[2];
; 276  :     int reg;
; 277  :     int reg2;
; 278  :     int i;
; 279  :     int j = 0;
; 280  : 	int tCount = 0;
; 281  : 	int freevecregs = 0;
; 282  : 	int vecidx = -1;
; 283  :     int membersize = 0;     /* used for vectorcall array */
; 284  :     int memberCount= 0;     /* used for vectorcall array */
; 285  :     int base;
; 286  :     struct proc_info *info = proc->e.procinfo; 

	mov	rdi, QWORD PTR [rcx+104]
	mov	QWORD PTR [rax-40], r12

; 287  :     struct dsym *t = NULL; /* used for vectorcall array member size */
; 288  :     bool destroyed = FALSE;
; 289  :     struct asym *sym;
; 290  :     //__debugbreak();
; 291  :     DebugMsg1(("ms64_param(%s, index=%u, param.memtype=%Xh, addr=%u) enter\n", proc->sym.name, index, param->sym.mem_type, addr ));
; 292  :     /* v2.11: default size is 32-bit, not 64-bit */
; 293  :     if ( param->sym.is_vararg ) {

	mov	r12, QWORD PTR opnd$[rsp]
	mov	QWORD PTR [rax-48], r13
	mov	QWORD PTR [rax-56], r14
	mov	QWORD PTR [rax-64], r15
	xor	r15b, r15b
	xor	ebx, ebx
	test	BYTE PTR [r8+55], 32			; 00000020H
	movzx	eax, r9b
	mov	r14, r8
	movsxd	rbp, edx
	je	SHORT $LN330@ms64_param

; 294  :         psize = 0;
; 295  :         
; 296  :         if ( addr || opnd->instr == T_OFFSET )

	test	r9b, r9b
	jne	SHORT $LN328@ms64_param
	cmp	DWORD PTR [r12+56], 241			; 000000f1H
	je	SHORT $LN328@ms64_param

; 298  :         else if ( opnd->kind == EXPR_REG && opnd->indirect == FALSE )

	cmp	DWORD PTR [r12+60], 2
	jne	SHORT $LN326@ms64_param
	test	BYTE PTR [r12+72], 1
	jne	SHORT $LN326@ms64_param

; 299  :             psize = SizeFromRegister( opnd->base_reg->tokval );

	mov	rax, QWORD PTR [r12+24]
	mov	ecx, DWORD PTR [rax+16]
	call	SizeFromRegister
	mov	r13d, eax
$LN324@ms64_param:

; 302  :         if ( psize < 4 )

	cmp	r13d, 4
	jae	SHORT $LN322@ms64_param
$LN381@ms64_param:

; 303  :             psize = 4;

	mov	r13d, 4

; 304  : 
; 305  :     } else

	jmp	SHORT $LN322@ms64_param
$LN326@ms64_param:

; 300  :         else if ( opnd->mem_type != MT_EMPTY )

	mov	ecx, DWORD PTR [r12+64]
	cmp	ecx, 192				; 000000c0H
	je	SHORT $LN381@ms64_param

; 301  :             psize = SizeFromMemtype( opnd->mem_type, USE64, opnd->type );

	mov	r8, QWORD PTR [r12+96]
	mov	edx, 2
	call	SizeFromMemtype
	mov	r13d, eax
	jmp	SHORT $LN324@ms64_param
$LN328@ms64_param:

; 297  :             psize = 8;

	mov	r13d, 8

; 302  :         if ( psize < 4 )

	jmp	SHORT $LN322@ms64_param
$LN330@ms64_param:

; 306  :         psize = SizeFromMemtype( param->sym.mem_type, USE64, param->sym.type );

	mov	r8, QWORD PTR [r8+88]
	mov	ecx, DWORD PTR [r14+44]
	mov	edx, 2
	call	SizeFromMemtype
	mov	r13d, eax
$LN322@ms64_param:

; 307  : 
; 308  : 	if (vcallpass == 1)

	mov	r11d, DWORD PTR vcallpass
	mov	r8d, 1
	mov	QWORD PTR [rsp+96], rsi
	cmp	r11d, r8d
	lea	r10, OFFSET FLAT:__ImageBase
	je	$LN385@ms64_param

; 309  : 		goto vcall;
; 310  : 
; 311  :     /* check for register overwrites; v2.11: moved out the if( index >= 4 ) block */
; 312  :     if ( opnd->base_reg != NULL ) {

	mov	rax, QWORD PTR [r12+24]
	test	rax, rax
	je	SHORT $LN384@ms64_param

; 313  :         reg = opnd->base_reg->tokval;

	movsxd	rsi, DWORD PTR [rax+16]

; 314  :         if ( GetValueSp( reg ) & OP_R ) {

	lea	rcx, QWORD PTR [rsi+rsi*2]
	mov	edx, DWORD PTR SpecialTable[r10+rcx*4]
	test	dl, 15
	je	SHORT $LN386@ms64_param

; 315  :             i = GetRegNo( reg );

	movzx	ecx, BYTE PTR SpecialTable[r10+rcx*4+10]

; 316  :             if ( REGPAR_WIN64 & ( 1 << i ) ) {

	mov	eax, r8d
	shl	eax, cl
	test	eax, 774				; 00000306H
	je	SHORT $LN318@ms64_param

; 317  :                 base = GetParmIndex( i );

	cmp	ecx, 8
	jl	SHORT $LN333@ms64_param
	add	ecx, -6
	jmp	SHORT $LN334@ms64_param
$LN333@ms64_param:
	dec	ecx
$LN334@ms64_param:

; 318  :                 if ( *regs_used & ( 1 << ( base + RPAR_START ) ) )

	mov	r9, QWORD PTR regs_used$[rsp]
	add	ecx, 3
	mov	edx, r8d
	shl	edx, cl
	test	dl, BYTE PTR [r9]
	je	SHORT $LN315@ms64_param

; 319  :                     destroyed = TRUE;

	movzx	r15d, r8b

; 320  :             } else if ( (*regs_used & R0_USED ) && ( ( GetValueSp( reg ) & OP_A ) || reg == T_AH ) ) {

	jmp	SHORT $LN315@ms64_param
$LN318@ms64_param:
	mov	r9, QWORD PTR regs_used$[rsp]
	test	BYTE PTR [r9], r8b
	je	SHORT $LN315@ms64_param
	bt	edx, 9
	jb	SHORT $LN314@ms64_param
	cmp	esi, 5
	jne	SHORT $LN315@ms64_param
$LN314@ms64_param:

; 321  :                 destroyed = TRUE;

	mov	r15b, r8b
	jmp	SHORT $LN315@ms64_param
$LN384@ms64_param:
	mov	esi, DWORD PTR reg$[rsp]
	mov	r9, QWORD PTR regs_used$[rsp]

; 966  : 					  {
; 967  : 						  *regs_used |= (1 << (index + RPAR_START)); /* Flag the appropriate GP register as used now for the reference */

	jmp	SHORT $LN315@ms64_param
$LN386@ms64_param:
	mov	r9, QWORD PTR regs_used$[rsp]
$LN315@ms64_param:

; 322  :             }
; 323  :         }
; 324  :     }
; 325  :     if ( opnd->idx_reg != NULL ) {

	mov	rax, QWORD PTR [r12+32]
	test	rax, rax
	je	SHORT $LN308@ms64_param

; 326  :         reg2 = opnd->idx_reg->tokval;

	movsxd	r8, DWORD PTR [rax+16]

; 327  :         if ( GetValueSp( reg2 ) & OP_R ) {

	lea	rcx, QWORD PTR [r8+r8*2]
	mov	edx, DWORD PTR SpecialTable[r10+rcx*4]
	test	dl, 15
	je	SHORT $LN308@ms64_param

; 328  :             i = GetRegNo( reg2 );

	movzx	ecx, BYTE PTR SpecialTable[r10+rcx*4+10]

; 329  :             if ( REGPAR_WIN64 & ( 1 << i ) ) {

	mov	eax, 1
	shl	eax, cl
	test	eax, 774				; 00000306H
	je	SHORT $LN311@ms64_param

; 330  :                 base = GetParmIndex( i );

	cmp	ecx, 8
	jl	SHORT $LN335@ms64_param
	add	ecx, -6
	jmp	SHORT $LN336@ms64_param
$LN335@ms64_param:
	dec	ecx
$LN336@ms64_param:

; 331  :                 if ( *regs_used & ( 1 << ( base + RPAR_START ) ) )

	add	ecx, 3
	mov	edx, 1
	shl	edx, cl
	test	dl, BYTE PTR [r9]
	jne	SHORT $LN382@ms64_param

; 332  :                     destroyed = TRUE;
; 333  :             } else if ( (*regs_used & R0_USED ) && ( ( GetValueSp( reg2 ) & OP_A ) || reg2 == T_AH ) ) {

	jmp	SHORT $LN308@ms64_param
$LN311@ms64_param:
	test	BYTE PTR [r9], 1
	je	SHORT $LN308@ms64_param
	bt	edx, 9
	jb	SHORT $LN382@ms64_param
	cmp	r8d, 5

; 334  :                 destroyed = TRUE;
; 335  :             }
; 336  :         }
; 337  :     }
; 338  :     if ( destroyed ) {

	je	SHORT $LN382@ms64_param
$LN308@ms64_param:
	test	r15b, r15b
	je	SHORT $LN391@ms64_param
$LN382@ms64_param:

; 339  :         EmitErr( REGISTER_VALUE_OVERWRITTEN_BY_INVOKE );

	mov	ecx, 165				; 000000a5H
	call	EmitErr

; 340  :         *regs_used = 0;

	mov	r15, QWORD PTR regs_used$[rsp]
	mov	r11d, DWORD PTR vcallpass
	mov	BYTE PTR [r15], bl
	lea	r10, OFFSET FLAT:__ImageBase
	jmp	SHORT $LN306@ms64_param
$LN391@ms64_param:

; 1041 : 					  if (*regs_used & (1 << (i + RPAR_START)))

	mov	r15, QWORD PTR regs_used$[rsp]
$LN306@ms64_param:

; 341  :     }
; 342  :     if (((proc->sym.langtype == LANG_VECTORCALL)&&( index >= 6 ))||
; 343  :     ((proc->sym.langtype == LANG_FASTCALL)&&( index >= 4 ))) {

	mov	rdx, QWORD PTR proc$[rsp]
	mov	r8d, DWORD PTR [rdx+84]
	cmp	r8d, 8
	jne	SHORT $LN303@ms64_param
	cmp	ebp, 6
	jge	SHORT $LN304@ms64_param
$LN303@ms64_param:
	cmp	r8d, 7
	jne	$LN305@ms64_param
	cmp	ebp, 4
	jl	$LN305@ms64_param
$LN304@ms64_param:

; 344  :         if ( addr  ) { //|| psize > 8

	cmp	BYTE PTR addr$[rsp], bl
	je	SHORT $LN302@ms64_param

; 345  :             if ( psize == 4 )

	cmp	r13d, 4
	jne	SHORT $LN301@ms64_param

; 346  :                 i = T_EAX;

	lea	esi, QWORD PTR [r13+13]

; 347  :             else {

	jmp	SHORT $LN299@ms64_param
$LN301@ms64_param:

; 348  :                 i = T_RAX;
; 349  :                 if ( psize < 8 )

	cmp	r13d, 8
	mov	esi, 115				; 00000073H
	jae	SHORT $LN299@ms64_param

; 350  :                     EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, index+1 );

	lea	edx, DWORD PTR [rbp+1]
	lea	ecx, QWORD PTR [rsi+30]
	call	EmitErr
$LN299@ms64_param:

; 351  :             }
; 352  :             *regs_used |= R0_USED;
; 353  :             AddLineQueueX( " lea %r, %s", i, paramvalue );

	mov	r8, QWORD PTR paramvalue$[rsp]
	or	BYTE PTR [r15], 1
	lea	rcx, OFFSET FLAT:$SG5898
	mov	edx, esi
	call	AddLineQueueX

; 354  :             AddLineQueueX( " mov [%r+%u], %r", T_RSP, NUMQUAL index*8, i );

	lea	r8d, DWORD PTR [rbp*8]
	lea	rcx, OFFSET FLAT:$SG5899
	mov	r9d, esi
	mov	edx, 119				; 00000077H
	call	AddLineQueueX

; 355  :             DebugMsg(("ms64_param(%s, param=%u): ADDR flags=%X\n", proc->sym.name, index, *regs_used ));
; 356  :             return( 1 );

	jmp	$LN46@ms64_param
$LN302@ms64_param:

; 357  :         }
; 358  :         if ( opnd->kind == EXPR_CONST ||
; 359  :            ( opnd->kind == EXPR_ADDR && opnd->indirect == FALSE && opnd->mem_type == MT_EMPTY && opnd->instr != T_OFFSET ) ) {

	mov	eax, DWORD PTR [r12+60]
	test	eax, eax
	je	$LN297@ms64_param
	cmp	eax, 1
	jne	SHORT $LN298@ms64_param
	test	BYTE PTR [r12+72], al
	jne	SHORT $LN298@ms64_param
	cmp	DWORD PTR [r12+64], 192			; 000000c0H
	jne	SHORT $LN298@ms64_param
	cmp	DWORD PTR [r12+56], 241			; 000000f1H
	jne	$LN297@ms64_param
$LN298@ms64_param:

; 380  :             }
; 381  :             DebugMsg(("ms64_param(%s, param=%u): MT_EMPTY size.p=%u flags=%X\n", proc->sym.name, index, psize, *regs_used ));
; 382  : 
; 383  :         } else if ( opnd->kind == EXPR_FLOAT  ) {

	cmp	eax, 3
	jne	$LN285@ms64_param

; 384  :             if ( param->sym.mem_type == MT_REAL8 ) {

	cmp	DWORD PTR [r14+44], 39			; 00000027H
	jne	SHORT $LN284@ms64_param

; 385  :                 AddLineQueueX( " mov %r ptr [%r+%u+0], %r (%s)", T_DWORD, T_RSP, NUMQUAL index*8, T_LOW32, paramvalue );

	mov	rbx, QWORD PTR paramvalue$[rsp]
	lea	edi, DWORD PTR [rbp*8]
	mov	esi, 209				; 000000d1H
	lea	r8d, QWORD PTR [rax+116]
	lea	rcx, OFFSET FLAT:$SG5920
	mov	edx, esi
	mov	r9d, edi
	mov	QWORD PTR [rsp+40], rbx
	mov	DWORD PTR [rsp+32], 237			; 000000edH
	call	AddLineQueueX

; 386  :                 AddLineQueueX( " mov %r ptr [%r+%u+4], %r (%s)", T_DWORD, T_RSP, NUMQUAL index*8, T_HIGH32, paramvalue );

	lea	r8d, QWORD PTR [rsi-90]
	lea	rcx, OFFSET FLAT:$SG5921
	mov	r9d, edi
	mov	edx, esi
	mov	QWORD PTR [rsp+40], rbx
	mov	DWORD PTR [rsp+32], 231			; 000000e7H
	call	AddLineQueueX

; 387  : 				return(1);

	jmp	$LN46@ms64_param
$LN284@ms64_param:

; 388  : 			}
; 389  : 			else {
; 390  : 				AddLineQueueX(" mov %r ptr [%r+%u], %s", T_DWORD, T_RSP, NUMQUAL index * 8, paramvalue);

	mov	rax, QWORD PTR paramvalue$[rsp]
	mov	edx, 209				; 000000d1H
	lea	r9d, DWORD PTR [rbp*8]
	lea	r8d, QWORD PTR [rdx-90]
	lea	rcx, OFFSET FLAT:$SG5923
	mov	QWORD PTR [rsp+32], rax
	call	AddLineQueueX

; 391  : 				return(1);

	jmp	$LN46@ms64_param
$LN285@ms64_param:

; 392  : 			}
; 393  : 
; 394  :         } else { /* it's a register or variable */
; 395  : 
; 396  :             if ( opnd->kind == EXPR_REG && opnd->indirect == FALSE ) {

	cmp	eax, 2
	jne	$LN281@ms64_param
	test	BYTE PTR [r12+72], 1
	jne	SHORT $LN281@ms64_param

; 397  :                 size = SizeFromRegister( reg );

	mov	ecx, esi
	call	SizeFromRegister

; 398  :                 if ( size == psize )

	cmp	eax, r13d
	mov	ebx, eax
	je	$LN270@ms64_param

; 399  :                     i = reg;
; 400  :                 else {
; 401  :                     if ( size > psize || ( size < psize && param->sym.mem_type == MT_PTR ) ) {

	cmp	eax, r13d
	ja	SHORT $LN277@ms64_param
	cmp	eax, r13d
	jae	SHORT $LN278@ms64_param
	cmp	DWORD PTR [r14+44], 195			; 000000c3H
	jne	SHORT $LN278@ms64_param
$LN277@ms64_param:

; 402  :                         DebugMsg(("ms64_param(%s, param=%u): type error size.p/a=%u/%u flags=%X\n", proc->sym.name, index, psize, size, *regs_used ));
; 403  :                         EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, index+1 );

	lea	edx, DWORD PTR [rbp+1]
	mov	ecx, 145				; 00000091H
	call	EmitErr

; 404  :                         psize = size;

	mov	r13d, ebx
$LN278@ms64_param:

; 405  :                     }
; 406  :                     switch ( psize ) {

	mov	eax, r13d
	dec	eax
	je	SHORT $LN274@ms64_param
	dec	eax
	je	SHORT $LN273@ms64_param
	cmp	eax, 2
	je	SHORT $LN272@ms64_param

; 408  :                     case 2:  i = T_AX;  break;
; 409  :                     case 4:  i = T_EAX; break;
; 410  :                     default: i = T_RAX; break;
; 411  :                     }
; 412  :                     *regs_used |= R0_USED;

	or	BYTE PTR [r15], 1
	mov	esi, 115				; 00000073H

; 413  :                 }
; 414  :                 DebugMsg(("ms64_param(%s, param=%u): REG size.p/a=%u/%u flags=%X\n", proc->sym.name, index, psize, size, *regs_used ));
; 415  :             } else {

	jmp	$LN270@ms64_param
$LN272@ms64_param:

; 408  :                     case 2:  i = T_AX;  break;
; 409  :                     case 4:  i = T_EAX; break;
; 410  :                     default: i = T_RAX; break;
; 411  :                     }
; 412  :                     *regs_used |= R0_USED;

	or	BYTE PTR [r15], 1
	mov	esi, 17

; 413  :                 }
; 414  :                 DebugMsg(("ms64_param(%s, param=%u): REG size.p/a=%u/%u flags=%X\n", proc->sym.name, index, psize, size, *regs_used ));
; 415  :             } else {

	jmp	$LN270@ms64_param
$LN273@ms64_param:

; 408  :                     case 2:  i = T_AX;  break;
; 409  :                     case 4:  i = T_EAX; break;
; 410  :                     default: i = T_RAX; break;
; 411  :                     }
; 412  :                     *regs_used |= R0_USED;

	or	BYTE PTR [r15], 1
	mov	esi, 9

; 413  :                 }
; 414  :                 DebugMsg(("ms64_param(%s, param=%u): REG size.p/a=%u/%u flags=%X\n", proc->sym.name, index, psize, size, *regs_used ));
; 415  :             } else {

	jmp	$LN270@ms64_param
$LN274@ms64_param:

; 407  :                     case 1:  i = T_AL;  break;

	mov	esi, 1

; 408  :                     case 2:  i = T_AX;  break;
; 409  :                     case 4:  i = T_EAX; break;
; 410  :                     default: i = T_RAX; break;
; 411  :                     }
; 412  :                     *regs_used |= R0_USED;

	or	BYTE PTR [r15], sil

; 413  :                 }
; 414  :                 DebugMsg(("ms64_param(%s, param=%u): REG size.p/a=%u/%u flags=%X\n", proc->sym.name, index, psize, size, *regs_used ));
; 415  :             } else {

	jmp	$LN270@ms64_param
$LN281@ms64_param:

; 416  :                 if ( opnd->mem_type == MT_EMPTY )

	mov	ecx, DWORD PTR [r12+64]
	cmp	ecx, 192				; 000000c0H
	jne	SHORT $LN269@ms64_param

; 417  :                     size = ( opnd->instr == T_OFFSET ? 8 : 4 );

	cmp	DWORD PTR [r12+56], 241			; 000000f1H
	mov	eax, 8
	mov	ebx, 4
	cmove	ebx, eax

; 418  :                 else

	jmp	SHORT $LN268@ms64_param
$LN269@ms64_param:

; 419  :                     size = SizeFromMemtype( opnd->mem_type, USE64, opnd->type );

	mov	r8, QWORD PTR [r12+96]
	mov	edx, 2
	call	SizeFromMemtype
	mov	rdx, QWORD PTR proc$[rsp]
	mov	ebx, eax
$LN268@ms64_param:

; 420  :                 DebugMsg(("ms64_param(%s, param=%u): MEM size.p/a=%u/%u flags=%X\n", proc->sym.name, index, psize, size, *regs_used ));
; 421  :                 switch ( psize ) {

	mov	eax, r13d
	dec	eax
	je	SHORT $LN265@ms64_param
	dec	eax
	je	SHORT $LN264@ms64_param
	cmp	eax, 2
	je	SHORT $LN263@ms64_param

; 425  :                 default: i = T_RAX; break;

	mov	esi, 115				; 00000073H
	lea	eax, QWORD PTR [rsi-114]
	jmp	SHORT $LN266@ms64_param
$LN263@ms64_param:

; 424  :                 case 4:  i = T_EAX; break;

	mov	esi, 17
	lea	eax, QWORD PTR [rsi-16]
	jmp	SHORT $LN266@ms64_param
$LN264@ms64_param:

; 423  :                 case 2:  i = T_AX;  break;

	mov	esi, 9
	lea	eax, QWORD PTR [rsi-8]
	jmp	SHORT $LN266@ms64_param
$LN265@ms64_param:

; 422  :                 case 1:  i = T_AL;  break;

	mov	eax, 1
	mov	esi, eax
$LN266@ms64_param:

; 426  :                 }
; 427  : 				if(proc->sym.langtype == LANG_VECTORCALL) return(1);

	cmp	DWORD PTR [rdx+84], 8
	je	$LN331@ms64_param

; 428  :                 *regs_used |= R0_USED;

	or	BYTE PTR [r15], 1
$LN270@ms64_param:

; 429  :             }
; 430  : 
; 431  :             /* v2.11: no expansion if target type is a pointer */
; 432  :             if ( size > psize || ( size < psize && param->sym.mem_type == MT_PTR ) ) {

	cmp	ebx, r13d
	ja	SHORT $LN259@ms64_param
	cmp	ebx, r13d
	jae	SHORT $LN260@ms64_param
	cmp	DWORD PTR [r14+44], 195			; 000000c3H
	jne	SHORT $LN260@ms64_param
$LN259@ms64_param:

; 433  :                 EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, index+1 );

	lea	edx, DWORD PTR [rbp+1]
	mov	ecx, 145				; 00000091H
	call	EmitErr
$LN260@ms64_param:

; 434  :             }
; 435  :             if ( size != psize ) {

	cmp	ebx, r13d
	je	SHORT $LN258@ms64_param

; 436  :                 if ( size == 4 ) {

	cmp	ebx, 4
	jne	SHORT $LN257@ms64_param

; 437  :                     if ( IS_SIGNED( opnd->mem_type ) )

	mov	eax, DWORD PTR [r12+64]
	and	al, -64					; ffffffffffffffc0H
	cmp	al, 64					; 00000040H
	jne	SHORT $LN256@ms64_param

; 438  :                         AddLineQueueX( " movsxd %r, %s", i, paramvalue );

	mov	r8, QWORD PTR paramvalue$[rsp]
	lea	rcx, OFFSET FLAT:$SG5955
	mov	edx, esi
	call	AddLineQueueX

; 439  :                     else

	jmp	SHORT $LN252@ms64_param
$LN256@ms64_param:

; 440  :                         AddLineQueueX( " mov %r, %s", i, paramvalue );

	mov	r8, QWORD PTR paramvalue$[rsp]
	lea	rcx, OFFSET FLAT:$SG5957
	mov	edx, esi
	call	AddLineQueueX

; 441  :                 } else

	jmp	SHORT $LN252@ms64_param
$LN257@ms64_param:

; 442  :                     AddLineQueueX( " mov%sx %r, %s", IS_SIGNED( opnd->mem_type ) ? "s" : "z", i, paramvalue );

	mov	eax, DWORD PTR [r12+64]
	mov	r9, QWORD PTR paramvalue$[rsp]
	lea	rcx, OFFSET FLAT:$SG5959
	and	al, -64					; ffffffffffffffc0H
	lea	rdx, OFFSET FLAT:$SG5960
	mov	r8d, esi
	cmp	al, 64					; 00000040H
	cmove	rdx, rcx
	lea	rcx, OFFSET FLAT:$SG5961
	call	AddLineQueueX

; 443  :             } else if ( opnd->kind != EXPR_REG || opnd->indirect == TRUE )

	jmp	SHORT $LN252@ms64_param
$LN258@ms64_param:
	cmp	DWORD PTR [r12+60], 2
	jne	SHORT $LN251@ms64_param
	test	BYTE PTR [r12+72], 1
	je	SHORT $LN252@ms64_param
$LN251@ms64_param:

; 444  :                 AddLineQueueX( " mov %r, %s", i, paramvalue );

	mov	r8, QWORD PTR paramvalue$[rsp]
	lea	rcx, OFFSET FLAT:$SG5965
	mov	edx, esi
	call	AddLineQueueX
$LN252@ms64_param:

; 445  : 
; 446  :             AddLineQueueX( " mov [%r+%u], %r", T_RSP, NUMQUAL index*8, i );

	lea	r8d, DWORD PTR [rbp*8]
	lea	rcx, OFFSET FLAT:$SG5966
	mov	r9d, esi
	mov	edx, 119				; 00000077H
	call	AddLineQueueX

; 447  : 			return(1);

	jmp	$LN46@ms64_param
$LN297@ms64_param:

; 360  :             /* v2.06: support 64-bit constants for params > 4 */
; 361  :             if ( psize == 8 &&
; 362  :                 ( opnd->value64 > LONG_MAX || opnd->value64 < LONG_MIN ) ) {

	cmp	r13d, 8
	jne	SHORT $LN296@ms64_param
	mov	rcx, QWORD PTR [r12]
	cmp	rcx, 2147483647				; 7fffffffH
	jg	SHORT $LN295@ms64_param
	cmp	rcx, -2147483648			; ffffffff80000000H
	jge	SHORT $LN296@ms64_param
$LN295@ms64_param:

; 363  :                 AddLineQueueX( " mov %r ptr [%r+%u], %r ( %s )", T_DWORD, T_RSP, NUMQUAL index*8, T_LOW32, paramvalue );

	mov	rdi, QWORD PTR paramvalue$[rsp]
	mov	esi, 209				; 000000d1H
	lea	ebx, DWORD PTR [rbp*8]
	lea	rcx, OFFSET FLAT:$SG5904
	lea	r8d, QWORD PTR [rsi-90]
	mov	edx, esi
	mov	r9d, ebx
	mov	QWORD PTR [rsp+40], rdi
	mov	DWORD PTR [rsp+32], 237			; 000000edH
	call	AddLineQueueX

; 364  :                 AddLineQueueX( " mov %r ptr [%r+%u], %r ( %s )", T_DWORD, T_RSP, NUMQUAL index*8+4, T_HIGH32, paramvalue );

	lea	r9d, DWORD PTR [rbx+4]
	lea	r8d, QWORD PTR [rsi-90]
	lea	rcx, OFFSET FLAT:$SG5905
	mov	edx, esi
	mov	QWORD PTR [rsp+40], rdi
	mov	DWORD PTR [rsp+32], 231			; 000000e7H
	call	AddLineQueueX

; 365  : 				return(1);

	jmp	$LN46@ms64_param
$LN296@ms64_param:

; 366  :             } else {
; 367  :                 /* v2.11: no expansion if target type is a pointer and argument is an address part */
; 368  :                 if ( param->sym.mem_type == MT_PTR && opnd->kind == EXPR_ADDR && opnd->sym->state != SYM_UNDEFINED ) {

	cmp	DWORD PTR [r14+44], 195			; 000000c3H
	jne	SHORT $LN293@ms64_param
	cmp	eax, 1
	jne	SHORT $LN293@ms64_param
	mov	rax, QWORD PTR [r12+80]
	cmp	DWORD PTR [rax+40], ebx
	je	SHORT $LN293@ms64_param

; 369  :                     DebugMsg(("ms64_param(%s, param=%u): MT_PTR, type error, psize=%u\n", proc->sym.name, index, psize ));
; 370  :                     EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, index+1 );

	lea	edx, DWORD PTR [rbp+1]
	mov	ecx, 145				; 00000091H
	call	EmitErr
$LN293@ms64_param:

; 371  :                 }
; 372  :                 switch ( psize ) {

	dec	r13d
	je	SHORT $LN290@ms64_param
	dec	r13d
	je	SHORT $LN289@ms64_param
	cmp	r13d, 2
	je	SHORT $LN288@ms64_param

; 376  :                 default:  i = T_QWORD; break;

	mov	esi, 213				; 000000d5H
	jmp	SHORT $LN291@ms64_param
$LN288@ms64_param:

; 375  :                 case 4:   i = T_DWORD; break;

	mov	esi, 209				; 000000d1H
	jmp	SHORT $LN291@ms64_param
$LN289@ms64_param:

; 374  :                 case 2:   i = T_WORD; break;

	mov	esi, 207				; 000000cfH
	jmp	SHORT $LN291@ms64_param
$LN290@ms64_param:

; 373  :                 case 1:   i = T_BYTE; break;

	mov	esi, 205				; 000000cdH
$LN291@ms64_param:

; 377  :                 }
; 378  :                 AddLineQueueX( " mov %r ptr [%r+%u], %s", i, T_RSP, NUMQUAL index*8, paramvalue );

	mov	rax, QWORD PTR paramvalue$[rsp]
	lea	r9d, DWORD PTR [rbp*8]
	lea	rcx, OFFSET FLAT:$SG5916
	mov	r8d, 119				; 00000077H
	mov	edx, esi
	mov	QWORD PTR [rsp+32], rax
	call	AddLineQueueX

; 379  : 				return(1);

	jmp	$LN46@ms64_param
$LN305@ms64_param:

; 448  :         }
; 449  : 
; 450  :     } else if ( param->sym.mem_type == MT_REAL4 ||
; 451  :                param->sym.mem_type == MT_REAL8 ) {

	mov	edx, DWORD PTR [r14+44]
	cmp	edx, 35					; 00000023H
	je	SHORT $LN248@ms64_param
	cmp	edx, 39					; 00000027H
	jne	$LN230@ms64_param
$LN248@ms64_param:

; 452  :         /* v2.04: check if argument is the correct XMM register already */
; 453  :         if ( opnd->kind == EXPR_REG && opnd->indirect == FALSE ) {

	mov	r9d, DWORD PTR [r12+60]
	cmp	r9d, 2
	jne	SHORT $LN247@ms64_param
	test	BYTE PTR [r12+72], 1
	jne	SHORT $LN247@ms64_param

; 454  :             if ( GetValueSp( reg ) & OP_XMM ) {

	movsxd	rax, esi
	lea	rcx, QWORD PTR [rax+rax*2]
	test	BYTE PTR SpecialTable[r10+rcx*4], 32	; 00000020H
	je	$LN239@ms64_param

; 455  :                  if (proc->sym.langtype == LANG_VECTORCALL)

	cmp	r8d, 8
	jne	SHORT $LN245@ms64_param

; 456  :                      info->vregs[index] = 1;

	mov	BYTE PTR [rbp+rdi+68], 1
$LN245@ms64_param:

; 457  :                 if ( reg == T_XMM0 + index )

	lea	r8d, DWORD PTR [rbp+40]
	cmp	esi, r8d
	je	$LN46@ms64_param

; 458  :                     DebugMsg(("ms64_param(%s, param=%u): argument optimized\n", proc->sym.name, index ));
; 459  : 				else
; 460  : 				{
; 461  : 					if (param->sym.mem_type == MT_REAL4)

	cmp	DWORD PTR [r14+44], 35			; 00000023H
	jne	SHORT $LN242@ms64_param

; 462  : 						AddLineQueueX(" %s %r, %s", MOVE_ALIGNED_FLOAT, T_XMM0 + index, paramvalue);

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	rdx, QWORD PTR MOVE_ALIGNED_FLOAT
	lea	rcx, OFFSET FLAT:$SG5976
	call	AddLineQueueX

; 463  : 					else

	jmp	$LN46@ms64_param
$LN242@ms64_param:

; 464  : 						AddLineQueueX(" %s %r, %s", MOVE_ALIGNED_FLOAT, T_XMM0 + index, paramvalue);

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	rdx, QWORD PTR MOVE_ALIGNED_FLOAT
	lea	rcx, OFFSET FLAT:$SG5978
	call	AddLineQueueX

; 465  : 				}
; 466  :                 return( 1 );

	jmp	$LN46@ms64_param
$LN247@ms64_param:

; 467  :             }
; 468  :         }
; 469  : 		else if (opnd->kind == EXPR_REG && opnd->indirect == TRUE) {

	cmp	r9d, 2
	jne	SHORT $LN239@ms64_param
	test	BYTE PTR [r12+72], 1
	je	SHORT $LN239@ms64_param

; 470  : 			//if (GetValueSp(reg) & OP_XMM) {
; 471  : 				if (reg == T_XMM0 + index)

	lea	r8d, DWORD PTR [rbp+40]
	cmp	esi, r8d
	je	$LN46@ms64_param

; 472  : 					DebugMsg(("ms64_param(%s, param=%u): argument optimized\n", proc->sym.name, index));
; 473  : 				else
; 474  : 				{
; 475  : 					if(param->sym.mem_type == MT_REAL4)

	cmp	edx, 35					; 00000023H
	jne	SHORT $LN236@ms64_param

; 476  : 						AddLineQueueX(" %s %r, %s", MOVE_SIMD_DWORD, T_XMM0 + index, paramvalue);

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	rdx, QWORD PTR MOVE_SIMD_DWORD
	lea	rcx, OFFSET FLAT:$SG5984
	call	AddLineQueueX

; 477  : 					else

	jmp	$LN46@ms64_param
$LN236@ms64_param:

; 478  : 						AddLineQueueX(" %s %r, %s", MOVE_SIMD_QWORD, T_XMM0 + index, paramvalue);

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	rdx, QWORD PTR MOVE_SIMD_QWORD
	lea	rcx, OFFSET FLAT:$SG5986
	call	AddLineQueueX

; 479  : 				}
; 480  : 				return(1);

	jmp	$LN46@ms64_param
$LN239@ms64_param:

; 481  : 			//}
; 482  : 		}
; 483  : 
; 484  : 		if ( opnd->kind == EXPR_FLOAT ) {

	cmp	r9d, 3
	jne	$LN231@ms64_param

; 485  : 			if (proc->sym.langtype == LANG_VECTORCALL)

	cmp	r8d, 8
	jne	SHORT $LN233@ms64_param

; 486  : 			{
; 487  : 				info->vregs[index] = 1;

	mov	BYTE PTR [rbp+rdi+68], 1

; 488  : 				info->xyzused[index] = 1; /* JPH */

	mov	BYTE PTR [rbp+rdi+74], 1
$LN233@ms64_param:

; 489  : 			}
; 490  :             *regs_used |= R0_USED;

	or	BYTE PTR [r15], 1

; 491  :             if ( param->sym.mem_type == MT_REAL4 ) {

	cmp	DWORD PTR [r14+44], 35			; 00000023H
	jne	SHORT $LN232@ms64_param

; 492  :                 
; 493  :                 AddLineQueueX( "mov %r, %s", T_EAX, paramvalue );

	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	esi, 17
	lea	rcx, OFFSET FLAT:$SG5990
	mov	edx, esi
	call	AddLineQueueX

; 494  :                 AddLineQueueX( "%s %r, %r", MOVE_SIMD_DWORD, T_XMM0 + index, T_EAX );

	mov	rdx, QWORD PTR MOVE_SIMD_DWORD
	lea	r8d, DWORD PTR [rbp+40]
	lea	rcx, OFFSET FLAT:$SG5991
	mov	r9d, esi
	call	AddLineQueueX

; 495  : 				return(1);

	jmp	$LN46@ms64_param
$LN232@ms64_param:

; 496  :             } else {
; 497  :                 AddLineQueueX( "mov %r, %r ptr %s", T_RAX, T_REAL8, paramvalue );

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	esi, 115				; 00000073H
	lea	rcx, OFFSET FLAT:$SG5993
	lea	r8d, QWORD PTR [rsi+100]
	mov	edx, esi
	call	AddLineQueueX

; 498  :                 AddLineQueueX( "%s %r, %r", MOVE_SIMD_QWORD, T_XMM0 + index, T_RAX );

	mov	rdx, QWORD PTR MOVE_SIMD_QWORD
	lea	r8d, DWORD PTR [rbp+40]
	lea	rcx, OFFSET FLAT:$SG5994
	mov	r9d, esi
	call	AddLineQueueX

; 499  : 				return(1);

	jmp	$LN46@ms64_param
$LN231@ms64_param:

; 500  :             }
; 501  :         } 
; 502  :         if ( opnd->kind == EXPR_ADDR ) {

	cmp	r9d, 1
	jne	$LN230@ms64_param

; 503  : 			if (proc->sym.langtype == LANG_VECTORCALL)

	cmp	r8d, 8
	jne	SHORT $LN229@ms64_param

; 504  : 			{
; 505  : 				*regs_used |= R0_USED;

	or	BYTE PTR [r15], r9b

; 506  : 				info->vregs[index] = 1;

	mov	BYTE PTR [rbp+rdi+68], r9b

; 507  : 				info->xyzused[index] = 1; /* JPH */

	mov	BYTE PTR [rbp+rdi+74], r9b

; 508  : 				if (opnd->sym->mem_type == MT_REAL8)

	mov	rax, QWORD PTR [r12+80]
	cmp	DWORD PTR [rax+44], 39			; 00000027H
	jne	SHORT $LN228@ms64_param

; 509  : 					AddLineQueueX("%s %r,qword ptr %s", MOVE_DOUBLE, T_XMM0 + index, paramvalue);

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	rdx, QWORD PTR MOVE_DOUBLE
	lea	r8d, DWORD PTR [rbp+40]
	lea	rcx, OFFSET FLAT:$SG5998
	call	AddLineQueueX

; 510  : 				else

	jmp	$LN46@ms64_param
$LN228@ms64_param:

; 511  : 					AddLineQueueX("%s %r,dword ptr %s", MOVE_SINGLE, T_XMM0 + index, paramvalue);

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	rdx, QWORD PTR MOVE_SINGLE
	lea	r8d, DWORD PTR [rbp+40]
	lea	rcx, OFFSET FLAT:$SG6000
	call	AddLineQueueX

; 512  : 			}
; 513  : 			else

	jmp	$LN46@ms64_param
$LN229@ms64_param:

; 514  : 			{
; 515  : 				if (param->sym.mem_type == MT_REAL8)

	cmp	edx, 39					; 00000027H
	jne	SHORT $LN225@ms64_param

; 516  : 					AddLineQueueX("%s %r,qword ptr %s", MOVE_SIMD_QWORD, T_XMM0 + index, paramvalue);

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	rdx, QWORD PTR MOVE_SIMD_QWORD
	lea	r8d, DWORD PTR [rbp+40]
	lea	rcx, OFFSET FLAT:$SG6003
	call	AddLineQueueX
	jmp	$LN46@ms64_param
$LN225@ms64_param:

; 517  : 				else if (param->sym.mem_type == MT_REAL4)

	cmp	edx, 35					; 00000023H
	jne	$LN46@ms64_param

; 518  : 					AddLineQueueX("%s %r,dword ptr %s", MOVE_SIMD_DWORD, T_XMM0 + index, paramvalue);

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	rdx, QWORD PTR MOVE_SIMD_DWORD
	lea	r8d, DWORD PTR [rbp+40]
	lea	rcx, OFFSET FLAT:$SG6006
	call	AddLineQueueX

; 519  : 			}
; 520  : 			return(1);

	jmp	$LN46@ms64_param
$LN230@ms64_param:

; 521  :         } 
; 522  :       } 
; 523  : 	if(vcallpass==1)

	cmp	r11d, 1
	je	$LN46@ms64_param
	mov	r8d, 1
	jmp	SHORT $vcall$5873
$LN385@ms64_param:
	mov	esi, DWORD PTR reg$[rsp]
$vcall$5873:

; 524  : 		goto vcalldone;
; 525  : 
; 526  : vcall:     
; 527  : 	  if ((proc->sym.langtype == LANG_VECTORCALL) && (psize == 8) && (param->sym.ttype != 0) && (param->sym.ttype->e.structinfo->isHFA) && (param->sym.mem_type == MT_TYPE)) {

	mov	r15, QWORD PTR proc$[rsp]
	mov	edx, DWORD PTR [r15+84]
	cmp	edx, 8
	jne	$LN221@ms64_param
	cmp	r13d, edx
	jne	$LN221@ms64_param
	mov	rcx, QWORD PTR [r14+88]
	test	rcx, rcx
	je	$LN221@ms64_param
	mov	rax, QWORD PTR [rcx+104]
	cmp	BYTE PTR [rax+22], bl
	je	$LN221@ms64_param
	cmp	DWORD PTR [r14+44], 196			; 000000c4H
	jne	$LN221@ms64_param

; 528  :           /* it can be only HFA data type made of 2 REAL4 */
; 529  :           t = param->sym.ttype;   
; 530  : 		  if (t != 0 && t->e.structinfo->isHFA && (vcallpass == 1))

	cmp	BYTE PTR [rax+22], bl
	mov	r10, rax
	je	$LN46@ms64_param
	cmp	r11d, 1
	jne	$LN46@ms64_param

; 531  : 		  {
; 532  :       
; 533  : 			  freevecregs = 0;

	lea	r9, QWORD PTR [rdi+68]

; 534  : 			  vecidx = -1;

	lea	ecx, QWORD PTR [rdx-9]
	mov	r8d, ebx
	mov	rdx, r9

; 535  : 			  for (i = 0; i < 6; i++)

	mov	eax, ebx
	npad	3
$LL219@ms64_param:

; 536  : 			  {
; 537  : 				  if (info->vregs[i] == 0)

	cmp	BYTE PTR [rdx], bl
	jne	SHORT $LN218@ms64_param

; 538  : 				  {
; 539  : 					  if (vecidx == -1) vecidx = i;

	cmp	ecx, -1
	cmove	ecx, eax

; 540  : 					  freevecregs++;

	inc	r8d
$LN218@ms64_param:
	inc	eax
	inc	rdx
	cmp	eax, 6
	jl	SHORT $LL219@ms64_param

; 541  : 				  }
; 542  : 			  }
; 543  : 
; 544  : 			  memberCount = t->e.structinfo->memberCount;

	mov	r15d, DWORD PTR [r10+24]

; 545  : 			  if (memberCount > freevecregs) goto uselea;

	cmp	r15d, r8d
	jg	$LN396@ms64_param

; 546  : 			  membersize = psize / memberCount;     //get the size of a single element which is REAL4 in this case        

	xor	edx, edx
	mov	eax, 8

; 547  : 			  j = 0;
; 548  : 			  tCount = memberCount;

	mov	r13d, r15d
	div	r15d

; 549  : 			  while (tCount > 0)

	test	r15d, r15d
	movsxd	rsi, ecx
	mov	r14d, eax
	jle	$LN46@ms64_param

; 546  : 			  membersize = psize / memberCount;     //get the size of a single element which is REAL4 in this case        

	lea	r12d, DWORD PTR [rcx+40]
$LL213@ms64_param:

; 550  : 			  {
; 551  : 				  if (info->vregs[vecidx] == 0)

	cmp	BYTE PTR [rsi+r9], 0
	jne	SHORT $LN211@ms64_param

; 552  : 				  {
; 553  : 					  info->vregs[vecidx] = 1;

	mov	BYTE PTR [rsi+r9], 1

; 554  : 					  info->vecregs[index] = memberCount;         //store number of members in proper location pointed by index
; 555  : 					  info->vsize += membersize;                  //vsize contains total size 
; 556  : 					  info->vecregsize[vecidx] = membersize;      //size of data tu be put in register
; 557  : 					  info->xyzused[vecidx] = 1;                  //mark that the placeholder for register is used
; 558  : 					  AddLineQueueX("%s %r,dword ptr [%s+%d]", MOVE_SINGLE, T_XMM0 + vecidx, paramvalue, j* membersize);

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	BYTE PTR [rbp+rdi+56], r15b
	add	DWORD PTR [rdi+44], r14d
	mov	BYTE PTR [rsi+rdi+62], r14b
	mov	BYTE PTR [rsi+rdi+74], 1
	mov	rdx, QWORD PTR MOVE_SINGLE
	lea	rcx, OFFSET FLAT:$SG6022
	mov	r8d, r12d
	mov	DWORD PTR [rsp+32], ebx
	call	AddLineQueueX

; 559  : 					  tCount--;

	dec	r13d

; 560  : 					  j++;

	add	ebx, r14d
	lea	r9, QWORD PTR [rdi+68]
$LN211@ms64_param:

; 561  : 				  }
; 562  : 				  vecidx++;

	inc	r12d
	inc	rsi
	test	r13d, r13d
	jg	SHORT $LL213@ms64_param

; 563  : 			  }
; 564  : 		  }

	jmp	$LN46@ms64_param
$LN221@ms64_param:

; 565  :     }
; 566  : 	  else if ((proc->sym.langtype == LANG_VECTORCALL) && (psize == 16) && (param->sym.ttype != 0) && (param->sym.ttype->e.structinfo->isHFA) && (param->sym.mem_type == MT_TYPE)) {

	cmp	edx, 8
	jne	$LN209@ms64_param
	cmp	r13d, 16
	jne	$LN209@ms64_param
	mov	rcx, QWORD PTR [r14+88]
	test	rcx, rcx
	je	$LN209@ms64_param
	mov	rax, QWORD PTR [rcx+104]
	cmp	BYTE PTR [rax+22], bl
	je	$LN209@ms64_param
	cmp	DWORD PTR [r14+44], 196			; 000000c4H
	jne	$LN209@ms64_param

; 567  : 		  /* it can be only HFA data type made of 2 REAL8 */
; 568  : 		  t = param->sym.ttype;
; 569  : 		  if (t != 0 && t->e.structinfo->isHFA && (vcallpass == 1))

	cmp	BYTE PTR [rax+22], bl
	mov	r9, rax
	je	$LN46@ms64_param
	cmp	r11d, 1
	jne	$LN46@ms64_param

; 570  : 		  {
; 571  : 			  
; 572  : 			  freevecregs = 0;
; 573  : 			  vecidx = -1;

	lea	ecx, QWORD PTR [rdx-9]
	mov	r8d, ebx

; 574  : 			  for (i = 0; i < 6; i++)

	mov	eax, ebx
	lea	rdx, QWORD PTR [rdi+68]
	npad	4
$LL207@ms64_param:

; 575  : 			  {
; 576  : 				  if (info->vregs[i] == 0)

	cmp	BYTE PTR [rdx], bl
	jne	SHORT $LN206@ms64_param

; 577  : 				  {
; 578  : 					  if (vecidx == -1) vecidx = i;

	cmp	ecx, -1
	cmove	ecx, eax

; 579  : 					  freevecregs++;

	inc	r8d
$LN206@ms64_param:
	inc	eax
	inc	rdx
	cmp	eax, 6
	jl	SHORT $LL207@ms64_param

; 580  : 				  }
; 581  : 			  }
; 582  : 
; 583  : 			  memberCount = t->e.structinfo->memberCount;

	mov	r15d, DWORD PTR [r9+24]

; 584  : 			  if (memberCount > freevecregs) goto uselea;

	cmp	r15d, r8d
	jg	$LN395@ms64_param

; 585  : 			  membersize = psize / memberCount;          //get the size of a single element which is REAL4 in this case        

	xor	edx, edx
	mov	eax, 16

; 586  : 			  j = 0;
; 587  : 			  tCount = memberCount;

	mov	r12d, r15d
	div	r15d
	movsxd	rsi, ecx

; 588  : 			  if (membersize == 8)

	cmp	eax, 8
	jne	SHORT $LN201@ms64_param

; 589  : 			  {
; 590  : 				  while (tCount > 0)

	test	r15d, r15d
	jle	$LN46@ms64_param
	lea	r13d, DWORD PTR [rcx+40]
$LL200@ms64_param:

; 591  : 				  {
; 592  : 					  if (info->vregs[vecidx] == 0)

	cmp	BYTE PTR [rsi+rdi+68], 0
	jne	SHORT $LN198@ms64_param

; 593  : 					  {
; 594  : 						  info->vregs[vecidx] = 1;
; 595  : 						  info->vecregs[index] = memberCount;        //store number of members in proper location pointed by index
; 596  : 						  info->vsize += membersize;                      //vsize contains total size 
; 597  : 						  info->vecregsize[vecidx] = membersize;      //size of data tu be put in register
; 598  : 						  info->xyzused[vecidx] = 1;                  //mark that the placeholder for register is used
; 599  : 						  AddLineQueueX("%s %r,qword ptr [%s+%d]", MOVE_DOUBLE, T_XMM0 + vecidx, paramvalue, j * membersize);

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	BYTE PTR [rsi+rdi+68], 1
	mov	BYTE PTR [rbp+rdi+56], r15b
	add	DWORD PTR [rdi+44], 8
	mov	BYTE PTR [rsi+rdi+62], 8
	mov	BYTE PTR [rsi+rdi+74], 1
	mov	rdx, QWORD PTR MOVE_DOUBLE
	lea	rcx, OFFSET FLAT:$SG6037
	mov	r8d, r13d
	mov	DWORD PTR [rsp+32], ebx
	call	AddLineQueueX

; 600  : 						  tCount--;

	dec	r12d

; 601  : 						  j++;

	add	ebx, 8
$LN198@ms64_param:

; 602  : 					  }
; 603  : 					  vecidx++;

	inc	r13d
	inc	rsi
	test	r12d, r12d
	jg	SHORT $LL200@ms64_param

; 604  : 				  }
; 605  : 			  }
; 606  : 			  /* HFA data type made of 4 REAL4 */
; 607  : 			  else if (membersize == 4)

	jmp	$LN46@ms64_param
$LN201@ms64_param:
	cmp	eax, 4
	jne	$LN46@ms64_param

; 608  : 			  {
; 609  : 				  while (tCount > 0)

	test	r15d, r15d
	jle	$LN46@ms64_param
	lea	r13d, DWORD PTR [rcx+40]
$LL195@ms64_param:

; 610  : 				  {
; 611  : 					  if (info->vregs[vecidx] == 0)

	cmp	BYTE PTR [rsi+rdi+68], 0
	jne	SHORT $LN193@ms64_param

; 612  : 					  {
; 613  : 						  info->vregs[vecidx] = 1;
; 614  : 						  info->vecregs[index] = memberCount;         //store number of members in proper location pointed by index
; 615  : 						  info->vsize += membersize;                  //vsize contains total size 
; 616  : 						  info->vecregsize[vecidx] = membersize;      //size of data tu be put in register
; 617  : 						  info->xyzused[vecidx] = 1;                  //mark that the placeholder for register is used
; 618  : 						  AddLineQueueX("%s %r,dword ptr [%s+%d]", MOVE_SINGLE, T_XMM0 + vecidx, paramvalue, j * membersize);

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	BYTE PTR [rsi+rdi+68], 1
	mov	BYTE PTR [rbp+rdi+56], r15b
	add	DWORD PTR [rdi+44], 4
	mov	BYTE PTR [rsi+rdi+62], 4
	mov	BYTE PTR [rsi+rdi+74], 1
	mov	rdx, QWORD PTR MOVE_SINGLE
	lea	rcx, OFFSET FLAT:$SG6044
	mov	r8d, r13d
	mov	DWORD PTR [rsp+32], ebx
	call	AddLineQueueX

; 619  : 						  tCount--;

	dec	r12d

; 620  : 						  j++;

	add	ebx, 4
$LN193@ms64_param:

; 621  : 					  }
; 622  : 					  vecidx++;

	inc	r13d
	inc	rsi
	test	r12d, r12d
	jg	SHORT $LL195@ms64_param

; 623  : 				  }
; 624  : 			  }
; 625  : 		  }

	jmp	$LN46@ms64_param
$LN209@ms64_param:

; 626  : 	  }
; 627  :       else if ((proc->sym.langtype == LANG_VECTORCALL) && (psize == 12) && (param->sym.ttype != 0) && (param->sym.ttype->e.structinfo->isHFA) && (param->sym.mem_type == MT_TYPE)) {

	cmp	edx, 8
	jne	$LN191@ms64_param
	cmp	r13d, 12
	jne	$LN191@ms64_param
	mov	rcx, QWORD PTR [r14+88]
	test	rcx, rcx
	je	$LN191@ms64_param
	mov	rax, QWORD PTR [rcx+104]
	cmp	BYTE PTR [rax+22], bl
	je	$LN191@ms64_param
	cmp	DWORD PTR [r14+44], 196			; 000000c4H
	jne	$LN191@ms64_param

; 628  : 		  /* it can be only HFA data type made of 3 REAL4 */
; 629  : 		  t = param->sym.ttype;
; 630  : 		  if (t != 0 && t->e.structinfo->isHFA && (vcallpass == 1))

	cmp	BYTE PTR [rax+22], bl
	mov	r10, rax
	je	$LN46@ms64_param
	cmp	r11d, 1
	jne	$LN46@ms64_param

; 631  : 		  {
; 632  : 			  freevecregs = 0;

	lea	r9, QWORD PTR [rdi+68]

; 633  : 			  vecidx = -1;

	lea	ecx, QWORD PTR [rdx-9]
	mov	r8d, ebx
	mov	rdx, r9

; 634  : 			  for (i = 0; i < 6; i++)

	mov	eax, ebx
	npad	6
$LL189@ms64_param:

; 635  : 			  {
; 636  : 				  if (info->vregs[i] == 0)

	cmp	BYTE PTR [rdx], bl
	jne	SHORT $LN188@ms64_param

; 637  : 				  {
; 638  : 					  if (vecidx == -1) vecidx = i;

	cmp	ecx, -1
	cmove	ecx, eax

; 639  : 					  freevecregs++;

	inc	r8d
$LN188@ms64_param:
	inc	eax
	inc	rdx
	cmp	eax, 6
	jl	SHORT $LL189@ms64_param

; 640  : 				  }
; 641  : 			  }
; 642  : 
; 643  : 			  memberCount = t->e.structinfo->memberCount;

	mov	r15d, DWORD PTR [r10+24]

; 644  : 			  if (memberCount > freevecregs) goto uselea;

	cmp	r15d, r8d
	jg	$LN394@ms64_param

; 645  : 			  membersize = psize / memberCount;               //get the size of a single element which is REAL4 in this case        

	xor	edx, edx
	mov	eax, 12

; 646  : 			  j = 0;
; 647  : 			  tCount = memberCount;

	mov	r13d, r15d
	div	r15d

; 648  : 			  while (tCount > 0)

	test	r15d, r15d
	movsxd	rsi, ecx
	mov	r14d, eax
	jle	$LN46@ms64_param

; 645  : 			  membersize = psize / memberCount;               //get the size of a single element which is REAL4 in this case        

	lea	r12d, DWORD PTR [rcx+40]
$LL183@ms64_param:

; 649  : 			  {
; 650  : 				  if (info->vregs[vecidx] == 0)

	cmp	BYTE PTR [rsi+r9], 0
	jne	SHORT $LN181@ms64_param

; 651  : 				  {
; 652  : 					  info->vregs[vecidx] = 1;

	mov	BYTE PTR [rsi+r9], 1

; 653  : 					  info->vecregs[index] = memberCount;         //store number of members in proper location pointed by index
; 654  : 					  info->vsize += membersize;                  //vsize contains total size 
; 655  : 					  info->vecregsize[vecidx] = membersize;      //size of data tu be put in register
; 656  : 					  info->xyzused[vecidx] = 1;                  //mark that the placeholder for register is used
; 657  : 					  AddLineQueueX("%s %r,dword ptr [%s+%d]", MOVE_SINGLE, T_XMM0 + vecidx, paramvalue, j * membersize);

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	BYTE PTR [rbp+rdi+56], r15b
	add	DWORD PTR [rdi+44], r14d
	mov	BYTE PTR [rsi+rdi+62], r14b
	mov	BYTE PTR [rsi+rdi+74], 1
	mov	rdx, QWORD PTR MOVE_SINGLE
	lea	rcx, OFFSET FLAT:$SG6058
	mov	r8d, r12d
	mov	DWORD PTR [rsp+32], ebx
	call	AddLineQueueX

; 658  : 					  tCount--;

	dec	r13d

; 659  : 					  j++;

	add	ebx, r14d
	lea	r9, QWORD PTR [rdi+68]
$LN181@ms64_param:

; 660  : 				  }
; 661  : 				  vecidx++;

	inc	r12d
	inc	rsi
	test	r13d, r13d
	jg	SHORT $LL183@ms64_param

; 662  : 			  }
; 663  : 		  }

	jmp	$LN46@ms64_param
$LN191@ms64_param:

; 664  : 	  }
; 665  :       else if ((proc->sym.langtype == LANG_VECTORCALL) && (psize == 24) && (param->sym.ttype != 0) && (param->sym.ttype->e.structinfo->isHFA) && (param->sym.mem_type == MT_TYPE)) {

	cmp	edx, 8
	jne	$LN179@ms64_param
	cmp	r13d, 24
	jne	$LN179@ms64_param
	mov	rcx, QWORD PTR [r14+88]
	test	rcx, rcx
	je	$LN179@ms64_param
	mov	rax, QWORD PTR [rcx+104]
	cmp	BYTE PTR [rax+22], bl
	je	$LN179@ms64_param
	cmp	DWORD PTR [r14+44], 196			; 000000c4H
	jne	$LN179@ms64_param

; 666  : 		  /* it can be only HFA data type made of 3 REAL8 */
; 667  : 		  t = param->sym.ttype;
; 668  : 		  if (t != 0 && t->e.structinfo->isHFA && (vcallpass == 1))

	cmp	BYTE PTR [rax+22], bl
	mov	r10, rax
	je	$LN46@ms64_param
	cmp	r11d, 1
	jne	$LN46@ms64_param

; 669  : 		  {
; 670  : 
; 671  : 			  freevecregs = 0;

	lea	r9, QWORD PTR [rdi+68]

; 672  : 			  vecidx = -1;

	lea	ecx, QWORD PTR [rdx-9]
	mov	r8d, ebx
	mov	rdx, r9

; 673  : 			  for (i = 0; i < 6; i++)

	mov	eax, ebx
	npad	1
$LL177@ms64_param:

; 674  : 			  {
; 675  : 				  if (info->vregs[i] == 0)

	cmp	BYTE PTR [rdx], bl
	jne	SHORT $LN176@ms64_param

; 676  : 				  {
; 677  : 					  if (vecidx == -1) vecidx = i;

	cmp	ecx, -1
	cmove	ecx, eax

; 678  : 					  freevecregs++;

	inc	r8d
$LN176@ms64_param:
	inc	eax
	inc	rdx
	cmp	eax, 6
	jl	SHORT $LL177@ms64_param

; 679  : 				  }
; 680  : 			  }
; 681  : 
; 682  : 			  memberCount = t->e.structinfo->memberCount;

	mov	r15d, DWORD PTR [r10+24]

; 683  : 			  if (memberCount > freevecregs) goto uselea;

	cmp	r15d, r8d
	jg	$LN393@ms64_param

; 684  : 			  membersize = psize / memberCount;          //get the size of a single element which is REAL4 in this case        

	xor	edx, edx
	mov	eax, 24

; 685  : 			  j = 0;
; 686  : 			  tCount = memberCount;

	mov	r13d, r15d
	div	r15d

; 687  : 			  while (tCount > 0)

	test	r15d, r15d
	movsxd	rsi, ecx
	mov	r14d, eax
	jle	$LN46@ms64_param

; 684  : 			  membersize = psize / memberCount;          //get the size of a single element which is REAL4 in this case        

	lea	r12d, DWORD PTR [rcx+40]
$LL171@ms64_param:

; 688  : 			  {
; 689  : 				  if (info->vregs[vecidx] == 0)

	cmp	BYTE PTR [rsi+r9], 0
	jne	SHORT $LN169@ms64_param

; 690  : 				  {
; 691  : 					  info->vregs[vecidx] = 1;

	mov	BYTE PTR [rsi+r9], 1

; 692  : 					  info->vecregs[index] = memberCount;        //store number of members in proper location pointed by index
; 693  : 					  info->vsize += membersize;                      //vsize contains total size 
; 694  : 					  info->vecregsize[vecidx] = membersize;      //size of data tu be put in register
; 695  : 					  info->xyzused[vecidx] = 1;                  //mark that the placeholder for register is used
; 696  : 					  AddLineQueueX("%s %r,qword ptr [%s+%d]", MOVE_DOUBLE, T_XMM0 + vecidx, paramvalue, j * membersize);

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	BYTE PTR [rbp+rdi+56], r15b
	add	DWORD PTR [rdi+44], r14d
	mov	BYTE PTR [rsi+rdi+62], r14b
	mov	BYTE PTR [rsi+rdi+74], 1
	mov	rdx, QWORD PTR MOVE_DOUBLE
	lea	rcx, OFFSET FLAT:$SG6072
	mov	r8d, r12d
	mov	DWORD PTR [rsp+32], ebx
	call	AddLineQueueX

; 697  : 					  tCount--;

	dec	r13d

; 698  : 					  j++;

	add	ebx, r14d
	lea	r9, QWORD PTR [rdi+68]
$LN169@ms64_param:

; 699  : 				  }
; 700  : 				  vecidx++;

	inc	r12d
	inc	rsi
	test	r13d, r13d
	jg	SHORT $LL171@ms64_param

; 701  : 			  }
; 702  : 		  }

	jmp	$LN46@ms64_param
$LN179@ms64_param:

; 703  :       }
; 704  : 	  else if ((proc->sym.langtype == LANG_VECTORCALL) && (psize == 32) && (param->sym.ttype != 0) && (param->sym.ttype->e.structinfo->isHFA) && (param->sym.mem_type == MT_TYPE)) {

	cmp	edx, 8
	jne	$LN167@ms64_param
	cmp	r13d, 32				; 00000020H
	jne	$LN167@ms64_param
	mov	rcx, QWORD PTR [r14+88]
	test	rcx, rcx
	je	$LN167@ms64_param
	mov	rax, QWORD PTR [rcx+104]
	cmp	BYTE PTR [rax+22], bl
	je	$LN167@ms64_param
	cmp	DWORD PTR [r14+44], 196			; 000000c4H
	jne	$LN167@ms64_param

; 705  : 		  /* it can be only HFA data type made of 4 REAL8 */
; 706  : 		  t = param->sym.ttype;
; 707  : 		  if (t != 0 && t->e.structinfo->isHFA && (vcallpass == 1))

	cmp	BYTE PTR [rax+22], bl
	mov	r9, rax
	je	$LN46@ms64_param
	cmp	r11d, 1
	jne	$LN46@ms64_param

; 708  : 		  {
; 709  : 
; 710  : 			  freevecregs = 0;
; 711  : 			  vecidx = -1;

	lea	ecx, QWORD PTR [rdx-9]
	mov	r8d, ebx

; 712  : 			  for (i = 0; i < 6; i++)

	mov	eax, ebx
	lea	rdx, QWORD PTR [rdi+68]
	npad	4
$LL165@ms64_param:

; 713  : 			  {
; 714  : 				  if (info->vregs[i] == 0)

	cmp	BYTE PTR [rdx], bl
	jne	SHORT $LN164@ms64_param

; 715  : 				  {
; 716  : 					  if (vecidx == -1) vecidx = i;

	cmp	ecx, -1
	cmove	ecx, eax

; 717  : 					  freevecregs++;

	inc	r8d
$LN164@ms64_param:
	inc	eax
	inc	rdx
	cmp	eax, 6
	jl	SHORT $LL165@ms64_param

; 718  : 				  }
; 719  : 			  }
; 720  : 
; 721  : 			  memberCount = t->e.structinfo->memberCount;

	mov	r14d, DWORD PTR [r9+24]

; 722  : 			  if (memberCount > freevecregs) goto uselea;

	cmp	r14d, r8d
	jg	$LN392@ms64_param

; 723  : 			  membersize = psize / memberCount;          //get the size of a single element which is REAL4 in this case        

	xor	edx, edx
	mov	eax, 32					; 00000020H

; 724  : 			  j = 0;
; 725  : 			  tCount = memberCount;

	mov	r13d, r14d
	div	r14d

; 726  : 			  while (tCount > 0)

	test	r14d, r14d
	movsxd	rsi, ecx
	mov	edx, eax
	mov	DWORD PTR membersize$5$[rsp], eax
	jle	$LN46@ms64_param

; 723  : 			  membersize = psize / memberCount;          //get the size of a single element which is REAL4 in this case        

	lea	r12d, DWORD PTR [rcx+40]
	npad	6
$LL159@ms64_param:

; 727  : 			  {
; 728  : 				  if (info->vregs[vecidx] == 0)

	cmp	BYTE PTR [rsi+rdi+68], 0
	jne	SHORT $LN157@ms64_param

; 729  : 				  {
; 730  : 					  info->vregs[vecidx] = 1;
; 731  : 					  info->vecregs[index] = memberCount;        //store number of members in proper location pointed by index
; 732  : 					  info->vsize += membersize;                      //vsize contains total size 
; 733  : 					  info->vecregsize[vecidx] = membersize;      //size of data tu be put in register
; 734  : 					  info->xyzused[vecidx] = 1;                  //mark that the placeholder for register is used
; 735  : 					  AddLineQueueX("%s %r,qword ptr [%s+%d]", MOVE_DOUBLE, T_XMM0 + vecidx, paramvalue, j * 8);

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	BYTE PTR [rsi+rdi+68], 1
	mov	BYTE PTR [rbp+rdi+56], r14b
	add	DWORD PTR [rdi+44], edx
	mov	BYTE PTR [rsi+rdi+62], dl
	mov	BYTE PTR [rsi+rdi+74], 1
	mov	rdx, QWORD PTR MOVE_DOUBLE
	lea	rcx, OFFSET FLAT:$SG6086
	mov	r8d, r12d
	mov	DWORD PTR [rsp+32], ebx
	call	AddLineQueueX
	mov	edx, DWORD PTR membersize$5$[rsp]

; 736  : 					  tCount--;

	dec	r13d

; 737  : 					  j++;

	add	ebx, 8
$LN157@ms64_param:

; 738  : 				  }
; 739  : 				  vecidx++;

	inc	r12d
	inc	rsi
	test	r13d, r13d
	jg	SHORT $LL159@ms64_param

; 740  : 			  }
; 741  : 		  }
; 742  : 	  }
; 743  : 
; 744  :       else {

	jmp	$LN46@ms64_param
$LN167@ms64_param:

; 745  :       if ( addr || psize > 8 ) { /* psize > 8 should happen only for vectorcall */

	cmp	BYTE PTR addr$[rsp], bl
	jne	$LN154@ms64_param
	cmp	r13d, 8
	ja	$LN154@ms64_param

; 989  :         }
; 990  :         
; 991  : 	  if (vcallpass == 0)

	test	r11d, r11d
	jne	$LN46@ms64_param

; 992  : 	  {
; 993  : 		  /* register argument? */
; 994  : 		  if (opnd->kind == EXPR_REG && opnd->indirect == FALSE) {

	mov	eax, DWORD PTR [r12+60]
	cmp	eax, 2
	jne	SHORT $LN44@ms64_param
	test	BYTE PTR [r12+72], 1
	jne	SHORT $LN44@ms64_param

; 995  : 			  reg = opnd->base_reg->tokval;

	mov	rax, QWORD PTR [r12+24]
	mov	esi, DWORD PTR [rax+16]

; 996  : 			  size = SizeFromRegister(reg);

	mov	ecx, esi
	call	SizeFromRegister
	mov	r15d, 4
	mov	edi, eax
$LN32@ms64_param:

; 1017 : 
; 1018 : 		  /* v2.11: allow argument extension, so long as the target isn't a pointer */
; 1019 : 		  //if ( size != psize && param->sym.is_vararg == FALSE ) {
; 1020 : 		  if (size > psize || (size < psize && param->sym.mem_type == MT_PTR)) {

	cmp	edi, r13d
	ja	SHORT $LN30@ms64_param
	cmp	edi, r13d
	jae	SHORT $LN31@ms64_param
	cmp	DWORD PTR [r14+44], 195			; 000000c3H
	jne	SHORT $LN31@ms64_param
$LN30@ms64_param:

; 1021 : 			  DebugMsg(("ms64_param(%s, param=%u): type error size.p/a=%u/%u flags=%X\n", proc->sym.name, index, psize, size, *regs_used));
; 1022 : 			  EmitErr(INVOKE_ARGUMENT_TYPE_MISMATCH, index + 1);

	lea	edx, DWORD PTR [rbp+1]
	mov	ecx, 145				; 00000091H
	call	EmitErr
$LN31@ms64_param:

; 1023 : 		  }
; 1024 : 		  /* v2.11: use parameter size to allow argument extension */
; 1025 : 		  switch (psize) {

	mov	eax, r13d
	dec	eax
	je	$LN27@ms64_param
	dec	eax
	je	$LN26@ms64_param
	cmp	eax, 2
	je	$LN25@ms64_param

; 1029 : 		  default:base = 3 * 4; break;

	mov	r14d, 12
	jmp	$LN28@ms64_param
$LN44@ms64_param:

; 997  : 		  }
; 998  : 		  else if (opnd->kind == EXPR_CONST || opnd->kind == EXPR_FLOAT) {

	test	eax, eax
	je	$LN41@ms64_param
	cmp	eax, 3
	je	$LN41@ms64_param

; 1000 : 		  }
; 1001 : 		  else if (opnd->mem_type != MT_EMPTY) {

	mov	ecx, DWORD PTR [r12+64]
	cmp	ecx, 192				; 000000c0H
	je	SHORT $LN39@ms64_param

; 1002 : 			  size = SizeFromMemtype(opnd->mem_type, USE64, opnd->type);

	mov	r8, QWORD PTR [r12+96]
	mov	edx, 2
	call	SizeFromMemtype
	mov	r15d, 4
	mov	edi, eax
	jmp	SHORT $LN32@ms64_param
$LN39@ms64_param:

; 1003 : 		  }
; 1004 : 		  else if (opnd->kind == EXPR_ADDR && opnd->sym != NULL && opnd->sym->state == SYM_UNDEFINED) {

	cmp	eax, 1
	jne	SHORT $LN37@ms64_param
	mov	rcx, QWORD PTR [r12+80]
	test	rcx, rcx
	je	SHORT $LN37@ms64_param
	cmp	DWORD PTR [rcx+40], ebx
	jne	SHORT $LN37@ms64_param

; 1005 : 			  DebugMsg1(("ms64_param(%s, param=%u): forward ref=%s, assumed size=%u\n", proc->sym.name, index, opnd->sym->name, psize));
; 1006 : 			  size = psize;

	mov	edi, r13d
	lea	r15d, QWORD PTR [rax+3]
	jmp	SHORT $LN31@ms64_param
$LN37@ms64_param:

; 1007 : 		  }
; 1008 : 		  else if (opnd->kind == EXPR_ADDR && opnd->sym == NULL) {

	cmp	eax, 1
	jne	SHORT $LN35@ms64_param
	cmp	QWORD PTR [r12+80], rbx
	jne	SHORT $LN35@ms64_param

; 1009 : 			  size = psize;

	mov	edi, r13d
	lea	r15d, QWORD PTR [rax+3]
	jmp	$LN31@ms64_param
$LN35@ms64_param:

; 1010 : 		  }
; 1011 : 		  else if (opnd->kind == EXPR_REG && opnd->indirect == TRUE)

	cmp	eax, 2
	jne	SHORT $LN33@ms64_param
	test	BYTE PTR [r12+72], 1
	je	SHORT $LN33@ms64_param

; 1012 : 		  {
; 1013 : 			  size = psize;

	mov	edi, r13d

; 1014 : 		  }
; 1015 : 		  else

	lea	r15d, QWORD PTR [rax+2]
	jmp	$LN31@ms64_param
$LN33@ms64_param:

; 1016 : 			  size = (opnd->instr == T_OFFSET ? 8 : 4);

	cmp	DWORD PTR [r12+56], 241			; 000000f1H
	mov	r15d, 4
	mov	eax, 8
	mov	edi, r15d
	cmove	edi, eax
	jmp	$LN32@ms64_param
$LN41@ms64_param:

; 999  : 			  size = psize;

	mov	edi, r13d

; 1017 : 
; 1018 : 		  /* v2.11: allow argument extension, so long as the target isn't a pointer */
; 1019 : 		  //if ( size != psize && param->sym.is_vararg == FALSE ) {
; 1020 : 		  if (size > psize || (size < psize && param->sym.mem_type == MT_PTR)) {

	mov	r15d, 4
	jmp	$LN31@ms64_param
$LN25@ms64_param:

; 1028 : 		  case 4: base = 2 * 4; break;

	mov	r14d, 8
	jmp	SHORT $LN28@ms64_param
$LN26@ms64_param:

; 1027 : 		  case 2: base = 1 * 4; break;

	mov	r14d, r15d
	jmp	SHORT $LN28@ms64_param
$LN27@ms64_param:

; 1026 : 		  case 1: base = 0 * 4; break;

	mov	r14d, ebx
$LN28@ms64_param:

; 1030 : 		  }
; 1031 : 		  /* optimization if the register holds the value already */
; 1032 : 		  if (opnd->kind == EXPR_REG && opnd->indirect == FALSE) {

	cmp	DWORD PTR [r12+60], 2
	jne	$LN387@ms64_param
	test	BYTE PTR [r12+72], 1
	jne	$LN388@ms64_param

; 1033 : 			  if (GetValueSp(reg) & OP_R) {

	movsxd	rax, esi
	lea	r8, OFFSET FLAT:__ImageBase
	lea	rdx, QWORD PTR [rax+rax*2]
	test	BYTE PTR SpecialTable[r8+rdx*4], 15
	je	$LN389@ms64_param

; 1034 : 				  if (ms64_regs[index+base] == reg) {

	movsxd	rcx, r14d
	add	rcx, rbp
	cmp	DWORD PTR ms64_regs[r8+rcx*4], esi

; 1035 : 					  DebugMsg(("ms64_param(%s, param=%u): argument optimized\n", proc->sym.name, index));
; 1036 : 					  return(1);

	je	$LN46@ms64_param

; 1037 : 				  }
; 1038 : 				  i = GetRegNo(reg);

	lea	rsi, OFFSET FLAT:__ImageBase
	movzx	ecx, BYTE PTR SpecialTable[rsi+rdx*4+10]

; 1039 : 				  if (REGPAR_WIN64 & (1 << i)) {

	mov	edx, 1
	mov	eax, edx
	shl	eax, cl
	test	eax, 774				; 00000306H
	je	SHORT $LN390@ms64_param

; 1040 : 					  i = GetParmIndex(i);

	cmp	ecx, 8
	jl	SHORT $LN337@ms64_param
	sub	ecx, 6
	jmp	SHORT $LN338@ms64_param
$LN337@ms64_param:
	dec	ecx
$LN338@ms64_param:

; 1041 : 					  if (*regs_used & (1 << (i + RPAR_START)))

	mov	r15, QWORD PTR regs_used$[rsp]
	add	ecx, 3
	shl	edx, cl
	test	dl, BYTE PTR [r15]
	je	SHORT $LN398@ms64_param

; 1042 : 						  EmitErr(REGISTER_VALUE_OVERWRITTEN_BY_INVOKE);

	mov	ecx, 165				; 000000a5H
	call	EmitErr
	mov	edx, 1
	jmp	SHORT $LN19@ms64_param
$LN387@ms64_param:

; 318  :                 if ( *regs_used & ( 1 << ( base + RPAR_START ) ) )

	mov	r15, QWORD PTR regs_used$[rsp]
	lea	rsi, OFFSET FLAT:__ImageBase
	mov	edx, 1
	jmp	SHORT $LN19@ms64_param
$LN388@ms64_param:
	mov	r15, QWORD PTR regs_used$[rsp]
	lea	rsi, OFFSET FLAT:__ImageBase
	mov	edx, 1
	jmp	SHORT $LN19@ms64_param
$LN389@ms64_param:
	mov	r15, QWORD PTR regs_used$[rsp]
	lea	rsi, OFFSET FLAT:__ImageBase
	mov	edx, 1
	jmp	SHORT $LN19@ms64_param
$LN390@ms64_param:
	mov	r15, QWORD PTR regs_used$[rsp]
	jmp	SHORT $LN19@ms64_param
$LN398@ms64_param:

; 270  : {

	mov	edx, 1
$LN19@ms64_param:

; 1043 : 				  }
; 1044 : 			  }
; 1045 : 		  }
; 1046 : 
; 1047 : 		  /* v2.11: allow argument extension */
; 1048 : 		  if (size < psize)

	cmp	edi, r13d
	jae	$LN18@ms64_param

; 1049 : 			  if (size == 4) {

	cmp	edi, 4
	jne	SHORT $LN17@ms64_param

; 1050 : 				  if (IS_SIGNED(opnd->mem_type))

	mov	eax, DWORD PTR [r12+64]
	and	al, -64					; ffffffffffffffc0H
	cmp	al, 64					; 00000040H
	jne	SHORT $LN16@ms64_param

; 1051 : 					  AddLineQueueX(" movsxd %r, %s", ms64_regs[index + base], paramvalue);

	mov	r8, QWORD PTR paramvalue$[rsp]
	movsxd	rcx, r14d
	add	rcx, rbp
	mov	edx, DWORD PTR ms64_regs[rsi+rcx*4]
	lea	rcx, OFFSET FLAT:$SG6263
	call	AddLineQueueX

; 1080 : 			  }
; 1081 : 		  }
; 1082 : 		  *regs_used |= (1 << (index + RPAR_START - 1));

	lea	ecx, DWORD PTR [rbp+2]
	mov	eax, 1
	shl	al, cl
	or	BYTE PTR [r15], al
	jmp	$LN46@ms64_param
$LN16@ms64_param:

; 1052 : 				  else
; 1053 : 					  AddLineQueueX(" mov %r, %s", ms64_regs[index + 2 * 4], paramvalue);

	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, DWORD PTR ms64_regs[rsi+rbp*4+32]
	lea	rcx, OFFSET FLAT:$SG6265
	call	AddLineQueueX

; 1080 : 			  }
; 1081 : 		  }
; 1082 : 		  *regs_used |= (1 << (index + RPAR_START - 1));

	lea	ecx, DWORD PTR [rbp+2]
	mov	eax, 1
	shl	al, cl
	or	BYTE PTR [r15], al
	jmp	$LN46@ms64_param
$LN17@ms64_param:

; 1054 : 			  }
; 1055 :         else
; 1056 :           AddLineQueueX(" mov%sx %r, %s", IS_SIGNED(opnd->mem_type) ? "s" : "z", ms64_regs[index + base], paramvalue);

	mov	eax, DWORD PTR [r12+64]
	mov	r9, QWORD PTR paramvalue$[rsp]
	lea	r8, OFFSET FLAT:$SG6267
	and	al, -64					; ffffffffffffffc0H
	movsxd	rcx, r14d
	lea	rdx, OFFSET FLAT:$SG6268
	add	rcx, rbp
	cmp	al, 64					; 00000040H
	cmove	rdx, r8
	mov	r8d, DWORD PTR ms64_regs[rsi+rcx*4]
	lea	rcx, OFFSET FLAT:$SG6269
	call	AddLineQueueX

; 1080 : 			  }
; 1081 : 		  }
; 1082 : 		  *regs_used |= (1 << (index + RPAR_START - 1));

	lea	ecx, DWORD PTR [rbp+2]
	mov	eax, 1
	shl	al, cl
	or	BYTE PTR [r15], al
	jmp	$LN46@ms64_param
$LN18@ms64_param:

; 1057 : 		  else {
; 1058 :         *regs_used |= ( 1 << ( index + RPAR_START ) );
; 1059 :         DebugMsg1(("ms64_param(%s, param=%u): size=%u flags=%X\n", proc->sym.name, index, size, *regs_used));
; 1060 : 			  /* v2.12 added by habran : if parametar  is zero use 'xor reg,reg' instead of 'mov reg,0' */
; 1061 : 			  if ((!strcasecmp(paramvalue, "0") || (!strcasecmp(paramvalue, "NULL")) || (!strcasecmp(paramvalue, "FALSE")))) {

	mov	rbx, QWORD PTR paramvalue$[rsp]
	mov	eax, edx
	lea	ecx, DWORD PTR [rbp+3]
	shl	al, cl
	lea	rdx, OFFSET FLAT:$SG6273
	mov	rcx, rbx
	or	BYTE PTR [r15], al
	call	_stricmp
	test	eax, eax
	je	$LN11@ms64_param
	lea	rdx, OFFSET FLAT:$SG6274
	mov	rcx, rbx
	call	_stricmp
	test	eax, eax
	je	$LN11@ms64_param
	lea	rdx, OFFSET FLAT:$SG6275
	mov	rcx, rbx
	call	_stricmp
	test	eax, eax
	je	$LN11@ms64_param

; 1065 : 			  }
; 1066 : 			  else
; 1067 : 			  {
; 1068 : 				  if (index > 3)

	cmp	ebp, 3
	jle	SHORT $LN8@ms64_param

; 1069 : 				  {
; 1070 : 					  switch (psize) {

	dec	r13d
	je	SHORT $LN5@ms64_param
	dec	r13d
	je	SHORT $LN4@ms64_param
	cmp	r13d, 2
	je	SHORT $LN3@ms64_param

; 1074 : 					  default:  i = T_QWORD; break;

	mov	esi, 213				; 000000d5H
	jmp	SHORT $LN6@ms64_param
$LN3@ms64_param:

; 1073 : 					  case 4:   i = T_DWORD; break;

	mov	esi, 209				; 000000d1H
	jmp	SHORT $LN6@ms64_param
$LN4@ms64_param:

; 1072 : 					  case 2:   i = T_WORD; break;

	mov	esi, 207				; 000000cfH
	jmp	SHORT $LN6@ms64_param
$LN5@ms64_param:

; 1071 : 					  case 1:   i = T_BYTE; break;

	mov	esi, 205				; 000000cdH
$LN6@ms64_param:

; 1075 : 					  }
; 1076 : 					  AddLineQueueX(" mov %r ptr [%r+%u], %s", i, T_RSP, NUMQUAL index * 8, paramvalue);

	lea	r9d, DWORD PTR [rbp*8]
	lea	rcx, OFFSET FLAT:$SG6288
	mov	r8d, 119				; 00000077H
	mov	edx, esi
	mov	QWORD PTR [rsp+32], rbx
	call	AddLineQueueX

; 1080 : 			  }
; 1081 : 		  }
; 1082 : 		  *regs_used |= (1 << (index + RPAR_START - 1));

	lea	ecx, DWORD PTR [rbp+2]
	mov	eax, 1
	shl	al, cl
	or	BYTE PTR [r15], al
	jmp	$LN46@ms64_param
$LN8@ms64_param:

; 1077 : 				  }
; 1078 : 				  else
; 1079 : 					  AddLineQueueX(" mov %r, %s", ms64_regs[index + base], paramvalue);

	movsxd	rcx, r14d
	mov	r8, rbx
	add	rcx, rbp
	mov	edx, DWORD PTR ms64_regs[rsi+rcx*4]
	lea	rcx, OFFSET FLAT:$SG6290
	call	AddLineQueueX

; 1080 : 			  }
; 1081 : 		  }
; 1082 : 		  *regs_used |= (1 << (index + RPAR_START - 1));

	lea	ecx, DWORD PTR [rbp+2]
	mov	eax, 1
	shl	al, cl
	or	BYTE PTR [r15], al
	jmp	$LN46@ms64_param
$LN11@ms64_param:

; 1062 : 				  if (ms64_regs[index + base] > T_R9D) index -= 4;

	movsxd	rcx, r14d
	lea	rax, QWORD PTR [rcx+rbp]
	cmp	DWORD PTR ms64_regs[rsi+rax*4], 108	; 0000006cH
	jle	SHORT $LN10@ms64_param
	sub	ebp, 4
$LN10@ms64_param:

; 1063 : 				  AddLineQueueX(" xor %r, %r", ms64_regs[index + base], ms64_regs[index + base]);

	movsxd	rax, ebp
	add	rax, rcx
	lea	rcx, OFFSET FLAT:$SG6277
	mov	edx, DWORD PTR ms64_regs[rsi+rax*4]
	mov	r8d, edx
	call	AddLineQueueX

; 1064 : 				  return(1);

	jmp	$LN46@ms64_param
$LN154@ms64_param:

; 746  : 		  if (psize >= 4) {

	cmp	r13d, 4
	jb	$LN153@ms64_param

; 747  : 			  if (proc->sym.langtype == LANG_VECTORCALL) {

	cmp	edx, 8
	jne	$LN397@ms64_param

; 748  : 				  if ((param->sym.mem_type == MT_TYPE)) {

	cmp	DWORD PTR [r14+44], 196			; 000000c4H
	jne	$LN151@ms64_param

; 749  : 					  t = param->sym.ttype;
; 750  : 
; 751  : 					  if (vcallpass == 0 && opnd->kind == EXPR_REG && opnd->indirect == FALSE && reg < T_XMM6 && index < 6 && info->vecregs[(reg - T_XMM0)] != 0 && (index != reg-T_XMM0))

	test	r11d, r11d
	mov	r10, QWORD PTR [r14+88]
	jne	SHORT $LN150@ms64_param
	cmp	DWORD PTR [r12+60], 2
	jne	SHORT $LN150@ms64_param
	test	BYTE PTR [r12+72], 1
	jne	SHORT $LN150@ms64_param
	cmp	esi, 46					; 0000002eH
	jge	SHORT $LN150@ms64_param
	cmp	ebp, 6
	jge	SHORT $LN150@ms64_param
	movsxd	rax, esi
	cmp	BYTE PTR [rax+rdi+16], bl
	je	SHORT $LN150@ms64_param
	lea	eax, DWORD PTR [rsi-40]
	cmp	ebp, eax
	je	SHORT $LN150@ms64_param

; 752  : 					  {
; 753  : 						  EmitErr(REGISTER_VALUE_OVERWRITTEN_BY_INVOKE, index);

	mov	edx, ebp
	mov	ecx, 165				; 000000a5H

; 754  : 						  return(1);

	jmp	$LN399@ms64_param
$LN150@ms64_param:

; 755  : 					  }
; 756  : 
; 757  : 					  if (t->e.structinfo->stype == MM128 && vcallpass==0) {

	mov	r9, QWORD PTR [r10+104]
	mov	edx, DWORD PTR [r9+16]
	cmp	edx, 1
	jne	$LN149@ms64_param
	test	r11d, r11d
	jne	$LN149@ms64_param

; 758  : 						  if (opnd->kind == EXPR_REG && opnd->indirect == FALSE) {

	cmp	DWORD PTR [r12+60], 2
	jne	$LN140@ms64_param
	test	BYTE PTR [r12+72], dl
	jne	$LN140@ms64_param

; 759  : 							  if ((GetValueSp(reg) & OP_XMM)|| t->e.structinfo->isHFA ) {

	movsxd	rax, esi
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rax, OFFSET FLAT:__ImageBase
	test	BYTE PTR SpecialTable[rax+rcx*4], 32	; 00000020H
	jne	SHORT $LN146@ms64_param
	cmp	BYTE PTR [r9+22], bl
	je	$LN140@ms64_param
$LN146@ms64_param:

; 760  : 
; 761  : 								  t->e.structinfo->memberCount = 1;

	mov	DWORD PTR [r9+24], r8d

; 762  : 								  info->vregs[index] = 1;
; 763  : 								  info->vecregs[index] = 1;
; 764  : 								  info->xyzused[index] = 1;
; 765  : 								  info->vsize += 16;
; 766  : 								  info->vecregsize[index] = 16;
; 767  : 								  if (reg == T_XMM0 + index)

	lea	r8d, DWORD PTR [rbp+40]
	mov	BYTE PTR [rbp+rdi+68], 1
	mov	BYTE PTR [rbp+rdi+56], 1
	mov	BYTE PTR [rbp+rdi+74], 1
	add	DWORD PTR [rdi+44], 16
	cmp	esi, r8d
	mov	BYTE PTR [rbp+rdi+62], 16
	je	$LN46@ms64_param

; 768  : 									  DebugMsg(("ms64_param(%s, param=%u): argument optimized\n", proc->sym.name, index));
; 769  : 								  else
; 770  : 									  AddLineQueueX("%s %r,oword ptr %s", MOVE_ALIGNED_FLOAT, T_XMM0 + index, paramvalue);

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	rdx, QWORD PTR MOVE_ALIGNED_FLOAT
	lea	rcx, OFFSET FLAT:$SG6100
	call	AddLineQueueX

; 771  : 								  return(1);

	jmp	$LN46@ms64_param
$LN149@ms64_param:

; 772  : 							  }
; 773  : 						  }
; 774  : 					  }
; 775  : 					  else if (t->e.structinfo->stype == MM256 && vcallpass == 0) {

	cmp	edx, 2
	jne	SHORT $LN140@ms64_param
	test	r11d, r11d
	jne	SHORT $LN140@ms64_param

; 776  : 						  if (opnd->kind == EXPR_REG && opnd->indirect == FALSE) {

	cmp	DWORD PTR [r12+60], edx
	jne	SHORT $LN140@ms64_param
	test	BYTE PTR [r12+72], 1
	jne	SHORT $LN140@ms64_param

; 777  : 							  if (GetValueSp(reg) & OP_YMM) {

	movsxd	rax, esi
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rax, OFFSET FLAT:__ImageBase
	test	BYTE PTR SpecialTable[rax+rcx*4], 128	; 00000080H
	je	SHORT $LN140@ms64_param

; 778  : 								  t->e.structinfo->memberCount = 1;

	mov	DWORD PTR [r9+24], r8d

; 779  : 								  info->vregs[index] = 1;
; 780  : 								  info->xyzused[index] = 1;
; 781  : 								  info->vsize += 32;
; 782  : 								  info->vecregsize[index] = 32;
; 783  : 								  if (reg == T_YMM0 + index)

	lea	edx, DWORD PTR [rbp+56]
	mov	BYTE PTR [rbp+rdi+68], 1
	mov	BYTE PTR [rbp+rdi+74], 1
	add	DWORD PTR [rdi+44], 32			; 00000020H
	cmp	esi, edx
	mov	BYTE PTR [rbp+rdi+62], 32		; 00000020H
	je	SHORT $LN138@ms64_param

; 784  : 									  DebugMsg(("ms64_param(%s, param=%u): argument optimized\n", proc->sym.name, index));
; 785  : 								  else
; 786  : 									  AddLineQueueX("vmovaps %r,ymmword ptr %s", T_YMM0 + index, paramvalue);

	mov	r8, QWORD PTR paramvalue$[rsp]
	lea	rcx, OFFSET FLAT:$SG6107
	call	AddLineQueueX
	mov	r8d, 1
$LN138@ms64_param:

; 787  : 								  return(1);

	mov	eax, r8d
	jmp	$LN331@ms64_param
$LN140@ms64_param:

; 788  : 							  }
; 789  : 						  }
; 790  : 					  }
; 791  : #if EVEXSUPP
; 792  : 					  else if (t->e.structinfo->stype == MM512 && vcallpass == 0) {
; 793  : 						  if (opnd->kind == EXPR_REG && opnd->indirect == FALSE) {
; 794  : 							  if (GetValueSp(reg) & OP_YMM) {
; 795  : 								  t->e.structinfo->memberCount = 1;
; 796  : 								  info->vregs[index] = 1;
; 797  : 								  info->xyzused[index] = 1;
; 798  : 								  info->vsize += 64;
; 799  : 								  info->vecregsize[index] = 64;
; 800  : 								  if (reg == T_YMM0 + index)
; 801  : 									  DebugMsg(("ms64_param(%s, param=%u): argument optimized\n", proc->sym.name, index));
; 802  : 								  else
; 803  : 									  AddLineQueueX("vmovaps %r,ymmword ptr %s", T_YMM0 + index, paramvalue);
; 804  : 								  return(1);
; 805  : 							  }
; 806  : 						  }
; 807  : 					  }
; 808  : #endif                
; 809  : 
; 810  : 					  if (t->e.structinfo->stype == MM128)

	cmp	edx, 1
	jne	SHORT $LN137@ms64_param

; 811  : 						  membersize = 16;

	lea	r8d, QWORD PTR [rdx+15]
	jmp	SHORT $LN135@ms64_param
$LN137@ms64_param:

; 812  : 					  else if (t->e.structinfo->stype == MM256)

	mov	r8d, ebx
	mov	eax, 32					; 00000020H
	cmp	edx, 2
	cmove	r8d, eax
$LN135@ms64_param:

; 813  : 						  membersize = 32;
; 814  : #if EVEXSUPP
; 815  : 					  else if (t->e.structinfo->stype == MM512)
; 816  : 						  membersize = 64;
; 817  : #endif            
; 818  : 					  memberCount = t->e.structinfo->memberCount;
; 819  : 					  if (t->e.structinfo->isHVA) {

	cmp	BYTE PTR [r9+21], bl
	mov	r12d, DWORD PTR [r9+24]
	je	SHORT $LN134@ms64_param

; 820  : 						  if (memberCount)

	test	r12d, r12d
	je	SHORT $LN128@ms64_param

; 821  : 							  membersize = psize / memberCount;

	xor	edx, edx
	mov	eax, r13d
	div	r12d
	mov	r8d, eax

; 822  : 					  }
; 823  : 					  else if ((t->e.structinfo->isHFA)|| (proc->e.procinfo->paralist->sym.type && proc->e.procinfo->paralist->sym.type->max_mbr_size == 4))  {

	jmp	SHORT $LN128@ms64_param
$LN134@ms64_param:
	cmp	BYTE PTR [r9+22], bl
	jne	SHORT $LN130@ms64_param
	mov	rax, QWORD PTR [r15+104]
	mov	rcx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rcx+88]
	test	rax, rax
	je	SHORT $LN131@ms64_param
	cmp	DWORD PTR [rax+56], 4
	je	SHORT $LN130@ms64_param
$LN131@ms64_param:

; 826  : 					  }
; 827  : 					  else if (vcallpass == 0 && t->e.structinfo->stype != MM128 && t->e.structinfo->stype != MM256) {

	test	r11d, r11d
	jne	SHORT $LN128@ms64_param
	cmp	edx, 1
	je	SHORT $LN128@ms64_param
	cmp	edx, 2
	je	SHORT $LN128@ms64_param

; 828  : 						  goto uselea;

	lea	r9d, QWORD PTR [r11+1]
	jmp	$uselea$6017
$LN130@ms64_param:

; 824  : 						  membersize = psize;

	mov	r8d, r13d

; 825  : 						  memberCount = 1;

	mov	r12d, 1
$LN128@ms64_param:

; 829  : 					  }
; 830  :             if (t->e.structinfo->isHFA) memberCount = 1;

	cmp	BYTE PTR [r9+22], bl
	mov	r9d, 1
	cmovne	r12d, r9d

; 831  : 					  info->vecregs[index] = memberCount;

	mov	BYTE PTR [rbp+rdi+56], r12b

; 832  : 					  info->vsize += psize;

	add	DWORD PTR [rdi+44], r13d

; 833  : 					  info->vecregsize[index] = membersize;
; 834  : 					  if (((vcallpass == 1) && t->e.structinfo->isHVA) || t->e.structinfo->stype == MM128 || t->e.structinfo->stype == MM256) {

	cmp	r11d, r9d
	mov	BYTE PTR [rbp+rdi+62], r8b
	jne	SHORT $LN124@ms64_param
	mov	rax, QWORD PTR [r10+104]
	cmp	BYTE PTR [rax+21], bl
	jne	SHORT $LN125@ms64_param
$LN124@ms64_param:
	mov	rax, QWORD PTR [r10+104]
	mov	ecx, DWORD PTR [rax+16]
	cmp	ecx, r9d
	je	SHORT $LN125@ms64_param
	cmp	ecx, 2
	jne	$LN46@ms64_param
$LN125@ms64_param:

; 835  : 						  for (i = 0, j = 0; i < 6; i++) {

	mov	edx, ebx
	mov	rcx, rbx
$LL123@ms64_param:

; 836  : 							  j += info->vregs[i];

	movzx	eax, BYTE PTR [rcx+rdi+68]
	add	edx, eax

; 837  : 							  if (info->vregs[i]) {

	test	al, al
	je	SHORT $LN122@ms64_param

; 838  : 								  info->xyzused[i] = 1;

	mov	BYTE PTR [rcx+rdi+74], r9b
$LN122@ms64_param:

; 835  : 						  for (i = 0, j = 0; i < 6; i++) {

	inc	rcx
	cmp	rcx, 6
	jl	SHORT $LL123@ms64_param

; 839  : 							  }
; 840  : 							  else if ((info->vregs[i] >= 1) && (info->xyzused[i] != 1))
; 841  : 								  info->xyzused[i] = 0;
; 842  : 						  }
; 843  : 						  if (j > 6)goto uselea;

	cmp	edx, 6
	jg	$uselea$6017

; 844  : 						  for (i = 0, j = 0; i < 6; i++) {

	mov	ecx, ebx
	mov	rax, rbx
	lea	rsi, QWORD PTR [rdi+74]
	npad	5
$LL116@ms64_param:

; 845  : 							  if (info->xyzused[i] == 0)

	cmp	BYTE PTR [rax+rsi], bl
	jne	SHORT $LN115@ms64_param

; 846  : 								  j++;

	inc	ecx
$LN115@ms64_param:

; 844  : 						  for (i = 0, j = 0; i < 6; i++) {

	inc	rax
	cmp	rax, 6
	jl	SHORT $LL116@ms64_param

; 847  : 						  }
; 848  : 						  if (vcallpass == 1 && memberCount > j && (t->e.structinfo->isHFA || t->e.structinfo->isHVA)) goto uselea;

	cmp	r11d, r9d
	jne	SHORT $LN112@ms64_param
	cmp	r12d, ecx
	jle	SHORT $LN112@ms64_param
	mov	rax, QWORD PTR [r10+104]
	cmp	BYTE PTR [rax+22], bl
	jne	$uselea$6017
	cmp	BYTE PTR [rax+21], bl
	jne	$uselea$6017
$LN112@ms64_param:

; 849  : 
; 850  : 						  switch (membersize) {

	cmp	r8d, 4
	je	$LN108@ms64_param
	cmp	r8d, 8
	je	$LN100@ms64_param
	cmp	r8d, 16
	je	$LN92@ms64_param
	cmp	r8d, 32					; 00000020H
	jne	$LN46@ms64_param

; 883  : 						  case 32:
; 884  : 							  if ((vcallpass == 0) && t->e.structinfo->stype == MM256)

	test	r11d, r11d
	jne	SHORT $LN79@ms64_param
	mov	rax, QWORD PTR [r10+104]
	cmp	DWORD PTR [rax+16], 2
	jne	$LN46@ms64_param

; 885  : 							  {
; 886  : 								  AddLineQueueX("vmovups %r,oword ptr %s", T_YMM0 + index, paramvalue);

	mov	r8, QWORD PTR paramvalue$[rsp]
	lea	edx, DWORD PTR [rbp+56]
	lea	rcx, OFFSET FLAT:$SG6179
	call	AddLineQueueX

; 887  : 								  info->xyzused[index] = 1;

	mov	BYTE PTR [rbp+rdi+74], 1
	jmp	$LN46@ms64_param
$LN79@ms64_param:

; 888  : 							  }
; 889  : 							  else if ((vcallpass == 1) && (t->e.structinfo->isHFA || t->e.structinfo->isHVA))

	cmp	r11d, r9d
	jne	$LN46@ms64_param
	mov	rax, QWORD PTR [r10+104]
	cmp	BYTE PTR [rax+22], bl
	jne	SHORT $LN76@ms64_param
	cmp	BYTE PTR [rax+21], bl
	je	$LN46@ms64_param
$LN76@ms64_param:

; 890  : 							  {
; 891  : 								  for (i = 0, j = 0; i < memberCount; i++) {

	test	r12d, r12d
	mov	ebp, ebx
	mov	rdi, rbx
	jle	$LN46@ms64_param
	mov	r13, QWORD PTR paramvalue$[rsp]
	mov	rax, rsi
$LL75@ms64_param:

; 892  : 									  while (info->xyzused[j] != 0) j++;

	cmp	BYTE PTR [rax], 0
	je	SHORT $LN71@ms64_param
$LL72@ms64_param:
	inc	rdi
	inc	ebp
	cmp	BYTE PTR [rdi+rsi], 0
	jne	SHORT $LL72@ms64_param
$LN71@ms64_param:

; 893  : 									  if (i == 0) AddLineQueueX("vmovups %r,ymmword ptr %s", T_YMM0 + j, paramvalue);

	test	ebx, ebx
	jne	SHORT $LN70@ms64_param
	lea	edx, DWORD PTR [rbp+56]
	lea	rcx, OFFSET FLAT:$SG6190
	mov	r8, r13
	call	AddLineQueueX
	jmp	SHORT $LN69@ms64_param
$LN70@ms64_param:

; 894  : 									  else      AddLineQueueX("vmovups %r,ymmword ptr [%s+%d]", T_YMM0 + j, paramvalue, i * 32);

	mov	r9d, ebx
	lea	edx, DWORD PTR [rbp+56]
	lea	rcx, OFFSET FLAT:$SG6192
	shl	r9d, 5
	mov	r8, r13
	call	AddLineQueueX
$LN69@ms64_param:

; 895  : 									  info->xyzused[j] = 1;

	lea	rax, QWORD PTR [rdi+rsi]
	inc	ebx
	cmp	ebx, r12d
	mov	BYTE PTR [rax], 1
	jl	SHORT $LL75@ms64_param

; 896  : 								  }
; 897  : 							  }
; 898  : 							  break;

	jmp	$LN46@ms64_param
$LN92@ms64_param:

; 867  : 						  case 16:
; 868  : 							  if ((vcallpass == 0) && t->e.structinfo->stype == MM128)

	test	r11d, r11d
	jne	SHORT $LN91@ms64_param
	mov	rax, QWORD PTR [r10+104]
	cmp	DWORD PTR [rax+16], r9d
	jne	$LN46@ms64_param

; 869  : 							  {
; 870  : 								  AddLineQueueX("%s %r,oword ptr %s", MOVE_ALIGNED_FLOAT, T_XMM0 + index, paramvalue);

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	rdx, QWORD PTR MOVE_ALIGNED_FLOAT
	lea	r8d, DWORD PTR [rbp+40]
	lea	rcx, OFFSET FLAT:$SG6163
	call	AddLineQueueX

; 871  : 								  info->xyzused[index] = 1;

	mov	BYTE PTR [rbp+rdi+74], 1
	jmp	$LN46@ms64_param
$LN91@ms64_param:

; 872  : 							  }
; 873  : 							  else if ((vcallpass == 1) && (t->e.structinfo->isHFA || t->e.structinfo->isHVA))

	cmp	r11d, r9d
	jne	$LN46@ms64_param
	mov	rax, QWORD PTR [r10+104]
	cmp	BYTE PTR [rax+22], bl
	jne	SHORT $LN88@ms64_param
	cmp	BYTE PTR [rax+21], bl
	je	$LN46@ms64_param
$LN88@ms64_param:

; 874  : 							  {
; 875  : 								  for (i = 0, j = 0; i < memberCount; i++) {

	test	r12d, r12d
	mov	ebp, ebx
	mov	rdi, rbx
	jle	$LN46@ms64_param
	mov	r13, QWORD PTR paramvalue$[rsp]
	mov	rax, rsi
$LL87@ms64_param:

; 876  : 									  while (info->xyzused[j] != 0) j++;

	cmp	BYTE PTR [rax], 0
	je	SHORT $LN83@ms64_param
	npad	7
$LL84@ms64_param:
	inc	rdi
	inc	ebp
	cmp	BYTE PTR [rdi+rsi], 0
	jne	SHORT $LL84@ms64_param
$LN83@ms64_param:

; 877  : 									  if (i == 0) AddLineQueueX("%s %r,oword ptr %s", MOVE_ALIGNED_FLOAT, T_XMM0 + j, paramvalue);

	test	ebx, ebx
	jne	SHORT $LN82@ms64_param
	mov	rdx, QWORD PTR MOVE_ALIGNED_FLOAT
	lea	r8d, DWORD PTR [rbp+40]
	lea	rcx, OFFSET FLAT:$SG6174
	mov	r9, r13
	call	AddLineQueueX
	jmp	SHORT $LN81@ms64_param
$LN82@ms64_param:

; 878  : 									  else      AddLineQueueX("%s %r,oword ptr [%s+%d]", MOVE_ALIGNED_FLOAT, T_XMM0 + j, paramvalue, i * 16);

	mov	rdx, QWORD PTR MOVE_ALIGNED_FLOAT
	mov	eax, ebx
	lea	r8d, DWORD PTR [rbp+40]
	shl	eax, 4
	lea	rcx, OFFSET FLAT:$SG6176
	mov	r9, r13
	mov	DWORD PTR [rsp+32], eax
	call	AddLineQueueX
$LN81@ms64_param:

; 879  : 									  info->xyzused[j] = 1;

	lea	rax, QWORD PTR [rdi+rsi]
	inc	ebx
	cmp	ebx, r12d
	mov	BYTE PTR [rax], 1
	jl	SHORT $LL87@ms64_param

; 880  : 								  }
; 881  : 							  }
; 882  : 							  break;

	jmp	$LN46@ms64_param
$LN100@ms64_param:

; 857  : 							  }
; 858  : 							  break;
; 859  : 						  case 8:
; 860  : 							  for (i = 0, j = 0; i < memberCount; i++) {

	test	r12d, r12d
	mov	ebp, ebx
	mov	rdi, rbx
	jle	$LN46@ms64_param
	mov	r13, QWORD PTR paramvalue$[rsp]
	mov	rax, rsi
	npad	6
$LL99@ms64_param:

; 861  : 								  while (info->xyzused[j] != 0) j++;

	cmp	BYTE PTR [rax], 0
	je	SHORT $LN95@ms64_param
$LL96@ms64_param:
	inc	rdi
	inc	ebp
	cmp	BYTE PTR [rdi+rsi], 0
	jne	SHORT $LL96@ms64_param
$LN95@ms64_param:

; 862  : 								  if (i == 0) AddLineQueueX("%s %r,oword ptr %s", MOVE_DOUBLE, T_XMM0 + j, paramvalue);

	test	ebx, ebx
	jne	SHORT $LN94@ms64_param
	mov	rdx, QWORD PTR MOVE_DOUBLE
	lea	r8d, DWORD PTR [rbp+40]
	lea	rcx, OFFSET FLAT:$SG6158
	mov	r9, r13
	call	AddLineQueueX
	jmp	SHORT $LN93@ms64_param
$LN94@ms64_param:

; 863  : 								  else      AddLineQueueX("%s %r,oword ptr [%s+%d]", MOVE_DOUBLE, T_XMM0 + j, paramvalue, i * 8);

	mov	rdx, QWORD PTR MOVE_DOUBLE
	lea	eax, DWORD PTR [rbx*8]
	lea	r8d, DWORD PTR [rbp+40]
	lea	rcx, OFFSET FLAT:$SG6160
	mov	r9, r13
	mov	DWORD PTR [rsp+32], eax
	call	AddLineQueueX
$LN93@ms64_param:

; 864  : 								  info->xyzused[j] = 1;

	lea	rax, QWORD PTR [rdi+rsi]
	inc	ebx
	cmp	ebx, r12d
	mov	BYTE PTR [rax], 1
	jl	SHORT $LL99@ms64_param

; 865  : 							  }
; 866  : 							  break;

	jmp	$LN46@ms64_param
$LN108@ms64_param:

; 851  : 						  case 4:                             /* it could be 3 or more REAL4 */
; 852  : 							  for (i = 0, j = 0; i < membersize; i++) {

	mov	r12, QWORD PTR paramvalue$[rsp]
	mov	ebp, ebx
	mov	rdi, rbx
	mov	rax, rsi
$LL107@ms64_param:

; 853  : 								  while (info->xyzused[j] != 0) j++;

	cmp	BYTE PTR [rax], 0
	je	SHORT $LN103@ms64_param
	npad	3
$LL104@ms64_param:
	inc	rdi
	inc	ebp
	cmp	BYTE PTR [rdi+rsi], 0
	jne	SHORT $LL104@ms64_param
$LN103@ms64_param:

; 854  : 								  if (i == 0) AddLineQueueX("%s %r,dword ptr %s", MOVE_SINGLE, T_XMM0 + j, paramvalue);

	test	ebx, ebx
	jne	SHORT $LN102@ms64_param
	mov	rdx, QWORD PTR MOVE_SINGLE
	lea	r8d, DWORD PTR [rbp+40]
	lea	rcx, OFFSET FLAT:$SG6147
	mov	r9, r12
	call	AddLineQueueX
	jmp	SHORT $LN101@ms64_param
$LN102@ms64_param:

; 855  : 								  else      AddLineQueueX("%s %r,dword ptr [%s+%d]", MOVE_SINGLE, T_XMM0 + j, paramvalue, i * 4);

	mov	rdx, QWORD PTR MOVE_SINGLE
	lea	eax, DWORD PTR [rbx*4]
	lea	r8d, DWORD PTR [rbp+40]
	lea	rcx, OFFSET FLAT:$SG6149
	mov	r9, r12
	mov	DWORD PTR [rsp+32], eax
	call	AddLineQueueX
$LN101@ms64_param:

; 856  : 								  info->xyzused[j] = 1;

	lea	rax, QWORD PTR [rdi+rsi]
	inc	ebx
	cmp	ebx, 4
	mov	BYTE PTR [rax], 1
	jl	SHORT $LL107@ms64_param

; 899  : #if EVEXSUPP 
; 900  : 						  case 64:
; 901  : 							  if ((vcallpass == 1) && (t->e.structinfo->isHFA || t->e.structinfo->isHVA))
; 902  : 							  {
; 903  : 								  for (i = 0, j = 0; i < memberCount; i++) {
; 904  : 									  while (info->xyzused[j] != 0) j++;
; 905  : 									  if (i == 0) AddLineQueueX("vmovups %r,zmmword ptr %s", T_ZMM0 + j, paramvalue);
; 906  : 									  else      AddLineQueueX("vmovups %r,zmmword ptr [%s+%d]", T_ZMM0 + j, paramvalue, i * 64);
; 907  : 									  info->xyzused[j] = 1;
; 908  : 								  }
; 909  : 							  }
; 910  : 							  break;
; 911  : #endif 
; 912  : 						  }
; 913  : 					  }

	jmp	$LN46@ms64_param
$LN151@ms64_param:

; 914  : 				  }
; 915  : 				  else if (vcallpass == 0) {

	test	r11d, r11d
	jne	$LN46@ms64_param

; 916  : 					  switch (psize) {

	cmp	r13d, 4
	je	$LN64@ms64_param
	cmp	r13d, 8
	je	$LN61@ms64_param
	cmp	r13d, 16
	je	SHORT $LN58@ms64_param
	cmp	r13d, 32				; 00000020H
	jne	$LN46@ms64_param

; 946  : 					  case 32:
; 947  : 						  info->vregs[index] = 1;
; 948  : 						  AddLineQueueX("vmovups %r,oword ptr %s", T_YMM0 + index, paramvalue);

	mov	r8, QWORD PTR paramvalue$[rsp]
	lea	edx, DWORD PTR [rbp+56]
	lea	rcx, OFFSET FLAT:$SG6218
	mov	BYTE PTR [rbp+rdi+68], 1
	call	AddLineQueueX

; 949  : 						  break;

	jmp	$LN46@ms64_param
$LN58@ms64_param:

; 933  : 					  case 16:
; 934  : 						  if (opnd->kind == EXPR_REG && opnd->indirect == FALSE) {

	cmp	DWORD PTR [r12+60], 2
	jne	SHORT $LN57@ms64_param
	test	BYTE PTR [r12+72], 1
	jne	SHORT $LN57@ms64_param

; 935  : 							  if (GetValueSp(reg) & OP_XMM) {

	movsxd	rax, esi
	lea	rcx, QWORD PTR [rax+rax*2]
	test	BYTE PTR SpecialTable[r10+rcx*4], 32	; 00000020H
	je	SHORT $LN53@ms64_param

; 936  : 								  if (reg == T_XMM0 + index)

	lea	r8d, DWORD PTR [rbp+40]
	cmp	esi, r8d
	je	SHORT $LN53@ms64_param

; 937  : 									  DebugMsg(("ms64_param(%s, param=%u): argument optimized\n", proc->sym.name, index));
; 938  : 								  else
; 939  : 									  AddLineQueueX("%s %r,oword ptr %s", MOVE_ALIGNED_FLOAT, T_XMM0 + index, paramvalue);

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	rdx, QWORD PTR MOVE_ALIGNED_FLOAT
	lea	rcx, OFFSET FLAT:$SG6214
	call	AddLineQueueX

; 944  : 						  info->vregs[index] = 1;

	mov	BYTE PTR [rbp+rdi+68], 1

; 945  : 						  break;

	jmp	$LN46@ms64_param
$LN57@ms64_param:

; 940  : 							  }
; 941  : 						  }
; 942  : 						  else
; 943  : 							  AddLineQueueX("%s %r,oword ptr %s", MOVE_ALIGNED_FLOAT, T_XMM0 + index, paramvalue);

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	rdx, QWORD PTR MOVE_ALIGNED_FLOAT
	lea	r8d, DWORD PTR [rbp+40]
	lea	rcx, OFFSET FLAT:$SG6216
	call	AddLineQueueX
$LN53@ms64_param:

; 944  : 						  info->vregs[index] = 1;

	mov	BYTE PTR [rbp+rdi+68], 1

; 945  : 						  break;

	jmp	$LN46@ms64_param
$LN61@ms64_param:

; 924  : 						  break;
; 925  : 					  case 8:
; 926  : 						  if (opnd->kind == EXPR_FLOAT) {

	cmp	DWORD PTR [r12+60], 3
	jne	SHORT $LN60@ms64_param

; 927  : 							  AddLineQueueX("%s %r,qword ptr %s", MOVE_DOUBLE, T_XMM0 + index, paramvalue);

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	rdx, QWORD PTR MOVE_DOUBLE
	lea	r8d, DWORD PTR [rbp+40]
	lea	rcx, OFFSET FLAT:$SG6206
	call	AddLineQueueX

; 928  : 							  info->vregs[index] = 1;

	mov	BYTE PTR [rbp+rdi+68], 1

; 929  : 						  }
; 930  : 						  else

	jmp	$LN46@ms64_param
$LN60@ms64_param:

; 931  : 							  AddLineQueueX("mov %r, qword ptr %s", ms64_regs[index + 2 * 4], paramvalue);

	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, DWORD PTR ms64_regs[r10+rbp*4+32]
	lea	rcx, OFFSET FLAT:$SG6208
	call	AddLineQueueX

; 932  : 						  break;

	jmp	$LN46@ms64_param
$LN64@ms64_param:

; 917  : 					  case 4:
; 918  : 						  if (opnd->kind == EXPR_FLOAT) {

	cmp	DWORD PTR [r12+60], 3
	jne	SHORT $LN63@ms64_param

; 919  : 							  AddLineQueueX("%s %r,dword ptr %s", MOVE_SINGLE, T_XMM0 + index, paramvalue);

	mov	r9, QWORD PTR paramvalue$[rsp]
	mov	rdx, QWORD PTR MOVE_SINGLE
	lea	r8d, DWORD PTR [rbp+40]
	lea	rcx, OFFSET FLAT:$SG6201
	call	AddLineQueueX

; 920  : 							  info->vregs[index] = 1;

	mov	BYTE PTR [rbp+rdi+68], 1

; 921  : 						  }
; 922  : 						  else

	jmp	$LN46@ms64_param
$LN63@ms64_param:

; 923  : 							  AddLineQueueX("mov %r, qword ptr %s", ms64_regs[index + 2 * 4], paramvalue);

	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	edx, DWORD PTR ms64_regs[r10+rbp*4+32]
	lea	rcx, OFFSET FLAT:$SG6203
	call	AddLineQueueX

; 950  : #if EVEXSUPP 
; 951  : 					  case 32:
; 952  : 						  info->vregs[index] = 1;
; 953  : 						  AddLineQueueX("vmovups %r,zmmword ptr %s", T_ZMM0 + index, paramvalue);
; 954  : 						  break;
; 955  : #endif
; 956  : 					  }
; 957  : 				  }
; 958  : 			  }
; 959  : 			  else

	jmp	$LN46@ms64_param
$LN392@ms64_param:

; 270  : {

	mov	r9d, 1
	jmp	SHORT $uselea$6017
$LN393@ms64_param:
	mov	r9d, 1
	jmp	SHORT $uselea$6017
$LN394@ms64_param:
	mov	r9d, 1
	jmp	SHORT $uselea$6017
$LN395@ms64_param:
	mov	r9d, 1
	jmp	SHORT $uselea$6017
$LN396@ms64_param:
	mov	r9d, 1
	jmp	SHORT $uselea$6017
$LN397@ms64_param:
	mov	r9d, 1
$uselea$6017:

; 960  : 			  {
; 961  :       uselea:
; 962  : 
; 963  : 				  if ((proc->sym.langtype == LANG_VECTORCALL))

	mov	rax, QWORD PTR proc$[rsp]
	cmp	DWORD PTR [rax+84], 8
	jne	$LN50@ms64_param

; 964  : 				  {
; 965  : 					  if (index < 4)

	cmp	ebp, 4
	jge	SHORT $LN49@ms64_param

; 968  : 						  info->vecregs[index] = 0; /* In this case the vectorcall item is passed by reference in a GP register, so prevent it being homed in PROC */
; 969  : 						  AddLineQueueX(" lea %r, %s", ms64_regs[index + 2 * 4 + (psize > 4 ? 4 : 0)], paramvalue);

	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	eax, r9d
	mov	r9, QWORD PTR regs_used$[rsp]
	lea	ecx, DWORD PTR [rbp+3]
	mov	r15d, 4
	shl	al, cl
	lea	rcx, OFFSET FLAT:$SG6222
	or	BYTE PTR [r9], al
	mov	BYTE PTR [rbp+rdi+56], bl
	cmp	r13d, 4
	cmova	rbx, r15
	lea	rax, OFFSET FLAT:__ImageBase
	add	rbx, rbp
	mov	edx, DWORD PTR ms64_regs[rax+rbx*4+32]
	call	AddLineQueueX

; 977  : 
; 978  : 					  }
; 979  : 				  }
; 980  : 				  else

	jmp	$LN46@ms64_param
$LN49@ms64_param:

; 970  : 					  }
; 971  : 					  else
; 972  : 					  {
; 973  : 						  *regs_used |= R0_USED;

	mov	r9, QWORD PTR regs_used$[rsp]

; 974  : 						  AddLineQueueX(" lea %r, %s", T_RAX, paramvalue);

	mov	r8, QWORD PTR paramvalue$[rsp]
	mov	esi, 115				; 00000073H
	or	BYTE PTR [r9], 1
	lea	rcx, OFFSET FLAT:$SG6224
	mov	edx, esi
	call	AddLineQueueX

; 975  : 						  AddLineQueueX(" mov qword ptr [%r+%u], %r", T_RSP, NUMQUAL index * 8, T_RAX);

	lea	r8d, DWORD PTR [rbp*8]
	lea	edx, QWORD PTR [rsi+4]
	lea	rcx, OFFSET FLAT:$SG6225
	mov	r9d, esi
	call	AddLineQueueX

; 976  : 						  return(1);

	jmp	SHORT $LN46@ms64_param
$LN50@ms64_param:

; 981  : 				  {
; 982  : 					  AddLineQueueX(" lea %r, %s", ms64_regs[index + 2 * 4 + (psize > 4 ? 4 : 0)], paramvalue);

	mov	r8, QWORD PTR paramvalue$[rsp]
	cmp	r13d, 4
	lea	rax, OFFSET FLAT:__ImageBase
	mov	r15d, 4
	lea	rcx, OFFSET FLAT:$SG6227
	cmova	rbx, r15
	add	rbx, rbp
	mov	edx, DWORD PTR ms64_regs[rax+rbx*4+32]
	call	AddLineQueueX

; 983  : 				  }
; 984  : 			  }
; 985  : 		  }
; 986  :           else

	jmp	SHORT $LN46@ms64_param
$LN153@ms64_param:

; 987  :                 EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, index+1 );

	lea	edx, DWORD PTR [rbp+1]
	mov	ecx, 145				; 00000091H
$LN399@ms64_param:
	call	EmitErr
$LN46@ms64_param:
$vcalldone$6008:

; 988  :             return( 1 );

	mov	eax, 1
$LN331@ms64_param:
	mov	r15, QWORD PTR [rsp+56]
	mov	r14, QWORD PTR [rsp+64]
	mov	r13, QWORD PTR [rsp+72]
	mov	r12, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+112]

; 1083 : 		  DebugMsg1(("ms64_param(%s, param=%u): size=%u flags=%X\n", proc->sym.name, index, size, *regs_used));
; 1084 : 	  }
; 1085 :  }
; 1086 : vcalldone:
; 1087 :     return( 1 );
; 1088 : }

	add	rsp, 120				; 00000078H
	ret	0
ms64_param ENDP
_TEXT	ENDS
EXTRN	GetGroup:NEAR
EXTRN	search_assume:NEAR
xdata	SEGMENT
$unwind$GetSegmentPart DD 050e01H
	DD	09740eH
	DD	086409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$GetSegmentPart DD @imagerel(GetSegmentPart#)
	DD	@imagerel(GetSegmentPart#+102)
	DD	@imagerel($unwind$GetSegmentPart#)
pdata	ENDS
xdata	SEGMENT
$chain$2$GetSegmentPart DD 020521H
	DD	073405H
	DD	@imagerel(GetSegmentPart#)
	DD	@imagerel(GetSegmentPart#+102)
	DD	@imagerel($unwind$GetSegmentPart#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$GetSegmentPart DD @imagerel(GetSegmentPart#+102)
	DD	@imagerel(GetSegmentPart#+205)
	DD	@imagerel($chain$2$GetSegmentPart#)
pdata	ENDS
xdata	SEGMENT
$chain$4$GetSegmentPart DD 020021H
	DD	073400H
	DD	@imagerel(GetSegmentPart#)
	DD	@imagerel(GetSegmentPart#+102)
	DD	@imagerel($unwind$GetSegmentPart#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$GetSegmentPart DD @imagerel(GetSegmentPart#+205)
	DD	@imagerel(GetSegmentPart#+278)
	DD	@imagerel($chain$4$GetSegmentPart#)
pdata	ENDS
xdata	SEGMENT
$chain$6$GetSegmentPart DD 020021H
	DD	073400H
	DD	@imagerel(GetSegmentPart#)
	DD	@imagerel(GetSegmentPart#+102)
	DD	@imagerel($unwind$GetSegmentPart#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$GetSegmentPart DD @imagerel(GetSegmentPart#+278)
	DD	@imagerel(GetSegmentPart#+359)
	DD	@imagerel($chain$6$GetSegmentPart#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
opnd$ = 48
buffer$ = 56
fullparam$ = 64
GetSegmentPart PROC NEAR

; 1099 : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rdx

; 1100 :     short reg = T_NULL;
; 1101 :     DebugMsg1(("GetSegmentPart(%s) enter [override=%s sym=%s segment=%s]\n",
; 1102 :                fullparam, opnd->override ? opnd->override->string_ptr : "NULL",
; 1103 :                opnd->sym ? opnd->sym->name : "NULL",
; 1104 :                opnd->sym ? opnd->sym->segment ? opnd->sym->segment->name : "NULL" : "NULL" ));
; 1105 :     if ( opnd->override != NULL ) {

	mov	rdx, QWORD PTR [rcx+48]
	mov	rsi, rcx
	test	rdx, rdx
	je	SHORT $LN16@GetSegment

; 1106 :         if ( opnd->override->token == T_REG )

	cmp	BYTE PTR [rdx], 2
	jne	SHORT $LN15@GetSegment

; 1138 :     }
; 1139 :     DebugMsg1(("GetSegmentPart: reg%u, buffer=%s\n", reg, reg ? "" : buffer ));
; 1140 :     return( reg );

	mov	ax, WORD PTR [rdx+16]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]

; 1141 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN15@GetSegment:

; 1107 :             reg = opnd->override->tokval;
; 1108 :         else
; 1109 :             strcpy( buffer, opnd->override->string_ptr );

	mov	rdx, QWORD PTR [rdx+8]
	npad	7
$LL19@GetSegment:
	movzx	ecx, BYTE PTR [rdx]
	inc	rdi
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rdi-1], cl
	jne	SHORT $LL19@GetSegment

; 1138 :     }
; 1139 :     DebugMsg1(("GetSegmentPart: reg%u, buffer=%s\n", reg, reg ? "" : buffer ));
; 1140 :     return( reg );

	xor	ax, ax
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]

; 1141 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN16@GetSegment:

; 1110 :     } else if ( opnd->sym != NULL && opnd->sym->segment != NULL ) {

	mov	rax, QWORD PTR [rcx+80]
	mov	QWORD PTR [rsp+56], rbx
	test	rax, rax
	je	$LN12@GetSegment
	mov	rbx, QWORD PTR [rax+32]
	test	rbx, rbx
	je	SHORT $LN12@GetSegment

; 1111 :         struct dsym *dir = GetSegm( opnd->sym );
; 1112 :         enum assume_segreg as;
; 1113 :         if ( dir->e.seginfo->segtype == SEGTYPE_DATA ||
; 1114 :             dir->e.seginfo->segtype == SEGTYPE_BSS )

	mov	rax, QWORD PTR [rbx+104]
	mov	ecx, DWORD PTR [rax+72]
	cmp	ecx, 2
	je	SHORT $LN10@GetSegment
	cmp	ecx, 3
	je	SHORT $LN10@GetSegment

; 1116 :         else
; 1117 :             as = search_assume( (struct asym *)dir, ASSUME_CS, TRUE );

	mov	r8b, 1
	mov	edx, 1
	mov	rcx, rbx
	call	search_assume
	jmp	SHORT $LN9@GetSegment
$LN10@GetSegment:

; 1115 :             as = search_assume( (struct asym *)dir, ASSUME_DS, TRUE );

	mov	r8b, 1
	mov	edx, 3
	mov	rcx, rbx
	call	search_assume
$LN9@GetSegment:

; 1118 :         if ( as != ASSUME_NOTHING ) {

	cmp	eax, -2
	je	SHORT $LN8@GetSegment

; 1119 :             //GetResWName( segreg_tab[as], buffer );
; 1120 :             reg = T_ES + as; /* v2.08: T_ES is first seg reg in special.h */

	add	ax, 25
	mov	rbx, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]

; 1141 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@GetSegment:

; 1121 :         } else {
; 1122 :             struct asym *seg;
; 1123 :             seg = GetGroup( opnd->sym );

	mov	rcx, QWORD PTR [rsi+80]
	call	GetGroup

; 1124 :             if ( seg == NULL )

	test	rax, rax
	cmove	rax, rbx

; 1125 :                 seg = &dir->sym;
; 1126 :             if ( seg )
; 1127 :                 strcpy( buffer, seg->name );

	mov	rcx, QWORD PTR [rax+8]
$LL20@GetSegment:
	movzx	eax, BYTE PTR [rcx]
	inc	rdi
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi-1], al
	jne	SHORT $LL20@GetSegment

; 1128 :             else {
; 1129 :                 strcpy( buffer, "seg " );
; 1130 :                 strcat( buffer, fullparam );
; 1131 :             }
; 1132 :         }

	jmp	SHORT $LN26@GetSegment
$LN12@GetSegment:

; 1133 :     } else if ( opnd->sym && opnd->sym->state == SYM_STACK ) {

	test	rax, rax
	je	SHORT $LN2@GetSegment
	cmp	DWORD PTR [rax+40], 5
	jne	SHORT $LN2@GetSegment

; 1138 :     }
; 1139 :     DebugMsg1(("GetSegmentPart: reg%u, buffer=%s\n", reg, reg ? "" : buffer ));
; 1140 :     return( reg );

	mov	ax, 27
	mov	rbx, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]

; 1141 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@GetSegment:

; 1134 :         reg = T_SS;
; 1135 :     } else {
; 1136 :         strcpy( buffer,"seg " );

	mov	eax, DWORD PTR $SG6327

; 1137 :         strcat( buffer, fullparam );

	mov	rcx, -1
	mov	DWORD PTR [rdi], eax
	movzx	eax, BYTE PTR $SG6327+4
	mov	BYTE PTR [rdi+4], al
	xor	eax, eax
	repne scasb
	xor	ecx, ecx
	npad	11
$LL24@GetSegment:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL24@GetSegment
$LN26@GetSegment:
	mov	rbx, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]

; 1138 :     }
; 1139 :     DebugMsg1(("GetSegmentPart: reg%u, buffer=%s\n", reg, reg ? "" : buffer ));
; 1140 :     return( reg );

	xor	ax, ax

; 1141 : }

	add	rsp, 40					; 00000028H
	ret	0
GetSegmentPart ENDP
; Function compile flags: /Ogtpy
proc$ = 8
numparams$ = 16
start$ = 24
tokenarray$ = 32
value$ = 40
watc_fcstart PROC NEAR

; 1158 :     DebugMsg1(("watc_fcstart(%s, %u, %u)\n", proc->sym.name, numparams, start ));
; 1159 :     return( 1 );

	mov	eax, 1

; 1160 : }

	ret	0
watc_fcstart ENDP
_TEXT	ENDS
EXTRN	stackreg:BYTE
_BSS	SEGMENT
size_vararg DD	01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$watc_fcend DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$watc_fcend DD @imagerel(watc_fcend#)
	DD	@imagerel(watc_fcend#+113)
	DD	@imagerel($unwind$watc_fcend#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
proc$ = 48
numparams$ = 56
value$ = 64
watc_fcend PROC NEAR

; 1164 : {

	sub	rsp, 40					; 00000028H

; 1165 :     DebugMsg1(("watc_fcend(%s, %u, %u)\n", proc->sym.name, numparams, value ));
; 1166 :     if ( proc->e.procinfo->has_vararg ) {

	mov	rax, QWORD PTR [rcx+104]
	test	BYTE PTR [rax+128], 1
	je	SHORT $LN3@watc_fcend

; 1167 :         AddLineQueueX( " add %r, %u", stackreg[ModuleInfo.Ofssize], NUMQUAL proc->e.procinfo->parasize + size_vararg );

	mov	r8d, DWORD PTR size_vararg
	lea	rcx, OFFSET FLAT:stackreg
	add	r8d, DWORD PTR [rax+32]
	movzx	eax, BYTE PTR ModuleInfo+404
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG6347

; 1170 :     }
; 1171 :     return;
; 1172 : }

	add	rsp, 40					; 00000028H
	jmp	AddLineQueueX
$LN3@watc_fcend:

; 1168 :     } else if ( fcscratch < proc->e.procinfo->parasize ) {

	mov	r8d, DWORD PTR [rax+32]
	mov	eax, DWORD PTR fcscratch
	cmp	eax, r8d
	jae	SHORT $LN1@watc_fcend

; 1169 :         AddLineQueueX( " add %r, %u", stackreg[ModuleInfo.Ofssize], NUMQUAL ( proc->e.procinfo->parasize - fcscratch ) );

	sub	r8d, eax
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:stackreg
	mov	edx, DWORD PTR [rcx+rax*4]
	lea	rcx, OFFSET FLAT:$SG6350
	call	AddLineQueueX
$LN1@watc_fcend:

; 1170 :     }
; 1171 :     return;
; 1172 : }

	add	rsp, 40					; 00000028H
	ret	0
watc_fcend ENDP
_TEXT	ENDS
EXTRN	strchr:NEAR
xdata	SEGMENT
$unwind$watc_param DD 082501H
	DD	024e425H
	DD	028641cH
	DD	02a340eH
	DD	02b010aH
xdata	ENDS
pdata	SEGMENT
$pdata$watc_param DD @imagerel(watc_param#)
	DD	@imagerel(watc_param#+73)
	DD	@imagerel($unwind$watc_param#)
pdata	ENDS
xdata	SEGMENT
$chain$6$watc_param DD 08ae21H
	DD	026c4aeH
	DD	02954a6H
	DD	025d41eH
	DD	0277408H
	DD	@imagerel(watc_param#)
	DD	@imagerel(watc_param#+73)
	DD	@imagerel($unwind$watc_param#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$watc_param DD @imagerel(watc_param#+73)
	DD	@imagerel(watc_param#+445)
	DD	@imagerel($chain$6$watc_param#)
pdata	ENDS
xdata	SEGMENT
$chain$7$watc_param DD 020821H
	DD	023f408H
	DD	@imagerel(watc_param#+73)
	DD	@imagerel(watc_param#+445)
	DD	@imagerel($chain$6$watc_param#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$watc_param DD @imagerel(watc_param#+445)
	DD	@imagerel(watc_param#+697)
	DD	@imagerel($chain$7$watc_param#)
pdata	ENDS
xdata	SEGMENT
$chain$8$watc_param DD 021H
	DD	@imagerel(watc_param#+73)
	DD	@imagerel(watc_param#+445)
	DD	@imagerel($chain$6$watc_param#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$watc_param DD @imagerel(watc_param#+697)
	DD	@imagerel(watc_param#+734)
	DD	@imagerel($chain$8$watc_param#)
pdata	ENDS
xdata	SEGMENT
$chain$9$watc_param DD 021H
	DD	@imagerel(watc_param#)
	DD	@imagerel(watc_param#+73)
	DD	@imagerel($unwind$watc_param#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$watc_param DD @imagerel(watc_param#+734)
	DD	@imagerel(watc_param#+766)
	DD	@imagerel($chain$9$watc_param#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
reg$ = 48
regs$ = 80
buffer$6389 = 144
proc$ = 352
index$ = 360
param$ = 368
addr$ = 376
opnd$ = 384
paramvalue$ = 392
r0used$ = 400
watc_param PROC NEAR

; 1179 : {

	mov	rax, rsp
	sub	rsp, 344				; 00000158H
	mov	QWORD PTR [rax-8], rbx
	mov	rbx, r8

; 1180 :     int opc;
; 1181 :     int qual;
; 1182 :     int i;
; 1183 :     char regs[64];
; 1184 :     char *reg[4];
; 1185 :     char *p;
; 1186 :     int psize = SizeFromMemtype( param->sym.mem_type, USE_EMPTY, param->sym.type );

	mov	r8, QWORD PTR [r8+88]
	mov	ecx, DWORD PTR [rbx+44]
	mov	QWORD PTR [rax-24], rsi
	mov	edx, 254				; 000000feH
	mov	QWORD PTR [rax-56], r14
	movzx	esi, r9b
	call	SizeFromMemtype

; 1187 : 
; 1188 :     DebugMsg1(("watc_param(%s, param=%u [name=%s, state=%u]),addr=%u: psize=%u\n", proc->sym.name, index, param->sym.name, param->sym.state, addr, psize ));
; 1189 :     if ( param->sym.state != SYM_TMACRO )

	cmp	DWORD PTR [rbx+40], 10
	mov	r14d, eax
	je	SHORT $LN31@watc_param

; 1190 :         return( 0 );

	xor	eax, eax
	jmp	$LN32@watc_param
$LN31@watc_param:

; 1191 :     DebugMsg1(("watc_param(%s): register param=%s\n", proc->sym.name, param->sym.string_ptr ));
; 1192 : 
; 1193 :     fcscratch += CurrWordSize;
; 1194 : 
; 1195 :     /* the "name" might be a register pair */
; 1196 : 
; 1197 :     reg[0] = param->sym.string_ptr;

	mov	rbx, QWORD PTR [rbx+16]
	movzx	eax, BYTE PTR ModuleInfo+406
	mov	QWORD PTR [rsp+312], rdi
	add	DWORD PTR fcscratch, eax

; 1198 :     reg[1] = NULL;

	xor	edi, edi

; 1199 :     reg[2] = NULL;
; 1200 :     reg[3] = NULL;
; 1201 :     if ( strchr( reg[0], ':' ) ) {

	mov	rcx, rbx
	lea	edx, QWORD PTR [rdi+58]
	mov	QWORD PTR [rsp+296], r13
	mov	QWORD PTR reg$[rsp], rbx
	mov	r13, rdi
	mov	QWORD PTR reg$[rsp+8], rdi
	mov	QWORD PTR reg$[rsp+16], rdi
	mov	QWORD PTR reg$[rsp+24], rdi
	call	strchr
	test	rax, rax
	je	SHORT $LN38@watc_param

; 1202 :         strcpy( regs, reg[0] );

	lea	rcx, QWORD PTR regs$[rsp]
	sub	rcx, rbx
$LL34@watc_param:
	movzx	eax, BYTE PTR [rbx]
	inc	rbx
	test	al, al
	mov	BYTE PTR [rcx+rbx-1], al
	jne	SHORT $LL34@watc_param

; 1203 :         fcscratch += CurrWordSize;

	movzx	eax, BYTE PTR ModuleInfo+406

; 1204 :         for ( p = regs, i = 0; i < 4; i++ ) {

	mov	rbx, rdi
	add	DWORD PTR fcscratch, eax
	lea	rax, QWORD PTR regs$[rsp]
$LL29@watc_param:

; 1205 :             reg[i] = p;
; 1206 :             p = strchr( p, ':' );

	mov	edx, 58					; 0000003aH
	mov	rcx, rax
	mov	QWORD PTR reg$[rsp+rbx*8], rax
	call	strchr

; 1207 :             if ( p == NULL )

	test	rax, rax
	je	SHORT $LN42@watc_param
	inc	rbx

; 1208 :                 break;
; 1209 :             *p++ = NULLC;

	mov	BYTE PTR [rax], dil

; 1210 :             p++;

	add	rax, 2
	cmp	rbx, 4
	jl	SHORT $LL29@watc_param
$LN42@watc_param:

; 1204 :         for ( p = regs, i = 0; i < 4; i++ ) {

	mov	r13, QWORD PTR reg$[rsp+8]
	mov	rbx, QWORD PTR reg$[rsp]
$LN38@watc_param:

; 1211 :         }
; 1212 :     }
; 1213 : 
; 1214 :     if ( addr ) {

	test	sil, sil
	mov	QWORD PTR [rsp+328], rbp
	mov	QWORD PTR [rsp+304], r12
	je	$LN25@watc_param

; 1215 :         if ( opnd->kind == T_REG || opnd->sym->state == SYM_STACK ) {

	mov	rcx, QWORD PTR opnd$[rsp]
	cmp	DWORD PTR [rcx+60], 2
	je	SHORT $LN23@watc_param
	mov	rax, QWORD PTR [rcx+80]
	cmp	DWORD PTR [rax+40], 5
	je	SHORT $LN23@watc_param

; 1218 :         } else {
; 1219 :             opc = T_MOV;

	mov	esi, 606				; 0000025eH

; 1220 :             qual = T_OFFSET;

	mov	ebp, 241				; 000000f1H
	jmp	SHORT $LN22@watc_param
$LN23@watc_param:

; 1216 :             opc = T_LEA;

	mov	esi, 634				; 0000027aH

; 1217 :             qual = T_NULL;

	mov	ebp, edi
$LN22@watc_param:

; 1221 :         }
; 1222 :         /* v2.05: filling of segment part added */
; 1223 :         i = 0;
; 1224 :         if ( reg[1] != NULL ) {

	test	r13, r13
	mov	r12, QWORD PTR paramvalue$[rsp]
	je	SHORT $LN21@watc_param

; 1225 :             char buffer[128];
; 1226 :             short sreg;
; 1227 :             if ( sreg = GetSegmentPart( opnd, buffer, paramvalue ) )

	lea	rdx, QWORD PTR buffer$6389[rsp]
	mov	r8, r12
	call	GetSegmentPart
	test	ax, ax
	je	SHORT $LN20@watc_param

; 1228 :                 AddLineQueueX( "%r %s, %r", T_MOV, reg[0],  sreg );

	lea	rcx, OFFSET FLAT:$SG6392
	movsx	r9d, ax
	mov	r8, rbx
	mov	edx, 606				; 0000025eH
	call	AddLineQueueX

; 1229 :             else

	jmp	SHORT $LN19@watc_param
$LN20@watc_param:

; 1230 :                 AddLineQueueX( "%r %s, %s", T_MOV, reg[0],  buffer );

	lea	r9, QWORD PTR buffer$6389[rsp]
	lea	rcx, OFFSET FLAT:$SG6394
	mov	r8, rbx
	mov	edx, 606				; 0000025eH
	call	AddLineQueueX
$LN19@watc_param:

; 1231 :             i++;

	mov	edi, 1
$LN21@watc_param:

; 1232 :         }
; 1233 :         AddLineQueueX( "%r %s, %r %s", opc, reg[i], qual, paramvalue );

	movsxd	r8, edi
	lea	rcx, OFFSET FLAT:$SG6395
	mov	r9d, ebp
	mov	r8, QWORD PTR reg$[rsp+r8*8]
	mov	edx, esi
	mov	QWORD PTR [rsp+32], r12
	call	AddLineQueueX

; 1234 :         return( 1 );

	jmp	$LN47@watc_param
$LN25@watc_param:

; 1235 :     }
; 1236 :     for ( i = 3; i >= 0; i-- ) {

	mov	rsi, QWORD PTR paramvalue$[rsp]
	mov	r12, QWORD PTR opnd$[rsp]
	mov	edi, 3
	mov	QWORD PTR [rsp+280], r15
	lea	ebp, QWORD PTR [rdi+1]
	mov	r15d, 209				; 000000d1H
	npad	2
$LL18@watc_param:

; 1237 :         if ( reg[i] ) {

	mov	r10, QWORD PTR reg$[rsp+rdi*8]
	test	r10, r10
	je	$LN17@watc_param

; 1238 :             if ( opnd->kind == EXPR_CONST ) {

	mov	eax, DWORD PTR [r12+60]
	test	eax, eax
	jne	SHORT $LN14@watc_param

; 1239 :                 if ( i > 0 )

	test	rdi, rdi
	jle	SHORT $LN13@watc_param

; 1240 :                     qual = T_LOWWORD;

	mov	r8d, 238				; 000000eeH
	jmp	SHORT $LN41@watc_param
$LN13@watc_param:

; 1241 :                 else if ( i == 0 && reg[1] != NULL )

	test	rdi, rdi
	jne	SHORT $LN9@watc_param
	test	r13, r13
	je	SHORT $LN9@watc_param

; 1242 :                     qual = T_HIGHWORD;

	mov	r8d, 232				; 000000e8H
$LN41@watc_param:

; 1243 :                 else
; 1244 :                     qual = T_NULL;
; 1245 :                 if ( qual != T_NULL )
; 1246 :                     AddLineQueueX( "mov %s, %r (%s)", reg[i], qual, paramvalue );

	lea	rcx, OFFSET FLAT:$SG6407
	mov	r9, rsi
	mov	rdx, r10
	call	AddLineQueueX

; 1247 :                 else

	jmp	$LN17@watc_param
$LN9@watc_param:

; 1248 :                     AddLineQueueX( "mov %s, %s", reg[i], paramvalue );

	lea	rcx, OFFSET FLAT:$SG6409
	mov	r8, rsi
	mov	rdx, r10
	call	AddLineQueueX

; 1249 :             } else if ( opnd->kind == EXPR_REG ) {

	jmp	SHORT $LN17@watc_param
$LN14@watc_param:
	cmp	eax, 2
	jne	SHORT $LN6@watc_param

; 1250 :                 AddLineQueueX( "mov %s, %s", reg[i], paramvalue );

	lea	rcx, OFFSET FLAT:$SG6412
	mov	r8, rsi
	mov	rdx, r10
	call	AddLineQueueX

; 1251 :             } else {

	jmp	SHORT $LN17@watc_param
$LN6@watc_param:

; 1252 :                 if ( i == 0 && reg[1] == NULL )

	test	rdi, rdi
	jne	SHORT $LN4@watc_param
	test	r13, r13
	jne	SHORT $LN4@watc_param

; 1253 :                     AddLineQueueX( "mov %s, %s", reg[i], paramvalue );

	lea	rcx, OFFSET FLAT:$SG6416
	mov	r8, rsi
	mov	rdx, rbx
	call	AddLineQueueX

; 1254 :                 else {

	jmp	SHORT $LN17@watc_param
$LN4@watc_param:

; 1255 :                     if ( ModuleInfo.Ofssize )

	movzx	ecx, BYTE PTR ModuleInfo+404
	mov	r8d, 207				; 000000cfH

; 1256 :                         qual = T_DWORD;
; 1257 :                     else
; 1258 :                         qual = T_WORD;
; 1259 :                     AddLineQueueX( "mov %s, %r %r %s[%u]", reg[i], qual, T_PTR, paramvalue, psize - ( (i+1) * ( 2 << ModuleInfo.Ofssize ) ) );

	mov	edx, 2
	test	cl, cl
	mov	eax, r14d
	mov	r9d, 258				; 00000102H
	cmovne	r8d, r15d
	shl	edx, cl
	lea	rcx, OFFSET FLAT:$SG6420
	imul	edx, ebp
	sub	eax, edx
	mov	rdx, r10
	mov	DWORD PTR [rsp+40], eax
	mov	QWORD PTR [rsp+32], rsi
	call	AddLineQueueX
$LN17@watc_param:
	dec	ebp
	dec	rdi
	jns	$LL18@watc_param
	mov	r15, QWORD PTR [rsp+280]
$LN47@watc_param:
	mov	r12, QWORD PTR [rsp+304]
	mov	rbp, QWORD PTR [rsp+328]
	mov	rdi, QWORD PTR [rsp+312]
	mov	r13, QWORD PTR [rsp+296]

; 1260 :                 }
; 1261 :             }
; 1262 :         }
; 1263 :     }
; 1264 :     return( 1 );

	mov	eax, 1
$LN32@watc_param:
	mov	r14, QWORD PTR [rsp+288]
	mov	rsi, QWORD PTR [rsp+320]
	mov	rbx, QWORD PTR [rsp+336]

; 1265 : }

	add	rsp, 344				; 00000158H
	ret	0
watc_param ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SkipTypecast DD 010201H
	DD	07002H
xdata	ENDS
pdata	SEGMENT
$pdata$SkipTypecast DD @imagerel(SkipTypecast#)
	DD	@imagerel(SkipTypecast#+195)
	DD	@imagerel($unwind$SkipTypecast#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
fullparam$ = 16
i$ = 24
tokenarray$ = 32
SkipTypecast PROC NEAR

; 1271 : {

	push	rdi

; 1275 :         if (( tokenarray[j].token == T_COMMA ) || ( tokenarray[j].token == T_FINAL ) )

	movsxd	rdx, edx
	mov	BYTE PTR [rcx], 0
	mov	r10, rcx
	mov	rax, rdx
	shl	rax, 5
	cmp	BYTE PTR [rax+r8], 44			; 0000002cH
	je	$LN12@SkipTypeca
	shl	rdx, 5
	lea	r11, OFFSET FLAT:$SG6438
	add	rdx, r8
	lea	r8, QWORD PTR [rdx+32]
	npad	1
$LL8@SkipTypeca:
	cmp	BYTE PTR [rdx], 0
	je	$LN12@SkipTypeca

; 1276 :             break;
; 1277 :         if (( tokenarray[j+1].token == T_BINARY_OPERATOR ) && ( tokenarray[j+1].tokval == T_PTR ) )

	cmp	BYTE PTR [r8], 5
	jne	SHORT $LN3@SkipTypeca
	cmp	DWORD PTR [r8+16], 258			; 00000102H
	jne	SHORT $LN3@SkipTypeca

; 1278 :             j = j + 1;

	add	r8, 32					; 00000020H
	add	rdx, 32					; 00000020H

; 1279 :         else {

	jmp	SHORT $LN7@SkipTypeca
$LN3@SkipTypeca:

; 1280 :             if ( fullparam[0] != NULLC )

	cmp	BYTE PTR [r10], 0
	je	SHORT $LN1@SkipTypeca

; 1281 :                 strcat( fullparam," " );

	xor	eax, eax
	mov	rdi, r10
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	7
$LL15@SkipTypeca:
	movzx	eax, BYTE PTR [r11+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL15@SkipTypeca
$LN1@SkipTypeca:

; 1282 :             strcat( fullparam, tokenarray[j].string_ptr );

	mov	r9, QWORD PTR [rdx+8]
	xor	eax, eax
	mov	rdi, r10
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	12
$LL14@SkipTypeca:
	movzx	eax, BYTE PTR [r9+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL14@SkipTypeca
$LN7@SkipTypeca:

; 1272 :     int j;
; 1273 :     fullparam[0] = NULLC;
; 1274 :     for ( j = i; ; j++ ) {

	add	rdx, 32					; 00000020H
	add	r8, 32					; 00000020H

; 1275 :         if (( tokenarray[j].token == T_COMMA ) || ( tokenarray[j].token == T_FINAL ) )

	cmp	BYTE PTR [rdx], 44			; 0000002cH
	jne	$LL8@SkipTypeca
$LN12@SkipTypeca:

; 1283 :         }
; 1284 :     }
; 1285 : }

	pop	rdi
	ret	0
SkipTypecast ENDP
; Function compile flags: /Ogtpy
pStr$ = 8
ParamIsString PROC NEAR

; 1289 : 	char c;
; 1290 : 	char *pS = pStr;
; 1291 : 
; 1292 : 	c = *pS;
; 1293 : 	if (c != '"') return(FALSE);

	cmp	BYTE PTR [rcx], 34			; 00000022H
	je	SHORT $LN5@ParamIsStr
	xor	eax, eax

; 1306 : 	}
; 1307 : 	return(TRUE);
; 1308 : }

	ret	0
$LN5@ParamIsStr:

; 1294 : 	pS++;

	inc	rcx

; 1295 : 
; 1296 : 	while (TRUE)
; 1297 : 	{
; 1298 : 		c = *pS;
; 1299 : 		if (c == 0)

	cmp	BYTE PTR [rcx], 0
	je	SHORT $LN10@ParamIsStr
$LL4@ParamIsStr:

; 1303 : 			break;
; 1304 : 		}
; 1305 : 		pS++;

	inc	rcx
	cmp	BYTE PTR [rcx], 0
	jne	SHORT $LL4@ParamIsStr
$LN10@ParamIsStr:

; 1300 : 		{
; 1301 : 			c = *(pS - 1);
; 1302 : 			if (c != '"') return(FALSE);

	xor	eax, eax
	cmp	BYTE PTR [rcx-1], 34			; 00000022H
	sete	al

; 1306 : 	}
; 1307 : 	return(TRUE);
; 1308 : }

	ret	0
ParamIsString ENDP
; Function compile flags: /Ogtpy
s$ = 8
hashpjw	PROC NEAR

; 1313 : 	unsigned h;
; 1314 : 	unsigned g;
; 1315 : 
; 1316 : #if HASH_MAGNITUDE==12
; 1317 : 	for (h = 0; *s; ++s) {
; 1318 : 		h = (h << 4) + (*s | ' ');
; 1319 : 		g = h & ~0x0fff;
; 1320 : 		h ^= g;
; 1321 : 		h ^= g >> 12;
; 1322 : 	}
; 1323 : #else
; 1324 : 	for (h = 0; *s; ++s) {

	movzx	eax, BYTE PTR [rcx]
	xor	r8d, r8d
	mov	r9, rcx
	test	al, al
	je	SHORT $LN8@hashpjw
	npad	3
$LL3@hashpjw:

; 1325 : 		h = (h << 5) + (*s | ' ');

	movsx	edx, al
	mov	eax, r8d
	inc	r9
	or	edx, 32					; 00000020H
	shl	eax, 5
	lea	r8d, DWORD PTR [rax+rdx]
	mov	al, BYTE PTR [r9]

; 1326 : 		g = h & ~0x7fff;

	mov	edx, r8d
	and	edx, -32768				; ffff8000H

; 1327 : 		h ^= g;
; 1328 : 		h ^= g >> 15;

	mov	ecx, edx
	shr	ecx, 15
	xor	ecx, edx
	xor	r8d, ecx
	test	al, al
	jne	SHORT $LL3@hashpjw
$LN8@hashpjw:

; 1329 : 	}
; 1330 : #endif
; 1331 : 	return(h);

	mov	eax, r8d

; 1332 : }

	ret	0
hashpjw	ENDP
_TEXT	ENDS
EXTRN	minintvalues:BYTE
EXTRN	maxintvalues:BYTE
EXTRN	Options:BYTE
EXTRN	AddLineQueue:NEAR
EXTRN	GetResWName:NEAR
EXTRN	EvalOperand:NEAR
EXTRN	SymLookup:NEAR
EXTRN	SymFind:NEAR
EXTRN	write_to_file:BYTE
EXTRN	sprintf:NEAR
EXTRN	SymTables:BYTE
EXTRN	__chkstk:NEAR
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$PushInvokeParam DD 0126701H
	DD	08141f467H
	DD	08142e45fH
	DD	08143d457H
	DD	08144c444H
	DD	08145743cH
	DD	081466434H
	DD	08147542cH
	DD	081483424H
	DD	08149011cH
xdata	ENDS
pdata	SEGMENT
$pdata$PushInvokeParam DD @imagerel(PushInvokeParam#)
	DD	@imagerel(PushInvokeParam#+7852)
	DD	@imagerel($unwind$PushInvokeParam#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
addr$1$ = 64
j$ = 68
currParm$1$ = 72
tv3014 = 80
tv2754 = 80
opnd$ = 96
tv2753 = 208
buf$ = 216
fullparam$ = 256
buffer$ = 1280
isString$ = 2304
stringparam$ = 2560
i$ = 264784
tokenarray$ = 264792
proc$ = 264800
curr$ = 264808
reqParam$ = 264816
r0flags$ = 264824
PushInvokeParam PROC NEAR

; 1348 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	eax, 264776				; 00040a48H
	call	__chkstk
	sub	rsp, rax
	mov	QWORD PTR [rsp+264768], rbx
	mov	QWORD PTR [rsp+264760], rbp
	mov	QWORD PTR [rsp+264752], rsi
	mov	QWORD PTR [rsp+264744], rdi
	mov	QWORD PTR [rsp+264736], r12

; 1349 :     int currParm;
; 1350 :     int psize;
; 1351 :     int asize;
; 1352 :     int pushsize;
; 1353 :     int j;
; 1354 :     int fptrsize;
; 1355 :     char Ofssize;
; 1356 :     bool addr = FALSE; /* ADDR operator found */
; 1357 :     struct expr opnd;
; 1358 :     char fullparam[MAX_LINE_LEN];
; 1359 :     char buffer[MAX_LINE_LEN];
; 1360 : 	char stringparam[256][MAX_LINE_LEN];
; 1361 : 	bool isString[256];
; 1362 : 	int reg = 0;
; 1363 : 	
; 1364 : 	struct asym *lbl;
; 1365 : 	struct dsym *curseg;
; 1366 : 	struct dsym *prev;
; 1367 : 	struct dsym *currs;
; 1368 : 	size_t slen;
; 1369 : 	uint_32 pos;
; 1370 : 	char *pSrc;
; 1371 : 	char *pDest;
; 1372 : 	char *labelstr = "__ls";
; 1373 : 	char buf[32];
; 1374 : 
; 1375 : 	DebugMsg1(("PushInvokeParam(%s, param=%s:%u, i=%u ) enter\n", proc->sym.name, curr ? curr->sym.name : "NULL", reqParam, i ));
; 1376 :    //__debugbreak();
; 1377 :     for ( currParm = 0; currParm <= reqParam; ) {

	xor	r11d, r11d
	cmp	DWORD PTR reqParam$[rsp], r11d
	mov	QWORD PTR [rsp+264728], r13
	mov	QWORD PTR [rsp+264720], r14
	mov	QWORD PTR [rsp+264712], r15
	movsxd	r15, ecx
	mov	r12, r9
	mov	r13, rdx
	mov	BYTE PTR addr$1$[rsp], 0
	mov	r10d, r11d
	mov	rax, r15
	mov	DWORD PTR currParm$1$[rsp], r11d
	lea	r14d, QWORD PTR [r11+2]
	jl	$LN398@PushInvoke
	mov	r14, QWORD PTR ModuleInfo+432
	shl	rax, 5
	lea	r8, QWORD PTR isString$[rsp+r15]
	lea	r9, QWORD PTR [rax+rdx+8]
	mov	QWORD PTR tv2754[rsp], r8
	mov	QWORD PTR tv2753[rsp], r9
	npad	1
$LL281@PushInvoke:

; 1378 : 		isString[i] = FALSE;
; 1379 : 		if ( tokenarray[i].token == T_FINAL ) { /* this is no real error! */

	movzx	eax, BYTE PTR [r9-8]
	mov	BYTE PTR [r8], 0
	test	al, al
	je	$LN413@PushInvoke

; 1380 :             DebugMsg1(("PushInvokeParam(%s): T_FINAL token, i=%u\n", proc->sym.name, i));
; 1381 :             return( ERROR );
; 1382 :         }
; 1383 :         if ( tokenarray[i].token == T_COMMA ) {

	cmp	al, 44					; 0000002cH
	jne	SHORT $LN278@PushInvoke

; 1384 :             currParm++;

	inc	r10d
	mov	DWORD PTR currParm$1$[rsp], r10d
	jmp	$LN262@PushInvoke
$LN278@PushInvoke:

; 1385 :         }
; 1386 : 		else if (ParamIsString(tokenarray[i].string_ptr))

	mov	rcx, QWORD PTR [r9]
	mov	rax, rcx
	cmp	BYTE PTR [rcx], 34			; 00000022H
	jne	$LN276@PushInvoke
	inc	rax
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN362@PushInvoke
	npad	7
$LL293@PushInvoke:
	inc	rax
	cmp	BYTE PTR [rax], 0
	jne	SHORT $LL293@PushInvoke
$LN362@PushInvoke:
	cmp	BYTE PTR [rax-1], 34			; 00000022H
	jne	$LN276@PushInvoke

; 1387 : 		{
; 1388 : 
; 1389 : 			// Preserve current Segment.
; 1390 : 			curseg = ModuleInfo.currseg;
; 1391 : 			// Find Data Segment.
; 1392 : 			prev = NULL;
; 1393 : 			currs = NULL;
; 1394 : 			for (currs = SymTables[TAB_SEG].head; currs && currs->next; prev = currs, currs = currs->next)

	mov	rbx, QWORD PTR SymTables+32
	test	rbx, rbx
	je	SHORT $LN407@PushInvoke
	npad	2
$LL275@PushInvoke:
	mov	r8, QWORD PTR [rbx+112]
	test	r8, r8
	je	SHORT $LN407@PushInvoke

; 1395 : 			{
; 1396 : 				if (strcmp(currs->sym.name, "_DATA") == 0)

	mov	rax, QWORD PTR [rbx+8]
	lea	rdi, OFFSET FLAT:$SG6512
	sub	rdi, rax
	npad	9
$LL396@PushInvoke:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+rdi]
	sub	edx, ecx
	jne	SHORT $LN397@PushInvoke
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL396@PushInvoke
$LN397@PushInvoke:
	test	edx, edx
	je	SHORT $LN407@PushInvoke
	test	r8, r8
	mov	rbx, r8
	jne	SHORT $LL275@PushInvoke
$LN407@PushInvoke:

; 1397 : 					break;
; 1398 : 			}
; 1399 : 			// Set CurrSeg
; 1400 : 			CurrSeg = currs;

	mov	QWORD PTR ModuleInfo+432, rbx

; 1401 : 			// Transfer raw String Data.
; 1402 : 			slen = strlen(tokenarray[i].string_ptr);
; 1403 : 			pos = currs->e.seginfo->current_loc;
; 1404 : 			pSrc = tokenarray[i].string_ptr;

	mov	rsi, QWORD PTR [r9]
	mov	rdi, QWORD PTR [r9]
	xor	eax, eax
	mov	rcx, -1

; 1405 : 			pDest = (char*)currs->e.seginfo->CodeBuffer;
; 1406 : 			
; 1407 : 			sprintf(buf, "%s%d", labelstr, hashpjw( tokenarray[i].string_ptr ));

	mov	rdx, rsi
	repne scasb
	mov	rax, QWORD PTR [rbx+104]
	mov	r9d, r11d
	mov	r12d, DWORD PTR [rax+12]
	mov	rdi, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rsi]
	test	al, al
	not	rcx
	lea	rbp, QWORD PTR [rcx-1]
	je	SHORT $LN297@PushInvoke
	npad	10
$LL299@PushInvoke:
	movsx	ecx, al
	shl	r9d, 5
	inc	rdx
	or	ecx, 32					; 00000020H
	add	r9d, ecx
	mov	ecx, r9d
	and	ecx, -32768				; ffff8000H
	mov	eax, ecx
	shr	eax, 15
	xor	eax, ecx
	xor	r9d, eax
	mov	al, BYTE PTR [rdx]
	test	al, al
	jne	SHORT $LL299@PushInvoke
$LN297@PushInvoke:
	lea	r8, OFFSET FLAT:$SG6497
	lea	rdx, OFFSET FLAT:$SG6514
	lea	rcx, QWORD PTR buf$[rsp]
	call	sprintf

; 1408 : 
; 1409 : 			if (pDest != 0 && write_to_file == TRUE)

	test	rdi, rdi
	je	$LN271@PushInvoke
	cmp	BYTE PTR write_to_file, 1
	jne	$LN271@PushInvoke

; 1410 : 			{
; 1411 : 				/* Does this literal already exist? */
; 1412 : 				lbl = SymFind( buf );

	lea	rcx, QWORD PTR buf$[rsp]
	call	SymFind

; 1413 : 				if (lbl == NULL || lbl->state == SYM_UNDEFINED)

	test	rax, rax
	mov	rdx, rax
	je	SHORT $LN269@PushInvoke
	cmp	DWORD PTR [rax+40], 0
	je	SHORT $LN269@PushInvoke

; 1420 : 				}
; 1421 : 				else
; 1422 : 				{
; 1423 : 					pDest += lbl->offset;

	movsxd	rax, DWORD PTR [rax+16]
	add	rdi, rax
	jmp	SHORT $LN268@PushInvoke
$LN269@PushInvoke:

; 1414 : 				{
; 1415 : 					lbl = SymLookup(buf);

	lea	rcx, QWORD PTR buf$[rsp]
	call	SymLookup

; 1416 : 					literalCnt++;

	inc	DWORD PTR literalCnt

; 1417 : 					pDest += pos;

	add	rdi, r12

; 1418 : 					lbl->value = pos;
; 1419 : 					lbl->offset = pos;

	mov	DWORD PTR [rax+16], r12d
	mov	rdx, rax
$LN268@PushInvoke:

; 1424 : 				}
; 1425 : 
; 1426 : 				for (j = 0; j < slen; j++)

	xor	ecx, ecx
	test	rbp, rbp
	mov	DWORD PTR j$[rsp], ecx
	je	SHORT $LN265@PushInvoke
	npad	10
$LL267@PushInvoke:

; 1427 : 				{
; 1428 : 					*pDest++ = *pSrc++;

	movzx	eax, BYTE PTR [rsi]
	inc	rdi
	inc	rsi
	mov	BYTE PTR [rdi-1], al
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
	cdqe
	cmp	rax, rbp
	jb	SHORT $LL267@PushInvoke
$LN265@PushInvoke:

; 1429 : 				}
; 1430 : 				*pDest++ = 0;

	mov	BYTE PTR [rdi], cl

; 1431 : 
; 1432 : 				lbl->segment = currs;
; 1433 : 				lbl->isdefined = TRUE;

	or	BYTE PTR [rdx+48], 2

; 1434 : 				lbl->mem_type = MT_BYTE;
; 1435 : 				lbl->state = SYM_INTERNAL;

	mov	edi, 1

; 1436 : 				lbl->first_size = 2;
; 1437 : 				lbl->Ofssize = 2;
; 1438 : 				lbl->isfunc = 1;
; 1439 : 				lbl->total_length = 1;
; 1440 : 				lbl->total_size = 1;
; 1441 : 				lbl->max_offset = 1;
; 1442 : 				lbl->debuginfo = 1;
; 1443 : 				lbl->sfunc_ptr = 1;

	mov	QWORD PTR [rdx+72], rdi
	mov	DWORD PTR [rdx+52], 2
	mov	QWORD PTR [rdx+32], rbx

; 1444 : 				lbl->langtype = LANG_FASTCALL;
; 1445 : 				lbl->cvtyperef = 1;

	mov	WORD PTR [rdx+72], di
	mov	DWORD PTR [rdx+44], ecx
	mov	DWORD PTR [rdx+40], edi
	mov	BYTE PTR [rdx+52], 2
	mov	DWORD PTR [rdx+64], edi
	mov	DWORD PTR [rdx+84], 7
$LN271@PushInvoke:

; 1446 : 	
; 1447 : 			}
; 1448 : 			
; 1449 : 			currs->e.seginfo->current_loc += (slen + 1);

	mov	rcx, QWORD PTR [rbx+104]
	lea	eax, DWORD PTR [rbp+1]
	add	DWORD PTR [rcx+12], eax

; 1450 : 			currs->e.seginfo->bytes_written += (slen + 1);

	mov	rcx, QWORD PTR [rbx+104]
	lea	eax, DWORD PTR [rbp+1]
	add	DWORD PTR [rcx+24], eax

; 1451 : 			currs->e.seginfo->written = TRUE;

	mov	rax, QWORD PTR [rbx+104]
	or	BYTE PTR [rax+107], 32			; 00000020H

; 1452 : 			if (currs->e.seginfo->current_loc > currs->sym.max_offset)

	mov	rax, QWORD PTR [rbx+104]
	mov	ecx, DWORD PTR [rax+12]
	cmp	ecx, DWORD PTR [rbx+64]
	jbe	SHORT $LN264@PushInvoke

; 1453 : 				currs->sym.max_offset = currs->e.seginfo->current_loc;

	mov	DWORD PTR [rbx+64], ecx
$LN264@PushInvoke:

; 1454 : 
; 1455 : 			/* invoke parameter is a raw ascii string, 
; 1456 : 			   substitute in the our new label pointing to this raw string in .data segment. */
; 1457 : 			sprintf( stringparam[i], "%s", buf );

	movsxd	rax, r15d
	lea	r8, QWORD PTR buf$[rsp]
	lea	rdx, OFFSET FLAT:$SG6524
	shl	rax, 10
	lea	rcx, QWORD PTR stringparam$[rsp+rax]
	call	sprintf

; 1458 : 			isString[i] = TRUE;

	mov	r8, QWORD PTR tv2754[rsp]

; 1459 : 
; 1460 : 			// Restore current Sement.
; 1461 : 			CurrSeg = curseg;

	mov	r9, QWORD PTR tv2753[rsp]
	mov	r10d, DWORD PTR currParm$1$[rsp]
	mov	BYTE PTR [r8], 1
	mov	QWORD PTR ModuleInfo+432, r14
	xor	r11d, r11d
	jmp	$LN262@PushInvoke
$LN276@PushInvoke:

; 1462 : 		}
; 1463 : 		else if (strcmp(tokenarray[i].string_ptr,"L") == 0 && ParamIsString(tokenarray[i + 1].string_ptr))

	lea	rdi, OFFSET FLAT:$SG6527
	sub	rdi, rcx
	npad	4
$LL394@PushInvoke:
	movzx	edx, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rcx+rdi]
	sub	edx, eax
	jne	SHORT $LN395@PushInvoke
	inc	rcx
	test	eax, eax
	jne	SHORT $LL394@PushInvoke
$LN395@PushInvoke:
	test	edx, edx
	jne	$LN262@PushInvoke
	mov	rax, QWORD PTR [r9+32]
	cmp	BYTE PTR [rax], 34			; 00000022H
	jne	$LN262@PushInvoke
	inc	rax
	cmp	BYTE PTR [rax], dl
	je	SHORT $LN364@PushInvoke
	npad	2
$LL305@PushInvoke:
	inc	rax
	cmp	BYTE PTR [rax], 0
	jne	SHORT $LL305@PushInvoke
$LN364@PushInvoke:
	cmp	BYTE PTR [rax-1], 34			; 00000022H
	jne	$LN262@PushInvoke

; 1464 : 		{
; 1465 : 
; 1466 : 			// Preserve current Segment.
; 1467 : 			curseg = ModuleInfo.currseg;
; 1468 : 			// Find Data Segment.
; 1469 : 			prev = NULL;
; 1470 : 			currs = NULL;
; 1471 : 			for (currs = SymTables[TAB_SEG].head; currs && currs->next; prev = currs, currs = currs->next)

	mov	rbx, QWORD PTR SymTables+32
	test	rbx, rbx
	je	SHORT $LN408@PushInvoke
	npad	2
$LL261@PushInvoke:
	mov	r8, QWORD PTR [rbx+112]
	test	r8, r8
	je	SHORT $LN408@PushInvoke

; 1472 : 			{
; 1473 : 				if (strcmp(currs->sym.name, "_DATA") == 0)

	mov	rax, QWORD PTR [rbx+8]
	lea	rdi, OFFSET FLAT:$SG6534
	sub	rdi, rax
	npad	9
$LL392@PushInvoke:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+rdi]
	sub	edx, ecx
	jne	SHORT $LN393@PushInvoke
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL392@PushInvoke
$LN393@PushInvoke:
	test	edx, edx
	je	SHORT $LN408@PushInvoke
	test	r8, r8
	mov	rbx, r8
	jne	SHORT $LL261@PushInvoke
$LN408@PushInvoke:

; 1474 : 					break;
; 1475 : 			}
; 1476 : 			// Set CurrSeg
; 1477 : 			CurrSeg = currs;

	mov	QWORD PTR ModuleInfo+432, rbx

; 1478 : 			// Transfer raw String Data.
; 1479 : 			slen = strlen(tokenarray[i+1].string_ptr);

	mov	rsi, QWORD PTR [r9+32]

; 1480 : 			pos = currs->e.seginfo->current_loc;
; 1481 : 			pSrc = tokenarray[i+1].string_ptr;
; 1482 : 			pDest = (char*)currs->e.seginfo->CodeBuffer;
; 1483 : 
; 1484 : 			sprintf(buf, "%s%d", labelstr, hashpjw(tokenarray[i].string_ptr));

	mov	r8, QWORD PTR [r9]
	xor	eax, eax
	mov	rdi, rsi
	mov	rcx, -1
	repne scasb
	mov	rax, QWORD PTR [rbx+104]
	mov	r9d, r11d
	mov	r12d, DWORD PTR [rax+12]
	mov	rdi, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [r8]
	test	al, al
	not	rcx
	lea	rbp, QWORD PTR [rcx-1]
	je	SHORT $LN309@PushInvoke
	npad	8
$LL311@PushInvoke:
	movsx	edx, al
	shl	r9d, 5
	inc	r8
	or	edx, 32					; 00000020H
	add	r9d, edx
	mov	ecx, r9d
	and	ecx, -32768				; ffff8000H
	mov	eax, ecx
	shr	eax, 15
	xor	eax, ecx
	xor	r9d, eax
	mov	al, BYTE PTR [r8]
	test	al, al
	jne	SHORT $LL311@PushInvoke
$LN309@PushInvoke:
	lea	r8, OFFSET FLAT:$SG6497
	lea	rdx, OFFSET FLAT:$SG6536
	lea	rcx, QWORD PTR buf$[rsp]
	call	sprintf

; 1485 : 
; 1486 : 			if (pDest != 0 && write_to_file == TRUE)

	test	rdi, rdi
	je	$LN257@PushInvoke
	cmp	BYTE PTR write_to_file, 1
	jne	$LN257@PushInvoke

; 1487 : 			{
; 1488 : 
; 1489 : 				/* Does this literal already exist? */
; 1490 : 				lbl = SymFind(buf);

	lea	rcx, QWORD PTR buf$[rsp]
	call	SymFind

; 1491 : 				if (lbl == NULL || lbl->state == SYM_UNDEFINED)

	test	rax, rax
	mov	r11, rax
	je	SHORT $LN255@PushInvoke
	cmp	DWORD PTR [rax+40], 0
	je	SHORT $LN255@PushInvoke

; 1498 : 				}
; 1499 : 				else
; 1500 : 				{
; 1501 : 					pDest += lbl->offset;

	movsxd	rax, DWORD PTR [rax+16]
	add	rdi, rax
	jmp	SHORT $LN254@PushInvoke
$LN255@PushInvoke:

; 1492 : 				{
; 1493 : 					lbl = SymLookup(buf);

	lea	rcx, QWORD PTR buf$[rsp]
	call	SymLookup

; 1494 : 					literalCnt++;

	inc	DWORD PTR literalCnt

; 1495 : 					pDest += pos;

	add	rdi, r12

; 1496 : 					lbl->value = pos;
; 1497 : 					lbl->offset = pos;

	mov	DWORD PTR [rax+16], r12d
	mov	r11, rax
$LN254@PushInvoke:

; 1502 : 				}
; 1503 : 
; 1504 : 				for (j = 0; j < slen; j++)

	xor	ecx, ecx
	test	rbp, rbp
	mov	DWORD PTR j$[rsp], ecx
	je	SHORT $LN251@PushInvoke
	npad	9
$LL253@PushInvoke:

; 1505 : 				{
; 1506 : 					*pDest++ = *pSrc++;

	movzx	eax, BYTE PTR [rsi]
	inc	rsi

; 1507 : 					*pDest++ = 0;

	add	rdi, 2
	mov	BYTE PTR [rdi-2], al
	mov	BYTE PTR [rdi-1], cl
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
	cdqe
	cmp	rax, rbp
	jb	SHORT $LL253@PushInvoke
$LN251@PushInvoke:

; 1508 : 				}
; 1509 : 				*pDest++ = 0;

	mov	BYTE PTR [rdi], cl

; 1510 : 				*pDest++ = 0;

	mov	BYTE PTR [rdi+1], cl

; 1511 : 
; 1512 : 				lbl->segment = currs;
; 1513 : 				lbl->isdefined = TRUE;

	or	BYTE PTR [r11+48], 2

; 1514 : 				lbl->mem_type = MT_BYTE;
; 1515 : 				lbl->state = SYM_INTERNAL;

	mov	edi, 1

; 1516 : 				lbl->first_size = 2;

	mov	DWORD PTR [r11+52], 2
	mov	QWORD PTR [r11+32], rbx

; 1517 : 				lbl->Ofssize = 2;
; 1518 : 				lbl->isfunc = 1;
; 1519 : 				lbl->total_length = 1;
; 1520 : 				lbl->total_size = 1;
; 1521 : 				lbl->max_offset = 1;
; 1522 : 				lbl->debuginfo = 1;
; 1523 : 				lbl->sfunc_ptr = 1;

	mov	QWORD PTR [r11+72], rdi
	mov	DWORD PTR [r11+44], ecx
	mov	BYTE PTR [r11+52], 2

; 1524 : 				lbl->langtype = LANG_FASTCALL;
; 1525 : 				lbl->cvtyperef = 1;

	mov	WORD PTR [r11+72], di
	mov	DWORD PTR [r11+40], edi
	mov	DWORD PTR [r11+64], edi
	mov	DWORD PTR [r11+84], 7
$LN257@PushInvoke:

; 1526 : 			}
; 1527 : 			
; 1528 : 			currs->e.seginfo->current_loc += (slen * 2 + 2);

	mov	rcx, QWORD PTR [rbx+104]
	lea	edx, DWORD PTR [rbp+rbp]
	lea	eax, DWORD PTR [rdx+2]
	add	DWORD PTR [rcx+12], eax

; 1529 : 			currs->e.seginfo->bytes_written += (slen * 2 + 2);

	mov	rcx, QWORD PTR [rbx+104]
	lea	eax, DWORD PTR [rdx+2]
	add	DWORD PTR [rcx+24], eax

; 1530 : 			currs->e.seginfo->written = TRUE;

	mov	rax, QWORD PTR [rbx+104]
	or	BYTE PTR [rax+107], 32			; 00000020H

; 1531 : 			if (currs->e.seginfo->current_loc > currs->sym.max_offset)

	mov	rax, QWORD PTR [rbx+104]
	mov	ecx, DWORD PTR [rax+12]
	cmp	ecx, DWORD PTR [rbx+64]
	jbe	SHORT $LN250@PushInvoke

; 1532 : 				currs->sym.max_offset = currs->e.seginfo->current_loc;

	mov	DWORD PTR [rbx+64], ecx
$LN250@PushInvoke:

; 1533 : 
; 1534 : 			/* invoke parameter is a raw ascii string,
; 1535 : 			substitute in the our new label pointing to this raw string in .data segment. */
; 1536 : 			sprintf(stringparam[i], "%s", buf);

	movsxd	rax, r15d
	lea	r8, QWORD PTR buf$[rsp]
	lea	rdx, OFFSET FLAT:$SG6546
	shl	rax, 10
	lea	rcx, QWORD PTR stringparam$[rsp+rax]
	call	sprintf

; 1537 : 			isString[i] = TRUE;
; 1538 : 
; 1539 : 			// Restore current Sement.
; 1540 : 			CurrSeg = curseg;
; 1541 : 
; 1542 : 			for (j = i; j < Token_Count-1; j++)

	mov	eax, DWORD PTR ModuleInfo+496
	mov	r8, QWORD PTR tv2754[rsp]
	dec	eax
	mov	BYTE PTR [r8], 1
	mov	QWORD PTR ModuleInfo+432, r14
	cmp	r15d, eax
	mov	ecx, r15d
	mov	DWORD PTR j$[rsp], r15d
	jge	SHORT $LN247@PushInvoke
	npad	11
$LL249@PushInvoke:

; 1543 : 			{
; 1544 : 				tokenarray[j] = tokenarray[j + 1];

	movsxd	rcx, ecx
	shl	rcx, 5
	mov	rax, QWORD PTR [rcx+r13+32]
	mov	QWORD PTR [rcx+r13], rax
	mov	rax, QWORD PTR [rcx+r13+40]
	mov	QWORD PTR [rcx+r13+8], rax
	mov	rax, QWORD PTR [rcx+r13+48]
	mov	QWORD PTR [rcx+r13+16], rax
	mov	rax, QWORD PTR [rcx+r13+56]
	mov	QWORD PTR [rcx+r13+24], rax
	mov	ecx, DWORD PTR j$[rsp]
	mov	eax, DWORD PTR ModuleInfo+496
	inc	ecx
	dec	eax
	cmp	ecx, eax
	mov	DWORD PTR j$[rsp], ecx
	jl	SHORT $LL249@PushInvoke

; 1537 : 			isString[i] = TRUE;
; 1538 : 
; 1539 : 			// Restore current Sement.
; 1540 : 			CurrSeg = curseg;
; 1541 : 
; 1542 : 			for (j = i; j < Token_Count-1; j++)

	mov	r14, QWORD PTR ModuleInfo+432
$LN247@PushInvoke:

; 1545 : 			}
; 1546 : 			Token_Count--;

	dec	DWORD PTR ModuleInfo+496
	mov	r9, QWORD PTR tv2753[rsp]
	mov	r10d, DWORD PTR currParm$1$[rsp]
	xor	r11d, r11d
$LN262@PushInvoke:

; 1547 : 
; 1548 : 		}
; 1549 :         i++;

	add	r9, 32					; 00000020H
	inc	r8
	inc	r15d
	cmp	r10d, DWORD PTR reqParam$[rsp]
	mov	QWORD PTR tv2753[rsp], r9
	mov	QWORD PTR tv2754[rsp], r8
	jle	$LL281@PushInvoke

; 1837 :                     SkipTypecast( fullparam, i, tokenarray );

	mov	r12, QWORD PTR curr$[rsp]
	mov	r14d, 2
$LN398@PushInvoke:

; 1550 :     }
; 1551 :     /* if curr is NULL this call is just a parameter check */
; 1552 :     if ( !curr ) return( NOT_ERROR );

	test	r12, r12
	je	$LN1@PushInvoke

; 1553 : 
; 1554 : #if 1 /* v2.05 */
; 1555 :     psize = curr->sym.total_size;

	mov	esi, DWORD PTR [r12+64]

; 1556 :     DebugMsg1(("PushInvokeParam(%s,%u): pmtype=%Xh, psize=%u\n", proc->sym.name, reqParam, curr->sym.mem_type, psize ));
; 1557 : #else
; 1558 :     /* set psize (size of parameter) */
; 1559 :     if ( curr->is_ptr ) {
; 1560 :         psize = 2 << curr->sym.Ofssize;
; 1561 :         if ( curr->sym.isfar )
; 1562 :             psize += 2;
; 1563 :     } else
; 1564 :         psize = SizeFromMemtype( curr->sym.mem_type, curr->sym.Ofssize, curr->sym.type );
; 1565 :     DebugMsg1(("PushInvokeParam(%s,%u): is_ptr=%u, pmtype=%Xh, psize=%u\n", proc->sym.name, reqParam, curr->is_ptr, curr->sym.mem_type, psize ));
; 1566 : #endif
; 1567 : 
; 1568 :     /* ADDR: the argument's address is to be pushed? */
; 1569 :     if ( tokenarray[i].token == T_RES_ID && tokenarray[i].tokval == T_ADDR ) {

	movsxd	rax, r15d
	shl	rax, 5
	cmp	BYTE PTR [rax+r13], 7
	jne	SHORT $LN245@PushInvoke
	cmp	DWORD PTR [rax+r13+16], 260		; 00000104H
	jne	SHORT $LN245@PushInvoke

; 1570 :         addr = TRUE;

	mov	BYTE PTR addr$1$[rsp], 1

; 1571 :         i++;

	inc	r15d
$LN245@PushInvoke:

; 1572 :     }
; 1573 : 
; 1574 :     /* copy the parameter tokens to fullparam */
; 1575 :     for ( j = i; tokenarray[j].token != T_COMMA && tokenarray[j].token != T_FINAL; j++ );

	movsxd	rbx, r15d
	mov	DWORD PTR j$[rsp], r15d
	mov	ecx, r15d
	mov	rbp, rbx
	shl	rbp, 5
	mov	QWORD PTR tv3014[rsp], rbp
	movzx	eax, BYTE PTR [r13+rbp]
	cmp	al, 44					; 0000002cH
	je	SHORT $LN409@PushInvoke
$LL244@PushInvoke:
	test	al, al
	je	SHORT $LN409@PushInvoke
	inc	ecx
	movsxd	rax, ecx
	mov	DWORD PTR j$[rsp], ecx
	shl	rax, 5
	mov	al, BYTE PTR [rax+r13]
	cmp	al, 44					; 0000002cH
	jne	SHORT $LL244@PushInvoke
$LN409@PushInvoke:

; 1576 : 	if (isString[i])

	cmp	BYTE PTR isString$[rsp+rbx], 0
	je	SHORT $LN241@PushInvoke

; 1577 : 	{
; 1578 : 		memcpy(fullparam, stringparam[i], strlen(stringparam[i])+1 );

	mov	rax, rbx
	mov	rcx, -1
	shl	rax, 10
	lea	rdx, QWORD PTR stringparam$[rsp+rax]
	xor	eax, eax
	mov	rdi, rdx
	repne scasb
	not	rcx
	mov	r8, rcx
	lea	rcx, QWORD PTR fullparam$[rsp]
	call	memcpy

; 1579 : 		addr = TRUE;
; 1580 : 		psize = 2 << curr->sym.Ofssize;

	movzx	ecx, BYTE PTR [r12+52]
	mov	esi, r14d
	shl	esi, cl

; 1581 : 		if (curr->sym.isfar)

	test	BYTE PTR [r12+55], 16
	mov	BYTE PTR addr$1$[rsp], 1
	je	SHORT $LN239@PushInvoke

; 1582 : 			psize += 2;

	add	esi, 2

; 1583 : 	}
; 1584 : 	else

	jmp	SHORT $LN239@PushInvoke
$LN241@PushInvoke:

; 1585 : 	{
; 1586 : 		memcpy(fullparam, tokenarray[i].tokpos, tokenarray[j].tokpos - tokenarray[i].tokpos);

	mov	rdx, QWORD PTR [r13+rbp+24]
	movsxd	rdi, ecx
	lea	rcx, QWORD PTR fullparam$[rsp]
	shl	rdi, 5
	mov	r8, QWORD PTR [rdi+r13+24]
	sub	r8, rdx
	call	memcpy

; 1587 : 		fullparam[tokenarray[j].tokpos - tokenarray[i].tokpos] = NULLC;

	mov	rax, QWORD PTR [rdi+r13+24]
	sub	rax, QWORD PTR [r13+rbp+24]
	mov	BYTE PTR fullparam$[rsp+rax], 0
$LN239@PushInvoke:

; 1588 : 	}
; 1589 :     
; 1590 : 
; 1591 :     j = i;
; 1592 :     /* v2.11: GetSymOfssize() doesn't work for state SYM_TYPE */
; 1593 :     //fptrsize = 2 + ( 2 << GetSymOfssize( &proc->sym ) );
; 1594 :     Ofssize = ( proc->sym.state == SYM_TYPE ? proc->sym.seg_ofssize : GetSymOfssize( &proc->sym ) );

	mov	rax, QWORD PTR proc$[rsp]
	mov	DWORD PTR j$[rsp], r15d
	cmp	DWORD PTR [rax+40], 7
	jne	SHORT $LN284@PushInvoke
	mov	r14b, BYTE PTR [rax+55]
	and	r14b, 3
	jmp	SHORT $LN285@PushInvoke
$LN284@PushInvoke:
	mov	rcx, rax
	call	GetSymOfssize
	mov	r14d, eax
$LN285@PushInvoke:

; 1595 :     fptrsize = 2 + ( 2 << Ofssize );
; 1596 : 
; 1597 :     if ( addr ) {

	mov	rbp, QWORD PTR r0flags$[rsp]
	movsx	r12d, r14b
	mov	r8d, 2
	mov	ecx, r12d
	mov	r15d, r8d
	shl	r15d, cl
	cmp	BYTE PTR addr$1$[rsp], 0
	lea	edi, DWORD PTR [r15+2]
	je	$LN238@PushInvoke

; 1598 :         /* v2.06: don't handle forward refs if -Zne is set */
; 1599 :         //if ( EvalOperand( &j, Token_Count, &opnd, 0 ) == ERROR )
; 1600 :         if ( EvalOperand( &j, tokenarray, Token_Count, &opnd, ModuleInfo.invoke_exprparm ) == ERROR )

	movzx	ecx, BYTE PTR ModuleInfo+426
	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opnd$[rsp]
	mov	BYTE PTR [rsp+32], cl
	lea	rcx, QWORD PTR j$[rsp]
	mov	rdx, r13
	call	EvalOperand
	cmp	eax, -1

; 1601 :             return( ERROR );

	je	$LN413@PushInvoke

; 1602 :         /* DWORD (16bit) and FWORD(32bit) are treated like FAR ptrs
; 1603 :          * v2.11: argument may be a FAR32 pointer ( psize == 6 ), while
; 1604 :          * fptrsize may be just 4!
; 1605 :          */
; 1606 :         //if ( psize > fptrsize ) {
; 1607 :         if ( psize > fptrsize && fptrsize > 4 ) {

	cmp	esi, edi
	jle	SHORT $LN236@PushInvoke
	cmp	edi, 4
	jle	SHORT $LN236@PushInvoke

; 1608 :             /* QWORD is NOT accepted as a FAR ptr */
; 1609 :             DebugMsg1(("PushInvokeParm(%u): error, psize=%u, fptrsize=%u\n", reqParam, psize, fptrsize));
; 1610 :             EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam+1 );

	mov	edx, DWORD PTR reqParam$[rsp]
	inc	edx

; 1611 :             return( NOT_ERROR );

	jmp	$LN414@PushInvoke
$LN236@PushInvoke:

; 1612 :         }
; 1613 : 
; 1614 :         if (proc->sym.langtype == LANG_FASTCALL){

	mov	r10, QWORD PTR proc$[rsp]
	lea	r13, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR [r10+84]
	cmp	eax, 7
	jne	SHORT $LN235@PushInvoke

; 1615 :           if (fastcall_tab[ModuleInfo.fctype].handleparam(proc, reqParam, curr, addr, &opnd, fullparam, r0flags))

	movsxd	rax, DWORD PTR ModuleInfo+376
	mov	rbx, QWORD PTR curr$[rsp]
	movzx	r9d, BYTE PTR addr$1$[rsp]
	mov	edx, DWORD PTR reqParam$[rsp]
	lea	rcx, QWORD PTR fullparam$[rsp]
	mov	QWORD PTR [rsp+48], rbp
	mov	QWORD PTR [rsp+40], rcx
	lea	rcx, QWORD PTR opnd$[rsp]
	lea	rax, QWORD PTR [rax+rax*2]
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, r10
	mov	r8, rbx
	call	QWORD PTR fastcall_tab[r13+rax*8+16]
	test	eax, eax
	je	SHORT $LN231@PushInvoke

; 1616 :             return(NOT_ERROR);

	jmp	$LN1@PushInvoke
$LN235@PushInvoke:

; 1617 :         }
; 1618 :         else if (proc->sym.langtype == LANG_VECTORCALL){

	cmp	eax, 8
	jne	SHORT $LN411@PushInvoke

; 1619 :             if ( vectorcall_tab[ModuleInfo.fctype].handleparam( proc, reqParam, curr, addr, &opnd, fullparam, r0flags ) )

	movsxd	rax, DWORD PTR ModuleInfo+376
	mov	rbx, QWORD PTR curr$[rsp]
	movzx	r9d, BYTE PTR addr$1$[rsp]
	mov	edx, DWORD PTR reqParam$[rsp]
	lea	rcx, QWORD PTR fullparam$[rsp]
	mov	QWORD PTR [rsp+48], rbp
	mov	QWORD PTR [rsp+40], rcx
	lea	rcx, QWORD PTR opnd$[rsp]
	lea	rax, QWORD PTR [rax+rax*2]
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, r10
	mov	r8, rbx
	call	QWORD PTR vectorcall_tab[r13+rax*8+16]
	test	eax, eax
	je	SHORT $LN231@PushInvoke

; 1620 :                 return( NOT_ERROR );

	jmp	$LN1@PushInvoke
$LN411@PushInvoke:

; 1678 :                     /* v2.04: a 32bit offset pushed in 16-bit code */
; 1679 :                     if ( curr->sym.is_vararg && CurrWordSize == 2 && opnd.Ofssize > USE16 ) {

	mov	rbx, QWORD PTR curr$[rsp]
$LN231@PushInvoke:

; 1621 :         }
; 1622 :         if ( opnd.kind == EXPR_REG || opnd.indirect ) {

	cmp	DWORD PTR opnd$[rsp+60], 2
	je	SHORT $LN229@PushInvoke
	test	BYTE PTR opnd$[rsp+72], 1
	je	$LN399@PushInvoke
$LN229@PushInvoke:

; 1623 :             if ( curr->sym.isfar || psize == fptrsize ) {

	test	BYTE PTR [rbx+55], 16
	jne	SHORT $LN227@PushInvoke
	cmp	esi, edi
	jne	SHORT $LN228@PushInvoke
$LN227@PushInvoke:

; 1624 :                 DebugMsg1(("PushInvokeParam: far ptr, %s isfar=%u, psize=%u, fptrsize=%u\n", curr->sym.name, curr->sym.isfar, psize, fptrsize ));
; 1625 :                 if ( opnd.sym && opnd.sym->state == SYM_STACK )

	mov	rax, QWORD PTR opnd$[rsp+80]
	test	rax, rax
	je	SHORT $LN226@PushInvoke
	cmp	DWORD PTR [rax+40], 5
	jne	SHORT $LN226@PushInvoke

; 1626 :                     GetResWName( T_SS, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	ecx, 27
	call	GetResWName
	jmp	SHORT $LN223@PushInvoke
$LN226@PushInvoke:

; 1627 :                 else if ( opnd.override != NULL )

	mov	rcx, QWORD PTR opnd$[rsp+48]
	test	rcx, rcx
	je	SHORT $LN224@PushInvoke

; 1628 :                     strcpy( buffer, opnd.override->string_ptr );

	mov	rcx, QWORD PTR [rcx+8]
	lea	rdx, QWORD PTR buffer$[rsp]
	npad	6
$LL286@PushInvoke:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL286@PushInvoke

; 1629 :                 else

	jmp	SHORT $LN223@PushInvoke
$LN224@PushInvoke:

; 1630 :                     GetResWName( T_DS, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	ecx, 28
	call	GetResWName
$LN223@PushInvoke:

; 1631 :                 AddLineQueueX( " push %s", buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, OFFSET FLAT:$SG6575
	call	AddLineQueueX
$LN228@PushInvoke:

; 1632 :             }
; 1633 :             AddLineQueueX( " lea %r, %s", regax[ModuleInfo.Ofssize], fullparam );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6576
	mov	edx, DWORD PTR regax[r13+rax*4]
	call	AddLineQueueX

; 1634 :             *r0flags |= R0_USED;

	or	BYTE PTR [rbp], 1

; 1635 :             AddLineQueueX( " push %r", regax[ModuleInfo.Ofssize] );

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	edx, DWORD PTR regax[r13+rax*4]
	lea	rcx, OFFSET FLAT:$SG6577
	call	AddLineQueueX

; 1636 :         } else {

	jmp	$LN402@PushInvoke
$LN238@PushInvoke:

; 1690 : 
; 1691 :         /* handle the <reg>::<reg> case here, the evaluator wont handle it */
; 1692 :         if ( tokenarray[j].token == T_REG &&
; 1693 :             tokenarray[j+1].token == T_DBL_COLON &&
; 1694 :             tokenarray[j+2].token == T_REG ) {

	movsxd	rax, DWORD PTR j$[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	lea	r13, OFFSET FLAT:__ImageBase
	mov	rcx, rax
	shl	rcx, 5
	cmp	BYTE PTR [rcx+rdx], r8b
	jne	$LN202@PushInvoke
	cmp	BYTE PTR [rcx+rdx+32], 13
	jne	$LN202@PushInvoke
	add	rax, r8
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], r8b
	jne	$LN202@PushInvoke

; 1695 :             int asize2;
; 1696 :             /* for pointers, segreg size is assumed to be always 2 */
; 1697 :             if ( GetValueSp( tokenarray[j].tokval ) & OP_SR ) {

	mov	edx, DWORD PTR [rcx+rdx+16]
	lea	rax, QWORD PTR [rdx+rdx*2]
	test	DWORD PTR SpecialTable[r13+rax*4], 24576 ; 00006000H
	je	SHORT $LN201@PushInvoke

; 1698 :                 asize2 = 2;
; 1699 :                 /* v2.11: if target and current src have different offset sizes,
; 1700 :                  * the push of the segment register must be 66h-prefixed!
; 1701 :                  */
; 1702 :                 if ( Ofssize != ModuleInfo.Ofssize || ( curr->sym.Ofssize == USE16 && CurrWordSize > 2 ) )

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	edi, r8d
	cmp	r12d, eax
	jne	SHORT $LN199@PushInvoke
	mov	rax, QWORD PTR curr$[rsp]
	cmp	BYTE PTR [rax+52], 0
	jne	SHORT $LN198@PushInvoke
	cmp	BYTE PTR ModuleInfo+406, dil
	jbe	SHORT $LN198@PushInvoke
$LN199@PushInvoke:

; 1703 :                     AddLineQueue( " db 66h" );

	lea	rcx, OFFSET FLAT:$SG6613
	call	AddLineQueue

; 1704 :             } else

	jmp	SHORT $LN198@PushInvoke
$LN201@PushInvoke:

; 1705 :                 asize2 = SizeFromRegister( tokenarray[j].tokval );

	mov	ecx, edx
	call	SizeFromRegister
	mov	edi, eax
$LN198@PushInvoke:

; 1706 :             asize = SizeFromRegister( tokenarray[j+2].tokval );

	movsxd	rcx, DWORD PTR j$[rsp]
	mov	r12, QWORD PTR tokenarray$[rsp]
	shl	rcx, 5
	mov	ecx, DWORD PTR [rcx+r12+80]
	call	SizeFromRegister

; 1707 :             AddLineQueueX( " push %r", tokenarray[j].tokval );

	movsxd	rcx, DWORD PTR j$[rsp]
	shl	rcx, 5
	mov	ebp, eax
	mov	edx, DWORD PTR [rcx+r12+16]
	lea	rcx, OFFSET FLAT:$SG6615
	call	AddLineQueueX

; 1708 :             /* v2.04: changed */
; 1709 :             if (( curr->sym.is_vararg ) && (asize + asize2) != CurrWordSize )

	mov	rax, QWORD PTR curr$[rsp]
	test	BYTE PTR [rax+55], 32			; 00000020H
	je	SHORT $LN197@PushInvoke
	movzx	ecx, BYTE PTR ModuleInfo+406
	lea	edx, DWORD PTR [rbp+rdi]
	cmp	edx, ecx
	je	SHORT $LN197@PushInvoke

; 1710 :                 size_vararg += asize2;

	add	DWORD PTR size_vararg, edi

; 1711 :             else

	jmp	SHORT $LN196@PushInvoke
$LN197@PushInvoke:

; 1712 :                 asize += asize2;

	add	ebp, edi
$LN196@PushInvoke:

; 1713 :             strcpy( fullparam, tokenarray[j+2].string_ptr );

	movsxd	rdi, DWORD PTR j$[rsp]
	lea	rdx, QWORD PTR fullparam$[rsp]
	mov	rax, rdi
	shl	rax, 5
	mov	rcx, QWORD PTR [rax+r12+72]
	npad	6
$LL289@PushInvoke:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL289@PushInvoke

; 1714 : 
; 1715 :             opnd.kind = EXPR_REG;
; 1716 :             opnd.indirect = FALSE;

	and	DWORD PTR opnd$[rsp+72], -2		; fffffffeH

; 1717 :             opnd.sym = NULL;

	xor	ecx, ecx

; 1718 :             opnd.base_reg = &tokenarray[j+2]; /* for error msg 'eax overwritten...' */

	lea	eax, DWORD PTR [rdi+2]
	mov	QWORD PTR opnd$[rsp+80], rcx
	movsxd	rcx, eax
	mov	edx, 2
	shl	rcx, 5
	mov	DWORD PTR opnd$[rsp+60], edx
	add	rcx, r12
	mov	QWORD PTR opnd$[rsp+24], rcx

; 1719 :         } else {

	jmp	$LN404@PushInvoke
$LN202@PushInvoke:

; 1720 :             /* v2.06: don't handle forward refs if -Zne is set */
; 1721 :             //if ( EvalOperand( &j, Token_Count, &opnd, 0 ) == ERROR ) {
; 1722 :             if ( EvalOperand( &j, tokenarray, Token_Count, &opnd, ModuleInfo.invoke_exprparm ) == ERROR ) {

	movzx	eax, BYTE PTR ModuleInfo+426
	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opnd$[rsp]
	lea	rcx, QWORD PTR j$[rsp]
	mov	BYTE PTR [rsp+32], al
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN194@PushInvoke
$LN413@PushInvoke:

; 1723 :                 return( ERROR );

	mov	eax, -1
	jmp	$LN282@PushInvoke
$LN194@PushInvoke:

; 1724 :             }
; 1725 : 
; 1726 :             /* for a simple register, get its size */
; 1727 :             if ( opnd.kind == EXPR_REG && opnd.indirect == FALSE ) {

	mov	edx, DWORD PTR opnd$[rsp+60]
	cmp	edx, 2
	jne	SHORT $LN193@PushInvoke
	test	BYTE PTR opnd$[rsp+72], 1
	jne	SHORT $LN384@PushInvoke

; 1728 :                 asize = SizeFromRegister( opnd.base_reg->tokval );

	mov	rax, QWORD PTR opnd$[rsp+24]
	mov	ecx, DWORD PTR [rax+16]
	call	SizeFromRegister
	mov	edx, DWORD PTR opnd$[rsp+60]
	mov	ebp, eax
	jmp	$LN404@PushInvoke
$LN193@PushInvoke:

; 1729 :             //} else if ( opnd.mem_type == MT_EMPTY ) { /* v2.10: a TYPE may return mem_type != MT_EMPTY! */
; 1730 :             } else if ( opnd.kind == EXPR_CONST || opnd.mem_type == MT_EMPTY ) {

	test	edx, edx
	je	$LN190@PushInvoke
$LN384@PushInvoke:
	mov	ecx, DWORD PTR opnd$[rsp+64]
	cmp	ecx, 192				; 000000c0H
	je	$LN190@PushInvoke

; 1741 :                 }
; 1742 :                 DebugMsg1(("PushInvokeParm(%u): memtype EMPTY, asize=%u psize=%u\n", reqParam, asize, psize ));
; 1743 :             } else if ( opnd.mem_type != MT_TYPE ) {

	cmp	ecx, 196				; 000000c4H
	je	$LN185@PushInvoke

; 1744 :                 if ( opnd.kind == EXPR_ADDR &&
; 1745 :                      opnd.indirect == FALSE &&
; 1746 :                      opnd.sym &&
; 1747 :                      opnd.instr == EMPTY &&
; 1748 :                      ( opnd.mem_type == MT_NEAR || opnd.mem_type == MT_FAR ) )

	cmp	edx, 1
	jne	SHORT $LN184@PushInvoke
	test	BYTE PTR opnd$[rsp+72], dl
	jne	SHORT $LN184@PushInvoke
	mov	rdx, QWORD PTR opnd$[rsp+80]
	test	rdx, rdx
	je	SHORT $LN184@PushInvoke
	cmp	DWORD PTR opnd$[rsp+56], -2
	jne	SHORT $LN184@PushInvoke
	cmp	ecx, 129				; 00000081H
	je	SHORT $push_address$6579
	cmp	ecx, 130				; 00000082H
	je	SHORT $push_address$6579
$LN184@PushInvoke:

; 1749 :                     goto push_address;
; 1750 :                 if ( opnd.Ofssize == USE_EMPTY )

	movzx	ecx, BYTE PTR opnd$[rsp+69]
	movzx	eax, BYTE PTR ModuleInfo+404

; 1751 :                     opnd.Ofssize = ModuleInfo.Ofssize;
; 1752 :                 asize = SizeFromMemtype( opnd.mem_type, opnd.Ofssize, opnd.type );

	mov	r8, QWORD PTR opnd$[rsp+96]
	mov	edx, ecx
	cmp	cl, 254					; 000000feH
	mov	ecx, DWORD PTR opnd$[rsp+64]
	cmove	edx, eax
	mov	BYTE PTR opnd$[rsp+69], dl
	movzx	edx, dl
	call	SizeFromMemtype

; 1753 :             } else {

	mov	edx, DWORD PTR opnd$[rsp+60]
	mov	ebp, eax
	jmp	$LN404@PushInvoke
$LN399@PushInvoke:

; 1744 :                 if ( opnd.kind == EXPR_ADDR &&
; 1745 :                      opnd.indirect == FALSE &&
; 1746 :                      opnd.sym &&
; 1747 :                      opnd.instr == EMPTY &&
; 1748 :                      ( opnd.mem_type == MT_NEAR || opnd.mem_type == MT_FAR ) )

	mov	rdx, QWORD PTR opnd$[rsp+80]
$push_address$6579:

; 1637 :         push_address:
; 1638 : 
; 1639 :             /* push segment part of address?
; 1640 :              * v2.11: do not assume a far pointer if psize == fptrsize
; 1641 :              * ( parameter might be near32 in a 16-bit environment )
; 1642 :              */
; 1643 :             //if ( curr->sym.isfar || psize == fptrsize ) {
; 1644 :             if ( curr->sym.isfar || psize > ( 2 << curr->sym.Ofssize ) ) {

	mov	r8, QWORD PTR curr$[rsp]
	test	BYTE PTR [r8+55], 16
	jne	SHORT $LN220@PushInvoke
	movzx	ecx, BYTE PTR [r8+52]
	mov	eax, 2
	shl	eax, cl
	cmp	esi, eax
	jle	$LN216@PushInvoke
$LN220@PushInvoke:

; 1645 : 
; 1646 :                 short sreg;
; 1647 :                 sreg = GetSegmentPart( &opnd, buffer, fullparam );

	mov	rcx, QWORD PTR opnd$[rsp+48]
	test	rcx, rcx
	je	$LN329@PushInvoke
	cmp	BYTE PTR [rcx], 2
	jne	SHORT $LN328@PushInvoke
	mov	di, WORD PTR [rcx+16]
$LN314@PushInvoke:

; 1648 :                 if ( sreg ) {

	test	di, di
	je	SHORT $LN219@PushInvoke
$LN388@PushInvoke:

; 1649 :                     /* v2.11: push segment part as WORD or DWORD depending on target's offset size
; 1650 :                      * problem: "pushw ds" is not accepted, so just emit a size prefix.
; 1651 :                      */
; 1652 :                     if ( Ofssize != ModuleInfo.Ofssize || ( curr->sym.Ofssize == USE16 && CurrWordSize > 2 ) )

	movzx	eax, BYTE PTR ModuleInfo+404
	cmp	r12d, eax
	jne	SHORT $LN217@PushInvoke
	cmp	BYTE PTR [r8+52], 0
	jne	SHORT $LN218@PushInvoke
	cmp	BYTE PTR ModuleInfo+406, 2
	jbe	SHORT $LN218@PushInvoke
$LN217@PushInvoke:

; 1653 :                         AddLineQueue( " db 66h" );

	lea	rcx, OFFSET FLAT:$SG6586
	call	AddLineQueue
$LN218@PushInvoke:

; 1654 :                     AddLineQueueX( " push %r", sreg );

	lea	rcx, OFFSET FLAT:$SG6587
	movsx	edx, di
	call	AddLineQueueX

; 1655 :                 } else

	mov	rdx, QWORD PTR opnd$[rsp+80]
	mov	r8, QWORD PTR curr$[rsp]
	jmp	SHORT $LN216@PushInvoke

; 1645 : 
; 1646 :                 short sreg;
; 1647 :                 sreg = GetSegmentPart( &opnd, buffer, fullparam );

$LN328@PushInvoke:
	mov	rcx, QWORD PTR [rcx+8]
	lea	rdx, QWORD PTR buffer$[rsp]
	npad	12
$LL332@PushInvoke:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL332@PushInvoke
$LN219@PushInvoke:

; 1656 :                     AddLineQueueX( " push %s", buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, OFFSET FLAT:$SG6589
	call	AddLineQueueX
	mov	rdx, QWORD PTR opnd$[rsp+80]
	mov	r8, QWORD PTR curr$[rsp]
$LN216@PushInvoke:

; 1657 :             }
; 1658 :             /* push offset part of address */
; 1659 :             if ( (ModuleInfo.curr_cpu & P_CPU_MASK ) < P_186 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 16
	jge	$LN215@PushInvoke

; 1660 :                 AddLineQueueX( " mov %r, offset %s", T_AX, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6591
	mov	edx, 9
	call	AddLineQueueX

; 1661 :                 AddLineQueueX( " push %r", T_AX );

	lea	rcx, OFFSET FLAT:$SG6592
	mov	edx, 9
	call	AddLineQueueX

; 1662 :                 *r0flags |= R0_USED;

	or	BYTE PTR [rbp], 1

; 1663 :             } else {

	mov	rbx, QWORD PTR curr$[rsp]
	jmp	$LN402@PushInvoke

; 1645 : 
; 1646 :                 short sreg;
; 1647 :                 sreg = GetSegmentPart( &opnd, buffer, fullparam );

$LN329@PushInvoke:
	test	rdx, rdx
	je	$LN315@PushInvoke
	mov	rbx, QWORD PTR [rdx+32]
	test	rbx, rbx
	je	$LN325@PushInvoke
	mov	rax, QWORD PTR [rbx+104]
	mov	ecx, DWORD PTR [rax+72]
	cmp	ecx, 2
	je	SHORT $LN323@PushInvoke
	cmp	ecx, 3
	je	SHORT $LN323@PushInvoke
	mov	r8b, 1
	mov	edx, 1
	mov	rcx, rbx
	call	search_assume
	mov	edi, eax
	jmp	SHORT $LN322@PushInvoke
$LN323@PushInvoke:
	mov	r8b, 1
	mov	edx, 3
	mov	rcx, rbx
	call	search_assume
	mov	edi, eax
$LN322@PushInvoke:
	cmp	edi, -2
	je	SHORT $LN321@PushInvoke
	mov	r8, QWORD PTR curr$[rsp]
	add	di, 25
	jmp	$LN314@PushInvoke
$LN321@PushInvoke:
	mov	rcx, QWORD PTR opnd$[rsp+80]
	call	GetGroup
	lea	rdx, QWORD PTR buffer$[rsp]
	test	rax, rax
	cmove	rax, rbx
	mov	rcx, QWORD PTR [rax+8]
	npad	10
$LL333@PushInvoke:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL333@PushInvoke
	jmp	$LN219@PushInvoke
$LN325@PushInvoke:
	cmp	DWORD PTR [rdx+40], 5
	jne	SHORT $LN315@PushInvoke
	mov	di, 27
	jmp	$LN388@PushInvoke
$LN315@PushInvoke:
	mov	eax, DWORD PTR $SG6327[r13]
	lea	rcx, QWORD PTR buffer$[rsp]
	lea	rdi, QWORD PTR buffer$[rsp]
	mov	DWORD PTR [rcx], eax
	movzx	eax, BYTE PTR $SG6327[r13+4]
	lea	rdx, QWORD PTR fullparam$[rsp]
	mov	BYTE PTR [rcx+4], al
	xor	eax, eax
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	3
$LL391@PushInvoke:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL391@PushInvoke

; 1648 :                 if ( sreg ) {

	jmp	$LN219@PushInvoke
$LN215@PushInvoke:

; 1664 :                 if ( curr->sym.is_vararg && opnd.Ofssize == USE_EMPTY && opnd.sym )

	test	BYTE PTR [r8+55], 32			; 00000020H
	je	SHORT $LN400@PushInvoke
	mov	al, BYTE PTR opnd$[rsp+69]
	cmp	al, 254					; 000000feH
	jne	SHORT $LN213@PushInvoke
	test	rdx, rdx
	je	SHORT $LN401@PushInvoke

; 1665 :                     opnd.Ofssize = GetSymOfssize( opnd.sym );

	mov	rcx, rdx
	call	GetSymOfssize
	mov	r8, QWORD PTR curr$[rsp]
	mov	BYTE PTR opnd$[rsp+69], al
	jmp	SHORT $LN213@PushInvoke
$LN400@PushInvoke:
	mov	al, BYTE PTR opnd$[rsp+69]
$LN213@PushInvoke:

; 1666 :                 /* v2.04: expand 16-bit offset to 32
; 1667 :                  * v2.11: also expand if there's an explicit near32 ptr requested in 16-bit
; 1668 :                  */
; 1669 :                 //if ( opnd.Ofssize == USE16 && CurrWordSize > 2 ) {
; 1670 :                 if ( ( opnd.Ofssize == USE16 && CurrWordSize > 2 ) ||
; 1671 :                     ( curr->sym.Ofssize == USE32 && CurrWordSize == 2 ) ) {

	test	al, al
	jne	SHORT $LN401@PushInvoke
	movzx	eax, BYTE PTR ModuleInfo+406
	cmp	al, 2
	ja	SHORT $LN211@PushInvoke
	jmp	SHORT $LN210@PushInvoke
$LN401@PushInvoke:
	mov	al, BYTE PTR ModuleInfo+406
$LN210@PushInvoke:
	movzx	ecx, BYTE PTR [r8+52]
	cmp	cl, 1
	jne	SHORT $LN212@PushInvoke
	cmp	al, 2
	jne	SHORT $LN212@PushInvoke
$LN211@PushInvoke:

; 1672 :                     AddLineQueueX( " pushd %r %s", T_OFFSET, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6598
	mov	edx, 241				; 000000f1H
	call	AddLineQueueX

; 1673 :                 } else if ( CurrWordSize > 2 && curr->sym.Ofssize == USE16 &&

	mov	rbx, QWORD PTR curr$[rsp]
	jmp	SHORT $LN402@PushInvoke
$LN212@PushInvoke:

; 1674 :                            ( curr->sym.isfar || Ofssize == USE16 ) ) { /* v2.11: added */

	cmp	al, 2
	jbe	SHORT $LN208@PushInvoke
	test	cl, cl
	jne	SHORT $LN208@PushInvoke
	test	BYTE PTR [r8+55], 16
	jne	SHORT $LN207@PushInvoke
	test	r14b, r14b
	jne	SHORT $LN208@PushInvoke
$LN207@PushInvoke:

; 1675 :                     AddLineQueueX( " pushw %r %s", T_OFFSET, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6602
	mov	edx, 241				; 000000f1H
	call	AddLineQueueX

; 1676 :                 } else {

	mov	rbx, QWORD PTR curr$[rsp]
	jmp	SHORT $LN402@PushInvoke
$LN208@PushInvoke:

; 1677 :                     AddLineQueueX( " push %r %s", T_OFFSET, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6604
	mov	edx, 241				; 000000f1H
	call	AddLineQueueX

; 1678 :                     /* v2.04: a 32bit offset pushed in 16-bit code */
; 1679 :                     if ( curr->sym.is_vararg && CurrWordSize == 2 && opnd.Ofssize > USE16 ) {

	mov	rbx, QWORD PTR curr$[rsp]
	test	BYTE PTR [rbx+55], 32			; 00000020H
	je	SHORT $LN402@PushInvoke
	cmp	BYTE PTR ModuleInfo+406, 2
	jne	SHORT $LN402@PushInvoke
	cmp	BYTE PTR opnd$[rsp+69], 0
	jbe	SHORT $LN402@PushInvoke

; 1680 :                         size_vararg += CurrWordSize;

	add	DWORD PTR size_vararg, 2
$LN402@PushInvoke:

; 1681 :                     }
; 1682 :                 }
; 1683 :             }
; 1684 :         }
; 1685 :         if ( curr->sym.is_vararg ) {

	movzx	eax, BYTE PTR [rbx+55]
	test	al, 32					; 00000020H
	je	$LN1@PushInvoke

; 1686 :             size_vararg += CurrWordSize + ( curr->sym.isfar ? CurrWordSize : 0 );

	test	al, 16
	je	SHORT $LN287@PushInvoke
	movzx	ecx, BYTE PTR ModuleInfo+406
	movzx	eax, BYTE PTR ModuleInfo+406
	add	eax, ecx
	add	DWORD PTR size_vararg, eax

; 1687 :             DebugMsg1(("PushInvokeParm(%u): new value of size_vararg=%u [CurrWordSize=%u]\n", reqParam, size_vararg, CurrWordSize ));
; 1688 :         }
; 1689 :     } else { /* ! ADDR branch */

	jmp	$LN1@PushInvoke
$LN287@PushInvoke:

; 1686 :             size_vararg += CurrWordSize + ( curr->sym.isfar ? CurrWordSize : 0 );

	movzx	eax, BYTE PTR ModuleInfo+406
	xor	ecx, ecx
	add	eax, ecx
	add	DWORD PTR size_vararg, eax

; 1687 :             DebugMsg1(("PushInvokeParm(%u): new value of size_vararg=%u [CurrWordSize=%u]\n", reqParam, size_vararg, CurrWordSize ));
; 1688 :         }
; 1689 :     } else { /* ! ADDR branch */

	jmp	$LN1@PushInvoke
$LN185@PushInvoke:

; 1754 :                 if ( opnd.sym != NULL )

	mov	rax, QWORD PTR opnd$[rsp+80]
	test	rax, rax
	je	SHORT $LN180@PushInvoke

; 1755 :                     asize = opnd.sym->type->total_size;

	mov	rax, QWORD PTR [rax+88]
	mov	ebp, DWORD PTR [rax+64]

; 1756 :                 else

	jmp	SHORT $LN404@PushInvoke
$LN180@PushInvoke:

; 1757 :                     asize = opnd.mbr->type->total_size;

	mov	rax, QWORD PTR opnd$[rsp+88]
	mov	rcx, QWORD PTR [rax+88]
	mov	ebp, DWORD PTR [rcx+64]
	jmp	SHORT $LN404@PushInvoke
$LN190@PushInvoke:

; 1731 :                 asize = psize;
; 1732 :                 /* v2.04: added, to catch 0-size params ( STRUCT without members ) */
; 1733 :                 if ( psize == 0 ) {

	test	esi, esi
	mov	ebp, esi
	jne	SHORT $LN404@PushInvoke

; 1734 :                     if ( curr->sym.is_vararg == FALSE ) {

	mov	rax, QWORD PTR curr$[rsp]
	test	BYTE PTR [rax+55], 32			; 00000020H
	jne	SHORT $LN188@PushInvoke

; 1735 :                         DebugMsg1(("PushInvokeParm(%u): error, psize=0\n" ));
; 1736 :                         EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam+1 );

	mov	edx, DWORD PTR reqParam$[rsp]
	mov	ecx, 145				; 00000091H
	inc	edx
	call	EmitErr
	mov	edx, DWORD PTR opnd$[rsp+60]
$LN188@PushInvoke:

; 1737 :                     }
; 1738 :                     /* v2.07: for VARARG, get the member's size if it is a structured var */
; 1739 :                     if ( opnd.mbr && opnd.mbr->mem_type == MT_TYPE )

	mov	r8, QWORD PTR opnd$[rsp+88]
	test	r8, r8
	je	SHORT $LN404@PushInvoke
	cmp	DWORD PTR [r8+44], 196			; 000000c4H
	jne	SHORT $LN404@PushInvoke

; 1740 :                         asize = SizeFromMemtype( opnd.mbr->mem_type, opnd.Ofssize, opnd.mbr->type );

	movzx	edx, BYTE PTR opnd$[rsp+69]
	mov	r8, QWORD PTR [r8+88]
	mov	ecx, 196				; 000000c4H
	call	SizeFromMemtype
	mov	edx, DWORD PTR opnd$[rsp+60]
	mov	ebp, eax
$LN404@PushInvoke:

; 1758 :             }
; 1759 :         }
; 1760 : 
; 1761 :         if ( curr->sym.is_vararg == TRUE )

	mov	rcx, QWORD PTR curr$[rsp]

; 1762 :             psize = asize;
; 1763 : 
; 1764 : #ifdef DEBUG_OUT
; 1765 :         if ( opnd.sym )
; 1766 :             DebugMsg1(("PushInvokeParam(%s, %u): arg name=%s, asize=%u, amtype=%xh psize=%u\n", proc->sym.name, reqParam, opnd.sym->name, asize, opnd.mem_type, psize));
; 1767 :         else
; 1768 :             DebugMsg1(("PushInvokeParam(%s, %u): arg no name, asize=%u, amtype=%xh psize=%u\n", proc->sym.name, reqParam, asize, opnd.mem_type, psize));
; 1769 : #endif
; 1770 :         pushsize = CurrWordSize;
; 1771 : 
; 1772 :         if (proc->sym.langtype == LANG_FASTCALL){

	mov	r10, QWORD PTR proc$[rsp]
	movzx	r12d, BYTE PTR ModuleInfo+406
	movzx	eax, BYTE PTR [rcx+55]
	mov	rdi, QWORD PTR r0flags$[rsp]
	and	al, 32					; 00000020H
	cmp	al, 32					; 00000020H
	mov	eax, DWORD PTR [r10+84]
	cmove	esi, ebp
	cmp	eax, 7
	jne	SHORT $LN177@PushInvoke

; 1773 :           if (fastcall_tab[ModuleInfo.fctype].handleparam(proc, reqParam, curr, addr, &opnd, fullparam, r0flags))

	movsxd	rax, DWORD PTR ModuleInfo+376
	lea	rdx, QWORD PTR fullparam$[rsp]
	mov	QWORD PTR [rsp+48], rdi
	mov	QWORD PTR [rsp+40], rdx
	lea	rdx, QWORD PTR opnd$[rsp]
	mov	r8, rcx
	mov	QWORD PTR [rsp+32], rdx
	mov	edx, DWORD PTR reqParam$[rsp]
	lea	rax, QWORD PTR [rax+rax*2]
	xor	r9d, r9d
	mov	rcx, r10
	call	QWORD PTR fastcall_tab[r13+rax*8+16]
	test	eax, eax
	je	$LN405@PushInvoke

; 1774 :             return(NOT_ERROR);

	jmp	$LN1@PushInvoke
$LN177@PushInvoke:

; 1775 :         }
; 1776 :         else if (proc->sym.langtype == LANG_VECTORCALL){

	cmp	eax, 8
	jne	$LN412@PushInvoke

; 1777 :           if (opnd.kind == EXPR_REG && reqParam > 5) {

	cmp	edx, 2
	jne	SHORT $LN173@PushInvoke
	mov	r8d, DWORD PTR reqParam$[rsp]
	cmp	r8d, 5
	jle	SHORT $LN173@PushInvoke

; 1778 :             if ((GetValueSp(reg) & OP_XMM)||(GetValueSp(reg) & OP_YMM) 
; 1779 : #if EVEXSUPP
; 1780 :                 ||(GetValueSp(reg) & OP_ZMM)
; 1781 : #endif
; 1782 :               )

	mov	eax, DWORD PTR SpecialTable
	test	al, 32					; 00000020H
	jne	SHORT $LN171@PushInvoke
	test	al, al
	jns	$LN169@PushInvoke
$LN171@PushInvoke:

; 1783 :                 EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam );                

	mov	edx, r8d
	mov	ecx, 145				; 00000091H
	call	EmitErr

; 1784 :            }
; 1785 :            else if (vectorcall_tab[ModuleInfo.fctype].handleparam(proc, reqParam, curr, addr, &opnd, fullparam, r0flags))

	mov	edx, DWORD PTR opnd$[rsp+60]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	r8d, DWORD PTR reqParam$[rsp]
	jmp	SHORT $LN169@PushInvoke
$LN173@PushInvoke:
	movsxd	rax, DWORD PTR ModuleInfo+376
	lea	rdx, QWORD PTR fullparam$[rsp]
	mov	QWORD PTR [rsp+48], rdi
	mov	QWORD PTR [rsp+40], rdx
	lea	rdx, QWORD PTR opnd$[rsp]
	mov	r8, rcx
	mov	QWORD PTR [rsp+32], rdx
	mov	edx, DWORD PTR reqParam$[rsp]
	lea	rax, QWORD PTR [rax+rax*2]
	xor	r9d, r9d
	mov	rcx, r10
	call	QWORD PTR vectorcall_tab[r13+rax*8+16]
	test	eax, eax

; 1786 :             return(NOT_ERROR);

	jne	$LN1@PushInvoke
$LN405@PushInvoke:
	mov	edx, DWORD PTR opnd$[rsp+60]
	mov	rcx, QWORD PTR curr$[rsp]
	mov	r8d, DWORD PTR reqParam$[rsp]

; 2243 :                                 break;
; 2244 :                             }
; 2245 :                         default:
; 2246 :                             DebugMsg1(("PushInvokeParm(%u): error, CONST, asize=%u, psize=%u, pushsize=%u\n",
; 2247 :                                       reqParam, asize, psize, pushsize ));
; 2248 :                             EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam+1 );

	jmp	SHORT $LN169@PushInvoke
$LN412@PushInvoke:
	mov	r8d, DWORD PTR reqParam$[rsp]
$LN169@PushInvoke:

; 1787 :         }
; 1788 :         /* v2.04: this check has been moved behind the fastcall_tab() call */
; 1789 :         /* v2.11: if target is a pointer, sizes must match */
; 1790 :         //if ( asize > psize ) { /* argument's size too big? */
; 1791 :         if ( ( asize > psize ) || ( asize < psize && curr->sym.mem_type == MT_PTR ) ) {

	cmp	ebp, esi
	jg	$LN167@PushInvoke
	cmp	ebp, esi
	jge	SHORT $LN168@PushInvoke
	cmp	DWORD PTR [rcx+44], 195			; 000000c3H
	je	$LN167@PushInvoke
$LN168@PushInvoke:

; 1795 :         }
; 1796 : 
; 1797 :         if ( ( opnd.kind == EXPR_ADDR && opnd.instr != T_OFFSET ) ||
; 1798 :             ( opnd.kind == EXPR_REG && opnd.indirect == TRUE ) ) {

	cmp	edx, 1
	jne	SHORT $LN164@PushInvoke
	cmp	DWORD PTR opnd$[rsp+56], 241		; 000000f1H
	jne	SHORT $LN165@PushInvoke
$LN109@PushInvoke:

; 2141 : 
; 2142 :                 /* v2.06: size check */
; 2143 :                 if ( psize ) {

	test	esi, esi
	je	$LN43@PushInvoke

; 2144 :                     if ( opnd.kind == EXPR_FLOAT )

	cmp	edx, 3
	jne	$LN51@PushInvoke

; 2145 :                         asize = 4;

	lea	eax, QWORD PTR [rdx+1]
	jmp	$LN44@PushInvoke
$LN164@PushInvoke:

; 1795 :         }
; 1796 : 
; 1797 :         if ( ( opnd.kind == EXPR_ADDR && opnd.instr != T_OFFSET ) ||
; 1798 :             ( opnd.kind == EXPR_REG && opnd.indirect == TRUE ) ) {

	cmp	edx, 2
	jne	SHORT $LN109@PushInvoke
	test	BYTE PTR opnd$[rsp+72], 1
	je	$LN385@PushInvoke
$LN165@PushInvoke:

; 1799 : 
; 1800 :             /* catch the case when EAX has been used for ADDR,
; 1801 :              * and is later used as addressing register!
; 1802 :              *
; 1803 :              */
; 1804 :             if ( *r0flags &&
; 1805 :                 (( opnd.base_reg != NULL &&
; 1806 :                   ( opnd.base_reg->tokval == T_EAX
; 1807 : #if AMD64_SUPPORT
; 1808 :                    || opnd.base_reg->tokval == T_RAX
; 1809 : #endif
; 1810 :                   )) ||
; 1811 :                  ( opnd.idx_reg != NULL &&
; 1812 :                   ( opnd.idx_reg->tokval == T_EAX
; 1813 : #if AMD64_SUPPORT
; 1814 :                    || opnd.idx_reg->tokval == T_RAX
; 1815 : #endif
; 1816 :                  )))) {

	cmp	BYTE PTR [rdi], 0
	je	SHORT $LN163@PushInvoke
	mov	rax, QWORD PTR opnd$[rsp+24]
	test	rax, rax
	je	SHORT $LN161@PushInvoke
	mov	ecx, DWORD PTR [rax+16]
	cmp	ecx, 17
	je	SHORT $LN160@PushInvoke
	cmp	ecx, 115				; 00000073H
	je	SHORT $LN160@PushInvoke
$LN161@PushInvoke:
	mov	rax, QWORD PTR opnd$[rsp+32]
	test	rax, rax
	je	SHORT $LN163@PushInvoke
	mov	ecx, DWORD PTR [rax+16]
	cmp	ecx, 17
	je	SHORT $LN160@PushInvoke
	cmp	ecx, 115				; 00000073H
	jne	SHORT $LN163@PushInvoke
$LN160@PushInvoke:

; 1817 :                 EmitErr( REGISTER_VALUE_OVERWRITTEN_BY_INVOKE );

	mov	ecx, 165				; 000000a5H
	call	EmitErr

; 1818 :                 *r0flags = 0;

	mov	BYTE PTR [rdi], 0
$LN163@PushInvoke:

; 1819 :             }
; 1820 : 
; 1821 :             if ( curr->sym.is_vararg ) {

	mov	r8, QWORD PTR curr$[rsp]
	test	BYTE PTR [r8+55], 32			; 00000020H
	je	SHORT $LN159@PushInvoke

; 1822 :                 size_vararg += ( asize > pushsize ? asize : pushsize );

	cmp	ebp, r12d
	mov	eax, r12d
	cmovg	eax, ebp
	add	DWORD PTR size_vararg, eax
$LN159@PushInvoke:

; 1823 :                 DebugMsg1(("PushInvokeParm(%u): asize=%u added to size_vararg, now=%u\n",
; 1824 :                            reqParam, asize > pushsize ? asize : pushsize, size_vararg ));
; 1825 :             }
; 1826 :             if ( asize > pushsize ) {

	cmp	ebp, r12d
	jle	$LN158@PushInvoke

; 1827 : 
; 1828 :                 short dw = T_WORD;
; 1829 :                 if (( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	mov	si, 207					; 000000cfH
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN157@PushInvoke

; 1830 :                     pushsize = 4;

	mov	r12d, 4

; 1831 :                     dw = T_DWORD;

	mov	si, 209					; 000000d1H
$LN157@PushInvoke:

; 1832 :                 }
; 1833 : 
; 1834 :                 /* in params like "qword ptr [eax]" the typecast
; 1835 :                  * has to be removed */
; 1836 :                 if ( opnd.explicit ) {

	test	BYTE PTR opnd$[rsp+72], 2
	je	$LN360@PushInvoke

; 1837 :                     SkipTypecast( fullparam, i, tokenarray );

	mov	rax, QWORD PTR tv3014[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	xor	cl, cl
	cmp	BYTE PTR [rax+rdx], 44			; 0000002cH
	mov	BYTE PTR fullparam$[rsp], cl
	je	$LN410@PushInvoke
	shl	rbx, 5
	lea	r8, OFFSET FLAT:$SG6438
	add	rbx, rdx
	npad	2
$LL341@PushInvoke:
	cmp	BYTE PTR [rbx], 0
	je	$LN410@PushInvoke
	cmp	BYTE PTR [rbx+32], 5
	lea	rax, QWORD PTR [rbx+32]
	jne	SHORT $LN336@PushInvoke
	cmp	DWORD PTR [rbx+48], 258			; 00000102H
	jne	SHORT $LN336@PushInvoke
	mov	rbx, rax
	jmp	SHORT $LN340@PushInvoke
$LN336@PushInvoke:
	test	cl, cl
	je	SHORT $LN334@PushInvoke
	xor	eax, eax
	lea	rdi, QWORD PTR fullparam$[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	6
$LL390@PushInvoke:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL390@PushInvoke
$LN334@PushInvoke:
	mov	rdx, QWORD PTR [rbx+8]
	xor	eax, eax
	lea	rdi, QWORD PTR fullparam$[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	7
$LL389@PushInvoke:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL389@PushInvoke
	movzx	ecx, BYTE PTR fullparam$[rsp]
$LN340@PushInvoke:
	add	rbx, 32					; 00000020H
	cmp	BYTE PTR [rbx], 44			; 0000002cH
	jne	$LL341@PushInvoke
$LN410@PushInvoke:

; 1838 :                     opnd.explicit = FALSE;

	and	DWORD PTR opnd$[rsp+72], -3		; fffffffdH
$LN360@PushInvoke:

; 1839 :                 }
; 1840 : 
; 1841 :                 while ( asize > 0 ) {

	test	ebp, ebp

; 1847 :                             /* v2.05: better push a 0 word? */
; 1848 :                             //AddLineQueueX( " pushw 0" );
; 1849 :                           /* ASMC v1.12: dword-aligned stack in 32bit */
; 1850 :                           if (pushsize == 4)

	movsxd	rbx, r12d
	jle	$LN1@PushInvoke
	mov	edi, ebp
	sub	edi, r12d
	npad	4
$LL155@PushInvoke:

; 1842 : 
; 1843 :                     if ( asize & 2 ) {

	test	bpl, 2
	je	SHORT $LN153@PushInvoke

; 1844 : 
; 1845 :                         /* ensure the stack remains dword-aligned in 32bit */
; 1846 :                         if ( ModuleInfo.Ofssize > USE16 ) {

	movzx	eax, BYTE PTR ModuleInfo+404
	test	al, al
	je	SHORT $LN152@PushInvoke

; 1847 :                             /* v2.05: better push a 0 word? */
; 1848 :                             //AddLineQueueX( " pushw 0" );
; 1849 :                           /* ASMC v1.12: dword-aligned stack in 32bit */
; 1850 :                           if (pushsize == 4)

	cmp	rbx, 4
	jne	SHORT $LN151@PushInvoke

; 1851 :                             size_vararg += 2;

	add	DWORD PTR size_vararg, 2
$LN151@PushInvoke:

; 1852 :                           /******/
; 1853 : #if AMD64_SUPPORT
; 1854 :                             AddLineQueueX( " sub %r, 2", stackreg[ModuleInfo.Ofssize] );

	movzx	eax, al
	lea	rcx, OFFSET FLAT:$SG6669
	mov	edx, DWORD PTR stackreg[r13+rax*4]
	call	AddLineQueueX
$LN152@PushInvoke:
	add	ebp, -2

; 1855 : #else
; 1856 :                             AddLineQueueX( " sub %r, 2", T_ESP );
; 1857 : #endif
; 1858 :                         }
; 1859 :                         AddLineQueueX( " push word ptr %s+%u", fullparam, NUMQUAL asize-2 );

	lea	rdx, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6670
	mov	r8d, ebp
	call	AddLineQueueX

; 1860 :                         asize -= 2;

	sub	edi, 2

; 1861 :                     } else {

	jmp	SHORT $LN150@PushInvoke
$LN153@PushInvoke:

; 1862 :                         AddLineQueueX( " push %r ptr %s+%u", dw, fullparam, NUMQUAL asize-pushsize );

	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6672
	movsx	edx, si
	mov	r9d, edi
	call	AddLineQueueX

; 1863 :                         asize -= pushsize;

	sub	ebp, r12d
	sub	edi, r12d
$LN150@PushInvoke:

; 1839 :                 }
; 1840 : 
; 1841 :                 while ( asize > 0 ) {

	test	ebp, ebp
	jg	SHORT $LL155@PushInvoke

; 1864 :                     }
; 1865 :                 }
; 1866 :                 //return( NOT_ERROR );
; 1867 : 
; 1868 :             } else if ( asize < pushsize ) {

	jmp	$LN1@PushInvoke
$LN158@PushInvoke:
	cmp	ebp, r12d
	jge	$LN148@PushInvoke

; 1869 : 
; 1870 :                 if ( psize > 4 ) {

	cmp	esi, 4
	jle	SHORT $LN147@PushInvoke

; 1871 :                     DebugMsg1(("PushInvokeParm(%u): error, ADDR, psize=%u, is > 4\n",
; 1872 :                               reqParam, psize ));
; 1873 :                     EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam+1 );

	mov	edx, DWORD PTR reqParam$[rsp]
	mov	ecx, 145				; 00000091H
	inc	edx
	call	EmitErr
	mov	r8, QWORD PTR curr$[rsp]
$LN147@PushInvoke:

; 1874 :                 }
; 1875 :                 /* v2.11: added, use MOVSX/MOVZX if cpu >= 80386 */
; 1876 :                 if ( asize < 4 && psize > 2 && IS_SIGNED( opnd.mem_type ) && ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {

	cmp	ebp, 4
	mov	edx, DWORD PTR ModuleInfo+392
	jge	SHORT $LN146@PushInvoke
	cmp	esi, 2
	jle	SHORT $LN146@PushInvoke
	mov	eax, DWORD PTR opnd$[rsp+64]
	and	al, -64					; ffffffffffffffc0H
	cmp	al, 64					; 00000040H
	jne	SHORT $LN146@PushInvoke
	mov	eax, edx
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN146@PushInvoke

; 1877 :                     AddLineQueueX( " movsx %r, %s", T_EAX, fullparam );

	mov	ebx, 17
	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6677
	mov	edx, ebx
	call	AddLineQueueX

; 1878 :                     AddLineQueueX( " push %r", T_EAX );

	lea	rcx, OFFSET FLAT:$SG6678
	mov	edx, ebx
	call	AddLineQueueX

; 1879 :                     *r0flags = R0_USED; /* reset R0_H_CLEARED  */

	mov	BYTE PTR [rdi], 1

; 1880 :                 } else {

	jmp	$LN1@PushInvoke
$LN146@PushInvoke:

; 1881 :                     //switch (sym->mem_type) {
; 1882 :                     switch ( opnd.mem_type ) {

	mov	ecx, DWORD PTR opnd$[rsp+64]
	test	ecx, ecx
	je	$LN142@PushInvoke
	dec	ecx
	je	SHORT $LN129@PushInvoke
	sub	ecx, 63					; 0000003fH
	je	$LN142@PushInvoke
	dec	ecx
	je	SHORT $LN129@PushInvoke

; 1950 :                     default:
; 1951 :                         AddLineQueueX( " push %s", fullparam );

	lea	rdx, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6728
	call	AddLineQueueX
	jmp	$LN1@PushInvoke
$LN129@PushInvoke:

; 1919 :                         break;
; 1920 :                     case MT_WORD:
; 1921 :                     case MT_SWORD:
; 1922 :                         /* pushsize is 4 here, hence it's always 32-bit code!
; 1923 :                          * v2.04: use the Masm-compatible, non-destructive
; 1924 :                          * PUSH if psize is 2.
; 1925 :                          */
; 1926 :                         //if ( Options.masm_compat_gencode ) {
; 1927 :                         /* v2.11: don't push 0 if src operand is signed */
; 1928 :                         //if ( Options.masm_compat_gencode || psize == 2 ) {
; 1929 :                         if ( opnd.mem_type == MT_WORD && ( Options.masm_compat_gencode || psize == 2 )) {

	cmp	DWORD PTR opnd$[rsp+64], 1
	jne	SHORT $LN128@PushInvoke
	cmp	BYTE PTR Options+137, 0
	jne	SHORT $LN127@PushInvoke
	cmp	esi, 2
	jne	SHORT $LN128@PushInvoke
$LN127@PushInvoke:

; 1930 :                             /* v2.05: push a 0 word if argument is VARARG
; 1931 :                              * v2.10: push a 0 word if psize != 2
; 1932 :                              */
; 1933 :                             //if ( curr->sym.is_vararg )
; 1934 :                             if ( curr->sym.is_vararg || psize != 2 )

	test	BYTE PTR [r8+55], 32			; 00000020H
	jne	SHORT $LN125@PushInvoke
	cmp	esi, 2
	jne	SHORT $LN125@PushInvoke

; 1936 :                             else {
; 1937 : #if AMD64_SUPPORT
; 1938 :                                 AddLineQueueX( " sub %r, 2", stackreg[ModuleInfo.Ofssize] );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:$SG6720
	mov	edx, DWORD PTR stackreg[r13+rax*4]
	call	AddLineQueueX
	jmp	SHORT $LN124@PushInvoke
$LN125@PushInvoke:

; 1935 :                                 AddLineQueueX( " pushw 0" );

	lea	rcx, OFFSET FLAT:$SG6718
	call	AddLineQueueX
$LN124@PushInvoke:

; 1939 : #else
; 1940 :                                 AddLineQueueX( " sub %r, 2", T_ESP );
; 1941 : #endif
; 1942 :                             }
; 1943 :                             AddLineQueueX( " push %s", fullparam );

	lea	rdx, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6721
	call	AddLineQueueX

; 1944 :                         } else {

	jmp	$LN1@PushInvoke
$LN128@PushInvoke:

; 1945 :                             AddLineQueueX( " mov%sx %r, %s", opnd.mem_type == MT_WORD ? "z" : "s", T_EAX, fullparam );

	cmp	DWORD PTR opnd$[rsp+64], 1
	lea	rax, OFFSET FLAT:$SG6723
	lea	rdx, OFFSET FLAT:$SG6724
	mov	ebx, 17
	lea	r9, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6725
	cmove	rdx, rax
	mov	r8d, ebx
	call	AddLineQueueX

; 1946 :                             AddLineQueueX( " push %r", T_EAX );

	lea	rcx, OFFSET FLAT:$SG6726
	mov	edx, ebx
	call	AddLineQueueX

; 1947 :                             *r0flags = R0_USED; /* reset R0_H_CLEARED  */

	mov	BYTE PTR [rdi], 1

; 1948 :                         }
; 1949 :                         break;

	jmp	$LN1@PushInvoke
$LN142@PushInvoke:

; 1883 :                     case MT_BYTE:
; 1884 :                     case MT_SBYTE:
; 1885 :                         if ( psize == 1 && curr->sym.is_vararg == FALSE ) {

	cmp	esi, 1
	jne	SHORT $LN141@PushInvoke
	test	BYTE PTR [r8+55], 32			; 00000020H
	jne	SHORT $LN141@PushInvoke

; 1886 :                             AddLineQueueX( " mov %r, %s", T_AL, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6686
	mov	edx, esi
	call	AddLineQueueX

; 1887 :                             AddLineQueueX( " push %r", regax[ModuleInfo.Ofssize] );

	movzx	edx, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:$SG6687
	mov	edx, DWORD PTR regax[r13+rdx*4]
	call	AddLineQueueX

; 1917 :                         }
; 1918 :                         *r0flags |= R0_USED;

	or	BYTE PTR [rdi], sil

; 1952 :                     }
; 1953 :                 }
; 1954 :             } else { /* asize == pushsize */

	jmp	$LN1@PushInvoke
$LN141@PushInvoke:

; 1888 :                         } else if ( pushsize == 2 ) { /* 16-bit code? */

	cmp	r12d, 2
	jne	$LN139@PushInvoke

; 1889 :                             if ( opnd.mem_type == MT_BYTE ) {

	cmp	DWORD PTR opnd$[rsp+64], 0
	jne	SHORT $LN138@PushInvoke

; 1890 :                                 if ( psize == 4 )

	cmp	esi, 4
	jne	SHORT $LN134@PushInvoke

; 1891 :                                     if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) < P_186 )  {

	and	edx, 240				; 000000f0H
	cmp	edx, 16
	jge	SHORT $LN136@PushInvoke

; 1892 :                                         if ( !(*r0flags & R0_X_CLEARED ) )

	test	BYTE PTR [rdi], sil
	jne	SHORT $LN135@PushInvoke

; 1893 :                                             AddLineQueueX( " xor %r, %r", T_AX, T_AX );

	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG6694
	mov	r8d, edx
	call	AddLineQueueX
$LN135@PushInvoke:

; 1894 :                                         *r0flags |= ( R0_X_CLEARED | R0_H_CLEARED );

	or	BYTE PTR [rdi], 6

; 1895 :                                         AddLineQueueX( " push %r", T_AX );

	lea	rcx, OFFSET FLAT:$SG6695
	mov	edx, 9
	call	AddLineQueueX

; 1896 :                                     } else

	jmp	SHORT $LN134@PushInvoke
$LN136@PushInvoke:

; 1897 :                                         AddLineQueue( " push 0" );

	lea	rcx, OFFSET FLAT:$SG6697
	call	AddLineQueue
$LN134@PushInvoke:

; 1898 :                                 AddLineQueueX( " mov %r, %s", T_AL, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6698
	mov	edx, 1
	call	AddLineQueueX

; 1899 :                                 if ( !( *r0flags & R0_H_CLEARED )) {

	test	BYTE PTR [rdi], 2
	jne	SHORT $LN131@PushInvoke

; 1900 :                                     AddLineQueueX( " mov %r, 0", T_AH );

	lea	rcx, OFFSET FLAT:$SG6700
	mov	edx, 5
	call	AddLineQueueX

; 1901 :                                     *r0flags |= R0_H_CLEARED;

	or	BYTE PTR [rdi], 2

; 1902 :                                 }
; 1903 :                             } else {

	jmp	SHORT $LN131@PushInvoke
$LN138@PushInvoke:

; 1904 :                                 AddLineQueueX( " mov %r, %s", T_AL, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6702
	mov	edx, 1
	call	AddLineQueueX

; 1905 :                                 *r0flags = 0; /* reset AH_CLEARED */
; 1906 :                                 AddLineQueue( " cbw" );

	lea	rcx, OFFSET FLAT:$SG6703
	mov	BYTE PTR [rdi], 0
	call	AddLineQueue

; 1907 :                                 if ( psize == 4 ) {

	cmp	esi, 4
	jne	SHORT $LN131@PushInvoke

; 1908 :                                     AddLineQueue( " cwd" );

	lea	rcx, OFFSET FLAT:$SG6705
	call	AddLineQueue

; 1909 :                                     AddLineQueueX( " push %r", T_DX );

	lea	edx, QWORD PTR [rsi+7]
	lea	rcx, OFFSET FLAT:$SG6706
	call	AddLineQueueX

; 1910 :                                     *r0flags |= R2_USED;

	or	BYTE PTR [rdi], 8
$LN131@PushInvoke:

; 1911 :                                 }
; 1912 :                             }
; 1913 :                             AddLineQueueX( " push %r", T_AX );

	lea	rcx, OFFSET FLAT:$SG6707
	mov	edx, 9
	call	AddLineQueueX

; 1917 :                         }
; 1918 :                         *r0flags |= R0_USED;

	or	BYTE PTR [rdi], 1

; 1952 :                     }
; 1953 :                 }
; 1954 :             } else { /* asize == pushsize */

	jmp	$LN1@PushInvoke
$LN139@PushInvoke:

; 1914 :                         } else {
; 1915 :                             AddLineQueueX( " mov%sx %r, %s", opnd.mem_type == MT_BYTE ? "z" : "s", T_EAX, fullparam );

	cmp	DWORD PTR opnd$[rsp+64], 0
	lea	rax, OFFSET FLAT:$SG6709
	lea	rdx, OFFSET FLAT:$SG6710
	mov	ebx, 17
	lea	r9, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6711
	cmove	rdx, rax
	mov	r8d, ebx
	call	AddLineQueueX

; 1916 :                             AddLineQueueX( " push %r", T_EAX );

	lea	rcx, OFFSET FLAT:$SG6712
	mov	edx, ebx
	call	AddLineQueueX

; 1917 :                         }
; 1918 :                         *r0flags |= R0_USED;

	or	BYTE PTR [rdi], 1

; 1952 :                     }
; 1953 :                 }
; 1954 :             } else { /* asize == pushsize */

	jmp	$LN1@PushInvoke
$LN148@PushInvoke:

; 1955 : 
; 1956 :                 /* v2.11: changed */
; 1957 :                 if ( IS_SIGNED( opnd.mem_type ) && psize > asize ) {

	mov	eax, DWORD PTR opnd$[rsp+64]
	and	al, -64					; ffffffffffffffc0H
	cmp	al, 64					; 00000040H
	jne	$LN120@PushInvoke
	cmp	esi, ebp
	jle	$LN120@PushInvoke

; 1958 :                     if ( psize > 2 && (( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) ) {

	cmp	esi, 2
	jle	SHORT $LN119@PushInvoke
	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN119@PushInvoke

; 1959 :                         AddLineQueueX( " movsx %r, %s", T_EAX, fullparam );

	mov	ebx, 17
	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6732
	mov	edx, ebx
	call	AddLineQueueX

; 1960 :                         AddLineQueueX( " push %r", T_EAX );

	lea	rcx, OFFSET FLAT:$SG6733
	mov	edx, ebx
	call	AddLineQueueX

; 1961 :                         *r0flags = R0_USED; /* reset R0_H_CLEARED  */

	mov	BYTE PTR [rdi], 1
	jmp	$LN1@PushInvoke
$LN119@PushInvoke:

; 1962 :                     } else if ( pushsize == 2 && psize > 2 ) {

	cmp	r12d, 2
	jne	SHORT $LN117@PushInvoke
	cmp	esi, r12d
	jle	SHORT $LN117@PushInvoke

; 1963 :                         AddLineQueueX( " mov %r, %s", T_AX, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	lea	edx, QWORD PTR [r12+7]
	lea	rcx, OFFSET FLAT:$SG6736
	call	AddLineQueueX

; 1964 :                         AddLineQueueX( " cwd" );

	lea	rcx, OFFSET FLAT:$SG6737
	call	AddLineQueueX

; 1965 :                         AddLineQueueX( " push %r", T_DX );

	lea	edx, QWORD PTR [r12+9]
	lea	rcx, OFFSET FLAT:$SG6738
	call	AddLineQueueX

; 1966 :                         AddLineQueueX( " push %r", T_AX );

	lea	edx, QWORD PTR [r12+7]
	lea	rcx, OFFSET FLAT:$SG6739
	call	AddLineQueueX

; 1967 :                         *r0flags = R0_USED | R2_USED;

	mov	BYTE PTR [rdi], 9

; 1968 :                     } else

	jmp	$LN1@PushInvoke
$LN117@PushInvoke:

; 1969 :                         AddLineQueueX( " push %s", fullparam );

	lea	rdx, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6741
	call	AddLineQueueX

; 1970 :                 } else {

	jmp	$LN1@PushInvoke
$LN120@PushInvoke:

; 1971 :                     if ( pushsize == 2 && psize > 2 ) {

	cmp	r12d, 2
	jne	SHORT $LN111@PushInvoke
	cmp	esi, r12d
	jle	SHORT $LN111@PushInvoke

; 1972 :                         if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) < P_186 )  {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 16
	jge	SHORT $LN113@PushInvoke

; 1973 :                             if ( !(*r0flags & R0_X_CLEARED ) )

	test	BYTE PTR [rdi], 4
	jne	SHORT $LN112@PushInvoke

; 1974 :                                 AddLineQueueX( " xor %r, %r", T_AX, T_AX );

	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG6746
	mov	r8d, edx
	call	AddLineQueueX
$LN112@PushInvoke:

; 1975 :                             AddLineQueueX( " push %r", T_AX );

	lea	rcx, OFFSET FLAT:$SG6747
	mov	edx, 9
	call	AddLineQueueX

; 1976 :                             *r0flags |= ( R0_USED | R0_X_CLEARED | R0_H_CLEARED );

	or	BYTE PTR [rdi], 7

; 1977 :                         } else

	jmp	SHORT $LN111@PushInvoke
$LN113@PushInvoke:

; 1978 :                             AddLineQueueX( " pushw 0" );

	lea	rcx, OFFSET FLAT:$SG6749
	call	AddLineQueueX
$LN111@PushInvoke:

; 1979 :                     }
; 1980 :                     AddLineQueueX( " push %s", fullparam );

	lea	rdx, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6750
	call	AddLineQueueX

; 1981 :                 }
; 1982 :             }
; 1983 : 
; 1984 :         } else { /* the parameter is a register or constant value! */

	jmp	$LN1@PushInvoke
$LN385@PushInvoke:

; 1985 : 
; 1986 :             //char is_r0 = FALSE;
; 1987 :             if ( opnd.kind == EXPR_REG ) {
; 1988 :                 int reg = opnd.base_reg->tokval;

	mov	rax, QWORD PTR opnd$[rsp+24]
	movsxd	rbx, DWORD PTR [rax+16]

; 1989 :                 unsigned optype = GetValueSp( reg );
; 1990 : 
; 1991 :                 /* v2.11 */
; 1992 :                 if ( curr->sym.is_vararg == TRUE && psize < pushsize )

	mov	rax, QWORD PTR curr$[rsp]
	test	BYTE PTR [rax+55], 32			; 00000020H
	lea	rcx, QWORD PTR [rbx+rbx*2]
	mov	r14d, DWORD PTR SpecialTable[r13+rcx*4]
	je	SHORT $LN108@PushInvoke
	cmp	esi, r12d
	cmovl	esi, r12d
$LN108@PushInvoke:

; 1993 :                     psize = pushsize;
; 1994 : 
; 1995 :                 /* v2.06: check if register is valid to be pushed.
; 1996 :                  * ST(n), MMn, XMMn, YMMn and special registers are NOT valid!
; 1997 :                  */
; 1998 :                 if ( optype & ( OP_STI | OP_MMX | OP_XMM
; 1999 : #if AVXSUPP
; 2000 :                                | OP_YMM
; 2001 : #endif
; 2002 :                                | OP_RSPEC ) ) {

	test	r14d, 102576				; 000190b0H
	je	SHORT $LN107@PushInvoke

; 2003 : 
; 2004 :                     return( EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam+1 ) );

	lea	edx, DWORD PTR [r8+1]
	mov	ecx, 145				; 00000091H
	call	EmitErr
	jmp	$LN282@PushInvoke
$LN107@PushInvoke:

; 2005 :                 }
; 2006 : 
; 2007 :                 if ( ( *r0flags & R0_USED ) && ( reg == T_AH || ( optype & OP_A ) ) ) {

	movzx	eax, BYTE PTR [rdi]
	test	al, 1
	je	SHORT $LN106@PushInvoke
	cmp	ebx, 5
	je	SHORT $LN105@PushInvoke
	bt	r14d, 9
	jae	SHORT $LN106@PushInvoke
$LN105@PushInvoke:

; 2008 :                     EmitErr( REGISTER_VALUE_OVERWRITTEN_BY_INVOKE );

	mov	ecx, 165				; 000000a5H
	call	EmitErr

; 2009 :                     *r0flags &= ~R0_USED;

	and	BYTE PTR [rdi], 254			; 000000feH
	jmp	SHORT $LN103@PushInvoke
$LN106@PushInvoke:

; 2010 :                 } else if ( ( *r0flags & R2_USED ) && ( reg == T_DH || GetRegNo( reg ) == 2 ) ) {

	test	al, 8
	je	SHORT $LN103@PushInvoke
	cmp	ebx, 7
	je	SHORT $LN102@PushInvoke
	cmp	BYTE PTR SpecialTable[r13+rcx*4+10], 2
	jne	SHORT $LN103@PushInvoke
$LN102@PushInvoke:

; 2011 :                     EmitErr( REGISTER_VALUE_OVERWRITTEN_BY_INVOKE );

	mov	ecx, 165				; 000000a5H
	call	EmitErr

; 2012 :                     *r0flags &= ~R2_USED;

	and	BYTE PTR [rdi], 247			; 000000f7H
$LN103@PushInvoke:

; 2013 :                 }
; 2014 :                 /* v2.11: use target's "pushsize", not the current one */
; 2015 :                 //if ( asize != psize || asize < pushsize ) {
; 2016 :                 if ( asize != psize || asize < ( 2 << Ofssize ) ) {

	cmp	ebp, esi
	jne	SHORT $LN100@PushInvoke
	cmp	ebp, r15d
	jge	$LN55@PushInvoke
$LN100@PushInvoke:

; 2017 :                     /* register size doesn't match the needed parameter size.
; 2018 :                      */
; 2019 :                     if ( psize > 4 ) {

	cmp	esi, 4
	jle	SHORT $LN99@PushInvoke

; 2020 :                         DebugMsg1(("PushInvokeParm(%u): error, REG, asize=%u, psize=%u, pushsize=%u\n",
; 2021 :                                   reqParam, asize, psize, pushsize ));
; 2022 :                         EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam+1 );

	mov	edx, DWORD PTR reqParam$[rsp]
	mov	ecx, 145				; 00000091H
	inc	edx
	call	EmitErr
$LN99@PushInvoke:

; 2023 :                     }
; 2024 : 
; 2025 :                     if ( asize <= 2 && ( psize == 4 || pushsize == 4 ) ) {

	cmp	ebp, 2
	jg	$LN73@PushInvoke
	cmp	esi, 4
	je	SHORT $LN97@PushInvoke
	cmp	r12d, 4
	jne	$LN73@PushInvoke
$LN97@PushInvoke:

; 2026 :                         if (( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 && asize == psize ) {

	mov	eax, DWORD PTR ModuleInfo+392
	mov	ecx, eax
	and	ecx, 240				; 000000f0H
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN96@PushInvoke
	cmp	ebp, esi
	jne	SHORT $LN96@PushInvoke

; 2027 :                             if ( asize == 2 )

	cmp	ebp, 2
	jne	SHORT $LN95@PushInvoke

; 2028 :                                 reg = reg - T_AX + T_EAX;

	add	ebx, 8

; 2029 :                             else {

	jmp	$LN55@PushInvoke
$LN95@PushInvoke:

; 2030 :                                 /* v2.11: hibyte registers AH, BH, CH, DH ( no 4-7 ) needs special handling */
; 2031 :                                 if ( reg < T_AH )

	cmp	ebx, 5
	jge	SHORT $LN93@PushInvoke

; 2032 :                                     reg = reg - T_AL + T_EAX;

	add	ebx, 16

; 2033 :                                 else {

	jmp	$LN55@PushInvoke
$LN93@PushInvoke:

; 2034 :                                     AddLineQueueX( " mov %r, %s", T_AL, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6772
	mov	edx, 1
	call	AddLineQueueX

; 2035 :                                     *r0flags |= R0_USED;

	or	BYTE PTR [rdi], 1

; 2036 :                                     reg = T_EAX;

	mov	ebx, 17

; 2037 :                                 }
; 2038 :                                 asize = 2; /* done */
; 2039 :                             }

	jmp	$LN55@PushInvoke
$LN96@PushInvoke:

; 2040 :                         } else if ( IS_SIGNED( opnd.mem_type ) && pushsize < 4 ) {

	mov	edx, DWORD PTR opnd$[rsp+64]
	and	edx, 192				; 000000c0H
	cmp	edx, 64					; 00000040H
	jne	$LN90@PushInvoke
	cmp	r12d, 4
	jge	$LN90@PushInvoke

; 2041 : 
; 2042 :                             /* psize is 4 in this branch */
; 2043 :                             if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {

	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN89@PushInvoke

; 2044 :                                 AddLineQueueX( " movsx %r, %s", T_EAX, fullparam );

	mov	ebx, 17
	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6776
	mov	edx, ebx
	call	AddLineQueueX

; 2045 :                                 *r0flags = R0_USED;

	mov	BYTE PTR [rdi], 1

; 2046 :                                 reg = T_EAX;
; 2047 :                             } else {

	jmp	$LN55@PushInvoke
$LN89@PushInvoke:

; 2048 :                                 *r0flags = R0_USED | R2_USED;
; 2049 :                                 if ( asize == 1 ) {

	cmp	ebp, 1
	mov	BYTE PTR [rdi], 9
	jne	SHORT $LN87@PushInvoke

; 2050 :                                     if ( reg != T_AL )

	cmp	ebx, ebp
	je	SHORT $LN86@PushInvoke

; 2051 :                                         AddLineQueueX( " mov %r, %s", T_AL, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6780
	mov	edx, ebp
	call	AddLineQueueX
$LN86@PushInvoke:

; 2052 :                                     AddLineQueue( " cbw" );

	lea	rcx, OFFSET FLAT:$SG6781
	call	AddLineQueue
	jmp	SHORT $LN84@PushInvoke
$LN87@PushInvoke:

; 2053 :                                 } else if ( reg != T_AX )

	cmp	ebx, 9
	je	SHORT $LN84@PushInvoke

; 2054 :                                     AddLineQueueX( " mov %r, %s", T_AX, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6784
	mov	edx, 9
	call	AddLineQueueX
$LN84@PushInvoke:

; 2055 :                                 AddLineQueue( " cwd" );

	lea	rcx, OFFSET FLAT:$SG6785
	call	AddLineQueue

; 2056 :                                 AddLineQueueX( " push %r", T_DX );

	lea	rcx, OFFSET FLAT:$SG6786
	mov	edx, 11
	call	AddLineQueueX

; 2057 :                                 reg = T_AX;

	mov	ebx, 9

; 2058 :                             }
; 2059 :                             asize = 2; /* done */

	jmp	$LN55@PushInvoke
$LN90@PushInvoke:

; 2060 : 
; 2061 :                         } else if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_186 ) {

	cmp	ecx, 16
	jl	SHORT $LN82@PushInvoke

; 2062 : 
; 2063 :                             if ( pushsize == 4 ) {

	cmp	r12d, 4
	jne	SHORT $LN81@PushInvoke

; 2064 :                                 if ( asize == 1 ) {

	cmp	ebp, 1
	je	$LN380@PushInvoke

; 2065 :                                     /* handled below */
; 2066 :                                 } else if ( psize <= 2 ) {

	cmp	esi, 2
	jg	SHORT $LN78@PushInvoke

; 2067 : #if AMD64_SUPPORT
; 2068 :                                     AddLineQueueX( " sub %r, 2", stackreg[ModuleInfo.Ofssize] );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:$SG6793
	mov	edx, DWORD PTR stackreg[r13+rax*4]
	call	AddLineQueueX
	jmp	$LN73@PushInvoke
$LN78@PushInvoke:

; 2069 : #else
; 2070 :                                     AddLineQueueX( " sub %r, 2", T_ESP );
; 2071 : #endif
; 2072 :                                 } else if ( IS_SIGNED( opnd.mem_type ) ) {

	cmp	edx, 64					; 00000040H
	jne	SHORT $LN76@PushInvoke

; 2073 :                                     AddLineQueueX( " movsx %r, %s", T_EAX, fullparam );

	mov	ebx, 17
	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6796
	mov	edx, ebx
	call	AddLineQueueX

; 2074 :                                     *r0flags = R0_USED;

	mov	BYTE PTR [rdi], 1

; 2075 :                                     reg = T_EAX;
; 2076 :                                 } else {

	jmp	SHORT $LN73@PushInvoke
$LN76@PushInvoke:

; 2077 :                                     AddLineQueue( " pushw 0" );

	lea	rcx, OFFSET FLAT:$SG6798
	call	AddLineQueue

; 2078 :                                 }
; 2079 :                             } else

	jmp	SHORT $LN73@PushInvoke
$LN81@PushInvoke:

; 2080 :                                 AddLineQueue( " pushw 0" );

	lea	rcx, OFFSET FLAT:$SG6800
	call	AddLineQueue

; 2081 : 
; 2082 :                         } else {

	jmp	SHORT $LN73@PushInvoke
$LN82@PushInvoke:

; 2083 : 
; 2084 :                             if ( !(*r0flags & R0_X_CLEARED) ) {

	test	BYTE PTR [rdi], 4
	jne	SHORT $LN72@PushInvoke

; 2085 :                                 /* v2.11: extra check needed */
; 2086 :                                 if ( reg == T_AH || ( optype & OP_A ) )

	cmp	ebx, 5
	je	SHORT $LN70@PushInvoke
	bt	r14d, 9
	jae	SHORT $LN71@PushInvoke
$LN70@PushInvoke:

; 2087 :                                     EmitErr( REGISTER_VALUE_OVERWRITTEN_BY_INVOKE );

	mov	ecx, 165				; 000000a5H
	call	EmitErr
$LN71@PushInvoke:

; 2088 :                                 AddLineQueueX( " xor %r, %r", T_AX, T_AX );

	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG6805
	mov	r8d, edx
	call	AddLineQueueX
$LN72@PushInvoke:

; 2089 :                             }
; 2090 :                             AddLineQueueX( " push %r", T_AX );

	lea	rcx, OFFSET FLAT:$SG6806
	mov	edx, 9
	call	AddLineQueueX

; 2091 :                             *r0flags = R0_USED | R0_H_CLEARED | R0_X_CLEARED;

	mov	BYTE PTR [rdi], 7
$LN73@PushInvoke:

; 2092 :                         }
; 2093 :                     }
; 2094 : 
; 2095 :                     if ( asize == 1 ) {

	cmp	ebp, 1
	jne	$LN55@PushInvoke
	mov	eax, DWORD PTR ModuleInfo+392
$LN380@PushInvoke:

; 2096 :                         if ( ( reg >= T_AH && reg <= T_BH ) || psize != 1 ) {

	cmp	ebx, 5
	jl	SHORT $LN66@PushInvoke
	cmp	ebx, 8
	jle	SHORT $LN67@PushInvoke
$LN66@PushInvoke:
	cmp	esi, 1
	jne	SHORT $LN379@PushInvoke

; 2119 :                             /* convert 8-bit to 16/32-bit register name */
; 2120 :                             if ( (( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386) &&
; 2121 :                                 ( psize == 4 || pushsize == 4 ) ) {

	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	$LN57@PushInvoke
	cmp	r12d, 4
	jne	$LN57@PushInvoke

; 2122 :                                 reg = reg - T_AL + T_EAX;

	add	ebx, 16

; 2123 :                             } else

	jmp	$LN55@PushInvoke
$LN67@PushInvoke:

; 2097 :                             if ( psize != 1 && ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {

	cmp	esi, 1
	je	SHORT $LN65@PushInvoke
$LN379@PushInvoke:
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN65@PushInvoke

; 2098 :                                 /* v2.10: consider signed type coercion! */
; 2099 :                                 AddLineQueueX( " mov%sx %r, %s", IS_SIGNED( opnd.mem_type ) ? "s" : "z",
; 2100 :                                               regax[ModuleInfo.Ofssize], fullparam );

	movzx	ecx, BYTE PTR ModuleInfo+404
	mov	eax, DWORD PTR opnd$[rsp+64]
	lea	r8, OFFSET FLAT:$SG6812
	and	al, -64					; ffffffffffffffc0H
	lea	rdx, OFFSET FLAT:$SG6813
	lea	r9, QWORD PTR fullparam$[rsp]
	cmp	al, 64					; 00000040H
	cmove	rdx, r8
	mov	r8d, DWORD PTR regax[r13+rcx*4]
	lea	rcx, OFFSET FLAT:$SG6814
	call	AddLineQueueX

; 2101 :                                 *r0flags =  ( IS_SIGNED( opnd.mem_type ) ? R0_USED : R0_USED | R0_H_CLEARED );

	mov	edx, DWORD PTR opnd$[rsp+64]
	mov	eax, 3
	and	dl, -64					; ffffffffffffffc0H
	mov	ecx, 1
	cmp	dl, 64					; 00000040H
	cmove	eax, ecx
	mov	BYTE PTR [rdi], al

; 2115 :                                     }
; 2116 :                             }
; 2117 :                             reg = regax[ModuleInfo.Ofssize];

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	ebx, DWORD PTR regax[r13+rax*4]

; 2118 :                         } else {

	jmp	$LN55@PushInvoke
$LN65@PushInvoke:

; 2102 :                             } else {
; 2103 :                                 if ( reg != T_AL ) {

	cmp	ebx, 1
	je	SHORT $LN63@PushInvoke

; 2104 :                                     AddLineQueueX( " mov %r, %s", T_AL, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6817
	mov	edx, 1
	call	AddLineQueueX

; 2105 :                                     *r0flags |= R0_USED;
; 2106 :                                     *r0flags &= ~R0_X_CLEARED;

	movzx	edx, BYTE PTR [rdi]
	and	dl, 251					; 000000fbH
	or	dl, 1
	mov	BYTE PTR [rdi], dl
$LN63@PushInvoke:

; 2107 :                                 }
; 2108 :                                 if ( psize != 1 ) /* v2.11: don't modify AH if paramsize is 1 */

	cmp	esi, 1
	je	SHORT $LN59@PushInvoke

; 2109 :                                     if ( IS_SIGNED( opnd.mem_type ) ) {

	mov	eax, DWORD PTR opnd$[rsp+64]
	and	al, -64					; ffffffffffffffc0H
	cmp	al, 64					; 00000040H
	jne	SHORT $LN61@PushInvoke

; 2110 :                                         AddLineQueue( " cbw" );

	lea	rcx, OFFSET FLAT:$SG6820
	call	AddLineQueue

; 2111 :                                         *r0flags &= ~( R0_H_CLEARED | R0_X_CLEARED );

	and	BYTE PTR [rdi], 249			; 000000f9H

; 2115 :                                     }
; 2116 :                             }
; 2117 :                             reg = regax[ModuleInfo.Ofssize];

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	ebx, DWORD PTR regax[r13+rax*4]

; 2118 :                         } else {

	jmp	SHORT $LN55@PushInvoke
$LN61@PushInvoke:

; 2112 :                                     } else if (!( *r0flags & R0_H_CLEARED )) {

	test	BYTE PTR [rdi], 2
	jne	SHORT $LN59@PushInvoke

; 2113 :                                         AddLineQueueX( " mov %r, 0", T_AH );

	lea	rcx, OFFSET FLAT:$SG6823
	mov	edx, 5
	call	AddLineQueueX

; 2114 :                                         *r0flags |= R0_H_CLEARED;

	or	BYTE PTR [rdi], 2
$LN59@PushInvoke:

; 2115 :                                     }
; 2116 :                             }
; 2117 :                             reg = regax[ModuleInfo.Ofssize];

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	ebx, DWORD PTR regax[r13+rax*4]

; 2118 :                         } else {

	jmp	SHORT $LN55@PushInvoke
$LN57@PushInvoke:

; 2124 :                                 reg = reg - T_AL + T_AX;

	add	ebx, 8
$LN55@PushInvoke:

; 2125 :                         }
; 2126 :                     }
; 2127 : #if 0
; 2128 :                     if ( is_r0 && ( *r0flags & R0_USED ) ) {
; 2129 :                         EmitErr( REGISTER_VALUE_OVERWRITTEN_BY_INVOKE );
; 2130 :                         *r0flags = 0;
; 2131 :                     }
; 2132 : #endif
; 2133 :                 }
; 2134 :                 AddLineQueueX( " push %r", reg );

	lea	rcx, OFFSET FLAT:$SG6828
	mov	edx, ebx
	call	AddLineQueueX

; 2135 :                 /* v2.05: don't change psize if > pushsize */
; 2136 :                 if ( psize < pushsize )

	cmp	esi, r12d
	jge	$LN2@PushInvoke

; 2137 :                     /* v2.04: adjust psize ( for siz_vararg update ) */
; 2138 :                     psize = pushsize;

	mov	esi, r12d

; 2139 : 
; 2140 :             } else { /* constant value */

	jmp	$LN2@PushInvoke
$LN51@PushInvoke:

; 2146 :                     else if ( opnd.value64 <= 255 && opnd.value64 >= -255 )

	mov	rcx, QWORD PTR opnd$[rsp]
	lea	rax, QWORD PTR [rcx+255]
	cmp	rax, 510				; 000001feH
	ja	SHORT $LN49@PushInvoke

; 2147 :                         asize = 1;

	mov	eax, 1
	jmp	SHORT $LN44@PushInvoke
$LN49@PushInvoke:

; 2148 :                     else if ( opnd.value64 <= 65535 && opnd.value64 >= -65535 )

	lea	rax, QWORD PTR [rcx+65535]
	cmp	rax, 131070				; 0001fffeH
	ja	SHORT $LN47@PushInvoke

; 2149 :                         asize = 2;

	mov	eax, 2
	jmp	SHORT $LN44@PushInvoke
$LN47@PushInvoke:

; 2150 :                     else if ( opnd.value64 <= maxintvalues[0] && opnd.value64 >= minintvalues[0] )

	cmp	rcx, QWORD PTR maxintvalues
	jg	SHORT $LN45@PushInvoke
	cmp	rcx, QWORD PTR minintvalues
	jl	SHORT $LN45@PushInvoke

; 2151 :                         asize = 4;

	mov	eax, 4

; 2152 :                     else

	jmp	SHORT $LN44@PushInvoke
$LN45@PushInvoke:

; 2153 :                         asize = 8;

	mov	eax, 8
$LN44@PushInvoke:

; 2154 :                     if ( psize < asize )

	cmp	esi, eax
	jge	SHORT $LN43@PushInvoke

; 2155 :                         EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam+1 );

	lea	edx, DWORD PTR [r8+1]
	mov	ecx, 145				; 00000091H
	call	EmitErr
	mov	edx, DWORD PTR opnd$[rsp+60]
$LN43@PushInvoke:

; 2156 :                 }
; 2157 : 
; 2158 :                 /* v2.11: don't use CurrWordSize */
; 2159 :                 //asize = CurrWordSize;
; 2160 :                 asize = 2 << Ofssize;
; 2161 : 
; 2162 :                 if ( psize < asize )  /* ensure that the default argsize (2,4,8) is met */

	cmp	esi, r15d
	mov	ecx, DWORD PTR opnd$[rsp]
	jge	SHORT $LN37@PushInvoke

; 2163 :                     if ( psize == 0 && curr->sym.is_vararg ) {

	test	esi, esi
	jne	SHORT $LN41@PushInvoke
	mov	rax, QWORD PTR curr$[rsp]
	test	BYTE PTR [rax+55], 32			; 00000020H
	je	SHORT $LN41@PushInvoke

; 2164 :                         /* v2.04: push a dword constant in 16-bit */
; 2165 :                         if ( asize == 2 &&
; 2166 :                             ( opnd.value > 0xFFFFL || opnd.value < -65535L ) )

	cmp	r15d, 2
	jne	SHORT $LN40@PushInvoke
	cmp	ecx, 65535				; 0000ffffH
	jg	SHORT $LN39@PushInvoke
	cmp	ecx, -65535				; ffffffffffff0001H
	jge	SHORT $LN40@PushInvoke
$LN39@PushInvoke:

; 2167 :                             psize = 4;

	mov	esi, 4

; 2168 :                         else

	jmp	SHORT $LN37@PushInvoke
$LN40@PushInvoke:

; 2169 :                             psize = asize;

	mov	esi, r15d

; 2170 :                     } else

	jmp	SHORT $LN37@PushInvoke
$LN41@PushInvoke:

; 2171 :                         psize = asize;

	mov	esi, r15d
$LN37@PushInvoke:

; 2172 : 
; 2173 :                 if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) < P_186 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	mov	r8d, eax
	and	r8d, 240				; 000000f0H
	cmp	r8d, 16
	jge	$LN36@PushInvoke

; 2174 :                     *r0flags |= R0_USED;

	or	BYTE PTR [rdi], 1

; 2175 :                     switch ( psize ) {

	cmp	esi, 2
	je	$LN33@PushInvoke
	cmp	esi, 4
	je	SHORT $LN28@PushInvoke

; 2198 :                     default:
; 2199 :                         DebugMsg1(("PushInvokeParm(%u): error, CONST, asize=%u, psize=%u, pushsize=%u\n",
; 2200 :                                   reqParam, asize, psize, pushsize ));
; 2201 :                         EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam+1 );

	mov	edx, DWORD PTR reqParam$[rsp]
	mov	ecx, 145				; 00000091H
	inc	edx
	call	EmitErr
	jmp	$LN30@PushInvoke
$LN28@PushInvoke:

; 2184 :                         }
; 2185 :                         break;
; 2186 :                     case 4:
; 2187 :                         if ( opnd.uvalue <= 0xFFFF )

	cmp	ecx, 65535				; 0000ffffH
	ja	SHORT $LN27@PushInvoke

; 2188 :                             AddLineQueueX( " xor %r, %r", T_AX, T_AX );

	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG6861
	mov	r8d, edx
	call	AddLineQueueX

; 2189 :                         else

	jmp	SHORT $LN26@PushInvoke
$LN27@PushInvoke:

; 2190 :                             AddLineQueueX( " mov %r, %r (%s)", T_AX, T_HIGHWORD, fullparam );

	lea	r9, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6863
	mov	edx, 9
	mov	r8d, 232				; 000000e8H
	call	AddLineQueueX
$LN26@PushInvoke:

; 2191 :                         AddLineQueueX( " push %r", T_AX );

	lea	rcx, OFFSET FLAT:$SG6864
	mov	edx, 9
	call	AddLineQueueX

; 2192 :                         if ( opnd.uvalue != 0 || opnd.kind == EXPR_ADDR ) {

	cmp	DWORD PTR opnd$[rsp], 0
	jne	SHORT $LN24@PushInvoke
	cmp	DWORD PTR opnd$[rsp+60], 1
	je	SHORT $LN24@PushInvoke

; 2194 :                         } else {
; 2195 :                             *r0flags |= R0_H_CLEARED | R0_X_CLEARED;

	or	BYTE PTR [rdi], 6
	jmp	SHORT $LN30@PushInvoke
$LN24@PushInvoke:

; 2193 :                             AddLineQueueX( " mov %r, %r (%s)", T_AX, T_LOWWORD, fullparam );

	lea	r9, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6867
	mov	edx, 9
	mov	r8d, 238				; 000000eeH
	call	AddLineQueueX

; 2196 :                         }
; 2197 :                         break;

	jmp	SHORT $LN30@PushInvoke
$LN33@PushInvoke:

; 2176 :                     case 2:
; 2177 :                         if ( opnd.value != 0 || opnd.kind == EXPR_ADDR ) {

	test	ecx, ecx
	jne	SHORT $LN31@PushInvoke
	cmp	edx, 1
	je	SHORT $LN31@PushInvoke

; 2179 :                         } else {
; 2180 :                             if ( !(*r0flags & R0_X_CLEARED ) ) {

	test	BYTE PTR [rdi], 4
	jne	SHORT $LN29@PushInvoke

; 2181 :                                 AddLineQueueX( " xor %r, %r", T_AX, T_AX );

	mov	edx, 9
	lea	rcx, OFFSET FLAT:$SG6858
	mov	r8d, edx
	call	AddLineQueueX
$LN29@PushInvoke:

; 2182 :                             }
; 2183 :                             *r0flags |= R0_H_CLEARED | R0_X_CLEARED;

	or	BYTE PTR [rdi], 6
	jmp	SHORT $LN30@PushInvoke
$LN31@PushInvoke:

; 2178 :                             AddLineQueueX( " mov %r, %s", T_AX, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6855
	mov	edx, 9
	call	AddLineQueueX
$LN30@PushInvoke:

; 2202 :                     }
; 2203 :                     AddLineQueueX( " push %r", T_AX );

	lea	rcx, OFFSET FLAT:$SG6870
	mov	edx, 9
	call	AddLineQueueX

; 2204 :                 } else { /* cpu >= 80186 */

	jmp	SHORT $LN2@PushInvoke
$LN36@PushInvoke:

; 2205 :                     char *instr = "";
; 2206 :                     char *suffix;
; 2207 :                     int qual = EMPTY;
; 2208 :                     //if ( asize != psize ) {
; 2209 :                     if ( psize != pushsize ) {

	cmp	esi, r12d
	lea	rdi, OFFSET FLAT:$SG6873
	je	SHORT $LN3@PushInvoke

; 2210 :                         switch ( psize ) {

	cmp	esi, 2
	je	$LN17@PushInvoke
	cmp	esi, 4
	je	$LN11@PushInvoke
	cmp	esi, 6
	je	$LN16@PushInvoke
	cmp	esi, 8
	jne	SHORT $LN6@PushInvoke

; 2233 :                         case 8:
; 2234 : #if AMD64_SUPPORT
; 2235 :                             if (( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_64 )

	cmp	r8d, 112				; 00000070H
	jge	SHORT $LN3@PushInvoke

; 2236 :                                 break;
; 2237 : #endif
; 2238 :                             /* v2.06: added support for double constants */
; 2239 :                             if ( opnd.kind == EXPR_CONST || opnd.kind == EXPR_FLOAT ) {

	test	edx, edx
	je	SHORT $LN5@PushInvoke
	cmp	edx, 3
	je	SHORT $LN5@PushInvoke
$LN6@PushInvoke:

; 2243 :                                 break;
; 2244 :                             }
; 2245 :                         default:
; 2246 :                             DebugMsg1(("PushInvokeParm(%u): error, CONST, asize=%u, psize=%u, pushsize=%u\n",
; 2247 :                                       reqParam, asize, psize, pushsize ));
; 2248 :                             EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam+1 );

	mov	edx, DWORD PTR reqParam$[rsp]
	mov	ecx, 145				; 00000091H
	inc	edx
	call	EmitErr
$LN3@PushInvoke:

; 2254 :                         AddLineQueueX( " push%s %s", instr, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6908
	mov	rdx, rdi
	call	AddLineQueueX
$LN2@PushInvoke:

; 2255 :                 }
; 2256 :             }
; 2257 :             if ( curr->sym.is_vararg ) {

	mov	rax, QWORD PTR curr$[rsp]
	test	BYTE PTR [rax+55], 32			; 00000020H
	je	$LN1@PushInvoke

; 2258 :                 size_vararg += psize;

	add	DWORD PTR size_vararg, esi

; 2259 :                 DebugMsg1(("PushInvokeParm(%u): psize=%u added to size_vararg, now=%u\n", reqParam, psize, size_vararg ));
; 2260 :             }
; 2261 :         }
; 2262 :     }
; 2263 :     return( NOT_ERROR );

	jmp	$LN1@PushInvoke
$LN5@PushInvoke:

; 2240 :                                 AddLineQueueX( " pushd %r (%s)", T_HIGH32, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6902
	mov	edx, 231				; 000000e7H
	call	AddLineQueueX

; 2241 :                                 qual = T_LOW32;

	mov	r8d, 237				; 000000edH

; 2242 :                                 instr = "d";

	lea	rdx, OFFSET FLAT:$SG6903
$LN387@PushInvoke:

; 2252 :                         AddLineQueueX( " push%s %r (%s)", instr, qual, fullparam );

	lea	r9, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6906
	call	AddLineQueueX

; 2253 :                     else

	jmp	SHORT $LN2@PushInvoke
$LN16@PushInvoke:

; 2213 :                             break;
; 2214 :                         case 6: /* v2.04: added */
; 2215 :                             /* v2.11: use pushw only for 16-bit target */
; 2216 :                             if ( Ofssize == USE16 )

	test	r14b, r14b
	jne	SHORT $LN15@PushInvoke

; 2217 :                                 suffix = "w";

	lea	rdx, OFFSET FLAT:$SG6885
	jmp	SHORT $LN12@PushInvoke
$LN15@PushInvoke:

; 2218 :                             else if ( Ofssize == USE32 && CurrWordSize == 2 )

	cmp	r14b, 1
	jne	SHORT $LN13@PushInvoke
	cmp	BYTE PTR ModuleInfo+406, 2
	jne	SHORT $LN13@PushInvoke

; 2219 :                                 suffix = "d";

	lea	rdx, OFFSET FLAT:$SG6888

; 2220 :                             else

	jmp	SHORT $LN12@PushInvoke
$LN13@PushInvoke:

; 2221 :                                 suffix = "";

	lea	rdx, OFFSET FLAT:$SG6890
$LN12@PushInvoke:

; 2222 :                             AddLineQueueX( " push%s (%s) shr 32t", suffix, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6891
	call	AddLineQueueX
	mov	eax, DWORD PTR ModuleInfo+392
$LN11@PushInvoke:

; 2223 :                             /* no break */
; 2224 :                         case 4:
; 2225 :                             if (( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 )

	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN10@PushInvoke

; 2226 :                                 instr = "d";

	lea	rdi, OFFSET FLAT:$SG6894

; 2227 :                             else {

	jmp	$LN3@PushInvoke
$LN10@PushInvoke:

; 2228 :                                 AddLineQueueX( " pushw %r (%s)", T_HIGHWORD, fullparam );

	lea	r8, QWORD PTR fullparam$[rsp]
	lea	rcx, OFFSET FLAT:$SG6896
	mov	edx, 232				; 000000e8H
	call	AddLineQueueX

; 2229 :                                 instr = "w";

	lea	rdx, OFFSET FLAT:$SG6897

; 2230 :                                 qual = T_LOWWORD;

	mov	r8d, 238				; 000000eeH

; 2231 :                             }
; 2232 :                             break;

	jmp	$LN387@PushInvoke
$LN17@PushInvoke:

; 2211 :                         case 2:
; 2212 :                             instr = "w";

	lea	rdi, OFFSET FLAT:$SG6882

; 2249 :                         }
; 2250 :                     }
; 2251 :                     if ( qual != EMPTY )

	jmp	$LN3@PushInvoke
$LN167@PushInvoke:

; 1792 :             DebugMsg(("PushInvokeParm(%u): argsize error, arg size=%d, parm size=%d\n", reqParam, asize, psize));
; 1793 :             EmitErr( INVOKE_ARGUMENT_TYPE_MISMATCH, reqParam+1 );

	lea	edx, DWORD PTR [r8+1]
$LN414@PushInvoke:
	mov	ecx, 145				; 00000091H
	call	EmitErr
$LN1@PushInvoke:

; 1794 :             return( NOT_ERROR );

	xor	eax, eax
$LN282@PushInvoke:
	mov	r15, QWORD PTR [rsp+264712]
	mov	r14, QWORD PTR [rsp+264720]
	mov	r13, QWORD PTR [rsp+264728]
	mov	r12, QWORD PTR [rsp+264736]
	mov	rdi, QWORD PTR [rsp+264744]
	mov	rsi, QWORD PTR [rsp+264752]
	mov	rbp, QWORD PTR [rsp+264760]
	mov	rbx, QWORD PTR [rsp+264768]

; 2264 : }

	add	rsp, 264776				; 00040a48H
	ret	0
PushInvokeParam ENDP
_TEXT	ENDS
PUBLIC	InvokeDirective
EXTRN	RunLineQueue:NEAR
EXTRN	LstWrite:NEAR
EXTRN	GetCurrOffset:NEAR
EXTRN	Mangle:NEAR
EXTRN	EmitWarn:NEAR
EXTRN	Parse_Pass:DWORD
EXTRN	GetStdAssume:NEAR
xdata	SEGMENT
$unwind$InvokeDirective DD 0a1a01H
	DD	017f41aH
	DD	019d416H
	DD	01b7412H
	DD	020340eH
	DD	01d010aH
xdata	ENDS
pdata	SEGMENT
$pdata$InvokeDirective DD @imagerel($LN137#)
	DD	@imagerel($LN137#+419)
	DD	@imagerel($unwind$InvokeDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$7$InvokeDirective DD 08fb21H
	DD	02154fbH
	DD	01ac454H
	DD	018e410H
	DD	01c6408H
	DD	@imagerel($LN137#)
	DD	@imagerel($LN137#+419)
	DD	@imagerel($unwind$InvokeDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$InvokeDirective DD @imagerel($LN137#+419)
	DD	@imagerel($LN137#+754)
	DD	@imagerel($chain$7$InvokeDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$8$InvokeDirective DD 021H
	DD	@imagerel($LN137#)
	DD	@imagerel($LN137#+419)
	DD	@imagerel($unwind$InvokeDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$InvokeDirective DD @imagerel($LN137#+754)
	DD	@imagerel($LN137#+794)
	DD	@imagerel($chain$8$InvokeDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$9$InvokeDirective DD 080021H
	DD	018e400H
	DD	01ac400H
	DD	01c6400H
	DD	0215400H
	DD	@imagerel($LN137#)
	DD	@imagerel($LN137#+419)
	DD	@imagerel($unwind$InvokeDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$InvokeDirective DD @imagerel($LN137#+794)
	DD	@imagerel($LN137#+2264)
	DD	@imagerel($chain$9$InvokeDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$10$InvokeDirective DD 021H
	DD	@imagerel($LN137#)
	DD	@imagerel($LN137#+419)
	DD	@imagerel($unwind$InvokeDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$10$InvokeDirective DD @imagerel($LN137#+2264)
	DD	@imagerel($LN137#+2279)
	DD	@imagerel($chain$10$InvokeDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
value$ = 48
parmpos$1$ = 52
opnd$ = 64
porder$ = 240
i$ = 240
r0flags$ = 248
tokenarray$ = 248
InvokeDirective PROC NEAR

; 2270 : {

$LN137:
	mov	rax, rsp
	sub	rsp, 232				; 000000e8H
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax-16], rdi
	mov	QWORD PTR [rax-32], r13
	mov	QWORD PTR [rax-48], r15

; 2271 :     struct asym    *sym;
; 2272 :     struct dsym    *proc;
; 2273 :     char           *p;
; 2274 :     //char         *param;
; 2275 :     int            numParam;
; 2276 :     int            value;
; 2277 :     int            size;
; 2278 :     int            parmpos;
; 2279 :     int            namepos;
; 2280 :     int            porder;
; 2281 :     int            j;
; 2282 :     uint_8         r0flags = 0;
; 2283 :     //bool           uselabel = FALSE;
; 2284 :     struct proc_info *info;
; 2285 :     struct dsym    *curr;
; 2286 :     struct expr    opnd;
; 2287 :     //char           buffer[MAX_LINE_LEN];
; 2288 : 
; 2289 :     DebugMsg1(("InvokeDir(%s) enter\n", tokenarray[i].tokpos ));
; 2290 :     i++; /* skip INVOKE directive */

	lea	r15d, DWORD PTR [rcx+1]
	mov	BYTE PTR [rax+16], 0

; 2291 :     namepos = i;
; 2292 :     /* if there is more than just an ID item describing the invoke target,
; 2293 :      use the expression evaluator to get it
; 2294 :      */
; 2295 :     if ( tokenarray[i].token != T_ID || ( tokenarray[i+1].token != T_COMMA && tokenarray[i+1].token != T_FINAL ) ) {

	movsxd	rcx, r15d
	mov	DWORD PTR [rax+8], r15d
	mov	r13, rdx
	shl	rcx, 5
	lea	rdi, OFFSET FLAT:__ImageBase
	cmp	BYTE PTR [rcx+rdx], 8
	jne	SHORT $LN92@InvokeDire
	movzx	eax, BYTE PTR [rcx+rdx+32]
	cmp	al, 44					; 0000002cH
	je	SHORT $LN93@InvokeDire
	test	al, al
	jne	SHORT $LN92@InvokeDire
$LN93@InvokeDire:

; 2329 : 
; 2330 :     } else {
; 2331 :         opnd.base_reg = NULL;

	mov	QWORD PTR opnd$[rsp+24], 0

; 2332 :         sym = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rcx+rdx+8]
	call	SymFind

; 2333 :         i++;

	inc	DWORD PTR i$[rsp]
	mov	rbx, rax
	jmp	$LN84@InvokeDire
$LN92@InvokeDire:

; 2296 :     //if ( tokenarray[i+1].token != T_COMMA && tokenarray[i+1].token != T_FINAL ) {
; 2297 :         if ( ERROR == EvalOperand( &i, tokenarray, Token_Count, &opnd, 0 ) )

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opnd$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	BYTE PTR [rsp+32], 0
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN91@InvokeDire

; 2298 :             return( ERROR );

	jmp	$LN94@InvokeDire
$LN91@InvokeDire:

; 2299 :         DebugMsg1(("InvokeDir: target is expression, kind=%u sym=%s mbr=%s type=%s memtype=%X ofssize=%u\n",
; 2300 :                    opnd.kind,
; 2301 :                    opnd.sym ? opnd.sym->name : "NULL",
; 2302 :                    opnd.mbr ? opnd.mbr->name : "NULL",
; 2303 :                    opnd.type ? opnd.type->name : "NULL",
; 2304 :                    opnd.mem_type, opnd.Ofssize ));
; 2305 : #if 1
; 2306 :         /* a typecast with PTR? Since v1.95, this has highest priority */
; 2307 :         //if (opnd.explicit == TRUE && opnd.type != NULL && opnd.type->state == SYM_TYPE ) {
; 2308 :         /* v1.96: removed opnd.explicit!!! */
; 2309 :         /* fixme: if opnd.type is set, opnd.type MUST have state SYM_TYPE */
; 2310 :         if ( opnd.type != NULL && opnd.type->state == SYM_TYPE ) {

	mov	rax, QWORD PTR opnd$[rsp+96]
	test	rax, rax
	je	SHORT $LN88@InvokeDire
	cmp	DWORD PTR [rax+40], 7
	jne	SHORT $LN88@InvokeDire

; 2311 :             sym = opnd.type;
; 2312 :             DebugMsg1(("InvokeDirective: opnd.type=>%s< mem_type=%Xh\n", sym->name, sym->mem_type ));
; 2313 :             proc = (struct dsym *)sym;
; 2314 :             //if ( opnd.label_tok != NULL ) /* v2.09: uselabel obsolete */
; 2315 :             //    uselabel = TRUE;
; 2316 :             if ( sym->mem_type == MT_PROC ) /* added for v1.95 */

	mov	ecx, DWORD PTR [rax+44]
	cmp	ecx, 128				; 00000080H
	je	$isfnproto$6937

; 2317 :                 goto isfnproto;
; 2318 :             if ( sym->mem_type == MT_PTR )  /* v2.09: mem_type must be MT_PTR */

	cmp	ecx, 195				; 000000c3H
	je	$isfnptr$6939
$LN88@InvokeDire:

; 2319 :                 goto isfnptr;
; 2320 :         }
; 2321 : #endif
; 2322 :         if ( opnd.kind == EXPR_REG ) {

	cmp	DWORD PTR opnd$[rsp+60], 2
	jne	SHORT $LN87@InvokeDire

; 2323 :             if ( GetValueSp( opnd.base_reg->tokval ) & OP_RGT8 )

	mov	rax, QWORD PTR opnd$[rsp+24]
	mov	ecx, DWORD PTR [rax+16]
	lea	rax, QWORD PTR [rcx+rcx*2]
	test	BYTE PTR SpecialTable[rdi+rax*4], 14
	je	$LN75@InvokeDire

; 2324 :                 sym = GetStdAssume( GetRegNo( opnd.base_reg->tokval ) );

	movzx	ecx, BYTE PTR SpecialTable[rdi+rax*4+10]
	call	GetStdAssume
	mov	rbx, rax

; 2325 :             else

	jmp	SHORT $LN84@InvokeDire
$LN87@InvokeDire:

; 2326 :                 sym = NULL;
; 2327 :         } else
; 2328 :             sym = ( opnd.mbr ? opnd.mbr : opnd.sym );

	mov	rax, QWORD PTR opnd$[rsp+88]
	mov	rbx, QWORD PTR opnd$[rsp+80]
	test	rax, rax
	cmovne	rbx, rax
$LN84@InvokeDire:

; 2334 :     }
; 2335 : 
; 2336 :     if( sym == NULL ) {

	test	rbx, rbx

; 2337 :         /* v2.04: msg changed */
; 2338 :         return( EmitErr( INVOKE_REQUIRES_PROTOTYPE ) );

	je	$LN75@InvokeDire

; 2339 :         //return( EmitErr( SYMBOL_NOT_DEFINED, name ) );
; 2340 :     }
; 2341 :     if( sym->isproc )  /* the most simple case: symbol is a PROC */

	test	BYTE PTR [rbx+49], 8
	jne	$LN71@InvokeDire

; 2342 :         ;
; 2343 :     else if ( sym->mem_type == MT_PTR && sym->target_type && sym->target_type->isproc )

	mov	ecx, DWORD PTR [rbx+44]
	cmp	ecx, 195				; 000000c3H
	jne	SHORT $LN79@InvokeDire
	mov	rax, QWORD PTR [rbx+56]
	test	rax, rax
	je	SHORT $LN79@InvokeDire
	test	BYTE PTR [rax+49], 8
	je	SHORT $LN79@InvokeDire

; 2344 :         sym = sym->target_type;

	mov	rbx, rax
	jmp	SHORT $LN71@InvokeDire
$LN79@InvokeDire:

; 2345 :     else if ( sym->mem_type == MT_PTR && sym->target_type && sym->target_type->mem_type == MT_PROC ) {

	cmp	ecx, 195				; 000000c3H
	jne	SHORT $LN77@InvokeDire
	mov	rax, QWORD PTR [rbx+56]
	test	rax, rax
	je	SHORT $LN77@InvokeDire
	cmp	DWORD PTR [rax+44], 128			; 00000080H
	je	SHORT $isfnproto$6937
$LN77@InvokeDire:

; 2346 :         proc = (struct dsym *)sym->target_type;
; 2347 :         goto isfnproto;
; 2348 :     } else if ( ( sym->mem_type == MT_TYPE ) && ( sym->type->mem_type == MT_PTR || sym->type->mem_type == MT_PROC ) ) {

	cmp	ecx, 196				; 000000c4H
	jne	$LN75@InvokeDire
	mov	rax, QWORD PTR [rbx+88]
	mov	ecx, DWORD PTR [rax+44]
	cmp	ecx, 195				; 000000c3H
	je	SHORT $LN74@InvokeDire
	cmp	ecx, 128				; 00000080H
	jne	$LN75@InvokeDire
$LN74@InvokeDire:

; 2349 :         /* second case: symbol is a (function?) pointer */
; 2350 :         proc = (struct dsym *)sym->type;
; 2351 :         if ( proc->sym.mem_type != MT_PROC )

	cmp	ecx, 128				; 00000080H
	jne	SHORT $isfnptr$6939
$isfnproto$6937:

; 2352 :             goto isfnptr;
; 2353 :     isfnproto:
; 2354 :         /* pointer target must be a PROTO typedef */
; 2355 :         if ( proc->sym.mem_type != MT_PROC ) {

	cmp	DWORD PTR [rax+44], 128			; 00000080H

; 2356 :             DebugMsg(("InvokeDir: error proc.name=>%s< .mem_type=%Xh\n", proc->sym.name, proc->sym.mem_type ));
; 2357 :             DebugMsg(("InvokeDir: error sym.name=%s\n", sym ? sym->name : "" ));
; 2358 :             return( EmitErr( INVOKE_REQUIRES_PROTOTYPE ) );

	jne	$LN75@InvokeDire
$isfnptr$6939:

; 2359 :         }
; 2360 :     isfnptr:
; 2361 :         /* get the pointer target */
; 2362 :         sym = proc->sym.target_type;

	mov	rbx, QWORD PTR [rax+56]

; 2363 :         DebugMsg1(("InvokeDir: proc=%s target_type=>%s<\n", proc->sym.name, sym ? sym->name : "NULL" ));
; 2364 :         if ( sym == NULL ) {

	test	rbx, rbx

; 2365 :             return( EmitErr( INVOKE_REQUIRES_PROTOTYPE ) );

	je	$LN75@InvokeDire
$LN71@InvokeDire:

; 2381 :     }
; 2382 :     proc = (struct dsym *)sym;
; 2383 :     info = proc->e.procinfo;
; 2384 :     /* if (Parse_Pass == PASS_1) */
; 2385 :       memset(info->vregs, 0, 6); /* reset vregs EVERY pass */

	xor	eax, eax
	mov	QWORD PTR [rsp+224], rsi
	mov	QWORD PTR [rsp+192], r14
	mov	r14, QWORD PTR [rbx+104]

; 2386 :       /* clear sse register flags every pass*/
; 2387 :       memset(info->xyzused, 0, 6);
; 2388 :       memset(info->vecregsize, 0, 6);
; 2389 :       info->vsize = 0;
; 2390 :       //memset(regsize, 0, 6);
; 2391 :     
; 2392 : #if 0 /* v2.05: can't happen anymore */
; 2393 :     /* does FASTCALL variant support INVOKE? */
; 2394 :     if ( proc->sym.langtype == LANG_FASTCALL && fastcall_tab[ModuleInfo.fctype].invokestart == NULL ) {
; 2395 :         return( EmitError( FASTCALL_VARIANT_NOT_SUPPORTED ) );
; 2396 :     }
; 2397 : #endif
; 2398 : 
; 2399 :     /* get the number of parameters */
; 2400 :     for ( curr = info->paralist, numParam = 0 ; curr ; curr = curr->nextparam, numParam++ );

	xor	esi, esi
	mov	DWORD PTR [r14+68], eax
	mov	WORD PTR [r14+72], ax
	mov	DWORD PTR [r14+74], eax
	mov	WORD PTR [r14+78], ax
	mov	DWORD PTR [r14+62], eax
	mov	WORD PTR [r14+66], ax
	mov	DWORD PTR [r14+44], eax
	mov	rax, QWORD PTR [r14+8]
	test	rax, rax
	je	SHORT $LN67@InvokeDire
$LL69@InvokeDire:
	mov	rax, QWORD PTR [rax+120]
	inc	esi
	test	rax, rax
	jne	SHORT $LL69@InvokeDire
$LN67@InvokeDire:

; 2401 :     DebugMsg1(("InvokeDir: numparams=%u\n", numParam ));
; 2402 : 
; 2403 :     if ( proc->sym.langtype == LANG_FASTCALL ) {

	mov	eax, DWORD PTR [rbx+84]
	mov	QWORD PTR [rsp+208], r12
	cmp	eax, 7
	jne	SHORT $LN66@InvokeDire

; 2404 :         fcscratch = 0;
; 2405 :         porder = fastcall_tab[ModuleInfo.fctype].invokestart( proc, numParam, i, tokenarray, &value );

	movsxd	rax, DWORD PTR ModuleInfo+376
	mov	r8d, DWORD PTR i$[rsp]
	lea	rcx, QWORD PTR value$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	lea	rax, QWORD PTR [rax+rax*2]
	mov	r9, r13
	mov	edx, esi
	mov	rcx, rbx
	mov	DWORD PTR fcscratch, 0
	call	QWORD PTR fastcall_tab[rdi+rax*8]
	mov	r12d, eax
	jmp	SHORT $LN64@InvokeDire
$LN66@InvokeDire:

; 2406 :     }
; 2407 :     else if ( proc->sym.langtype == LANG_VECTORCALL ) {

	cmp	eax, 8
	jne	SHORT $LN121@InvokeDire

; 2408 :         fcscratch = 0;
; 2409 :         porder = vectorcall_tab[ModuleInfo.fctype].invokestart( proc, numParam, i, tokenarray, &value );

	movsxd	rax, DWORD PTR ModuleInfo+376
	mov	r8d, DWORD PTR i$[rsp]
	lea	rcx, QWORD PTR value$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	lea	rax, QWORD PTR [rax+rax*2]
	mov	r9, r13
	mov	edx, esi
	mov	rcx, rbx
	mov	DWORD PTR fcscratch, 0
	call	QWORD PTR vectorcall_tab[rdi+rax*8]
	mov	r12d, eax
	jmp	SHORT $LN64@InvokeDire
$LN121@InvokeDire:
	mov	r12d, DWORD PTR porder$[rsp]
$LN64@InvokeDire:

; 2410 :     }
; 2411 : 
; 2412 : 	/* -----------------------------------------------------------------------------------------------
; 2413 : 	 HANDLE PARAMETERS (FIRST PASS)
; 2414 : 	----------------------------------------------------------------------------------------------- */ 
; 2415 :     curr = info->paralist;
; 2416 :     parmpos = i;
; 2417 : 
; 2418 :     if ( !( info->has_vararg ) ) {

	test	BYTE PTR [r14+128], 1
	mov	ecx, DWORD PTR i$[rsp]
	mov	rdi, QWORD PTR [r14+8]
	mov	DWORD PTR parmpos$1$[rsp], ecx
	mov	QWORD PTR [rsp+264], rbp
	jne	SHORT $LN63@InvokeDire

; 2419 :         /* check if there is a superfluous parameter in the INVOKE call */
; 2420 :         if ( PushInvokeParam( i, tokenarray, proc, NULL, numParam, &r0flags ) != ERROR ) {

	lea	rax, QWORD PTR r0flags$[rsp]
	xor	r9d, r9d
	mov	r8, rbx
	mov	QWORD PTR [rsp+40], rax
	mov	rdx, r13
	mov	DWORD PTR [rsp+32], esi
	call	PushInvokeParam
	cmp	eax, -1
	je	$LN123@InvokeDire

; 2421 :             DebugMsg(("InvokeDir: superfluous argument, i=%u\n", i));
; 2422 :             return( EmitErr( TOO_MANY_ARGUMENTS_TO_INVOKE ) );

	mov	ecx, 177				; 000000b1H
	call	EmitErr
$LN136@InvokeDire:
	mov	rbp, QWORD PTR [rsp+264]
	mov	r12, QWORD PTR [rsp+208]
	mov	rsi, QWORD PTR [rsp+224]
	mov	r14, QWORD PTR [rsp+192]
$LN94@InvokeDire:
	mov	r15, QWORD PTR [rsp+184]
	mov	r13, QWORD PTR [rsp+200]
	mov	rdi, QWORD PTR [rsp+216]
	mov	rbx, QWORD PTR [rsp+256]

; 2585 : }

	add	rsp, 232				; 000000e8H
	ret	0
$LN63@InvokeDire:

; 2423 :         }
; 2424 :     } else {
; 2425 :         int j = (Token_Count - i) / 2;

	mov	eax, DWORD PTR ModuleInfo+496

; 2426 :         /* for VARARG procs, just push the additional params with
; 2427 :          the VARARG descriptor
; 2428 :         */
; 2429 :         numParam--;

	dec	esi

; 2430 :         size_vararg = 0; /* reset the VARARG parameter size count */

	mov	DWORD PTR size_vararg, 0
	sub	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2431 :         while ( curr && curr->sym.is_vararg == FALSE ) curr = curr->nextparam;

	test	rdi, rdi
	mov	ebp, eax
	je	SHORT $LN130@InvokeDire
	npad	6
$LL60@InvokeDire:
	test	BYTE PTR [rdi+55], 32			; 00000020H
	jne	SHORT $LN130@InvokeDire
	mov	rdi, QWORD PTR [rdi+120]
	test	rdi, rdi
	jne	SHORT $LL60@InvokeDire
$LN130@InvokeDire:

; 2432 :         DebugMsg1(("InvokeDir: VARARG proc, numparams=%u, actual (max) params=%u, parasize=%u\n", numParam, j, info->parasize));
; 2433 :         for ( ; j >= numParam; j-- )

	cmp	eax, esi
	jl	SHORT $LN56@InvokeDire
	jmp	SHORT $LN58@InvokeDire
	npad	11
$LL122@InvokeDire:
	mov	ecx, DWORD PTR i$[rsp]
$LN58@InvokeDire:

; 2434 :             PushInvokeParam( i, tokenarray, proc, curr, j, &r0flags );

	lea	rax, QWORD PTR r0flags$[rsp]
	mov	r9, rdi
	mov	r8, rbx
	mov	QWORD PTR [rsp+40], rax
	mov	rdx, r13
	mov	DWORD PTR [rsp+32], ebp
	call	PushInvokeParam
	dec	ebp
	cmp	ebp, esi
	jge	SHORT $LL122@InvokeDire

; 2432 :         DebugMsg1(("InvokeDir: VARARG proc, numparams=%u, actual (max) params=%u, parasize=%u\n", numParam, j, info->parasize));
; 2433 :         for ( ; j >= numParam; j-- )

	mov	ecx, DWORD PTR i$[rsp]
$LN56@InvokeDire:

; 2435 :         /* move to first non-vararg parameter, if any */
; 2436 :         for ( curr = info->paralist; curr && curr->sym.is_vararg == TRUE; curr = curr->nextparam );

	mov	rdi, QWORD PTR [r14+8]
	test	rdi, rdi
	je	SHORT $LN53@InvokeDire
	npad	4
$LL55@InvokeDire:
	test	BYTE PTR [rdi+55], 32			; 00000020H
	je	SHORT $LN53@InvokeDire
	mov	rdi, QWORD PTR [rdi+120]
	test	rdi, rdi
	jne	SHORT $LL55@InvokeDire
	jmp	SHORT $LN53@InvokeDire
$LN123@InvokeDire:
	mov	ecx, DWORD PTR i$[rsp]
$LN53@InvokeDire:

; 2437 :     }
; 2438 :     
; 2439 :     /* the parameters are usually stored in "push" order.
; 2440 :      * This if() must match the one in proc.c, ParseParams().
; 2441 :      */
; 2442 : 
; 2443 :     if ( sym->langtype == LANG_STDCALL ||
; 2444 :         sym->langtype == LANG_C ||
; 2445 :         ( sym->langtype == LANG_FASTCALL && porder ) || 
; 2446 :         (sym->langtype == LANG_VECTORCALL  && porder) ||
; 2447 :         sym->langtype == LANG_SYSCALL ) {

	mov	eax, DWORD PTR [rbx+84]
	cmp	eax, 3
	je	$LN51@InvokeDire
	cmp	eax, 1
	je	SHORT $LN51@InvokeDire
	cmp	eax, 7
	jne	SHORT $LN50@InvokeDire
	test	r12d, r12d
	jne	SHORT $LN51@InvokeDire
$LN50@InvokeDire:
	cmp	eax, 8
	jne	SHORT $LN49@InvokeDire
	test	r12d, r12d
	jne	SHORT $LN51@InvokeDire
$LN49@InvokeDire:
	cmp	eax, 2
	je	SHORT $LN51@InvokeDire

; 2453 :             }
; 2454 :         }
; 2455 :     } else {
; 2456 :         for ( numParam = 0 ; curr && curr->sym.is_vararg == FALSE; curr = curr->nextparam, numParam++ ) {

	xor	esi, esi
	test	rdi, rdi
	je	$LN46@InvokeDire
	jmp	SHORT $LN43@InvokeDire
	npad	1
$LL124@InvokeDire:
	mov	ecx, DWORD PTR i$[rsp]
$LN43@InvokeDire:
	test	BYTE PTR [rdi+55], 32			; 00000020H
	jne	$LN46@InvokeDire

; 2457 :             if ( PushInvokeParam( i, tokenarray, proc, curr, numParam, &r0flags ) == ERROR ) {

	lea	rax, QWORD PTR r0flags$[rsp]
	mov	r9, rdi
	mov	r8, rbx
	mov	QWORD PTR [rsp+40], rax
	mov	rdx, r13
	mov	DWORD PTR [rsp+32], esi
	call	PushInvokeParam
	cmp	eax, -1
	jne	SHORT $LN42@InvokeDire

; 2458 :                 DebugMsg(("InvokeDir: PushInvokeParam(curr=%u, i=%u, numParam=%u) failed\n", curr, i, numParam));
; 2459 :                 EmitErr( TOO_FEW_ARGUMENTS_TO_INVOKE, sym->name );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 146				; 00000092H
	call	EmitErr
$LN42@InvokeDire:
	mov	rdi, QWORD PTR [rdi+120]
	inc	esi
	test	rdi, rdi
	jne	SHORT $LL124@InvokeDire

; 2291 :     namepos = i;
; 2292 :     /* if there is more than just an ID item describing the invoke target,
; 2293 :      use the expression evaluator to get it
; 2294 :      */
; 2295 :     if ( tokenarray[i].token != T_ID || ( tokenarray[i+1].token != T_COMMA && tokenarray[i+1].token != T_FINAL ) ) {

	jmp	SHORT $LN46@InvokeDire
$LN51@InvokeDire:

; 2448 :         for ( ; curr ; curr = curr->nextparam ) {

	test	rdi, rdi
	je	SHORT $LN46@InvokeDire
	jmp	SHORT $LN48@InvokeDire
	npad	9
$LL125@InvokeDire:
	mov	ecx, DWORD PTR i$[rsp]
$LN48@InvokeDire:

; 2449 :             numParam--;
; 2450 :             if ( PushInvokeParam( i, tokenarray, proc, curr, numParam, &r0flags ) == ERROR ) {

	lea	rax, QWORD PTR r0flags$[rsp]
	dec	esi
	mov	r9, rdi
	mov	QWORD PTR [rsp+40], rax
	mov	r8, rbx
	mov	rdx, r13
	mov	DWORD PTR [rsp+32], esi
	call	PushInvokeParam
	cmp	eax, -1
	jne	SHORT $LN47@InvokeDire

; 2451 :                 DebugMsg(("InvokeDir: PushInvokeParam(curr=%u, i=%u, numParam=%u) failed\n", curr, i, numParam));
; 2452 :                 EmitErr( TOO_FEW_ARGUMENTS_TO_INVOKE, sym->name );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 146				; 00000092H
	call	EmitErr
$LN47@InvokeDire:
	mov	rdi, QWORD PTR [rdi+120]
	test	rdi, rdi
	jne	SHORT $LL125@InvokeDire
$LN46@InvokeDire:

; 2460 :             }
; 2461 :         }
; 2462 :     }
; 2463 : 
; 2464 : 	/* -----------------------------------------------------------------------------------------------
; 2465 : 	HANDLE PARAMETERS (SECOND PASS FOR VECTORCALL)
; 2466 : 	----------------------------------------------------------------------------------------------- */
; 2467 : 	if (sym->langtype == LANG_VECTORCALL)

	cmp	DWORD PTR [rbx+84], 8
	jne	$LN21@InvokeDire

; 2468 : 	{
; 2469 : 		vcallpass = 1;
; 2470 :     info->vsize = 0;
; 2471 : 		curr = info->paralist;

	mov	rdi, QWORD PTR [r14+8]
	xor	r8d, r8d

; 2472 : 		parmpos = i;
; 2473 : 
; 2474 : 		if (!(info->has_vararg)) {

	test	BYTE PTR [r14+128], 1
	mov	DWORD PTR [r14+44], r8d
	mov	ecx, DWORD PTR i$[rsp]
	mov	DWORD PTR vcallpass, 1
	mov	DWORD PTR parmpos$1$[rsp], ecx
	jne	SHORT $LN38@InvokeDire

; 2475 : 			/* check if there is a superfluous parameter in the INVOKE call */
; 2476 : 			if (PushInvokeParam(i, tokenarray, proc, NULL, numParam, &r0flags) != ERROR) {

	lea	rax, QWORD PTR r0flags$[rsp]
	xor	r9d, r9d
	mov	r8, rbx
	mov	QWORD PTR [rsp+40], rax
	mov	rdx, r13
	mov	DWORD PTR [rsp+32], esi
	call	PushInvokeParam
	cmp	eax, -1
	je	$LN127@InvokeDire

; 2477 : 				DebugMsg(("InvokeDir: superfluous argument, i=%u\n", i));
; 2478 : 				return(EmitErr(TOO_MANY_ARGUMENTS_TO_INVOKE));

	mov	ecx, 177				; 000000b1H
	call	EmitErr
	jmp	$LN136@InvokeDire
$LN38@InvokeDire:

; 2479 : 			}
; 2480 : 		}
; 2481 : 		else {
; 2482 : 			int j = (Token_Count - i) / 2;

	mov	eax, DWORD PTR ModuleInfo+496

; 2483 : 			/* for VARARG procs, just push the additional params with
; 2484 : 			the VARARG descriptor
; 2485 : 			*/
; 2486 : 			numParam--;

	dec	esi

; 2487 : 			size_vararg = 0; /* reset the VARARG parameter size count */

	mov	DWORD PTR size_vararg, r8d
	sub	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2488 : 			while (curr && curr->sym.is_vararg == FALSE) curr = curr->nextparam;

	test	rdi, rdi
	mov	ebp, eax
	je	SHORT $LN131@InvokeDire
	npad	4
$LL35@InvokeDire:
	test	BYTE PTR [rdi+55], 32			; 00000020H
	jne	SHORT $LN131@InvokeDire
	mov	rdi, QWORD PTR [rdi+120]
	test	rdi, rdi
	jne	SHORT $LL35@InvokeDire
$LN131@InvokeDire:

; 2489 : 			DebugMsg1(("InvokeDir: VARARG proc, numparams=%u, actual (max) params=%u, parasize=%u\n", numParam, j, info->parasize));
; 2490 : 			for (; j >= numParam; j--)

	cmp	eax, esi
	jl	SHORT $LN31@InvokeDire
	jmp	SHORT $LN33@InvokeDire
	npad	11
$LL126@InvokeDire:
	mov	ecx, DWORD PTR i$[rsp]
$LN33@InvokeDire:

; 2491 : 				PushInvokeParam(i, tokenarray, proc, curr, j, &r0flags);

	lea	rax, QWORD PTR r0flags$[rsp]
	mov	r9, rdi
	mov	r8, rbx
	mov	QWORD PTR [rsp+40], rax
	mov	rdx, r13
	mov	DWORD PTR [rsp+32], ebp
	call	PushInvokeParam
	dec	ebp
	cmp	ebp, esi
	jge	SHORT $LL126@InvokeDire

; 2489 : 			DebugMsg1(("InvokeDir: VARARG proc, numparams=%u, actual (max) params=%u, parasize=%u\n", numParam, j, info->parasize));
; 2490 : 			for (; j >= numParam; j--)

	mov	ecx, DWORD PTR i$[rsp]
$LN31@InvokeDire:

; 2492 : 			/* move to first non-vararg parameter, if any */
; 2493 : 			for (curr = info->paralist; curr && curr->sym.is_vararg == TRUE; curr = curr->nextparam);

	mov	rdi, QWORD PTR [r14+8]
	test	rdi, rdi
	je	SHORT $LN28@InvokeDire
	npad	4
$LL30@InvokeDire:
	test	BYTE PTR [rdi+55], 32			; 00000020H
	je	SHORT $LN28@InvokeDire
	mov	rdi, QWORD PTR [rdi+120]
	test	rdi, rdi
	jne	SHORT $LL30@InvokeDire
	jmp	SHORT $LN28@InvokeDire
$LN127@InvokeDire:
	mov	ecx, DWORD PTR i$[rsp]
$LN28@InvokeDire:

; 2494 : 		}
; 2495 : 
; 2496 : 		/* the parameters are usually stored in "push" order.
; 2497 : 		* This if() must match the one in proc.c, ParseParams().
; 2498 : 		*/
; 2499 : 
; 2500 : 		if (sym->langtype == LANG_STDCALL ||
; 2501 : 			sym->langtype == LANG_C ||
; 2502 : 			(sym->langtype == LANG_FASTCALL && porder) ||
; 2503 : 			(sym->langtype == LANG_VECTORCALL  && porder) ||
; 2504 : 			sym->langtype == LANG_SYSCALL) {

	mov	eax, DWORD PTR [rbx+84]
	cmp	eax, 3
	je	$LN26@InvokeDire
	cmp	eax, 1
	je	SHORT $LN26@InvokeDire
	cmp	eax, 7
	jne	SHORT $LN25@InvokeDire
	test	r12d, r12d
	jne	SHORT $LN26@InvokeDire
$LN25@InvokeDire:
	cmp	eax, 8
	jne	SHORT $LN24@InvokeDire
	test	r12d, r12d
	jne	SHORT $LN26@InvokeDire
$LN24@InvokeDire:
	cmp	eax, 2
	je	SHORT $LN26@InvokeDire

; 2510 : 				}
; 2511 : 			}
; 2512 : 		}
; 2513 : 		else {
; 2514 : 			for (numParam = 0; curr && curr->sym.is_vararg == FALSE; curr = curr->nextparam, numParam++) {

	xor	esi, esi
	test	rdi, rdi
	je	$LN21@InvokeDire
	jmp	SHORT $LN18@InvokeDire
	npad	1
$LL128@InvokeDire:
	mov	ecx, DWORD PTR i$[rsp]
$LN18@InvokeDire:
	test	BYTE PTR [rdi+55], 32			; 00000020H
	jne	$LN21@InvokeDire

; 2515 : 				if (PushInvokeParam(i, tokenarray, proc, curr, numParam, &r0flags) == ERROR) {

	lea	rax, QWORD PTR r0flags$[rsp]
	mov	r9, rdi
	mov	r8, rbx
	mov	QWORD PTR [rsp+40], rax
	mov	rdx, r13
	mov	DWORD PTR [rsp+32], esi
	call	PushInvokeParam
	cmp	eax, -1
	jne	SHORT $LN17@InvokeDire

; 2516 : 					DebugMsg(("InvokeDir: PushInvokeParam(curr=%u, i=%u, numParam=%u) failed\n", curr, i, numParam));
; 2517 : 					EmitErr(TOO_FEW_ARGUMENTS_TO_INVOKE, sym->name);

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 146				; 00000092H
	call	EmitErr
$LN17@InvokeDire:
	mov	rdi, QWORD PTR [rdi+120]
	inc	esi
	test	rdi, rdi
	jne	SHORT $LL128@InvokeDire

; 2291 :     namepos = i;
; 2292 :     /* if there is more than just an ID item describing the invoke target,
; 2293 :      use the expression evaluator to get it
; 2294 :      */
; 2295 :     if ( tokenarray[i].token != T_ID || ( tokenarray[i+1].token != T_COMMA && tokenarray[i+1].token != T_FINAL ) ) {

	jmp	SHORT $LN21@InvokeDire
$LN26@InvokeDire:

; 2505 : 			for (; curr; curr = curr->nextparam) {

	test	rdi, rdi
	je	SHORT $LN21@InvokeDire
	jmp	SHORT $LN23@InvokeDire
	npad	9
$LL129@InvokeDire:
	mov	ecx, DWORD PTR i$[rsp]
$LN23@InvokeDire:

; 2506 : 				numParam--;
; 2507 : 				if (PushInvokeParam(i, tokenarray, proc, curr, numParam, &r0flags) == ERROR) {

	lea	rax, QWORD PTR r0flags$[rsp]
	dec	esi
	mov	r9, rdi
	mov	QWORD PTR [rsp+40], rax
	mov	r8, rbx
	mov	rdx, r13
	mov	DWORD PTR [rsp+32], esi
	call	PushInvokeParam
	cmp	eax, -1
	jne	SHORT $LN22@InvokeDire

; 2508 : 					DebugMsg(("InvokeDir: PushInvokeParam(curr=%u, i=%u, numParam=%u) failed\n", curr, i, numParam));
; 2509 : 					EmitErr(TOO_FEW_ARGUMENTS_TO_INVOKE, sym->name);

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 146				; 00000092H
	call	EmitErr
$LN22@InvokeDire:
	mov	rdi, QWORD PTR [rdi+120]
	test	rdi, rdi
	jne	SHORT $LL129@InvokeDire
$LN21@InvokeDire:

; 2518 : 				}
; 2519 : 			}
; 2520 : 		}
; 2521 : 	}
; 2522 : 	vcallpass = 0;
; 2523 : 
; 2524 : #if 1
; 2525 :     /* v2.05 added. A warning only, because Masm accepts this. */
; 2526 :     if ( opnd.base_reg != NULL &&
; 2527 :         Parse_Pass == PASS_1 &&
; 2528 :         (r0flags & R0_USED ) &&
; 2529 :         opnd.base_reg->bytval == 0 )

	mov	rax, QWORD PTR opnd$[rsp+24]
	mov	DWORD PTR vcallpass, 0
	test	rax, rax
	je	SHORT $LN14@InvokeDire
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN14@InvokeDire
	test	BYTE PTR r0flags$[rsp], 1
	je	SHORT $LN14@InvokeDire
	cmp	BYTE PTR [rax+1], 0
	jne	SHORT $LN14@InvokeDire

; 2530 :         EmitWarn( 2, REGISTER_VALUE_OVERWRITTEN_BY_INVOKE );

	mov	edx, 165				; 000000a5H
	mov	ecx, 2
	call	EmitWarn
$LN14@InvokeDire:

; 2531 : #endif
; 2532 :     p = StringBufferEnd;

	mov	rbp, QWORD PTR ModuleInfo+488

; 2533 :     strcpy( p, " call " );

	lea	r12, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $SG7028[r12]

; 2534 :     p += 6;

	add	rbp, 6
	mov	DWORD PTR [rbp-6], eax
	movzx	eax, WORD PTR $SG7028[r12+4]
	mov	WORD PTR [rbp-2], ax
	movzx	eax, BYTE PTR $SG7028[r12+6]
	mov	BYTE PTR [rbp], al

; 2535 :     /* v2.09: 'uselabel' obsolete */
; 2536 :     //if ( uselabel ) {
; 2537 :     //    DebugMsg1(("InvokeDir: opnd.label_tok is used: %s\n", opnd.label_tok->string_ptr ));
; 2538 :     //    strcpy( p, opnd.label_tok->string_ptr );
; 2539 :     //} else {
; 2540 : #if DLLIMPORT
; 2541 :         if ( sym->state == SYM_EXTERNAL && sym->dll ) {

	cmp	DWORD PTR [rbx+40], 2
	jne	$LN10@InvokeDire
	cmp	QWORD PTR [rbx+64], 0
	je	$LN10@InvokeDire

; 2542 :             char *iatname = p;
; 2543 :             strcpy( p, ModuleInfo.g.imp_prefix );

	mov	rcx, QWORD PTR ModuleInfo+88
	mov	r12, rbp
	mov	rdx, rbp
	npad	8
$LL96@InvokeDire:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL96@InvokeDire

; 2544 :             p += strlen( p );

	xor	eax, eax
	mov	rdi, rbp
	mov	rcx, -1
	repne scasb
	not	rcx
	dec	rcx
	add	rbp, rcx

; 2545 :             p += Mangle( sym, p );

	mov	rcx, rbx
	mov	rdx, rbp
	call	Mangle

; 2546 :             namepos++;

	inc	r15d
	movsxd	rcx, eax

; 2547 :             if ( sym->iat_used == FALSE ) {

	movzx	eax, BYTE PTR [rbx+48]
	add	rbp, rcx
	test	al, 8
	jne	SHORT $LN132@InvokeDire

; 2548 :                 sym->iat_used = TRUE;

	or	al, 8
	mov	BYTE PTR [rbx+48], al

; 2549 :                 sym->dll->cnt++;

	mov	rax, QWORD PTR [rbx+64]
	inc	DWORD PTR [rax+8]

; 2550 :                 if ( sym->langtype != LANG_NONE && sym->langtype != ModuleInfo.langtype )

	mov	edx, DWORD PTR [rbx+84]
	test	edx, edx
	je	SHORT $LN11@InvokeDire
	cmp	edx, DWORD PTR ModuleInfo+364
	je	SHORT $LN11@InvokeDire

; 2551 :                     AddLineQueueX( " externdef %r %s: %r %r", sym->langtype + T_C - 1, iatname, T_PTR, T_PROC );

	lea	rcx, OFFSET FLAT:$SG7033
	add	edx, 263				; 00000107H
	mov	r9d, 258				; 00000102H
	mov	r8, r12
	mov	DWORD PTR [rsp+32], 433			; 000001b1H
	call	AddLineQueueX

; 2552 :                 else

	lea	r12, OFFSET FLAT:__ImageBase
	jmp	SHORT $LN10@InvokeDire
$LN11@InvokeDire:

; 2553 :                     AddLineQueueX( " externdef %s: %r %r", iatname, T_PTR, T_PROC );

	lea	rcx, OFFSET FLAT:$SG7035
	mov	r9d, 433				; 000001b1H
	mov	r8d, 258				; 00000102H
	mov	rdx, r12
	call	AddLineQueueX
	lea	r12, OFFSET FLAT:__ImageBase
	jmp	SHORT $LN10@InvokeDire
$LN132@InvokeDire:

; 2518 : 				}
; 2519 : 			}
; 2520 : 		}
; 2521 : 	}
; 2522 : 	vcallpass = 0;
; 2523 : 
; 2524 : #if 1
; 2525 :     /* v2.05 added. A warning only, because Masm accepts this. */
; 2526 :     if ( opnd.base_reg != NULL &&
; 2527 :         Parse_Pass == PASS_1 &&
; 2528 :         (r0flags & R0_USED ) &&
; 2529 :         opnd.base_reg->bytval == 0 )

	lea	r12, OFFSET FLAT:__ImageBase
$LN10@InvokeDire:

; 2554 :             }
; 2555 :         }
; 2556 : #endif
; 2557 :         size = tokenarray[parmpos].tokpos - tokenarray[namepos].tokpos;

	movsxd	rax, DWORD PTR parmpos$1$[rsp]
	movsxd	rdx, r15d
	shl	rdx, 5
	shl	rax, 5
	mov	ecx, DWORD PTR [rax+r13+24]
	sub	ecx, DWORD PTR [rdx+r13+24]

; 2558 :         memcpy( p, tokenarray[namepos].tokpos, size );

	mov	rdx, QWORD PTR [rdx+r13+24]
	movsxd	rdi, ecx
	mov	rcx, rbp
	mov	r8, rdi
	call	memcpy

; 2559 :         *(p+size) = NULLC;

	mov	BYTE PTR [rdi+rbp], 0

; 2560 : #if 0  /* v2.09: uselabel obsolete */
; 2561 :     }
; 2562 : #endif
; 2563 :     AddLineQueue( StringBufferEnd );

	mov	rcx, QWORD PTR ModuleInfo+488
	call	AddLineQueue

; 2564 : 
; 2565 :     if (( sym->langtype == LANG_C || sym->langtype == LANG_SYSCALL ) &&
; 2566 :         ( info->parasize || ( info->has_vararg && size_vararg ) )) {

	mov	edx, DWORD PTR [rbx+84]
	cmp	edx, 1
	je	SHORT $LN8@InvokeDire
	cmp	edx, 2
	jne	SHORT $LN9@InvokeDire
$LN8@InvokeDire:
	mov	r8d, DWORD PTR [r14+32]
	mov	eax, DWORD PTR size_vararg
	test	r8d, r8d
	jne	SHORT $LN7@InvokeDire
	test	BYTE PTR [r14+128], 1
	je	SHORT $LN9@InvokeDire
	test	eax, eax
	jne	SHORT $LN7@InvokeDire
$LN9@InvokeDire:

; 2572 :     } 
; 2573 :     else if ( sym->langtype == LANG_FASTCALL ) {

	cmp	edx, 7
	jne	SHORT $LN3@InvokeDire

; 2574 :         fastcall_tab[ModuleInfo.fctype].invokeend( proc, numParam, value );

	movsxd	rax, DWORD PTR ModuleInfo+376
	mov	r8d, DWORD PTR value$[rsp]
	mov	edx, esi
	lea	rax, QWORD PTR [rax+rax*2]
	mov	rcx, rbx
	call	QWORD PTR fastcall_tab[r12+rax*8+8]
	jmp	SHORT $LN5@InvokeDire
$LN3@InvokeDire:

; 2575 :     }
; 2576 :     else if ( sym->langtype == LANG_VECTORCALL ) {

	cmp	edx, 8
	jne	SHORT $LN5@InvokeDire

; 2577 :         vectorcall_tab[ModuleInfo.fctype].invokeend( proc, numParam, value );

	movsxd	rax, DWORD PTR ModuleInfo+376
	mov	r8d, DWORD PTR value$[rsp]
	mov	edx, esi
	lea	rax, QWORD PTR [rax+rax*2]
	mov	rcx, rbx
	call	QWORD PTR vectorcall_tab[r12+rax*8+8]
	jmp	SHORT $LN5@InvokeDire
$LN7@InvokeDire:

; 2567 :         if ( info->has_vararg ) {

	test	BYTE PTR [r14+128], 1
	je	SHORT $LN6@InvokeDire

; 2568 :             DebugMsg1(("InvokeDir: size of fix args=%u, var args=%u\n", info->parasize, size_vararg));
; 2569 :             AddLineQueueX( " add %r, %u", stackreg[ModuleInfo.Ofssize], NUMQUAL info->parasize + size_vararg );

	add	r8d, eax
	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:$SG7040
	mov	edx, DWORD PTR stackreg[r12+rax*4]
	call	AddLineQueueX

; 2570 :         } else

	jmp	SHORT $LN5@InvokeDire
$LN6@InvokeDire:

; 2571 :             AddLineQueueX( " add %r, %u", stackreg[ModuleInfo.Ofssize], NUMQUAL info->parasize );

	movzx	eax, BYTE PTR ModuleInfo+404
	lea	rcx, OFFSET FLAT:$SG7042
	mov	edx, DWORD PTR stackreg[r12+rax*4]
	call	AddLineQueueX
$LN5@InvokeDire:

; 2578 :     }
; 2579 : 
; 2580 :     LstWrite( LSTTYPE_DIRECTIVE, GetCurrOffset(), NULL );

	call	GetCurrOffset
	xor	r8d, r8d
	lea	ecx, QWORD PTR [r8+4]
	mov	edx, eax
	call	LstWrite

; 2581 : 
; 2582 :     RunLineQueue();

	call	RunLineQueue

; 2583 : 
; 2584 :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN136@InvokeDire
$LN75@InvokeDire:

; 2366 :         }
; 2367 :     } else {
; 2368 :         DebugMsg(("InvokeDir: error, sym=%s state=%u memtype=%Xh [type=%s memtype=%Xh]\n",
; 2369 :                   sym->name, sym->state, sym->mem_type,
; 2370 :                   sym->type ? sym->type->name : "NULL",
; 2371 :                   sym->type ? sym->type->mem_type : 0));
; 2372 : #ifdef DEBUG_OUT
; 2373 :         if ( sym->mem_type == MT_PTR || sym->mem_type == MT_PROC )
; 2374 :             DebugMsg(("InvokeDir: error, target_type=%s [memtype=%X pmemtype=%X isproc=%u])\n",
; 2375 :                       sym->target_type->name,
; 2376 :                       sym->target_type->mem_type,
; 2377 :                       sym->target_type->ptr_memtype,
; 2378 :                       sym->target_type->isproc ));
; 2379 : #endif
; 2380 :         return( EmitErr( INVOKE_REQUIRES_PROTOTYPE ) );

	mov	ecx, 159				; 0000009fH
	call	EmitErr
	jmp	$LN94@InvokeDire
InvokeDirective ENDP
_TEXT	ENDS
END
