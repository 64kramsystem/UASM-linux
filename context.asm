; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
typetab	DD	01H
	DD	02H
	DD	04H
	DD	08H
	DD	010H
	DD	0fH
CONST	ENDS
_DATA	SEGMENT
$SG5476	DB	'ASSUMES', 00H
$SG5477	DB	'RADIX', 00H
	ORG $+2
$SG5478	DB	'LISTING', 00H
$SG5479	DB	'CPU', 00H
	ORG $+4
$SG5480	DB	'ALIGNMENT', 00H
	ORG $+2
$SG5481	DB	'ALL', 00H
_DATA	ENDS
CONST	SEGMENT
contextnames DQ	FLAT:$SG5476
	DQ	FLAT:$SG5477
	DQ	FLAT:$SG5478
	DQ	FLAT:$SG5479
	DQ	FLAT:$SG5480
	DQ	FLAT:$SG5481
CONST	ENDS
PUBLIC	ContextDirective
EXTRN	EmitErr:NEAR
EXTRN	GetStdAssumeTable:NEAR
EXTRN	GetSegAssumeTable:NEAR
EXTRN	LclAlloc:NEAR
EXTRN	SetStdAssumeTable:NEAR
EXTRN	SetSegAssumeTable:NEAR
EXTRN	sym_Cpu:QWORD
EXTRN	ModuleInfo:BYTE
EXTRN	Options:BYTE
EXTRN	_stricmp:NEAR
xdata	SEGMENT
$unwind$ContextDirective DD 0112c01H
	DD	07f42cH
	DD	08e428H
	DD	09d424H
	DD	0ac420H
	DD	0b741cH
	DD	0c6418H
	DD	0115414H
	DD	0103410H
	DD	0c20cH
xdata	ENDS
pdata	SEGMENT
$pdata$ContextDirective DD @imagerel($LN67#)
	DD	@imagerel($LN67#+1123)
	DD	@imagerel($unwind$ContextDirective#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\context.c
pdata	ENDS
_TEXT	SEGMENT
$T5641 = 32
tv675 = 40
type$ = 112
i$ = 112
tokenarray$ = 120
ContextDirective PROC NEAR

; 107  : {

$LN67:
	mov	QWORD PTR [rsp+16], rdx
	mov	rax, rsp
	sub	rsp, 104				; 00000068H
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax+32], rbp
	mov	QWORD PTR [rax-8], rsi
	mov	QWORD PTR [rax-16], rdi
	mov	QWORD PTR [rax-24], r12
	mov	QWORD PTR [rax-32], r13
	mov	QWORD PTR [rax-40], r14
	mov	QWORD PTR [rax-48], r15
	movsxd	r14, ecx

; 108  :     int start = i;
; 109  :     int directive = tokenarray[i].tokval;

	mov	rax, r14
	mov	QWORD PTR tv675[rsp], r14

; 110  :     enum context_type type;
; 111  :     int j;
; 112  :     struct context *curr;
; 113  : 
; 114  :     DebugMsg(( "%s directive enter\n", tokenarray[i].string_ptr ));
; 115  : 
; 116  :     i++; /* skip CONTEXT keyword */

	inc	r14d
	shl	rax, 5

; 117  : 
; 118  :     while ( tokenarray[i].token == T_ID ) {

	movsxd	r8, r14d
	mov	rbp, rdx

; 135  :         }
; 136  : 
; 137  :         if ( directive == T_POPCONTEXT ) {

	movsxd	rax, DWORD PTR [rax+rdx+16]
	mov	QWORD PTR $T5641[rsp], rax
	mov	rax, r8
	shl	rax, 5
	cmp	BYTE PTR [rax+rdx], 8
	jne	$LN60@ContextDir
	shl	r8, 5
	lea	rax, OFFSET FLAT:contextnames
	lea	r13, QWORD PTR [r8+rdx]
	lea	r15, QWORD PTR [r13+32]
	lea	r12, QWORD PTR [r13+8]
	npad	10
$LL43@ContextDir:
	xor	esi, esi
	xor	ebx, ebx
	lea	edi, QWORD PTR [rsi-1]
	npad	9
$LL41@ContextDir:
	mov	rdx, QWORD PTR [r12]
	mov	rcx, QWORD PTR [rax+rbx*8]
	call	_stricmp
	test	eax, eax
	je	SHORT $LN50@ContextDir
	inc	esi
	inc	rbx
	cmp	esi, 6
	jae	$LN64@ContextDir

; 119  :         for ( j = 0, type = -1; j < ( sizeof(typetab) / sizeof(typetab[0]) ); j++ ) {

	lea	rax, OFFSET FLAT:contextnames
	jmp	SHORT $LL41@ContextDir
$LN50@ContextDir:

; 120  :             if ( _stricmp( contextnames[j], tokenarray[i].string_ptr ) == 0 ) {
; 121  :                 type = typetab[j];

	lea	rcx, OFFSET FLAT:typetab
	mov	edi, DWORD PTR [rcx+rbx*4]

; 122  :                 break;
; 123  :             }
; 124  :         }
; 125  : 
; 126  :         if ( type == -1 )

	cmp	edi, -1
	je	$LN63@ContextDir

; 127  :             break;
; 128  : 
; 129  :         /* reject ALIGNMENT if strict masm compat is on */
; 130  :         if ( Options.strict_masm_compat ) {

	cmp	BYTE PTR Options+136, 0
	je	SHORT $LN34@ContextDir

; 131  :             if ( type == CONT_ALIGNMENT )

	cmp	edi, 16
	je	$LN62@ContextDir

; 132  :                 break;
; 133  :             else
; 134  :                 type &= ~CONT_ALIGNMENT; /* in case ALIGNMENT is again included in ALL */

	and	edi, -17
$LN34@ContextDir:

; 135  :         }
; 136  : 
; 137  :         if ( directive == T_POPCONTEXT ) {

	cmp	QWORD PTR $T5641[rsp], 453		; 000001c5H
	jne	$LN33@ContextDir

; 138  :             struct context *prev;
; 139  :             struct context *next;
; 140  :             DebugMsg(( "POPCONTEXT type=%X\n", type ));
; 141  :             /* for POPCONTEXT, check if appropriate items are on the stack */
; 142  :             for ( prev = NULL, curr = ContextStack; curr && type; curr = next ) {

	mov	rbx, QWORD PTR ModuleInfo+240
	xor	ebp, ebp
	test	rbx, rbx
	je	$LN30@ContextDir
$LL32@ContextDir:
	test	edi, edi
	je	$LN61@ContextDir

; 143  : 
; 144  :                 DebugMsg(( "POPCONTEXT: found item with type=%X\n", curr->type ));
; 145  :                 next = curr->next;
; 146  :                 /* matching item on the stack? */
; 147  :                 if ( !( curr->type & type ) ) {

	mov	eax, DWORD PTR [rbx+8]
	mov	rsi, QWORD PTR [rbx]
	test	eax, edi
	jne	SHORT $LN29@ContextDir

; 148  :                     prev = curr;

	mov	rbp, rbx

; 149  :                     continue;

	jmp	$LN31@ContextDir
$LN29@ContextDir:

; 150  :                 }
; 151  : 
; 152  :                 type &= ~curr->type;

	not	eax
	and	edi, eax

; 153  :                 if ( prev )

	test	rbp, rbp
	je	SHORT $LN28@ContextDir

; 154  :                     prev->next = next;

	mov	QWORD PTR [rbp], rsi

; 155  :                 else

	jmp	SHORT $LN27@ContextDir
$LN28@ContextDir:

; 156  :                     ContextStack = next;

	mov	QWORD PTR ModuleInfo+240, rsi
$LN27@ContextDir:

; 157  : 
; 158  :                 curr->next = ContextFree;

	mov	rax, QWORD PTR ModuleInfo+248
	mov	QWORD PTR [rbx], rax

; 159  :                 ContextFree = curr;

	mov	QWORD PTR ModuleInfo+248, rbx

; 160  : 
; 161  :                 /* restore the values */
; 162  :                 switch ( curr->type ) {

	mov	ecx, DWORD PTR [rbx+8]
	dec	ecx
	je	$LN24@ContextDir
	dec	ecx
	je	$LN23@ContextDir
	sub	ecx, 2
	je	SHORT $LN21@ContextDir
	sub	ecx, 4
	je	SHORT $LN20@ContextDir
	cmp	ecx, 8
	jne	$LN31@ContextDir

; 170  :                 case CONT_ALIGNMENT:
; 171  :                     ModuleInfo.fieldalign = curr->alc.fieldalign;

	movzx	eax, BYTE PTR [rbx+16]
	mov	BYTE PTR ModuleInfo+397, al

; 172  :                     ModuleInfo.procalign  = curr->alc.procalign;

	movzx	eax, BYTE PTR [rbx+17]
	mov	BYTE PTR ModuleInfo+399, al

; 173  :                     break;

	jmp	$LN31@ContextDir
$LN20@ContextDir:

; 181  :                 case CONT_CPU:
; 182  :                     ModuleInfo.cpu      = curr->cc.cpu;
; 183  :                     if ( sym_Cpu )

	mov	rcx, QWORD PTR sym_Cpu
	movzx	eax, WORD PTR [rbx+16]
	test	rcx, rcx
	mov	WORD PTR ModuleInfo+388, ax
	je	SHORT $LN19@ContextDir

; 184  :                         sym_Cpu->value  = curr->cc.cpu;

	movsx	eax, WORD PTR [rbx+16]
	mov	DWORD PTR [rcx+16], eax
$LN19@ContextDir:

; 185  :                     ModuleInfo.curr_cpu = curr->cc.curr_cpu;

	mov	eax, DWORD PTR [rbx+20]
	mov	DWORD PTR ModuleInfo+392, eax
	jmp	$LN31@ContextDir
$LN21@ContextDir:

; 174  :                 case CONT_LISTING:
; 175  :                     ModuleInfo.list_macro = curr->lc.list_macro;

	mov	eax, DWORD PTR [rbx+16]

; 176  :                     ModuleInfo.list       = curr->lc.list;

	mov	ecx, DWORD PTR ModuleInfo+408
	mov	DWORD PTR ModuleInfo+400, eax
	movzx	eax, BYTE PTR [rbx+20]
	shl	eax, 12
	xor	eax, ecx
	and	eax, 4096				; 00001000H
	xor	ecx, eax
	mov	DWORD PTR ModuleInfo+408, ecx

; 177  :                     ModuleInfo.cref       = curr->lc.cref;

	movzx	eax, BYTE PTR [rbx+20]
	shl	eax, 12
	xor	eax, ecx
	and	eax, 8192				; 00002000H
	xor	ecx, eax
	mov	DWORD PTR ModuleInfo+408, ecx

; 178  :                     ModuleInfo.listif     = curr->lc.listif;

	movzx	eax, BYTE PTR [rbx+20]
	shl	eax, 12
	xor	eax, ecx
	and	eax, 16384				; 00004000H
	xor	ecx, eax
	mov	DWORD PTR ModuleInfo+408, ecx

; 179  :                     ModuleInfo.list_generated_code = curr->lc.list_generated_code;

	movzx	eax, BYTE PTR [rbx+20]
	shl	eax, 12
	xor	eax, ecx
	and	eax, 32768				; 00008000H
	xor	ecx, eax
	mov	DWORD PTR ModuleInfo+408, ecx

; 180  :                     break;

	jmp	SHORT $LN31@ContextDir
$LN23@ContextDir:

; 166  :                     break;
; 167  :                 case CONT_RADIX:
; 168  :                     ModuleInfo.radix = curr->rc.radix;

	movzx	eax, BYTE PTR [rbx+16]
	mov	BYTE PTR ModuleInfo+396, al

; 169  :                     break;

	jmp	SHORT $LN31@ContextDir
$LN24@ContextDir:

; 163  :                 case CONT_ASSUMES:
; 164  :                     SetSegAssumeTable( curr->ac.SegAssumeTable );

	lea	rcx, QWORD PTR [rbx+16]
	call	SetSegAssumeTable

; 165  :                     SetStdAssumeTable( curr->ac.StdAssumeTable, curr->ac.type_content );

	lea	rdx, QWORD PTR [rbx+368]
	lea	rcx, QWORD PTR [rbx+112]
	call	SetStdAssumeTable
$LN31@ContextDir:
	test	rsi, rsi
	mov	rbx, rsi
	jne	$LL32@ContextDir
$LN30@ContextDir:

; 186  :                 }
; 187  :             }
; 188  :             if ( type ) {

	test	edi, edi
	je	$LN61@ContextDir

; 189  :                 DebugMsg(( "POPCONTEXT error, remaining type flags=%X\n", type ));
; 190  :                 return( EmitErr( UNMATCHED_BLOCK_NESTING, tokenarray[start].tokpos ) );

	mov	rax, QWORD PTR tv675[rsp]
	mov	rdx, QWORD PTR tokenarray$[rsp]
	mov	ecx, 142				; 0000008eH
	shl	rax, 5
	mov	rdx, QWORD PTR [rax+rdx+24]
	jmp	$LN66@ContextDir
$LN33@ContextDir:

; 191  :             }
; 192  :         } else {
; 193  :             DebugMsg(( "PUSHCONTEXT type=%X\n", type ));
; 194  :             for ( j = 0; j < ( sizeof(typetab) / sizeof(typetab[0] ) ) && type; j++ ) {

	xor	ebp, ebp
	mov	rsi, rcx
$LL16@ContextDir:
	test	edi, edi
	je	$LN61@ContextDir

; 195  :                 if ( type & typetab[j] ) {

	mov	eax, DWORD PTR [rsi]
	test	eax, edi
	je	$LN15@ContextDir

; 196  : 
; 197  :                     type &= ~typetab[j];
; 198  : 
; 199  :                     if ( ContextFree ) {

	mov	rbx, QWORD PTR ModuleInfo+248
	not	eax
	and	edi, eax
	test	rbx, rbx
	je	SHORT $LN12@ContextDir

; 200  :                         curr = ContextFree;
; 201  :                         ContextFree = curr->next;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR ModuleInfo+248, rax

; 202  :                     } else

	jmp	SHORT $LN11@ContextDir
$LN12@ContextDir:

; 203  :                         curr = LclAlloc( sizeof( struct context ) );

	mov	ecx, 752				; 000002f0H
	call	LclAlloc
	mov	rbx, rax
$LN11@ContextDir:

; 204  : 
; 205  :                     curr->type = typetab[j];

	mov	ecx, DWORD PTR [rsi]
	mov	DWORD PTR [rbx+8], ecx

; 206  :                     curr->next = ContextStack;

	mov	rcx, QWORD PTR ModuleInfo+240
	mov	QWORD PTR [rbx], rcx

; 207  :                     ContextStack = curr;
; 208  : 
; 209  :                     switch ( typetab[j] ) {

	mov	eax, DWORD PTR [rsi]
	mov	QWORD PTR ModuleInfo+240, rbx
	dec	eax
	je	$LN8@ContextDir
	dec	eax
	je	$LN7@ContextDir
	sub	eax, 2
	je	SHORT $LN5@ContextDir
	sub	eax, 4
	je	SHORT $LN4@ContextDir
	cmp	eax, 8
	jne	$LN15@ContextDir

; 217  :                     case CONT_ALIGNMENT:
; 218  :                         curr->alc.fieldalign = ModuleInfo.fieldalign;

	movzx	eax, BYTE PTR ModuleInfo+397
	mov	BYTE PTR [rbx+16], al

; 219  :                         curr->alc.procalign  = ModuleInfo.procalign;

	movzx	eax, BYTE PTR ModuleInfo+399
	mov	BYTE PTR [rbx+17], al

; 220  :                         break;

	jmp	$LN15@ContextDir
$LN4@ContextDir:

; 228  :                     case CONT_CPU:
; 229  :                         curr->cc.cpu      = ModuleInfo.cpu;

	movzx	eax, WORD PTR ModuleInfo+388
	mov	WORD PTR [rbx+16], ax

; 230  :                         curr->cc.curr_cpu = ModuleInfo.curr_cpu;

	mov	eax, DWORD PTR ModuleInfo+392
	mov	DWORD PTR [rbx+20], eax

; 231  :                         break;

	jmp	$LN15@ContextDir
$LN5@ContextDir:

; 221  :                     case CONT_LISTING:
; 222  :                         curr->lc.list_macro = ModuleInfo.list_macro;

	mov	eax, DWORD PTR ModuleInfo+400
	mov	DWORD PTR [rbx+16], eax

; 223  :                         curr->lc.list       = ModuleInfo.list;

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 12
	xor	al, BYTE PTR [rbx+20]
	and	al, 1
	xor	BYTE PTR [rbx+20], al
	movzx	eax, BYTE PTR [rbx+20]

; 224  :                         curr->lc.cref       = ModuleInfo.cref;

	mov	ecx, DWORD PTR ModuleInfo+408
	shr	ecx, 13
	add	cl, cl
	xor	cl, al
	and	cl, 2
	xor	cl, al
	mov	BYTE PTR [rbx+20], cl

; 225  :                         curr->lc.listif     = ModuleInfo.listif;

	mov	edx, DWORD PTR ModuleInfo+408
	shr	edx, 14
	shl	dl, 2
	xor	dl, cl
	and	dl, 4
	xor	dl, cl
	mov	BYTE PTR [rbx+20], dl

; 226  :                         curr->lc.list_generated_code = ModuleInfo.list_generated_code;

	mov	eax, DWORD PTR ModuleInfo+408
	shr	eax, 15
	shl	al, 3
	xor	al, dl
	and	al, 8
	xor	al, dl
	mov	BYTE PTR [rbx+20], al

; 227  :                         break;

	jmp	SHORT $LN15@ContextDir
$LN7@ContextDir:

; 213  :                         break;
; 214  :                     case CONT_RADIX:
; 215  :                         curr->rc.radix = ModuleInfo.radix;

	movzx	eax, BYTE PTR ModuleInfo+396
	mov	BYTE PTR [rbx+16], al

; 216  :                         break;

	jmp	SHORT $LN15@ContextDir
$LN8@ContextDir:

; 210  :                     case CONT_ASSUMES:
; 211  :                         GetSegAssumeTable( curr->ac.SegAssumeTable );

	lea	rcx, QWORD PTR [rbx+16]
	call	GetSegAssumeTable

; 212  :                         GetStdAssumeTable( curr->ac.StdAssumeTable, curr->ac.type_content );

	lea	rdx, QWORD PTR [rbx+368]
	lea	rcx, QWORD PTR [rbx+112]
	call	GetStdAssumeTable
$LN15@ContextDir:
	inc	ebp
	add	rsi, 4
	cmp	ebp, 6
	jb	$LL16@ContextDir
$LN61@ContextDir:

; 232  :                     }
; 233  :                 }
; 234  :             }
; 235  :         }
; 236  : 
; 237  :         i++;

	add	r13, 32					; 00000020H
	inc	r14d
	add	r15, 32					; 00000020H
	add	r12, 32					; 00000020H

; 238  :         if ( tokenarray[i].token == T_COMMA && tokenarray[i+1].token != T_FINAL )

	cmp	BYTE PTR [r13], 44			; 0000002cH
	jne	SHORT $LN3@ContextDir
	cmp	BYTE PTR [r15], 0
	je	SHORT $LN3@ContextDir

; 239  :             i++;

	inc	r14d
	add	r15, 32					; 00000020H
	add	r13, 32					; 00000020H
	add	r12, 32					; 00000020H
$LN3@ContextDir:

; 117  : 
; 118  :     while ( tokenarray[i].token == T_ID ) {

	cmp	BYTE PTR [r13], 8
	jne	SHORT $LN65@ContextDir
	lea	rax, OFFSET FLAT:contextnames
	jmp	$LL43@ContextDir
$LN60@ContextDir:

; 189  :                 DebugMsg(( "POPCONTEXT error, remaining type flags=%X\n", type ));
; 190  :                 return( EmitErr( UNMATCHED_BLOCK_NESTING, tokenarray[start].tokpos ) );

	mov	edi, DWORD PTR type$[rsp]
	jmp	SHORT $LN42@ContextDir
$LN62@ContextDir:

; 107  : {

	mov	rbp, QWORD PTR tokenarray$[rsp]
	jmp	SHORT $LN42@ContextDir
$LN63@ContextDir:
	mov	rbp, QWORD PTR tokenarray$[rsp]
	jmp	SHORT $LN42@ContextDir
$LN64@ContextDir:
	mov	rbp, QWORD PTR tokenarray$[rsp]
	jmp	SHORT $LN42@ContextDir
$LN65@ContextDir:
	mov	rbp, QWORD PTR tokenarray$[rsp]
$LN42@ContextDir:

; 240  :     }
; 241  : 
; 242  :     if ( tokenarray[i].token != T_FINAL || type == -1 ) {

	movsxd	rdx, r14d
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbp], 0
	jne	SHORT $LN1@ContextDir
	cmp	edi, -1
	je	SHORT $LN1@ContextDir

; 244  :     }
; 245  : 
; 246  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN44@ContextDir
$LN1@ContextDir:

; 243  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rbp+24]
	mov	ecx, 209				; 000000d1H
$LN66@ContextDir:
	call	EmitErr
$LN44@ContextDir:
	mov	r15, QWORD PTR [rsp+56]
	mov	r14, QWORD PTR [rsp+64]
	mov	r13, QWORD PTR [rsp+72]
	mov	r12, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+136]
	mov	rbx, QWORD PTR [rsp+128]

; 247  : }

	add	rsp, 104				; 00000068H
	ret	0
ContextDirective ENDP
_TEXT	ENDS
PUBLIC	ContextSaveState
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$ContextSaveState DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$ContextSaveState DD @imagerel($LN16#)
	DD	@imagerel($LN16#+41)
	DD	@imagerel($unwind$ContextSaveState#)
pdata	ENDS
xdata	SEGMENT
$chain$1$ContextSaveState DD 040a21H
	DD	09740aH
	DD	083405H
	DD	@imagerel($LN16#)
	DD	@imagerel($LN16#+41)
	DD	@imagerel($unwind$ContextSaveState#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$ContextSaveState DD @imagerel($LN16#+41)
	DD	@imagerel($LN16#+138)
	DD	@imagerel($chain$1$ContextSaveState#)
pdata	ENDS
xdata	SEGMENT
$chain$2$ContextSaveState DD 021H
	DD	@imagerel($LN16#)
	DD	@imagerel($LN16#+41)
	DD	@imagerel($unwind$ContextSaveState#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$ContextSaveState DD @imagerel($LN16#+138)
	DD	@imagerel($LN16#+143)
	DD	@imagerel($chain$2$ContextSaveState#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
ContextSaveState PROC NEAR

; 255  : {

$LN16:
	sub	rsp, 40					; 00000028H

; 256  :     int i;
; 257  :     struct context *src;
; 258  :     struct context *dst;
; 259  : 
; 260  :     for ( i = 0, src = ContextStack ; src ; i++, src = src->next );

	mov	rax, QWORD PTR ModuleInfo+240
	xor	ecx, ecx
	test	rax, rax
	je	SHORT $LN1@ContextSav
$LL7@ContextSav:
	mov	rax, QWORD PTR [rax]
	inc	ecx
	test	rax, rax
	jne	SHORT $LL7@ContextSav

; 261  : 
; 262  :     if ( i ) {

	test	ecx, ecx
	je	SHORT $LN1@ContextSav

; 263  :         cntSavedContexts = i;

	mov	DWORD PTR ModuleInfo+264, ecx

; 264  :         SavedContexts = LclAlloc( i * sizeof( struct context ) );

	movsxd	rcx, ecx
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	imul	rcx, 752				; 000002f0H
	call	LclAlloc

; 265  :         DebugMsg(( "ContextSaveState: SavedContexts=%X\n", SavedContexts ));
; 266  :         for ( src = ContextStack, dst = SavedContexts ; src ; src = src->next, dst++ ) {

	mov	rbx, QWORD PTR ModuleInfo+240
	test	rbx, rbx
	mov	rdi, rax
	mov	QWORD PTR ModuleInfo+256, rax
	je	SHORT $LN15@ContextSav
	npad	11
$LL3@ContextSav:

; 267  :             memcpy( dst, src, sizeof( struct context ) );

	mov	rcx, rdi
	mov	rdx, rbx
	mov	r8d, 752				; 000002f0H
	call	memcpy
	mov	rbx, QWORD PTR [rbx]
	add	rdi, 752				; 000002f0H
	test	rbx, rbx
	jne	SHORT $LL3@ContextSav
$LN15@ContextSav:
	mov	rbx, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
$LN1@ContextSav:

; 268  :         }
; 269  :     }
; 270  : }

	add	rsp, 40					; 00000028H
	ret	0
ContextSaveState ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$ContextRestoreState DD 030901H
	DD	086409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$ContextRestoreState DD @imagerel(ContextRestoreState#)
	DD	@imagerel(ContextRestoreState#+21)
	DD	@imagerel($unwind$ContextRestoreState#)
pdata	ENDS
xdata	SEGMENT
$chain$2$ContextRestoreState DD 040d21H
	DD	07340dH
	DD	097405H
	DD	@imagerel(ContextRestoreState#)
	DD	@imagerel(ContextRestoreState#+21)
	DD	@imagerel($unwind$ContextRestoreState#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$ContextRestoreState DD @imagerel(ContextRestoreState#+21)
	DD	@imagerel(ContextRestoreState#+148)
	DD	@imagerel($chain$2$ContextRestoreState#)
pdata	ENDS
xdata	SEGMENT
$chain$3$ContextRestoreState DD 021H
	DD	@imagerel(ContextRestoreState#)
	DD	@imagerel(ContextRestoreState#+21)
	DD	@imagerel($unwind$ContextRestoreState#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$ContextRestoreState DD @imagerel(ContextRestoreState#+148)
	DD	@imagerel(ContextRestoreState#+158)
	DD	@imagerel($chain$3$ContextRestoreState#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
ContextRestoreState PROC NEAR

; 276  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rsi

; 277  :     int i;
; 278  :     struct context *dst;
; 279  : 
; 280  :     for ( i = cntSavedContexts ; i ; i-- ) {

	movsxd	rsi, DWORD PTR ModuleInfo+264
	test	rsi, rsi
	je	SHORT $LN3@ContextRes
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rsi
	mov	QWORD PTR [rsp+56], rbx
	imul	rdi, 752				; 000002f0H
	sub	rdi, 752				; 000002f0H
$LL5@ContextRes:

; 281  :         if ( ContextFree ) {

	mov	rbx, QWORD PTR ModuleInfo+248
	test	rbx, rbx
	je	SHORT $LN2@ContextRes

; 282  :             dst = ContextFree;
; 283  :             ContextFree = dst->next;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR ModuleInfo+248, rax

; 284  :         } else

	jmp	SHORT $LN1@ContextRes
$LN2@ContextRes:

; 285  :             dst = LclAlloc( sizeof( struct context ) );

	mov	ecx, 752				; 000002f0H
	call	LclAlloc
	mov	rbx, rax
$LN1@ContextRes:

; 286  :         memcpy( dst, &SavedContexts[i-1], sizeof( struct context ) );

	mov	rdx, QWORD PTR ModuleInfo+256
	mov	rcx, rbx
	mov	r8d, 752				; 000002f0H
	add	rdx, rdi
	call	memcpy

; 287  :         dst->next = ContextStack;

	mov	r11, QWORD PTR ModuleInfo+240
	sub	rdi, 752				; 000002f0H
	dec	rsi
	mov	QWORD PTR [rbx], r11

; 288  :         ContextStack = dst;

	mov	QWORD PTR ModuleInfo+240, rbx
	jne	SHORT $LL5@ContextRes
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+56]
$LN3@ContextRes:
	mov	rsi, QWORD PTR [rsp+64]

; 289  :     }
; 290  : }

	add	rsp, 40					; 00000028H
	ret	0
ContextRestoreState ENDP
_TEXT	ENDS
PUBLIC	ContextInit
xdata	SEGMENT
$unwind$ContextInit DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$ContextInit DD @imagerel($LN14#)
	DD	@imagerel($LN14#+12)
	DD	@imagerel($unwind$ContextInit#)
pdata	ENDS
xdata	SEGMENT
$chain$0$ContextInit DD 020521H
	DD	086405H
	DD	@imagerel($LN14#)
	DD	@imagerel($LN14#+12)
	DD	@imagerel($unwind$ContextInit#)
xdata	ENDS
pdata	SEGMENT
$pdata$0$ContextInit DD @imagerel($LN14#+12)
	DD	@imagerel($LN14#+33)
	DD	@imagerel($chain$0$ContextInit#)
pdata	ENDS
xdata	SEGMENT
$chain$2$ContextInit DD 040d21H
	DD	07340dH
	DD	097405H
	DD	@imagerel($LN14#+12)
	DD	@imagerel($LN14#+33)
	DD	@imagerel($chain$0$ContextInit#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$ContextInit DD @imagerel($LN14#+33)
	DD	@imagerel($LN14#+164)
	DD	@imagerel($chain$2$ContextInit#)
pdata	ENDS
xdata	SEGMENT
$chain$3$ContextInit DD 021H
	DD	@imagerel($LN14#+12)
	DD	@imagerel($LN14#+33)
	DD	@imagerel($chain$0$ContextInit#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$ContextInit DD @imagerel($LN14#+164)
	DD	@imagerel($LN14#+169)
	DD	@imagerel($chain$3$ContextInit#)
pdata	ENDS
xdata	SEGMENT
$chain$4$ContextInit DD 021H
	DD	@imagerel($LN14#)
	DD	@imagerel($LN14#+12)
	DD	@imagerel($unwind$ContextInit#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$ContextInit DD @imagerel($LN14#+169)
	DD	@imagerel($LN14#+174)
	DD	@imagerel($chain$4$ContextInit#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pass$ = 48
ContextInit PROC NEAR

; 298  : {

$LN14:
	sub	rsp, 40					; 00000028H

; 299  :     /* if ContextStack isn't NULL, then at least one PUSHCONTEXT
; 300  :      * didn't have a matching POPCONTEXT. No need to reset it to NULL -
; 301  :      * but might be ok to move the items to the ContextFree heap.
; 302  :      */
; 303  :     //ContextStack = NULL;
; 304  : #if FASTPASS
; 305  :     if ( pass > PASS_1 ) {

	test	ecx, ecx
	jle	$LN6@ContextIni
	mov	QWORD PTR [rsp+64], rsi

; 306  :         ContextRestoreState();

	movsxd	rsi, DWORD PTR ModuleInfo+264
	test	rsi, rsi
	je	$LN13@ContextIni
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rsi
	mov	QWORD PTR [rsp+56], rbx
	imul	rdi, 752				; 000002f0H
	sub	rdi, 752				; 000002f0H
	npad	4
$LL8@ContextIni:
	mov	rbx, QWORD PTR ModuleInfo+248
	test	rbx, rbx
	je	SHORT $LN5@ContextIni
	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR ModuleInfo+248, rax
	jmp	SHORT $LN4@ContextIni
$LN5@ContextIni:
	mov	ecx, 752				; 000002f0H
	call	LclAlloc
	mov	rbx, rax
$LN4@ContextIni:
	mov	rdx, QWORD PTR ModuleInfo+256
	mov	rcx, rbx
	mov	r8d, 752				; 000002f0H
	add	rdx, rdi
	call	memcpy
	mov	r11, QWORD PTR ModuleInfo+240
	sub	rdi, 752				; 000002f0H
	dec	rsi
	mov	QWORD PTR [rbx], r11
	mov	QWORD PTR ModuleInfo+240, rbx
	jne	SHORT $LL8@ContextIni
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+56]
$LN13@ContextIni:
	mov	rsi, QWORD PTR [rsp+64]
$LN6@ContextIni:

; 307  :     }
; 308  : #endif
; 309  : }

	add	rsp, 40					; 00000028H
	ret	0
ContextInit ENDP
_TEXT	ENDS
END
