; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG6717	DB	01H DUP (?)
	ALIGN	4

$SG6471	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	LastCodeBufSize:DWORD
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
$SG6258	DB	'$$SYMBOLS', 00H
	ORG $+2
$SG6259	DB	'DEBSYM', 00H
	ORG $+5
$SG6260	DB	'$$TYPES', 00H
$SG6261	DB	'DEBTYP', 00H
_DATA	ENDS
CONST	SEGMENT
SymDebParm DQ	FLAT:$SG6258
	DQ	FLAT:$SG6259
	DQ	FLAT:$SG6260
	DQ	FLAT:$SG6261
CONST	ENDS
_DATA	SEGMENT
	ORG $+1
$SG6463	DB	01H, 00H
	ORG $+2
$SG6801	DB	01H, 'CV', 00H
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omf.c
_DATA	ENDS
_TEXT	SEGMENT
obj$ = 8
command$ = 16
omf_InitRec PROC NEAR

; 151  :     obj->length = 0;

	xor	eax, eax

; 152  :     obj->curoff = 0;
; 153  :     obj->data = NULL;
; 154  :     obj->command = command;

	mov	BYTE PTR [rcx+16], dl
	mov	DWORD PTR [rcx], eax
	mov	DWORD PTR [rcx+4], eax
	mov	QWORD PTR [rcx+8], rax

; 155  :     obj->is_32 = 0;

	mov	BYTE PTR [rcx+17], al

; 156  :     DebugMsg1(("omf_InitRec(%p, %X)\n", obj, command ));
; 157  :     return;
; 158  : }

	ret	0
omf_InitRec ENDP
_TEXT	ENDS
EXTRN	localtime:NEAR
xdata	SEGMENT
$unwind$timet2dostime DD 010901H
	DD	04209H
xdata	ENDS
pdata	SEGMENT
$pdata$timet2dostime DD @imagerel(timet2dostime#)
	DD	@imagerel(timet2dostime#+95)
	DD	@imagerel($unwind$timet2dostime#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
x$ = 48
dt$ = 56
timet2dostime PROC NEAR

; 162  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 163  :     struct tm *    ltime;
; 164  :     union DOS_DATETIME dt;
; 165  : 
; 166  :     ltime = localtime( &x );

	lea	rcx, QWORD PTR x$[rsp]
	call	localtime

; 167  :     dt.dos.date = (( ltime->tm_year - 80 ) << DATE_YEAR_B )
; 168  :              | (( ltime->tm_mon + 1 ) << DATE_MON_B )
; 169  :              | (( ltime->tm_mday ) << DATE_DAY_B );

	movzx	edx, WORD PTR [rax+20]
	movzx	ecx, WORD PTR [rax+16]
	inc	cx
	add	dx, 48					; 00000030H
	shl	cx, 5
	shl	dx, 9
	or	dx, cx

; 170  :     dt.dos.time = (( ltime->tm_hour ) << TIME_HOUR_B )
; 171  :              | (( ltime->tm_min ) << TIME_MIN_B )
; 172  :              | (( ltime->tm_sec / 2 ) << TIME_SEC_B );

	movzx	ecx, WORD PTR [rax+8]
	or	dx, WORD PTR [rax+12]
	shl	cx, 6
	or	cx, WORD PTR [rax+4]
	mov	eax, DWORD PTR [rax]
	mov	WORD PTR dt$[rsp+2], dx
	cdq
	shl	cx, 5
	sub	eax, edx
	sar	eax, 1
	or	cx, ax
	mov	WORD PTR dt$[rsp], cx

; 173  :     return( dt.timet );

	mov	rax, QWORD PTR dt$[rsp]

; 174  : }

	add	rsp, 40					; 00000028H
	ret	0
timet2dostime ENDP
; Function compile flags: /Ogtpy
objr$ = 8
value$ = 16
Put8	PROC NEAR

; 179  : /**/myassert( objr != NULL && objr->data != NULL );
; 180  :     objr->data[ objr->curoff++ ] = value;

	mov	r8d, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR [rcx+8]
	mov	BYTE PTR [r8+rax], dl
	inc	DWORD PTR [rcx+4]

; 181  : }

	ret	0
Put8	ENDP
; Function compile flags: /Ogtpy
objr$ = 8
value$ = 16
Put16	PROC NEAR

; 186  : /**/myassert( objr != NULL && objr->data != NULL );
; 187  : 
; 188  :     WriteU16( objr->data + objr->curoff, value );

	mov	r8d, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR [rcx+8]
	mov	WORD PTR [r8+rax], dx

; 189  :     objr->curoff += sizeof( uint_16 );

	add	DWORD PTR [rcx+4], 2

; 190  : }

	ret	0
Put16	ENDP
; Function compile flags: /Ogtpy
objr$ = 8
value$ = 16
Put32	PROC NEAR

; 195  : /**/myassert( objr != NULL && objr->data != NULL );
; 196  : 
; 197  :     WriteU32( objr->data + objr->curoff, value );

	mov	r8d, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR [rcx+8]
	mov	DWORD PTR [r8+rax], edx

; 198  :     objr->curoff += sizeof( uint_32 );

	add	DWORD PTR [rcx+4], 4

; 199  : }

	ret	0
Put32	ENDP
; Function compile flags: /Ogtpy
objr$ = 8
idx$ = 16
PutIndex PROC NEAR

; 225  : /**/myassert( objr != NULL && objr->data != NULL && idx <= 0x7FFF );
; 226  :     if( idx > 0x7f ) {

	cmp	edx, 127				; 0000007fH
	mov	r10, rcx
	jbe	SHORT $LN1@PutIndex

; 227  :         objr->data[objr->curoff++] = ( idx >> 8 ) | 0x80;

	mov	r8d, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR [rcx+8]
	mov	r9d, edx
	shr	r9d, 8
	or	r9b, 128				; 00000080H
	mov	BYTE PTR [r8+rax], r9b
	inc	DWORD PTR [rcx+4]
$LN1@PutIndex:

; 228  :     }
; 229  :     objr->data[objr->curoff++] = idx & 0xff;

	mov	ecx, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR [r10+8]
	mov	BYTE PTR [rcx+rax], dl
	inc	DWORD PTR [r10+4]

; 230  : }

	ret	0
PutIndex ENDP
_TEXT	ENDS
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$PutData DD 051801H
	DD	097418H
	DD	083409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$PutData DD @imagerel(PutData#)
	DD	@imagerel(PutData#+50)
	DD	@imagerel($unwind$PutData#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
objr$ = 48
data$ = 56
len$ = 64
PutData	PROC NEAR

; 234  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rbx
	mov	rbx, rcx

; 235  :     /**/myassert( objr != NULL && objr->data != NULL );
; 236  :     memcpy( objr->data + objr->curoff, data, len );

	mov	ecx, DWORD PTR [rcx+4]
	add	rcx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, r8
	call	memcpy

; 237  :     objr->curoff += len;

	add	DWORD PTR [rbx+4], edi
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 238  : }

	add	rsp, 40					; 00000028H
	ret	0
PutData	ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$PutName DD 052301H
	DD	097423H
	DD	083411H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$PutName DD @imagerel(PutName#)
	DD	@imagerel(PutName#+65)
	DD	@imagerel($unwind$PutName#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
objr$ = 48
name$ = 56
len$ = 64
PutName	PROC NEAR

; 242  : {

	sub	rsp, 40					; 00000028H

; 243  :     /**/myassert( objr != NULL && objr->data != NULL );
; 244  : #if MAX_ID_LEN > MAX_ID_LEN_OMF
; 245  :     if ( len > MAX_ID_LEN_OMF ) {
; 246  :         EmitWarn( 1, IDENTIFIER_TOO_LONG );
; 247  :         len = MAX_ID_LEN_OMF;
; 248  :     }
; 249  : #endif
; 250  :     objr->data[objr->curoff++] = len;

	mov	r9d, DWORD PTR [rcx+4]
	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rsp+64], rbx
	mov	BYTE PTR [r9+rax], r8b
	inc	DWORD PTR [rcx+4]
	mov	rbx, rcx
	mov	ecx, DWORD PTR [rcx+4]
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, r8

; 251  :     PutData( objr, (uint_8 *)name, len );

	add	rcx, QWORD PTR [rbx+8]
	call	memcpy
	add	DWORD PTR [rbx+4], edi
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 252  : }

	add	rsp, 40					; 00000028H
	ret	0
PutName	ENDP
; Function compile flags: /Ogtpy
objr$ = 8
data$ = 16
len$ = 24
AttachData PROC NEAR

; 257  : /**/myassert( objr->data == NULL );
; 258  :     objr->data = data;

	mov	QWORD PTR [rcx+8], rdx

; 259  :     objr->length = len;

	mov	DWORD PTR [rcx], r8d

; 260  : }

	ret	0
AttachData ENDP
_TEXT	ENDS
PUBLIC	omf_GetGrpIdx
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
sym$ = 8
omf_GetGrpIdx PROC NEAR

; 277  :     return( sym ? ((struct dsym *)sym)->e.grpinfo->grp_idx : 0 );

	test	rcx, rcx
	je	SHORT $LN3@omf_GetGrp
	mov	rax, QWORD PTR [rcx+104]
	mov	eax, DWORD PTR [rax+8]

; 278  : }

	ret	0
$LN3@omf_GetGrp:

; 277  :     return( sym ? ((struct dsym *)sym)->e.grpinfo->grp_idx : 0 );

	xor	eax, eax

; 278  : }

	ret	0
omf_GetGrpIdx ENDP
_TEXT	ENDS
PUBLIC	omf_OutSelect
EXTRN	omf_write_record:NEAR
EXTRN	GetSegIdx:NEAR
EXTRN	write_to_file:BYTE
EXTRN	GetCurrOffset:NEAR
EXTRN	ModuleInfo:BYTE
_BSS	SEGMENT
	ALIGN	4

?sel_start@?1??omf_OutSelect@@9@9 DD 01H DUP (?)	; `omf_OutSelect'::`2'::sel_start
_BSS	ENDS
xdata	SEGMENT
$unwind$omf_OutSelect DD 020601H
	DD	03002b206H
xdata	ENDS
pdata	SEGMENT
$pdata$omf_OutSelect DD @imagerel($LN35#)
	DD	@imagerel($LN35#+464)
	DD	@imagerel($unwind$omf_OutSelect#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buffer$ = 32
obj$ = 48
is_data$ = 112
omf_OutSelect PROC NEAR

; 286  : {

$LN35:
	push	rbx
	sub	rsp, 96					; 00000060H

; 287  :     struct omf_rec      obj;
; 288  :     uint_32             currofs;
; 289  :     int                 sel_idx;
; 290  :     static uint_32      sel_start;  /* start offset of data items */
; 291  :     unsigned char       buffer[12]; /* max is 11 ( see below ) */
; 292  : 
; 293  :     if( is_data ) {

	test	cl, cl
	je	SHORT $LN9@omf_OutSel

; 294  :         /* do nothing if it isn't the first data item or
; 295  :          * if current segment isn't code
; 296  :          */
; 297  :         if( CurrSeg->e.seginfo->data_in_code ||
; 298  :            ( CurrSeg->e.seginfo->segtype != SEGTYPE_CODE ) )

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	test	BYTE PTR [rcx+107], 8
	jne	$LN4@omf_OutSel
	cmp	DWORD PTR [rcx+72], 1
	jne	$LN4@omf_OutSel

; 299  :             return;
; 300  :         sel_start = GetCurrOffset();

	call	GetCurrOffset
	mov	DWORD PTR ?sel_start@?1??omf_OutSelect@@9@9, eax

; 301  :         CurrSeg->e.seginfo->data_in_code = TRUE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	or	BYTE PTR [rcx+107], 8

; 331  :         }
; 332  :     }
; 333  : }

	add	rsp, 96					; 00000060H
	pop	rbx
	ret	0
$LN9@omf_OutSel:

; 302  :         DebugMsg(("omf_OutSelect: data in code segment (%s), starting at %" I32_SPEC "X\n", CurrSeg->sym.name, sel_start ));
; 303  :     } else if ( CurrSeg->e.seginfo->data_in_code ) { /* data items written? */

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rcx+104]
	test	BYTE PTR [rax+107], 8
	je	$LN4@omf_OutSel

; 304  :         
; 305  :         CurrSeg->e.seginfo->data_in_code = FALSE;

	and	BYTE PTR [rax+107], 247			; 000000f7H

; 306  : 
; 307  :         if( write_to_file == TRUE ) {

	cmp	BYTE PTR write_to_file, 1
	jne	$LN4@omf_OutSel

; 308  :             omf_InitRec( &obj, CMD_COMENT );
; 309  :             obj.d.coment.attr = CMT_TNP;
; 310  :             obj.d.coment.cmt_class = CMT_DISASM_DIRECTIVE;
; 311  : 
; 312  :             sel_idx = GetSegIdx( &CurrSeg->sym );

	mov	rcx, QWORD PTR ModuleInfo+432
	xor	eax, eax
	mov	BYTE PTR obj$[rsp+16], 136		; 00000088H
	mov	DWORD PTR obj$[rsp], eax
	mov	DWORD PTR obj$[rsp+4], eax
	mov	QWORD PTR obj$[rsp+8], rax
	mov	BYTE PTR obj$[rsp+17], al
	mov	BYTE PTR obj$[rsp+20], 128		; 00000080H
	mov	BYTE PTR obj$[rsp+21], 253		; 000000fdH
	call	GetSegIdx

; 313  : 
; 314  :             //AllocData( objr, 11 );  /* 11 = 1 + 2 + 4 + 4 */
; 315  :             AttachData( &obj, buffer, 11 );  /* 11 = 1 + 2 + 4 + 4 */

	mov	DWORD PTR obj$[rsp], 11
	mov	ebx, eax
	lea	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR obj$[rsp+8], rax

; 316  :             currofs = GetCurrOffset();

	call	GetCurrOffset

; 317  :             DebugMsg(("omf_OutSelect: writing coment record about data in code: start=%" I32_SPEC "X curofs=%" I32_SPEC "X\n", sel_start, currofs ));
; 318  :             if( ( sel_start > 0xffffUL ) || ( currofs > 0xffffUL ) ) {

	mov	r8d, DWORD PTR ?sel_start@?1??omf_OutSelect@@9@9
	cmp	r8d, 65535				; 0000ffffH
	mov	r11d, eax
	ja	SHORT $LN2@omf_OutSel
	cmp	eax, 65535				; 0000ffffH
	ja	SHORT $LN2@omf_OutSel

; 323  :             } else {
; 324  :                 Put8( &obj, DDIR_SCAN_TABLE );

	mov	edx, DWORD PTR obj$[rsp+4]
	mov	rcx, QWORD PTR obj$[rsp+8]
	mov	BYTE PTR [rdx+rcx], 115			; 00000073H
	mov	ecx, DWORD PTR obj$[rsp+4]
	inc	ecx

; 325  :                 PutIndex( &obj, sel_idx );

	cmp	ebx, 127				; 0000007fH
	mov	DWORD PTR obj$[rsp+4], ecx
	jbe	SHORT $LN27@omf_OutSel
	mov	rax, QWORD PTR obj$[rsp+8]
	mov	edx, ebx
	shr	edx, 8
	or	dl, 128					; 00000080H
	mov	BYTE PTR [rcx+rax], dl
	mov	ecx, DWORD PTR obj$[rsp+4]
	inc	ecx
	mov	DWORD PTR obj$[rsp+4], ecx
$LN27@omf_OutSel:
	mov	rax, QWORD PTR obj$[rsp+8]
	mov	BYTE PTR [rcx+rax], bl
	mov	eax, DWORD PTR obj$[rsp+4]
	inc	eax
	mov	DWORD PTR obj$[rsp+4], eax

; 326  :                 Put16( &obj, sel_start );

	mov	ecx, eax
	mov	rax, QWORD PTR obj$[rsp+8]
	mov	WORD PTR [rcx+rax], r8w
	mov	eax, DWORD PTR obj$[rsp+4]
	add	eax, 2
	mov	DWORD PTR obj$[rsp+4], eax

; 327  :                 Put16( &obj, currofs );

	mov	ecx, eax
	mov	rax, QWORD PTR obj$[rsp+8]
	mov	WORD PTR [rcx+rax], r11w
	mov	eax, DWORD PTR obj$[rsp+4]
	add	eax, 2
	jmp	SHORT $LN34@omf_OutSel
$LN2@omf_OutSel:

; 319  :                 Put8( &obj, DDIR_SCAN_TABLE_32 );

	mov	ecx, DWORD PTR obj$[rsp+4]
	mov	rax, QWORD PTR obj$[rsp+8]
	mov	BYTE PTR [rcx+rax], 83			; 00000053H
	mov	eax, DWORD PTR obj$[rsp+4]
	inc	eax

; 320  :                 PutIndex( &obj, sel_idx );

	cmp	ebx, 127				; 0000007fH
	mov	DWORD PTR obj$[rsp+4], eax
	jbe	SHORT $LN18@omf_OutSel
	mov	ecx, eax
	mov	rax, QWORD PTR obj$[rsp+8]
	mov	edx, ebx
	shr	edx, 8
	or	dl, 128					; 00000080H
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR obj$[rsp+4]
	inc	eax
	mov	DWORD PTR obj$[rsp+4], eax
$LN18@omf_OutSel:
	mov	ecx, eax
	mov	rax, QWORD PTR obj$[rsp+8]
	mov	BYTE PTR [rcx+rax], bl
	mov	eax, DWORD PTR obj$[rsp+4]
	inc	eax
	mov	DWORD PTR obj$[rsp+4], eax

; 321  :                 Put32( &obj, sel_start );

	mov	ecx, eax
	mov	rax, QWORD PTR obj$[rsp+8]
	mov	DWORD PTR [rcx+rax], r8d
	mov	eax, DWORD PTR obj$[rsp+4]
	add	eax, 4
	mov	DWORD PTR obj$[rsp+4], eax

; 322  :                 Put32( &obj, currofs );

	mov	ecx, eax
	mov	rax, QWORD PTR obj$[rsp+8]
	mov	DWORD PTR [rcx+rax], r11d
	mov	eax, DWORD PTR obj$[rsp+4]
	add	eax, 4
$LN34@omf_OutSel:

; 328  :             }
; 329  :             TruncRec( &obj );
; 330  :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	DWORD PTR obj$[rsp+4], eax
	mov	DWORD PTR obj$[rsp], eax
	call	omf_write_record
$LN4@omf_OutSel:

; 331  :         }
; 332  :     }
; 333  : }

	add	rsp, 96					; 00000060H
	pop	rbx
	ret	0
omf_OutSelect ENDP
_TEXT	ENDS
EXTRN	GetGroup:NEAR
EXTRN	LinnumQueue:BYTE
xdata	SEGMENT
$unwind$omf_write_linnum DD 010401H
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_linnum DD @imagerel(omf_write_linnum#)
	DD	@imagerel(omf_write_linnum#+205)
	DD	@imagerel($unwind$omf_write_linnum#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
obj$ = 32
is32$ = 96
omf_write_linnum PROC NEAR

; 348  : {

	sub	rsp, 88					; 00000058H

; 349  :     unsigned             ofssize = ( is32 ? sizeof( uint_32) : sizeof( uint_16 ) );
; 350  :     unsigned             size;
; 351  :     uint_8               *data;
; 352  :     struct line_num_info *node;
; 353  :     struct line_num_info *next;
; 354  :     struct omf_rec       obj;
; 355  : 
; 356  :     for( node = LinnumQueue.head, data = StringBufferEnd; node; node = next ) {

	mov	r8, QWORD PTR LinnumQueue
	mov	eax, 4
	test	cl, cl
	mov	r9d, 2
	movzx	r10d, cl
	cmovne	r9d, eax
	test	r8, r8
	mov	rax, QWORD PTR ModuleInfo+488
	mov	rdx, rax
	je	SHORT $LN2@omf_write_
	npad	1
$LL4@omf_write_:

; 357  :         next = node->next;
; 358  :         *(uint_16 *)data = node->number;

	movzx	eax, WORD PTR [r8+8]
	mov	rcx, QWORD PTR [r8]

; 359  :         data += sizeof( uint_16 );

	add	rdx, 2
	mov	WORD PTR [rdx-2], ax

; 360  :         *(uint_32 *)data = node->offset;

	mov	eax, DWORD PTR [r8+12]
	mov	r8, rcx
	mov	DWORD PTR [rdx], eax

; 361  :         data += ofssize;

	add	rdx, r9
	test	rcx, rcx
	jne	SHORT $LL4@omf_write_

; 349  :     unsigned             ofssize = ( is32 ? sizeof( uint_32) : sizeof( uint_16 ) );
; 350  :     unsigned             size;
; 351  :     uint_8               *data;
; 352  :     struct line_num_info *node;
; 353  :     struct line_num_info *next;
; 354  :     struct omf_rec       obj;
; 355  : 
; 356  :     for( node = LinnumQueue.head, data = StringBufferEnd; node; node = next ) {

	mov	rax, QWORD PTR ModuleInfo+488
$LN2@omf_write_:

; 362  :         LclFree( node );
; 363  :     }
; 364  :     LinnumQueue.head = NULL;

	xor	ecx, ecx

; 365  : 
; 366  :     size = (char *)data - StringBufferEnd;

	sub	edx, eax
	mov	QWORD PTR LinnumQueue, rcx

; 367  :     if( size ) {

	je	SHORT $LN1@omf_write_

; 368  :         omf_InitRec( &obj, CMD_LINNUM );

	mov	DWORD PTR obj$[rsp+4], ecx

; 369  :         obj.is_32 = is32;
; 370  :         AttachData( &obj, StringBufferEnd, size );
; 371  :         obj.d.linnum.base.grp_idx = omf_GetGrpIdx( GetGroup( &CurrSeg->sym ) ); /* fixme ? */

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	BYTE PTR obj$[rsp+16], 148		; 00000094H
	mov	BYTE PTR obj$[rsp+17], r10b
	mov	QWORD PTR obj$[rsp+8], rax
	mov	DWORD PTR obj$[rsp], edx
	call	GetGroup
	test	rax, rax
	je	SHORT $LN13@omf_write_
	mov	rax, QWORD PTR [rax+104]
	movzx	ecx, WORD PTR [rax+8]
	mov	WORD PTR obj$[rsp+20], cx
	jmp	SHORT $LN14@omf_write_
$LN13@omf_write_:
	mov	WORD PTR obj$[rsp+20], 0
$LN14@omf_write_:

; 372  :         obj.d.linnum.base.seg_idx = CurrSeg->e.seginfo->seg_idx;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	movzx	eax, WORD PTR [rcx+68]

; 373  :         obj.d.linnum.base.frame = 0; /* field not used here */
; 374  :         omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	WORD PTR obj$[rsp+24], 0
	mov	WORD PTR obj$[rsp+22], ax
	call	omf_write_record
$LN1@omf_write_:

; 375  :     }
; 376  :     return;
; 377  : }

	add	rsp, 88					; 00000058H
	ret	0
omf_write_linnum ENDP
_TEXT	ENDS
EXTRN	OmfFixGenFix:NEAR
xdata	SEGMENT
$unwind$omf_write_fixupp DD 0b2301H
	DD	0bd423H
	DD	0cc41fH
	DD	011741bH
	DD	0f5413H
	DD	0e340fH
	DD	0c207H
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_fixupp DD @imagerel(omf_write_fixupp#)
	DD	@imagerel(omf_write_fixupp#+69)
	DD	@imagerel($unwind$omf_write_fixupp#)
pdata	ENDS
xdata	SEGMENT
$chain$5$omf_write_fixupp DD 020421H
	DD	0106404H
	DD	@imagerel(omf_write_fixupp#)
	DD	@imagerel(omf_write_fixupp#+69)
	DD	@imagerel($unwind$omf_write_fixupp#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$omf_write_fixupp DD @imagerel(omf_write_fixupp#+69)
	DD	@imagerel(omf_write_fixupp#+243)
	DD	@imagerel($chain$5$omf_write_fixupp#)
pdata	ENDS
xdata	SEGMENT
$chain$6$omf_write_fixupp DD 021H
	DD	@imagerel(omf_write_fixupp#)
	DD	@imagerel(omf_write_fixupp#+69)
	DD	@imagerel($unwind$omf_write_fixupp#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$omf_write_fixupp DD @imagerel(omf_write_fixupp#+243)
	DD	@imagerel(omf_write_fixupp#+276)
	DD	@imagerel($chain$6$omf_write_fixupp#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
obj$ = 32
seg$ = 112
is32$ = 120
omf_write_fixupp PROC NEAR

; 381  : {

	mov	r11, rsp
	sub	rsp, 104				; 00000068H

; 382  :     uint_8 *data;
; 383  :     unsigned size;
; 384  :     struct fixup *fix;
; 385  :     enum fixup_types type = ( is32 ? FIX_GEN_MS386 : FIX_GEN_INTEL );
; 386  :     struct omf_rec  obj;
; 387  : 
; 388  :     fix = seg->e.seginfo->FixupList.head;

	mov	rax, QWORD PTR [rcx+104]
	mov	QWORD PTR [r11+8], rbx
	mov	QWORD PTR [r11+16], rbp
	mov	rbx, QWORD PTR [rax+40]
	mov	QWORD PTR [r11+32], rdi
	mov	QWORD PTR [r11-8], r12
	mov	QWORD PTR [r11-16], r13
	xor	r13d, r13d
	test	dl, dl
	mov	r12d, r13d
	setne	r12b

; 389  :     while ( fix ) {

	test	rbx, rbx
	movzx	edi, dl
	mov	rbp, rcx
	je	$LN25@omf_write_@2
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	QWORD PTR [r11+24], rsi
	npad	7
$LL13@omf_write_@2:

; 390  :         for( data = StringBufferEnd, size = 0; fix; fix = fix->nextrlc ) {

	test	rbx, rbx
	mov	rsi, rdx
	mov	ecx, r13d
	je	$LN26@omf_write_@2
	npad	1
$LL11@omf_write_@2:

; 391  :             switch( fix->type ) {

	mov	eax, DWORD PTR [rbx+24]
	cmp	eax, 3
	je	SHORT $LN6@omf_write_@2
	cmp	eax, 6
	je	SHORT $LN6@omf_write_@2
	cmp	eax, 10
	je	SHORT $LN6@omf_write_@2

; 396  :                 break;
; 397  :             default:
; 398  :                 if ( is32 ) continue;

	test	dil, dil
	jne	SHORT $LN10@omf_write_@2

; 399  :                 break;

	jmp	SHORT $LN5@omf_write_@2
$LN6@omf_write_@2:

; 392  :             case FIX_RELOFF32:
; 393  :             case FIX_OFF32:
; 394  :             case FIX_PTR32:
; 395  :                 if ( !is32 ) continue;

	test	dil, dil
	je	SHORT $LN10@omf_write_@2
$LN5@omf_write_@2:

; 400  :             }
; 401  :             if ( size > 1020 - FIX_GEN_MAX )

	cmp	ecx, 1009				; 000003f1H
	ja	SHORT $LN22@omf_write_@2

; 402  :                 break;
; 403  :             data += OmfFixGenFix( fix, seg->e.seginfo->start_loc, data, type );

	mov	rax, QWORD PTR [rbp+104]
	mov	r9d, r12d
	mov	r8, rsi
	mov	edx, DWORD PTR [rax+8]
	mov	rcx, rbx
	call	OmfFixGenFix

; 404  :             size = (char *)data - StringBufferEnd;

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	r11d, eax
	add	rsi, r11
	mov	ecx, esi
	sub	ecx, edx
$LN10@omf_write_@2:
	mov	rbx, QWORD PTR [rbx+8]
	test	rbx, rbx
	jne	SHORT $LL11@omf_write_@2
$LN22@omf_write_@2:

; 405  :         }
; 406  :         if ( size ) {

	test	ecx, ecx
	je	SHORT $LN1@omf_write_@2

; 407  :             omf_InitRec( &obj, CMD_FIXUPP );
; 408  :             obj.is_32 = is32;
; 409  :             AttachData( &obj, StringBufferEnd, size );

	mov	DWORD PTR obj$[rsp], ecx

; 410  :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	DWORD PTR obj$[rsp+4], r13d
	mov	BYTE PTR obj$[rsp+16], 156		; 0000009cH
	mov	BYTE PTR obj$[rsp+17], dil
	mov	QWORD PTR obj$[rsp+8], rdx
	call	omf_write_record
	mov	rdx, QWORD PTR ModuleInfo+488
$LN1@omf_write_@2:

; 389  :     while ( fix ) {

	test	rbx, rbx
	jne	$LL13@omf_write_@2
$LN26@omf_write_@2:
	mov	rsi, QWORD PTR [rsp+128]
$LN25@omf_write_@2:
	mov	r13, QWORD PTR [rsp+88]
	mov	r12, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+136]
	mov	rbp, QWORD PTR [rsp+120]
	mov	rbx, QWORD PTR [rsp+112]

; 411  :         }
; 412  :     }
; 413  : }

	add	rsp, 104				; 00000068H
	ret	0
omf_write_fixupp ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$omf_write_theadr DD 020601H
	DD	070029206H
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_theadr DD @imagerel(omf_write_theadr#)
	DD	@imagerel(omf_write_theadr#+119)
	DD	@imagerel($unwind$omf_write_theadr#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
obj$ = 32
name$ = 96
omf_write_theadr PROC NEAR

; 525  : {

	push	rdi
	sub	rsp, 80					; 00000050H

; 526  :     struct omf_rec obj;
; 527  :     unsigned    len;
; 528  :     //const struct fname_item *fn;
; 529  : 
; 530  :     DebugMsg1(("omf_write_theadr(%s) enter\n", name));
; 531  : 
; 532  :     omf_InitRec( &obj, CMD_THEADR );
; 533  : 
; 534  :     /* v2.08: use the name given at the cmdline, that's what Masm does.
; 535  :      * Masm emits either a relative or a full path, depending on what
; 536  :      * was given as filename!
; 537  :      */
; 538  :     len = strlen( name );
; 539  :     AttachData( &obj, StringBufferEnd, len + 1 );

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	r9, rcx
	xor	eax, eax
	mov	DWORD PTR obj$[rsp+4], 0
	mov	QWORD PTR obj$[rsp+8], rdx
	mov	rdi, r9
	mov	BYTE PTR obj$[rsp+16], 128		; 00000080H
	mov	BYTE PTR obj$[rsp+17], 0
	mov	rcx, -1
	repne scasb
	not	rcx
	dec	rcx

; 540  :     PutName( &obj, name, len );

	mov	edi, ecx
	lea	eax, DWORD PTR [rcx+1]
	mov	r8, rdi
	mov	DWORD PTR obj$[rsp], eax
	mov	BYTE PTR [rdx], dil
	mov	eax, DWORD PTR obj$[rsp+4]
	inc	eax
	mov	rdx, r9
	mov	ecx, eax
	mov	DWORD PTR obj$[rsp+4], eax
	add	rcx, QWORD PTR obj$[rsp+8]
	call	memcpy
	add	DWORD PTR obj$[rsp+4], edi

; 541  :     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record

; 542  : 
; 543  :     DebugMsg1(("omf_write_theadr() exit\n"));
; 544  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
omf_write_theadr ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$omf_end_of_pass1 DD 010401H
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$omf_end_of_pass1 DD @imagerel(omf_end_of_pass1#)
	DD	@imagerel(omf_end_of_pass1#+67)
	DD	@imagerel($unwind$omf_end_of_pass1#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
obj$ = 32
omf_end_of_pass1 PROC NEAR

; 606  : {

	sub	rsp, 88					; 00000058H

; 607  :     struct omf_rec obj;
; 608  : 
; 609  :     omf_InitRec( &obj, CMD_COMENT );
; 610  :     obj.d.coment.attr = 0x00;
; 611  :     obj.d.coment.cmt_class = CMT_MS_END_PASS_1;
; 612  :     AttachData( &obj, (uint_8 *)"\x001", 1 );

	lea	rax, OFFSET FLAT:$SG6463

; 613  :     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	DWORD PTR obj$[rsp+4], 0
	mov	BYTE PTR obj$[rsp+16], 136		; 00000088H
	mov	BYTE PTR obj$[rsp+17], 0
	mov	BYTE PTR obj$[rsp+20], 0
	mov	QWORD PTR obj$[rsp+8], rax
	mov	BYTE PTR obj$[rsp+21], 162		; 000000a2H
	mov	DWORD PTR obj$[rsp], 1
	call	omf_write_record

; 614  : }

	add	rsp, 88					; 00000058H
	ret	0
omf_end_of_pass1 ENDP
_TEXT	ENDS
PUBLIC	omf_set_filepos
EXTRN	fseek:NEAR
_BSS	SEGMENT
end_of_header DD 01H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
_TEXT	SEGMENT
omf_set_filepos PROC NEAR

; 623  :     DebugMsg1(( "omf_set_filepos: reset file pos to %X\n", end_of_header ));
; 624  : #if MULTIHDR
; 625  : #endif
; 626  :     fseek( CurrFile[OBJ], end_of_header, SEEK_SET );

	mov	edx, DWORD PTR end_of_header
	mov	rcx, QWORD PTR ModuleInfo+104
	xor	r8d, r8d

; 627  : }

	jmp	fseek
omf_set_filepos ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$omf_write_dosseg DD 010401H
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_dosseg DD @imagerel(omf_write_dosseg#)
	DD	@imagerel(omf_write_dosseg#+60)
	DD	@imagerel($unwind$omf_write_dosseg#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
obj$ = 32
omf_write_dosseg PROC NEAR

; 631  : {

	sub	rsp, 88					; 00000058H

; 632  :     struct omf_rec obj;
; 633  : 
; 634  :     omf_InitRec( &obj, CMD_COMENT );

	xor	ecx, ecx

; 635  :     obj.d.coment.attr = CMT_TNP;
; 636  :     obj.d.coment.cmt_class = CMT_DOSSEG;
; 637  :     AttachData( &obj, (uint_8 *)"", 0 );

	lea	rax, OFFSET FLAT:$SG6471
	mov	BYTE PTR obj$[rsp+16], 136		; 00000088H
	mov	DWORD PTR obj$[rsp+4], ecx
	mov	BYTE PTR obj$[rsp+17], cl
	mov	DWORD PTR obj$[rsp], ecx

; 638  :     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	BYTE PTR obj$[rsp+20], 128		; 00000080H
	mov	BYTE PTR obj$[rsp+21], 158		; 0000009eH
	mov	QWORD PTR obj$[rsp+8], rax
	call	omf_write_record

; 639  : }

	add	rsp, 88					; 00000058H
	ret	0
omf_write_dosseg ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$omf_write_lib DD 010401H
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_lib DD @imagerel(omf_write_lib#)
	DD	@imagerel(omf_write_lib#+20)
	DD	@imagerel($unwind$omf_write_lib#)
pdata	ENDS
xdata	SEGMENT
$chain$2$omf_write_lib DD 060f21H
	DD	0f740fH
	DD	0d340aH
	DD	0e6405H
	DD	@imagerel(omf_write_lib#)
	DD	@imagerel(omf_write_lib#+20)
	DD	@imagerel($unwind$omf_write_lib#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$omf_write_lib DD @imagerel(omf_write_lib#+20)
	DD	@imagerel(omf_write_lib#+150)
	DD	@imagerel($chain$2$omf_write_lib#)
pdata	ENDS
xdata	SEGMENT
$chain$3$omf_write_lib DD 021H
	DD	@imagerel(omf_write_lib#)
	DD	@imagerel(omf_write_lib#+20)
	DD	@imagerel($unwind$omf_write_lib#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$omf_write_lib DD @imagerel(omf_write_lib#+150)
	DD	@imagerel(omf_write_lib#+155)
	DD	@imagerel($chain$3$omf_write_lib#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
obj$ = 32
omf_write_lib PROC NEAR

; 643  : {

	sub	rsp, 88					; 00000058H

; 644  :     struct omf_rec      obj;
; 645  :     struct qitem        *curr;
; 646  :     struct qitem        *next;
; 647  :     char                *name;
; 648  : 
; 649  :     DebugMsg1(("omf_write_lib() enter\n"));
; 650  :     for( curr = ModuleInfo.g.LibQueue.head; curr; curr = next ) {

	mov	rdx, QWORD PTR ModuleInfo+64
	test	rdx, rdx
	je	$LN1@omf_write_@3
	mov	QWORD PTR [rsp+112], rsi
	mov	QWORD PTR [rsp+104], rbx
	mov	QWORD PTR [rsp+120], rdi
	xor	esi, esi
	npad	11
$LL3@omf_write_@3:

; 651  :         next = curr->next;

	mov	rbx, QWORD PTR [rdx]

; 652  :         name = curr->value;

	add	rdx, 8

; 653  :         omf_InitRec( &obj, CMD_COMENT );

	mov	DWORD PTR obj$[rsp], esi
	mov	QWORD PTR obj$[rsp+8], rsi

; 654  :         obj.d.coment.attr = CMT_TNP;
; 655  :         obj.d.coment.cmt_class = CMT_DEFAULT_LIBRARY;
; 656  :         AttachData( &obj, (uint_8 *)name, strlen( name ) );

	mov	rdi, rdx
	xor	eax, eax
	mov	DWORD PTR obj$[rsp+4], esi
	mov	BYTE PTR obj$[rsp+16], 136		; 00000088H
	mov	BYTE PTR obj$[rsp+17], sil
	mov	BYTE PTR obj$[rsp+20], 128		; 00000080H
	mov	BYTE PTR obj$[rsp+21], 159		; 0000009fH
	mov	rcx, -1
	repne scasb
	mov	QWORD PTR obj$[rsp+8], rdx
	not	rcx
	dec	rcx
	mov	DWORD PTR obj$[rsp], ecx

; 657  :         omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record
	test	rbx, rbx
	mov	rdx, rbx
	jne	SHORT $LL3@omf_write_@3
	mov	rdi, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [rsp+104]
$LN1@omf_write_@3:

; 658  :     }
; 659  :     DebugMsg1(("omf_write_lib() exit\n"));
; 660  : }

	add	rsp, 88					; 00000058H
	ret	0
omf_write_lib ENDP
_TEXT	ENDS
EXTRN	_strupr:NEAR
EXTRN	Mangle:NEAR
EXTRN	Options:BYTE
EXTRN	SymTables:BYTE
xdata	SEGMENT
$unwind$omf_write_export DD 030901H
	DD	0c3409H
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_export DD @imagerel(omf_write_export#)
	DD	@imagerel(omf_write_export#+25)
	DD	@imagerel($unwind$omf_write_export#)
pdata	ENDS
xdata	SEGMENT
$chain$4$omf_write_export DD 081421H
	DD	0f7414H
	DD	0e640fH
	DD	0d540aH
	DD	0ac405H
	DD	@imagerel(omf_write_export#)
	DD	@imagerel(omf_write_export#+25)
	DD	@imagerel($unwind$omf_write_export#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$omf_write_export DD @imagerel(omf_write_export#+25)
	DD	@imagerel(omf_write_export#+368)
	DD	@imagerel($chain$4$omf_write_export#)
pdata	ENDS
xdata	SEGMENT
$chain$5$omf_write_export DD 021H
	DD	@imagerel(omf_write_export#)
	DD	@imagerel(omf_write_export#+25)
	DD	@imagerel($unwind$omf_write_export#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$omf_write_export DD @imagerel(omf_write_export#+368)
	DD	@imagerel(omf_write_export#+378)
	DD	@imagerel($chain$5$omf_write_export#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
obj$ = 32
omf_write_export PROC NEAR

; 717  : {

	sub	rsp, 88					; 00000058H
	mov	QWORD PTR [rsp+96], rbx

; 718  :     uint_8      parmcnt;
; 719  :     struct dsym *dir;
; 720  :     struct dsym *parm;
; 721  :     struct omf_rec obj;
; 722  :     int         len;
; 723  :     uint_8      *data;
; 724  : 
; 725  : #if DLLIMPORT && WRITEIMPDEF /* writing import records in OMF not supported yet */
; 726  :     omf_write_import();
; 727  : #endif
; 728  : 
; 729  :     for( dir = SymTables[TAB_PROC].head; dir != NULL; dir = dir->nextproc ) {

	mov	rbx, QWORD PTR SymTables+64
	test	rbx, rbx
	je	$LN8@omf_write_@4
	mov	QWORD PTR [rsp+80], r12
	mov	QWORD PTR [rsp+104], rbp
	mov	QWORD PTR [rsp+112], rsi
	mov	QWORD PTR [rsp+120], rdi
	xor	r12d, r12d
$LL10@omf_write_@4:

; 730  :         if( dir->e.procinfo->isexport ) {

	mov	rax, QWORD PTR [rbx+104]
	test	BYTE PTR [rax+128], 4
	je	$LN9@omf_write_@4

; 731  : 
; 732  :             omf_InitRec( &obj, CMD_COMENT );
; 733  :             obj.d.coment.attr = 0x00;
; 734  :             obj.d.coment.cmt_class = CMT_OMF_EXT;
; 735  :             data = StringBufferEnd;
; 736  : 
; 737  :             /* structure of EXPDEF "comment":
; 738  :              * type          db CMT_EXT_EXPDEF (=02)
; 739  :              * exported_flag db ?
; 740  :              * ex_name_len   db ?
; 741  :              * exported_name db ex_name_len dup (?)
; 742  :              * int_name_len  db 0     ;always 0
; 743  :              * ;internal_name db int_name_len dup (?)
; 744  :              * ;ordinal      dw ?     ;optional
; 745  :              */
; 746  :             if ( Options.no_export_decoration == FALSE )

	cmp	BYTE PTR Options+127, r12b
	mov	rsi, QWORD PTR ModuleInfo+488
	mov	DWORD PTR obj$[rsp], r12d
	mov	DWORD PTR obj$[rsp+4], r12d
	mov	QWORD PTR obj$[rsp+8], r12
	mov	BYTE PTR obj$[rsp+16], 136		; 00000088H
	mov	BYTE PTR obj$[rsp+17], r12b
	mov	BYTE PTR obj$[rsp+20], r12b
	mov	BYTE PTR obj$[rsp+21], 160		; 000000a0H
	jne	SHORT $LN6@omf_write_@4

; 747  :                 len = Mangle( &dir->sym, data+3 );

	lea	rdi, QWORD PTR [rsi+3]
	mov	rcx, rbx
	mov	rdx, rdi
	call	Mangle
	mov	ebp, eax

; 748  :             else {

	jmp	SHORT $LN5@omf_write_@4
$LN6@omf_write_@4:

; 749  :                 strcpy( data+3, dir->sym.name );

	mov	rdx, QWORD PTR [rbx+8]
	lea	rdi, QWORD PTR [rsi+3]
	mov	r8, rdi
	npad	14
$LL13@omf_write_@4:
	movzx	eax, BYTE PTR [rdx]
	inc	r8
	inc	rdx
	test	al, al
	mov	BYTE PTR [r8-1], al
	jne	SHORT $LL13@omf_write_@4

; 750  :                 len = dir->sym.name_size;

	movzx	ebp, BYTE PTR [rbx+80]
$LN5@omf_write_@4:

; 751  :             }
; 752  :             /* v2.11: case mapping was missing */
; 753  :             if ( ModuleInfo.convert_uppercase )

	test	BYTE PTR ModuleInfo+408, 4
	je	SHORT $LN4@omf_write_@4

; 754  :                 _strupr( data+3 );

	mov	rcx, rdi
	call	_strupr
$LN4@omf_write_@4:

; 755  : #if MAX_ID_LEN > 255
; 756  :             if ( len > 255 )
; 757  :                 len = 255; /* restrict name to 255 chars */
; 758  : #endif
; 759  :             AttachData( &obj, data, len + 4 );

	mov	QWORD PTR obj$[rsp+8], rsi
	lea	eax, DWORD PTR [rbp+4]

; 760  :             Put8( &obj, CMT_EXT_EXPDEF );
; 761  :             /* write the "Exported Flag" byte:
; 762  :              * bits 0-4: parameter count
; 763  :              * bit 5: no data (entry doesn't use initialized data )
; 764  :              * bit 6: resident (name should be kept resident)
; 765  :              * bit 7: ordinal ( if 1, 2 byte index must follow name)
; 766  :              */
; 767  :             for ( parm = dir->e.procinfo->paralist, parmcnt = 0; parm; parm = parm->nextparam, parmcnt++ );

	xor	dl, dl
	mov	DWORD PTR obj$[rsp], eax
	mov	eax, DWORD PTR obj$[rsp+4]
	mov	BYTE PTR [rax+rsi], 2
	mov	r8d, DWORD PTR obj$[rsp+4]
	inc	r8d
	mov	DWORD PTR obj$[rsp+4], r8d
	mov	rax, QWORD PTR [rbx+104]
	mov	rcx, QWORD PTR [rax+8]
	test	rcx, rcx
	je	SHORT $LN1@omf_write_@4
	npad	10
$LL3@omf_write_@4:
	mov	rcx, QWORD PTR [rcx+120]
	inc	dl
	test	rcx, rcx
	jne	SHORT $LL3@omf_write_@4
$LN1@omf_write_@4:

; 768  :             parmcnt &= 0x1F; /* ensure bits 5-7 are still 0 */
; 769  :             Put8( &obj, parmcnt ); /* v2.01: changed from fix 0x00 */

	mov	rax, QWORD PTR obj$[rsp+8]
	and	dl, 31
	mov	BYTE PTR [r8+rax], dl
	mov	eax, DWORD PTR obj$[rsp+4]
	inc	eax

; 770  :             Put8( &obj, len );

	mov	ecx, eax
	mov	DWORD PTR obj$[rsp+4], eax
	mov	rax, QWORD PTR obj$[rsp+8]
	mov	BYTE PTR [rcx+rax], bpl

; 771  :             obj.curoff += len;

	mov	eax, DWORD PTR obj$[rsp+4]
	lea	ecx, DWORD PTR [rax+rbp+1]

; 772  :             Put8( &obj, 0 );

	mov	rax, QWORD PTR obj$[rsp+8]
	mov	DWORD PTR obj$[rsp+4], ecx
	mov	BYTE PTR [rcx+rax], r12b
	inc	DWORD PTR obj$[rsp+4]

; 773  :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record
$LN9@omf_write_@4:
	mov	rbx, QWORD PTR [rbx+120]
	test	rbx, rbx
	jne	$LL10@omf_write_@4
	mov	r12, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+104]
$LN8@omf_write_@4:
	mov	rbx, QWORD PTR [rsp+96]

; 774  :         }
; 775  :     }
; 776  : }

	add	rsp, 88					; 00000058H
	ret	0
omf_write_export ENDP
_TEXT	ENDS
EXTRN	EmitWarn:NEAR
xdata	SEGMENT
$unwind$omf_write_grpdef DD 030901H
	DD	0e3409H
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_grpdef DD @imagerel(omf_write_grpdef#)
	DD	@imagerel(omf_write_grpdef#+25)
	DD	@imagerel($unwind$omf_write_grpdef#)
pdata	ENDS
xdata	SEGMENT
$chain$1$omf_write_grpdef DD 020521H
	DD	0f7405H
	DD	@imagerel(omf_write_grpdef#)
	DD	@imagerel(omf_write_grpdef#+25)
	DD	@imagerel($unwind$omf_write_grpdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$omf_write_grpdef DD @imagerel(omf_write_grpdef#+25)
	DD	@imagerel(omf_write_grpdef#+332)
	DD	@imagerel($chain$1$omf_write_grpdef#)
pdata	ENDS
xdata	SEGMENT
$chain$2$omf_write_grpdef DD 021H
	DD	@imagerel(omf_write_grpdef#)
	DD	@imagerel(omf_write_grpdef#+25)
	DD	@imagerel($unwind$omf_write_grpdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$omf_write_grpdef DD @imagerel(omf_write_grpdef#+332)
	DD	@imagerel(omf_write_grpdef#+342)
	DD	@imagerel($chain$2$omf_write_grpdef#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
grp$ = 32
omf_write_grpdef PROC NEAR

; 783  : {

	sub	rsp, 88					; 00000058H
	mov	QWORD PTR [rsp+112], rbx

; 784  :     struct dsym     *curr;
; 785  :     struct dsym     *segminfo;
; 786  :     struct seg_item *seg;
; 787  :     struct omf_rec  grp;
; 788  :     //char            writeseg;
; 789  : 
; 790  :     DebugMsg1(("omf_write_grpdef enter\n"));
; 791  :     //line_num = LineNumber;
; 792  : 
; 793  :     /* size of group records may exceed 1024! */
; 794  :     for( curr = SymTables[TAB_GRP].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+48
	test	rbx, rbx
	je	$LN5@omf_write_@5
	mov	QWORD PTR [rsp+120], rdi
	xor	edi, edi
$LL7@omf_write_@5:

; 795  : 
; 796  :         omf_InitRec( &grp, CMD_GRPDEF );
; 797  : 
; 798  :         grp.d.grpdef.idx = curr->e.grpinfo->grp_idx;
; 799  : 
; 800  :         /* we might need:
; 801  :          * - 1 or 2 bytes for the group name index
; 802  :          * - 2 or 3 bytes for each segment in the group
; 803  :          */
; 804  :         AttachData( &grp, StringBufferEnd, 2 + 3 * curr->e.grpinfo->numseg );

	mov	r8, QWORD PTR ModuleInfo+488
	mov	DWORD PTR grp$[rsp], edi
	mov	QWORD PTR grp$[rsp+8], rdi
	mov	DWORD PTR grp$[rsp+4], edi
	mov	BYTE PTR grp$[rsp+16], 154		; 0000009aH
	mov	edx, edi
	mov	BYTE PTR grp$[rsp+17], dl
	mov	rax, QWORD PTR [rbx+104]
	movzx	ecx, WORD PTR [rax+8]
	mov	WORD PTR grp$[rsp+20], cx
	mov	rax, QWORD PTR [rbx+104]
	mov	ecx, DWORD PTR [rax+16]
	mov	QWORD PTR grp$[rsp+8], r8
	lea	ecx, DWORD PTR [rcx+rcx*2+2]
	mov	DWORD PTR grp$[rsp], ecx

; 805  :         /* v2.01: the LName index of the group may be > 0xff */
; 806  :         /* v2.03: use the group index directly */
; 807  :         PutIndex( &grp, curr->e.grpinfo->lname_idx );

	mov	rax, QWORD PTR [rbx+104]
	mov	ecx, DWORD PTR [rax+12]
	cmp	ecx, 127				; 0000007fH
	jbe	SHORT $LN14@omf_write_@5
	mov	eax, ecx
	shr	eax, 8
	or	al, 128					; 00000080H
	mov	BYTE PTR [r8], al
	mov	edx, DWORD PTR grp$[rsp+4]
	mov	r8, QWORD PTR grp$[rsp+8]
	inc	edx
	mov	DWORD PTR grp$[rsp+4], edx
$LN14@omf_write_@5:
	mov	eax, edx
	mov	BYTE PTR [rax+r8], cl
	mov	ecx, DWORD PTR grp$[rsp+4]
	inc	ecx
	mov	DWORD PTR grp$[rsp+4], ecx

; 808  : 
; 809  :         for( seg = curr->e.grpinfo->seglist; seg; seg = seg->next ) {

	mov	rax, QWORD PTR [rbx+104]
	mov	r8, QWORD PTR [rax]
	test	r8, r8
	je	$LN2@omf_write_@5
	npad	11
$LL4@omf_write_@5:

; 810  :             //writeseg = TRUE;
; 811  :             segminfo = (struct dsym *)(seg->seg);

	mov	rdx, QWORD PTR [r8+8]

; 812  :             Put8( &grp, GRP_SEGIDX );

	mov	rax, QWORD PTR grp$[rsp+8]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
	mov	ecx, DWORD PTR grp$[rsp+4]
	inc	ecx
	mov	DWORD PTR grp$[rsp+4], ecx

; 813  :             PutIndex( &grp, segminfo->e.seginfo->seg_idx );

	mov	rax, QWORD PTR [rdx+104]
	mov	r9d, DWORD PTR [rax+68]
	cmp	r9d, 127				; 0000007fH
	jbe	SHORT $LN19@omf_write_@5
	mov	rax, QWORD PTR grp$[rsp+8]
	mov	edx, r9d
	shr	edx, 8
	or	dl, 128					; 00000080H
	mov	BYTE PTR [rcx+rax], dl
	mov	ecx, DWORD PTR grp$[rsp+4]
	inc	ecx
	mov	DWORD PTR grp$[rsp+4], ecx
$LN19@omf_write_@5:
	mov	rax, QWORD PTR grp$[rsp+8]
	mov	BYTE PTR [rcx+rax], r9b
	mov	ecx, DWORD PTR grp$[rsp+4]
	inc	ecx

; 814  :             /* truncate the group record if it comes near output buffer limit! */
; 815  :             if ( grp.curoff > OBJ_BUFFER_SIZE - 10 ) {

	cmp	ecx, 4070				; 00000fe6H
	mov	DWORD PTR grp$[rsp+4], ecx
	ja	SHORT $LN24@omf_write_@5
	mov	r8, QWORD PTR [r8]
	test	r8, r8
	jne	SHORT $LL4@omf_write_@5
	jmp	SHORT $LN2@omf_write_@5
$LN24@omf_write_@5:

; 816  :                 EmitWarn( 2, GROUP_DEFINITION_TOO_LARGE, curr->sym.name );

	mov	r8, QWORD PTR [rbx+8]
	mov	edx, 267				; 0000010bH
	mov	ecx, 2
	call	EmitWarn
	mov	ecx, DWORD PTR grp$[rsp+4]
$LN2@omf_write_@5:

; 817  :                 break;
; 818  :             }
; 819  :         }
; 820  :         TruncRec( &grp );

	mov	DWORD PTR grp$[rsp], ecx

; 821  :         omf_write_record( &grp );

	lea	rcx, QWORD PTR grp$[rsp]
	call	omf_write_record
	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	$LL7@omf_write_@5
	mov	rdi, QWORD PTR [rsp+120]
$LN5@omf_write_@5:
	mov	rbx, QWORD PTR [rsp+112]

; 822  :     }
; 823  :     DebugMsg1(("omf_write_grpdef exit\n"));
; 824  : }

	add	rsp, 88					; 00000058H
	ret	0
omf_write_grpdef ENDP
; Function compile flags: /Ogtpy
alignment$ = 8
get_omfalign PROC NEAR

; 829  :     switch ( alignment ) {

	movzx	edx, cl
	dec	edx
	je	SHORT $LN5@get_omfali
	dec	edx
	je	SHORT $LN4@get_omfali
	sub	edx, 2
	je	SHORT $LN3@get_omfali
	sub	edx, 4
	je	SHORT $LN2@get_omfali
	cmp	edx, 247				; 000000f7H
	je	SHORT $LN1@get_omfali

; 841  :     }
; 842  :     /* value 0 is byte alignment, anything elso is "unexpected" */
; 843  :     /**/myassert( alignment == 0 );
; 844  :     return( SEGDEF_ALIGN_BYTE );

	mov	al, 1

; 845  : }

	ret	0
$LN1@get_omfali:

; 834  : #if PAGE4K /* PharLab peculiarity; this is invalid for MS OMF */
; 835  :     case 12:
; 836  :         if ( Parse_Pass == PASS_1 )
; 837  :             EmitWarn( 2, NO_4KPAGE_ALIGNED_SEGMENTS_IN_MS386 );
; 838  :         return( SEGDEF_ALIGN_4KPAGE );
; 839  : #endif
; 840  :     case MAX_SEGALIGNMENT: return( SEGDEF_ALIGN_ABS );

	xor	al, al

; 845  : }

	ret	0
$LN2@get_omfali:

; 833  :     case  8:  return( SEGDEF_ALIGN_PAGE );

	mov	al, 4

; 845  : }

	ret	0
$LN3@get_omfali:

; 832  :     case  4:  return( SEGDEF_ALIGN_PARA );

	mov	al, 3

; 845  : }

	ret	0
$LN4@get_omfali:

; 831  :     case  2:  return( SEGDEF_ALIGN_DWORD );

	mov	al, 5

; 845  : }

	ret	0
$LN5@get_omfali:

; 830  :     case  1:  return( SEGDEF_ALIGN_WORD );

	mov	al, 2

; 845  : }

	ret	0
get_omfalign ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$omf_write_segdef DD 030901H
	DD	0e3409H
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_segdef DD @imagerel(omf_write_segdef#)
	DD	@imagerel(omf_write_segdef#+25)
	DD	@imagerel($unwind$omf_write_segdef#)
pdata	ENDS
xdata	SEGMENT
$chain$1$omf_write_segdef DD 020521H
	DD	0f7405H
	DD	@imagerel(omf_write_segdef#)
	DD	@imagerel(omf_write_segdef#+25)
	DD	@imagerel($unwind$omf_write_segdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$omf_write_segdef DD @imagerel(omf_write_segdef#+25)
	DD	@imagerel(omf_write_segdef#+459)
	DD	@imagerel($chain$1$omf_write_segdef#)
pdata	ENDS
xdata	SEGMENT
$chain$2$omf_write_segdef DD 021H
	DD	@imagerel(omf_write_segdef#)
	DD	@imagerel(omf_write_segdef#+25)
	DD	@imagerel($unwind$omf_write_segdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$omf_write_segdef DD @imagerel(omf_write_segdef#+459)
	DD	@imagerel(omf_write_segdef#+469)
	DD	@imagerel($chain$2$omf_write_segdef#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
obj$ = 32
buffer$6544 = 96
omf_write_segdef PROC NEAR

; 855  : {

	sub	rsp, 88					; 00000058H
	mov	QWORD PTR [rsp+112], rbx

; 856  :     struct dsym    *curr;
; 857  :     struct omf_rec obj;
; 858  : 
; 859  :     DebugMsg1(("omf_write_segdef enter\n"));
; 860  : 
; 861  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+32
	test	rbx, rbx
	je	$LN5@omf_write_@6
	mov	QWORD PTR [rsp+120], rdi
	xor	edi, edi
$LL7@omf_write_@6:

; 862  : 
; 863  : #if COMDATSUPP
; 864  :         if ( curr->e.seginfo->comdat_selection )

	mov	rax, QWORD PTR [rbx+104]
	test	BYTE PTR [rax+108], 56			; 00000038H
	jne	$LN6@omf_write_@6

; 865  :             continue;
; 866  : #endif
; 867  :         omf_InitRec( &obj, CMD_SEGDEF );

	mov	DWORD PTR obj$[rsp], edi
	mov	DWORD PTR obj$[rsp+4], edi
	mov	QWORD PTR obj$[rsp+8], rdi
	mov	BYTE PTR obj$[rsp+16], 152		; 00000098H
	mov	BYTE PTR obj$[rsp+17], dil

; 868  :         if ( curr->e.seginfo->Ofssize > USE16 ) {

	mov	rax, QWORD PTR [rbx+104]
	cmp	BYTE PTR [rax+104], dil
	jbe	SHORT $LN3@omf_write_@6

; 869  :             obj.is_32 = ( ( curr->e.seginfo->force32 || ( curr->sym.max_offset >= 0x10000 ) ) ? 1 : 0 );

	test	BYTE PTR [rax+107], 4
	jne	SHORT $LN10@omf_write_@6
	cmp	DWORD PTR [rbx+64], 65536		; 00010000H
	jge	SHORT $LN10@omf_write_@6
	mov	BYTE PTR obj$[rsp+17], dil
	jmp	SHORT $LN2@omf_write_@6
$LN10@omf_write_@6:
	mov	BYTE PTR obj$[rsp+17], 1

; 870  :         } else {

	jmp	SHORT $LN2@omf_write_@6
$LN3@omf_write_@6:

; 871  :             obj.is_32 = 0;

	mov	BYTE PTR obj$[rsp+17], dil
$LN2@omf_write_@6:

; 872  :         }
; 873  : 
; 874  :         obj.d.segdef.idx             = curr->e.seginfo->seg_idx;

	mov	rax, QWORD PTR [rbx+104]
	movzx	ecx, WORD PTR [rax+68]
	mov	WORD PTR obj$[rsp+20], cx

; 875  :         obj.d.segdef.use_32          = ( curr->e.seginfo->Ofssize > USE16 ? 1 : 0 );

	mov	rax, QWORD PTR [rbx+104]
	cmp	BYTE PTR [rax+104], dil
	seta	BYTE PTR obj$[rsp+22]

; 876  :         obj.d.segdef.align           = get_omfalign( curr->e.seginfo->alignment );

	mov	rax, QWORD PTR [rbx+104]
	movzx	ecx, BYTE PTR [rax+106]
	dec	ecx
	je	SHORT $LN20@omf_write_@6
	dec	ecx
	je	SHORT $LN19@omf_write_@6
	sub	ecx, 2
	je	SHORT $LN18@omf_write_@6
	sub	ecx, 4
	je	SHORT $LN17@omf_write_@6
	cmp	ecx, 247				; 000000f7H
	je	SHORT $LN16@omf_write_@6
	mov	al, 1
	jmp	SHORT $LN23@omf_write_@6
$LN16@omf_write_@6:
	xor	al, al
	jmp	SHORT $LN23@omf_write_@6
$LN17@omf_write_@6:
	mov	al, 4
	jmp	SHORT $LN23@omf_write_@6
$LN18@omf_write_@6:
	mov	al, 3
	jmp	SHORT $LN23@omf_write_@6
$LN19@omf_write_@6:
	mov	al, 5
	jmp	SHORT $LN23@omf_write_@6
$LN20@omf_write_@6:
	mov	al, 2
$LN23@omf_write_@6:
	mov	BYTE PTR obj$[rsp+23], al

; 877  :         obj.d.segdef.combine         = curr->e.seginfo->combine;

	mov	rax, QWORD PTR [rbx+104]
	movzx	ecx, BYTE PTR [rax+108]
	and	cl, 7
	mov	BYTE PTR obj$[rsp+24], cl

; 878  :         obj.d.segdef.abs.frame       = curr->e.seginfo->abs_frame;

	mov	rax, QWORD PTR [rbx+104]
	movzx	ecx, WORD PTR [rax+88]
	mov	WORD PTR obj$[rsp+28], cx

; 879  :         obj.d.segdef.abs.offset      = curr->e.seginfo->abs_offset;

	mov	rax, QWORD PTR [rbx+104]
	mov	ecx, DWORD PTR [rax+96]
	mov	DWORD PTR obj$[rsp+32], ecx

; 880  :         obj.d.segdef.seg_length      = curr->sym.max_offset;

	mov	eax, DWORD PTR [rbx+64]
	mov	DWORD PTR obj$[rsp+36], eax

; 881  :         obj.d.segdef.seg_lname_idx   = curr->e.seginfo->lname_idx;

	mov	rax, QWORD PTR [rbx+104]
	movzx	ecx, WORD PTR [rax+76]
	mov	WORD PTR obj$[rsp+40], cx

; 882  :         obj.d.segdef.class_lname_idx = ( curr->e.seginfo->clsym ? curr->e.seginfo->clsym->class_lname_idx : 1 );

	mov	rax, QWORD PTR [rbx+104]
	cmp	QWORD PTR [rax+80], rdi
	je	SHORT $LN12@omf_write_@6
	mov	rcx, QWORD PTR [rax+80]
	movzx	eax, WORD PTR [rcx+16]
	mov	WORD PTR obj$[rsp+42], ax
	jmp	SHORT $LN13@omf_write_@6
$LN12@omf_write_@6:
	mov	WORD PTR obj$[rsp+42], 1
$LN13@omf_write_@6:

; 883  :         obj.d.segdef.ovl_lname_idx   = 1;
; 884  : 
; 885  :         omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	WORD PTR obj$[rsp+44], 1
	call	omf_write_record

; 886  :         DebugMsg1(("omf_write_segdef(%s): len=%" I32_SPEC "X use32=%u align=%u comb=%u seg_lname=%u class_lname=%u ovl_lname=%u\n",
; 887  :                   curr->sym.name,
; 888  :                   obj.d.segdef.seg_length,
; 889  :                   obj.d.segdef.use_32,
; 890  :                   obj.d.segdef.align,
; 891  :                   obj.d.segdef.combine,
; 892  :                   obj.d.segdef.seg_lname_idx,
; 893  :                   obj.d.segdef.class_lname_idx,
; 894  :                   obj.d.segdef.ovl_lname_idx
; 895  :                  ));
; 896  :         /* write a comment for the linker.
; 897  :          * this is something not done by Masm, it has
; 898  :          * been inherited from Wasm.
; 899  :          */
; 900  :         if( curr->e.seginfo->segtype == SEGTYPE_CODE && Options.no_opt_farcall == FALSE ) {

	mov	r11, QWORD PTR [rbx+104]
	cmp	DWORD PTR [r11+72], 1
	jne	SHORT $LN6@omf_write_@6
	cmp	BYTE PTR Options+121, dil
	jne	SHORT $LN6@omf_write_@6

; 901  :             uint_8 buffer[4];
; 902  :             omf_InitRec( &obj, CMD_COMENT );
; 903  :             obj.d.coment.attr = CMT_TNP;
; 904  :             obj.d.coment.cmt_class = CMT_LINKER_DIRECTIVE;
; 905  :             AttachData( &obj, buffer, 3 );

	lea	rax, QWORD PTR buffer$6544[rsp]
	mov	BYTE PTR obj$[rsp+16], 136		; 00000088H
	mov	BYTE PTR obj$[rsp+17], dil
	mov	BYTE PTR obj$[rsp+20], 128		; 00000080H
	mov	BYTE PTR obj$[rsp+21], 254		; 000000feH
	mov	DWORD PTR obj$[rsp], 3
	mov	QWORD PTR obj$[rsp+8], rax

; 906  :             Put8( &obj, LDIR_OPT_FAR_CALLS );

	mov	ecx, 1
	mov	BYTE PTR buffer$6544[rsp], 79		; 0000004fH
	mov	DWORD PTR obj$[rsp+4], ecx

; 907  :             PutIndex( &obj, curr->e.seginfo->seg_idx );

	mov	rax, QWORD PTR [rbx+104]
	mov	edx, DWORD PTR [rax+68]
	cmp	edx, 127				; 0000007fH
	jbe	SHORT $LN31@omf_write_@6
	mov	eax, edx
	mov	ecx, 2
	shr	eax, 8
	mov	DWORD PTR obj$[rsp+4], ecx
	or	al, 128					; 00000080H
	mov	BYTE PTR buffer$6544[rsp+1], al
$LN31@omf_write_@6:
	mov	eax, ecx

; 908  :             /* v2.04: added. cut off the 3. byte if not needed */
; 909  :             TruncRec( &obj );
; 910  :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	BYTE PTR buffer$6544[rsp+rax], dl
	mov	eax, DWORD PTR obj$[rsp+4]
	inc	eax
	mov	DWORD PTR obj$[rsp+4], eax
	mov	DWORD PTR obj$[rsp], eax
	call	omf_write_record
$LN6@omf_write_@6:
	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	$LL7@omf_write_@6
	mov	rdi, QWORD PTR [rsp+120]
$LN5@omf_write_@6:
	mov	rbx, QWORD PTR [rsp+112]

; 911  :         }
; 912  :     }
; 913  :     DebugMsg1(("omf_write_segdef exit\n"));
; 914  : }

	add	rsp, 88					; 00000058H
	ret	0
omf_write_segdef ENDP
_TEXT	ENDS
_BSS	SEGMENT
startitem DD	01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$omf_write_lnames DD 0e4401H
	DD	08e3444H
	DD	08bd42aH
	DD	08cc421H
	DD	091741dH
	DD	0906419H
	DD	08f540eH
	DD	08d010aH
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_lnames DD @imagerel(omf_write_lnames#)
	DD	@imagerel(omf_write_lnames#+361)
	DD	@imagerel($unwind$omf_write_lnames#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
obj$ = 32
buffer$ = 80
omf_write_lnames PROC NEAR

; 923  : {

	mov	rax, rsp
	sub	rsp, 1128				; 00000468H
	mov	QWORD PTR [rax+16], rbp

; 924  :     int         size;
; 925  :     int         items;
; 926  :     unsigned char *p;
; 927  :     //void        *pv = NULL;
; 928  :     struct qnode *curr;
; 929  :     struct asym *sym;
; 930  :     struct omf_rec obj;
; 931  :     unsigned char buffer[MAX_LNAME_SIZE];
; 932  : 
; 933  :     DebugMsg1(("omf_write_lnames() enter\n"));
; 934  :     p = buffer;
; 935  :     *p++ = NULLC; /* start with the NULL entry */
; 936  :     items = 1;
; 937  :     startitem = 1;
; 938  : 
; 939  :     for ( curr = ModuleInfo.g.LnameQueue.head; ; curr = curr->next ) {

	mov	rbp, QWORD PTR ModuleInfo+32
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	QWORD PTR [rax-8], r12
	mov	edi, 1
	mov	QWORD PTR [rax-16], r13
	mov	BYTE PTR buffer$[rsp], 0
	lea	rsi, QWORD PTR buffer$[rsp+1]
	mov	r12d, edi
	mov	DWORD PTR startitem, edi
	xor	r13d, r13d
	mov	QWORD PTR [rax+8], rbx
$LL13@omf_write_@7:

; 940  :         //sym = GetLnameData( &pv );
; 941  :         sym = ( curr ? (struct asym *)(curr->elmt) : NULL );

	test	rbp, rbp
	je	SHORT $LN16@omf_write_@7
	mov	rbx, QWORD PTR [rbp+8]
	jmp	SHORT $LN17@omf_write_@7
$LN16@omf_write_@7:
	mov	rbx, r13
$LN17@omf_write_@7:

; 942  :         size = p - buffer;

	lea	rax, QWORD PTR buffer$[rsp]
	mov	edx, esi
	sub	edx, eax

; 943  :         /* v2.04: changed extra bytes from 1 to 4 (CMD, RECLEN, CHKSUM) */
; 944  :         //if ( sym == NULL || ( ( size + sym->name_size + 1 ) > MAX_LNAME_SIZE )) {
; 945  :         if ( sym == NULL || ( ( size + sym->name_size + 4 ) > MAX_LNAME_SIZE )) {

	test	rbx, rbx
	je	SHORT $LN9@omf_write_@7
	movzx	eax, BYTE PTR [rbx+80]
	lea	ecx, DWORD PTR [rax+rdx+4]
	cmp	ecx, 1024				; 00000400H
	jle	SHORT $LN10@omf_write_@7
$LN9@omf_write_@7:

; 946  :             if( size ) {

	test	edx, edx
	je	SHORT $LN8@omf_write_@7

; 947  :                 omf_InitRec( &obj, CMD_LNAMES );
; 948  :                 /* first_idx and num_names are NOT
; 949  :                  * written to the LNAMES record!
; 950  :                  * In fact, they aren't used at all.
; 951  :                  */
; 952  :                 obj.d.lnames.first_idx = startitem;
; 953  :                 obj.d.lnames.num_names = items;
; 954  :                 AttachData( &obj, buffer, size );

	lea	rax, QWORD PTR buffer$[rsp]

; 955  :                 omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	DWORD PTR obj$[rsp+4], r13d
	mov	BYTE PTR obj$[rsp+16], 150		; 00000096H
	mov	BYTE PTR obj$[rsp+17], r13b
	mov	WORD PTR obj$[rsp+20], r12w
	mov	QWORD PTR obj$[rsp+8], rax
	mov	WORD PTR obj$[rsp+22], di
	mov	DWORD PTR obj$[rsp], edx
	call	omf_write_record

; 956  :                 startitem = items;

	mov	r12d, edi
	mov	DWORD PTR startitem, edi
$LN8@omf_write_@7:

; 957  :             }
; 958  :             if ( sym == NULL )

	test	rbx, rbx
	je	SHORT $LN24@omf_write_@7

; 959  :                 break;
; 960  :             p = buffer;

	lea	rsi, QWORD PTR buffer$[rsp]
$LN10@omf_write_@7:

; 961  :         }
; 962  :         *p++ = (char)sym->name_size;

	movzx	eax, BYTE PTR [rbx+80]
	inc	rsi
	mov	BYTE PTR [rsi-1], al

; 963  :         /* copy 1 byte more - the NULLC - for _strupr() */
; 964  :         memcpy( p, sym->name, sym->name_size + 1 );

	movzx	eax, BYTE PTR [rbx+80]
	mov	rdx, QWORD PTR [rbx+8]
	inc	eax
	mov	rcx, rsi
	movsxd	r8, eax
	call	memcpy

; 965  :         /* lnames are converted for casemaps ALL and NOTPUBLIC */
; 966  :         if ( ModuleInfo.case_sensitive == FALSE )

	test	BYTE PTR ModuleInfo+408, 2
	jne	SHORT $LN6@omf_write_@7

; 967  :             _strupr( p );

	mov	rcx, rsi
	call	_strupr
	mov	r12d, DWORD PTR startitem
$LN6@omf_write_@7:

; 968  :         DebugMsg1(("omf_write_lnames: %u=%s\n", items, p ));
; 969  :         p += sym->name_size; /* overwrite the null char */

	movzx	eax, BYTE PTR [rbx+80]

; 970  :         items++;
; 971  :         /* v2.12: lname_idx fields now set in OMF only */
; 972  :         switch ( sym->state ) {

	mov	ecx, DWORD PTR [rbx+40]
	inc	edi
	add	rsi, rax
	sub	ecx, 3
	je	SHORT $LN3@omf_write_@7
	dec	ecx
	je	SHORT $LN2@omf_write_@7

; 975  :         default:      sym->class_lname_idx = items;                       break;

	mov	DWORD PTR [rbx+16], edi
	mov	rbp, QWORD PTR [rbp]
	jmp	$LL13@omf_write_@7
$LN2@omf_write_@7:

; 974  :         case SYM_GRP: ((struct dsym *)sym)->e.grpinfo->lname_idx = items; break;

	mov	rax, QWORD PTR [rbx+104]
	mov	DWORD PTR [rax+12], edi
	mov	rbp, QWORD PTR [rbp]
	jmp	$LL13@omf_write_@7
$LN3@omf_write_@7:

; 973  :         case SYM_SEG: ((struct dsym *)sym)->e.seginfo->lname_idx = items; break;

	mov	rax, QWORD PTR [rbx+104]
	mov	DWORD PTR [rax+76], edi
	mov	rbp, QWORD PTR [rbp]
	jmp	$LL13@omf_write_@7
$LN24@omf_write_@7:
	mov	r13, QWORD PTR [rsp+1112]
	mov	r12, QWORD PTR [rsp+1120]
	mov	rdi, QWORD PTR [rsp+1160]
	mov	rsi, QWORD PTR [rsp+1152]
	mov	rbp, QWORD PTR [rsp+1144]
	mov	rbx, QWORD PTR [rsp+1136]

; 976  :         }
; 977  :     };
; 978  : 
; 979  :     DebugMsg1(("omf_write_lnames() exit, items=%u\n", items ));
; 980  : }

	add	rsp, 1128				; 00000468H
	ret	0
omf_write_lnames ENDP
; Function compile flags: /Ogtpy
r$ = 8
GetExt	PROC NEAR

; 998  :     struct asym *sym;
; 999  :     if ( r->method == 0 ) {

	cmp	BYTE PTR [rcx+10], 0
	mov	rdx, rcx
	jne	SHORT $LN14@GetExt

; 1000 :         for ( ; r->p; ) {

	cmp	QWORD PTR [rcx], 0
	je	SHORT $LN7@GetExt
	npad	1
$LL8@GetExt:

; 1001 :             sym = (struct asym *)r->p;

	mov	r8, QWORD PTR [rcx]

; 1002 :             r->p = r->p->next;

	mov	rax, QWORD PTR [r8+112]
	mov	QWORD PTR [rcx], rax

; 1003 :             if ( sym->iscomm == TRUE )

	test	BYTE PTR [r8+55], 4
	jne	SHORT $LN5@GetExt

; 1004 :                 continue;
; 1005 :             if ( sym->altname && sym->altname->included == FALSE ) {

	mov	rax, QWORD PTR [r8+72]
	test	rax, rax
	je	SHORT $LN5@GetExt
	test	BYTE PTR [rax+49], 64			; 00000040H
	je	SHORT $LN15@GetExt
$LN5@GetExt:

; 1000 :         for ( ; r->p; ) {

	cmp	QWORD PTR [rcx], 0
	jne	SHORT $LL8@GetExt
$LN7@GetExt:

; 1010 :             }
; 1011 :         }
; 1012 :         r->method++;

	mov	BYTE PTR [rcx+10], 1

; 1013 :         r->p = SymTables[TAB_EXT].head;

	mov	rax, QWORD PTR SymTables+16
	mov	QWORD PTR [rcx], rax
$LN14@GetExt:

; 1014 :     }
; 1015 :     for ( ; r->p; ) {

	cmp	QWORD PTR [rcx], 0
	je	SHORT $LN3@GetExt
	npad	6
$LL4@GetExt:

; 1016 :         sym = (struct asym *)r->p;

	mov	r8, QWORD PTR [rcx]

; 1017 :         r->p = r->p->next;

	mov	rax, QWORD PTR [r8+112]
	mov	QWORD PTR [rcx], rax

; 1018 :         if ( sym->iscomm == TRUE || sym->weak == TRUE )

	movzx	eax, BYTE PTR [r8+55]
	test	al, 4
	jne	SHORT $LN1@GetExt
	test	al, 8
	je	SHORT $LN2@GetExt
$LN1@GetExt:

; 1014 :     }
; 1015 :     for ( ; r->p; ) {

	cmp	QWORD PTR [rcx], 0
	jne	SHORT $LL4@GetExt
$LN3@GetExt:

; 1024 :     }
; 1025 :     return( NULL );

	xor	eax, eax

; 1026 : }

	ret	0
$LN15@GetExt:

; 1006 :                 /**/ myassert( r->index ); /* overflow occured? */
; 1007 :                 sym->altname->ext_idx2 = r->index++;

	mov	rcx, rax
	movzx	eax, WORD PTR [rdx+8]
	mov	WORD PTR [rcx+98], ax
	inc	WORD PTR [rdx+8]

; 1008 :                 sym->altname->included = TRUE;

	mov	rax, QWORD PTR [r8+72]
	or	BYTE PTR [rax+49], 64			; 00000040H

; 1009 :                 return( sym->altname );

	mov	rax, QWORD PTR [r8+72]

; 1026 : }

	ret	0
$LN2@GetExt:

; 1019 :             continue;
; 1020 :         /**/ myassert( r->index ); /* overflow occured? */
; 1021 :         sym->ext_idx1 = r->index++;

	movzx	ecx, WORD PTR [rcx+8]

; 1022 :         //r->p->sym.included = TRUE;
; 1023 :         return( sym );

	mov	rax, r8
	mov	WORD PTR [r8+96], cx
	inc	WORD PTR [rdx+8]

; 1026 : }

	ret	0
GetExt	ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$omf_write_extdef DD 020a01H
	DD	0ad010aH
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_extdef DD @imagerel(omf_write_extdef#)
	DD	@imagerel(omf_write_extdef#+10)
	DD	@imagerel($unwind$omf_write_extdef#)
pdata	ENDS
xdata	SEGMENT
$chain$1$omf_write_extdef DD 040f21H
	DD	0af540fH
	DD	0ae3404H
	DD	@imagerel(omf_write_extdef#)
	DD	@imagerel(omf_write_extdef#+10)
	DD	@imagerel($unwind$omf_write_extdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$omf_write_extdef DD @imagerel(omf_write_extdef#+10)
	DD	@imagerel(omf_write_extdef#+25)
	DD	@imagerel($chain$1$omf_write_extdef#)
pdata	ENDS
xdata	SEGMENT
$chain$4$omf_write_extdef DD 060c21H
	DD	0aae40cH
	DD	0abd408H
	DD	0b17404H
	DD	@imagerel(omf_write_extdef#+10)
	DD	@imagerel(omf_write_extdef#+25)
	DD	@imagerel($chain$1$omf_write_extdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$omf_write_extdef DD @imagerel(omf_write_extdef#+25)
	DD	@imagerel(omf_write_extdef#+200)
	DD	@imagerel($chain$4$omf_write_extdef#)
pdata	ENDS
xdata	SEGMENT
$chain$6$omf_write_extdef DD 041021H
	DD	0acc410H
	DD	0b06408H
	DD	@imagerel(omf_write_extdef#+25)
	DD	@imagerel(omf_write_extdef#+200)
	DD	@imagerel($chain$4$omf_write_extdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$omf_write_extdef DD @imagerel(omf_write_extdef#+200)
	DD	@imagerel(omf_write_extdef#+548)
	DD	@imagerel($chain$6$omf_write_extdef#)
pdata	ENDS
xdata	SEGMENT
$chain$7$omf_write_extdef DD 021H
	DD	@imagerel(omf_write_extdef#+25)
	DD	@imagerel(omf_write_extdef#+200)
	DD	@imagerel($chain$4$omf_write_extdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$omf_write_extdef DD @imagerel(omf_write_extdef#+548)
	DD	@imagerel(omf_write_extdef#+580)
	DD	@imagerel($chain$7$omf_write_extdef#)
pdata	ENDS
xdata	SEGMENT
$chain$8$omf_write_extdef DD 020021H
	DD	0aae400H
	DD	@imagerel(omf_write_extdef#+10)
	DD	@imagerel(omf_write_extdef#+25)
	DD	@imagerel($chain$1$omf_write_extdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$omf_write_extdef DD @imagerel(omf_write_extdef#+580)
	DD	@imagerel(omf_write_extdef#+800)
	DD	@imagerel($chain$8$omf_write_extdef#)
pdata	ENDS
xdata	SEGMENT
$chain$9$omf_write_extdef DD 040021H
	DD	0aae400H
	DD	0af5400H
	DD	@imagerel(omf_write_extdef#)
	DD	@imagerel(omf_write_extdef#+10)
	DD	@imagerel($unwind$omf_write_extdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$omf_write_extdef DD @imagerel(omf_write_extdef#+800)
	DD	@imagerel(omf_write_extdef#+861)
	DD	@imagerel($chain$9$omf_write_extdef#)
pdata	ENDS
xdata	SEGMENT
$chain$10$omf_write_extdef DD 0e0021H
	DD	0aae400H
	DD	0abd400H
	DD	0acc400H
	DD	0b17400H
	DD	0b06400H
	DD	0af5400H
	DD	0ae3400H
	DD	@imagerel(omf_write_extdef#)
	DD	@imagerel(omf_write_extdef#+10)
	DD	@imagerel($unwind$omf_write_extdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$10$omf_write_extdef DD @imagerel(omf_write_extdef#+861)
	DD	@imagerel(omf_write_extdef#+903)
	DD	@imagerel($chain$10$omf_write_extdef#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
obj$ = 32
buffer$ = 80
data$ = 336
omf_write_extdef PROC NEAR

; 1035 : {

	mov	rax, rsp
	sub	rsp, 1384				; 00000568H
	mov	QWORD PTR [rax+8], rbx

; 1036 :     struct omf_rec obj;
; 1037 :     struct asym *sym;
; 1038 :     struct dsym *symext;
; 1039 :     unsigned    rec_size;
; 1040 :     unsigned    len;
; 1041 :     struct readext r;
; 1042 :     char        data[MAX_EXT_LENGTH];
; 1043 :     unsigned char buffer[MAX_ID_LEN + MANGLE_BYTES + 1];
; 1044 : 
; 1045 :     DebugMsg1(("omf_write_extdef enter\n"));
; 1046 : 
; 1047 :     r.p = SymTables[TAB_EXT].head;

	mov	rbx, QWORD PTR SymTables+16
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+32], rdi
	mov	QWORD PTR [rax-16], r13
	mov	QWORD PTR [rax-24], r14

; 1048 :     r.index = 1;
; 1049 :     r.method = 0;

	xor	r13b, r13b

; 1050 :     obj.d.extdef.first_idx = 0;
; 1051 : 
; 1052 :     /* scan the EXTERN/EXTERNDEF items */
; 1053 : 
; 1054 :     sym = GetExt( &r );

	xor	r14d, r14d
	test	rbx, rbx
	mov	bp, 1
	mov	WORD PTR obj$[rsp+20], 0
	je	SHORT $LN25@omf_write_@8
	npad	5
$LL26@omf_write_@8:
	mov	rdi, rbx
	mov	rbx, QWORD PTR [rbx+112]
	test	BYTE PTR [rdi+55], 4
	jne	SHORT $LN23@omf_write_@8
	mov	rax, QWORD PTR [rdi+72]
	test	rax, rax
	je	SHORT $LN23@omf_write_@8
	test	BYTE PTR [rax+49], 64			; 00000040H
	je	SHORT $LN65@omf_write_@8
$LN23@omf_write_@8:
	test	rbx, rbx
	jne	SHORT $LL26@omf_write_@8
$LN25@omf_write_@8:
	mov	rbx, QWORD PTR SymTables+16
	mov	r13b, 1
	test	rbx, rbx
	je	$LN76@omf_write_@8
	npad	12
$LL22@omf_write_@8:
	mov	rdi, rbx
	mov	rbx, QWORD PTR [rbx+112]
	movzx	eax, BYTE PTR [rdi+55]
	test	al, 4
	jne	SHORT $LN19@omf_write_@8
	test	al, 8
	je	SHORT $LN20@omf_write_@8
$LN19@omf_write_@8:
	test	rbx, rbx
	jne	SHORT $LL22@omf_write_@8

; 1066 : 
; 1067 :             if( rec_size + len + 2 >= MAX_EXT_LENGTH ) {

	jmp	$LN76@omf_write_@8
$LN65@omf_write_@8:

; 1050 :     obj.d.extdef.first_idx = 0;
; 1051 : 
; 1052 :     /* scan the EXTERN/EXTERNDEF items */
; 1053 : 
; 1054 :     sym = GetExt( &r );

	mov	WORD PTR [rax+98], 1
	mov	rax, QWORD PTR [rdi+72]
	mov	bp, 2
	or	BYTE PTR [rax+49], 64			; 00000040H
	mov	rdi, QWORD PTR [rdi+72]
	jmp	SHORT $LN59@omf_write_@8
$LN20@omf_write_@8:
	mov	WORD PTR [rdi+96], 1
	mov	bp, 2
$LN59@omf_write_@8:

; 1055 :     while ( sym ) {

	test	rdi, rdi
	je	$LN76@omf_write_@8
	mov	QWORD PTR [rsp+1408], rsi
	mov	QWORD PTR [rsp+1376], r12
	npad	8
$LL16@omf_write_@8:

; 1056 :         for ( rec_size = 0, obj.d.extdef.num_names = 0; sym; sym = GetExt( &r ) ) {

	test	rdi, rdi
	mov	r12d, r14d
	mov	WORD PTR obj$[rsp+22], r12w
	je	$LN78@omf_write_@8
$LL39@omf_write_@8:

; 1057 :             //DebugMsg(("omf_write_extdef: %s, weak=%u, used=%u\n", curr->sym.name, curr->sym.weak, curr->sym.used ));
; 1058 :             DebugMsg1(("omf_write_extdef: %s\n", sym->name));
; 1059 :             len = Mangle( sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rdi
	call	Mangle

; 1060 : #if MAX_ID_LEN > 255
; 1061 :             if ( len > 255 )
; 1062 :                 len = 255; /* length is 1 byte only */
; 1063 : #endif
; 1064 :             if ( ModuleInfo.convert_uppercase )

	test	BYTE PTR ModuleInfo+408, 4
	mov	esi, eax
	je	SHORT $LN11@omf_write_@8

; 1065 :                 _strupr( buffer );

	lea	rcx, QWORD PTR buffer$[rsp]
	call	_strupr
$LN11@omf_write_@8:

; 1066 : 
; 1067 :             if( rec_size + len + 2 >= MAX_EXT_LENGTH ) {

	lea	eax, DWORD PTR [rsi+r12+2]
	cmp	eax, 1020				; 000003fcH
	jae	$LN74@omf_write_@8

; 1068 :                 break;
; 1069 :             }
; 1070 :             obj.d.extdef.num_names++;

	inc	WORD PTR obj$[rsp+22]

; 1071 : 
; 1072 :             data[rec_size++] = (char)len;

	mov	eax, r12d
	inc	r12d

; 1073 :             memcpy( data + rec_size, buffer, len );

	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR data$[rsp+r12]
	mov	r8, rsi
	mov	BYTE PTR data$[rsp+rax], sil
	call	memcpy

; 1074 :             rec_size += len;

	add	r12d, esi

; 1075 :             data[rec_size++] = 0;      /* for the type index */

	mov	BYTE PTR data$[rsp+r12], r14b
	mov	eax, r12d
	inc	r12d
	test	r13b, r13b
	jne	SHORT $LN62@omf_write_@8

; 1056 :         for ( rec_size = 0, obj.d.extdef.num_names = 0; sym; sym = GetExt( &r ) ) {

	test	rbx, rbx
	je	SHORT $LN36@omf_write_@8
	npad	9
$LL37@omf_write_@8:
	mov	rcx, rbx
	mov	rbx, QWORD PTR [rbx+112]
	test	BYTE PTR [rcx+55], 4
	jne	SHORT $LN34@omf_write_@8
	mov	rax, QWORD PTR [rcx+72]
	test	rax, rax
	je	SHORT $LN34@omf_write_@8
	test	BYTE PTR [rax+49], 64			; 00000040H
	je	$LN66@omf_write_@8
$LN34@omf_write_@8:
	test	rbx, rbx
	jne	SHORT $LL37@omf_write_@8
$LN36@omf_write_@8:
	mov	rbx, QWORD PTR SymTables+16
	mov	r13b, 1
$LN62@omf_write_@8:
	test	rbx, rbx
	je	SHORT $LN72@omf_write_@8
	npad	12
$LL33@omf_write_@8:
	mov	rdi, rbx
	mov	rbx, QWORD PTR [rbx+112]
	movzx	eax, BYTE PTR [rdi+55]
	test	al, 4
	jne	SHORT $LN30@omf_write_@8
	test	al, 8
	je	$LN31@omf_write_@8
$LN30@omf_write_@8:
	test	rbx, rbx
	jne	SHORT $LL33@omf_write_@8
$LN72@omf_write_@8:
	mov	rdi, r14
$LN74@omf_write_@8:

; 1076 :         }
; 1077 :         if ( rec_size ) {

	test	r12d, r12d
	je	SHORT $LN9@omf_write_@8

; 1078 :             DebugMsg1(("omf_write_extdef: write record, names=%u, size=%u, MAX=%u\n", obj.d.extdef.num_names, rec_size, MAX_EXT_LENGTH ));
; 1079 :             omf_InitRec( &obj, CMD_EXTDEF );
; 1080 :             AttachData( &obj, (uint_8 *)data, rec_size );

	lea	rax, QWORD PTR data$[rsp]

; 1081 :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	DWORD PTR obj$[rsp+4], r14d
	mov	BYTE PTR obj$[rsp+16], 140		; 0000008cH
	mov	BYTE PTR obj$[rsp+17], r14b
	mov	DWORD PTR obj$[rsp], r12d
	mov	QWORD PTR obj$[rsp+8], rax
	call	omf_write_record

; 1082 :             obj.d.extdef.first_idx += obj.d.extdef.num_names;

	movzx	r11d, WORD PTR obj$[rsp+22]
	add	WORD PTR obj$[rsp+20], r11w
$LN9@omf_write_@8:

; 1055 :     while ( sym ) {

	test	rdi, rdi
	jne	$LL16@omf_write_@8
$LN78@omf_write_@8:
	mov	rsi, QWORD PTR [rsp+1408]
	mov	r12, QWORD PTR [rsp+1376]
$LN76@omf_write_@8:

; 1083 :         }
; 1084 :     }
; 1085 : 
; 1086 :     /* v2.04: write WKEXT coment records.
; 1087 :      * those items are defined via "EXTERN (altname)" syntax.
; 1088 :      * After the records have been written, the indices in
; 1089 :      * altname are no longer needed.
; 1090 :      */
; 1091 : 
; 1092 :     for ( symext = SymTables[TAB_EXT].head; symext; symext = symext->next ) {

	mov	rbx, QWORD PTR SymTables+16
	mov	r13, QWORD PTR [rsp+1368]
	mov	rdi, QWORD PTR [rsp+1416]
	test	rbx, rbx
	je	$LN6@omf_write_@8
$LL8@omf_write_@8:

; 1093 :         if ( symext->sym.iscomm == FALSE && symext->sym.altname ) {

	test	BYTE PTR [rbx+55], 4
	jne	$LN7@omf_write_@8
	cmp	QWORD PTR [rbx+72], r14
	je	$LN7@omf_write_@8

; 1094 :             omf_InitRec( &obj, CMD_COMENT );
; 1095 :             obj.d.coment.attr = CMT_TNP;
; 1096 :             obj.d.coment.cmt_class = CMT_WKEXT;
; 1097 :             AttachData( &obj, buffer, 4 );

	lea	rcx, QWORD PTR buffer$[rsp]
	mov	eax, r14d
	mov	BYTE PTR obj$[rsp+16], 136		; 00000088H
	mov	BYTE PTR obj$[rsp+17], r14b
	mov	BYTE PTR obj$[rsp+20], 128		; 00000080H
	mov	BYTE PTR obj$[rsp+21], 168		; 000000a8H
	mov	QWORD PTR obj$[rsp+8], rcx
	mov	DWORD PTR obj$[rsp+4], eax
	mov	DWORD PTR obj$[rsp], 4

; 1098 :             PutIndex( &obj, symext->sym.ext_idx1 );

	movzx	ecx, WORD PTR [rbx+96]
	cmp	ecx, 127				; 0000007fH
	jbe	SHORT $LN49@omf_write_@8
	mov	eax, ecx
	shr	eax, 8
	or	al, 128					; 00000080H
	mov	BYTE PTR buffer$[rsp], al
	mov	eax, 1
	mov	DWORD PTR obj$[rsp+4], eax
$LN49@omf_write_@8:
	mov	BYTE PTR buffer$[rsp+rax], cl
	mov	ecx, DWORD PTR obj$[rsp+4]
	inc	ecx
	mov	DWORD PTR obj$[rsp+4], ecx

; 1099 :             PutIndex( &obj, symext->sym.altname->ext_idx2 );

	mov	rax, QWORD PTR [rbx+72]
	movzx	r8d, WORD PTR [rax+98]
	cmp	r8d, 127				; 0000007fH
	jbe	SHORT $LN52@omf_write_@8
	mov	rax, QWORD PTR obj$[rsp+8]
	mov	edx, r8d
	shr	edx, 8
	or	dl, 128					; 00000080H
	mov	BYTE PTR [rcx+rax], dl
	mov	ecx, DWORD PTR obj$[rsp+4]
	inc	ecx
	mov	DWORD PTR obj$[rsp+4], ecx
$LN52@omf_write_@8:
	mov	rax, QWORD PTR obj$[rsp+8]
	mov	BYTE PTR [rcx+rax], r8b
	mov	eax, DWORD PTR obj$[rsp+4]

; 1100 :             TruncRec( &obj );
; 1101 :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	inc	eax
	mov	DWORD PTR obj$[rsp+4], eax
	mov	DWORD PTR obj$[rsp], eax
	call	omf_write_record
$LN7@omf_write_@8:
	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	$LL8@omf_write_@8
$LN6@omf_write_@8:

; 1102 :         }
; 1103 :     }
; 1104 :     /* v2.05: reset the indices - this must be done only after ALL WKEXT
; 1105 :      * records have been written!
; 1106 :      */
; 1107 :     for ( symext = SymTables[TAB_EXT].head; symext; symext = symext->next ) {

	mov	rcx, QWORD PTR SymTables+16
	mov	rbx, QWORD PTR [rsp+1392]
	test	rcx, rcx
	je	SHORT $LN73@omf_write_@8
	npad	4
$LL4@omf_write_@8:

; 1108 :             /* v2.09: don't touch the index if the alternate name is an external
; 1109 :              * - else an invalid object file will be created!
; 1110 :              */
; 1111 :         if ( symext->sym.iscomm == FALSE && symext->sym.altname && symext->sym.altname->state != SYM_EXTERNAL )

	test	BYTE PTR [rcx+55], 4
	jne	SHORT $LN3@omf_write_@8
	mov	rdx, QWORD PTR [rcx+72]
	test	rdx, rdx
	je	SHORT $LN3@omf_write_@8
	cmp	DWORD PTR [rdx+40], 2
	je	SHORT $LN3@omf_write_@8

; 1112 :             symext->sym.altname->ext_idx = 0;

	mov	DWORD PTR [rdx+96], r14d
$LN3@omf_write_@8:

; 1102 :         }
; 1103 :     }
; 1104 :     /* v2.05: reset the indices - this must be done only after ALL WKEXT
; 1105 :      * records have been written!
; 1106 :      */
; 1107 :     for ( symext = SymTables[TAB_EXT].head; symext; symext = symext->next ) {

	mov	rcx, QWORD PTR [rcx+112]
	test	rcx, rcx
	jne	SHORT $LL4@omf_write_@8
$LN73@omf_write_@8:
	mov	r14, QWORD PTR [rsp+1360]

; 1113 :     }
; 1114 :     /* v2.09: write COMM items here. This allows to handle
; 1115 :      * the external index field entirely in omf.c
; 1116 :      * v2.11: removed again, since omf_write_extdef() is no
; 1117 :      * longer called externally.
; 1118 :      */
; 1119 :     //omf_write_comdef( r.index );
; 1120 : 
; 1121 :     DebugMsg1(("omf_write_extdef exit, index=%u\n", r.index ));
; 1122 :     return( r.index );

	mov	ax, bp
	mov	rbp, QWORD PTR [rsp+1400]

; 1123 : }

	add	rsp, 1384				; 00000568H
	ret	0
$LN66@omf_write_@8:

; 1056 :         for ( rec_size = 0, obj.d.extdef.num_names = 0; sym; sym = GetExt( &r ) ) {

	mov	WORD PTR [rax+98], bp
	mov	rax, QWORD PTR [rcx+72]
	inc	bp
	or	BYTE PTR [rax+49], 64			; 00000040H
	mov	rdi, QWORD PTR [rcx+72]
	jmp	SHORT $LN68@omf_write_@8
$LN31@omf_write_@8:
	mov	WORD PTR [rdi+96], bp
	inc	bp
$LN68@omf_write_@8:
	test	rdi, rdi
	jne	$LL39@omf_write_@8
	jmp	$LN74@omf_write_@8
omf_write_extdef ENDP
; Function compile flags: /Ogtpy
value$ = 8
get_size_of_comdef_number PROC NEAR

; 1130 :     /* The spec allows up to 128 in a one byte size field, but lots
; 1131 :        of software has problems with that, so we'll restrict ourselves
; 1132 :        to 127.
; 1133 :     */
; 1134 :     if( value < 128 ) {

	cmp	ecx, 128				; 00000080H
	jae	SHORT $LN6@get_size_o

; 1135 :         return( 1 );    /* 1 byte value */

	mov	eax, 1

; 1139 :         return( 4 );    /* 1 byte flag + 3 byte value */
; 1140 :     } else { /* if( value <= ULONG_MAX ) */
; 1141 :         return( 5 );    /* 1 byte flag + 4 byte value */
; 1142 :     }
; 1143 : }

	ret	0
$LN6@get_size_o:

; 1136 :     } else if( value <= USHRT_MAX ) {

	cmp	ecx, 65535				; 0000ffffH
	ja	SHORT $LN4@get_size_o

; 1137 :         return( 3 );    /* 1 byte flag + 2 byte value */

	mov	eax, 3

; 1139 :         return( 4 );    /* 1 byte flag + 3 byte value */
; 1140 :     } else { /* if( value <= ULONG_MAX ) */
; 1141 :         return( 5 );    /* 1 byte flag + 4 byte value */
; 1142 :     }
; 1143 : }

	ret	0
$LN4@get_size_o:

; 1138 :     } else if( value <= THREE_BYTE_MAX ) {

	xor	eax, eax
	cmp	ecx, 16777215				; 00ffffffH
	seta	al
	add	eax, 4

; 1139 :         return( 4 );    /* 1 byte flag + 3 byte value */
; 1140 :     } else { /* if( value <= ULONG_MAX ) */
; 1141 :         return( 5 );    /* 1 byte flag + 4 byte value */
; 1142 :     }
; 1143 : }

	ret	0
get_size_of_comdef_number ENDP
; Function compile flags: /Ogtpy
buffer$ = 8
value$ = 16
put_comdef_number PROC NEAR

; 1150 :     unsigned i;
; 1151 :     unsigned symsize;
; 1152 : 
; 1153 :     symsize = get_size_of_comdef_number( value );

	cmp	edx, 128				; 00000080H
	mov	rax, rcx
	jae	SHORT $LN17@put_comdef
	mov	r8d, 1
	jmp	SHORT $LN13@put_comdef
$LN17@put_comdef:
	cmp	edx, 65535				; 0000ffffH
	ja	SHORT $LN15@put_comdef
	mov	r8d, 3
	jmp	SHORT $LN13@put_comdef
$LN15@put_comdef:
	xor	r8d, r8d
	cmp	edx, 16777215				; 00ffffffH
	seta	r8b
	add	r8d, 4
$LN13@put_comdef:

; 1154 :     switch( symsize ) {

	mov	ecx, r8d
	dec	ecx
	je	SHORT $LN7@put_comdef
	sub	ecx, 2
	je	SHORT $LN6@put_comdef
	dec	ecx
	je	SHORT $LN5@put_comdef
	dec	ecx
	jne	SHORT $LN8@put_comdef

; 1158 :     case 5:  *buffer++ = COMDEF_LEAF_4;  break; /* 0x88 */

	mov	BYTE PTR [rax], 136			; 00000088H
	inc	rax
	jmp	SHORT $LN8@put_comdef
$LN5@put_comdef:

; 1157 :     case 4:  *buffer++ = COMDEF_LEAF_3;  break; /* 0x84 */

	mov	BYTE PTR [rax], 132			; 00000084H
	inc	rax
	jmp	SHORT $LN8@put_comdef
$LN6@put_comdef:

; 1156 :     case 3:  *buffer++ = COMDEF_LEAF_2;  break; /* 0x81 */

	mov	BYTE PTR [rax], 129			; 00000081H
	inc	rax
	jmp	SHORT $LN8@put_comdef
$LN7@put_comdef:

; 1155 :     case 1:  *buffer = value; break;

	mov	BYTE PTR [rax], dl
$LN8@put_comdef:

; 1159 :     }
; 1160 : 
; 1161 :     for( i = 1; i < symsize; i++ ) {

	cmp	r8d, 1
	jbe	SHORT $LN22@put_comdef
	lea	r9d, DWORD PTR [r8-1]
	npad	4
$LL3@put_comdef:

; 1162 :         *buffer++ = value % ( UCHAR_MAX + 1 );

	mov	BYTE PTR [rax], dl
	inc	rax

; 1163 :         value >>= 8;

	shr	edx, 8
	dec	r9
	jne	SHORT $LL3@put_comdef
$LN22@put_comdef:

; 1164 :     }
; 1165 :     return( symsize );

	mov	eax, r8d

; 1166 : }

	ret	0
put_comdef_number ENDP
_TEXT	ENDS
EXTRN	SizeFromMemtype:NEAR
xdata	SEGMENT
$unwind$omf_write_comdef DD 0a2101H
	DD	0adf421H
	DD	0aee41dH
	DD	0b0c419H
	DD	0b5740eH
	DD	0b1010aH
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_comdef DD @imagerel(omf_write_comdef#)
	DD	@imagerel(omf_write_comdef#+52)
	DD	@imagerel($unwind$omf_write_comdef#)
pdata	ENDS
xdata	SEGMENT
$chain$7$omf_write_comdef DD 081021H
	DD	0afd410H
	DD	0b4640cH
	DD	0b35408H
	DD	0b23404H
	DD	@imagerel(omf_write_comdef#)
	DD	@imagerel(omf_write_comdef#+52)
	DD	@imagerel($unwind$omf_write_comdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$omf_write_comdef DD @imagerel(omf_write_comdef#+52)
	DD	@imagerel(omf_write_comdef#+882)
	DD	@imagerel($chain$7$omf_write_comdef#)
pdata	ENDS
xdata	SEGMENT
$chain$8$omf_write_comdef DD 021H
	DD	@imagerel(omf_write_comdef#)
	DD	@imagerel(omf_write_comdef#+52)
	DD	@imagerel($unwind$omf_write_comdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$omf_write_comdef DD @imagerel(omf_write_comdef#+882)
	DD	@imagerel(omf_write_comdef#+928)
	DD	@imagerel($chain$8$omf_write_comdef#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
number$ = 32
obj$ = 48
buffer$ = 96
data$ = 352
index$ = 1424
omf_write_comdef PROC NEAR

; 1179 : {

	mov	rax, rsp
	sub	rsp, 1416				; 00000588H
	mov	QWORD PTR [rax+32], rdi

; 1180 :     struct omf_rec obj;
; 1181 :     struct dsym    *curr;
; 1182 :     unsigned    num;
; 1183 :     unsigned    recsize;
; 1184 :     unsigned    numsize;
; 1185 :     unsigned    symsize;
; 1186 :     uint_32     varsize;
; 1187 :     unsigned    start = 0; /* record's start index (not used) */
; 1188 :     char        buffer[MAX_ID_LEN + MANGLE_BYTES + 1];
; 1189 :     char        data[MAX_EXT_LENGTH];
; 1190 :     char        number[16];
; 1191 : 
; 1192 :     DebugMsg1(("omf_write_comdef enter\n"));
; 1193 :     curr = SymTables[TAB_EXT].head;

	mov	rdi, QWORD PTR SymTables+16
	mov	QWORD PTR [rax-8], r12
	mov	QWORD PTR [rax-24], r14
	mov	QWORD PTR [rax-32], r15
	xor	r15d, r15d

; 1194 :     while ( curr ) {

	test	rdi, rdi
	movzx	r12d, cx
	mov	r14d, r15d
	je	$LN91@omf_write_@9
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax-16], r13
	npad	12
$LL12@omf_write_@9:

; 1195 :         for( num = 0, recsize = 0; curr != NULL ; curr = curr->next ) {

	test	rdi, rdi
	mov	r13d, r15d
	mov	esi, r15d
	je	$LN90@omf_write_@9
	npad	1
$LL10@omf_write_@9:

; 1196 :             if ( curr->sym.iscomm == FALSE )

	test	BYTE PTR [rdi+55], 4
	je	$LN9@omf_write_@9

; 1197 :                 continue;
; 1198 :             symsize = Mangle( &curr->sym, buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, rdi
	call	Mangle

; 1199 : #if MAX_ID_LEN > 255
; 1200 :             if ( symsize > 255 )
; 1201 :                 symsize = 255; /* length is 1 byte only */
; 1202 : #endif
; 1203 :             /* v2.11: case mapping was missing */
; 1204 :             if ( ModuleInfo.convert_uppercase )

	test	BYTE PTR ModuleInfo+408, 4
	mov	ebp, eax
	je	SHORT $LN6@omf_write_@9

; 1205 :                 _strupr( buffer );

	lea	rcx, QWORD PTR buffer$[rsp]
	call	_strupr
$LN6@omf_write_@9:

; 1206 : 
; 1207 :             varsize = SizeFromMemtype( curr->sym.mem_type, ModuleInfo.Ofssize, curr->sym.type );

	movzx	edx, BYTE PTR ModuleInfo+404
	mov	r8, QWORD PTR [rdi+88]
	mov	ecx, DWORD PTR [rdi+44]
	call	SizeFromMemtype

; 1208 : 
; 1209 :             /**/ myassert( index );
; 1210 :             curr->sym.ext_idx = index++; /* v2.09: set external index here */

	movzx	ecx, r12w
	inc	r12w

; 1211 : 
; 1212 :             DebugMsg1(("omf_write_comdef: %s, size=%u, sym.total_size=%u, sym.total_length=%u, sym.isfar=%u\n",
; 1213 :                       curr->sym.name, varsize, curr->sym.total_size, curr->sym.total_length, curr->sym.isfar ));
; 1214 :             if ( varsize == 0 )

	test	eax, eax
	mov	r11d, eax
	mov	DWORD PTR [rdi+96], ecx
	jne	SHORT $LN5@omf_write_@9

; 1215 :                 varsize = curr->sym.total_size / curr->sym.total_length;

	mov	eax, DWORD PTR [rdi+64]
	xor	edx, edx
	div	DWORD PTR [rdi+72]
	mov	r11d, eax
$LN5@omf_write_@9:

; 1216 : 
; 1217 :             numsize = 1;
; 1218 :             if ( curr->sym.isfar == TRUE ) {

	test	BYTE PTR [rdi+55], 16
	je	$LN4@omf_write_@9

; 1219 :                 number[0] = COMDEF_FAR;  /* 0x61 */
; 1220 :                 numsize += put_comdef_number( &number[1], curr->sym.total_length );

	mov	ecx, DWORD PTR [rdi+72]
	mov	BYTE PTR number$[rsp], 97		; 00000061H
	lea	rdx, QWORD PTR number$[rsp+1]
	cmp	ecx, 128				; 00000080H
	jae	SHORT $LN31@omf_write_@9
	mov	r9d, 1
	mov	r10, r9
	jmp	SHORT $LN26@omf_write_@9
$LN31@omf_write_@9:
	cmp	ecx, 65535				; 0000ffffH
	ja	SHORT $LN29@omf_write_@9
	mov	r9d, 3
	mov	r10, r9
	jmp	SHORT $LN26@omf_write_@9
$LN29@omf_write_@9:
	cmp	ecx, 16777215				; 00ffffffH
	ja	SHORT $LN27@omf_write_@9
	mov	r9d, 4
	mov	r10, r9
	jmp	SHORT $LN26@omf_write_@9
$LN27@omf_write_@9:
	mov	r9d, 5
	mov	r10, r9
$LN26@omf_write_@9:
	mov	eax, r9d
	dec	eax
	je	SHORT $LN21@omf_write_@9
	sub	eax, 2
	je	SHORT $LN20@omf_write_@9
	dec	eax
	je	SHORT $LN19@omf_write_@9
	dec	eax
	jne	SHORT $LN22@omf_write_@9
	mov	BYTE PTR number$[rsp+1], 136		; 00000088H
	lea	rdx, QWORD PTR number$[rsp+2]
	jmp	SHORT $LN87@omf_write_@9
$LN19@omf_write_@9:
	mov	BYTE PTR number$[rsp+1], 132		; 00000084H
	lea	rdx, QWORD PTR number$[rsp+2]
	jmp	SHORT $LN87@omf_write_@9
$LN20@omf_write_@9:
	mov	BYTE PTR number$[rsp+1], 129		; 00000081H
	lea	rdx, QWORD PTR number$[rsp+2]
	jmp	SHORT $LN87@omf_write_@9
$LN21@omf_write_@9:
	mov	BYTE PTR number$[rsp+1], cl
	jmp	SHORT $LN15@omf_write_@9
$LN22@omf_write_@9:
	cmp	r9d, 1
	jbe	SHORT $LN15@omf_write_@9
$LN87@omf_write_@9:
	lea	r8d, DWORD PTR [r9-1]
	npad	3
$LL17@omf_write_@9:
	mov	BYTE PTR [rdx], cl
	inc	rdx
	shr	ecx, 8
	dec	r8
	jne	SHORT $LL17@omf_write_@9
$LN15@omf_write_@9:

; 1221 :                 numsize += put_comdef_number( &number[numsize], varsize );

	cmp	r11d, 128				; 00000080H
	lea	ebx, DWORD PTR [r9+1]
	lea	rcx, QWORD PTR number$[rsp+r10+1]
	jae	SHORT $LN50@omf_write_@9
	mov	r8d, 1
	jmp	SHORT $LN46@omf_write_@9
$LN50@omf_write_@9:
	cmp	r11d, 65535				; 0000ffffH
	ja	SHORT $LN48@omf_write_@9
	mov	r8d, 3
	jmp	SHORT $LN46@omf_write_@9
$LN48@omf_write_@9:
	cmp	r11d, 16777215				; 00ffffffH
	mov	r8d, r15d
	seta	r8b
	add	r8d, 4
$LN46@omf_write_@9:
	mov	eax, r8d
	dec	eax
	je	SHORT $LN40@omf_write_@9
	sub	eax, 2
	je	SHORT $LN39@omf_write_@9
	dec	eax
	je	SHORT $LN38@omf_write_@9
	dec	eax
	jne	SHORT $LN41@omf_write_@9
	mov	BYTE PTR [rcx], 136			; 00000088H
	inc	rcx
	jmp	SHORT $LN88@omf_write_@9
$LN38@omf_write_@9:
	mov	BYTE PTR [rcx], 132			; 00000084H
	inc	rcx
	jmp	SHORT $LN88@omf_write_@9
$LN39@omf_write_@9:
	mov	BYTE PTR [rcx], 129			; 00000081H
	inc	rcx
	jmp	SHORT $LN88@omf_write_@9
$LN40@omf_write_@9:
	mov	BYTE PTR [rcx], r11b
	add	ebx, r8d

; 1222 :                 DebugMsg(("omf_write_comdef: numsize=%u, length=%u, varsize=%u\n",
; 1223 :                           numsize, curr->sym.total_length, varsize ));
; 1224 :             } else {

	jmp	$LN3@omf_write_@9

; 1221 :                 numsize += put_comdef_number( &number[numsize], varsize );

$LN41@omf_write_@9:
	cmp	r8d, 1
	jbe	SHORT $LN34@omf_write_@9
$LN88@omf_write_@9:
	lea	edx, DWORD PTR [r8-1]
	npad	5
$LL36@omf_write_@9:
	mov	BYTE PTR [rcx], r11b
	inc	rcx
	shr	r11d, 8
	dec	rdx
	jne	SHORT $LL36@omf_write_@9
$LN34@omf_write_@9:
	add	ebx, r8d

; 1222 :                 DebugMsg(("omf_write_comdef: numsize=%u, length=%u, varsize=%u\n",
; 1223 :                           numsize, curr->sym.total_length, varsize ));
; 1224 :             } else {

	jmp	$LN3@omf_write_@9
$LN4@omf_write_@9:

; 1225 :                 number[0] = COMDEF_NEAR; /* 0x62 */
; 1226 :                 numsize += put_comdef_number( &number[1], curr->sym.total_length * varsize );

	mov	ecx, DWORD PTR [rdi+72]
	mov	BYTE PTR number$[rsp], 98		; 00000062H
	lea	rdx, QWORD PTR number$[rsp+1]
	imul	ecx, r11d
	cmp	ecx, 128				; 00000080H
	jae	SHORT $LN69@omf_write_@9
	mov	r9d, 1
	jmp	SHORT $LN65@omf_write_@9
$LN69@omf_write_@9:
	cmp	ecx, 65535				; 0000ffffH
	ja	SHORT $LN67@omf_write_@9
	mov	r9d, 3
	jmp	SHORT $LN65@omf_write_@9
$LN67@omf_write_@9:
	cmp	ecx, 16777215				; 00ffffffH
	mov	r9d, r15d
	seta	r9b
	add	r9d, 4
$LN65@omf_write_@9:
	mov	eax, r9d
	dec	eax
	je	SHORT $LN59@omf_write_@9
	sub	eax, 2
	je	SHORT $LN58@omf_write_@9
	dec	eax
	je	SHORT $LN57@omf_write_@9
	dec	eax
	jne	SHORT $LN60@omf_write_@9
	mov	BYTE PTR number$[rsp+1], 136		; 00000088H
	lea	rdx, QWORD PTR number$[rsp+2]
	jmp	SHORT $LN89@omf_write_@9
$LN57@omf_write_@9:
	mov	BYTE PTR number$[rsp+1], 132		; 00000084H
	lea	rdx, QWORD PTR number$[rsp+2]
	jmp	SHORT $LN89@omf_write_@9
$LN58@omf_write_@9:
	mov	BYTE PTR number$[rsp+1], 129		; 00000081H
	lea	rdx, QWORD PTR number$[rsp+2]
	jmp	SHORT $LN89@omf_write_@9
$LN59@omf_write_@9:
	mov	BYTE PTR number$[rsp+1], cl
	jmp	SHORT $LN53@omf_write_@9
$LN60@omf_write_@9:
	cmp	r9d, 1
	jbe	SHORT $LN53@omf_write_@9
$LN89@omf_write_@9:
	lea	r8d, DWORD PTR [r9-1]
$LL55@omf_write_@9:
	mov	BYTE PTR [rdx], cl
	inc	rdx
	shr	ecx, 8
	dec	r8
	jne	SHORT $LL55@omf_write_@9
$LN53@omf_write_@9:
	lea	ebx, DWORD PTR [r9+1]
$LN3@omf_write_@9:

; 1227 :                 DebugMsg1(("omf_write_comdef: numsize=%u, value=%u\n",
; 1228 :                           numsize, curr->sym.total_length * varsize ));
; 1229 :             }
; 1230 :             /* make sure the record's size doesn't exceed 1024.
; 1231 :              * 2 = 1 (name len) + 1 (type index)
; 1232 :              */
; 1233 :             if ( ( recsize + symsize + numsize + 2 ) > MAX_EXT_LENGTH )

	lea	eax, DWORD PTR [rbx+rbp]
	lea	ecx, DWORD PTR [rax+rsi+2]
	cmp	ecx, 1020				; 000003fcH
	ja	SHORT $LN81@omf_write_@9

; 1234 :                 break;
; 1235 : 
; 1236 :             /* copy name ( including size prefix ), type, number */
; 1237 :             data[recsize++] = (char)symsize;

	mov	eax, esi
	inc	esi

; 1238 :             memcpy( data + recsize, buffer, symsize );

	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, QWORD PTR data$[rsp+rsi]
	mov	r8, rbp
	mov	BYTE PTR data$[rsp+rax], bpl
	call	memcpy

; 1239 :             recsize += symsize;

	add	esi, ebp

; 1240 :             data[recsize++] = 0;      /* for the type index */
; 1241 :             memcpy( data + recsize, number, numsize );

	lea	rdx, QWORD PTR number$[rsp]
	mov	BYTE PTR data$[rsp+rsi], r15b
	inc	esi
	mov	r8d, ebx
	lea	rcx, QWORD PTR data$[rsp+rsi]
	mov	eax, esi
	call	memcpy

; 1242 :             recsize += numsize;

	add	esi, ebx

; 1243 : 
; 1244 :             num++;

	inc	r13d
$LN9@omf_write_@9:
	mov	rdi, QWORD PTR [rdi+112]
	test	rdi, rdi
	jne	$LL10@omf_write_@9
$LN81@omf_write_@9:

; 1245 : 
; 1246 :         } /* end for */
; 1247 : 
; 1248 :         if( num > 0 ) {

	test	r13d, r13d
	je	SHORT $LN1@omf_write_@9

; 1249 :             omf_InitRec( &obj, CMD_COMDEF );
; 1250 :             obj.d.comdef.first_idx = start; /* unused */
; 1251 :             AttachData( &obj, (uint_8 *)data, recsize );

	lea	rax, QWORD PTR data$[rsp]

; 1252 :             obj.d.comdef.num_names = num; /* unused */
; 1253 :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	DWORD PTR obj$[rsp+4], r15d
	mov	BYTE PTR obj$[rsp+16], 176		; 000000b0H
	mov	BYTE PTR obj$[rsp+17], r15b
	mov	WORD PTR obj$[rsp+20], r14w
	mov	QWORD PTR obj$[rsp+8], rax
	mov	DWORD PTR obj$[rsp], esi
	mov	WORD PTR obj$[rsp+22], r13w
	call	omf_write_record

; 1254 :             start += num;

	add	r14d, r13d
$LN1@omf_write_@9:

; 1194 :     while ( curr ) {

	test	rdi, rdi
	jne	$LL12@omf_write_@9
$LN90@omf_write_@9:
	mov	rsi, QWORD PTR [rsp+1440]
	mov	rbp, QWORD PTR [rsp+1432]
	mov	rbx, QWORD PTR [rsp+1424]
	mov	r13, QWORD PTR [rsp+1400]

; 1255 :         }
; 1256 :     }
; 1257 :     DebugMsg1(("omf_write_comdef exit\n"));
; 1258 :     return( index );

	mov	ax, r12w
$LN86@omf_write_@9:
	mov	r15, QWORD PTR [rsp+1384]
	mov	r14, QWORD PTR [rsp+1392]
	mov	r12, QWORD PTR [rsp+1408]
	mov	rdi, QWORD PTR [rsp+1448]

; 1259 : }

	add	rsp, 1416				; 00000588H
	ret	0
$LN91@omf_write_@9:

; 1255 :         }
; 1256 :     }
; 1257 :     DebugMsg1(("omf_write_comdef exit\n"));
; 1258 :     return( index );

	mov	ax, r12w
	jmp	SHORT $LN86@omf_write_@9
omf_write_comdef ENDP
_TEXT	ENDS
EXTRN	_stat:NEAR
xdata	SEGMENT
$unwind$GetFileTimeStamp DD 010401H
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$GetFileTimeStamp DD @imagerel(GetFileTimeStamp#)
	DD	@imagerel(GetFileTimeStamp#+35)
	DD	@imagerel($unwind$GetFileTimeStamp#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
statbuf$ = 32
filename$ = 96
GetFileTimeStamp PROC NEAR

; 1263 : {

	sub	rsp, 88					; 00000058H

; 1264 :     struct _stat statbuf;
; 1265 : 
; 1266 :     if( _stat( filename, &statbuf ) != 0 ) {

	lea	rdx, QWORD PTR statbuf$[rsp]
	call	_stat
	mov	rcx, QWORD PTR statbuf$[rsp+32]
	xor	edx, edx
	test	eax, eax
	cmovne	rcx, rdx
	mov	rax, rcx

; 1267 :         DebugMsg(("GetFileTimeStamp(%s): _stat() did return 0\n", filename ));
; 1268 :         return( 0 );
; 1269 :     }
; 1270 :     return( statbuf.st_mtime );
; 1271 : }

	add	rsp, 88					; 00000058H
	ret	0
GetFileTimeStamp ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$omf_write_autodep DD 0a2801H
	DD	013d428H
	DD	018641dH
	DD	0175419H
	DD	016340eH
	DD	015010aH
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_autodep DD @imagerel(omf_write_autodep#)
	DD	@imagerel(omf_write_autodep#+59)
	DD	@imagerel($unwind$omf_write_autodep#)
pdata	ENDS
xdata	SEGMENT
$chain$6$omf_write_autodep DD 061221H
	DD	0197412H
	DD	012e408H
	DD	014c404H
	DD	@imagerel(omf_write_autodep#)
	DD	@imagerel(omf_write_autodep#+59)
	DD	@imagerel($unwind$omf_write_autodep#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$omf_write_autodep DD @imagerel(omf_write_autodep#+59)
	DD	@imagerel(omf_write_autodep#+347)
	DD	@imagerel($chain$6$omf_write_autodep#)
pdata	ENDS
xdata	SEGMENT
$chain$7$omf_write_autodep DD 021H
	DD	@imagerel(omf_write_autodep#)
	DD	@imagerel(omf_write_autodep#+59)
	DD	@imagerel($unwind$omf_write_autodep#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$omf_write_autodep DD @imagerel(omf_write_autodep#+347)
	DD	@imagerel(omf_write_autodep#+441)
	DD	@imagerel($chain$7$omf_write_autodep#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
dt$7568 = 32
$T7570 = 40
obj$ = 48
statbuf$7561 = 96
omf_write_autodep PROC NEAR

; 1279 : {

	mov	rax, rsp
	sub	rsp, 168				; 000000a8H
	mov	QWORD PTR [rax+8], rbx

; 1280 :     struct omf_rec  obj;
; 1281 :     struct fname_item *curr;
; 1282 :     char            *p = StringBufferEnd;

	mov	rbx, QWORD PTR ModuleInfo+488
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi

; 1283 :     unsigned int    len;
; 1284 :     unsigned        idx;
; 1285 : 
; 1286 :     DebugMsg(("omf_write_autodep() enter\n"));
; 1287 :     for( idx = 0, curr = ModuleInfo.g.FNames; idx < ModuleInfo.g.cnt_fnames; idx++, curr++ ) {

	mov	rsi, QWORD PTR ModuleInfo+160
	mov	QWORD PTR [rax-16], r13
	xor	r13d, r13d
	cmp	DWORD PTR ModuleInfo+168, r13d
	mov	ebp, r13d
	jbe	$LN2@omf_write_
	mov	QWORD PTR [rax-8], r12
	mov	QWORD PTR [rax-24], r14
	mov	r14d, 255				; 000000ffH
	mov	QWORD PTR [rax+32], rdi
	npad	3
$LL4@omf_write_:

; 1288 :         omf_InitRec( &obj, CMD_COMENT );

	mov	DWORD PTR obj$[rsp], r13d
	mov	DWORD PTR obj$[rsp+4], r13d
	mov	QWORD PTR obj$[rsp+8], r13
	mov	BYTE PTR obj$[rsp+16], 136		; 00000088H
	mov	BYTE PTR obj$[rsp+17], r13b

; 1289 :         obj.d.coment.attr = CMT_TNP;

	mov	BYTE PTR obj$[rsp+20], 128		; 00000080H

; 1290 :         obj.d.coment.cmt_class = CMT_DEPENDENCY; /* 0xE9 */

	mov	BYTE PTR obj$[rsp+21], 233		; 000000e9H

; 1291 : 
; 1292 :         len = strlen( curr->fname );

	mov	r8, QWORD PTR [rsi]
	xor	eax, eax
	mov	rdi, r8
	mov	rcx, -1

; 1293 : #if MAX_STRING_LEN > 255
; 1294 :         if ( len > 255 )
; 1295 :             len = 255; /* length is 1 byte only */
; 1296 : #endif
; 1297 :         /* v2.11: field mtime removed, timestamp read when needed */
; 1298 :         //*((time_t *)p) = timet2dostime( curr->mtime );
; 1299 :         *((time_t *)p) = timet2dostime( GetFileTimeStamp( curr->fname ) );

	lea	rdx, QWORD PTR statbuf$7561[rsp]
	repne scasb
	not	rcx
	dec	rcx
	mov	rdi, rcx
	cmp	ecx, r14d
	mov	rcx, r8
	cmova	edi, r14d
	call	_stat
	mov	rdx, QWORD PTR statbuf$7561[rsp+32]
	test	eax, eax
	lea	rcx, QWORD PTR $T7570[rsp]
	cmovne	rdx, r13
	mov	QWORD PTR $T7570[rsp], rdx
	call	localtime

; 1300 :         *(p + 4) = (unsigned char)len;
; 1301 :         memcpy( p + 5, curr->fname, len );

	mov	r8d, edi
	movzx	edx, WORD PTR [rax+20]
	movzx	ecx, WORD PTR [rax+16]
	inc	cx
	add	dx, 48					; 00000030H
	shl	cx, 5
	shl	dx, 9
	or	dx, cx
	movzx	ecx, WORD PTR [rax+8]
	or	dx, WORD PTR [rax+12]
	shl	cx, 6
	or	cx, WORD PTR [rax+4]
	mov	eax, DWORD PTR [rax]
	mov	WORD PTR dt$7568[rsp+2], dx
	cdq
	shl	cx, 5
	sub	eax, edx
	sar	eax, 1
	or	cx, ax
	mov	WORD PTR dt$7568[rsp], cx
	lea	rcx, QWORD PTR [rbx+5]
	mov	rax, QWORD PTR dt$7568[rsp]
	mov	QWORD PTR [rbx], rax
	mov	BYTE PTR [rbx+4], dil
	mov	rdx, QWORD PTR [rsi]
	call	memcpy

; 1302 :         AttachData( &obj, (uint_8 *)p, len + 5 );

	lea	eax, DWORD PTR [rdi+5]

; 1303 :         DebugMsg(("omf_write_autodep(): write record: file=%s, time=%X\n", curr->fname, *((time_t *)p) ));
; 1304 :         omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	DWORD PTR obj$[rsp], eax
	mov	QWORD PTR obj$[rsp+8], rbx
	call	omf_write_record
	inc	ebp
	add	rsi, 8
	cmp	ebp, DWORD PTR ModuleInfo+168
	jb	$LL4@omf_write_
	mov	r14, QWORD PTR [rsp+144]
	mov	r12, QWORD PTR [rsp+160]
	mov	rdi, QWORD PTR [rsp+200]
$LN2@omf_write_:

; 1305 :     }
; 1306 :     /* one NULL dependency record must be on the end */
; 1307 :     omf_InitRec( &obj, CMD_COMENT );
; 1308 :     obj.d.coment.attr = CMT_TNP;
; 1309 :     obj.d.coment.cmt_class = CMT_DEPENDENCY;
; 1310 :     AttachData( &obj, (uint_8 *)"", 0 );

	lea	rax, OFFSET FLAT:$SG6717

; 1311 :     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	DWORD PTR obj$[rsp+4], r13d
	mov	BYTE PTR obj$[rsp+16], 136		; 00000088H
	mov	BYTE PTR obj$[rsp+17], r13b
	mov	BYTE PTR obj$[rsp+20], 128		; 00000080H
	mov	QWORD PTR obj$[rsp+8], rax
	mov	BYTE PTR obj$[rsp+21], 233		; 000000e9H
	mov	DWORD PTR obj$[rsp], r13d
	call	omf_write_record
	mov	r13, QWORD PTR [rsp+152]
	mov	rsi, QWORD PTR [rsp+192]
	mov	rbp, QWORD PTR [rsp+184]
	mov	rbx, QWORD PTR [rsp+176]

; 1312 :     DebugMsg(("omf_write_autodep() exit\n"));
; 1313 :     return( NOT_ERROR );

	xor	eax, eax

; 1314 : }

	add	rsp, 168				; 000000a8H
	ret	0
omf_write_autodep ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$omf_write_alias DD 040e01H
	DD	06b540eH
	DD	069010aH
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_alias DD @imagerel(omf_write_alias#)
	DD	@imagerel(omf_write_alias#+30)
	DD	@imagerel($unwind$omf_write_alias#)
pdata	ENDS
xdata	SEGMENT
$chain$4$omf_write_alias DD 081021H
	DD	06d7410H
	DD	06c640cH
	DD	06a3408H
	DD	068c404H
	DD	@imagerel(omf_write_alias#)
	DD	@imagerel(omf_write_alias#+30)
	DD	@imagerel($unwind$omf_write_alias#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$omf_write_alias DD @imagerel(omf_write_alias#+30)
	DD	@imagerel(omf_write_alias#+239)
	DD	@imagerel($chain$4$omf_write_alias#)
pdata	ENDS
xdata	SEGMENT
$chain$5$omf_write_alias DD 021H
	DD	@imagerel(omf_write_alias#)
	DD	@imagerel(omf_write_alias#+30)
	DD	@imagerel($unwind$omf_write_alias#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$omf_write_alias DD @imagerel(omf_write_alias#+239)
	DD	@imagerel(omf_write_alias#+255)
	DD	@imagerel($chain$5$omf_write_alias#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
obj$ = 32
tmp$ = 80
buff$ = 336
omf_write_alias PROC NEAR

; 1318 : {

	mov	rax, rsp
	sub	rsp, 840				; 00000348H
	mov	QWORD PTR [rax+16], rbp

; 1319 :     struct omf_rec      obj;
; 1320 :     char                *p;
; 1321 :     uint_8              len1;
; 1322 :     uint_8              len2;
; 1323 :     //bool                first = TRUE;
; 1324 :     struct dsym         *curr;
; 1325 :     char                tmp[MAX_ID_LEN + MANGLE_BYTES + 1];
; 1326 :     unsigned char       buff[2*MAX_ID_LEN_OMF + 2];
; 1327 : 
; 1328 :     for( curr = SymTables[TAB_ALIAS].head; curr; curr = curr->next ) {

	mov	rbp, QWORD PTR SymTables+80
	test	rbp, rbp
	je	$LN1@omf_write_
	mov	QWORD PTR [rax-8], r12
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	xor	r12d, r12d
$LL3@omf_write_:

; 1329 : 
; 1330 :         /* output an alias record for this alias */
; 1331 :         /* v2.10: use the decorated names */
; 1332 :         //len1 = curr->sym.name_size;
; 1333 :         len1 = Mangle( &curr->sym, tmp );

	lea	rdx, QWORD PTR tmp$[rsp]
	mov	rcx, rbp
	call	Mangle

; 1334 : #if MAX_ID_LEN > MAX_ID_LEN_OMF
; 1335 :         if ( len1 > MAX_ID_LEN_OMF )
; 1336 :             len1 = MAX_ID_LEN_OMF;
; 1337 : #endif
; 1338 :         p = buff;
; 1339 :         *p++ = len1;
; 1340 :         memcpy( p, tmp, len1 );

	lea	rdx, QWORD PTR tmp$[rsp]
	lea	rcx, QWORD PTR buff$[rsp+1]
	movzx	edi, al
	mov	esi, eax
	mov	r8, rdi
	mov	BYTE PTR buff$[rsp], sil
	call	memcpy

; 1341 :         p += len1;
; 1342 : 
; 1343 :         //len2 = curr->sym.substitute->name_size;
; 1344 :         len2 = Mangle( curr->sym.substitute, tmp );

	mov	rcx, QWORD PTR [rbp+16]
	lea	rdx, QWORD PTR tmp$[rsp]
	call	Mangle

; 1345 : #if MAX_ID_LEN > MAX_ID_LEN_OMF
; 1346 :         if ( len2 > MAX_ID_LEN_OMF )
; 1347 :             len2 = MAX_ID_LEN_OMF;
; 1348 : #endif
; 1349 :         *p++ = len2;

	lea	rcx, QWORD PTR buff$[rsp+rdi+2]

; 1350 :         memcpy( p, tmp, len2 );

	lea	rdx, QWORD PTR tmp$[rsp]
	mov	ebx, eax
	movzx	r8d, al
	mov	BYTE PTR buff$[rsp+rdi+1], bl
	call	memcpy

; 1351 : 
; 1352 :         omf_InitRec( &obj, CMD_ALIAS );
; 1353 :         AttachData( &obj, buff, len1 + len2 + 2 );

	lea	rax, QWORD PTR buff$[rsp]
	mov	QWORD PTR obj$[rsp+8], rax
	movzx	ecx, bl
	movzx	eax, sil
	lea	ecx, DWORD PTR [rcx+rax+2]
	mov	DWORD PTR obj$[rsp+4], r12d
	mov	BYTE PTR obj$[rsp+16], 198		; 000000c6H
	mov	DWORD PTR obj$[rsp], ecx

; 1354 :         omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	BYTE PTR obj$[rsp+17], r12b
	call	omf_write_record
	mov	rbp, QWORD PTR [rbp+112]
	test	rbp, rbp
	jne	$LL3@omf_write_
	mov	r12, QWORD PTR [rsp+832]
	mov	rdi, QWORD PTR [rsp+872]
	mov	rsi, QWORD PTR [rsp+864]
	mov	rbx, QWORD PTR [rsp+848]
$LN1@omf_write_:
	mov	rbp, QWORD PTR [rsp+856]

; 1355 :         //first = FALSE;
; 1356 :     }
; 1357 : }

	add	rsp, 840				; 00000348H
	ret	0
omf_write_alias ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$omf_write_pubdef DD 040e01H
	DD	010c40eH
	DD	011010aH
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_pubdef DD @imagerel(omf_write_pubdef#)
	DD	@imagerel(omf_write_pubdef#+30)
	DD	@imagerel($unwind$omf_write_pubdef#)
pdata	ENDS
xdata	SEGMENT
$chain$7$omf_write_pubdef DD 0e2a21H
	DD	0fd42aH
	DD	0157426H
	DD	014641fH
	DD	013541bH
	DD	0123417H
	DD	0df40dH
	DD	0ee404H
	DD	@imagerel(omf_write_pubdef#)
	DD	@imagerel(omf_write_pubdef#+30)
	DD	@imagerel($unwind$omf_write_pubdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$omf_write_pubdef DD @imagerel(omf_write_pubdef#+30)
	DD	@imagerel(omf_write_pubdef#+672)
	DD	@imagerel($chain$7$omf_write_pubdef#)
pdata	ENDS
xdata	SEGMENT
$chain$8$omf_write_pubdef DD 021H
	DD	@imagerel(omf_write_pubdef#)
	DD	@imagerel(omf_write_pubdef#+30)
	DD	@imagerel($unwind$omf_write_pubdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$omf_write_pubdef DD @imagerel(omf_write_pubdef#+672)
	DD	@imagerel(omf_write_pubdef#+690)
	DD	@imagerel($chain$8$omf_write_pubdef#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
curr32$6741 = 32
curr_seg$6738 = 40
obj$6769 = 48
obj$6754 = 48
omf_write_pubdef PROC NEAR

; 1369 : {

	mov	rax, rsp
	sub	rsp, 136				; 00000088H
	mov	QWORD PTR [rax-8], r12

; 1370 :     struct qnode        *q;
; 1371 : 
; 1372 :     DebugMsg1(("omf_write_pub enter\n"));
; 1373 : 
; 1374 :     /* v2.07: struct pubdef_data has been modified to match
; 1375 :      * the data to be written to the object module more closely.
; 1376 :      * This fixed a possible overrun if too many publics were written.
; 1377 :      * v2.11: now the data matches exactly the OMF PUBDEF record
; 1378 :      * and is just attached.
; 1379 :      */
; 1380 : 
; 1381 :     q = ModuleInfo.g.PubQueue.head;

	mov	r12, QWORD PTR ModuleInfo+16

; 1382 :     while ( q ) {

	test	r12, r12
	je	$LN38@omf_write_
	mov	QWORD PTR [rax-24], r14
	mov	r14, QWORD PTR curr_seg$6738[rsp]
	mov	QWORD PTR [rax-32], r15
	movzx	r15d, BYTE PTR curr32$6741[rsp]
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	xor	r8d, r8d
	mov	QWORD PTR [rax+32], rdi
	mov	QWORD PTR [rax-16], r13
	lea	edx, QWORD PTR [r8+4]
	npad	4
$LL18@omf_write_:

; 1383 :         struct asym     *curr_seg;
; 1384 :         uint_8          *data;
; 1385 :         unsigned        size;
; 1386 :         uint_8          curr32;
; 1387 :         uint_8          is32;
; 1388 : 
; 1389 :         for ( size = 0, data = StringBufferEnd; q; q = q->next ) {

	test	r12, r12
	mov	rbx, QWORD PTR ModuleInfo+488
	mov	esi, r8d
	je	$LN37@omf_write_
$LL16@omf_write_:

; 1390 :             unsigned    recsize;
; 1391 :             unsigned    len;
; 1392 :             struct asym *sym;
; 1393 :             sym = q->sym;

	mov	rdi, QWORD PTR [r12+8]

; 1394 : #if COMDATSUPP
; 1395 :             /* COMDAT symbol? Then write an LNAME record */
; 1396 :             if ( sym->segment && ((struct dsym *)sym->segment)->e.seginfo->comdat_selection ) {

	mov	rcx, QWORD PTR [rdi+32]
	test	rcx, rcx
	je	$LN13@omf_write_
	mov	rax, QWORD PTR [rcx+104]
	test	BYTE PTR [rax+108], 56			; 00000038H
	je	$LN13@omf_write_

; 1397 :                 struct dsym *seg = (struct dsym *)sym->segment;
; 1398 :                 if ( seg->e.seginfo->comdat_idx == 0 ) {

	cmp	WORD PTR [rax+88], 0
	mov	rdx, rax
	jne	$LN15@omf_write_

; 1399 :                     struct omf_rec obj;
; 1400 :                     seg->e.seginfo->comdat_idx = ++startitem;

	mov	eax, DWORD PTR startitem
	inc	eax
	mov	WORD PTR [rdx+88], ax
	mov	DWORD PTR startitem, eax

; 1401 :                     seg->sym.used = sym->used;

	movzx	eax, BYTE PTR [rdi+48]
	xor	al, BYTE PTR [rcx+48]

; 1402 :                     omf_InitRec( &obj, CMD_LNAMES );

	mov	DWORD PTR obj$6754[rsp], r8d
	mov	DWORD PTR obj$6754[rsp+4], r8d
	and	al, 1
	mov	QWORD PTR obj$6754[rsp+8], r8
	mov	BYTE PTR obj$6754[rsp+16], 150		; 00000096H
	xor	BYTE PTR [rcx+48], al

; 1403 :                     len = Mangle( sym, StringBufferEnd + 1 );

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, rdi
	inc	rdx
	mov	BYTE PTR obj$6754[rsp+17], 0
	call	Mangle

; 1404 :                     *StringBufferEnd = len;

	mov	rcx, QWORD PTR ModuleInfo+488
	mov	BYTE PTR [rcx], al

; 1405 :                     if ( ModuleInfo.case_sensitive == FALSE )

	test	BYTE PTR ModuleInfo+408, 2
	mov	edi, eax
	jne	SHORT $LN11@omf_write_

; 1406 :                         _strupr( StringBufferEnd + 1 );

	mov	rcx, QWORD PTR ModuleInfo+488
	inc	rcx
	call	_strupr
$LN11@omf_write_:

; 1407 :                     AttachData( &obj, StringBufferEnd, len + 1 );

	mov	rcx, QWORD PTR ModuleInfo+488
	lea	eax, DWORD PTR [rdi+1]
	mov	QWORD PTR obj$6754[rsp+8], rcx

; 1408 :                     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$6754[rsp]
	mov	DWORD PTR obj$6754[rsp], eax
	call	omf_write_record

; 1409 :                 } else if ( Parse_Pass == PASS_1 ) {
; 1410 :                     /* ??? */
; 1411 :                 }
; 1412 :                 continue;

	xor	r8d, r8d
	jmp	$LN15@omf_write_
$LN13@omf_write_:

; 1413 :             }
; 1414 : #endif
; 1415 :             /* for constants, Masm checks if the value will fit in a 16-bit field,
; 1416 :              * either signed ( -32768 ... 32767 ) or unsigned ( 0 ... 65635 ).
; 1417 :              * As a result, the following code:
; 1418 :              * E1 equ 32768
; 1419 :              * E2 equ -32768
; 1420 :              * PUBLIC E1, E2
; 1421 :              * will store both equates with value 8000h in the 16-bit PUBDEF record!!!
; 1422 :              * HJWasm behaves differently, resulting in negative values to be stored as 32-bit.
; 1423 :              */
; 1424 : #if 1
; 1425 :             is32 = ( sym->offset > 0xffffUL ? 1 : 0 );

	cmp	DWORD PTR [rdi+16], 65535		; 0000ffffH
	seta	bpl

; 1426 : #else
; 1427 :             is32 = ( sym->offset > 0xffff || sym->offset < -32768 ? 1 : 0 ); /* this is what Masm does */
; 1428 : #endif
; 1429 :             /* check if public fits in current record yet.
; 1430 :              * 4 bytes omf record overhead, 4 for base info, 1+1+4/2 for name_size, type & offset
; 1431 :              */
; 1432 :             recsize = size + sym->name_size + MANGLE_BYTES + 4+4+1+1+( is32 ? 4 : 2 );
; 1433 :             /* exit loop if segment or offset magnitude changes, or record becomes too big */
; 1434 :             if( size && ( sym->segment != curr_seg || is32 != curr32 || recsize > MAX_PUB_LENGTH ) )

	test	esi, esi
	je	SHORT $LN8@omf_write_
	cmp	rcx, r14
	jne	$LN7@omf_write_
	cmp	bpl, r15b
	jne	$LN7@omf_write_
	movzx	ecx, BYTE PTR [rdi+80]
	test	bpl, bpl
	mov	eax, 2
	cmovne	eax, edx
	add	eax, esi
	lea	ecx, DWORD PTR [rcx+rax+18]
	cmp	ecx, 1024				; 00000400H
	ja	SHORT $LN7@omf_write_
$LN8@omf_write_:

; 1435 :                 break;
; 1436 :             len = Mangle( sym, data + 1 );

	lea	rdx, QWORD PTR [rbx+1]
	mov	rcx, rdi
	call	Mangle

; 1437 : #if MAX_ID_LEN > MAX_ID_LEN_OMF
; 1438 :             if ( len > 255 )
; 1439 :                 len = 255; /* length is 1 byte only */
; 1440 : #endif
; 1441 :             if ( ModuleInfo.convert_uppercase )

	test	BYTE PTR ModuleInfo+408, 4
	mov	r13d, eax
	je	SHORT $LN6@omf_write_

; 1442 :                 _strupr( data + 1 );

	lea	rcx, QWORD PTR [rbx+1]
	call	_strupr
$LN6@omf_write_:

; 1443 :             curr_seg = sym->segment;

	mov	r14, QWORD PTR [rdi+32]

; 1444 :             curr32 = is32;
; 1445 : 
; 1446 :             *data = len;
; 1447 :             data += len + 1;

	lea	ecx, DWORD PTR [r13+1]
	mov	BYTE PTR [rbx], r13b
	add	rbx, rcx

; 1448 :             if ( curr32 ) {

	test	bpl, bpl
	mov	r15b, bpl
	je	SHORT $LN5@omf_write_

; 1449 :                 *(uint_32 *)data = sym->offset;

	mov	eax, DWORD PTR [rdi+16]

; 1450 :                 data += sizeof( uint_32 );

	add	rbx, 4
	mov	DWORD PTR [rbx-4], eax

; 1451 :             } else {

	jmp	SHORT $LN4@omf_write_
$LN5@omf_write_:

; 1452 :                 *(uint_16 *)data = sym->offset;

	movzx	eax, WORD PTR [rdi+16]

; 1453 :                 data += sizeof( uint_16 );

	add	rbx, 2
	mov	WORD PTR [rbx-2], ax
$LN4@omf_write_:

; 1454 :             }
; 1455 :             *data++ = 0; /* type field */

	mov	BYTE PTR [rbx], 0
	inc	rbx

; 1456 :             size = (char *)data - StringBufferEnd;

	mov	esi, ebx
	sub	esi, DWORD PTR ModuleInfo+488
	xor	r8d, r8d
$LN15@omf_write_:
	mov	r12, QWORD PTR [r12]
	mov	edx, 4
	test	r12, r12
	jne	$LL16@omf_write_
$LN7@omf_write_:

; 1457 :         }
; 1458 :         if ( size ) {

	test	esi, esi
	je	$LN3@omf_write_

; 1459 :             struct omf_rec      obj;
; 1460 :             omf_InitRec( &obj, CMD_PUBDEF );
; 1461 :             AttachData( &obj, StringBufferEnd, size );
; 1462 :             obj.is_32 = curr32;
; 1463 :             if( curr_seg == NULL ) { /* absolute symbol, no segment */

	test	r14, r14
	mov	rax, QWORD PTR ModuleInfo+488
	mov	DWORD PTR obj$6769[rsp+4], r8d
	mov	BYTE PTR obj$6769[rsp+16], 144		; 00000090H
	mov	DWORD PTR obj$6769[rsp], esi
	mov	BYTE PTR obj$6769[rsp+17], r15b
	mov	QWORD PTR obj$6769[rsp+8], rax
	jne	SHORT $LN2@omf_write_

; 1464 :                 obj.d.pubdef.base.grp_idx = 0;

	mov	WORD PTR obj$6769[rsp+20], r14w

; 1465 :                 obj.d.pubdef.base.seg_idx = 0;

	mov	WORD PTR obj$6769[rsp+22], r14w

; 1466 :             } else {

	jmp	SHORT $LN32@omf_write_
$LN2@omf_write_:

; 1467 :                 obj.d.pubdef.base.seg_idx = GetSegIdx( curr_seg );

	mov	rcx, r14
	call	GetSegIdx

; 1468 :                 obj.d.pubdef.base.grp_idx = omf_GetGrpIdx( GetGroup( curr_seg ) );

	mov	rcx, r14
	mov	WORD PTR obj$6769[rsp+22], ax
	call	GetGroup
	test	rax, rax
	je	SHORT $LN31@omf_write_
	mov	rax, QWORD PTR [rax+104]
	movzx	ecx, WORD PTR [rax+8]
	mov	WORD PTR obj$6769[rsp+20], cx
	jmp	SHORT $LN32@omf_write_
$LN31@omf_write_:
	mov	WORD PTR obj$6769[rsp+20], 0
$LN32@omf_write_:

; 1469 :             }
; 1470 :             obj.d.pubdef.base.frame = 0;
; 1471 :             omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$6769[rsp]
	mov	WORD PTR obj$6769[rsp+24], 0
	call	omf_write_record
$LN3@omf_write_:
	test	r12, r12
	mov	edx, 4
	lea	r8d, QWORD PTR [rdx-4]
	jne	$LL18@omf_write_
$LN37@omf_write_:
	mov	rbp, QWORD PTR [rsp+152]
	mov	r13, QWORD PTR [rsp+120]
	mov	rdi, QWORD PTR [rsp+168]
	mov	rsi, QWORD PTR [rsp+160]
	mov	rbx, QWORD PTR [rsp+144]
	mov	r14, QWORD PTR [rsp+112]
	mov	r15, QWORD PTR [rsp+104]

; 1472 :         }
; 1473 :     }
; 1474 : 
; 1475 :     DebugMsg1(("omf_write_pub exit\n"));
; 1476 :     return( NOT_ERROR );

	xor	eax, eax
	mov	r12, QWORD PTR [rsp+128]

; 1477 : }

	add	rsp, 136				; 00000088H
	ret	0
$LN38@omf_write_:

; 1472 :         }
; 1473 :     }
; 1474 : 
; 1475 :     DebugMsg1(("omf_write_pub exit\n"));
; 1476 :     return( NOT_ERROR );

	xor	eax, eax
	mov	r12, QWORD PTR [rsp+128]

; 1477 : }

	add	rsp, 136				; 00000088H
	ret	0
omf_write_pubdef ENDP
_TEXT	ENDS
EXTRN	OmfFixGenFixModend:NEAR
EXTRN	GetSymOfssize:NEAR
xdata	SEGMENT
$unwind$omf_write_modend DD 071801H
	DD	0117418H
	DD	0106414H
	DD	0f340bH
	DD	0c207H
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_modend DD @imagerel(omf_write_modend#)
	DD	@imagerel(omf_write_modend#+162)
	DD	@imagerel($unwind$omf_write_modend#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buffer$ = 32
obj$ = 48
fixup$ = 112
displ$ = 120
omf_write_modend PROC NEAR

; 1481 : {

	mov	rax, rsp
	sub	rsp, 104				; 00000068H
	mov	QWORD PTR [rax+16], rbx

; 1482 :     struct omf_rec  obj;
; 1483 :     uint_8 buffer[FIX_GEN_MODEND_MAX];
; 1484 : 
; 1485 :     DebugMsg(("omf_write_modend( fixup=%p, displ=%" I32_SPEC "X)\n", fixup, displ ));
; 1486 : 
; 1487 :     omf_InitRec( &obj, CMD_MODEND );

	xor	ebx, ebx

; 1488 : 
; 1489 :     if( fixup == NULL ) {

	test	rcx, rcx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	BYTE PTR [rax-40], 138			; 0000008aH
	mov	DWORD PTR [rax-56], ebx
	mov	DWORD PTR [rax-52], ebx
	mov	QWORD PTR [rax-48], rbx
	mov	BYTE PTR [rax-39], bl
	mov	esi, edx
	mov	rdi, rcx
	jne	SHORT $LN2@omf_write_

; 1490 :         obj.d.modend.main_module = FALSE;

	mov	BYTE PTR [rax-36], bl

; 1491 :         obj.d.modend.start_addrs = FALSE;

	mov	BYTE PTR [rax-35], bl

; 1492 :     } else {

	jmp	SHORT $LN1@omf_write_
$LN2@omf_write_:

; 1493 :         obj.d.modend.start_addrs = TRUE;
; 1494 :         obj.d.modend.main_module = TRUE;
; 1495 :         obj.is_32 = ( GetSymOfssize( fixup->sym ) > USE16 ? 1 : 0 ); /* USE16 or USE32 */

	mov	rcx, QWORD PTR [rcx+56]
	mov	BYTE PTR obj$[rsp+21], 1
	mov	BYTE PTR obj$[rsp+20], 1
	call	GetSymOfssize

; 1496 :         AttachData( &obj, buffer, 0 );

	lea	rcx, QWORD PTR buffer$[rsp]
	mov	DWORD PTR obj$[rsp], ebx
	test	eax, eax
	mov	QWORD PTR obj$[rsp+8], rcx

; 1497 :         obj.length = OmfFixGenFixModend( fixup, buffer, displ, obj.is_32 ? FIX_GEN_MS386 : FIX_GEN_INTEL );

	lea	rdx, QWORD PTR buffer$[rsp]
	setg	al
	mov	r8d, esi
	mov	rcx, rdi
	test	al, al
	mov	BYTE PTR obj$[rsp+17], al
	setne	bl
	mov	r9d, ebx
	call	OmfFixGenFixModend
	mov	DWORD PTR obj$[rsp], eax
$LN1@omf_write_:

; 1498 :     }
; 1499 :     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record
	mov	rdi, QWORD PTR [rsp+136]
	mov	rsi, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [rsp+120]

; 1500 : }

	add	rsp, 104				; 00000068H
	ret	0
omf_write_modend ENDP
_TEXT	ENDS
EXTRN	cv_write_debug_tables:NEAR
_BSS	SEGMENT
	ALIGN	8

SymDebSeg DQ	02H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$omf_write_debug_tables DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_debug_tables DD @imagerel(omf_write_debug_tables#)
	DD	@imagerel(omf_write_debug_tables#+97)
	DD	@imagerel($unwind$omf_write_debug_tables#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
omf_write_debug_tables PROC NEAR

; 1547 : {

	sub	rsp, 40					; 00000028H

; 1548 :     if ( SymDebSeg[DBGS_SYMBOLS] && SymDebSeg[DBGS_TYPES] ) {

	mov	rcx, QWORD PTR SymDebSeg
	test	rcx, rcx
	je	SHORT $LN1@omf_write_
	cmp	QWORD PTR SymDebSeg+8, 0
	je	SHORT $LN1@omf_write_

; 1549 :         SymDebSeg[DBGS_SYMBOLS]->e.seginfo->CodeBuffer = CurrSource;

	mov	rcx, QWORD PTR [rcx+104]
	mov	rax, QWORD PTR ModuleInfo+464

; 1550 :         SymDebSeg[DBGS_TYPES]->e.seginfo->CodeBuffer = CurrSource + 1024;
; 1551 :         cv_write_debug_tables( SymDebSeg[DBGS_SYMBOLS], SymDebSeg[DBGS_TYPES], NULL );

	xor	r8d, r8d
	mov	QWORD PTR [rcx+16], rax
	mov	rax, QWORD PTR SymDebSeg+8
	mov	rdx, QWORD PTR ModuleInfo+464
	mov	rcx, QWORD PTR [rax+104]
	add	rdx, 1024				; 00000400H
	mov	QWORD PTR [rcx+16], rdx
	mov	rdx, QWORD PTR SymDebSeg+8
	mov	rcx, QWORD PTR SymDebSeg
	call	cv_write_debug_tables
$LN1@omf_write_:

; 1552 :     }
; 1553 : }

	add	rsp, 40					; 00000028H
	ret	0
omf_write_debug_tables ENDP
_TEXT	ENDS
EXTRN	_chsize:NEAR
EXTRN	ftell:NEAR
_BSS	SEGMENT
public_pos DD	01H DUP (?)
seg_pos	DD	01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$omf_write_module DD 078301H
	DD	0117483H
	DD	0106475H
	DD	0f3410H
	DD	0c204H
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_module DD @imagerel(omf_write_module#)
	DD	@imagerel(omf_write_module#+366)
	DD	@imagerel($unwind$omf_write_module#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buffer$7708 = 32
obj$7707 = 48
modinfo$ = 112
omf_write_module PROC NEAR

; 1563 : {

	sub	rsp, 104				; 00000068H

; 1564 : #if TRUNCATE
; 1565 :     int fh;
; 1566 :     uint_32 size;
; 1567 : #endif
; 1568 :     /* -if Zi is set, write symbols and types */
; 1569 :     if ( Options.debug_symbols )

	cmp	BYTE PTR Options+2, 0
	mov	QWORD PTR [rsp+120], rbx
	mov	rbx, rcx
	je	SHORT $LN4@omf_write_

; 1570 :         omf_write_debug_tables();

	mov	rdx, QWORD PTR SymDebSeg
	test	rdx, rdx
	je	SHORT $LN4@omf_write_
	cmp	QWORD PTR SymDebSeg+8, 0
	je	SHORT $LN4@omf_write_
	mov	rdx, QWORD PTR [rdx+104]
	mov	rax, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	mov	QWORD PTR [rdx+16], rax
	mov	rax, QWORD PTR SymDebSeg+8
	mov	rdx, QWORD PTR ModuleInfo+464
	mov	rcx, QWORD PTR [rax+104]
	add	rdx, 1024				; 00000400H
	mov	QWORD PTR [rcx+16], rdx
	mov	rdx, QWORD PTR SymDebSeg+8
	mov	rcx, QWORD PTR SymDebSeg
	call	cv_write_debug_tables
$LN4@omf_write_:
	mov	QWORD PTR [rsp+128], rsi

; 1571 :     omf_write_modend( modinfo->g.start_fixup, modinfo->g.start_displ );

	mov	esi, DWORD PTR [rbx+216]
	mov	QWORD PTR [rsp+136], rdi
	mov	rdi, QWORD PTR [rbx+208]
	xor	ebx, ebx
	mov	BYTE PTR obj$7707[rsp+16], 138		; 0000008aH
	test	rdi, rdi
	mov	DWORD PTR obj$7707[rsp], ebx
	mov	DWORD PTR obj$7707[rsp+4], ebx
	mov	QWORD PTR obj$7707[rsp+8], rbx
	mov	BYTE PTR obj$7707[rsp+17], bl
	jne	SHORT $LN8@omf_write_
	mov	BYTE PTR obj$7707[rsp+20], bl
	mov	BYTE PTR obj$7707[rsp+21], bl
	jmp	SHORT $LN7@omf_write_
$LN8@omf_write_:
	mov	rcx, QWORD PTR [rdi+56]
	mov	BYTE PTR obj$7707[rsp+21], 1
	mov	BYTE PTR obj$7707[rsp+20], 1
	call	GetSymOfssize
	lea	rcx, QWORD PTR buffer$7708[rsp]
	mov	DWORD PTR obj$7707[rsp], ebx
	test	eax, eax
	mov	QWORD PTR obj$7707[rsp+8], rcx
	lea	rdx, QWORD PTR buffer$7708[rsp]
	setg	al
	mov	r8d, esi
	mov	rcx, rdi
	test	al, al
	mov	BYTE PTR obj$7707[rsp+17], al
	setne	bl
	mov	r9d, ebx
	call	OmfFixGenFixModend
	mov	DWORD PTR obj$7707[rsp], eax
$LN7@omf_write_:
	lea	rcx, QWORD PTR obj$7707[rsp]
	call	omf_write_record

; 1572 : #if FASTMEM==0
; 1573 :     LclFree( modinfo->g.start_fixup );
; 1574 : #endif
; 1575 : 
; 1576 : #if TRUNCATE
; 1577 :     /* under some very rare conditions, the object
; 1578 :      * module might become shorter! Hence the file
; 1579 :      * must be truncated now. The problem is that there
; 1580 :      * is no stream function for this task.
; 1581 :      * the final solution will be to save the segment contents
; 1582 :      * in buffers and write the object module once everything
; 1583 :      * is done ( as it is done for the other formats already).
; 1584 :      * v2.03: most likely no longer necessary, since the file
; 1585 :      * won't become shorter anymore.
; 1586 :      */
; 1587 :     size = ftell( CurrFile[OBJ] );

	mov	rcx, QWORD PTR ModuleInfo+104
	call	ftell

; 1588 : #if defined(__UNIX__) || defined(__CYGWIN__) || defined(__DJGPP__)
; 1589 :     fh = fileno( CurrFile[OBJ] );
; 1590 :     if ( ftruncate( fh, size ) ); /* gcc warns if return value of ftruncate() is "ignored" */
; 1591 : #elif defined(__BORLANDC__)
; 1592 :     fh = _fileno( CurrFile[OBJ] );
; 1593 :     chsize( fh, size );
; 1594 : #else
; 1595 :     fh = _fileno( CurrFile[OBJ] );
; 1596 :     _chsize( fh, size );

	mov	edx, eax
	mov	rax, QWORD PTR ModuleInfo+104
	mov	ecx, DWORD PTR [rax+28]
	call	_chsize

; 1597 : #endif
; 1598 : 
; 1599 : #endif
; 1600 : 
; 1601 :     /* write SEGDEF records. Since these records contain the segment's length,
; 1602 :      * the records have to be written again after the final assembly pass.
; 1603 :      */
; 1604 :     fseek( CurrFile[OBJ] , seg_pos, SEEK_SET );

	mov	edx, DWORD PTR seg_pos
	mov	rcx, QWORD PTR ModuleInfo+104
	xor	r8d, r8d
	call	fseek

; 1605 :     omf_write_segdef();

	call	omf_write_segdef

; 1606 :     /* write PUBDEF records. Since the final value of offsets isn't known after
; 1607 :      * the first pass, this has to be called again after the final pass.
; 1608 :      */
; 1609 :     fseek( CurrFile[OBJ], public_pos, SEEK_SET);

	mov	edx, DWORD PTR public_pos
	mov	rcx, QWORD PTR ModuleInfo+104
	xor	r8d, r8d
	call	fseek

; 1610 :     omf_write_pubdef();

	call	omf_write_pubdef
	mov	rdi, QWORD PTR [rsp+136]
	mov	rsi, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [rsp+120]

; 1611 :     return( NOT_ERROR );

	xor	eax, eax

; 1612 : }

	add	rsp, 104				; 00000068H
	ret	0
omf_write_module ENDP
_TEXT	ENDS
_BSS	SEGMENT
startext DD	01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$omf_write_ledata DD 061601H
	DD	0135416H
	DD	0123412H
	DD	011010aH
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_ledata DD @imagerel(omf_write_ledata#)
	DD	@imagerel(omf_write_ledata#+62)
	DD	@imagerel($unwind$omf_write_ledata#)
pdata	ENDS
xdata	SEGMENT
$chain$4$omf_write_ledata DD 061021H
	DD	010c410H
	DD	015740cH
	DD	0146404H
	DD	@imagerel(omf_write_ledata#)
	DD	@imagerel(omf_write_ledata#+62)
	DD	@imagerel($unwind$omf_write_ledata#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$omf_write_ledata DD @imagerel(omf_write_ledata#+62)
	DD	@imagerel(omf_write_ledata#+934)
	DD	@imagerel($chain$4$omf_write_ledata#)
pdata	ENDS
xdata	SEGMENT
$chain$5$omf_write_ledata DD 021H
	DD	@imagerel(omf_write_ledata#)
	DD	@imagerel(omf_write_ledata#+62)
	DD	@imagerel($unwind$omf_write_ledata#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$omf_write_ledata DD @imagerel(omf_write_ledata#+934)
	DD	@imagerel(omf_write_ledata#+968)
	DD	@imagerel($chain$5$omf_write_ledata#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
obj$ = 32
obj$7808 = 80
obj$7776 = 80
seg$ = 144
omf_write_ledata PROC NEAR

; 421  : {

	mov	r11, rsp
	sub	rsp, 136				; 00000088H

; 422  :     struct omf_rec  obj;
; 423  :     int_32          size;
; 424  : 
; 425  :     size = seg->e.seginfo->current_loc - seg->e.seginfo->start_loc;

	mov	rax, QWORD PTR [rcx+104]
	mov	QWORD PTR [r11+8], rbx
	mov	QWORD PTR [r11+16], rbp
	mov	ebx, DWORD PTR [rax+12]
	mov	rbp, rcx
	sub	ebx, DWORD PTR [rax+8]

; 426  :     DebugMsg1(( "omf_write_ledata enter, buffer=%p start ofs=%" I32_SPEC "X, size=%" I32_SPEC "X\n",
; 427  :               seg->e.seginfo->CodeBuffer, seg->e.seginfo->start_loc, size ));
; 428  :     if( size > 0 && write_to_file == TRUE ) {

	test	ebx, ebx
	jle	$LN1@omf_write_
	cmp	BYTE PTR write_to_file, 1
	jne	$LN1@omf_write_

; 429  :         LastCodeBufSize = size;

	mov	DWORD PTR LastCodeBufSize, ebx

; 430  : #if COMDATSUPP
; 431  :         if ( seg->e.seginfo->comdat_selection ) {

	mov	rdx, QWORD PTR [rcx+104]
	mov	QWORD PTR [r11+24], rsi
	test	BYTE PTR [rdx+108], 56			; 00000038H
	mov	QWORD PTR [r11+32], rdi
	mov	QWORD PTR [r11-8], r12
	je	$LN9@omf_write_

; 432  :             /* if the COMDAT symbol has been referenced in a FIXUPP,
; 433  :              * a CEXTDEF has to be written.
; 434  :              */
; 435  :             if ( seg->sym.used ) {

	xor	esi, esi
	test	BYTE PTR [rcx+48], 1
	lea	edi, QWORD PTR [rsi+4]
	je	$LN7@omf_write_

; 436  :                 omf_InitRec( &obj, CMD_CEXTDEF );
; 437  :                 AttachData( &obj, StringBufferEnd, 2 * sizeof( uint_16 ) );

	mov	rcx, QWORD PTR ModuleInfo+488
	mov	BYTE PTR obj$[rsp+16], 188		; 000000bcH
	mov	BYTE PTR obj$[rsp+17], sil
	mov	eax, esi
	mov	DWORD PTR obj$[rsp+4], eax
	mov	QWORD PTR [r11-96], rcx
	mov	DWORD PTR obj$[rsp], edi

; 438  :                 PutIndex( &obj, seg->e.seginfo->comdat_idx ); /* Index */

	movzx	r8d, WORD PTR [rdx+88]
	cmp	r8d, 127				; 0000007fH
	jbe	SHORT $LN17@omf_write_
	mov	eax, r8d
	shr	eax, 8
	or	al, 128					; 00000080H
	mov	BYTE PTR [rcx], al
	mov	eax, DWORD PTR obj$[rsp+4]
	inc	eax
	mov	DWORD PTR obj$[rsp+4], eax
	mov	rcx, QWORD PTR [r11-96]
$LN17@omf_write_:
	mov	BYTE PTR [rax+rcx], r8b
	mov	eax, DWORD PTR obj$[rsp+4]
	inc	eax
	mov	DWORD PTR obj$[rsp+4], eax

; 439  :                 PutIndex( &obj, 0 ); /* Type */

	mov	ecx, eax
	mov	rax, QWORD PTR obj$[rsp+8]
	mov	BYTE PTR [rcx+rax], sil
	mov	eax, DWORD PTR obj$[rsp+4]

; 440  :                 TruncRec( &obj );
; 441  :                 omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	inc	eax
	mov	DWORD PTR obj$[rsp+4], eax
	mov	DWORD PTR obj$[rsp], eax
	call	omf_write_record

; 442  :                 if ( seg->e.seginfo->seg_idx == 0 )

	mov	r11, QWORD PTR [rbp+104]
	cmp	DWORD PTR [r11+68], esi
	jne	SHORT $LN7@omf_write_

; 443  :                     seg->e.seginfo->seg_idx = startext++;

	mov	eax, DWORD PTR startext
	mov	DWORD PTR [r11+68], eax
	inc	eax
	mov	DWORD PTR startext, eax
$LN7@omf_write_:

; 444  :             }
; 445  : 
; 446  :             omf_InitRec( &obj, CMD_COMDAT );
; 447  :             AttachData( &obj, seg->e.seginfo->CodeBuffer, size );

	mov	rcx, QWORD PTR [rbp+104]
	xor	dl, dl
	mov	DWORD PTR obj$[rsp], esi
	mov	QWORD PTR obj$[rsp+8], rsi
	mov	BYTE PTR obj$[rsp+17], dl
	mov	DWORD PTR obj$[rsp+4], esi
	mov	BYTE PTR obj$[rsp+16], 194		; 000000c2H
	mov	rax, QWORD PTR [rcx+16]
	mov	DWORD PTR obj$[rsp], ebx
	mov	QWORD PTR obj$[rsp+8], rax

; 448  :             if( seg->e.seginfo->start_loc > 0xffffUL )

	cmp	DWORD PTR [rcx+8], 65535		; 0000ffffH
	mov	r12d, 1
	movzx	eax, dl

; 449  :                 obj.is_32 = 1;
; 450  :             obj.d.comdat.flags = 0;

	mov	BYTE PTR obj$[rsp+20], dl
	cmova	eax, r12d
	mov	BYTE PTR obj$[rsp+17], al

; 451  :             /* low 4-bits is allocation type */
; 452  :             if ( seg->e.seginfo->segtype == SEGTYPE_CODE ) {

	cmp	DWORD PTR [rcx+72], r12d
	jne	SHORT $LN5@omf_write_

; 453  :                 obj.d.comdat.attributes = ( ModuleInfo.model == MODEL_FLAT ? COMDAT_CODE32 : COMDAT_FAR_CODE );

	cmp	DWORD PTR ModuleInfo+360, 7
	mov	eax, r12d
	mov	edx, 3
	cmove	eax, edx
	mov	BYTE PTR obj$[rsp+21], al

; 454  :             } else {

	jmp	SHORT $LN4@omf_write_
$LN5@omf_write_:

; 455  :                 obj.d.comdat.attributes = ( ModuleInfo.model == MODEL_FLAT ? COMDAT_DATA32 : COMDAT_FAR_DATA );

	cmp	DWORD PTR ModuleInfo+360, 7
	mov	eax, 2
	cmove	eax, edi
	mov	BYTE PTR obj$[rsp+21], al
$LN4@omf_write_:

; 456  :             }
; 457  :             obj.d.comdat.align = get_omfalign( seg->e.seginfo->alignment );

	movzx	ecx, BYTE PTR [rcx+106]
	dec	ecx
	je	SHORT $LN31@omf_write_
	dec	ecx
	je	SHORT $LN30@omf_write_
	sub	ecx, 2
	je	SHORT $LN29@omf_write_
	sub	ecx, edi
	je	SHORT $LN28@omf_write_
	cmp	ecx, 247				; 000000f7H
	je	SHORT $LN27@omf_write_
	movzx	eax, r12b
	jmp	SHORT $LN34@omf_write_
$LN27@omf_write_:
	xor	al, al
	jmp	SHORT $LN34@omf_write_
$LN28@omf_write_:
	mov	al, dil
	jmp	SHORT $LN34@omf_write_
$LN29@omf_write_:
	mov	al, 3
	jmp	SHORT $LN34@omf_write_
$LN30@omf_write_:
	mov	al, 5
	jmp	SHORT $LN34@omf_write_
$LN31@omf_write_:
	mov	al, 2
$LN34@omf_write_:

; 458  :             obj.d.comdat.offset = seg->e.seginfo->start_loc;

	mov	rcx, QWORD PTR [rbp+104]
	mov	BYTE PTR obj$[rsp+22], al
	mov	eax, DWORD PTR [rcx+8]

; 459  :             obj.d.comdat.type_idx = 0;

	mov	WORD PTR obj$[rsp+28], si
	mov	DWORD PTR obj$[rsp+24], eax

; 460  :             obj.d.comdat.public_lname_idx = seg->e.seginfo->comdat_idx;

	movzx	eax, WORD PTR [rcx+88]
	mov	WORD PTR obj$[rsp+36], ax

; 461  :             /* todo: error if comdat_idx is 0 */
; 462  :         } else {

	jmp	SHORT $LN2@omf_write_
$LN9@omf_write_:

; 463  : #endif
; 464  :             omf_InitRec( &obj, CMD_LEDATA );

	xor	esi, esi
	xor	r8b, r8b
	mov	BYTE PTR obj$[rsp+16], 160		; 000000a0H
	mov	DWORD PTR obj$[rsp], esi
	mov	QWORD PTR obj$[rsp+8], rsi
	mov	BYTE PTR obj$[rsp+17], r8b
	mov	DWORD PTR obj$[rsp+4], esi

; 465  :             AttachData( &obj, seg->e.seginfo->CodeBuffer, size );

	mov	rax, QWORD PTR [rdx+16]
	mov	DWORD PTR obj$[rsp], ebx
	mov	QWORD PTR obj$[rsp+8], rax

; 466  :             obj.d.ledata.idx = seg->e.seginfo->seg_idx;

	movzx	eax, WORD PTR [rdx+68]

; 467  :             obj.d.ledata.offset = seg->e.seginfo->start_loc;
; 468  :             if( obj.d.ledata.offset > 0xffffUL )

	mov	r12d, 1
	mov	WORD PTR obj$[rsp+20], ax
	mov	edx, DWORD PTR [rdx+8]
	movzx	eax, r8b
	cmp	edx, 65535				; 0000ffffH
	mov	DWORD PTR obj$[rsp+24], edx
	cmova	eax, r12d
	mov	BYTE PTR obj$[rsp+17], al
$LN2@omf_write_:

; 469  :                 obj.is_32 = 1;
; 470  : #if COMDATSUPP
; 471  :         }
; 472  : #endif
; 473  :         omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	call	omf_write_record

; 474  : 
; 475  :         /* process Fixup, if any */
; 476  :         if( seg->e.seginfo->FixupList.head != NULL ) {

	mov	rbx, QWORD PTR [rbp+104]
	cmp	QWORD PTR [rbx+40], 0
	je	$LN92@omf_write_

; 477  : #if FASTMEM==0
; 478  :             struct fixup *fix;
; 479  :             struct fixup *next;
; 480  : #endif
; 481  :             omf_write_fixupp( seg, 0 );

	mov	rbx, QWORD PTR [rbx+40]
	test	rbx, rbx
	je	$LN88@omf_write_
	mov	rdx, QWORD PTR ModuleInfo+488
	npad	5
$LL52@omf_write_:
	test	rbx, rbx
	mov	rdi, rdx
	mov	ecx, esi
	je	$LN86@omf_write_
	npad	2
$LL50@omf_write_:
	mov	eax, DWORD PTR [rbx+24]
	cmp	eax, 3
	je	SHORT $LN49@omf_write_
	cmp	eax, 6
	je	SHORT $LN49@omf_write_
	cmp	eax, 10
	je	SHORT $LN49@omf_write_
	cmp	ecx, 1009				; 000003f1H
	ja	SHORT $LN82@omf_write_
	mov	rax, QWORD PTR [rbp+104]
	xor	r9d, r9d
	mov	r8, rdi
	mov	edx, DWORD PTR [rax+8]
	mov	rcx, rbx
	call	OmfFixGenFix
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	r11d, eax
	add	rdi, r11
	mov	ecx, edi
	sub	ecx, edx
$LN49@omf_write_:
	mov	rbx, QWORD PTR [rbx+8]
	test	rbx, rbx
	jne	SHORT $LL50@omf_write_
$LN82@omf_write_:
	test	ecx, ecx
	je	SHORT $LN40@omf_write_
	mov	DWORD PTR obj$7776[rsp], ecx
	lea	rcx, QWORD PTR obj$7776[rsp]
	mov	DWORD PTR obj$7776[rsp+4], esi
	mov	BYTE PTR obj$7776[rsp+16], 156		; 0000009cH
	mov	BYTE PTR obj$7776[rsp+17], 0
	mov	QWORD PTR obj$7776[rsp+8], rdx
	call	omf_write_record
	mov	rdx, QWORD PTR ModuleInfo+488
$LN40@omf_write_:
	test	rbx, rbx
	jne	$LL52@omf_write_
	jmp	SHORT $LN86@omf_write_
$LN88@omf_write_:
	mov	rdx, QWORD PTR ModuleInfo+488
$LN86@omf_write_:

; 482  :             omf_write_fixupp( seg, 1 );

	mov	rax, QWORD PTR [rbp+104]
	mov	rbx, QWORD PTR [rax+40]
	test	rbx, rbx
	je	$LN89@omf_write_
	npad	8
$LL71@omf_write_:
	test	rbx, rbx
	mov	rdi, rdx
	mov	ecx, esi
	je	$LN89@omf_write_
	npad	2
$LL69@omf_write_:
	mov	eax, DWORD PTR [rbx+24]
	cmp	eax, 3
	je	SHORT $LN64@omf_write_
	cmp	eax, 6
	je	SHORT $LN64@omf_write_
	cmp	eax, 10
	jne	SHORT $LN68@omf_write_
$LN64@omf_write_:
	cmp	ecx, 1009				; 000003f1H
	ja	SHORT $LN83@omf_write_
	mov	rax, QWORD PTR [rbp+104]
	mov	r9d, r12d
	mov	r8, rdi
	mov	edx, DWORD PTR [rax+8]
	mov	rcx, rbx
	call	OmfFixGenFix
	mov	rdx, QWORD PTR ModuleInfo+488
	mov	r11d, eax
	add	rdi, r11
	mov	ecx, edi
	sub	ecx, edx
$LN68@omf_write_:
	mov	rbx, QWORD PTR [rbx+8]
	test	rbx, rbx
	jne	SHORT $LL69@omf_write_
$LN83@omf_write_:
	test	ecx, ecx
	je	SHORT $LN59@omf_write_
	mov	DWORD PTR obj$7808[rsp], ecx
	lea	rcx, QWORD PTR obj$7808[rsp]
	mov	DWORD PTR obj$7808[rsp+4], esi
	mov	BYTE PTR obj$7808[rsp+16], 156		; 0000009cH
	mov	BYTE PTR obj$7808[rsp+17], 1
	mov	QWORD PTR obj$7808[rsp+8], rdx
	call	omf_write_record
	mov	rdx, QWORD PTR ModuleInfo+488
$LN59@omf_write_:
	test	rbx, rbx
	jne	$LL71@omf_write_
$LN89@omf_write_:

; 483  : #if FASTMEM==0
; 484  :             for( fix = seg->e.seginfo->FixupList.head; fix; ) {
; 485  :                 next = fix->nextrlc;
; 486  :                 LclFree( fix );
; 487  :                 fix = next;
; 488  :             }
; 489  : #endif
; 490  :             seg->e.seginfo->FixupList.head = seg->e.seginfo->FixupList.tail = NULL;

	mov	rax, QWORD PTR [rbp+104]
	mov	QWORD PTR [rax+48], rsi
	mov	rax, QWORD PTR [rbp+104]
	mov	QWORD PTR [rax+40], rsi
$LN92@omf_write_:
	mov	rdi, QWORD PTR [rsp+168]
	mov	rsi, QWORD PTR [rsp+160]
	mov	r12, QWORD PTR [rsp+128]
$LN1@omf_write_:

; 491  :         }
; 492  :     }
; 493  :     seg->e.seginfo->start_loc = seg->e.seginfo->current_loc;

	mov	rcx, QWORD PTR [rbp+104]
	mov	rbx, QWORD PTR [rsp+144]
	mov	rbp, QWORD PTR [rsp+152]
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rcx+8], eax

; 494  : }

	add	rsp, 136				; 00000088H
	ret	0
omf_write_ledata ENDP
_TEXT	ENDS
PUBLIC	omf_FlushCurrSeg
_BSS	SEGMENT
ln_size	DW	01H DUP (?)
	ALIGN	4

ln_is32	DB	01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$omf_FlushCurrSeg DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$omf_FlushCurrSeg DD @imagerel($LN4#)
	DD	@imagerel($LN4#+51)
	DD	@imagerel($unwind$omf_FlushCurrSeg#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
omf_FlushCurrSeg PROC NEAR

; 503  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 504  :     //unsigned i;
; 505  :     //unsigned size;
; 506  : 
; 507  :     DebugMsg1(( "omf_FlushCurrSeg() enter, CurrSeg=%s, currsrc=%u\n", CurrSeg ? CurrSeg->sym.name : "NULL", get_curr_srcfile() ));
; 508  : 
; 509  :     omf_write_ledata( CurrSeg );

	mov	rcx, QWORD PTR ModuleInfo+432
	call	omf_write_ledata

; 510  :     /* add line numbers if debugging info is desired */
; 511  :     //if( write_to_file && Options.line_numbers ) {
; 512  :     if( Options.line_numbers ) {

	cmp	BYTE PTR Options+1, 0
	je	SHORT $LN1@omf_FlushC

; 513  :         omf_write_linnum( ln_is32 );

	movzx	ecx, BYTE PTR ln_is32
	call	omf_write_linnum

; 514  :         ln_size = 0;

	mov	WORD PTR ln_size, 0
$LN1@omf_FlushC:

; 515  :     }
; 516  :     //if ( Options.no_comment_data_in_code_records == FALSE )
; 517  :     //    omf_OutSelect( FALSE );
; 518  :     return;
; 519  : }

	add	rsp, 40					; 00000028H
	ret	0
omf_FlushCurrSeg ENDP
_TEXT	ENDS
PUBLIC	omf_check_flush
EXTRN	GetFName:NEAR
_BSS	SEGMENT
	ALIGN	4

ln_srcfile DD	01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$omf_check_flush DD 051401H
	DD	0f7414H
	DD	0e340fH
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$omf_check_flush DD @imagerel($LN29#)
	DD	@imagerel($LN29#+435)
	DD	@imagerel($unwind$omf_check_flush#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
obj$7898 = 32
curr$ = 96
omf_check_flush PROC NEAR

; 562  : {

$LN29:
	sub	rsp, 88					; 00000058H

; 563  :     uint_8 is_32;
; 564  :     uint_16 size;
; 565  : #if MULTIHDR
; 566  :     if ( curr->srcfile != ln_srcfile ) {

	mov	eax, DWORD PTR ln_srcfile
	mov	QWORD PTR [rsp+112], rbx
	mov	QWORD PTR [rsp+120], rdi
	cmp	DWORD PTR [rcx+16], eax
	mov	rbx, rcx
	je	$LN6@omf_check_

; 567  :         if ( LinnumQueue.head )

	cmp	QWORD PTR LinnumQueue, 0
	je	SHORT $LN9@omf_check_

; 568  :             omf_FlushCurrSeg();

	mov	rcx, QWORD PTR ModuleInfo+432
	call	omf_write_ledata
	cmp	BYTE PTR Options+1, 0
	je	SHORT $LN9@omf_check_
	movzx	ecx, BYTE PTR ln_is32
	call	omf_write_linnum
	mov	WORD PTR ln_size, 0
$LN9@omf_check_:

; 569  :         /* todo: for Borland, there's a COMENT ( CMT_SRCFILE ) that could be written
; 570  :          * instead of THEADR.
; 571  :          */
; 572  :         omf_write_theadr( GetFName( curr->srcfile )->fname );

	mov	ecx, DWORD PTR [rbx+16]
	call	GetFName
	mov	DWORD PTR obj$7898[rsp+4], 0
	mov	rcx, -1
	mov	r9, QWORD PTR [rax]
	xor	eax, eax
	mov	BYTE PTR obj$7898[rsp+16], 128		; 00000080H
	mov	rdi, r9
	mov	BYTE PTR obj$7898[rsp+17], 0
	repne scasb
	not	rcx
	lea	rdx, QWORD PTR [rcx-1]
	mov	rcx, QWORD PTR ModuleInfo+488
	lea	eax, DWORD PTR [rdx+1]
	mov	QWORD PTR obj$7898[rsp+8], rcx
	mov	edi, edx
	mov	DWORD PTR obj$7898[rsp], eax
	mov	BYTE PTR [rcx], dil
	mov	eax, DWORD PTR obj$7898[rsp+4]
	inc	eax
	mov	r8d, edx
	mov	rdx, r9
	mov	ecx, eax
	mov	DWORD PTR obj$7898[rsp+4], eax
	add	rcx, QWORD PTR obj$7898[rsp+8]
	call	memcpy
	add	DWORD PTR obj$7898[rsp+4], edi
	lea	rcx, QWORD PTR obj$7898[rsp]
	call	omf_write_record

; 573  :         ln_srcfile = curr->srcfile;

	mov	edx, DWORD PTR [rbx+16]
	mov	DWORD PTR ln_srcfile, edx
	mov	rdi, QWORD PTR [rsp+120]
	mov	rbx, QWORD PTR [rsp+112]

; 597  :     return;
; 598  : };

	add	rsp, 88					; 00000058H
	ret	0
$LN6@omf_check_:

; 574  :         return;
; 575  :     }
; 576  : #endif
; 577  :     /* if there's a change in offset magnitude ( 16 -> 32 or 32 -> 16 ),
; 578  :      * do flush ( Masm compatible ).
; 579  :      */
; 580  :     is_32 = ( curr->offset > 0xffff ? TRUE : FALSE );

	cmp	DWORD PTR [rcx+12], 65535		; 0000ffffH
	seta	bl

; 581  :     if ( ln_is32 != is_32 ) {

	cmp	BYTE PTR ln_is32, bl
	je	SHORT $LN4@omf_check_

; 582  :         if ( LinnumQueue.head )

	cmp	QWORD PTR LinnumQueue, 0
	je	SHORT $LN22@omf_check_

; 583  :             omf_FlushCurrSeg();

	mov	rcx, QWORD PTR ModuleInfo+432
	call	omf_write_ledata
	cmp	BYTE PTR Options+1, 0
	je	SHORT $LN22@omf_check_
	movzx	ecx, BYTE PTR ln_is32
	call	omf_write_linnum
	mov	WORD PTR ln_size, 0
$LN22@omf_check_:

; 584  :         ln_is32 = is_32;

	mov	BYTE PTR ln_is32, bl
	mov	rdi, QWORD PTR [rsp+120]
	mov	rbx, QWORD PTR [rsp+112]

; 597  :     return;
; 598  : };

	add	rsp, 88					; 00000058H
	ret	0
$LN4@omf_check_:

; 585  :         return;
; 586  :     }
; 587  :     /* line number item consists of 16-bit line# and 16- or 32-bit offset */
; 588  :     size = sizeof( uint_16 ) + ( is_32 ? sizeof( uint_32 ) : sizeof( uint_16 ) );
; 589  :     /* if the size of the linnum data exceeds 1016,
; 590  :      * do flush ( Masm compatible ).
; 591  :      */
; 592  :     if ( ln_size + size > 1024 - 8 ) {

	movzx	edx, WORD PTR ln_size
	test	bl, bl
	mov	edi, 2
	mov	eax, 4
	cmovne	di, ax
	add	di, 2
	movzx	ecx, di
	add	ecx, edx
	cmp	ecx, 1016				; 000003f8H
	jle	SHORT $LN25@omf_check_

; 593  :         if ( LinnumQueue.head )

	cmp	QWORD PTR LinnumQueue, 0
	je	SHORT $LN25@omf_check_

; 594  :             omf_FlushCurrSeg();

	mov	rcx, QWORD PTR ModuleInfo+432
	call	omf_write_ledata
	cmp	BYTE PTR Options+1, 0
	je	SHORT $LN28@omf_check_
	movzx	ecx, BYTE PTR ln_is32
	call	omf_write_linnum
	xor	dx, dx
	jmp	SHORT $LN25@omf_check_
$LN28@omf_check_:
	movzx	edx, WORD PTR ln_size
$LN25@omf_check_:
	mov	rbx, QWORD PTR [rsp+112]

; 595  :     }
; 596  :     ln_size += size;

	add	dx, di
	mov	rdi, QWORD PTR [rsp+120]
	mov	WORD PTR ln_size, dx

; 597  :     return;
; 598  : };

	add	rsp, 88					; 00000058H
	ret	0
omf_check_flush ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$omf_cv_flushfunc DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$omf_cv_flushfunc DD @imagerel(omf_cv_flushfunc#)
	DD	@imagerel(omf_cv_flushfunc#+76)
	DD	@imagerel($unwind$omf_cv_flushfunc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
seg$ = 48
curr$ = 56
size$ = 64
pv$ = 72
omf_cv_flushfunc PROC NEAR

; 1506 : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 1507 :     uint_8 *buffer = seg->e.seginfo->CodeBuffer;

	mov	rax, QWORD PTR [rcx+104]
	mov	r10, rcx
	mov	rbx, QWORD PTR [rax+16]

; 1508 : 
; 1509 :     if ( ( curr - buffer ) && ( ( curr - buffer ) + size ) > ( 1024 - 8 ) ) {

	cmp	rdx, rbx
	je	SHORT $LN1@omf_cv_flu
	mov	r8d, r8d
	sub	r8, rbx
	add	r8, rdx
	cmp	r8, 1016				; 000003f8H
	jle	SHORT $LN1@omf_cv_flu

; 1510 :         seg->e.seginfo->current_loc = seg->e.seginfo->start_loc + ( curr - buffer );

	mov	ecx, DWORD PTR [rax+8]
	sub	ecx, ebx
	add	ecx, edx
	mov	DWORD PTR [rax+12], ecx

; 1511 :         omf_write_ledata( seg );

	mov	rcx, r10
	call	omf_write_ledata

; 1512 :         return( buffer );

	mov	rax, rbx

; 1515 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN1@omf_cv_flu:

; 1513 :     }
; 1514 :     return( curr );

	mov	rax, rdx

; 1515 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
omf_cv_flushfunc ENDP
_TEXT	ENDS
EXTRN	CreateIntSegment:NEAR
xdata	SEGMENT
$unwind$omf_write_header_dbgcv DD 092e01H
	DD	011742eH
	DD	010642aH
	DD	0f540fH
	DD	0e340bH
	DD	0c207H
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_header_dbgcv DD @imagerel(omf_write_header_dbgcv#)
	DD	@imagerel(omf_write_header_dbgcv#+206)
	DD	@imagerel($unwind$omf_write_header_dbgcv#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
obj$ = 48
omf_write_header_dbgcv PROC NEAR

; 1525 : {

	mov	rax, rsp
	sub	rsp, 104				; 00000068H
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp

; 1526 :     int i;
; 1527 :     struct omf_rec obj;
; 1528 : 
; 1529 :     omf_InitRec( &obj, CMD_COMENT );

	mov	DWORD PTR [rax-52], 0
	mov	BYTE PTR [rax-40], 136			; 00000088H
	mov	BYTE PTR [rax-39], 0

; 1530 :     obj.d.coment.attr = 0x00;

	mov	BYTE PTR [rax-36], 0

; 1531 :     obj.d.coment.cmt_class = CMT_MS_OMF; /* MS extensions present */

	mov	BYTE PTR [rax-35], 161			; 000000a1H
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi

; 1532 :     AttachData( &obj, "\001CV", 3 );

	lea	rax, OFFSET FLAT:$SG6801

; 1533 :     omf_write_record( &obj );

	lea	rcx, QWORD PTR obj$[rsp]
	mov	DWORD PTR obj$[rsp], 3
	mov	QWORD PTR obj$[rsp+8], rax
	call	omf_write_record
	lea	rdi, OFFSET FLAT:SymDebSeg
	lea	rbx, OFFSET FLAT:SymDebParm
	lea	rbp, OFFSET FLAT:omf_cv_flushfunc
	lea	rsi, OFFSET FLAT:SymDebParm+32
	npad	8
$LL4@omf_write_:

; 1534 :     for ( i = 0; i < DBGS_MAX; i++ ) {
; 1535 :         if ( SymDebSeg[i] = (struct dsym *)CreateIntSegment( SymDebParm[i].name, SymDebParm[i].cname, 0, USE32, TRUE ) ) {

	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rbx]
	mov	r9b, 1
	xor	r8d, r8d
	mov	BYTE PTR [rsp+32], 1
	call	CreateIntSegment
	test	rax, rax
	mov	QWORD PTR [rdi], rax
	je	SHORT $LN3@omf_write_

; 1536 :             SymDebSeg[i]->e.seginfo->force32 = TRUE; /* without this a 32-bit segdef is emitted only if segsize > 64kB */

	mov	rax, QWORD PTR [rax+104]
	or	BYTE PTR [rax+107], 4

; 1537 :             SymDebSeg[i]->e.seginfo->flushfunc = omf_cv_flushfunc;

	mov	rax, QWORD PTR [rdi]
	mov	rcx, QWORD PTR [rax+104]
	mov	QWORD PTR [rcx+32], rbp
$LN3@omf_write_:
	add	rbx, 16
	add	rdi, 8
	cmp	rbx, rsi
	jl	SHORT $LL4@omf_write_
	mov	rdi, QWORD PTR [rsp+136]
	mov	rsi, QWORD PTR [rsp+128]
	mov	rbp, QWORD PTR [rsp+120]
	mov	rbx, QWORD PTR [rsp+112]

; 1538 :         }
; 1539 :     }
; 1540 :     return;
; 1541 : }

	add	rsp, 104				; 00000068H
	ret	0
omf_write_header_dbgcv ENDP
_TEXT	ENDS
EXTRN	SortSegments:NEAR
xdata	SEGMENT
$unwind$omf_write_header_initial DD 010401H
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_header_initial DD @imagerel(omf_write_header_initial#)
	DD	@imagerel(omf_write_header_initial#+26)
	DD	@imagerel($unwind$omf_write_header_initial#)
pdata	ENDS
xdata	SEGMENT
$chain$0$omf_write_header_initial DD 020521H
	DD	0e6405H
	DD	@imagerel(omf_write_header_initial#)
	DD	@imagerel(omf_write_header_initial#+26)
	DD	@imagerel($unwind$omf_write_header_initial#)
xdata	ENDS
pdata	SEGMENT
$pdata$0$omf_write_header_initial DD @imagerel(omf_write_header_initial#+26)
	DD	@imagerel(omf_write_header_initial#+31)
	DD	@imagerel($chain$0$omf_write_header_initial#)
pdata	ENDS
xdata	SEGMENT
$chain$1$omf_write_header_initial DD 020521H
	DD	0f7405H
	DD	@imagerel(omf_write_header_initial#+26)
	DD	@imagerel(omf_write_header_initial#+31)
	DD	@imagerel($chain$0$omf_write_header_initial#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$omf_write_header_initial DD @imagerel(omf_write_header_initial#+31)
	DD	@imagerel(omf_write_header_initial#+253)
	DD	@imagerel($chain$1$omf_write_header_initial#)
pdata	ENDS
xdata	SEGMENT
$chain$2$omf_write_header_initial DD 020521H
	DD	0d3405H
	DD	@imagerel(omf_write_header_initial#+31)
	DD	@imagerel(omf_write_header_initial#+253)
	DD	@imagerel($chain$1$omf_write_header_initial#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$omf_write_header_initial DD @imagerel(omf_write_header_initial#+253)
	DD	@imagerel(omf_write_header_initial#+364)
	DD	@imagerel($chain$2$omf_write_header_initial#)
pdata	ENDS
xdata	SEGMENT
$chain$3$omf_write_header_initial DD 021H
	DD	@imagerel(omf_write_header_initial#+31)
	DD	@imagerel(omf_write_header_initial#+253)
	DD	@imagerel($chain$1$omf_write_header_initial#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$omf_write_header_initial DD @imagerel(omf_write_header_initial#+364)
	DD	@imagerel(omf_write_header_initial#+466)
	DD	@imagerel($chain$3$omf_write_header_initial#)
pdata	ENDS
xdata	SEGMENT
$chain$4$omf_write_header_initial DD 021H
	DD	@imagerel(omf_write_header_initial#+26)
	DD	@imagerel(omf_write_header_initial#+31)
	DD	@imagerel($chain$0$omf_write_header_initial#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$omf_write_header_initial DD @imagerel(omf_write_header_initial#+466)
	DD	@imagerel(omf_write_header_initial#+543)
	DD	@imagerel($chain$4$omf_write_header_initial#)
pdata	ENDS
xdata	SEGMENT
$chain$5$omf_write_header_initial DD 021H
	DD	@imagerel(omf_write_header_initial#)
	DD	@imagerel(omf_write_header_initial#+26)
	DD	@imagerel($unwind$omf_write_header_initial#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$omf_write_header_initial DD @imagerel(omf_write_header_initial#+543)
	DD	@imagerel(omf_write_header_initial#+550)
	DD	@imagerel($chain$5$omf_write_header_initial#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
obj$8025 = 32
obj$8005 = 32
obj$7990 = 32
obj$7970 = 32
modinfo$ = 96
omf_write_header_initial PROC NEAR

; 1618 : {

	sub	rsp, 88					; 00000058H

; 1619 :     uint_16 ext_idx;
; 1620 : 
; 1621 :     if ( write_to_file == FALSE )

	cmp	BYTE PTR write_to_file, 0

; 1622 :         return( NOT_ERROR );

	je	$LN43@omf_write_

; 1623 : 
; 1624 :     omf_write_theadr( CurrFName[ASM] ); /* write THEADR record, main src filename */

	mov	r9, QWORD PTR ModuleInfo+128
	xor	eax, eax
	mov	QWORD PTR [rsp+112], rsi
	mov	QWORD PTR [rsp+120], rdi
	mov	rdi, r9
	xor	esi, esi
	mov	DWORD PTR obj$7970[rsp+4], esi
	mov	rcx, -1
	mov	BYTE PTR obj$7970[rsp+16], 128		; 00000080H
	repne scasb
	mov	BYTE PTR obj$7970[rsp+17], sil
	not	rcx
	lea	rdx, QWORD PTR [rcx-1]
	mov	rcx, QWORD PTR ModuleInfo+488
	lea	eax, DWORD PTR [rdx+1]
	mov	QWORD PTR obj$7970[rsp+8], rcx
	mov	edi, edx
	mov	DWORD PTR obj$7970[rsp], eax
	mov	BYTE PTR [rcx], dil
	mov	eax, DWORD PTR obj$7970[rsp+4]
	inc	eax
	mov	r8d, edx
	mov	rdx, r9
	mov	ecx, eax
	mov	DWORD PTR obj$7970[rsp+4], eax
	add	rcx, QWORD PTR obj$7970[rsp+8]
	call	memcpy
	add	DWORD PTR obj$7970[rsp+4], edi
	lea	rcx, QWORD PTR obj$7970[rsp]
	call	omf_write_record

; 1625 :     /* v2.11: coment record "ms extensions present" now written here */
; 1626 :     if ( Options.debug_symbols ) /* -Zi option set? */

	cmp	BYTE PTR Options+2, sil
	je	SHORT $LN6@omf_write_

; 1627 :         omf_write_header_dbgcv();

	call	omf_write_header_dbgcv
$LN6@omf_write_:

; 1628 :     /* if( Options.no_dependencies == FALSE ) */
; 1629 :     if( Options.line_numbers )

	cmp	BYTE PTR Options+1, sil
	je	SHORT $LN5@omf_write_

; 1630 :         omf_write_autodep(); /* write dependency COMENT records ( known by Borland & OW ) */

	call	omf_write_autodep
$LN5@omf_write_:

; 1631 :     if( ModuleInfo.segorder == SEGORDER_DOSSEG )

	mov	eax, DWORD PTR ModuleInfo+380
	cmp	eax, 1
	jne	SHORT $LN4@omf_write_

; 1632 :         omf_write_dosseg(); /* write dosseg COMENT records */

	lea	rax, OFFSET FLAT:$SG6471
	lea	rcx, QWORD PTR obj$7990[rsp]
	mov	DWORD PTR obj$7990[rsp+4], esi
	mov	BYTE PTR obj$7990[rsp+16], 136		; 00000088H
	mov	BYTE PTR obj$7990[rsp+17], sil
	mov	BYTE PTR obj$7990[rsp+20], 128		; 00000080H
	mov	QWORD PTR obj$7990[rsp+8], rax
	mov	BYTE PTR obj$7990[rsp+21], 158		; 0000009eH
	mov	DWORD PTR obj$7990[rsp], esi
	call	omf_write_record
	jmp	SHORT $LN2@omf_write_
$LN4@omf_write_:

; 1633 :     else if( ModuleInfo.segorder == SEGORDER_ALPHA )

	cmp	eax, 2
	jne	SHORT $LN2@omf_write_

; 1634 :         SortSegments( 1 );

	lea	ecx, QWORD PTR [rax-1]
	call	SortSegments
$LN2@omf_write_:

; 1635 :     omf_write_lib(); /* write default lib COMENT records */

	mov	rdx, QWORD PTR ModuleInfo+64
	test	rdx, rdx
	je	SHORT $LN26@omf_write_
	mov	QWORD PTR [rsp+104], rbx
	npad	14
$LL28@omf_write_:
	mov	rbx, QWORD PTR [rdx]
	add	rdx, 8
	mov	DWORD PTR obj$8005[rsp], esi
	mov	QWORD PTR obj$8005[rsp+8], rsi
	mov	rdi, rdx
	xor	eax, eax
	mov	DWORD PTR obj$8005[rsp+4], esi
	mov	BYTE PTR obj$8005[rsp+16], 136		; 00000088H
	mov	BYTE PTR obj$8005[rsp+17], sil
	mov	BYTE PTR obj$8005[rsp+20], 128		; 00000080H
	mov	BYTE PTR obj$8005[rsp+21], 159		; 0000009fH
	mov	rcx, -1
	repne scasb
	mov	QWORD PTR obj$8005[rsp+8], rdx
	not	rcx
	dec	rcx
	mov	DWORD PTR obj$8005[rsp], ecx
	lea	rcx, QWORD PTR obj$8005[rsp]
	call	omf_write_record
	test	rbx, rbx
	mov	rdx, rbx
	jne	SHORT $LL28@omf_write_
	mov	rbx, QWORD PTR [rsp+104]
$LN26@omf_write_:

; 1636 :     omf_write_lnames(); /* write LNAMES records */

	call	omf_write_lnames

; 1637 : 
; 1638 :     /* write SEGDEF records. Since these records contain the segment's length,
; 1639 :      * the records have to be written again after the final assembly pass.
; 1640 :      * hence the start position of those records has to be saved.
; 1641 :      */
; 1642 :     seg_pos = ftell( CurrFile[OBJ] );

	mov	rcx, QWORD PTR ModuleInfo+104
	call	ftell
	mov	DWORD PTR seg_pos, eax

; 1643 :     omf_write_segdef();

	call	omf_write_segdef

; 1644 :     omf_write_grpdef(); /* write GRPDEF records */

	call	omf_write_grpdef

; 1645 :     ext_idx = omf_write_extdef(); /* write EXTDEF records */

	call	omf_write_extdef

; 1646 :     startext = omf_write_comdef( ext_idx ); /* write COMDEF records */

	movzx	ecx, ax
	call	omf_write_comdef
	movzx	edx, ax
	mov	DWORD PTR startext, edx

; 1647 :     omf_write_alias(); /* write ALIAS records */

	call	omf_write_alias

; 1648 : 
; 1649 :     /* write PUBDEF records. Since the final value of offsets isn't known after
; 1650 :      * the first pass, this has to be called again after the final pass.
; 1651 :      */
; 1652 :     public_pos = ftell( CurrFile[OBJ] );

	mov	rcx, QWORD PTR ModuleInfo+104
	call	ftell
	mov	DWORD PTR public_pos, eax

; 1653 :     omf_write_pubdef();

	call	omf_write_pubdef

; 1654 :     omf_write_export(); /* write export COMENT records */

	call	omf_write_export

; 1655 : 
; 1656 :     /* (optionally) write end-of-pass-one COMENT record
; 1657 :      * v2.10: don't write record if starting address is present.
; 1658 :      * the TIS OMF spec v1.1. warns that this
; 1659 :      * comment record is NOT to be present if
; 1660 :      * the MODEND record contains a starting address!
; 1661 :      */
; 1662 :     if ( !ModuleInfo.g.start_fixup )

	cmp	QWORD PTR ModuleInfo+208, rsi
	mov	rdi, QWORD PTR [rsp+120]
	jne	SHORT $LN35@omf_write_

; 1663 :         omf_end_of_pass1();

	lea	rax, OFFSET FLAT:$SG6463
	lea	rcx, QWORD PTR obj$8025[rsp]
	mov	DWORD PTR obj$8025[rsp+4], esi
	mov	BYTE PTR obj$8025[rsp+16], 136		; 00000088H
	mov	BYTE PTR obj$8025[rsp+17], sil
	mov	BYTE PTR obj$8025[rsp+20], sil
	mov	QWORD PTR obj$8025[rsp+8], rax
	mov	BYTE PTR obj$8025[rsp+21], 162		; 000000a2H
	mov	DWORD PTR obj$8025[rsp], 1
	call	omf_write_record
$LN35@omf_write_:

; 1664 :     end_of_header = ftell( CurrFile[OBJ] );

	mov	rcx, QWORD PTR ModuleInfo+104
	call	ftell
	mov	rsi, QWORD PTR [rsp+112]
	mov	DWORD PTR end_of_header, eax
$LN43@omf_write_:

; 1665 :     return( NOT_ERROR );

	xor	eax, eax

; 1666 : }

	add	rsp, 88					; 00000058H
	ret	0
omf_write_header_initial ENDP
_TEXT	ENDS
PUBLIC	omf_init
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
modinfo$ = 8
omf_init PROC NEAR

; 1673 :     DebugMsg(("omf_init enter\n"));
; 1674 :     modinfo->g.WriteModule = omf_write_module;

	lea	rax, OFFSET FLAT:omf_write_module

; 1675 :     modinfo->g.Pass1Checks = omf_write_header_initial;
; 1676 :     SymDebSeg[DBGS_SYMBOLS] = NULL;
; 1677 :     SymDebSeg[DBGS_TYPES] = NULL;
; 1678 : #if MULTIHDR
; 1679 :     ln_srcfile = modinfo->srcfile;
; 1680 : #endif
; 1681 :     ln_size = 0;

	mov	WORD PTR ln_size, 0
	mov	QWORD PTR [rcx+288], rax
	lea	rax, OFFSET FLAT:omf_write_header_initial
	mov	QWORD PTR [rcx+304], rax
	xor	eax, eax
	mov	QWORD PTR SymDebSeg, rax
	mov	QWORD PTR SymDebSeg+8, rax
	mov	eax, DWORD PTR [rcx+428]
	mov	DWORD PTR ln_srcfile, eax

; 1682 :     return;
; 1683 : }

	ret	0
omf_init ENDP
_TEXT	ENDS
END
