; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	directive_tab
PUBLIC	NameDirective
PUBLIC	IncludeLibDirective
PUBLIC	IncBinDirective
PUBLIC	EchoDirective
PUBLIC	AliasDirective
PUBLIC	RadixDirective
PUBLIC	SegOrderDirective
PUBLIC	StubDir
PUBLIC	IncludeDirective
EXTRN	ContextDirective:NEAR
EXTRN	OptionDirective:NEAR
EXTRN	EqualSgnDirective:NEAR
EXTRN	EquDirective:NEAR
EXTRN	LabelDirective:NEAR
EXTRN	AssumeDirective:NEAR
EXTRN	GrpDir:NEAR
EXTRN	EndsDir:NEAR
EXTRN	SegmentDir:NEAR
EXTRN	AlignDirective:NEAR
EXTRN	OrgDirective:NEAR
EXTRN	InvokeDirective:NEAR
EXTRN	LocalDir:NEAR
EXTRN	EndpDir:NEAR
EXTRN	ProcDir:NEAR
EXTRN	PublicDirective:NEAR
EXTRN	ProtoDirective:NEAR
EXTRN	ExterndefDirective:NEAR
EXTRN	ExternDirective:NEAR
EXTRN	CommDirective:NEAR
EXTRN	RecordDirective:NEAR
EXTRN	TypedefDirective:NEAR
EXTRN	StructDirective:NEAR
EXTRN	ExcFrameDirective:NEAR
EXTRN	SizeStrDir:NEAR
EXTRN	InStrDir:NEAR
EXTRN	SafeSEHDirective:NEAR
EXTRN	ModelDirective:NEAR
EXTRN	StartupExitDirective:NEAR
EXTRN	HllEndDir:NEAR
EXTRN	HllExitDir:NEAR
EXTRN	HllStartDir:NEAR
EXTRN	SimplifiedSegDir:NEAR
EXTRN	ListMacroDirective:NEAR
EXTRN	ListingDirective:NEAR
EXTRN	CpuDirective:NEAR
EXTRN	ErrorDirective:NEAR
EXTRN	EndDirective:NEAR
EXTRN	SubStrDir:NEAR
EXTRN	CatStrDir:NEAR
EXTRN	MacroDir:NEAR
EXTRN	PurgeDirective:NEAR
EXTRN	LoopDirective:NEAR
EXTRN	CondAsmDirective:NEAR
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
directive_tab DQ FLAT:CondAsmDirective
	DQ	FLAT:LoopDirective
	DQ	FLAT:PurgeDirective
	DQ	FLAT:IncludeDirective
	DQ	FLAT:MacroDir
	DQ	FLAT:CatStrDir
	DQ	FLAT:SubStrDir
	DQ	FLAT:StubDir
	DQ	FLAT:StubDir
	DQ	FLAT:EndDirective
	DQ	FLAT:ErrorDirective
	DQ	FLAT:CpuDirective
	DQ	FLAT:ListingDirective
	DQ	FLAT:ListMacroDirective
	DQ	FLAT:SegOrderDirective
	DQ	FLAT:SimplifiedSegDir
	DQ	FLAT:HllStartDir
	DQ	FLAT:HllExitDir
	DQ	FLAT:HllEndDir
	DQ	FLAT:StartupExitDirective
	DQ	FLAT:ModelDirective
	DQ	FLAT:RadixDirective
	DQ	FLAT:SafeSEHDirective
	DQ	FLAT:InStrDir
	DQ	FLAT:SizeStrDir
	DQ	FLAT:ExcFrameDirective
	DQ	FLAT:StructDirective
	DQ	FLAT:TypedefDirective
	DQ	FLAT:RecordDirective
	DQ	FLAT:CommDirective
	DQ	FLAT:ExternDirective
	DQ	FLAT:ExterndefDirective
	DQ	FLAT:ProtoDirective
	DQ	FLAT:PublicDirective
	DQ	FLAT:ProcDir
	DQ	FLAT:EndpDir
	DQ	FLAT:LocalDir
	DQ	FLAT:InvokeDirective
	DQ	FLAT:OrgDirective
	DQ	FLAT:AlignDirective
	DQ	FLAT:SegmentDir
	DQ	FLAT:EndsDir
	DQ	FLAT:GrpDir
	DQ	FLAT:AssumeDirective
	DQ	FLAT:LabelDirective
	DQ	FLAT:AliasDirective
	DQ	FLAT:EchoDirective
	DQ	FLAT:EquDirective
	DQ	FLAT:EqualSgnDirective
	DQ	FLAT:IncBinDirective
	DQ	FLAT:IncludeLibDirective
	DQ	FLAT:NameDirective
	DQ	FLAT:OptionDirective
	DQ	FLAT:ContextDirective
CONST	ENDS
_DATA	SEGMENT
$SG5874	DB	'%s', 0aH, 00H
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\directiv.c
_DATA	ENDS
_TEXT	SEGMENT
i$ = 8
tokenarray$ = 16
StubDir	PROC NEAR

; 48   : ret_code StubDir( int i, struct asm_tok tokenarray[] ){ return( ERROR ); }

	mov	eax, -1
	ret	0
StubDir	ENDP
_TEXT	ENDS
EXTRN	printf:NEAR
EXTRN	Options:BYTE
EXTRN	Parse_Pass:DWORD
xdata	SEGMENT
$unwind$EchoDirective DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$EchoDirective DD @imagerel($LN7#)
	DD	@imagerel($LN7#+56)
	DD	@imagerel($unwind$EchoDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
EchoDirective PROC NEAR

; 55   : {

$LN7:
	sub	rsp, 40					; 00000028H

; 56   :     if ( Parse_Pass == PASS_1 ) /* display in pass 1 only */

	cmp	DWORD PTR Parse_Pass, 0
	mov	rax, rdx
	jne	SHORT $LN6@EchoDirect

; 57   :         if ( Options.preprocessor_stdout == FALSE ) { /* don't print to stdout if -EP is on! */

	cmp	BYTE PTR Options+134, 0
	jne	SHORT $LN6@EchoDirect

; 58   :             printf( "%s\n", tokenarray[i+1].tokpos );

	movsxd	rdx, ecx
	lea	rcx, OFFSET FLAT:$SG5874
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rax+56]
	call	printf
$LN6@EchoDirect:

; 59   :         }
; 60   :     return( NOT_ERROR );

	xor	eax, eax

; 61   : }

	add	rsp, 40					; 00000028H
	ret	0
EchoDirective ENDP
_TEXT	ENDS
EXTRN	ProcessFile:NEAR
EXTRN	SearchFile:NEAR
EXTRN	isspace:NEAR
EXTRN	EmitErr:NEAR
EXTRN	EmitError:NEAR
EXTRN	LstWriteSrcLine:NEAR
EXTRN	ModuleInfo:BYTE
xdata	SEGMENT
$unwind$IncludeDirective DD 072901H
	DD	097429H
	DD	086416H
	DD	073411H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$IncludeDirective DD @imagerel($LN15#)
	DD	@imagerel($LN15#+250)
	DD	@imagerel($unwind$IncludeDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
IncludeDirective PROC NEAR

; 70   : {

$LN15:
	sub	rsp, 40					; 00000028H

; 71   :     char *name;
; 72   : 
; 73   :     DebugMsg1(("IncludeDirective enter\n"));
; 74   : 
; 75   :     if ( CurrFile[LST] ) {

	cmp	QWORD PTR ModuleInfo+112, 0
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, rdx
	mov	ebx, ecx
	je	SHORT $LN9@IncludeDir

; 76   :         LstWriteSrcLine();

	call	LstWriteSrcLine
$LN9@IncludeDir:

; 77   :     }
; 78   : 
; 79   :     i++; /* skip directive */

	inc	ebx
	mov	QWORD PTR [rsp+72], rdi

; 80   :     /* v2.03: allow plain numbers as file name argument */
; 81   :     //if ( tokenarray[i].token == T_FINAL || tokenarray[i].token == T_NUM ) {
; 82   :     if ( tokenarray[i].token == T_FINAL ) {

	movsxd	rdx, ebx
	mov	rdi, rdx
	shl	rdi, 5
	movzx	eax, BYTE PTR [rdi+rsi]
	test	al, al
	jne	SHORT $LN8@IncludeDir

; 83   :         return( EmitError( EXPECTED_FILE_NAME ) );

	mov	ecx, 112				; 00000070H
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 104  : }

	add	rsp, 40					; 00000028H
	jmp	EmitError
$LN8@IncludeDir:

; 84   :     }
; 85   : 
; 86   :     /* if the filename is enclosed in <>, just use this literal */
; 87   : 
; 88   :     if ( tokenarray[i].token == T_STRING && tokenarray[i].string_delim == '<' ) {

	cmp	al, 9
	jne	SHORT $LN7@IncludeDir
	cmp	BYTE PTR [rdi+rsi+1], 60		; 0000003cH
	jne	SHORT $LN7@IncludeDir

; 89   :         if ( tokenarray[i+1].token != T_FINAL ) {

	inc	rdx
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rsi], 0
	je	SHORT $LN6@IncludeDir

; 90   :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rsi+24]
	mov	ecx, 209				; 000000d1H
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 104  : }

	add	rsp, 40					; 00000028H
	jmp	EmitErr
$LN6@IncludeDir:

; 91   :         }
; 92   :         name = tokenarray[i].string_ptr;

	mov	rdi, QWORD PTR [rdi+rsi+8]

; 93   :     } else {

	jmp	SHORT $LN14@IncludeDir
$LN7@IncludeDir:

; 94   :         char *p;
; 95   :         /* if the filename isn't enclosed in <>, use anything that comes
; 96   :          * after INCLUDE - and remove trailing white spaces.
; 97   :          */
; 98   :         name = tokenarray[i].tokpos;
; 99   :         for ( p = tokenarray[Token_Count].tokpos - 1; p > name && isspace(*p); *p = NULLC, p-- );

	movsxd	rax, DWORD PTR ModuleInfo+496
	mov	rdi, QWORD PTR [rdi+rsi+24]
	shl	rax, 5
	mov	rbx, QWORD PTR [rax+rsi+24]
	dec	rbx
	cmp	rbx, rdi
	jbe	SHORT $LN14@IncludeDir
$LL4@IncludeDir:
	movsx	ecx, BYTE PTR [rbx]
	call	isspace
	test	eax, eax
	je	SHORT $LN14@IncludeDir
	mov	BYTE PTR [rbx], 0
	dec	rbx
	cmp	rbx, rdi
	ja	SHORT $LL4@IncludeDir
$LN14@IncludeDir:

; 100  :     }
; 101  :     if ( SearchFile( name, TRUE ) )

	mov	dl, 1
	mov	rcx, rdi
	call	SearchFile
	test	rax, rax
	je	SHORT $LN1@IncludeDir

; 102  :         ProcessFile( tokenarray );   /* v2.11: process the file synchronously */

	mov	rcx, rsi
	call	ProcessFile
$LN1@IncludeDir:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 103  :     return( NOT_ERROR );

	xor	eax, eax

; 104  : }

	add	rsp, 40					; 00000028H
	ret	0
IncludeDirective ENDP
_TEXT	ENDS
EXTRN	QEnqueue:NEAR
EXTRN	LclAlloc:NEAR
xdata	SEGMENT
$unwind$IncludeLibrary DD 051501H
	DD	097415H
	DD	083410H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$IncludeLibrary DD @imagerel(IncludeLibrary#)
	DD	@imagerel(IncludeLibrary#+180)
	DD	@imagerel($unwind$IncludeLibrary#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
IncludeLibrary PROC NEAR

; 108  : {

	sub	rsp, 40					; 00000028H

; 109  :     struct qitem *q;
; 110  : 
; 111  :     /* old approach, <= 1.91: add lib name to global namespace */
; 112  :     /* new approach, >= 1.92: check lib table, if entry is missing, add it */
; 113  :     /* Masm doesn't map cases for the paths. So if there is
; 114  :      * includelib <kernel32.lib>
; 115  :      * includelib <KERNEL32.LIB>
; 116  :      * then 2 defaultlib entries are added. If this is to be changed for
; 117  :      * HJWasm, activate the _stricmp() below.
; 118  :      */
; 119  :     for ( q = ModuleInfo.g.LibQueue.head; q ; q = q->next ) {

	mov	r8, QWORD PTR ModuleInfo+64
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	test	r8, r8
	mov	rbx, rcx
	je	SHORT $LN2@IncludeLib
	npad	3
$LL4@IncludeLib:

; 120  :         //if ( _stricmp( dir->sym.name, name) == 0)
; 121  :         if ( strcmp( q->value, name ) == 0 )

	lea	rax, QWORD PTR [r8+8]
	mov	rdi, rbx
	sub	rdi, rax
	npad	6
$LL12@IncludeLib:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+rdi]
	sub	edx, ecx
	jne	SHORT $LN13@IncludeLib
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL12@IncludeLib
$LN13@IncludeLib:
	test	edx, edx
	je	SHORT $LN10@IncludeLib
	mov	r8, QWORD PTR [r8]
	test	r8, r8
	jne	SHORT $LL4@IncludeLib
$LN2@IncludeLib:

; 123  :     }
; 124  :     q = LclAlloc( sizeof( struct qitem ) + strlen( name ) );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	add	rcx, 15
	call	LclAlloc

; 125  :     strcpy( q->value, name );

	lea	rdi, QWORD PTR [rax+8]
	mov	rdx, rdi
	sub	rdx, rbx
$LL7@IncludeLib:
	movzx	ecx, BYTE PTR [rbx]
	inc	rbx
	test	cl, cl
	mov	BYTE PTR [rdx+rbx-1], cl
	jne	SHORT $LL7@IncludeLib

; 126  :     QEnqueue( &ModuleInfo.g.LibQueue, q );

	lea	rcx, OFFSET FLAT:ModuleInfo+64
	mov	rdx, rax
	call	QEnqueue

; 127  :     return( q->value );

	mov	rax, rdi
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 128  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN10@IncludeLib:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 122  :             return( q->value );

	lea	rax, QWORD PTR [r8+8]

; 128  : }

	add	rsp, 40					; 00000028H
	ret	0
IncludeLibrary ENDP
_TEXT	ENDS
EXTRN	EmitWarn:NEAR
xdata	SEGMENT
$unwind$IncludeLibDirective DD 031001H
	DD	097410H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$IncludeLibDirective DD @imagerel($LN29#)
	DD	@imagerel($LN29#+33)
	DD	@imagerel($unwind$IncludeLibDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$2$IncludeLibDirective DD 040c21H
	DD	08640cH
	DD	073405H
	DD	@imagerel($LN29#)
	DD	@imagerel($LN29#+33)
	DD	@imagerel($unwind$IncludeLibDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$IncludeLibDirective DD @imagerel($LN29#+33)
	DD	@imagerel($LN29#+136)
	DD	@imagerel($chain$2$IncludeLibDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$4$IncludeLibDirective DD 040021H
	DD	086400H
	DD	073400H
	DD	@imagerel($LN29#)
	DD	@imagerel($LN29#+33)
	DD	@imagerel($unwind$IncludeLibDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$IncludeLibDirective DD @imagerel($LN29#+136)
	DD	@imagerel($LN29#+339)
	DD	@imagerel($chain$4$IncludeLibDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
IncludeLibDirective PROC NEAR

; 150  : {

$LN29:
	sub	rsp, 40					; 00000028H

; 151  :     char *name;
; 152  :     //struct asym *sym;
; 153  : 
; 154  :     if ( Parse_Pass != PASS_1 ) /* do all work in pass 1 */

	cmp	DWORD PTR Parse_Pass, 0
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rdx
	je	SHORT $LN8@IncludeLib@2

; 155  :         return( NOT_ERROR );

	xor	eax, eax
	mov	rdi, QWORD PTR [rsp+72]

; 184  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@IncludeLib@2:
	mov	QWORD PTR [rsp+56], rbx

; 156  :     i++; /* skip the directive */

	inc	ecx
	mov	QWORD PTR [rsp+64], rsi

; 157  :     /* v2.03: library name may be just a "number" */
; 158  :     //if ( tokenarray[i].token == T_FINAL || tokenarray[i].token == T_NUM ) {
; 159  :     if ( tokenarray[i].token == T_FINAL ) {

	movsxd	rsi, ecx
	mov	rbx, rsi
	shl	rbx, 5
	cmp	BYTE PTR [rbx+rdx], 0
	jne	SHORT $LN7@IncludeLib@2

; 160  :         /* v2.05: Masm doesn't complain if there's no name, so emit a warning only! */
; 161  :         //EmitError( LIBRARY_NAME_MISSING );
; 162  :         //return( ERROR );
; 163  :         EmitWarn( 2, LIBRARY_NAME_MISSING );

	mov	edx, 88					; 00000058H
	lea	ecx, QWORD PTR [rdx-86]
	call	EmitWarn
$LN7@IncludeLib@2:

; 164  :     }
; 165  : 
; 166  :     if ( tokenarray[i].token == T_STRING && tokenarray[i].string_delim == '<' ) {

	cmp	BYTE PTR [rbx+rdi], 9
	jne	SHORT $LN6@IncludeLib@2
	cmp	BYTE PTR [rbx+rdi+1], 60		; 0000003cH
	jne	SHORT $LN6@IncludeLib@2

; 167  :         if ( tokenarray[i+1].token != T_FINAL ) {

	lea	rdx, QWORD PTR [rsi+1]
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rdi], 0
	je	SHORT $LN5@IncludeLib@2

; 168  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rdi+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]

; 184  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN5@IncludeLib@2:

; 169  :         }
; 170  :         /* v2.08: use GetLiteralValue() */
; 171  :         //name = StringBufferEnd;
; 172  :         //GetLiteralValue( name, tokenarray[i].string_ptr );
; 173  :         name = tokenarray[i].string_ptr;

	mov	rbx, QWORD PTR [rbx+rdi+8]

; 174  :     } else {

	jmp	SHORT $LN26@IncludeLib@2
$LN6@IncludeLib@2:

; 175  :         char *p;
; 176  :         /* regard "everything" behind INCLUDELIB as the library name */
; 177  :         name = tokenarray[i].tokpos;

	mov	rbx, QWORD PTR [rbx+rdi+24]

; 178  :         /* remove trailing white spaces */
; 179  :         for ( p = tokenarray[Token_Count].tokpos - 1; p > name && isspace( *p ); *p = NULLC, p-- );

	movsxd	rax, DWORD PTR ModuleInfo+496
	shl	rax, 5
	mov	rdi, QWORD PTR [rax+rdi+24]
	dec	rdi
	cmp	rdi, rbx
	jbe	SHORT $LN26@IncludeLib@2
	npad	4
$LL3@IncludeLib@2:
	movsx	ecx, BYTE PTR [rdi]
	call	isspace
	test	eax, eax
	je	SHORT $LN26@IncludeLib@2
	mov	BYTE PTR [rdi], 0
	dec	rdi
	cmp	rdi, rbx
	ja	SHORT $LL3@IncludeLib@2
$LN26@IncludeLib@2:

; 180  :     }
; 181  : 
; 182  :     IncludeLibrary( name );

	mov	r8, QWORD PTR ModuleInfo+64
	test	r8, r8
	je	SHORT $LN12@IncludeLib@2
$LL14@IncludeLib@2:
	lea	rax, QWORD PTR [r8+8]
	mov	rdi, rbx
	sub	rdi, rax
	npad	3
$LL24@IncludeLib@2:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+rdi]
	sub	edx, ecx
	jne	SHORT $LN25@IncludeLib@2
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL24@IncludeLib@2
$LN25@IncludeLib@2:
	test	edx, edx
	je	SHORT $LN15@IncludeLib@2
	mov	r8, QWORD PTR [r8]
	test	r8, r8
	jne	SHORT $LL14@IncludeLib@2
$LN12@IncludeLib@2:
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	add	rcx, 15
	call	LclAlloc
	lea	rdx, QWORD PTR [rax+8]
	sub	rdx, rbx
	npad	1
$LL17@IncludeLib@2:
	movzx	ecx, BYTE PTR [rbx]
	inc	rbx
	test	cl, cl
	mov	BYTE PTR [rdx+rbx-1], cl
	jne	SHORT $LL17@IncludeLib@2
	lea	rcx, OFFSET FLAT:ModuleInfo+64
	mov	rdx, rax
	call	QEnqueue
$LN15@IncludeLib@2:
	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]

; 183  :     return( NOT_ERROR );

	xor	eax, eax

; 184  : }

	add	rsp, 40					; 00000028H
	ret	0
IncludeLibDirective ENDP
_TEXT	ENDS
EXTRN	fclose:NEAR
EXTRN	free:NEAR
EXTRN	OutputBinBytes:NEAR
EXTRN	fread:NEAR
EXTRN	malloc:NEAR
EXTRN	ftell:NEAR
EXTRN	fseek:NEAR
EXTRN	omf_OutSelect:NEAR
EXTRN	EvalOperand:NEAR
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$IncBinDirective DD 061701H
	DD	0157417H
	DD	01a3410H
	DD	017010aH
xdata	ENDS
pdata	SEGMENT
$pdata$IncBinDirective DD @imagerel($LN29#)
	DD	@imagerel($LN29#+445)
	DD	@imagerel($unwind$IncBinDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$2$IncBinDirective DD 020821H
	DD	01b5408H
	DD	@imagerel($LN29#)
	DD	@imagerel($LN29#+445)
	DD	@imagerel($unwind$IncBinDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$IncBinDirective DD @imagerel($LN29#+445)
	DD	@imagerel($LN29#+471)
	DD	@imagerel($chain$2$IncBinDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$3$IncBinDirective DD 020821H
	DD	0166408H
	DD	@imagerel($LN29#+445)
	DD	@imagerel($LN29#+471)
	DD	@imagerel($chain$2$IncBinDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$IncBinDirective DD @imagerel($LN29#+471)
	DD	@imagerel($LN29#+581)
	DD	@imagerel($chain$3$IncBinDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$4$IncBinDirective DD 021H
	DD	@imagerel($LN29#+445)
	DD	@imagerel($LN29#+471)
	DD	@imagerel($chain$2$IncBinDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$IncBinDirective DD @imagerel($LN29#+581)
	DD	@imagerel($LN29#+593)
	DD	@imagerel($chain$4$IncBinDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$5$IncBinDirective DD 021H
	DD	@imagerel($LN29#)
	DD	@imagerel($LN29#+445)
	DD	@imagerel($unwind$IncBinDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$IncBinDirective DD @imagerel($LN29#+593)
	DD	@imagerel($LN29#+627)
	DD	@imagerel($chain$5$IncBinDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
opndx$ = 48
i$ = 192
tokenarray$ = 200
IncBinDirective PROC NEAR

; 192  : {

$LN29:
	mov	rax, rsp
	sub	rsp, 184				; 000000b8H

; 193  :     FILE *file;
; 194  :     //int size;
; 195  :     uint_32 fileoffset = 0; /* fixme: should be uint_64 */
; 196  :     uint_32 sizemax = -1;
; 197  :     struct expr opndx;
; 198  : 	long sz;
; 199  : 	unsigned char* pBinData;
; 200  : 	size_t result = 0;
; 201  : 
; 202  :     DebugMsg(("IncBinDirective enter\n"));
; 203  : 
; 204  :     i++; /* skip the directive */

	inc	ecx
	mov	QWORD PTR [rax+24], rbx
	mov	rbx, rdx
	mov	QWORD PTR [rax-16], rdi

; 205  :     /* v2.03: file name may be just a "number" */
; 206  :     //if ( tokenarray[i].token == T_FINAL || tokenarray[i].token == T_NUM ) {
; 207  :     if ( tokenarray[i].token == T_FINAL ) {

	movsxd	rdx, ecx
	mov	DWORD PTR [rax+8], ecx
	shl	rdx, 5
	xor	edi, edi
	movzx	eax, BYTE PTR [rdx+rbx]
	test	al, al
	jne	SHORT $LN22@IncBinDire

; 208  :         return( EmitError( EXPECTED_FILE_NAME ) );

	lea	ecx, QWORD PTR [rdi+112]
	jmp	$LN28@IncBinDire
$LN22@IncBinDire:

; 209  :     }
; 210  : 
; 211  :     if ( tokenarray[i].token == T_STRING ) {

	cmp	al, 9
	jne	$LN21@IncBinDire

; 212  : 
; 213  :         /* v2.08: use string buffer to avoid buffer overflow if string is > FILENAME_MAX */
; 214  :         if ( tokenarray[i].string_delim == '"' || tokenarray[i].string_delim == '\'' ) {

	movzx	eax, BYTE PTR [rdx+rbx+1]
	cmp	al, 34					; 00000022H
	je	SHORT $LN19@IncBinDire
	cmp	al, 39					; 00000027H
	je	SHORT $LN19@IncBinDire

; 217  :         } else if ( tokenarray[i].string_delim == '<' ) {

	cmp	al, 60					; 0000003cH
	jne	$LN21@IncBinDire

; 218  :             /* v2.08: use GetLiteralValue() instead of strncpy() */
; 219  :             //GetLiteralValue( StringBufferEnd, tokenarray[i].string_ptr );
; 220  :             memcpy( StringBufferEnd, tokenarray[i].string_ptr, tokenarray[i].stringlen+1 );

	mov	r8d, DWORD PTR [rdx+rbx+16]
	mov	rcx, QWORD PTR ModuleInfo+488
	mov	rdx, QWORD PTR [rdx+rbx+8]
	inc	r8d
	call	memcpy

; 221  :         } else {

	jmp	SHORT $LN16@IncBinDire
$LN19@IncBinDire:

; 215  :             memcpy( StringBufferEnd, tokenarray[i].string_ptr+1, tokenarray[i].stringlen );

	mov	r8d, DWORD PTR [rdx+rbx+16]
	mov	rdx, QWORD PTR [rdx+rbx+8]
	mov	rcx, QWORD PTR ModuleInfo+488
	inc	rdx
	call	memcpy

; 216  :             StringBufferEnd[tokenarray[i].stringlen] = NULLC;

	movsxd	r11, DWORD PTR i$[rsp]
	mov	rax, QWORD PTR ModuleInfo+488
	shl	r11, 5
	mov	ecx, DWORD PTR [r11+rbx+16]
	mov	BYTE PTR [rcx+rax], dil
$LN16@IncBinDire:

; 226  :     }
; 227  :     i++;

	mov	ecx, DWORD PTR i$[rsp]
	inc	ecx

; 228  :     if ( tokenarray[i].token == T_COMMA ) {

	movsxd	rax, ecx
	mov	DWORD PTR i$[rsp], ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+rbx], 44			; 0000002cH
	jne	$LN5@IncBinDire

; 229  :         i++;
; 230  :         if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	inc	ecx
	lea	r9, QWORD PTR opndx$[rsp]
	mov	DWORD PTR i$[rsp], ecx
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rbx
	mov	BYTE PTR [rsp+32], dil
	call	EvalOperand
	cmp	eax, -1

; 231  :             return( ERROR );

	je	SHORT $LN27@IncBinDire

; 232  :         if ( opndx.kind == EXPR_CONST ) {

	mov	eax, DWORD PTR opndx$[rsp+60]
	test	eax, eax
	jne	SHORT $LN12@IncBinDire

; 233  :             fileoffset = opndx.value;

	mov	edi, DWORD PTR opndx$[rsp]
	jmp	SHORT $LN10@IncBinDire
$LN12@IncBinDire:

; 234  :         } else if ( opndx.kind != EXPR_EMPTY ) {

	cmp	eax, -2

; 235  :             return( EmitError( CONSTANT_EXPECTED ) );

	jne	SHORT $LN26@IncBinDire
$LN10@IncBinDire:

; 236  :         }
; 237  :         if ( tokenarray[i].token == T_COMMA ) {

	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+rbx], 44			; 0000002cH
	jne	SHORT $LN5@IncBinDire

; 238  :             i++;
; 239  :             if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	inc	ecx
	lea	r9, QWORD PTR opndx$[rsp]
	mov	DWORD PTR i$[rsp], ecx
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rbx
	mov	BYTE PTR [rsp+32], 0
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN8@IncBinDire
$LN27@IncBinDire:

; 240  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN23@IncBinDire
$LN8@IncBinDire:

; 241  :             if ( opndx.kind == EXPR_CONST ) {

	mov	eax, DWORD PTR opndx$[rsp+60]
	test	eax, eax

; 242  :                 sizemax = opndx.value;

	je	SHORT $LN25@IncBinDire

; 243  :             } else if ( opndx.kind != EXPR_EMPTY ) {

	cmp	eax, -2
	je	SHORT $LN25@IncBinDire
$LN26@IncBinDire:

; 244  :                 return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	jmp	$LN28@IncBinDire
$LN25@IncBinDire:
	mov	ecx, DWORD PTR i$[rsp]
$LN5@IncBinDire:

; 245  :             }
; 246  :         }
; 247  :     }
; 248  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, ecx
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbx], 0
	je	SHORT $LN4@IncBinDire

; 249  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rbx+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN23@IncBinDire
$LN4@IncBinDire:

; 250  :     }
; 251  : 
; 252  :     if( CurrSeg == NULL ) {

	cmp	QWORD PTR ModuleInfo+432, 0
	jne	SHORT $LN3@IncBinDire

; 253  :         return( EmitError( MUST_BE_IN_SEGMENT_BLOCK ) );

	mov	ecx, 82					; 00000052H
	jmp	$LN28@IncBinDire
$LN3@IncBinDire:

; 254  :     }
; 255  : 
; 256  :     /* v2.04: tell assembler that data is emitted */
; 257  :     if ( ModuleInfo.CommentDataInCode )

	cmp	BYTE PTR ModuleInfo+423, 0
	je	SHORT $LN2@IncBinDire

; 258  :         omf_OutSelect( TRUE );

	mov	cl, 1
	call	omf_OutSelect
$LN2@IncBinDire:

; 259  : 
; 260  :     DebugMsg1(("IncBinDirective: filename=%s, offset=%" I32_SPEC "u, size=%" I32_SPEC "u\n", StringBufferEnd, fileoffset, sizemax ));
; 261  : 
; 262  :     /* try to open the file */
; 263  :     if ( file = SearchFile( StringBufferEnd, FALSE ) ) 

	mov	rcx, QWORD PTR ModuleInfo+488
	xor	edx, edx
	mov	QWORD PTR [rsp+216], rbp
	call	SearchFile
	test	rax, rax
	mov	rbp, rax
	je	SHORT $LN1@IncBinDire

; 264  : 	{
; 265  : 		/* v2.14 : Get File Size */
; 266  : 		fseek( file, 0L, SEEK_END );

	xor	edx, edx
	mov	rcx, rax
	mov	QWORD PTR [rsp+176], rsi
	lea	r8d, QWORD PTR [rdx+2]
	call	fseek

; 267  : 		sz = ftell( file ) - fileoffset; // sz = total data size to load into segment/section.

	mov	rcx, rbp
	call	ftell

; 268  : 		fseek( file, 0L, SEEK_SET );

	xor	r8d, r8d
	xor	edx, edx
	mov	esi, eax
	mov	rcx, rbp
	sub	esi, edi
	call	fseek

; 269  : 		pBinData = (unsigned char*)malloc(sz);

	movsxd	rbx, esi
	mov	rcx, rbx
	call	malloc

; 270  : 		result = fread(pBinData, sz, 1, file);

	mov	r9, rbp
	mov	r8d, 1
	mov	rcx, rax
	mov	rdx, rbx
	mov	rdi, rax
	call	fread

; 271  : 		OutputBinBytes(pBinData, sz);

	mov	edx, esi
	mov	rcx, rdi
	call	OutputBinBytes

; 272  : 
; 273  :         /* transfer file content to the current segment. */
; 274  :         //if ( fileoffset )
; 275  :             //fseek( file, fileoffset, SEEK_SET );  /* fixme: use fseek64() */
; 276  :         //for( ; sizemax; sizemax-- ) {
; 277  :             //int ch = fgetc( file );
; 278  :             //if ( ( ch == EOF ) && feof( file ) )
; 279  :                 //break;
; 280  :             //OutputByte( ch );
; 281  :         //}
; 282  : 		free((void*)pBinData);

	mov	rcx, rdi
	call	free

; 283  :         fclose( file );

	mov	rcx, rbp
	call	fclose
	mov	rsi, QWORD PTR [rsp+176]
$LN1@IncBinDire:
	mov	rbp, QWORD PTR [rsp+216]

; 284  :     }
; 285  : 
; 286  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN23@IncBinDire
$LN21@IncBinDire:

; 222  :             return( EmitError( FILENAME_MUST_BE_ENCLOSED_IN_QUOTES_OR_BRACKETS ) );
; 223  :         }
; 224  :     } else {
; 225  :         return( EmitError( FILENAME_MUST_BE_ENCLOSED_IN_QUOTES_OR_BRACKETS ) );

	mov	ecx, 241				; 000000f1H
$LN28@IncBinDire:
	call	EmitError
$LN23@IncBinDire:
	mov	rdi, QWORD PTR [rsp+168]
	mov	rbx, QWORD PTR [rsp+208]

; 287  : }

	add	rsp, 184				; 000000b8H
	ret	0
IncBinDirective ENDP
_TEXT	ENDS
EXTRN	sym_remove_table:NEAR
EXTRN	sym_add_table:NEAR
EXTRN	SymTables:BYTE
EXTRN	SymCreate:NEAR
EXTRN	SymFind:NEAR
xdata	SEGMENT
$unwind$AliasDirective DD 051001H
	DD	075410H
	DD	06340bH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$AliasDirective DD @imagerel($LN31#)
	DD	@imagerel($LN31#+112)
	DD	@imagerel($unwind$AliasDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$2$AliasDirective DD 020521H
	DD	04c405H
	DD	@imagerel($LN31#)
	DD	@imagerel($LN31#+112)
	DD	@imagerel($unwind$AliasDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$AliasDirective DD @imagerel($LN31#+112)
	DD	@imagerel($LN31#+167)
	DD	@imagerel($chain$2$AliasDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$5$AliasDirective DD 040a21H
	DD	09740aH
	DD	04c400H
	DD	@imagerel($LN31#)
	DD	@imagerel($LN31#+112)
	DD	@imagerel($unwind$AliasDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$AliasDirective DD @imagerel($LN31#+167)
	DD	@imagerel($LN31#+353)
	DD	@imagerel($chain$5$AliasDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$6$AliasDirective DD 020521H
	DD	086405H
	DD	@imagerel($LN31#+167)
	DD	@imagerel($LN31#+353)
	DD	@imagerel($chain$5$AliasDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$AliasDirective DD @imagerel($LN31#+353)
	DD	@imagerel($LN31#+459)
	DD	@imagerel($chain$6$AliasDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$7$AliasDirective DD 021H
	DD	@imagerel($LN31#+167)
	DD	@imagerel($LN31#+353)
	DD	@imagerel($chain$5$AliasDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$AliasDirective DD @imagerel($LN31#+459)
	DD	@imagerel($LN31#+484)
	DD	@imagerel($chain$7$AliasDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$9$AliasDirective DD 060021H
	DD	04c400H
	DD	097400H
	DD	086400H
	DD	@imagerel($LN31#)
	DD	@imagerel($LN31#+112)
	DD	@imagerel($unwind$AliasDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$AliasDirective DD @imagerel($LN31#+484)
	DD	@imagerel($LN31#+535)
	DD	@imagerel($chain$9$AliasDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$10$AliasDirective DD 021H
	DD	@imagerel($LN31#)
	DD	@imagerel($LN31#+112)
	DD	@imagerel($unwind$AliasDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$10$AliasDirective DD @imagerel($LN31#+535)
	DD	@imagerel($LN31#+588)
	DD	@imagerel($chain$10$AliasDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
AliasDirective PROC NEAR

; 306  : {

$LN31:
	sub	rsp, 40					; 00000028H

; 307  :     //char *tmp;
; 308  :     struct asym *sym;
; 309  :     char *subst;
; 310  : 
; 311  :     i++; /* go past ALIAS */

	inc	ecx
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp

; 312  : 
; 313  :     if ( tokenarray[i].token != T_STRING ||
; 314  :         tokenarray[i].string_delim != '<' ) {

	movsxd	r8, ecx
	mov	rbx, rdx
	mov	rbp, r8
	shl	rbp, 5
	cmp	BYTE PTR [rdx+rbp], 9
	jne	$LN22@AliasDirec
	cmp	BYTE PTR [rdx+rbp+1], 60		; 0000003cH
	jne	$LN22@AliasDirec

; 317  :     }
; 318  : 
; 319  :     /* check syntax. note that '=' is T_DIRECTIVE && DRT_EQUALSGN */
; 320  :     if ( tokenarray[i+1].token != T_DIRECTIVE ||
; 321  :         //tokenarray[i+1].tokval != T_EQU ||
; 322  :         tokenarray[i+1].dirtype != DRT_EQUALSGN ) {

	lea	rdx, QWORD PTR [r8+1]
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbx], 3
	jne	$LN20@AliasDirec
	cmp	BYTE PTR [rdx+rbx+1], 48		; 00000030H
	jne	$LN20@AliasDirec

; 325  :     }
; 326  : 
; 327  :     if ( tokenarray[i+2].token != T_STRING ||
; 328  :         tokenarray[i+2].string_delim != '<' )  {

	lea	rax, QWORD PTR [r8+2]
	shl	rax, 5
	cmp	BYTE PTR [rax+rbx], 9
	jne	$LN22@AliasDirec
	cmp	BYTE PTR [rax+rbx+1], 60		; 0000003cH
	jne	$LN22@AliasDirec

; 329  :         DebugMsg(("AliasDirective: second argument is not a literal: %s\n", tokenarray[i+2].string_ptr ));
; 330  :         return( EmitError( TEXT_ITEM_REQUIRED ) );
; 331  :     }
; 332  :     subst = tokenarray[i+2].string_ptr;
; 333  : 
; 334  :     if ( tokenarray[i+3].token != T_FINAL ) {

	lea	rdx, QWORD PTR [r8+3]
	mov	QWORD PTR [rsp+32], r12
	mov	r12, QWORD PTR [rax+rbx+8]
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbx], 0
	je	SHORT $LN17@AliasDirec

; 335  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+3].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+rbx+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	mov	r12, QWORD PTR [rsp+32]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 388  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN17@AliasDirec:

; 336  :     }
; 337  : 
; 338  :     /* make sure <alias_name> isn't defined elsewhere */
; 339  :     sym = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rbx+rbp+8]
	mov	QWORD PTR [rsp+72], rdi
	call	SymFind

; 340  :     if ( sym == NULL || sym->state == SYM_UNDEFINED ) {

	test	rax, rax
	mov	rdi, rax
	je	$LN15@AliasDirec
	mov	eax, DWORD PTR [rax+40]
	test	eax, eax
	je	$LN15@AliasDirec

; 364  :     }
; 365  :     if ( sym->state != SYM_ALIAS || ( strcmp( sym->substitute->name, subst ) != 0 )) {

	cmp	eax, 8
	jne	SHORT $LN8@AliasDirec
	mov	r9, QWORD PTR [rdi+16]
	mov	r8, r12
	mov	rcx, QWORD PTR [r9+8]
	sub	r8, rcx
$LL26@AliasDirec:
	movzx	edx, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rcx+r8]
	sub	edx, eax
	jne	SHORT $LN27@AliasDirec
	inc	rcx
	test	eax, eax
	jne	SHORT $LL26@AliasDirec
$LN27@AliasDirec:
	test	edx, edx
	jne	SHORT $LN8@AliasDirec

; 368  :     }
; 369  : #if COFF_SUPPORT || ELF_SUPPORT
; 370  :     /* for COFF+ELF, make sure <actual_name> is "global" (EXTERNAL or
; 371  :      * public INTERNAL). For OMF, there's no check at all. */
; 372  :     if ( Parse_Pass != PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, edx
	je	SHORT $LN2@AliasDirec

; 373  :         if ( Options.output_format == OFORMAT_COFF
; 374  : #if ELF_SUPPORT
; 375  :              || Options.output_format == OFORMAT_ELF
; 376  : #endif
; 377  :            ) {

	mov	eax, DWORD PTR Options+156
	cmp	eax, 2
	je	SHORT $LN5@AliasDirec
	cmp	eax, 3
	jne	SHORT $LN2@AliasDirec
$LN5@AliasDirec:

; 378  :             if ( sym->substitute->state == SYM_UNDEFINED ) {

	mov	eax, DWORD PTR [r9+40]
	test	eax, eax
	jne	SHORT $LN4@AliasDirec

; 379  :                 return( EmitErr( SYMBOL_NOT_DEFINED, subst ) );

	lea	ecx, QWORD PTR [rax+102]
	mov	rdx, r12
	call	EmitErr
	jmp	$LN29@AliasDirec
$LN4@AliasDirec:

; 380  :             } else if ( sym->substitute->state != SYM_EXTERNAL &&
; 381  :                        ( sym->substitute->state != SYM_INTERNAL || sym->substitute->ispublic == FALSE ) ) {

	cmp	eax, 2
	je	SHORT $LN2@AliasDirec
	cmp	eax, 1
	jne	SHORT $LN1@AliasDirec
	test	BYTE PTR [r9+48], 128			; 00000080H
	jne	SHORT $LN2@AliasDirec
$LN1@AliasDirec:

; 382  :                 return( EmitErr( MUST_BE_PUBLIC_OR_EXTERNAL, subst ) );

	mov	rdx, r12
	mov	ecx, 269				; 0000010dH
	call	EmitErr
	jmp	$LN29@AliasDirec
$LN2@AliasDirec:

; 383  :             }
; 384  :         }
; 385  :     }
; 386  : #endif
; 387  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN29@AliasDirec
$LN8@AliasDirec:

; 366  :         DebugMsg(("AliasDirective: symbol redefinition\n"));
; 367  :         return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rdi+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	SHORT $LN29@AliasDirec
$LN15@AliasDirec:

; 341  :         struct asym *sym2;
; 342  :         /* v2.04b: adjusted to new field <substitute> */
; 343  :         sym2 = SymSearch( subst );

	mov	rcx, r12
	mov	QWORD PTR [rsp+64], rsi
	call	SymFind

; 344  :         if ( sym2 == NULL ) {

	test	rax, rax
	mov	rsi, rax
	jne	SHORT $LN14@AliasDirec

; 345  :             sym2 = SymCreate( subst );

	mov	rcx, r12
	call	SymCreate

; 346  :             sym2->state = SYM_UNDEFINED;
; 347  :             sym_add_table( &SymTables[TAB_UNDEF], (struct dsym *)sym2 );

	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rax
	mov	rsi, rax
	mov	DWORD PTR [rax+40], 0
	call	sym_add_table
$LN12@AliasDirec:

; 352  :         }
; 353  :         if ( sym == NULL )

	test	rdi, rdi
	jne	SHORT $LN11@AliasDirec

; 354  :             sym = SymCreate( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rbx+rbp+8]
	call	SymCreate
	mov	rdi, rax

; 355  :         else

	jmp	SHORT $LN10@AliasDirec
$LN14@AliasDirec:

; 348  :         } else if ( sym2->state != SYM_UNDEFINED &&
; 349  :                    sym2->state != SYM_INTERNAL &&
; 350  :                    sym2->state != SYM_EXTERNAL ) {

	mov	eax, DWORD PTR [rax+40]
	test	eax, eax
	je	SHORT $LN12@AliasDirec
	cmp	eax, 1
	je	SHORT $LN12@AliasDirec
	cmp	eax, 2
	je	SHORT $LN12@AliasDirec

; 351  :             return( EmitErr( MUST_BE_PUBLIC_OR_EXTERNAL, subst ) );

	mov	rdx, r12
	mov	ecx, 269				; 0000010dH
	call	EmitErr
$LN30@AliasDirec:
	mov	rsi, QWORD PTR [rsp+64]
$LN29@AliasDirec:
	mov	rdi, QWORD PTR [rsp+72]
	mov	r12, QWORD PTR [rsp+32]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 388  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN11@AliasDirec:

; 356  :             sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rdi
	call	sym_remove_table
$LN10@AliasDirec:

; 357  : 
; 358  :         sym->state = SYM_ALIAS;

	mov	DWORD PTR [rdi+40], 8

; 359  :         sym->substitute = sym2;

	mov	QWORD PTR [rdi+16], rsi

; 360  :         /* v2.10: copy language type of alias */
; 361  :         sym->langtype = sym2->langtype;

	mov	eax, DWORD PTR [rsi+84]

; 362  :         sym_add_table( &SymTables[TAB_ALIAS], (struct dsym *)sym ); /* add ALIAS */

	lea	rcx, OFFSET FLAT:SymTables+80
	mov	rdx, rdi
	mov	DWORD PTR [rdi+84], eax
	call	sym_add_table

; 363  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN30@AliasDirec
$LN20@AliasDirec:

; 323  :         DebugMsg(("AliasDirective: syntax error: %s\n", tokenarray[i+1].string_ptr ));
; 324  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+rbx+8]
	mov	ecx, 209				; 000000d1H
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 388  : }

	add	rsp, 40					; 00000028H
	jmp	EmitErr
$LN22@AliasDirec:

; 315  :         DebugMsg(("AliasDirective: first argument is not a literal: %s\n", tokenarray[i].string_ptr ));
; 316  :         return( EmitError( TEXT_ITEM_REQUIRED ) );

	mov	ecx, 144				; 00000090H
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 388  : }

	add	rsp, 40					; 00000028H
	jmp	EmitError
AliasDirective ENDP
_TEXT	ENDS
EXTRN	CurrStruct:QWORD
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
i$ = 8
tokenarray$ = 16
NameDirective PROC NEAR

; 395  :     if( Parse_Pass != PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	mov	r8, rdx

; 396  :         return( NOT_ERROR );

	jne	SHORT $LN7@NameDirect

; 397  :     /* if a module name is set with -nm, ignore NAME directive! */
; 398  :     /* v2.08: removed, since Options.names isn't touched at all */
; 399  :     //if( Options.names[OPTN_MODULE_NAME] != NULL )
; 400  :     //    return( NOT_ERROR );
; 401  : 
; 402  :     i++; /* skip directive */

	inc	ecx

; 403  : 
; 404  :     /* improper use of NAME is difficult to see since it is a nop
; 405  :      therefore some syntax checks are implemented:
; 406  :      - no 'name' structs, unions, records, typedefs!
; 407  :      - no 'name' struct fields!
; 408  :      - no 'name' segments!
; 409  :      - no 'name:' label!
; 410  :      */
; 411  :     if ( CurrStruct != NULL ||
; 412  :         ( tokenarray[i].token == T_DIRECTIVE &&
; 413  :          ( tokenarray[i].tokval == T_SEGMENT ||
; 414  :           tokenarray[i].tokval == T_STRUCT  ||
; 415  :           tokenarray[i].tokval == T_STRUC   ||
; 416  :           tokenarray[i].tokval == T_UNION   ||
; 417  :           tokenarray[i].tokval == T_TYPEDEF ||
; 418  :           tokenarray[i].tokval == T_RECORD)) ||
; 419  :          tokenarray[i].token == T_COLON ) {

	cmp	QWORD PTR CurrStruct, 0
	jne	SHORT $LN2@NameDirect
	movsxd	rax, ecx
	shl	rax, 5
	movzx	edx, BYTE PTR [rax+rdx]
	cmp	dl, 3
	jne	SHORT $LN1@NameDirect
	mov	eax, DWORD PTR [rax+r8+16]
	cmp	eax, 441				; 000001b9H
	je	SHORT $LN2@NameDirect
	cmp	eax, 423				; 000001a7H
	je	SHORT $LN2@NameDirect
	cmp	eax, 422				; 000001a6H
	je	SHORT $LN2@NameDirect
	cmp	eax, 424				; 000001a8H
	je	SHORT $LN2@NameDirect
	cmp	eax, 425				; 000001a9H
	je	SHORT $LN2@NameDirect
	cmp	eax, 426				; 000001aaH
	je	SHORT $LN2@NameDirect
$LN1@NameDirect:
	cmp	dl, 58					; 0000003aH
	je	SHORT $LN2@NameDirect
$LN7@NameDirect:

; 421  :     }
; 422  : 
; 423  :     /* don't touch Option fields! if anything at all, ModuleInfo.name may be modified.
; 424  :      * However, since the directive is ignored by Masm, nothing is done.
; 425  :      */
; 426  : //  strncpy( ModuleInfo.name, tokenarray[i].string_ptr, sizeof( ModuleInfo.name ) );
; 427  : //  ModuleInfo.name[ sizeof( ModuleInfo.name ) - 1] = NULLC;
; 428  : //  DebugMsg(("NameDirective: set name to >%s<\n", ModuleInfo.name ));
; 429  :     DebugMsg(("NameDirective: ignored name >%s<\n", tokenarray[i].string_ptr ));
; 430  :     return( NOT_ERROR );

	xor	eax, eax

; 431  : }

	ret	0
$LN2@NameDirect:

; 420  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i-1].tokpos ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r8-8]

; 431  : }

	jmp	EmitErr
NameDirective ENDP
_TEXT	ENDS
EXTRN	Tokenize:NEAR
xdata	SEGMENT
$unwind$RadixDirective DD 020a01H
	DD	015010aH
xdata	ENDS
pdata	SEGMENT
$pdata$RadixDirective DD @imagerel($LN9#)
	DD	@imagerel($LN9#+10)
	DD	@imagerel($unwind$RadixDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$1$RadixDirective DD 040f21H
	DD	019740fH
	DD	0183404H
	DD	@imagerel($LN9#)
	DD	@imagerel($LN9#+10)
	DD	@imagerel($unwind$RadixDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$RadixDirective DD @imagerel($LN9#+10)
	DD	@imagerel($LN9#+119)
	DD	@imagerel($chain$1$RadixDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$2$RadixDirective DD 020021H
	DD	0197400H
	DD	@imagerel($LN9#)
	DD	@imagerel($LN9#+10)
	DD	@imagerel($unwind$RadixDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$RadixDirective DD @imagerel($LN9#+119)
	DD	@imagerel($LN9#+267)
	DD	@imagerel($chain$2$RadixDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
opndx$ = 48
i$ = 176
tokenarray$ = 184
RadixDirective PROC NEAR

; 437  : {

$LN9:
	mov	rax, rsp
	sub	rsp, 168				; 000000a8H
	mov	QWORD PTR [rax+24], rbx

; 438  :     uint_8          oldradix;
; 439  :     struct expr     opndx;
; 440  : 
; 441  :     /* to get the .radix parameter, enforce radix 10 and retokenize! */
; 442  :     oldradix = ModuleInfo.radix;

	movzx	ebx, BYTE PTR ModuleInfo+396
	mov	QWORD PTR [rax+32], rdi
	mov	rdi, rdx

; 443  :     ModuleInfo.radix = 10;
; 444  :     i++; /* skip directive token */

	lea	edx, DWORD PTR [rcx+1]
	mov	BYTE PTR ModuleInfo+396, 10

; 445  :     Tokenize( tokenarray[i].tokpos, i, tokenarray, TOK_RESCAN );

	movsxd	rcx, edx
	mov	DWORD PTR [rax+8], edx
	mov	r9d, 1
	shl	rcx, 5
	mov	r8, rdi
	mov	rcx, QWORD PTR [rcx+rdi+24]
	call	Tokenize

; 446  :     ModuleInfo.radix = oldradix;
; 447  :     /* v2.11: flag NOUNDEF added - no forward ref possible */
; 448  :     if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR ) {

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rdi
	mov	BYTE PTR ModuleInfo+396, bl
	mov	BYTE PTR [rsp+32], 2
	call	EvalOperand
	mov	rbx, QWORD PTR [rsp+192]
	cmp	eax, -1
	jne	SHORT $LN5@RadixDirec
	mov	rdi, QWORD PTR [rsp+200]

; 466  : }

	add	rsp, 168				; 000000a8H
	ret	0
$LN5@RadixDirec:

; 449  :         return( ERROR );
; 450  :     }
; 451  : 
; 452  :     if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN4@RadixDirec

; 453  :         return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	jmp	SHORT $LN8@RadixDirec
$LN4@RadixDirec:

; 454  :     }
; 455  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, DWORD PTR i$[rsp]
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rdi], 0
	je	SHORT $LN3@RadixDirec

; 456  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rdi+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	mov	rdi, QWORD PTR [rsp+200]

; 466  : }

	add	rsp, 168				; 000000a8H
	ret	0
$LN3@RadixDirec:

; 457  :     }
; 458  :     if ( opndx.value > 16 || opndx.value < 2 || opndx.hvalue != 0 ) {

	mov	ecx, DWORD PTR opndx$[rsp]
	lea	eax, DWORD PTR [rcx-2]
	cmp	eax, 14
	ja	SHORT $LN1@RadixDirec
	cmp	DWORD PTR opndx$[rsp+4], 0
	jne	SHORT $LN1@RadixDirec

; 460  :     }
; 461  : 
; 462  :     ModuleInfo.radix = opndx.value;

	mov	BYTE PTR ModuleInfo+396, cl

; 463  :     DebugMsg(("RadixDirective: new radix=%u\n", ModuleInfo.radix ));
; 464  : 
; 465  :     return( NOT_ERROR );

	xor	eax, eax
	mov	rdi, QWORD PTR [rsp+200]

; 466  : }

	add	rsp, 168				; 000000a8H
	ret	0
$LN1@RadixDirec:

; 459  :         return( EmitError( INVALID_RADIX_TAG ) );

	mov	ecx, 181				; 000000b5H
$LN8@RadixDirec:
	call	EmitError
	mov	rdi, QWORD PTR [rsp+200]

; 466  : }

	add	rsp, 168				; 000000a8H
	ret	0
RadixDirective ENDP
_TEXT	ENDS
EXTRN	_strupr:NEAR
EXTRN	SpecialTable:BYTE
xdata	SEGMENT
$unwind$SegOrderDirective DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SegOrderDirective DD @imagerel($LN8#)
	DD	@imagerel($LN8#+157)
	DD	@imagerel($unwind$SegOrderDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
SegOrderDirective PROC NEAR

; 472  : {

$LN8:
	sub	rsp, 40					; 00000028H
	mov	r8, rdx

; 473  :     if ( tokenarray[i+1].token != T_FINAL ) {

	movsxd	rcx, ecx
	lea	rdx, QWORD PTR [rcx+1]
	shl	rdx, 5
	cmp	BYTE PTR [rdx+r8], 0
	je	SHORT $LN5@SegOrderDi

; 474  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i+1].tokpos ) );

	mov	rdx, QWORD PTR [rdx+r8+24]
	mov	ecx, 209				; 000000d1H

; 492  : }

	add	rsp, 40					; 00000028H
	jmp	EmitErr
$LN5@SegOrderDi:

; 475  :     }
; 476  : #if COFF_SUPPORT || ELF_SUPPORT || PE_SUPPORT
; 477  :     if ( Options.output_format == OFORMAT_COFF
; 478  : #if ELF_SUPPORT
; 479  :         || Options.output_format == OFORMAT_ELF
; 480  : #endif
; 481  : #if PE_SUPPORT
; 482  :         || ( Options.output_format == OFORMAT_BIN && ModuleInfo.sub_format == SFORMAT_PE )
; 483  : #endif
; 484  :        ) {

	mov	eax, DWORD PTR Options+156
	cmp	eax, 2
	je	SHORT $LN3@SegOrderDi
	cmp	eax, 3
	je	SHORT $LN3@SegOrderDi
	test	eax, eax
	jne	SHORT $LN4@SegOrderDi
	cmp	DWORD PTR ModuleInfo+372, 2
	je	SHORT $LN3@SegOrderDi
$LN4@SegOrderDi:

; 487  :     } else
; 488  : #endif
; 489  :         ModuleInfo.segorder = GetSflagsSp( tokenarray[i].tokval );

	shl	rcx, 5
	mov	eax, DWORD PTR [rcx+r8+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rax, OFFSET FLAT:SpecialTable+4
	mov	eax, DWORD PTR [rax+rcx*4]
	mov	DWORD PTR ModuleInfo+380, eax

; 490  : 
; 491  :     return( NOT_ERROR );

	xor	eax, eax

; 492  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@SegOrderDi:

; 485  :         if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN2@SegOrderDi

; 486  :             EmitWarn( 2, NOT_SUPPORTED_WITH_CURR_FORMAT, _strupr( tokenarray[i].string_ptr ) );

	shl	rcx, 5
	mov	rcx, QWORD PTR [rcx+r8+8]
	call	_strupr
	mov	edx, 224				; 000000e0H
	mov	ecx, 2
	mov	r8, rax
	call	EmitWarn
$LN2@SegOrderDi:

; 490  : 
; 491  :     return( NOT_ERROR );

	xor	eax, eax

; 492  : }

	add	rsp, 40					; 00000028H
	ret	0
SegOrderDirective ENDP
_TEXT	ENDS
END
