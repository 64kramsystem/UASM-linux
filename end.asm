; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG5745	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
$SG5653	DB	'mov %r,DGROUP', 00H
	ORG $+2
$SG5654	DB	'mov %r,%r', 00H
	ORG $+6
$SG5655	DB	'mov %r,%r', 00H
	ORG $+6
$SG5656	DB	'sub %r,%r', 00H
	ORG $+6
$SG5657	DB	'shl %r,1', 00H
	ORG $+7
$SG5658	DB	'shl %r,1', 00H
	ORG $+7
$SG5659	DB	'shl %r,1', 00H
	ORG $+7
$SG5660	DB	'shl %r,1', 00H
	ORG $+3
$SG5661	DB	'cli', 00H
$SG5662	DB	'mov %r,%r', 00H
	ORG $+6
$SG5663	DB	'add %r,%r', 00H
	ORG $+2
$SG5664	DB	'sti', 00H
_DATA	ENDS
CONST	SEGMENT
StartupDosNear0 DQ FLAT:$SG5653
	DW	0bH
	DW	00H
	ORG $+4
	DQ	FLAT:$SG5654
	DW	01cH
	DW	0bH
	ORG $+4
	DQ	FLAT:$SG5655
	DW	0cH
	DW	01bH
	ORG $+4
	DQ	FLAT:$SG5656
	DW	0cH
	DW	0bH
	ORG $+4
	DQ	FLAT:$SG5657
	DW	0cH
	DW	00H
	ORG $+4
	DQ	FLAT:$SG5658
	DW	0cH
	DW	00H
	ORG $+4
	DQ	FLAT:$SG5659
	DW	0cH
	DW	00H
	ORG $+4
	DQ	FLAT:$SG5660
	DW	0cH
	DW	00H
	ORG $+4
	DQ	FLAT:$SG5661
	DW	00H
	DW	00H
	ORG $+4
	DQ	FLAT:$SG5662
	DW	01bH
	DW	0bH
	ORG $+4
	DQ	FLAT:$SG5663
	DW	0dH
	DW	0cH
	ORG $+4
	DQ	FLAT:$SG5664
	DW	00H
	DW	00H
	ORG $+4
CONST	ENDS
_DATA	SEGMENT
$SG5666	DB	'mov %r,DGROUP', 00H
	ORG $+2
$SG5667	DB	'mov %r,%r', 00H
	ORG $+6
$SG5668	DB	'mov %r,%r', 00H
	ORG $+6
$SG5669	DB	'sub %r,%r', 00H
	ORG $+6
$SG5670	DB	'shl %r,4', 00H
	ORG $+7
$SG5671	DB	'mov %r,%r', 00H
	ORG $+6
$SG5672	DB	'add %r,%r', 00H
_DATA	ENDS
CONST	SEGMENT
StartupDosNear1 DQ FLAT:$SG5666
	DW	09H
	DW	00H
	ORG $+4
	DQ	FLAT:$SG5667
	DW	01cH
	DW	09H
	ORG $+4
	DQ	FLAT:$SG5668
	DW	0cH
	DW	01bH
	ORG $+4
	DQ	FLAT:$SG5669
	DW	0cH
	DW	09H
	ORG $+4
	DQ	FLAT:$SG5670
	DW	0cH
	DW	00H
	ORG $+4
	DQ	FLAT:$SG5671
	DW	01bH
	DW	09H
	ORG $+4
	DQ	FLAT:$SG5672
	DW	0dH
	DW	0cH
	ORG $+4
CONST	ENDS
_DATA	SEGMENT
	ORG $+6
$SG5674	DB	'mov %r,DGROUP', 00H
	ORG $+2
$SG5675	DB	'mov %r,%r', 00H
_DATA	ENDS
CONST	SEGMENT
StartupDosFar DQ FLAT:$SG5674
	DW	0bH
	DW	00H
	ORG $+4
	DQ	FLAT:$SG5675
	DW	01cH
	DW	0bH
	ORG $+4
CONST	ENDS
_DATA	SEGMENT
	ORG $+6
$SG5677	DB	'mov %r,0', 00H
	ORG $+3
$SG5678	DB	'push 1', 00H
	ORG $+5
$SG5679	DB	'push %r', 00H
$SG5680	DB	'call DOSEXIT', 00H
_DATA	ENDS
CONST	SEGMENT
ExitOS2	DQ	FLAT:$SG5677
	DW	05H
	DW	00H
	ORG $+4
	DQ	FLAT:$SG5678
	DW	00H
	DW	00H
	ORG $+4
	DQ	FLAT:$SG5679
	DW	09H
	DW	00H
	ORG $+4
	DQ	FLAT:$SG5680
	DW	00H
	DW	00H
	ORG $+4
CONST	ENDS
_DATA	SEGMENT
	ORG $+3
$SG5682	DB	'mov %r,4ch', 00H
	ORG $+5
$SG5683	DB	'int 21h', 00H
_DATA	ENDS
CONST	SEGMENT
ExitDos	DQ	FLAT:$SG5682
	DW	05H
	DW	00H
	ORG $+4
	DQ	FLAT:$SG5683
	DW	00H
	DW	00H
	ORG $+4
szStartAddr DB	'@Startup', 00H
CONST	ENDS
_DATA	SEGMENT
$SG5704	DB	'org 100h', 00H
	ORG $+3
$SG5705	DB	'%s::', 00H
	ORG $+7
$SG5722	DB	'mov %r,%s', 00H
	ORG $+6
$SG5726	DB	'mov %r,4C00h + %u', 00H
	ORG $+6
$SG5728	DB	'mov %r,%s', 00H
	ORG $+6
$SG5729	DB	'mov %r,4Ch', 00H
_DATA	ENDS
PUBLIC	StartupExitDirective
EXTRN	RunLineQueue:NEAR
EXTRN	EvalOperand:NEAR
EXTRN	AddLineQueueX:NEAR
EXTRN	AddLineQueue:NEAR
EXTRN	EmitErr:NEAR
EXTRN	EmitError:NEAR
EXTRN	ModuleInfo:BYTE
EXTRN	LstWriteSrcLine:NEAR
xdata	SEGMENT
$unwind$StartupExitDirective DD 061601H
	DD	014c416H
	DD	01b5412H
	DD	017010eH
xdata	ENDS
pdata	SEGMENT
$pdata$StartupExitDirective DD @imagerel($LN50#)
	DD	@imagerel($LN50#+101)
	DD	@imagerel($unwind$StartupExitDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$4$StartupExitDirective DD 062321H
	DD	0157423H
	DD	0166410H
	DD	01a3408H
	DD	@imagerel($LN50#)
	DD	@imagerel($LN50#+101)
	DD	@imagerel($unwind$StartupExitDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$StartupExitDirective DD @imagerel($LN50#+101)
	DD	@imagerel($LN50#+706)
	DD	@imagerel($chain$4$StartupExitDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$5$StartupExitDirective DD 021H
	DD	@imagerel($LN50#)
	DD	@imagerel($LN50#+101)
	DD	@imagerel($unwind$StartupExitDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$StartupExitDirective DD @imagerel($LN50#+706)
	DD	@imagerel($LN50#+730)
	DD	@imagerel($chain$5$StartupExitDirective#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\end.c
pdata	ENDS
_TEXT	SEGMENT
opndx$ = 48
i$ = 192
tokenarray$ = 200
StartupExitDirective PROC NEAR

; 96   : {

$LN50:
	mov	DWORD PTR [rsp+8], ecx
	mov	rax, rsp
	sub	rsp, 184				; 000000b8H
	mov	QWORD PTR [rax+32], rbp
	mov	QWORD PTR [rax-24], r12

; 97   :     int         count;
; 98   :     ret_code    rc = NOT_ERROR;

	xor	r12d, r12d
	mov	rbp, rdx

; 99   :     int         j;
; 100  :     const struct code_line *p;
; 101  :     struct expr opndx;
; 102  : 
; 103  :     LstWriteSrcLine();

	call	LstWriteSrcLine

; 104  : 
; 105  :     if( ModuleInfo.model == MODEL_NONE ) {

	mov	r11d, DWORD PTR ModuleInfo+360
	test	r11d, r11d
	jne	SHORT $LN29@StartupExi

; 106  :         return( EmitError( MODEL_IS_NOT_DECLARED ) );

	lea	ecx, QWORD PTR [r12+96]
	call	EmitError
	jmp	$LN30@StartupExi
$LN29@StartupExi:

; 107  :     }
; 108  :     if ( ModuleInfo.Ofssize > USE16 ) {

	cmp	BYTE PTR ModuleInfo+404, r12b
	jbe	SHORT $LN28@StartupExi

; 109  :         return( EmitErr( DOES_NOT_WORK_WITH_32BIT_SEGMENTS, tokenarray[i].string_ptr ) );

	movsxd	rdx, DWORD PTR i$[rsp]
	mov	ecx, 221				; 000000ddH
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbp+8]
	call	EmitErr
	jmp	$LN30@StartupExi
$LN28@StartupExi:
	mov	QWORD PTR [rsp+208], rbx
	mov	QWORD PTR [rsp+176], rsi

; 110  :     }
; 111  : 
; 112  :     switch( tokenarray[i].tokval ) {

	movsxd	rsi, DWORD PTR i$[rsp]
	mov	rax, rsi
	mov	QWORD PTR [rsp+168], rdi
	shl	rax, 5
	mov	ecx, DWORD PTR [rax+rbp+16]
	sub	ecx, 345				; 00000159H
	je	$LN13@StartupExi
	dec	ecx
	jne	$LN2@StartupExi

; 113  :     case T_DOT_STARTUP:
; 114  :         count = 0;
; 115  :         /* for tiny model, set current PC to 100h. */
; 116  :         if ( ModuleInfo.model == MODEL_TINY )

	cmp	r11d, 1
	jne	SHORT $LN24@StartupExi

; 117  :             AddLineQueue( "org 100h" );

	lea	rcx, OFFSET FLAT:$SG5704
	call	AddLineQueue
$LN24@StartupExi:

; 118  :         AddLineQueueX( "%s::", szStartAddr );

	lea	rdx, OFFSET FLAT:szStartAddr
	lea	rcx, OFFSET FLAT:$SG5705
	call	AddLineQueueX

; 119  :         if( ModuleInfo.ostype == OPSYS_DOS ) {

	cmp	DWORD PTR ModuleInfo+368, r12d
	jne	SHORT $LN14@StartupExi

; 120  :             if ( ModuleInfo.model == MODEL_TINY )

	cmp	DWORD PTR ModuleInfo+360, 1
	je	SHORT $LN14@StartupExi

; 121  :                 ;
; 122  :             else {
; 123  :                 if( ModuleInfo.distance == STACK_NEAR ) {

	cmp	DWORD PTR ModuleInfo+356, r12d
	jne	SHORT $LN20@StartupExi

; 124  :                     if ( ( ModuleInfo.cpu & M_CPUMSK ) <= M_8086 ) {

	movzx	eax, BYTE PTR ModuleInfo+388
	and	al, 127					; 0000007fH
	cmp	al, 1
	jg	SHORT $LN19@StartupExi

; 125  :                         p = StartupDosNear0;

	lea	rdi, OFFSET FLAT:StartupDosNear0

; 126  :                         count = sizeof( StartupDosNear0 ) / sizeof( StartupDosNear0[0] );

	mov	ebx, 12

; 127  :                     } else {

	jmp	SHORT $LL43@StartupExi
$LN19@StartupExi:

; 128  :                         p = StartupDosNear1;

	lea	rdi, OFFSET FLAT:StartupDosNear1

; 129  :                         count = sizeof( StartupDosNear1 ) / sizeof( StartupDosNear1[0] );

	mov	ebx, 7

; 130  :                     }
; 131  :                 } else {

	jmp	SHORT $LL43@StartupExi
$LN20@StartupExi:

; 132  :                     p = StartupDosFar;

	lea	rdi, OFFSET FLAT:StartupDosFar

; 133  :                     count = sizeof( StartupDosFar ) / sizeof( StartupDosFar[0] );

	mov	ebx, 2
	npad	7
$LL43@StartupExi:

; 134  :                 }
; 135  :                 for ( ; count ; count--, p++ )
; 136  :                     AddLineQueueX( (char *)p->src, p->r1, p->r2 );

	movsx	r8d, WORD PTR [rdi+10]
	movsx	edx, WORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rdi]
	call	AddLineQueueX
	add	rdi, 16
	dec	ebx
	jne	SHORT $LL43@StartupExi
$LN14@StartupExi:

; 137  :             }
; 138  :         }
; 139  :         ModuleInfo.StartupDirectiveFound = TRUE;
; 140  :         i++; /* skip directive token */

	mov	esi, DWORD PTR i$[rsp]
	bts	DWORD PTR ModuleInfo+408, 16
	inc	esi
	mov	DWORD PTR i$[rsp], esi

; 141  :         break;

	jmp	$LN2@StartupExi
$LN13@StartupExi:

; 142  :     case T_DOT_EXIT:
; 143  :         if( ModuleInfo.ostype == OPSYS_DOS ) {

	mov	eax, DWORD PTR ModuleInfo+368
	test	eax, eax
	jne	SHORT $LN12@StartupExi

; 144  :             p = ExitDos;

	lea	rdi, OFFSET FLAT:ExitDos

; 145  :             count = sizeof( ExitDos ) / sizeof( ExitDos[0] );

	lea	ebx, QWORD PTR [rax+2]

; 146  :         } else {

	jmp	SHORT $LN11@StartupExi
$LN12@StartupExi:

; 147  :             p = ExitOS2;

	lea	rdi, OFFSET FLAT:ExitOS2

; 148  :             count = sizeof( ExitOS2 ) / sizeof( ExitOS2[0] );

	mov	ebx, 4
$LN11@StartupExi:

; 149  :         }
; 150  :         i++; /* skip directive token */

	inc	esi

; 151  :         if ( tokenarray[i].token != T_FINAL ) {

	movsxd	r8, esi
	mov	DWORD PTR i$[rsp], esi
	shl	r8, 5
	cmp	BYTE PTR [r8+rbp], r12b
	je	$LN10@StartupExi

; 152  :             if( ModuleInfo.ostype == OPSYS_OS2 ) {

	cmp	eax, 1
	jne	SHORT $LN9@StartupExi

; 153  :                 AddLineQueueX( "mov %r,%s", T_AX, tokenarray[i].tokpos );

	mov	r8, QWORD PTR [r8+rbp+24]
	lea	edx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG5722
	call	AddLineQueueX

; 154  :                 i = Token_Count;

	mov	esi, DWORD PTR ModuleInfo+496
	mov	DWORD PTR i$[rsp], esi

; 155  :             } else {

	jmp	$LN5@StartupExi
$LN9@StartupExi:

; 156  :                 j = i;
; 157  :                 if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rbp
	mov	BYTE PTR [rsp+32], r12b
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN7@StartupExi

; 158  :                     return( ERROR );

	jmp	$LN49@StartupExi
$LN7@StartupExi:

; 159  :                 if ( opndx.kind == EXPR_CONST && opndx.value < 0x100 ) {

	cmp	DWORD PTR opndx$[rsp+60], r12d
	jne	SHORT $LN6@StartupExi
	mov	r8d, DWORD PTR opndx$[rsp]
	cmp	r8d, 256				; 00000100H
	jge	SHORT $LN6@StartupExi

; 160  :                     AddLineQueueX( "mov %r,4C00h + %u", T_AX, opndx.value );

	lea	rcx, OFFSET FLAT:$SG5726
	mov	edx, 9
	call	AddLineQueueX

; 161  :                 } else {

	mov	esi, DWORD PTR i$[rsp]
	jmp	SHORT $LN5@StartupExi
$LN6@StartupExi:

; 162  :                     AddLineQueueX( "mov %r,%s", T_AL, tokenarray[j].tokpos );

	movsxd	r8, esi
	lea	rcx, OFFSET FLAT:$SG5728
	mov	edx, 1
	shl	r8, 5
	mov	r8, QWORD PTR [r8+rbp+24]
	call	AddLineQueueX

; 163  :                     AddLineQueueX( "mov %r,4Ch", T_AH );

	lea	rcx, OFFSET FLAT:$SG5729
	mov	edx, 5
	call	AddLineQueueX
	mov	esi, DWORD PTR i$[rsp]
$LN5@StartupExi:

; 164  :                 }
; 165  :             }
; 166  :             p++;

	add	rdi, 16

; 167  :             count--;

	dec	ebx
$LN10@StartupExi:

; 168  :         }
; 169  : 
; 170  :         for( ; count ; count--, p++ ) {

	test	ebx, ebx
	je	SHORT $LN2@StartupExi
	npad	10
$LL4@StartupExi:

; 171  :             AddLineQueueX( (char *)p->src, p->r1, p->r2 );

	movsx	r8d, WORD PTR [rdi+10]
	movsx	edx, WORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rdi]
	call	AddLineQueueX
	add	rdi, 16
	dec	ebx
	jne	SHORT $LL4@StartupExi

; 168  :         }
; 169  : 
; 170  :         for( ; count ; count--, p++ ) {

	mov	esi, DWORD PTR i$[rsp]
$LN2@StartupExi:

; 172  :         }
; 173  :         break;
; 174  :     }
; 175  : 
; 176  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, esi
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbp], r12b
	je	SHORT $LN1@StartupExi

; 177  :         EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos );

	mov	rdx, QWORD PTR [rdx+rbp+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 178  :         rc = ERROR;

	mov	r12d, -1
$LN1@StartupExi:

; 179  :     }
; 180  : 
; 181  :     RunLineQueue();

	call	RunLineQueue

; 182  : 
; 183  :     return( rc );

	mov	eax, r12d
$LN49@StartupExi:
	mov	rsi, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [rsp+208]
	mov	rdi, QWORD PTR [rsp+168]
$LN30@StartupExi:
	mov	r12, QWORD PTR [rsp+160]
	mov	rbp, QWORD PTR [rsp+216]

; 184  : }

	add	rsp, 184				; 000000b8H
	ret	0
StartupExitDirective ENDP
_TEXT	ENDS
PUBLIC	EndDirective
EXTRN	AddPublicData:NEAR
EXTRN	SegmentModuleExit:NEAR
EXTRN	idata_fixup:NEAR
EXTRN	InstrTable:BYTE
EXTRN	optable_idx:BYTE
EXTRN	Options:BYTE
EXTRN	ProcCheckOpen:NEAR
EXTRN	CurrStruct:QWORD
EXTRN	EmitWarn:NEAR
EXTRN	Parse_Pass:DWORD
xdata	SEGMENT
$unwind$EndDirective DD 030901H
	DD	0260109H
	DD	03002H
xdata	ENDS
pdata	SEGMENT
$pdata$EndDirective DD @imagerel($LN23#)
	DD	@imagerel($LN23#+690)
	DD	@imagerel($unwind$EndDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
opndx$ = 48
CodeInfo$5756 = 160
i$ = 320
tokenarray$ = 328
EndDirective PROC NEAR

; 190  : {

$LN23:
	push	rbx
	sub	rsp, 304				; 00000130H

; 191  :     struct expr         opndx;
; 192  : 
; 193  :     DebugMsg1(("EndDirective enter\n"));
; 194  : 
; 195  :     i++; /* skip directive */

	inc	ecx
	mov	rbx, rdx
	mov	DWORD PTR i$[rsp], ecx

; 196  : 
; 197  :     /* v2.08: END may generate code, so write listing first */
; 198  :     LstWriteSrcLine();

	call	LstWriteSrcLine

; 199  : 
; 200  :     /* v2.05: first parse the arguments. this allows
; 201  :      * SegmentModuleExit() later to run generated code.
; 202  :      */
; 203  :     if( ModuleInfo.StartupDirectiveFound ) {

	test	BYTE PTR ModuleInfo+410, 1
	je	$LN22@EndDirecti

; 204  :         /* start label behind END ignored if .STARTUP has been found */
; 205  :         if( i < Token_Count && Parse_Pass == PASS_1 ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN15@EndDirecti
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN15@EndDirecti

; 206  :             EmitWarn( 2, START_ADDRESS_IGNORED );

	mov	edx, 242				; 000000f2H
	mov	ecx, 2
	call	EmitWarn
	mov	eax, DWORD PTR ModuleInfo+496
$LN15@EndDirecti:

; 207  :         }
; 208  :         i = Token_Count + 1;

	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 209  :         tokenarray[i].token = T_ID;

	movsxd	rcx, eax
	shl	rcx, 5
	mov	BYTE PTR [rcx+rbx], 8

; 210  :         tokenarray[i].string_ptr = (char *)szStartAddr;

	movsxd	rax, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:szStartAddr
	shl	rax, 5
	mov	QWORD PTR [rax+rbx+8], rcx

; 211  :         tokenarray[i+1].token = T_FINAL;

	movsxd	rax, DWORD PTR i$[rsp]

; 212  :         tokenarray[i+1].string_ptr = "";

	lea	rcx, OFFSET FLAT:$SG5745
	inc	rax
	shl	rax, 5
	mov	BYTE PTR [rax+rbx], 0
	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	mov	QWORD PTR [rax+rbx+40], rcx

; 213  :         Token_Count = i+1;

	mov	r8d, DWORD PTR i$[rsp]
	inc	r8d
	mov	DWORD PTR ModuleInfo+496, r8d
	jmp	SHORT $LN16@EndDirecti
$LN22@EndDirecti:
	mov	r8d, DWORD PTR ModuleInfo+496
$LN16@EndDirecti:

; 214  :     }
; 215  :     /* v2.11: flag EXPF_NOUNDEF added - will return ERROR if start label isn't defined */
; 216  :     if( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR ) {

	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rbx
	mov	BYTE PTR [rsp+32], 2
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN14@EndDirecti

; 289  : }

	add	rsp, 304				; 00000130H
	pop	rbx
	ret	0
$LN14@EndDirecti:

; 217  :         return( ERROR );
; 218  :     }
; 219  :     if( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, DWORD PTR i$[rsp]
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbx], 0
	je	SHORT $LN13@EndDirecti

; 220  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rbx+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 289  : }

	add	rsp, 304				; 00000130H
	pop	rbx
	ret	0
$LN13@EndDirecti:

; 221  :     }
; 222  : 
; 223  :     if ( CurrStruct ) {

	mov	rdx, QWORD PTR CurrStruct
	test	rdx, rdx
	je	SHORT $LN12@EndDirecti

; 224  :         while ( CurrStruct->next )

	mov	rax, QWORD PTR [rdx+112]
	test	rax, rax
	je	SHORT $LN10@EndDirecti
	npad	3
$LL11@EndDirecti:

; 225  :             CurrStruct = CurrStruct->next;

	mov	rdx, rax
	mov	QWORD PTR CurrStruct, rax
	mov	rax, QWORD PTR [rax+112]
	test	rax, rax
	jne	SHORT $LL11@EndDirecti
$LN10@EndDirecti:

; 226  :         EmitErr( UNMATCHED_BLOCK_NESTING, CurrStruct->sym.name );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 142				; 0000008eH
	call	EmitErr
$LN12@EndDirecti:

; 227  :     }
; 228  :     /* v2.10: check for open PROCedures */
; 229  :     ProcCheckOpen();

	call	ProcCheckOpen

; 230  : 
; 231  :     /* check type of start label. Must be a symbolic code label, internal or external */
; 232  :     if ( opndx.kind == EXPR_ADDR && opndx.indirect == FALSE &&
; 233  :         ( opndx.mem_type == MT_NEAR || opndx.mem_type == MT_FAR || ( opndx.mem_type == MT_EMPTY && opndx.instr == T_OFFSET ) ) &&
; 234  :         opndx.sym && (  opndx.sym->state == SYM_INTERNAL || opndx.sym->state == SYM_EXTERNAL ) ) {

	mov	r11d, DWORD PTR opndx$[rsp+60]
	cmp	r11d, 1
	jne	$LN9@EndDirecti
	test	BYTE PTR opndx$[rsp+72], r11b
	jne	$LN21@EndDirecti
	mov	eax, DWORD PTR opndx$[rsp+64]
	cmp	eax, 129				; 00000081H
	je	SHORT $LN8@EndDirecti
	cmp	eax, 130				; 00000082H
	je	SHORT $LN8@EndDirecti
	cmp	eax, 192				; 000000c0H
	jne	$LN21@EndDirecti
	cmp	DWORD PTR opndx$[rsp+56], 241		; 000000f1H
	jne	$LN21@EndDirecti
$LN8@EndDirecti:
	mov	rax, QWORD PTR opndx$[rsp+80]
	test	rax, rax
	je	$LN21@EndDirecti
	mov	ecx, DWORD PTR [rax+40]
	cmp	ecx, 1
	je	SHORT $LN7@EndDirecti
	cmp	ecx, 2
	jne	$LN21@EndDirecti
$LN7@EndDirecti:

; 235  : 
; 236  :         DebugMsg(("EndDirective: start label=%s, add=%" I32_SPEC "Xh\n", opndx.sym->name, opndx.value ));
; 237  : 
; 238  :         if ( Options.output_format == OFORMAT_OMF ) {

	cmp	DWORD PTR Options+156, 1
	jne	$LN6@EndDirecti

; 239  :             struct code_info    CodeInfo;
; 240  :             /* fixme: no need to create the fixup here, should be done in omf_write_modend() */
; 241  :             //CodeInfo.token = T_NULL; /* v2.09: T_NULL has no entry in optable_idx[] */
; 242  :             //CodeInfo.pinstr = &InstrTable[IndexFromToken( T_NULL )];
; 243  :             CodeInfo.opnd[0].InsFixup = NULL;
; 244  :             CodeInfo.token = T_NOP;
; 245  :             CodeInfo.pinstr = &InstrTable[IndexFromToken( T_NOP )];

	movzx	eax, WORD PTR optable_idx+376
	lea	rcx, OFFSET FLAT:InstrTable

; 246  :             CodeInfo.flags = 0;
; 247  :             CodeInfo.mem_type = MT_EMPTY;
; 248  :             idata_fixup( &CodeInfo, 0, &opndx );

	lea	r8, QWORD PTR opndx$[rsp]
	xor	edx, edx
	mov	QWORD PTR CodeInfo$5756[rsp+48], 0
	mov	DWORD PTR CodeInfo$5756[rsp+24], 643	; 00000283H
	imul	rax, 14
	add	rax, rcx
	lea	rcx, QWORD PTR CodeInfo$5756[rsp]
	mov	BYTE PTR CodeInfo$5756[rsp+142], 0
	mov	QWORD PTR CodeInfo$5756[rsp+16], rax
	mov	DWORD PTR CodeInfo$5756[rsp+28], 192	; 000000c0H
	call	idata_fixup

; 249  : #if FASTMEM==0
; 250  :             LclFree( ModuleInfo.g.start_fixup );
; 251  : #endif
; 252  :             ModuleInfo.g.start_fixup = CodeInfo.opnd[0].InsFixup;

	mov	r11, QWORD PTR CodeInfo$5756[rsp+48]

; 253  :             ModuleInfo.g.start_displ = opndx.value;

	mov	eax, DWORD PTR opndx$[rsp]
	mov	QWORD PTR ModuleInfo+208, r11
	mov	DWORD PTR ModuleInfo+216, eax
$LN2@EndDirecti:

; 278  :     }
; 279  : 
; 280  :     /* close open segments */
; 281  :     SegmentModuleExit();

	call	SegmentModuleExit

; 282  : 
; 283  :     if ( ModuleInfo.g.EndDirHook )

	mov	r11, QWORD PTR ModuleInfo+296
	test	r11, r11
	je	SHORT $LN1@EndDirecti

; 284  :         ModuleInfo.g.EndDirHook( &ModuleInfo );

	lea	rcx, OFFSET FLAT:ModuleInfo
	call	r11
$LN1@EndDirecti:

; 285  : 
; 286  :     ModuleInfo.EndDirFound = TRUE;

	bts	DWORD PTR ModuleInfo+408, 17

; 287  : 
; 288  :     return( NOT_ERROR );

	xor	eax, eax

; 289  : }

	add	rsp, 304				; 00000130H
	pop	rbx
	ret	0
$LN6@EndDirecti:

; 254  :         } else {
; 255  :             /* Masm silently ignores start for -coff if an offset was given */
; 256  :             //if ( opndx.value )
; 257  :             //   emit a warning
; 258  : 
; 259  :             if ( opndx.sym->state != SYM_EXTERNAL && opndx.sym->ispublic == FALSE ) {

	cmp	ecx, 2
	je	SHORT $LN4@EndDirecti
	test	BYTE PTR [rax+48], 128			; 00000080H
	jne	SHORT $LN4@EndDirecti

; 260  :                 opndx.sym->ispublic = TRUE;

	or	BYTE PTR [rax+48], 128			; 00000080H

; 261  :                 AddPublicData( opndx.sym );

	mov	rcx, QWORD PTR opndx$[rsp+80]
	call	AddPublicData
	mov	rax, QWORD PTR opndx$[rsp+80]
$LN4@EndDirecti:

; 262  :             }
; 263  :             ModuleInfo.g.start_label = opndx.sym;

	mov	QWORD PTR ModuleInfo+208, rax

; 264  :         }

	jmp	SHORT $LN2@EndDirecti
$LN9@EndDirecti:

; 265  :     } else if ( opndx.kind != EXPR_EMPTY ) {

	cmp	r11d, -2
	je	SHORT $LN2@EndDirecti
$LN21@EndDirecti:

; 266  : #ifdef DEBUG_OUT
; 267  :         if ( opndx.kind != EXPR_ADDR || opndx.indirect == TRUE ) {
; 268  :             DebugMsg(("EndDirective: start address invalid, opndx.kind=%X indirect=%u\n", opndx.kind, opndx.indirect ));
; 269  :         } else if ( opndx.sym == NULL ) {
; 270  :             DebugMsg(("EndDirective: start symbol=NULL\n" ));
; 271  :         } else if ( opndx.sym->state != SYM_INTERNAL && opndx.sym->state != SYM_EXTERNAL ) {
; 272  :             DebugMsg(("EndDirective: start address invalid, sym->state=%X\n", opndx.sym->state ));
; 273  :         } else {
; 274  :             DebugMsg(("EndDirective: start address not a code label, mem_type=%Xh\n", opndx.mem_type ));
; 275  :         }
; 276  : #endif
; 277  :         return( EmitError( OPERAND_MUST_BE_RELOCATABLE ) );

	mov	ecx, 188				; 000000bcH
	call	EmitError

; 289  : }

	add	rsp, 304				; 00000130H
	pop	rbx
	ret	0
EndDirective ENDP
_TEXT	ENDS
END
