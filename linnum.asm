; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
$SG5789	DB	'$$$%05u', 00H
_DATA	ENDS
EXTRN	LinnumQueue:BYTE
EXTRN	LclAlloc:NEAR
EXTRN	ModuleInfo:BYTE
EXTRN	Options:BYTE
xdata	SEGMENT
$unwind$AddLinnumData DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$AddLinnumData DD @imagerel(AddLinnumData#)
	DD	@imagerel(AddLinnumData#+124)
	DD	@imagerel($unwind$AddLinnumData#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\linnum.c
pdata	ENDS
_TEXT	SEGMENT
data$ = 48
AddLinnumData PROC NEAR

; 40   : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 41   :     struct qdesc *q;
; 42   : #if COFF_SUPPORT
; 43   :     if ( Options.output_format == OFORMAT_COFF ) {

	cmp	DWORD PTR Options+156, 2
	mov	rbx, rcx
	jne	SHORT $LN5@AddLinnumD

; 44   :         q = (struct qdesc *)CurrSeg->e.seginfo->LinnumQueue;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rdx, QWORD PTR [rax+104]
	mov	r8, QWORD PTR [rdx+56]

; 45   :         if ( q == NULL ) {

	test	r8, r8
	jne	SHORT $LN3@AddLinnumD

; 46   :             q = LclAlloc( sizeof( struct qdesc ) );

	lea	ecx, QWORD PTR [r8+16]
	call	LclAlloc

; 47   :             CurrSeg->e.seginfo->LinnumQueue = q;

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rdx, QWORD PTR [rcx+104]
	mov	r8, rax
	mov	QWORD PTR [rdx+56], rax

; 48   :             q->head = NULL;

	mov	QWORD PTR [rax], 0

; 49   :         }
; 50   :     } else

	jmp	SHORT $LN3@AddLinnumD
$LN5@AddLinnumD:

; 51   : #endif
; 52   :         q = &LinnumQueue;

	lea	r8, OFFSET FLAT:LinnumQueue
$LN3@AddLinnumD:

; 53   : 
; 54   :     data->next = NULL;

	mov	QWORD PTR [rbx], 0

; 55   :     if ( q->head == NULL)

	cmp	QWORD PTR [r8], 0
	jne	SHORT $LN2@AddLinnumD

; 56   :         q->head = q->tail = data;

	mov	QWORD PTR [r8], rbx

; 59   :         q->tail = data;

	mov	QWORD PTR [r8+8], rbx

; 60   :     }
; 61   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@AddLinnumD:

; 57   :     else {
; 58   :         ((struct line_num_info *)q->tail)->next = data;

	mov	rax, QWORD PTR [r8+8]
	mov	QWORD PTR [rax], rbx

; 59   :         q->tail = data;

	mov	QWORD PTR [r8+8], rbx

; 60   :     }
; 61   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
AddLinnumData ENDP
_TEXT	ENDS
PUBLIC	AddLinnumDataRef
EXTRN	EmitWarn:NEAR
EXTRN	TypeFromClassName:NEAR
EXTRN	omf_check_flush:NEAR
EXTRN	GetCurrOffset:NEAR
EXTRN	Parse_Pass:DWORD
EXTRN	GetLineNumber:NEAR
EXTRN	write_to_file:BYTE
EXTRN	SetSymSegOfs:NEAR
EXTRN	AddPublicData:NEAR
EXTRN	CreateProc:NEAR
EXTRN	SymFind:NEAR
EXTRN	sprintf:NEAR
EXTRN	procidx:DWORD
EXTRN	CurrProc:QWORD
_BSS	SEGMENT
lastLineNumber DD 01H DUP (?)
	ALIGN	8

dmyproc	DQ	01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$AddLinnumDataRef DD 092101H
	DD	0b7421H
	DD	0a6413H
	DD	09540eH
	DD	083409H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$AddLinnumDataRef DD @imagerel($LN31#)
	DD	@imagerel($LN31#+802)
	DD	@imagerel($unwind$AddLinnumDataRef#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
procname$5785 = 32
srcfile$ = 64
line_num$ = 72
AddLinnumDataRef PROC NEAR

; 71   : {

$LN31:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+80], rsi

; 72   :     struct line_num_info    *curr;
; 73   : 
; 74   : #if COFF_SUPPORT
; 75   :     /* COFF line number info is related to functions/procedures. Since
; 76   :      * assembly allows code lines outside of procs, "dummy" procs must
; 77   :      * be generated. A dummy proc lasts until
; 78   :      * - a true PROC is detected or
; 79   :      * - the source file changes or
; 80   :      * - the segment/section changes ( added in v2.11 )
; 81   :      */
; 82   :     if ( Options.output_format == OFORMAT_COFF &&
; 83   :         CurrProc == NULL &&
; 84   :         ( dmyproc == NULL ||
; 85   :         dmyproc->debuginfo->file != srcfile ||
; 86   :         dmyproc->segment != (struct asym *)CurrSeg ) ) {

	xor	ebp, ebp
	cmp	DWORD PTR Options+156, 2
	mov	QWORD PTR [rsp+88], rdi
	mov	edi, edx
	mov	esi, ecx
	jne	$LN27@AddLinnumD@2
	cmp	QWORD PTR CurrProc, rbp
	jne	$LN27@AddLinnumD@2
	mov	r8, QWORD PTR dmyproc
	test	r8, r8
	je	SHORT $LN15@AddLinnumD@2
	mov	rax, QWORD PTR [r8+72]
	movzx	ecx, WORD PTR [rax+14]
	cmp	ecx, esi
	jne	SHORT $LN16@AddLinnumD@2
	mov	rax, QWORD PTR ModuleInfo+432
	cmp	QWORD PTR [r8+32], rax
	je	$LN27@AddLinnumD@2
$LN16@AddLinnumD@2:

; 87   :         char procname[12];
; 88   :         if ( dmyproc ) {
; 89   :             /**/myassert( dmyproc->segment );
; 90   :             dmyproc->total_size =
; 91   :                 ((struct dsym *)dmyproc->segment)->e.seginfo->current_loc -
; 92   :                 dmyproc->offset;

	mov	rax, QWORD PTR [r8+32]
	mov	rcx, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rcx+12]
	sub	eax, DWORD PTR [r8+16]
	mov	DWORD PTR [r8+64], eax
$LN15@AddLinnumD@2:

; 93   :         }
; 94   :         sprintf( procname, "$$$%05u", procidx );

	mov	r8d, DWORD PTR procidx
	lea	rdx, OFFSET FLAT:$SG5789
	lea	rcx, QWORD PTR procname$5785[rsp]
	call	sprintf

; 95   :         DebugMsg1(("AddLinnumDataRef(src=%u.%u): CurrProc==NULL, dmyproc=%s searching proc=%s\n", srcfile, line_num, dmyproc ? dmyproc->name : "NULL", procname ));
; 96   :         dmyproc = SymSearch( procname );

	lea	rcx, QWORD PTR procname$5785[rsp]
	call	SymFind

; 97   : 
; 98   :         /* in pass 1, create the proc */
; 99   :         if ( dmyproc == NULL ) {

	test	rax, rax
	mov	QWORD PTR dmyproc, rax
	jne	SHORT $LN14@AddLinnumD@2

; 100  :             dmyproc = CreateProc( NULL, procname, SYM_INTERNAL );

	lea	r8d, QWORD PTR [rax+1]
	lea	rdx, QWORD PTR procname$5785[rsp]
	xor	ecx, ecx
	call	CreateProc

; 101  :             DebugMsg1(("AddLinnumDataRef: new proc %s created\n", procname ));
; 102  :             dmyproc->isproc = TRUE; /* flag is usually set inside ParseProc() */
; 103  :             dmyproc->included = TRUE;
; 104  :             AddPublicData( dmyproc );

	mov	rcx, rax
	mov	QWORD PTR dmyproc, rax
	or	BYTE PTR [rax+49], 72			; 00000048H
	call	AddPublicData

; 105  :         } else

	mov	rax, QWORD PTR dmyproc
	jmp	SHORT $LN13@AddLinnumD@2
$LN14@AddLinnumD@2:

; 106  :             procidx++; /* for passes > 1, adjust procidx */

	inc	DWORD PTR procidx
$LN13@AddLinnumD@2:

; 107  : 
; 108  :         /* if the symbols isn't a PROC, the symbol name has been used
; 109  :          * by the user - bad! A warning should be displayed */
; 110  :         if ( dmyproc->isproc == TRUE ) {

	test	BYTE PTR [rax+49], 8
	je	SHORT $LN27@AddLinnumD@2

; 111  :             SetSymSegOfs( dmyproc );

	mov	rcx, rax
	call	SetSymSegOfs

; 112  :             dmyproc->Ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	r11, QWORD PTR dmyproc
	mov	BYTE PTR [r11+52], al

; 113  :             dmyproc->langtype = ModuleInfo.langtype;

	mov	eax, DWORD PTR ModuleInfo+364
	mov	DWORD PTR [r11+84], eax

; 114  :             if ( write_to_file == TRUE ) {

	cmp	BYTE PTR write_to_file, 1
	jne	SHORT $LN27@AddLinnumD@2

; 115  :                 curr = LclAlloc( sizeof( struct line_num_info ) );

	mov	ecx, 24
	call	LclAlloc

; 116  :                 curr->sym = dmyproc;

	mov	rcx, QWORD PTR dmyproc
	mov	QWORD PTR [rax+16], rcx
	mov	rbx, rax

; 117  :                 curr->line_number = GetLineNumber();

	call	GetLineNumber

; 118  :                 curr->file = srcfile;

	mov	ecx, esi
	and	eax, 1048575				; 000fffffH

; 119  :                 curr->number = 0;

	mov	DWORD PTR [rbx+8], ebp
	shl	ecx, 20
	or	eax, ecx

; 120  :                 DebugMsg1(("AddLinnumDataRef: CURRPROC=NULL, sym=%s, calling AddLinnumData(src=%u.%u)\n", curr->sym->name, curr->file, curr->line_number ));
; 121  :                 AddLinnumData( curr );

	mov	rcx, rbx
	mov	DWORD PTR [rbx+12], eax
	call	AddLinnumData
$LN27@AddLinnumD@2:

; 122  :             }
; 123  :         }
; 124  :     }
; 125  : #endif
; 126  : 
; 127  :     if(  line_num && ( write_to_file == FALSE || lastLineNumber == line_num )) {

	test	edi, edi
	je	SHORT $LN10@AddLinnumD@2
	cmp	BYTE PTR write_to_file, bpl
	je	$LN20@AddLinnumD@2
	cmp	DWORD PTR lastLineNumber, edi

; 128  : #ifdef DEBUG_OUT
; 129  :         if ( write_to_file == TRUE )
; 130  :             DebugMsg1(("AddLinnumDataRef(src=%u.%u) line skipped, lastline=%u\n", srcfile, line_num, lastLineNumber ));
; 131  : #endif
; 132  :         return;

	je	$LN20@AddLinnumD@2
$LN10@AddLinnumD@2:

; 133  :     }
; 134  :     DebugMsg1(("AddLinnumDataRef(src=%u.%u): currofs=%Xh, CurrProc=%s, GeneratedCode=%u\n", srcfile, line_num, GetCurrOffset(), CurrProc ? CurrProc->sym.name : "NULL", ModuleInfo.GeneratedCode ));
; 135  : 
; 136  :     curr = LclAlloc( sizeof( struct line_num_info ) );

	mov	ecx, 24
	call	LclAlloc

; 137  :     curr->number = line_num;
; 138  : #if COFF_SUPPORT
; 139  :     if ( line_num == 0 ) { /* happens for COFF only */

	test	edi, edi
	mov	DWORD PTR [rax+8], edi
	mov	rbx, rax
	jne	$LN8@AddLinnumD@2

; 140  :         /* changed v2.03 (CurrProc might have been NULL) */
; 141  :         /* if ( Options.output_format == OFORMAT_COFF && CurrProc->sym.public == FALSE ) { */
; 142  :         /* v2.09: avoid duplicates, check for pass 1 */
; 143  :         //if ( Options.output_format == OFORMAT_COFF && CurrProc && CurrProc->sym.public == FALSE ) {
; 144  :         if ( Parse_Pass == PASS_1 &&
; 145  :             Options.output_format == OFORMAT_COFF && CurrProc && CurrProc->sym.ispublic == FALSE ) {

	cmp	DWORD PTR Parse_Pass, ebp
	jne	SHORT $LN28@AddLinnumD@2
	cmp	DWORD PTR Options+156, 2
	jne	SHORT $LN28@AddLinnumD@2
	mov	rcx, QWORD PTR CurrProc
	test	rcx, rcx
	je	SHORT $LN7@AddLinnumD@2
	test	BYTE PTR [rcx+48], 128			; 00000080H
	jne	SHORT $LN7@AddLinnumD@2

; 146  :             CurrProc->sym.included = TRUE;

	or	BYTE PTR [rcx+49], 64			; 00000040H

; 147  :             AddPublicData( (struct asym *)CurrProc );

	mov	rcx, QWORD PTR CurrProc
	call	AddPublicData
	mov	rcx, QWORD PTR CurrProc
	jmp	SHORT $LN7@AddLinnumD@2
$LN28@AddLinnumD@2:
	mov	rcx, QWORD PTR CurrProc
$LN7@AddLinnumD@2:

; 148  :         }
; 149  :         /* changed v2.03 */
; 150  :         /* curr->sym = (struct asym *)CurrProc; */
; 151  :         curr->sym = ( CurrProc ? (struct asym *)CurrProc : dmyproc );

	mov	rax, QWORD PTR dmyproc
	test	rcx, rcx
	cmovne	rax, rcx
	mov	QWORD PTR [rbx+16], rax

; 152  :         curr->line_number = GetLineNumber();

	call	GetLineNumber

; 153  :         curr->file        = srcfile;
; 154  :         /* set the function's size! */
; 155  :         if ( dmyproc ) {

	mov	rdx, QWORD PTR dmyproc
	and	eax, 1048575				; 000fffffH
	mov	ecx, esi
	shl	ecx, 20
	or	eax, ecx
	test	rdx, rdx
	mov	DWORD PTR [rbx+12], eax
	je	SHORT $LN6@AddLinnumD@2

; 156  :             /**/myassert( dmyproc->segment );
; 157  :             dmyproc->total_size =
; 158  :                 ((struct dsym *)dmyproc->segment)->e.seginfo->current_loc -
; 159  :                 dmyproc->offset;

	mov	rax, QWORD PTR [rdx+32]

; 160  :             dmyproc = NULL;

	mov	QWORD PTR dmyproc, rbp
	mov	rcx, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rcx+12]
	sub	eax, DWORD PTR [rdx+16]
	mov	DWORD PTR [rdx+64], eax
$LN6@AddLinnumD@2:

; 161  :         }
; 162  :         /* v2.11: write a 0x7fff line item if prologue exists */
; 163  :         if ( CurrProc && CurrProc->e.procinfo->size_prolog ) {

	mov	rax, QWORD PTR CurrProc
	test	rax, rax
	je	SHORT $LN4@AddLinnumD@2
	mov	rax, QWORD PTR [rax+104]
	cmp	BYTE PTR [rax+129], bpl
	je	SHORT $LN4@AddLinnumD@2

; 164  :             DebugMsg1(("AddLinnumDataRef: calling AddLinnumData(src=%u.%u) sym=%s\n", curr->file, curr->line_number, curr->sym->name ));
; 165  :             AddLinnumData( curr );

	mov	rcx, rbx
	call	AddLinnumData

; 166  :             curr = LclAlloc( sizeof( struct line_num_info ) );

	mov	ecx, 24
	call	LclAlloc
	mov	rbx, rax

; 167  :             curr->number = GetLineNumber();

	call	GetLineNumber
	mov	DWORD PTR [rbx+8], eax

; 168  :             curr->offset = GetCurrOffset();

	call	GetCurrOffset

; 169  :             curr->srcfile = srcfile;

	mov	DWORD PTR [rbx+16], esi
	mov	DWORD PTR [rbx+12], eax

; 170  :         }
; 171  :     } else {

	jmp	SHORT $LN4@AddLinnumD@2
$LN8@AddLinnumD@2:

; 172  : #endif
; 173  :         curr->offset = GetCurrOffset();

	call	GetCurrOffset

; 174  :         curr->srcfile = srcfile;

	mov	DWORD PTR [rbx+16], esi
	mov	DWORD PTR [rbx+12], eax
$LN4@AddLinnumD@2:

; 175  : #if COFF_SUPPORT
; 176  :     }
; 177  : #endif
; 178  :     lastLineNumber = line_num;
; 179  : 
; 180  :     /* v2.11: added, improved multi source support for CV.
; 181  :      * Also, the size of line number info could have become > 1024,
; 182  :      * ( even > 4096, thus causing an "internal error in omfint.c" )
; 183  :      */
; 184  :     if ( Options.output_format == OFORMAT_OMF )

	cmp	DWORD PTR Options+156, 1
	mov	DWORD PTR lastLineNumber, edi
	jne	SHORT $LN3@AddLinnumD@2

; 185  :         omf_check_flush( curr );

	mov	rcx, rbx
	call	omf_check_flush
$LN3@AddLinnumD@2:

; 186  : 
; 187  :     /* v2.10: warning if line-numbers for segments without class code! */
; 188  :     if ( CurrSeg->e.seginfo->linnum_init == FALSE ) {

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rcx+104]
	test	BYTE PTR [rax+107], 64			; 00000040H
	jne	SHORT $LN29@AddLinnumD@2

; 189  :         CurrSeg->e.seginfo->linnum_init = TRUE;

	or	BYTE PTR [rax+107], 64			; 00000040H

; 190  :         if ( TypeFromClassName( CurrSeg, CurrSeg->e.seginfo->clsym ) != SEGTYPE_CODE ) {

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rdx, QWORD PTR [rcx+104]
	mov	rdx, QWORD PTR [rdx+80]
	call	TypeFromClassName
	cmp	eax, 1
	je	SHORT $LN29@AddLinnumD@2

; 191  :             EmitWarn( 2, LINNUM_INFO_FOR_SEGMENT_WITHOUT_CLASS_CODE, CurrSeg->sym.name );

	mov	r8, QWORD PTR ModuleInfo+432
	mov	edx, 187				; 000000bbH
	mov	ecx, 2
	mov	r8, QWORD PTR [r8+8]
	call	EmitWarn
$LN29@AddLinnumD@2:

; 192  :         }
; 193  :     }
; 194  :     DebugMsg1(("AddLinnumDataRef: calling AddLinnumData(src=%u.%u ofs=%X)\n", curr->number == 0 ? curr->file : curr->srcfile, curr->number, curr->offset ));
; 195  :     AddLinnumData( curr );

	cmp	DWORD PTR Options+156, 2
	jne	SHORT $LN24@AddLinnumD@2
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	mov	r8, QWORD PTR [rcx+56]
	test	r8, r8
	jne	SHORT $LN22@AddLinnumD@2
	lea	ecx, QWORD PTR [r8+16]
	call	LclAlloc
	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rdx, QWORD PTR [rcx+104]
	mov	r8, rax
	mov	QWORD PTR [rdx+56], rax
	mov	QWORD PTR [rax], rbp
	jmp	SHORT $LN22@AddLinnumD@2
$LN24@AddLinnumD@2:
	lea	r8, OFFSET FLAT:LinnumQueue
$LN22@AddLinnumD@2:
	mov	QWORD PTR [rbx], rbp
	cmp	QWORD PTR [r8], rbp
	jne	SHORT $LN21@AddLinnumD@2
	mov	QWORD PTR [r8], rbx
	jmp	SHORT $LN30@AddLinnumD@2
$LN21@AddLinnumD@2:
	mov	rax, QWORD PTR [r8+8]
	mov	QWORD PTR [rax], rbx
$LN30@AddLinnumD@2:
	mov	QWORD PTR [r8+8], rbx
$LN20@AddLinnumD@2:
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 196  : 
; 197  :     return;
; 198  : }

	add	rsp, 56					; 00000038H
	ret	0
AddLinnumDataRef ENDP
_TEXT	ENDS
PUBLIC	QueueDeleteLinnum
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
queue$ = 8
QueueDeleteLinnum PROC NEAR

; 203  :     struct line_num_info    *curr;
; 204  :     struct line_num_info    *next;
; 205  : 
; 206  :     if ( queue == NULL )

	test	rcx, rcx
	je	SHORT $LN1@QueueDelet

; 207  : 	   return;
; 208  :     curr = queue->head;

	mov	rax, QWORD PTR [rcx]

; 209  :     for( ; curr ; curr = next ) {

	test	rax, rax
	je	SHORT $LN1@QueueDelet
	npad	3
$LL3@QueueDelet:
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL3@QueueDelet
$LN1@QueueDelet:

; 210  : 	    next = curr->next;
; 211  :     }
; 212  :     return;
; 213  : }

	ret	0
QueueDeleteLinnum ENDP
_TEXT	ENDS
PUBLIC	LinnumFini
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
LinnumFini PROC NEAR

; 221  : #if COFF_SUPPORT
; 222  :     if ( dmyproc ) {

	mov	rdx, QWORD PTR dmyproc
	test	rdx, rdx
	je	SHORT $LN1@LinnumFini

; 223  :         dmyproc->total_size =
; 224  :             ((struct dsym *)dmyproc->segment)->e.seginfo->current_loc -
; 225  :             dmyproc->offset;

	mov	rax, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR [rax+104]
	mov	eax, DWORD PTR [rcx+12]
	sub	eax, DWORD PTR [rdx+16]
	mov	DWORD PTR [rdx+64], eax
$LN1@LinnumFini:

; 226  :         DebugMsg(("LinnumFini: last dummy proc size=%Xh\n"));
; 227  :     }
; 228  : #endif
; 229  : }

	ret	0
LinnumFini ENDP
_TEXT	ENDS
PUBLIC	LinnumInit
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
LinnumInit PROC NEAR

; 234  :     lastLineNumber = 0;

	xor	eax, eax
	mov	DWORD PTR lastLineNumber, eax

; 235  : #if COFF_SUPPORT
; 236  :     dmyproc = NULL;

	mov	QWORD PTR dmyproc, rax

; 237  : #endif
; 238  : }

	ret	0
LinnumInit ENDP
_TEXT	ENDS
END
