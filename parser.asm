; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	SymTables:BYTE:060H
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	SegOverride:QWORD
COMM	ZEROLOCALS:BYTE
COMM	xmmOver0:BYTE:020H
COMM	xmmOver1:BYTE:020H
COMM	evex:BYTE
$SG6976	DB	'BYTE', 00H
	ORG $+3
$SG7050	DB	'WORD', 00H
	ORG $+3
$SG7057	DB	'DWORD', 00H
	ORG $+2
$SG7063	DB	'BYTE', 00H
	ORG $+3
$SG7088	DB	'BYTE', 00H
	ORG $+3
$SG7091	DB	'WORD', 00H
	ORG $+3
$SG7095	DB	'DWORD', 00H
	ORG $+2
$SG7123	DB	'use16', 00H
	ORG $+2
$SG7124	DB	'USE16', 00H
	ORG $+2
$SG7127	DB	'_flat', 00H
	ORG $+2
$SG7134	DB	'use32', 00H
	ORG $+2
$SG7135	DB	'USE32', 00H
	ORG $+2
$SG7138	DB	'_flat', 00H
	ORG $+2
$SG7145	DB	'use64', 00H
	ORG $+2
$SG7146	DB	'USE64', 00H
	ORG $+2
$SG7149	DB	'_flat', 00H
	ORG $+2
$SG7156	DB	'_DATA', 00H
	ORG $+2
$SG7157	DB	'_BSS', 00H
	ORG $+3
$SG7161	DB	'LABEL BYTE', 00H
	ORG $+1
$SG7162	DB	'%s %s', 00H
	ORG $+2
$SG7173	DB	'.', 00H
	ORG $+2
$SG7174	DB	'%s%s', 00H
	ORG $+3
$SG7418	DB	'xmmword', 00H
$SG7419	DB	'ptr', 00H
_DATA	ENDS
PUBLIC	sym_add_table
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\parser.c
_TEXT	SEGMENT
queue$ = 8
item$ = 16
sym_add_table PROC NEAR

; 103  : #ifdef DEBUG_OUT
; 104  :     if ( queue == &SymTables[TAB_UNDEF] )
; 105  :         item->sym.fwdref = TRUE;
; 106  : #endif
; 107  :     if( queue->head == NULL ) {

	cmp	QWORD PTR [rcx], 0
	jne	SHORT $LN2@sym_add_ta

; 108  :         queue->head = queue->tail = item;
; 109  :         item->next = item->prev = NULL;

	xor	eax, eax
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rdx+120], rax

; 113  :         queue->tail = item;
; 114  :         item->next = NULL;

	mov	QWORD PTR [rdx+112], rax

; 115  :     }
; 116  : }

	ret	0
$LN2@sym_add_ta:

; 110  :     } else {
; 111  :         item->prev = queue->tail;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx+120], rax

; 112  :         queue->tail->next = item;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+112], rdx

; 113  :         queue->tail = item;
; 114  :         item->next = NULL;

	xor	eax, eax
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rdx+112], rax

; 115  :     }
; 116  : }

	ret	0
sym_add_table ENDP
_TEXT	ENDS
PUBLIC	sym_remove_table
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
queue$ = 8
item$ = 16
sym_remove_table PROC NEAR

; 125  :     /* unlink the node */
; 126  :     if( item->prev )

	mov	r8, QWORD PTR [rdx+120]
	test	r8, r8
	je	SHORT $LN4@sym_remove

; 127  :         item->prev->next = item->next;

	mov	rax, QWORD PTR [rdx+112]
	mov	QWORD PTR [r8+112], rax
$LN4@sym_remove:

; 128  :     if( item->next )

	mov	r8, QWORD PTR [rdx+112]
	test	r8, r8
	je	SHORT $LN3@sym_remove

; 129  :         item->next->prev = item->prev;

	mov	rax, QWORD PTR [rdx+120]
	mov	QWORD PTR [r8+120], rax
$LN3@sym_remove:

; 130  : 
; 131  :     //if ( dir->next == NULL )
; 132  :     //    dir->next = dir->prev;
; 133  : 
; 134  :     if ( queue->head == item )

	cmp	QWORD PTR [rcx], rdx
	jne	SHORT $LN2@sym_remove

; 135  :         queue->head = item->next;

	mov	rax, QWORD PTR [rdx+112]
	mov	QWORD PTR [rcx], rax
$LN2@sym_remove:

; 136  :     if ( queue->tail == item )

	cmp	QWORD PTR [rcx+8], rdx
	jne	SHORT $LN7@sym_remove

; 137  :         queue->tail = item->prev;

	mov	rax, QWORD PTR [rdx+120]
	mov	QWORD PTR [rcx+8], rax
$LN7@sym_remove:

; 138  : 
; 139  :     item->next = NULL;

	xor	eax, eax

; 140  :     item->prev = NULL;

	mov	QWORD PTR [rdx+120], rax
	mov	QWORD PTR [rdx+112], rax

; 141  : }

	ret	0
sym_remove_table ENDP
_TEXT	ENDS
PUBLIC	sym_ext2int
EXTRN	AddPublicData:NEAR
xdata	SEGMENT
$unwind$sym_ext2int DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$sym_ext2int DD @imagerel($LN12#)
	DD	@imagerel($LN12#+139)
	DD	@imagerel($unwind$sym_ext2int#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
sym_ext2int PROC NEAR

; 153  : {

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H

; 154  :     /* v2.07: GlobalQueue has been removed */
; 155  :     if ( sym->isproc == FALSE && sym->ispublic == FALSE ) {

	test	BYTE PTR [rcx+49], 8
	mov	rbx, rcx
	jne	SHORT $LN2@sym_ext2in
	movzx	eax, BYTE PTR [rcx+48]
	test	al, al
	js	SHORT $LN2@sym_ext2in

; 156  :         sym->ispublic = TRUE;

	or	al, 128					; 00000080H
	mov	BYTE PTR [rcx+48], al

; 157  :         AddPublicData( sym );

	call	AddPublicData
$LN2@sym_ext2in:

; 158  :     }
; 159  :     sym_remove_table( &SymTables[TAB_EXT], (struct dsym *)sym );

	mov	rcx, QWORD PTR [rbx+120]
	test	rcx, rcx
	je	SHORT $LN8@sym_ext2in
	mov	rax, QWORD PTR [rbx+112]
	mov	QWORD PTR [rcx+112], rax
$LN8@sym_ext2in:
	mov	rcx, QWORD PTR [rbx+112]
	test	rcx, rcx
	je	SHORT $LN7@sym_ext2in
	mov	rax, QWORD PTR [rbx+120]
	mov	QWORD PTR [rcx+120], rax
$LN7@sym_ext2in:
	cmp	QWORD PTR SymTables+16, rbx
	jne	SHORT $LN6@sym_ext2in
	mov	rax, QWORD PTR [rbx+112]
	mov	QWORD PTR SymTables+16, rax
$LN6@sym_ext2in:
	cmp	QWORD PTR SymTables+24, rbx
	jne	SHORT $LN5@sym_ext2in
	mov	rax, QWORD PTR [rbx+120]
	mov	QWORD PTR SymTables+24, rax
$LN5@sym_ext2in:
	xor	eax, eax

; 160  :     if ( sym->isproc == FALSE ) /* v2.01: don't clear flags for PROTO */

	test	BYTE PTR [rbx+49], 8

; 162  :     sym->state = SYM_INTERNAL;

	mov	DWORD PTR [rbx+40], 1
	mov	QWORD PTR [rbx+112], rax
	mov	QWORD PTR [rbx+120], rax
	jne	SHORT $LN1@sym_ext2in

; 161  :         sym->first_size = 0;

	mov	DWORD PTR [rbx+52], eax
$LN1@sym_ext2in:

; 163  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
sym_ext2int ENDP
_TEXT	ENDS
PUBLIC	GetLangType
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
i$ = 8
tokenarray$ = 16
plang$ = 24
GetLangType PROC NEAR

; 168  :     if( tokenarray[*i].token == T_RES_ID ) {

	movsxd	r9, DWORD PTR [rcx]
	shl	r9, 5
	cmp	BYTE PTR [r9+rdx], 7
	jne	SHORT $LN1@GetLangTyp

; 169  : #if 1 /* v2.03: simplified */
; 170  :         if ( tokenarray[(*i)].tokval >= T_C &&
; 171  :             tokenarray[(*i)].tokval <= T_VECTORCALL ) { /* 2.15 implemented the VECTORCALL */

	mov	eax, DWORD PTR [r9+rdx+16]
	cmp	eax, 264				; 00000108H
	jb	SHORT $LN1@GetLangTyp
	cmp	eax, 271				; 0000010fH
	ja	SHORT $LN1@GetLangTyp

; 172  :             *plang = tokenarray[(*i)].bytval;

	movzx	eax, BYTE PTR [r9+rdx+1]
	mov	DWORD PTR [r8], eax

; 173  :             (*i)++;

	inc	DWORD PTR [rcx]

; 174  :             return( NOT_ERROR );

	xor	eax, eax

; 194  : }

	ret	0
$LN1@GetLangTyp:

; 175  :         }
; 176  : #else
; 177  :         switch( tokenarray[(*i)].tokval ) {
; 178  :         case T_C:        *plang = LANG_C;          break;
; 179  :         case T_SYSCALL:  *plang = LANG_SYSCALL;    break;
; 180  :         case T_STDCALL:  *plang = LANG_STDCALL;    break;
; 181  :         case T_PASCAL:   *plang = LANG_PASCAL;     break;
; 182  :         case T_FORTRAN:  *plang = LANG_FORTRAN;    break;
; 183  :         case T_BASIC:    *plang = LANG_BASIC;      break;
; 184  :         case T_FASTCALL: *plang = LANG_FASTCALL;   break;
; 185  :         case T_FASTCALL: *plang = LANG_VECTORCALL; break;
; 186  :         default:
; 187  :             return( ERROR );
; 188  :         }
; 189  :         (*i)++;
; 190  :         return( NOT_ERROR );
; 191  : #endif
; 192  :     }
; 193  :     return( ERROR );

	mov	eax, -1

; 194  : }

	ret	0
GetLangType ENDP
_TEXT	ENDS
PUBLIC	SizeFromRegister
EXTRN	ModuleInfo:BYTE
EXTRN	SpecialTable:BYTE
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
registertoken$ = 8
SizeFromRegister PROC NEAR

; 204  :     unsigned flags;
; 205  :     if (((registertoken >= T_YMM0) && (registertoken <= T_YMM7 ))||
; 206  :       ((registertoken >= T_YMM8) && (registertoken <= T_YMM31 )))

	cmp	ecx, 56					; 00000038H
	jl	SHORT $LN8@SizeFromRe
	cmp	ecx, 63					; 0000003fH
	jle	SHORT $LN9@SizeFromRe
$LN8@SizeFromRe:
	lea	eax, DWORD PTR [rcx-156]
	cmp	eax, 23
	ja	SHORT $LN10@SizeFromRe
$LN9@SizeFromRe:

; 207  :       flags = GetSflagsSp( registertoken ) & SFR_YMMMASK ;

	movsxd	rax, ecx
	lea	rdx, OFFSET FLAT:SpecialTable
	lea	rcx, QWORD PTR [rax+rax*2]
	shl	rcx, 2
	mov	eax, DWORD PTR [rcx+rdx+4]
	and	eax, 63					; 0000003fH

; 208  :     else if (((registertoken >= T_ZMM0) && (registertoken <= T_ZMM7 ))||

	jmp	SHORT $LN3@SizeFromRe
$LN10@SizeFromRe:

; 209  :       ((registertoken >= T_ZMM8) && (registertoken <= T_ZMM31 )))

	cmp	ecx, 64					; 00000040H
	jl	SHORT $LN4@SizeFromRe
	cmp	ecx, 71					; 00000047H
	jle	SHORT $LN5@SizeFromRe
$LN4@SizeFromRe:
	lea	eax, DWORD PTR [rcx-180]
	cmp	eax, 23
	ja	SHORT $LN6@SizeFromRe
$LN5@SizeFromRe:

; 210  :       flags = GetSflagsSp( registertoken ) & SFR_ZMMMASK ;

	movsxd	rax, ecx
	lea	rdx, OFFSET FLAT:SpecialTable
	lea	rcx, QWORD PTR [rax+rax*2]
	shl	rcx, 2
	mov	eax, DWORD PTR [rcx+rdx+4]
	and	eax, 127				; 0000007fH

; 211  :     else

	jmp	SHORT $LN3@SizeFromRe
$LN6@SizeFromRe:

; 212  :       flags = GetSflagsSp( registertoken ) & SFR_SIZMSK;

	movsxd	rax, ecx
	lea	rdx, OFFSET FLAT:SpecialTable
	lea	rcx, QWORD PTR [rax+rax*2]
	shl	rcx, 2
	mov	eax, DWORD PTR [rcx+rdx+4]
	and	eax, 31
$LN3@SizeFromRe:

; 213  : 
; 214  :     if ( flags )

	test	eax, eax

; 215  :         return( flags );

	jne	SHORT $LN11@SizeFromRe

; 216  : 
; 217  :     flags = GetValueSp( registertoken );
; 218  :     if ( flags & OP_SR )

	test	DWORD PTR [rcx+rdx], 24576		; 00006000H
	je	SHORT $LN1@SizeFromRe

; 219  :         return( CurrWordSize );

	movzx	eax, BYTE PTR ModuleInfo+406

; 224  : #else
; 225  :     return( 4 );
; 226  : #endif
; 227  : }

	ret	0
$LN1@SizeFromRe:

; 220  : 
; 221  :     /* CRx, DRx, TRx remaining */
; 222  : #if AMD64_SUPPORT
; 223  :     return( ModuleInfo.Ofssize == USE64 ? 8 : 4 );

	cmp	BYTE PTR ModuleInfo+404, 2
	mov	eax, 4
	mov	ecx, 8
	cmove	eax, ecx
$LN11@SizeFromRe:

; 224  : #else
; 225  :     return( 4 );
; 226  : #endif
; 227  : }

	ret	0
SizeFromRegister ENDP
_TEXT	ENDS
PUBLIC	SizeFromMemtype
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
mem_type$ = 8
Ofssize$ = 16
type$ = 24
SizeFromMemtype PROC NEAR

; 240  : if ((mem_type & MT_SPECIAL) == 0){

	test	cl, cl
	js	SHORT $LN11@SizeFromMe

; 241  : #if AVXSUPP
; 242  :   if (mem_type == MT_ZMMWORD )

	cmp	ecx, 63					; 0000003fH
	jne	SHORT $LN12@SizeFromMe

; 243  :     return (0x40);

	lea	eax, QWORD PTR [rcx+1]

; 272  :     }
; 273  : }

	ret	0
$LN12@SizeFromMe:

; 244  :   else
; 245  : #endif
; 246  :   return ((mem_type & MT_SIZE_MASK) + 1);

	and	ecx, 31
	lea	eax, DWORD PTR [rcx+1]

; 272  :     }
; 273  : }

	ret	0
$LN11@SizeFromMe:

; 247  :   }
; 248  :     if ( Ofssize == USE_EMPTY )

	cmp	edx, 254				; 000000feH
	jne	SHORT $LN10@SizeFromMe

; 249  :         Ofssize = ModuleInfo.Ofssize;

	movzx	edx, BYTE PTR ModuleInfo+404
$LN10@SizeFromMe:

; 250  : 
; 251  :     switch ( mem_type ) {

	add	ecx, -128				; ffffffffffffff80H
	je	SHORT $LN5@SizeFromMe
	dec	ecx
	je	SHORT $LN7@SizeFromMe
	dec	ecx
	je	SHORT $LN6@SizeFromMe
	sub	ecx, 65					; 00000041H
	je	SHORT $LN4@SizeFromMe
	dec	ecx
	jne	SHORT $LN2@SizeFromMe

; 266  :     case MT_TYPE:
; 267  :         if ( type )

	test	r8, r8
	je	SHORT $LN2@SizeFromMe

; 268  :           return( type->total_size );

	mov	eax, DWORD PTR [r8+64]

; 272  :     }
; 273  : }

	ret	0
$LN2@SizeFromMe:

; 269  :     default:
; 270  :         DebugMsg1(("SizeFromMemtype( memtype=%Xh, Ofssize=%u )=%u\n", mem_type, Ofssize, 0 ));
; 271  :         return( 0 );

	xor	eax, eax

; 272  :     }
; 273  : }

	ret	0
$LN4@SizeFromMe:

; 263  :     case MT_PTR:
; 264  :         DebugMsg1(("SizeFromMemtype( MT_PTR, Ofssize=%u )=%u\n", Ofssize, ( 2 << Ofssize ) + ( ( SIZE_DATAPTR & ( 1 << ModuleInfo.model ) ) ? 2 : 0 ) ));
; 265  :         return( ( 2 << Ofssize ) + ( ( SIZE_DATAPTR & ( 1 << ModuleInfo.model ) ) ? 2 : 0 ) );

	mov	ecx, DWORD PTR ModuleInfo+360
	mov	eax, 1
	shl	eax, cl
	mov	ecx, edx
	mov	edx, 2
	and	al, 104					; 00000068H
	neg	al
	sbb	eax, eax
	shl	edx, cl
	and	eax, 2
	add	eax, edx

; 272  :     }
; 273  : }

	ret	0
$LN6@SizeFromMe:

; 255  :     case MT_FAR:
; 256  :         DebugMsg1(("SizeFromMemtype( MT_FAR, Ofssize=%u )=%u\n", Ofssize, ( 2 << Ofssize ) + 2 ));
; 257  :         return ( ( 2 << Ofssize ) + 2 );

	mov	ecx, edx
	mov	eax, 2
	shl	eax, cl
	add	eax, 2

; 272  :     }
; 273  : }

	ret	0
$LN7@SizeFromMe:

; 252  :     case MT_NEAR:
; 253  :         DebugMsg1(("SizeFromMemtype( MT_NEAR, Ofssize=%u )=%u\n", Ofssize, 2 << Ofssize ));
; 254  :         return ( 2 << Ofssize );

	mov	ecx, edx
	mov	eax, 2
	shl	eax, cl

; 272  :     }
; 273  : }

	ret	0
$LN5@SizeFromMe:

; 258  :     case MT_PROC:
; 259  :         DebugMsg1(("SizeFromMemtype( MT_PROC, Ofssize=%u, type=%s )=%u\n", Ofssize, type->name, ( 2 << Ofssize ) + ( type->isfar ? 2 : 0 ) ));
; 260  :         /* v2.09: use type->isfar setting */
; 261  :         //return( ( 2 << Ofssize ) + ( ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ) ? 2 : 0 ) );
; 262  :         return( ( 2 << Ofssize ) + ( type->isfar ? 2 : 0 ) );

	mov	al, BYTE PTR [r8+55]
	mov	ecx, edx
	mov	edx, 2
	shr	eax, 3
	shl	edx, cl
	and	eax, 2
	add	eax, edx

; 272  :     }
; 273  : }

	ret	0
SizeFromMemtype ENDP
_TEXT	ENDS
PUBLIC	MemtypeFromSize
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
size$ = 8
ptype$ = 16
MemtypeFromSize PROC NEAR

; 280  :     int i;
; 281  :     for ( i = T_BYTE; SpecialTable[i].type == RWT_STYPE; i++ ) {

	cmp	BYTE PTR SpecialTable+2471, 6
	mov	r9d, 205				; 000000cdH
	jne	SHORT $LN6@MemtypeFro
	lea	r8, OFFSET FLAT:SpecialTable+2470
$LL8@MemtypeFro:

; 282  :         if( ( SpecialTable[i].bytval & MT_SPECIAL ) == 0 ) {

	movzx	eax, BYTE PTR [r8]
	test	al, al
	js	SHORT $LN7@MemtypeFro

; 283  :             /* the size is encoded 0-based in field mem_type */
; 284  : #if AVXSUPP
; 285  :           if (SpecialTable[i].bytval == MT_ZMMWORD){

	cmp	al, 63					; 0000003fH
	jne	SHORT $LN4@MemtypeFro

; 286  :             if (((SpecialTable[i].bytval & 0x3f) + 1) == size) {

	and	eax, 63					; 0000003fH

; 287  :               *ptype = SpecialTable[i].bytval;
; 288  :               return(NOT_ERROR);
; 289  :               }
; 290  :             }
; 291  :             else{

	jmp	SHORT $LN16@MemtypeFro
$LN4@MemtypeFro:

; 292  : #endif
; 293  :               if (((SpecialTable[i].bytval & MT_SIZE_MASK) + 1) == size) {

	and	eax, 31
$LN16@MemtypeFro:
	inc	eax
	cmp	eax, ecx
	je	SHORT $LN13@MemtypeFro
$LN7@MemtypeFro:

; 280  :     int i;
; 281  :     for ( i = T_BYTE; SpecialTable[i].type == RWT_STYPE; i++ ) {

	add	r8, 12
	inc	r9d
	cmp	BYTE PTR [r8+1], 6
	je	SHORT $LL8@MemtypeFro
$LN6@MemtypeFro:

; 296  :                 }
; 297  : #if AVXSUPP
; 298  :               }
; 299  : #endif
; 300  : 
; 301  :         }
; 302  :     }
; 303  :     return( ERROR );

	mov	eax, -1

; 304  : }

	ret	0
$LN13@MemtypeFro:

; 294  :                 *ptype = SpecialTable[i].bytval;

	movsxd	rax, r9d
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rax, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rax+rcx*4+10]
	mov	DWORD PTR [rdx], eax

; 295  :                 return(NOT_ERROR);

	xor	eax, eax

; 304  : }

	ret	0
MemtypeFromSize ENDP
_TEXT	ENDS
PUBLIC	OperandSize
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
opnd$ = 8
CodeInfo$ = 16
OperandSize PROC NEAR

; 309  :     /* v2.0: OP_M8_R8 and OP_M16_R16 have the DFT bit set! */
; 310  :     if( opnd == OP_NONE ) {

	test	ecx, ecx
	mov	r8, rdx

; 311  :         return( 0 );

	je	$LN1@OperandSiz

; 312  :     } else if( opnd == OP_M ) {

	cmp	ecx, -1887436800			; ffffffff8f800000H
	jne	$LN23@OperandSiz

; 313  :         return( SizeFromMemtype( CodeInfo->mem_type, CodeInfo->Ofssize, NULL ) );

	mov	edx, DWORD PTR [rdx+28]
	movzx	r8d, BYTE PTR [r8+106]
	test	dl, dl
	js	SHORT $LN38@OperandSiz
	cmp	edx, 63					; 0000003fH
	jne	SHORT $LN39@OperandSiz
	mov	edx, 64					; 00000040H
	mov	eax, edx

; 350  : }

	ret	0

; 313  :         return( SizeFromMemtype( CodeInfo->mem_type, CodeInfo->Ofssize, NULL ) );

$LN39@OperandSiz:
	and	edx, 31
	inc	edx
	mov	eax, edx

; 350  : }

	ret	0

; 313  :         return( SizeFromMemtype( CodeInfo->mem_type, CodeInfo->Ofssize, NULL ) );

$LN38@OperandSiz:
	cmp	r8d, 254				; 000000feH
	jne	SHORT $LN37@OperandSiz
	movzx	r8d, BYTE PTR ModuleInfo+404
$LN37@OperandSiz:
	add	edx, -128				; ffffffffffffff80H
	je	SHORT $LN32@OperandSiz
	dec	edx
	je	SHORT $LN34@OperandSiz
	dec	edx
	je	SHORT $LN33@OperandSiz
	cmp	edx, 65					; 00000041H
	je	SHORT $LN31@OperandSiz
	xor	edx, edx
	mov	eax, edx

; 350  : }

	ret	0

; 313  :         return( SizeFromMemtype( CodeInfo->mem_type, CodeInfo->Ofssize, NULL ) );

$LN31@OperandSiz:
	mov	ecx, DWORD PTR ModuleInfo+360
	mov	eax, 1
	shl	eax, cl
	and	al, 104					; 00000068H
	neg	al
	sbb	edx, edx
	jmp	SHORT $LN43@OperandSiz
$LN33@OperandSiz:
	mov	ecx, r8d
	mov	edx, 2
	shl	edx, cl
	add	edx, 2
	mov	eax, edx

; 350  : }

	ret	0

; 313  :         return( SizeFromMemtype( CodeInfo->mem_type, CodeInfo->Ofssize, NULL ) );

$LN34@OperandSiz:
	mov	ecx, r8d
	mov	edx, 2
	shl	edx, cl
	mov	eax, edx

; 350  : }

	ret	0

; 313  :         return( SizeFromMemtype( CodeInfo->mem_type, CodeInfo->Ofssize, NULL ) );

$LN32@OperandSiz:
	mov	dl, BYTE PTR ds:55
	shr	edx, 3
$LN43@OperandSiz:
	mov	ecx, r8d
	mov	eax, 2
	and	edx, 2
	shl	eax, cl
	add	edx, eax
	mov	eax, edx

; 350  : }

	ret	0
$LN23@OperandSiz:

; 314  :     } else if( opnd & ( OP_R8 | OP_M08 | OP_I8 ) ) {

	test	ecx, 8519681				; 00820001H
	je	SHORT $LN21@OperandSiz

; 315  :         return( 1 );

	mov	eax, 1

; 350  : }

	ret	0
$LN21@OperandSiz:

; 316  :     } else if( opnd & ( OP_R16 | OP_M16 | OP_I16 | OP_SR ) ) {

	test	ecx, 17063938				; 01046002H
	je	SHORT $LN19@OperandSiz

; 317  :         return( 2 );

	mov	eax, 2

; 350  : }

	ret	0
$LN19@OperandSiz:

; 318  :     } else if( opnd & ( OP_R32 | OP_M32 | OP_I32 ) ) {

	test	ecx, 34078724				; 02080004H
	je	SHORT $LN17@OperandSiz

; 319  :         return( 4 );

	mov	eax, 4

; 350  : }

	ret	0
$LN17@OperandSiz:

; 320  : #if AMD64_SUPPORT
; 321  :     } else if( opnd & ( OP_R64 | OP_M64 | OP_MMX | OP_I64 ) ) {

	test	ecx, 68157464				; 04100018H

; 322  : #else
; 323  :     } else if( opnd & ( OP_M64 | OP_MMX ) ) {
; 324  : #endif
; 325  :         return( 8 );

	jne	SHORT $LN44@OperandSiz

; 326  : //    } else if( opnd & ( OP_I | OP_I48 ) ) {
; 327  :     } else if( opnd & ( OP_I48 | OP_M48 ) ) {

	test	ecx, 1075838976				; 40200000H
	je	SHORT $LN13@OperandSiz

; 328  :         return( 6 );

	mov	eax, 6

; 350  : }

	ret	0
$LN13@OperandSiz:

; 329  :     } else if( opnd & ( OP_STI | OP_M80 ) ) {

	test	ecx, -2147385344			; ffffffff80018000H
	je	SHORT $LN11@OperandSiz

; 330  :         return( 10 );

	mov	eax, 10

; 350  : }

	ret	0
$LN11@OperandSiz:

; 331  :     } else if( opnd & ( OP_XMM | OP_M128 ) ) {

	test	ecx, 134217760				; 08000020H
	je	SHORT $LN9@OperandSiz

; 332  :         return( 16 );

	mov	eax, 16

; 350  : }

	ret	0
$LN9@OperandSiz:

; 333  : #if AVXSUPP
; 334  :     }else if (opnd & (OP_K | OP_M64)) {

	test	ecx, 67108928				; 04000040H
	je	SHORT $LN7@OperandSiz
$LN44@OperandSiz:

; 335  :       return(8);

	mov	eax, 8

; 350  : }

	ret	0
$LN7@OperandSiz:

; 336  :     }else if (opnd & (OP_YMM | OP_M256)) {

	test	ecx, 268435584				; 10000080H
	je	SHORT $LN5@OperandSiz

; 337  :         return( 32 );

	mov	eax, 32					; 00000020H

; 350  : }

	ret	0
$LN5@OperandSiz:

; 338  :     }else if (opnd & (OP_ZMM | OP_M512)) {

	test	ecx, 536871168				; 20000100H
	je	SHORT $LN3@OperandSiz

; 339  :       return(64);

	mov	eax, 64					; 00000040H

; 350  : }

	ret	0
$LN3@OperandSiz:

; 340  : #endif
; 341  :     } else if( opnd & OP_RSPEC ) {

	bt	ecx, 12
	jae	SHORT $LN1@OperandSiz

; 342  : #if AMD64_SUPPORT
; 343  :         return( ( CodeInfo->Ofssize == USE64 ) ? 8 : 4 );

	cmp	BYTE PTR [rdx+106], 2
	mov	eax, 8
	mov	ecx, 4
	cmove	ecx, eax
	mov	eax, ecx

; 350  : }

	ret	0
$LN1@OperandSiz:

; 344  : #else
; 345  :         return( 4 );
; 346  : #endif
; 347  :     }
; 348  :     DebugMsg1(("OperandSize: unhandled operand type %Xh!!!\n", opnd ));
; 349  :     return( 0 );

	xor	eax, eax

; 350  : }

	ret	0
OperandSize ENDP
_TEXT	ENDS
EXTRN	EmitError:NEAR
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
reg1$ = 8
reg2$ = 16
comp_mem16 PROC NEAR

; 359  :     switch( reg1 ) {

	cmp	ecx, 12
	je	SHORT $LN11@comp_mem16
	cmp	ecx, 14
	je	SHORT $LN6@comp_mem16

; 370  :         }
; 371  :         break;
; 372  :     default:
; 373  :         return( EmitError( MULTIPLE_INDEX_REGISTERS_NOT_ALLOWED ) );

	mov	ecx, 34					; 00000022H

; 376  : }

	jmp	EmitError
$LN6@comp_mem16:

; 364  :         }
; 365  :         break;
; 366  :     case T_BP:
; 367  :         switch( reg2 ) {

	sub	edx, 15
	je	SHORT $LN3@comp_mem16
	dec	edx
	jne	SHORT $LN9@comp_mem16

; 369  :         case T_DI: return( RM_BP_DI ); /* 03 */

	lea	eax, QWORD PTR [rdx+3]

; 376  : }

	ret	0
$LN3@comp_mem16:

; 368  :         case T_SI: return( RM_BP_SI ); /* 02 */

	mov	eax, 2

; 376  : }

	ret	0
$LN11@comp_mem16:

; 360  :     case T_BX:
; 361  :         switch( reg2 ) {

	sub	edx, 15
	je	SHORT $LN8@comp_mem16
	dec	edx
	je	SHORT $LN7@comp_mem16
$LN9@comp_mem16:

; 374  :     }
; 375  :     return( EmitError( MULTIPLE_BASE_REGISTERS_NOT_ALLOWED ) );

	mov	ecx, 29

; 376  : }

	jmp	EmitError
$LN7@comp_mem16:

; 363  :         case T_DI: return( RM_BX_DI ); /* 01 */

	mov	eax, 1

; 376  : }

	ret	0
$LN8@comp_mem16:

; 362  :         case T_SI: return( RM_BX_SI ); /* 00 */

	xor	eax, eax

; 376  : }

	ret	0
comp_mem16 ENDP
_TEXT	ENDS
EXTRN	EmitErr:NEAR
EXTRN	SetFixupFrame:NEAR
EXTRN	GetAssume:NEAR
xdata	SEGMENT
$unwind$check_assume DD 071601H
	DD	0b7416H
	DD	0a6411H
	DD	08340cH
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$check_assume DD @imagerel(check_assume#)
	DD	@imagerel(check_assume#+51)
	DD	@imagerel($unwind$check_assume#)
pdata	ENDS
xdata	SEGMENT
$chain$3$check_assume DD 020521H
	DD	095405H
	DD	@imagerel(check_assume#)
	DD	@imagerel(check_assume#+51)
	DD	@imagerel($unwind$check_assume#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$check_assume DD @imagerel(check_assume#+51)
	DD	@imagerel(check_assume#+147)
	DD	@imagerel($chain$3$check_assume#)
pdata	ENDS
xdata	SEGMENT
$chain$4$check_assume DD 021H
	DD	@imagerel(check_assume#)
	DD	@imagerel(check_assume#+51)
	DD	@imagerel($unwind$check_assume#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$check_assume DD @imagerel(check_assume#+147)
	DD	@imagerel(check_assume#+167)
	DD	@imagerel($chain$4$check_assume#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
assume$ = 32
CodeInfo$ = 64
sym$ = 72
default_reg$ = 80
check_assume PROC NEAR

; 385  : {

	sub	rsp, 56					; 00000038H

; 386  :     enum assume_segreg     reg;
; 387  :     struct asym            *assume;
; 388  : 
; 389  :     if( sym && sym->state == SYM_UNDEFINED )

	test	rdx, rdx
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+88], rdi
	mov	rbx, rdx
	mov	rsi, rcx
	mov	edi, r8d
	je	SHORT $LN8@check_assu
	cmp	DWORD PTR [rdx+40], 0
	je	SHORT $LN1@check_assu
$LN8@check_assu:

; 390  :         return;
; 391  : 
; 392  :     reg = GetAssume( SegOverride, sym, default_reg, &assume );

	mov	rcx, QWORD PTR SegOverride
	lea	r9, QWORD PTR assume$[rsp]
	mov	QWORD PTR [rsp+72], rbp
	call	GetAssume

; 393  :     /* set global vars Frame and Frame_Datum */
; 394  :     DebugMsg1(("check_assume(%s): calling SetFixupFrame(%s, FALSE)\n", sym ? sym->name : "NULL", assume ? assume->name : "NULL" ));
; 395  :     SetFixupFrame( assume, FALSE );

	mov	rcx, QWORD PTR assume$[rsp]
	xor	edx, edx
	mov	ebp, eax
	call	SetFixupFrame

; 396  : 
; 397  :     if( reg == ASSUME_NOTHING ) {

	cmp	ebp, -2
	jne	SHORT $LN7@check_assu

; 398  :         if ( sym ) {

	test	rbx, rbx
	je	SHORT $LN6@check_assu

; 399  :             //if( sym->state != SYM_EXTERNAL && sym->state != SYM_STACK ) {
; 400  :             /* v1.95: condition changed. Now there's an error msg only if
; 401  :              * the symbol has an explicite segment.
; 402  :              */
; 403  :             if( sym->segment != NULL ) {

	cmp	QWORD PTR [rbx+32], 0
	je	SHORT $LN5@check_assu

; 404  :                 DebugMsg1(("check_assume: no segment register available to access label %s\n", sym->name ));
; 405  :                 EmitErr( CANNOT_ACCESS_LABEL_THROUGH_SEGMENT_REGISTERS, sym->name );

	mov	rdx, QWORD PTR [rbx+8]
	lea	ecx, QWORD PTR [rbp+91]
	call	EmitErr

; 406  :             } else

	jmp	SHORT $LN11@check_assu
$LN5@check_assu:

; 407  :                 CodeInfo->prefix.RegOverride = default_reg;

	mov	DWORD PTR [rsi+4], edi

; 408  :         } else {

	jmp	SHORT $LN11@check_assu
$LN6@check_assu:

; 409  :             DebugMsg1(("check_assume: no segment register available to access seg-label %s\n", SegOverride->name ));
; 410  :             EmitErr( CANNOT_ACCESS_LABEL_THROUGH_SEGMENT_REGISTERS, SegOverride->name );

	mov	rdx, QWORD PTR SegOverride
	mov	ecx, 89					; 00000059H
	mov	rdx, QWORD PTR [rdx+8]
	call	EmitErr

; 411  :         }

	jmp	SHORT $LN11@check_assu
$LN7@check_assu:

; 412  :     } else if( default_reg != EMPTY ) {

	cmp	edi, -2
	je	SHORT $LN11@check_assu

; 413  :         CodeInfo->prefix.RegOverride = reg;

	mov	DWORD PTR [rsi+4], ebp
$LN11@check_assu:
	mov	rbp, QWORD PTR [rsp+72]
$LN1@check_assu:
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+64]

; 414  :     }
; 415  : }

	add	rsp, 56					; 00000038H
	ret	0
check_assume ENDP
_TEXT	ENDS
EXTRN	GetSymOfssize:NEAR
EXTRN	GetOverrideAssume:NEAR
xdata	SEGMENT
$unwind$seg_override DD 071e01H
	DD	09741eH
	DD	075412H
	DD	06340dH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$seg_override DD @imagerel(seg_override#)
	DD	@imagerel(seg_override#+105)
	DD	@imagerel($unwind$seg_override#)
pdata	ENDS
xdata	SEGMENT
$chain$3$seg_override DD 020521H
	DD	086405H
	DD	@imagerel(seg_override#)
	DD	@imagerel(seg_override#+105)
	DD	@imagerel($unwind$seg_override#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$seg_override DD @imagerel(seg_override#+105)
	DD	@imagerel(seg_override#+355)
	DD	@imagerel($chain$3$seg_override#)
pdata	ENDS
xdata	SEGMENT
$chain$4$seg_override DD 021H
	DD	@imagerel(seg_override#)
	DD	@imagerel(seg_override#+105)
	DD	@imagerel($unwind$seg_override#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$seg_override DD @imagerel(seg_override#+355)
	DD	@imagerel(seg_override#+382)
	DD	@imagerel($chain$4$seg_override#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
CodeInfo$ = 48
seg_reg$ = 56
sym$ = 64
direct$ = 72
seg_override PROC NEAR

; 424  : {

	sub	rsp, 40					; 00000028H

; 425  :     enum assume_segreg  default_seg;
; 426  :     struct asym         *assume;
; 427  : 
; 428  :     /* don't touch segment overrides for string instructions */
; 429  :     //if ( InstrTable[optable_idx[CodeInfo->token]].allowed_prefix == AP_REP ||
; 430  :     //     InstrTable[optable_idx[CodeInfo->token]].allowed_prefix == AP_REPxx )
; 431  :     if ( CodeInfo->pinstr->allowed_prefix == AP_REP ||
; 432  :          CodeInfo->pinstr->allowed_prefix == AP_REPxx )

	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	rbx, rcx
	movzx	ecx, WORD PTR [rax+2]
	mov	QWORD PTR [rsp+72], rdi
	cmp	cx, 2
	movzx	ebp, r9b
	mov	rdi, r8
	je	$LN19@seg_overri
	cmp	cx, 3
	je	$LN19@seg_overri

; 433  :         return;
; 434  : 
; 435  :     if( CodeInfo->token == T_LEA ) {

	cmp	DWORD PTR [rbx+24], 634			; 0000027aH
	jne	SHORT $LN18@seg_overri

; 436  :         CodeInfo->prefix.RegOverride = EMPTY; /* skip segment override */
; 437  :         SetFixupFrame( sym, FALSE );

	xor	edx, edx
	mov	rcx, r8
	mov	DWORD PTR [rbx+4], -2
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 485  :     }
; 486  : }

	add	rsp, 40					; 00000028H
	jmp	SetFixupFrame
$LN18@seg_overri:

; 438  :         return;
; 439  :     }
; 440  : 
; 441  :     switch( seg_reg ) {

	cmp	edx, 14
	mov	QWORD PTR [rsp+64], rsi
	je	SHORT $LN15@seg_overri
	cmp	edx, 20
	jle	SHORT $LN14@seg_overri
	cmp	edx, 22
	jle	SHORT $LN15@seg_overri
$LN14@seg_overri:

; 448  :         break;
; 449  :     default:
; 450  :         default_seg = ASSUME_DS;

	mov	esi, 3
	jmp	SHORT $LN16@seg_overri
$LN15@seg_overri:

; 442  :     //case T_SS: /* doesn't happen */
; 443  :     case T_BP:
; 444  :     case T_EBP:
; 445  :     case T_ESP:
; 446  :         /* todo: check why cases T_RBP/T_RSP aren't needed! */
; 447  :         default_seg = ASSUME_SS;

	mov	esi, 2
$LN16@seg_overri:

; 451  :     }
; 452  : 
; 453  :     if( CodeInfo->prefix.RegOverride != EMPTY ) {

	mov	ecx, DWORD PTR [rbx+4]
	cmp	ecx, -2
	je	$LN13@seg_overri

; 454  :         assume = GetOverrideAssume( CodeInfo->prefix.RegOverride );

	call	GetOverrideAssume

; 455  :         /* assume now holds assumed SEG/GRP symbol */
; 456  :         if ( sym ) {

	test	rdi, rdi
	je	SHORT $LN12@seg_overri

; 457  :             DebugMsg1(("seg_override: sym=%s\n", sym->name ));
; 458  :             SetFixupFrame( assume ? assume : sym, FALSE );

	test	rax, rax
	cmovne	rdi, rax
	xor	edx, edx
	mov	rcx, rdi
	call	SetFixupFrame
	jmp	$LN2@seg_overri
$LN12@seg_overri:

; 459  :         } else if ( direct ) {

	test	bpl, bpl
	je	$LN2@seg_overri

; 460  :             /* no label attached (DS:[0]). No fixup is to be created! */
; 461  :             if ( assume ) {

	test	rax, rax
	je	SHORT $LN9@seg_overri

; 462  :                 DebugMsg1(("seg_override, direct addressing: prefix.adrsiz will be set, assume=%s CI->ofssize=%u\n", assume->name, CodeInfo->Ofssize ));
; 463  :                 CodeInfo->prefix.adrsiz = ADDRSIZE( CodeInfo->Ofssize, GetSymOfssize( assume ) );

	mov	rcx, rax
	call	GetSymOfssize
	and	BYTE PTR [rbx+9], 254			; 000000feH
	movzx	ecx, BYTE PTR [rbx+106]
	xor	ecx, eax
	setne	al
	and	al, 1
	or	BYTE PTR [rbx+9], al

; 464  :                 //DebugMsg1(("seg_override: CI->prefix.adrsiz=%u\n", CodeInfo->prefix.adrsiz ));
; 465  :             } else {

	jmp	SHORT $LN2@seg_overri
$LN9@seg_overri:

; 466  :                 /* v2.01: if -Zm, then use current CS offset size.
; 467  :                  * This isn't how Masm v6 does it, but it matches Masm v5.
; 468  :                  */
; 469  :                 if ( ModuleInfo.m510 )

	test	BYTE PTR ModuleInfo+408, 128		; 00000080H
	je	SHORT $LN7@seg_overri

; 470  :                     CodeInfo->prefix.adrsiz = ADDRSIZE( CodeInfo->Ofssize, ModuleInfo.Ofssize );

	movzx	eax, BYTE PTR [rbx+106]
	xor	al, BYTE PTR ModuleInfo+404
	setne	cl
	xor	cl, BYTE PTR [rbx+9]
	and	cl, 1
	xor	BYTE PTR [rbx+9], cl

; 471  :                 else

	jmp	SHORT $LN2@seg_overri
$LN7@seg_overri:

; 472  :                     CodeInfo->prefix.adrsiz = ADDRSIZE( CodeInfo->Ofssize, ModuleInfo.defOfssize );

	movzx	eax, BYTE PTR [rbx+106]
	xor	al, BYTE PTR ModuleInfo+405
	setne	cl
	xor	cl, BYTE PTR [rbx+9]
	and	cl, 1
	xor	BYTE PTR [rbx+9], cl

; 473  :             }
; 474  :         }
; 475  :     } else {

	jmp	SHORT $LN2@seg_overri
$LN13@seg_overri:

; 476  :         if ( sym || SegOverride )

	test	r8, r8
	jne	SHORT $LN3@seg_overri
	cmp	QWORD PTR SegOverride, r8
	je	SHORT $LN2@seg_overri
$LN3@seg_overri:

; 477  :             check_assume( CodeInfo, sym, default_seg );

	mov	r8d, esi
	mov	rdx, rdi
	mov	rcx, rbx
	call	check_assume

; 478  :         if ( sym == NULL && SegOverride ) {

	test	rdi, rdi
	jne	SHORT $LN2@seg_overri
	mov	rcx, QWORD PTR SegOverride
	test	rcx, rcx
	je	SHORT $LN2@seg_overri

; 479  :             CodeInfo->prefix.adrsiz = ADDRSIZE( CodeInfo->Ofssize, GetSymOfssize( SegOverride ) );

	call	GetSymOfssize
	and	BYTE PTR [rbx+9], 254			; 000000feH
	movzx	ecx, BYTE PTR [rbx+106]
	xor	ecx, eax
	setne	al
	and	al, 1
	or	BYTE PTR [rbx+9], al
$LN2@seg_overri:

; 480  :         }
; 481  :     }
; 482  : 
; 483  :     if( CodeInfo->prefix.RegOverride == default_seg ) {

	cmp	DWORD PTR [rbx+4], esi
	mov	rsi, QWORD PTR [rsp+64]
	jne	SHORT $LN19@seg_overri

; 484  :         CodeInfo->prefix.RegOverride = EMPTY;

	mov	DWORD PTR [rbx+4], -2
$LN19@seg_overri:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 485  :     }
; 486  : }

	add	rsp, 40					; 00000028H
	ret	0
seg_override ENDP
_TEXT	ENDS
PUBLIC	set_frame
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
sym$ = 8
set_frame PROC NEAR

; 498  :     SetFixupFrame( SegOverride ? SegOverride : sym, FALSE );

	mov	rax, QWORD PTR SegOverride
	test	rax, rax
	cmovne	rcx, rax
	xor	edx, edx

; 499  : }

	jmp	SetFixupFrame
set_frame ENDP
_TEXT	ENDS
PUBLIC	set_frame2
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
sym$ = 8
set_frame2 PROC NEAR

; 510  :     SetFixupFrame( SegOverride ? SegOverride : sym, TRUE );

	mov	rax, QWORD PTR SegOverride
	mov	dl, 1
	test	rax, rax
	cmovne	rcx, rax

; 511  : }

	jmp	SetFixupFrame
set_frame2 ENDP
_TEXT	ENDS
EXTRN	__ImageBase:BYTE
xdata	SEGMENT
$unwind$set_rm_sib DD 0113301H
	DD	05f433H
	DD	06e42fH
	DD	07d42bH
	DD	08c427H
	DD	097423H
	DD	0a641fH
	DD	0b5413H
	DD	0c340fH
	DD	0c20bH
xdata	ENDS
pdata	SEGMENT
$pdata$set_rm_sib DD @imagerel(set_rm_sib#)
	DD	@imagerel(set_rm_sib#+1712)
	DD	@imagerel($unwind$set_rm_sib#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
CodeInfo$ = 112
CurrOpnd$ = 120
ss$ = 128
index$ = 136
base$ = 144
sym$ = 152
set_rm_sib PROC NEAR

; 524  : {

	mov	DWORD PTR [rsp+16], edx
	mov	rax, rsp
	sub	rsp, 104				; 00000068H
	mov	QWORD PTR [rax-8], rbx
	mov	QWORD PTR [rax-16], rbp

; 525  :     int                 temp;
; 526  :     unsigned char       mod_field;
; 527  :     unsigned char       rm_field;
; 528  :     unsigned char       base_reg;
; 529  :     unsigned char       idx_reg;
; 530  : #if AMD64_SUPPORT
; 531  :     unsigned char       bit3_base;
; 532  :     unsigned char       bit3_idx;
; 533  :     unsigned char       rex;
; 534  : #endif
; 535  : 
; 536  :     DebugMsg1(("set_rm_sib(scale=%u, index=%d, base=%d, sym=%s) enter [CI.adrsiz=%u]\n", 1 << (ss >> 6), index, base, sym ? sym->name : "NULL", CodeInfo->prefix.adrsiz ));
; 537  : 
; 538  :     /* clear mod */
; 539  :     rm_field = 0;
; 540  :     CodeInfo->basetype = base;

	movsxd	rbp, DWORD PTR base$[rsp]
	mov	QWORD PTR [rax-24], rsi
	mov	QWORD PTR [rax-32], rdi
	mov	QWORD PTR [rax-40], r12
	mov	QWORD PTR [rax-48], r13
	mov	QWORD PTR [rax-56], r14
	mov	QWORD PTR [rax-64], r15
	mov	eax, edx
	mov	BYTE PTR [rcx+108], bpl

; 541  : #if AMD64_SUPPORT
; 542  :     bit3_base = 0;
; 543  :     bit3_idx = 0;
; 544  :     rex = 0;

	xor	r12b, r12b

; 545  : #endif
; 546  :     if( CodeInfo->opnd[CurrOpnd].InsFixup != NULL ) { /* symbolic displacement given? */

	lea	r14, QWORD PTR [rax+rax*2+6]
	movsxd	r13, r9d
	movzx	r15d, r8b
	cmp	QWORD PTR [rcx+r14*8], 0
	mov	rbx, rcx
	mov	edi, edx
	je	SHORT $LN55@set_rm_sib

; 547  :         mod_field = MOD_10;

	mov	sil, 128				; 00000080H
	jmp	SHORT $LN48@set_rm_sib
$LN55@set_rm_sib:

; 548  :     } else if((CodeInfo->opnd[CurrOpnd].data32l == 0) ||( base == T_RIP)) { /* no displacement (or 0) */

	lea	rax, QWORD PTR [rax+rax*2]
	mov	ecx, DWORD PTR [rcx+rax*8+40]
	test	ecx, ecx
	je	SHORT $LN52@set_rm_sib
	cmp	ebp, 131				; 00000083H
	je	SHORT $LN52@set_rm_sib

; 550  :     } else if( ( CodeInfo->opnd[CurrOpnd].data32l > SCHAR_MAX )
; 551  :        || ( CodeInfo->opnd[CurrOpnd].data32l < SCHAR_MIN ) ) {

	cmp	ecx, 127				; 0000007fH
	jg	SHORT $LN49@set_rm_sib
	cmp	ecx, -128				; ffffffffffffff80H
	jl	SHORT $LN49@set_rm_sib

; 554  :         mod_field = MOD_01; /* byte size displacement */

	mov	sil, 64					; 00000040H
	jmp	SHORT $LN48@set_rm_sib
$LN49@set_rm_sib:

; 552  :         mod_field = MOD_10; /* full size displacement */

	mov	sil, 128				; 00000080H

; 553  :     } else {

	jmp	SHORT $LN48@set_rm_sib
$LN52@set_rm_sib:

; 549  :         mod_field = MOD_00;

	xor	sil, sil
$LN48@set_rm_sib:

; 555  :     }
; 556  : 
; 557  :     if( ( index == EMPTY ) && ( base == EMPTY ) ) {

	cmp	r13d, -2
	jne	$LN119@set_rm_sib
	cmp	ebp, r13d
	jne	$LN121@set_rm_sib

; 558  :         /* direct memory.
; 559  :          * clear the rightmost 3 bits
; 560  :          */
; 561  :         CodeInfo->isdirect = TRUE;

	or	BYTE PTR [rbx+142], 2

; 562  :         mod_field = MOD_00;
; 563  : 
; 564  :         /* default is DS:[], DS: segment override is not needed */
; 565  :         seg_override( CodeInfo, T_DS, sym, TRUE );

	mov	rax, QWORD PTR [rbx+16]
	xor	sil, sil
	movzx	ecx, WORD PTR [rax+2]
	cmp	cx, 2
	je	$LN78@set_rm_sib
	cmp	cx, 3
	je	$LN78@set_rm_sib
	cmp	DWORD PTR [rbx+24], 634			; 0000027aH
	jne	SHORT $LN77@set_rm_sib
	mov	rcx, QWORD PTR sym$[rsp]
	xor	edx, edx
	mov	DWORD PTR [rbx+4], r13d
	call	SetFixupFrame
	jmp	$LN78@set_rm_sib
$LN77@set_rm_sib:
	mov	ecx, DWORD PTR [rbx+4]
	cmp	ecx, -2
	je	$LN72@set_rm_sib
	call	GetOverrideAssume
	mov	rcx, QWORD PTR sym$[rsp]
	test	rcx, rcx
	je	SHORT $LN71@set_rm_sib
	test	rax, rax
	cmovne	rcx, rax
	xor	edx, edx
	call	SetFixupFrame
	jmp	$LN61@set_rm_sib
$LN71@set_rm_sib:
	test	rax, rax
	je	SHORT $LN68@set_rm_sib
	mov	rcx, rax
	call	GetSymOfssize
	and	BYTE PTR [rbx+9], 254			; 000000feH
	movzx	ecx, BYTE PTR [rbx+106]
	xor	ecx, eax
	setne	al
	and	al, 1
	or	BYTE PTR [rbx+9], al
	jmp	$LN61@set_rm_sib
$LN68@set_rm_sib:
	test	BYTE PTR ModuleInfo+408, 128		; 00000080H
	je	SHORT $LN66@set_rm_sib
	movzx	eax, BYTE PTR [rbx+106]
	xor	al, BYTE PTR ModuleInfo+404
	setne	cl
	xor	cl, BYTE PTR [rbx+9]
	and	cl, 1
	xor	BYTE PTR [rbx+9], cl
	jmp	SHORT $LN61@set_rm_sib
$LN66@set_rm_sib:
	movzx	eax, BYTE PTR [rbx+106]
	xor	al, BYTE PTR ModuleInfo+405
	setne	cl
	xor	cl, BYTE PTR [rbx+9]
	and	cl, 1
	xor	BYTE PTR [rbx+9], cl
	jmp	SHORT $LN61@set_rm_sib
$LN72@set_rm_sib:
	mov	r13, QWORD PTR sym$[rsp]
	test	r13, r13
	jne	SHORT $LN62@set_rm_sib
	cmp	QWORD PTR SegOverride, r13
	je	SHORT $LN61@set_rm_sib
$LN62@set_rm_sib:
	mov	eax, 3
	mov	rdx, r13
	mov	rcx, rbx
	mov	r8d, eax
	call	check_assume
	test	r13, r13
	jne	SHORT $LN61@set_rm_sib
	mov	rcx, QWORD PTR SegOverride
	test	rcx, rcx
	je	SHORT $LN61@set_rm_sib
	call	GetSymOfssize
	and	BYTE PTR [rbx+9], 254			; 000000feH
	movzx	ecx, BYTE PTR [rbx+106]
	xor	ecx, eax
	setne	al
	and	al, 1
	or	BYTE PTR [rbx+9], al
$LN61@set_rm_sib:
	cmp	DWORD PTR [rbx+4], 3
	jne	SHORT $LN78@set_rm_sib
	mov	DWORD PTR [rbx+4], -2
$LN78@set_rm_sib:

; 566  : 
; 567  :         DebugMsg1(( "set_rm_sib: direct addressing, CI.Ofssize=%u / adrsize=%u / data=%" I32_SPEC "X\n",
; 568  :                    CodeInfo->Ofssize, CodeInfo->prefix.adrsiz, CodeInfo->opnd[CurrOpnd].data32l ));
; 569  :         //if( !IS_ADDR32( CodeInfo ) ) {
; 570  :         if( ( CodeInfo->Ofssize == USE16 && CodeInfo->prefix.adrsiz == 0 ) ||
; 571  :             ( CodeInfo->Ofssize == USE32 && CodeInfo->prefix.adrsiz == 1 )) {

	movzx	eax, BYTE PTR [rbx+106]
	test	al, al
	jne	SHORT $LN44@set_rm_sib
	test	BYTE PTR [rbx+9], 1
	je	SHORT $LN45@set_rm_sib
$LN44@set_rm_sib:
	cmp	al, 1
	jne	SHORT $LN46@set_rm_sib
	test	BYTE PTR [rbx+9], al
	je	SHORT $LN46@set_rm_sib
$LN45@set_rm_sib:

; 572  :             if( !InWordRange( CodeInfo->opnd[CurrOpnd].data32l ) ) {

	lea	rax, QWORD PTR [rdi+rdi*2]
	mov	ecx, DWORD PTR [rbx+rax*8+40]
	cmp	ecx, 65535				; 0000ffffH
	jg	SHORT $LN58@set_rm_sib
	cmp	ecx, -65535				; ffffffffffff0001H
	jge	SHORT $LN43@set_rm_sib
$LN58@set_rm_sib:

; 573  :                 /* expect 16-bit but got 32-bit address */
; 574  :                 DebugMsg1(( "set_rm_sib: error, Ofssize=%u, adrsize=%u, data=%" I32_SPEC "X\n",
; 575  :                         CodeInfo->Ofssize, CodeInfo->prefix.adrsiz, CodeInfo->opnd[CurrOpnd].data32l ));
; 576  :                 return( EmitError( MAGNITUDE_OF_OFFSET_EXCEEDS_16BIT ) );

	mov	ecx, 58					; 0000003aH
	call	EmitError
	jmp	$LN56@set_rm_sib
$LN43@set_rm_sib:

; 577  :             }
; 578  :             rm_field = RM_D16; /* D16=110b */

	mov	dil, 6

; 579  :         } else {

	jmp	$LN15@set_rm_sib
$LN46@set_rm_sib:

; 580  :             rm_field = RM_D32; /* D32=101b */
; 581  : #if AMD64_SUPPORT
; 582  :             /* v2.03: the non-RIP encoding for 64bit uses a redundant SIB mode (base=none, index=none) */
; 583  :             /* v2.11: always use 64-bit non-RIP addressing if no fixup has been created. */
; 584  :             //if ( CodeInfo->Ofssize == USE64 && CodeInfo->prefix.RegOverride != EMPTY && SegOverride != &ModuleInfo.flat_grp->sym ) {
; 585  :             if ( CodeInfo->Ofssize == USE64 && CodeInfo->opnd[CurrOpnd].InsFixup == NULL ) {

	cmp	al, 2
	mov	dil, 5
	jne	$LN15@set_rm_sib
	cmp	QWORD PTR [rbx+r14*8], 0
	jne	$LN15@set_rm_sib

; 586  :                 DebugMsg1(( "set_rm_sib: 64-bit, no fixup, data64=%" I64_SPEC "X\n", CodeInfo->opnd[CurrOpnd].data64 ));
; 587  :                 rm_field = RM_SIB;

	mov	dil, 4

; 588  :                 CodeInfo->sib = 0x25; /* IIIBBB, base=101b, index=100b */

	mov	BYTE PTR [rbx+105], 37			; 00000025H

; 589  :             }
; 590  : #endif
; 591  :         }

	jmp	$LN15@set_rm_sib
$LN121@set_rm_sib:

; 592  :         DebugMsg1(("set_rm_sib, direct, CodeInfo->prefix.adrsiz=%u\n", CodeInfo->prefix.adrsiz ));
; 593  :     } else if( ( index == EMPTY ) && ( base != EMPTY ) ) {
; 594  :         /* for SI, DI and BX: default is DS:[],
; 595  :          * DS: segment override is not needed
; 596  :          * for BP: default is SS:[], SS: segment override is not needed
; 597  :          */
; 598  :         switch( base ) {

	mov	ecx, ebp
	sub	ecx, 12
	je	SHORT $LN31@set_rm_sib
	sub	ecx, 2
	je	SHORT $LN34@set_rm_sib
	dec	ecx
	je	SHORT $LN36@set_rm_sib
	dec	ecx
	je	SHORT $LN35@set_rm_sib

; 613  :             break;
; 614  :         default: /* for 386 and up */
; 615  :             base_reg = GetRegNo( base );

	lea	rcx, QWORD PTR [rbp+rbp*2]
	lea	r8, OFFSET FLAT:__ImageBase

; 616  : #if AMD64_SUPPORT
; 617  :             if (base_reg == 16)

	mov	r9d, 5
	movzx	eax, BYTE PTR SpecialTable[r8+rcx*4+10]
	cmp	al, 16
	mov	edi, eax
	cmove	edi, r9d

; 618  :                base_reg=5;  //RIP bytval=16 but we need 5 added by habran
; 619  :             bit3_base = base_reg >> 3;

	movzx	r12d, dil

; 620  :             base_reg &= BIT_012;

	and	dil, 7
	shr	r12b, 3

; 621  : #endif
; 622  :             rm_field = base_reg;
; 623  :             DebugMsg1(("set_rm_sib: base_reg is %u\n", base_reg ));
; 624  :             if ( base_reg == 4 ) {

	cmp	dil, 4
	jne	SHORT $LN28@set_rm_sib

; 625  :                 /* 4 is RSP/ESP or R12/R12D, which must use SIB encoding.
; 626  :                  * SSIIIBBB, ss = 00, index = 100b ( no index ), base = 100b ( ESP ) */
; 627  :                 CodeInfo->sib = 0x24;

	mov	BYTE PTR [rbx+105], 36			; 00000024H
	jmp	SHORT $LN37@set_rm_sib
$LN28@set_rm_sib:

; 628  :             } else if ( base_reg == 5 && mod_field == MOD_00 ) {

	cmp	dil, r9b
	jne	SHORT $LN37@set_rm_sib
	test	sil, sil
	jne	SHORT $LN37@set_rm_sib

; 629  :                 /* 5 is [E|R]BP or R13[D]. Needs displacement */
; 630  :                // 5 is also RIP register but doesn't need MOD_01
; 631  :                 if (base != T_RIP)  //added by habran

	movzx	esi, sil
	mov	ecx, 64					; 00000040H
	cmp	ebp, 131				; 00000083H
	cmovne	esi, ecx

; 632  :                  mod_field = MOD_01; /* byte size displacement */
; 633  :             }
; 634  : #if AMD64_SUPPORT
; 635  :             /* v2.02 */
; 636  :             //rex = ( bit3_base << 2 ); /* set REX_R */
; 637  :             rex = bit3_base; /* set REX_R */

	jmp	SHORT $LN37@set_rm_sib
$LN35@set_rm_sib:

; 602  :         case T_DI:
; 603  :             rm_field = RM_DI; /* 5 */

	mov	dil, 5

; 604  :             break;

	jmp	SHORT $LN37@set_rm_sib
$LN36@set_rm_sib:

; 599  :         case T_SI:
; 600  :             rm_field = RM_SI; /* 4 */

	mov	dil, 4

; 601  :             break;

	jmp	SHORT $LN37@set_rm_sib
$LN34@set_rm_sib:

; 605  :         case T_BP:
; 606  :             rm_field = RM_BP; /* 6 */
; 607  :             if( mod_field == MOD_00 ) {

	test	sil, sil
	mov	dil, 6
	jne	SHORT $LN37@set_rm_sib

; 608  :                if (base != T_RIP) mod_field = MOD_01;

	mov	sil, 64					; 00000040H

; 609  :             }
; 610  :             break;

	jmp	SHORT $LN37@set_rm_sib
$LN31@set_rm_sib:

; 611  :         case T_BX:
; 612  :             rm_field = RM_BX; /* 7 */

	mov	dil, 7
$LN37@set_rm_sib:

; 638  : #endif
; 639  :         }
; 640  : #if AMD64_SUPPORT
; 641  :         DebugMsg1(("set_rm_sib, indirect with base, mod_field=%X, rm_field=%X, rex=%X\n", mod_field, rm_field, rex ));
; 642  : #else
; 643  :         DebugMsg1(("set_rm_sib, indirect with base, rm_field=%X\n", rm_field ));
; 644  : #endif
; 645  :         seg_override( CodeInfo, base, sym, FALSE );

	mov	r8, QWORD PTR sym$[rsp]
	xor	r9d, r9d
	mov	edx, ebp
	mov	rcx, rbx
	call	seg_override
	jmp	$LN15@set_rm_sib
$LN119@set_rm_sib:

; 646  :     } else if( ( index != EMPTY ) && ( base == EMPTY ) ) {

	cmp	ebp, -2
	jne	$LN23@set_rm_sib

; 647  :         idx_reg = GetRegNo( index );

	lea	rcx, QWORD PTR [r13+r13*2]
	lea	r8, OFFSET FLAT:__ImageBase

; 648  : #if AVXSUPP
; 649  :         CodeInfo->indextype = GetValueSp( index );
; 650  : #endif
; 651  : #if AMD64_SUPPORT
; 652  :         bit3_idx = idx_reg >> 3;
; 653  :         idx_reg &= BIT_012;
; 654  : #endif
; 655  :         /* mod field is 00 */
; 656  :         mod_field = MOD_00;

	xor	sil, sil
	movzx	edx, BYTE PTR SpecialTable[r8+rcx*4+10]
	mov	eax, DWORD PTR SpecialTable[r8+rcx*4]

; 657  :         /* s-i-b is present ( r/m = 100b ) */
; 658  :         rm_field = RM_SIB;

	mov	dil, 4
	mov	r12b, dl

; 659  :         /* scale factor, index, base ( 0x05 => no base reg ) */
; 660  :         CodeInfo->sib = ( ss | ( idx_reg << 3 ) | 0x05 );

	and	dl, 7
	mov	DWORD PTR [rbx+132], eax

; 661  : #if AMD64_SUPPORT
; 662  :         rex = (bit3_idx << 1); /* set REX_X */
; 663  : #endif
; 664  :         /* default is DS:[], DS: segment override is not needed */
; 665  :         seg_override( CodeInfo, T_DS, sym, FALSE );

	mov	rax, QWORD PTR [rbx+16]
	shl	dl, 3
	shr	r12b, 3
	or	dl, r15b
	add	r12b, r12b
	or	dl, 5
	mov	BYTE PTR [rbx+105], dl
	movzx	ecx, WORD PTR [rax+2]
	cmp	cx, 2
	je	$LN15@set_rm_sib
	cmp	cx, 3
	je	$LN15@set_rm_sib
	cmp	DWORD PTR [rbx+24], 634			; 0000027aH
	jne	SHORT $LN99@set_rm_sib
	mov	rcx, QWORD PTR sym$[rsp]
	xor	edx, edx
	mov	DWORD PTR [rbx+4], ebp
	call	SetFixupFrame
	jmp	$LN15@set_rm_sib
$LN99@set_rm_sib:
	mov	ecx, DWORD PTR [rbx+4]
	cmp	ecx, -2
	je	SHORT $LN94@set_rm_sib
	call	GetOverrideAssume
	mov	rcx, QWORD PTR sym$[rsp]
	test	rcx, rcx
	je	SHORT $LN83@set_rm_sib
	test	rax, rax
	cmovne	rcx, rax
	xor	edx, edx
	call	SetFixupFrame
	jmp	SHORT $LN83@set_rm_sib
$LN94@set_rm_sib:
	mov	r13, QWORD PTR sym$[rsp]
	test	r13, r13
	jne	SHORT $LN84@set_rm_sib
	cmp	QWORD PTR SegOverride, r13
	je	SHORT $LN83@set_rm_sib
$LN84@set_rm_sib:
	mov	r8d, 3
	mov	rdx, r13
	mov	rcx, rbx
	call	check_assume
	test	r13, r13
	jne	SHORT $LN83@set_rm_sib
	mov	rcx, QWORD PTR SegOverride
	test	rcx, rcx
	je	SHORT $LN83@set_rm_sib
	call	GetSymOfssize
	and	BYTE PTR [rbx+9], 254			; 000000feH
	movzx	ecx, BYTE PTR [rbx+106]
	xor	ecx, eax
	setne	al
	and	al, 1
	or	BYTE PTR [rbx+9], al
$LN83@set_rm_sib:
	cmp	DWORD PTR [rbx+4], 3
	jne	$LN15@set_rm_sib
	mov	DWORD PTR [rbx+4], -2

; 666  :     } else {

	jmp	$LN15@set_rm_sib
$LN23@set_rm_sib:

; 667  :         /* base != EMPTY && index != EMPTY */
; 668  :         base_reg = GetRegNo( base );

	lea	r8, OFFSET FLAT:__ImageBase
	lea	rcx, QWORD PTR [rbp+rbp*2]

; 669  :         idx_reg  = GetRegNo( index );

	lea	r11, QWORD PTR [r13+r13*2]
	movzx	edx, BYTE PTR SpecialTable[r8+r11*4+10]

; 670  :         if ( base == T_RIP)

	movzx	r10d, BYTE PTR SpecialTable[r8+rcx*4+10]

; 671  :           base_reg = 0x5;
; 672  : #if AMD64_SUPPORT
; 673  :         bit3_base = base_reg >> 3;
; 674  :         bit3_idx  = idx_reg  >> 3;
; 675  :         base_reg &= BIT_012;
; 676  :         idx_reg  &= BIT_012;
; 677  : #endif
; 678  :         if ( ( GetSflagsSp( base ) & GetSflagsSp( index ) & SFR_SIZMSK ) == 0 ) {

	mov	eax, DWORD PTR SpecialTable[r8+r11*4+4]
	mov	r9d, 5
	cmp	ebp, 131				; 00000083H
	movzx	r14d, dl
	cmove	r10d, r9d
	and	eax, DWORD PTR SpecialTable[r8+rcx*4+4]
	shr	r14b, 3
	movzx	r9d, r10b
	and	r10b, 7
	and	dl, 7
	shr	r9b, 3
	test	al, 31
	jne	SHORT $LN18@set_rm_sib

; 679  : #if AVXSUPP
; 680  :            CodeInfo->indextype = GetValueSp( index );

	mov	eax, DWORD PTR SpecialTable[r8+r11*4]

; 681  :            if (CodeInfo->indextype == OP_XMM || CodeInfo->indextype == OP_YMM || CodeInfo->indextype == OP_ZMM){

	cmp	eax, 32					; 00000020H
	mov	DWORD PTR [rbx+132], eax
	je	SHORT $LN18@set_rm_sib
	cmp	eax, 128				; 00000080H
	je	SHORT $LN18@set_rm_sib
	cmp	eax, 256				; 00000100H
	je	SHORT $LN18@set_rm_sib

; 682  :              ;
; 683  :            }
; 684  :           else
; 685  : #endif
; 686  :           return( EmitError( CANNOT_MIX_16_AND_32_BIT_REGISTERS ) );

	mov	ecx, 38					; 00000026H
	call	EmitError
	jmp	$LN56@set_rm_sib
$LN18@set_rm_sib:

; 687  :         }
; 688  :   
; 689  :         switch( index ) {

	lea	eax, DWORD PTR [r13-12]
	cmp	eax, 119				; 00000077H
	ja	$LN9@set_rm_sib
	cdqe
	movzx	eax, BYTE PTR $LN128@set_rm_sib[r8+rax]
	mov	ecx, DWORD PTR $LN129@set_rm_sib[r8+rax*4]
	add	rcx, r8
	jmp	rcx
$LN14@set_rm_sib:

; 690  :         case T_BX:
; 691  :         case T_BP:
; 692  :             if( ( temp = comp_mem16( index, base ) ) == ERROR )

	cmp	r13d, 12
	je	SHORT $LN114@set_rm_sib
	cmp	r13d, 14
	je	SHORT $LN109@set_rm_sib
	mov	ecx, 34					; 00000022H
	call	EmitError
$LN117@set_rm_sib:
	cmp	eax, -1

; 693  :                 return( ERROR );

	je	SHORT $LN130@set_rm_sib
$LN13@set_rm_sib:

; 694  :             rm_field = temp;
; 695  :             seg_override( CodeInfo, index, sym, FALSE );

	mov	r8, QWORD PTR sym$[rsp]
	xor	r9d, r9d
	mov	edx, r13d
	mov	rcx, rbx
	mov	dil, al
	call	seg_override

; 696  :             break;

	jmp	$LN15@set_rm_sib

; 690  :         case T_BX:
; 691  :         case T_BP:
; 692  :             if( ( temp = comp_mem16( index, base ) ) == ERROR )

$LN109@set_rm_sib:
	mov	ecx, ebp
	sub	ecx, 15
	je	SHORT $LN106@set_rm_sib
	dec	ecx
	jne	SHORT $LN112@set_rm_sib
	lea	eax, QWORD PTR [rcx+3]
	jmp	SHORT $LN13@set_rm_sib
$LN106@set_rm_sib:
	mov	eax, 2
	jmp	SHORT $LN13@set_rm_sib
$LN114@set_rm_sib:
	mov	ecx, ebp
	sub	ecx, 15
	je	SHORT $LN111@set_rm_sib
	dec	ecx
	je	SHORT $LN110@set_rm_sib
$LN112@set_rm_sib:
	mov	ecx, 29
	call	EmitError
	jmp	SHORT $LN117@set_rm_sib
$LN110@set_rm_sib:
	mov	eax, 1
	jmp	SHORT $LN13@set_rm_sib
$LN111@set_rm_sib:
	xor	eax, eax
	jmp	SHORT $LN13@set_rm_sib
$LN12@set_rm_sib:

; 697  :         case T_SI:
; 698  :         case T_DI:
; 699  :             if( ( temp = comp_mem16( base, index ) ) == ERROR )

	mov	edx, r13d
	mov	ecx, ebp
	call	comp_mem16
	cmp	eax, -1
	jne	SHORT $LN11@set_rm_sib
$LN130@set_rm_sib:

; 700  :                 return( ERROR );

	mov	eax, -1
	jmp	$LN56@set_rm_sib
$LN11@set_rm_sib:

; 701  :             rm_field = temp;
; 702  :             seg_override( CodeInfo, base, sym, FALSE );

	mov	r8, QWORD PTR sym$[rsp]
	xor	r9d, r9d
	mov	edx, ebp
	mov	rcx, rbx
	mov	dil, al
	call	seg_override

; 703  :             break;

	jmp	SHORT $LN15@set_rm_sib
$LN10@set_rm_sib:

; 704  : #if AMD64_SUPPORT
; 705  :         case T_RSP:
; 706  :         case T_RIP:      //added by habran
; 707  : #endif
; 708  :         case T_ESP:
; 709  :             //EmitErr( CANNOT_BE_USED_AS_INDEX_REGISTER, ??? );
; 710  :             return( EmitError( INVALID_USE_OF_REGISTER ) );

	mov	ecx, 170				; 000000aaH
	call	EmitError
	jmp	$LN56@set_rm_sib
$LN9@set_rm_sib:

; 711  :         default:
; 712  :             if( base_reg == 5 ) { /* v2.03: EBP/RBP/R13/R13D? */

	cmp	r10b, 5
	jne	SHORT $LN6@set_rm_sib

; 713  :                 if( mod_field == MOD_00 ) {

	test	sil, sil
	jne	SHORT $LN6@set_rm_sib

; 714  :                     if (base != T_RIP) mod_field = MOD_01;     //ADDED BY HABRAN

	movzx	esi, sil
	mov	ecx, 64					; 00000040H
	cmp	ebp, 131				; 00000083H
	cmovne	esi, ecx
$LN6@set_rm_sib:

; 715  :                 }
; 716  :             }
; 717  : 
; 718  :             /* s-i-b is present ( r/m = 100b ) */
; 719  :             rm_field |= RM_SIB;
; 720  :             CodeInfo->sib = ( ss | idx_reg << 3 | base_reg );
; 721  : #if AMD64_SUPPORT
; 722  :             rex = (bit3_idx << 1) + (bit3_base); /* set REX_X + REX_B */
; 723  : #endif
; 724  :             seg_override( CodeInfo, base, sym, FALSE );

	mov	r8, QWORD PTR sym$[rsp]
	shl	dl, 3
	mov	r12b, r14b
	or	dl, r10b
	add	r12b, r12b
	mov	rcx, rbx
	or	dl, r15b
	add	r12b, r9b
	xor	r9d, r9d
	mov	BYTE PTR [rbx+105], dl
	mov	edx, ebp
	mov	dil, 4
	call	seg_override
$LN15@set_rm_sib:

; 725  :         } /* end switch(index) */
; 726  : #if AMD64_SUPPORT
; 727  :         DebugMsg1(("set_rm_sib, indirect, base+index: mod_field=%X, rm_field=%X, rex=%X\n", mod_field, rm_field, rex ));
; 728  : #else
; 729  :         DebugMsg1(("set_rm_sib, indirect, base+index: rm_field=%X\n", rm_field ));
; 730  : #endif
; 731  :     }
; 732  :     if( CurrOpnd == OPND2 ) {

	mov	eax, DWORD PTR CurrOpnd$[rsp]
	cmp	eax, 1
	jne	SHORT $LN5@set_rm_sib

; 733  :         /* shift the register field to left by 3 bit */
; 734  :        if ( base == T_RIP )      //added by habran

	cmp	ebp, 131				; 00000083H
	jne	SHORT $LN4@set_rm_sib

; 735  :           mod_field &= BIT_012;

	and	sil, 7
$LN4@set_rm_sib:

; 736  :           CodeInfo->rm_byte = mod_field | ( rm_field << 3 ) | ( CodeInfo->rm_byte & BIT_012 );

	and	BYTE PTR [rbx+104], 7

; 737  : 
; 738  : #if AMD64_SUPPORT
; 739  :         /* v2.02: exchange B and R, keep X */
; 740  :         //CodeInfo->prefix.rex |= (rex >> 2 );
; 741  :         CodeInfo->prefix.rex |= ( ( rex >> 2 ) | ( rex & REX_X ) | (( rex & 1) << 2 ) );

	movzx	ecx, r12b
	movzx	eax, r12b
	and	cl, 1
	shr	al, 2
	shl	dil, 3
	shl	cl, 2
	and	r12b, 2
	or	dil, sil
	or	BYTE PTR [rbx+104], dil
	or	cl, al
	or	cl, r12b
	or	BYTE PTR [rbx+8], cl
	jmp	SHORT $LN2@set_rm_sib
$LN5@set_rm_sib:

; 742  : #endif
; 743  :     } else if( CurrOpnd == OPND1 ) {

	test	eax, eax
	jne	SHORT $LN2@set_rm_sib

; 744  :        if ( base == T_RIP )     //added by habran

	cmp	ebp, 131				; 00000083H
	jne	SHORT $LN1@set_rm_sib

; 745  :           mod_field &= BIT_012;

	and	sil, 7
$LN1@set_rm_sib:

; 746  :         CodeInfo->rm_byte = mod_field | rm_field;

	or	sil, dil

; 747  : #if AMD64_SUPPORT
; 748  :         CodeInfo->prefix.rex |= rex;

	or	BYTE PTR [rbx+8], r12b
	mov	BYTE PTR [rbx+104], sil
$LN2@set_rm_sib:

; 749  : #endif
; 750  :     }
; 751  :     return( NOT_ERROR );

	xor	eax, eax
$LN56@set_rm_sib:
	mov	r15, QWORD PTR [rsp+40]
	mov	r14, QWORD PTR [rsp+48]
	mov	r13, QWORD PTR [rsp+56]
	mov	r12, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+96]

; 752  : }

	add	rsp, 104				; 00000068H
	ret	0
	npad	1
$LN129@set_rm_sib:
	DD	$LN14@set_rm_sib
	DD	$LN12@set_rm_sib
	DD	$LN10@set_rm_sib
	DD	$LN9@set_rm_sib
$LN128@set_rm_sib:
	DB	0
	DB	3
	DB	0
	DB	1
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
set_rm_sib ENDP
_TEXT	ENDS
PUBLIC	segm_override
EXTRN	SymFind:NEAR
EXTRN	SegAssumeTable:BYTE
_BSS	SEGMENT
LastRegOverride DD 01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$segm_override DD 051201H
	DD	097412H
	DD	08340dH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$segm_override DD @imagerel($LN11#)
	DD	@imagerel($LN11#+218)
	DD	@imagerel($unwind$segm_override#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
opndx$ = 48
CodeInfo$ = 56
segm_override PROC NEAR

; 766  : {

$LN11:
	sub	rsp, 40					; 00000028H

; 767  :     struct asym      *sym;
; 768  : 
; 769  :     if( opndx->override != NULL ) {

	mov	rcx, QWORD PTR [rcx+48]
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	test	rcx, rcx
	mov	rbx, rdx
	je	$LN2@segm_overr

; 770  :         if( opndx->override->token == T_REG ) {

	cmp	BYTE PTR [rcx], 2
	jne	$LN7@segm_overr

; 771  :             int temp = GetRegNo( opndx->override->tokval );

	mov	eax, DWORD PTR [rcx+16]
	lea	rdx, OFFSET FLAT:__ImageBase
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	edi, BYTE PTR SpecialTable[rdx+rcx*4+10]

; 772  :             if ( SegAssumeTable[temp].error ) {

	mov	rax, rdi
	add	rax, rax
	cmp	BYTE PTR SegAssumeTable[rdx+rax*8+8], 0
	je	SHORT $LN6@segm_overr

; 773  :                 DebugMsg(("segm_override: assume error, reg=%u\n", temp ));
; 774  :                 return( EmitError( USE_OF_REGISTER_ASSUMED_TO_ERROR ) );

	mov	ecx, 183				; 000000b7H
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 795  : }

	add	rsp, 40					; 00000028H
	jmp	EmitError
$LN6@segm_overr:

; 775  :             }
; 776  : #if AMD64_SUPPORT
; 777  :             /* ES,CS,SS and DS overrides are invalid in 64-bit */
; 778  :             if ( CodeInfo && CodeInfo->Ofssize == USE64 && temp < ASSUME_FS ) {

	test	rbx, rbx
	je	SHORT $LN5@segm_overr
	cmp	BYTE PTR [rbx+106], 2
	jne	SHORT $LN5@segm_overr
	cmp	edi, 4
	jge	SHORT $LN5@segm_overr

; 779  :                 return( EmitError( ILLEGAL_USE_OF_SEGMENT_REGISTER ) );

	mov	ecx, 275				; 00000113H
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 795  : }

	add	rsp, 40					; 00000028H
	jmp	EmitError
$LN5@segm_overr:

; 780  :             }
; 781  : #endif
; 782  :             sym = GetOverrideAssume( temp );

	mov	ecx, edi
	call	GetOverrideAssume

; 783  :             if ( CodeInfo ) {

	test	rbx, rbx
	je	SHORT $LN3@segm_overr

; 784  :                 /* hack: save the previous reg override value (needed for CMPS) */
; 785  :                 LastRegOverride = CodeInfo->prefix.RegOverride;

	mov	ecx, DWORD PTR [rbx+4]

; 786  :                 CodeInfo->prefix.RegOverride = temp;

	mov	DWORD PTR [rbx+4], edi
	mov	DWORD PTR LastRegOverride, ecx

; 787  :             }
; 788  :         } else {

	jmp	SHORT $LN3@segm_overr
$LN7@segm_overr:

; 789  :             sym = SymSearch( opndx->override->string_ptr );

	mov	rcx, QWORD PTR [rcx+8]
	call	SymFind
$LN3@segm_overr:

; 790  :         }
; 791  :         if ( sym && ( sym->state == SYM_GRP || sym->state == SYM_SEG ))

	test	rax, rax
	je	SHORT $LN2@segm_overr
	mov	ecx, DWORD PTR [rax+40]
	cmp	ecx, 4
	je	SHORT $LN1@segm_overr
	cmp	ecx, 3
	jne	SHORT $LN2@segm_overr
$LN1@segm_overr:

; 792  :             SegOverride = sym;

	mov	QWORD PTR SegOverride, rax
$LN2@segm_overr:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 793  :     }
; 794  :     return( NOT_ERROR );

	xor	eax, eax

; 795  : }

	add	rsp, 40					; 00000028H
	ret	0
segm_override ENDP
_TEXT	ENDS
EXTRN	EmitConstError:NEAR
EXTRN	process_branch:NEAR
xdata	SEGMENT
$unwind$idata_nofixup DD 030c01H
	DD	09740cH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$idata_nofixup DD @imagerel(idata_nofixup#)
	DD	@imagerel(idata_nofixup#+50)
	DD	@imagerel($unwind$idata_nofixup#)
pdata	ENDS
xdata	SEGMENT
$chain$1$idata_nofixup DD 020521H
	DD	086405H
	DD	@imagerel(idata_nofixup#)
	DD	@imagerel(idata_nofixup#+50)
	DD	@imagerel($unwind$idata_nofixup#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$idata_nofixup DD @imagerel(idata_nofixup#+50)
	DD	@imagerel(idata_nofixup#+94)
	DD	@imagerel($chain$1$idata_nofixup#)
pdata	ENDS
xdata	SEGMENT
$chain$4$idata_nofixup DD 040521H
	DD	063405H
	DD	086400H
	DD	@imagerel(idata_nofixup#)
	DD	@imagerel(idata_nofixup#+50)
	DD	@imagerel($unwind$idata_nofixup#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$idata_nofixup DD @imagerel(idata_nofixup#+94)
	DD	@imagerel(idata_nofixup#+203)
	DD	@imagerel($chain$4$idata_nofixup#)
pdata	ENDS
xdata	SEGMENT
$chain$8$idata_nofixup DD 080f21H
	DD	04c40fH
	DD	07540aH
	DD	086400H
	DD	063400H
	DD	@imagerel(idata_nofixup#)
	DD	@imagerel(idata_nofixup#+50)
	DD	@imagerel($unwind$idata_nofixup#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$idata_nofixup DD @imagerel(idata_nofixup#+203)
	DD	@imagerel(idata_nofixup#+687)
	DD	@imagerel($chain$8$idata_nofixup#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
CodeInfo$ = 48
CurrOpnd$ = 56
opndx$ = 64
idata_nofixup PROC NEAR

; 808  : {

	sub	rsp, 40					; 00000028H

; 809  :     enum operand_type op_type;
; 810  :     int_32      value;
; 811  :     int         size;
; 812  : 
; 813  :     DebugMsg1(("idata_nofixup( CurrOpnd=%u ) enter [opnd kind=%u mem_type=%Xh value=%" I64_SPEC "X]\n", CurrOpnd, opndx->kind, opndx->mem_type, opndx->value64));
; 814  : 
; 815  :     /* jmp/call/jxx/loop/jcxz/jecxz? */
; 816  :     if( IS_ANY_BRANCH( CodeInfo->token ) ) {

	mov	eax, DWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+72], rdi
	mov	r9, rcx
	cmp	eax, 455				; 000001c7H
	mov	edi, edx
	jl	SHORT $LN34@idata_nofi
	cmp	eax, 504				; 000001f8H
	jg	SHORT $LN34@idata_nofi

; 817  :         return( process_branch( CodeInfo, CurrOpnd, opndx ) );

	mov	edx, edi
	mov	rdi, QWORD PTR [rsp+72]

; 935  : }

	add	rsp, 40					; 00000028H
	jmp	process_branch
$LN34@idata_nofi:

; 818  :     }
; 819  :     value = opndx->value;

	mov	r11d, DWORD PTR [r8]
	mov	QWORD PTR [rsp+64], rsi

; 820  :     CodeInfo->opnd[CurrOpnd].data32l = value;

	lea	rsi, QWORD PTR [rdi+rdi*2]
	mov	DWORD PTR [rcx+rsi*8+40], r11d

; 821  : 
; 822  : #if AMD64_SUPPORT
; 823  :     /* 64bit immediates are restricted to MOV <reg>,<imm64>
; 824  :      */
; 825  :     if ( opndx->hlvalue != 0 ) { /* magnitude > 64 bits? */

	cmp	QWORD PTR [r8+8], 0
	je	SHORT $LN33@idata_nofi

; 826  :         DebugMsg1(("idata_nofixup: error, hlvalue=%" I64_SPEC "X\n", opndx->hlvalue ));
; 827  :         return( EmitConstError( opndx ) );

	mov	rcx, r8
	call	EmitConstError
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]

; 935  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN33@idata_nofi:
	mov	QWORD PTR [rsp+48], rbx

; 828  :     }
; 829  :     /* v2.03: handle QWORD type coercion here as well!
; 830  :      * This change also reveals an old problem in the expression evaluator:
; 831  :      * the mem_type field is set whenever a (simple) type token is found.
; 832  :      * It should be set ONLY when the type is used in conjuction with the
; 833  :      * PTR operator!
; 834  :      * current workaround: query the 'explicit' flag.
; 835  :      */
; 836  :     //if ( opndx->value64 <= minintvalues[0] || opndx->value64 > maxintvalues[0] ) {
; 837  :     /* use long format of MOV for 64-bit if value won't fit in a signed DWORD */
; 838  :     if ( CodeInfo->Ofssize == USE64 &&
; 839  :         CodeInfo->token == T_MOV &&
; 840  :         CurrOpnd == OPND2 &&
; 841  :         ( CodeInfo->opnd[OPND1].type & OP_R64 ) &&
; 842  :         ( opndx->value64 > LONG_MAX || opndx->value64 < LONG_MIN ||
; 843  :          (opndx->explicit && ( opndx->mem_type == MT_QWORD || opndx->mem_type == MT_SQWORD ) ) ) ) {

	movzx	ebx, BYTE PTR [rcx+106]
	cmp	bl, 2
	jne	SHORT $LN32@idata_nofi
	cmp	DWORD PTR [rcx+24], 606			; 0000025eH
	jne	SHORT $LN32@idata_nofi
	cmp	edi, 1
	jne	SHORT $LN32@idata_nofi
	test	BYTE PTR [rcx+32], 8
	je	SHORT $LN32@idata_nofi
	mov	rax, QWORD PTR [r8]
	cmp	rax, 2147483647				; 7fffffffH
	jg	SHORT $LN30@idata_nofi
	cmp	rax, -2147483648			; ffffffff80000000H
	jl	SHORT $LN30@idata_nofi
	test	BYTE PTR [r8+72], bl
	je	SHORT $LN32@idata_nofi
	mov	eax, DWORD PTR [r8+64]
	cmp	eax, 7
	je	SHORT $LN30@idata_nofi
	cmp	eax, 71					; 00000047H
	jne	SHORT $LN32@idata_nofi
$LN30@idata_nofi:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+64]

; 844  :         // CodeInfo->iswide = 1; /* has been set by first operand already */
; 845  :         CodeInfo->opnd[CurrOpnd].type = OP_I64;

	mov	DWORD PTR [rcx+56], 1048576		; 00100000H

; 846  :         CodeInfo->opnd[CurrOpnd].data32h = opndx->hvalue;

	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rcx+68], eax

; 847  :         return( NOT_ERROR );

	xor	eax, eax
	mov	rdi, QWORD PTR [rsp+72]

; 935  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN32@idata_nofi:

; 848  :     }
; 849  :     //if ( opndx->value64 <= minintvalues[0] || opndx->value64 > maxintvalues[0] ) {
; 850  :     //    DebugMsg1(("idata_nofixup: error, hvalue=%Xh\n", opndx->hvalue ));
; 851  :     //    return( EmitConstError( opndx ) );
; 852  :     //}
; 853  : #endif
; 854  : 
; 855  :     /* v2.06: code simplified.
; 856  :      * to be fixed: the "wide" bit should not be set here!
; 857  :      * Problem: the "wide" bit isn't set in memory_operand(),
; 858  :      * probably because of the instructions which accept both
; 859  :      * signed and unsigned arguments (ADD, CMP, ... ).
; 860  :      */
; 861  : 
; 862  :     if ( opndx->explicit ) {

	test	BYTE PTR [r8+72], 2
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+32], r12
	mov	r12d, 262144				; 00040000H
	mov	ebp, 524288				; 00080000H
	je	$LN29@idata_nofi

; 863  :         /* size coercion for immediate value */
; 864  :         CodeInfo->const_size_fixed = TRUE;

	or	BYTE PTR [rcx+142], 8

; 865  :         size = SizeFromMemtype( opndx->mem_type,
; 866  :                                opndx->Ofssize,
; 867  :                                opndx->type );

	mov	edx, DWORD PTR [r8+64]
	movzx	r10d, BYTE PTR [r8+69]
	test	dl, dl
	mov	rcx, QWORD PTR [r8+96]
	js	SHORT $LN47@idata_nofi
	cmp	edx, 63					; 0000003fH
	jne	SHORT $LN48@idata_nofi
	mov	edx, 64					; 00000040H
	jmp	$LN44@idata_nofi
$LN48@idata_nofi:
	and	edx, 31
	inc	edx
	jmp	$LN44@idata_nofi
$LN47@idata_nofi:
	cmp	r10d, 254				; 000000feH
	jne	SHORT $LN46@idata_nofi
	movzx	r10d, BYTE PTR ModuleInfo+404
$LN46@idata_nofi:
	add	edx, -128				; ffffffffffffff80H
	je	SHORT $LN41@idata_nofi
	dec	edx
	je	SHORT $LN43@idata_nofi
	dec	edx
	je	SHORT $LN42@idata_nofi
	sub	edx, 65					; 00000041H
	je	SHORT $LN40@idata_nofi
	dec	edx
	jne	SHORT $LN38@idata_nofi
	test	rcx, rcx
	je	SHORT $LN38@idata_nofi
	mov	edx, DWORD PTR [rcx+64]
	jmp	SHORT $LN44@idata_nofi
$LN38@idata_nofi:
	xor	edx, edx
	jmp	SHORT $LN44@idata_nofi
$LN40@idata_nofi:
	mov	ecx, DWORD PTR ModuleInfo+360
	mov	eax, 1
	shl	eax, cl
	mov	ecx, r10d
	and	al, 104					; 00000068H
	neg	al
	mov	eax, 2
	sbb	edx, edx
	shl	eax, cl
	and	edx, 2
	add	edx, eax
	jmp	SHORT $LN44@idata_nofi
$LN42@idata_nofi:
	mov	ecx, r10d
	mov	edx, 2
	shl	edx, cl
	add	edx, 2
	jmp	SHORT $LN44@idata_nofi
$LN43@idata_nofi:
	mov	ecx, r10d
	mov	edx, 2
	shl	edx, cl
	jmp	SHORT $LN44@idata_nofi
$LN41@idata_nofi:
	mov	dl, BYTE PTR [rcx+55]
	mov	eax, 2
	mov	ecx, r10d
	shr	edx, 3
	shl	eax, cl
	and	edx, 2
	add	edx, eax
$LN44@idata_nofi:

; 868  :         /* don't check if size and value are compatible. */
; 869  :         switch ( size ) {

	dec	edx
	je	SHORT $LN26@idata_nofi
	dec	edx
	je	SHORT $LN25@idata_nofi
	cmp	edx, 2
	je	SHORT $LN24@idata_nofi

; 873  :         default:
; 874  :             DebugMsg1(("idata_nofixup: invalid size %d for immediate operand\n", size ));
; 875  :             return( EmitError( INVALID_INSTRUCTION_OPERANDS ) );

	mov	ecx, 49					; 00000031H
	call	EmitError
	jmp	$LN56@idata_nofi
$LN24@idata_nofi:

; 872  :         case 4: op_type = OP_I32; break;

	mov	ecx, ebp
	jmp	SHORT $LN19@idata_nofi
$LN25@idata_nofi:

; 871  :         case 2: op_type = OP_I16; break;

	mov	ecx, r12d
	jmp	SHORT $LN19@idata_nofi
$LN26@idata_nofi:

; 870  :         case 1: op_type = OP_I8;  break;

	mov	ecx, 131072				; 00020000H

; 876  :         }
; 877  :     } else {

	jmp	SHORT $LN19@idata_nofi
$LN29@idata_nofi:

; 878  :         /* use true signed values for BYTE only! */
; 879  :         if ( (int_8)value == value )

	movsx	eax, r11b
	cmp	eax, r11d
	jne	SHORT $LN21@idata_nofi

; 880  :             op_type = OP_I8;

	mov	ecx, 131072				; 00020000H
	jmp	SHORT $LN19@idata_nofi
$LN21@idata_nofi:

; 881  :         //else if ( value <= SHRT_MAX && value >= SHRT_MIN )
; 882  :         /* v2.04: range FFFF0000-FFFF7FFF is also acceptable for 16-bit */
; 883  :         //else if ( value <= USHRT_MAX && value >= SHRT_MIN )
; 884  :         /* v2.04b: HJWASMR needs a 1L */
; 885  :         //else if( value <= USHRT_MAX && value >= - (USHRT_MAX+1) )
; 886  :         /* v2.07: HJWASMR needs 0L before the - op */
; 887  :         //else if( value <= USHRT_MAX && value >= - USHRT_MAX )
; 888  :         else if( value <= USHRT_MAX && value >= 0L - USHRT_MAX )

	lea	eax, DWORD PTR [r11+65535]
	mov	ecx, ebp
	cmp	eax, 131070				; 0001fffeH
	cmovbe	ecx, r12d
$LN19@idata_nofi:

; 889  :             op_type = OP_I16;
; 890  :         else {
; 891  :             op_type = OP_I32;
; 892  :         }
; 893  :     }
; 894  : 
; 895  :     switch ( CodeInfo->token ) {

	mov	edx, DWORD PTR [r9+24]
	sub	edx, 565				; 00000235H
	je	SHORT $LN6@idata_nofi
	sub	edx, 36					; 00000024H
	je	SHORT $LN15@idata_nofi
	cmp	edx, 2
	jne	SHORT $LN5@idata_nofi

; 906  :     case T_PUSHW:
; 907  :         if ( op_type != OP_I32 ) {

	cmp	ecx, ebp
	je	SHORT $LN5@idata_nofi

; 908  :             op_type = OP_I16;
; 909  :             if( (int_8)value == (int_16)value ) {

	movsx	eax, r11b
	mov	ecx, r12d
	cmp	ax, r11w
	jne	SHORT $LN5@idata_nofi

; 910  :                 op_type = OP_I8;

	mov	ecx, 131072				; 00020000H

; 911  :             }
; 912  :         }
; 913  :         break;

	jmp	SHORT $LN5@idata_nofi
$LN15@idata_nofi:

; 896  :     case T_PUSH:
; 897  :         if ( opndx->explicit == FALSE ) {

	test	BYTE PTR [r8+72], 2
	jne	SHORT $LN13@idata_nofi

; 898  :             if ( CodeInfo->Ofssize > USE16 && op_type == OP_I16 )

	test	bl, bl
	je	SHORT $LN13@idata_nofi
	cmp	ecx, r12d
	jne	SHORT $LN12@idata_nofi

; 899  :                 op_type = OP_I32;

	mov	ecx, ebp

; 900  :         }
; 901  :         if ( op_type == OP_I16 )

	jmp	SHORT $LN52@idata_nofi
$LN13@idata_nofi:
	cmp	ecx, r12d
	jne	SHORT $LN12@idata_nofi

; 902  :             CodeInfo->prefix.opsiz = OPSIZE16( CodeInfo );

	and	BYTE PTR [r9+9], 253			; 000000fdH
	test	bl, bl
	setne	al
	and	al, 1
	add	al, al
	or	BYTE PTR [r9+9], al
	jmp	SHORT $LN5@idata_nofi
$LN12@idata_nofi:

; 903  :         else if ( op_type == OP_I32 )

	cmp	ecx, ebp
	jne	SHORT $LN5@idata_nofi
$LN52@idata_nofi:

; 904  :             CodeInfo->prefix.opsiz = OPSIZE32( CodeInfo );

	and	BYTE PTR [r9+9], 253			; 000000fdH
	test	bl, bl
	sete	al
	and	al, 1
	add	al, al
	or	BYTE PTR [r9+9], al

; 905  :         break;

	jmp	SHORT $LN5@idata_nofi
$LN6@idata_nofi:

; 914  :     case T_PUSHD:
; 915  :         if ( op_type == OP_I16 )

	cmp	ecx, r12d
	cmove	ecx, ebp
$LN5@idata_nofi:

; 916  :             op_type = OP_I32;
; 917  :         break;
; 918  :     }
; 919  : 
; 920  :     /* v2.11: set the wide-bit if a mem_type size of > BYTE is set???
; 921  :      * actually, it should only be set if immediate is second operand
; 922  :      * ( and first operand is a memory ref with a size > 1 )
; 923  :      */
; 924  :     if (CurrOpnd == OPND2){

	cmp	edi, 1
	jne	SHORT $LN1@idata_nofi

; 925  : #if AVXSUPP
; 926  :         if ( CodeInfo->mem_type == MT_ZMMWORD ) CodeInfo->iswide = 1;

	mov	eax, DWORD PTR [r9+28]
	cmp	eax, 63					; 0000003fH

; 927  :         else 

	je	SHORT $LN57@idata_nofi

; 928  : #endif
; 929  :           if ( !(CodeInfo->mem_type & MT_SPECIAL) && ( CodeInfo->mem_type & MT_SIZE_MASK ) )

	test	al, al
	js	SHORT $LN1@idata_nofi
	test	al, 31
	je	SHORT $LN1@idata_nofi
$LN57@idata_nofi:

; 930  :             CodeInfo->iswide = 1;

	or	BYTE PTR [r9+142], 1
$LN1@idata_nofi:

; 931  :          }
; 932  :     CodeInfo->opnd[CurrOpnd].type = op_type;

	mov	DWORD PTR [r9+rsi*8+32], ecx

; 933  :     DebugMsg1(("idata_nofixup exit, op_type=%" I32_SPEC "X\n", op_type ));
; 934  :     return( NOT_ERROR );

	xor	eax, eax
$LN56@idata_nofi:
	mov	rbp, QWORD PTR [rsp+56]
	mov	r12, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]

; 935  : }

	add	rsp, 40					; 00000028H
	ret	0
idata_nofixup ENDP
_TEXT	ENDS
PUBLIC	idata_fixup
EXTRN	CreateFixup:NEAR
EXTRN	Parse_Pass:DWORD
xdata	SEGMENT
$unwind$idata_fixup DD 092301H
	DD	08e423H
	DD	0ac416H
	DD	0f7411H
	DD	0c340cH
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$idata_fixup DD @imagerel($LN144#)
	DD	@imagerel($LN144#+74)
	DD	@imagerel($unwind$idata_fixup#)
pdata	ENDS
xdata	SEGMENT
$chain$5$idata_fixup DD 041721H
	DD	07f417H
	DD	09d405H
	DD	@imagerel($LN144#)
	DD	@imagerel($LN144#+74)
	DD	@imagerel($unwind$idata_fixup#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$idata_fixup DD @imagerel($LN144#+74)
	DD	@imagerel($LN144#+219)
	DD	@imagerel($chain$5$idata_fixup#)
pdata	ENDS
xdata	SEGMENT
$chain$7$idata_fixup DD 040a21H
	DD	0e640aH
	DD	0d5405H
	DD	@imagerel($LN144#+74)
	DD	@imagerel($LN144#+219)
	DD	@imagerel($chain$5$idata_fixup#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$idata_fixup DD @imagerel($LN144#+219)
	DD	@imagerel($LN144#+1858)
	DD	@imagerel($chain$7$idata_fixup#)
pdata	ENDS
xdata	SEGMENT
$chain$8$idata_fixup DD 021H
	DD	@imagerel($LN144#+74)
	DD	@imagerel($LN144#+219)
	DD	@imagerel($chain$5$idata_fixup#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$idata_fixup DD @imagerel($LN144#+1858)
	DD	@imagerel($LN144#+1868)
	DD	@imagerel($chain$8$idata_fixup#)
pdata	ENDS
xdata	SEGMENT
$chain$9$idata_fixup DD 021H
	DD	@imagerel($LN144#)
	DD	@imagerel($LN144#+74)
	DD	@imagerel($unwind$idata_fixup#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$idata_fixup DD @imagerel($LN144#+1868)
	DD	@imagerel($LN144#+1896)
	DD	@imagerel($chain$9$idata_fixup#)
pdata	ENDS
xdata	SEGMENT
$chain$10$idata_fixup DD 080021H
	DD	07f400H
	DD	09d400H
	DD	0e6400H
	DD	0d5400H
	DD	@imagerel($LN144#)
	DD	@imagerel($LN144#+74)
	DD	@imagerel($unwind$idata_fixup#)
xdata	ENDS
pdata	SEGMENT
$pdata$10$idata_fixup DD @imagerel($LN144#+1896)
	DD	@imagerel($LN144#+2154)
	DD	@imagerel($chain$10$idata_fixup#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
fixup_option$1$ = 32
CodeInfo$ = 96
CurrOpnd$ = 104
opndx$ = 112
idata_fixup PROC NEAR

; 950  : {

$LN144:
	sub	rsp, 88					; 00000058H

; 951  :     //struct fixup      *fixup;
; 952  :     enum fixup_types    fixup_type;
; 953  :     enum fixup_options  fixup_option = OPTJ_NONE;
; 954  :     int                 size;
; 955  :     uint_8              Ofssize; /* 1=32bit, 0=16bit offset for fixup */
; 956  : 
; 957  :     DebugMsg1(("idata_fixup( CurrOpnd=%u ) enter [opndx.kind=%u mem_type=%Xh, CodeInfo.mem_type=%Xh]\n", CurrOpnd, opndx->kind, opndx->mem_type, CodeInfo->mem_type));
; 958  : 
; 959  :     /* jmp/call/jcc/loopcc/jxcxz? */
; 960  :     if( IS_ANY_BRANCH( CodeInfo->token ) ) {

	mov	eax, DWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+96], rbx
	mov	QWORD PTR [rsp+120], rdi
	mov	QWORD PTR [rsp+80], r12
	xor	r12d, r12d
	cmp	eax, 455				; 000001c7H
	mov	QWORD PTR [rsp+64], r14
	mov	rdi, r8
	mov	rbx, rcx
	mov	r14d, edx
	mov	DWORD PTR fixup_option$1$[rsp], r12d
	jl	SHORT $LN94@idata_fixu
	cmp	eax, 504				; 000001f8H
	jg	SHORT $LN94@idata_fixu

; 961  :         return( process_branch( CodeInfo, CurrOpnd, opndx ) );

	mov	edx, r14d
	call	process_branch
	jmp	$LN95@idata_fixu
$LN94@idata_fixu:

; 962  :     }
; 963  :     CodeInfo->opnd[CurrOpnd].data32l = opndx->value;

	mov	eax, DWORD PTR [r8]
	mov	QWORD PTR [rsp+72], r13
	lea	r13, QWORD PTR [r14+r14*2]
	mov	DWORD PTR [rcx+r13*8+40], eax

; 964  : 
; 965  :     if ( opndx->Ofssize != USE_EMPTY ) {

	mov	r11b, BYTE PTR [r8+69]
	mov	QWORD PTR [rsp+56], r15
	cmp	r11b, 254				; 000000feH
	jne	SHORT $LN87@idata_fixu

; 966  :         Ofssize = opndx->Ofssize;
; 967  :     } else if( ( opndx->sym->state == SYM_SEG )
; 968  :         || ( opndx->sym->state == SYM_GRP )
; 969  :         || ( opndx->instr == T_SEG ) ) {

	mov	rcx, QWORD PTR [r8+80]
	mov	eax, DWORD PTR [rcx+40]
	cmp	eax, 3
	je	SHORT $LN90@idata_fixu
	cmp	eax, 4
	je	SHORT $LN90@idata_fixu
	cmp	DWORD PTR [r8+56], 244			; 000000f4H
	je	SHORT $LN90@idata_fixu

; 971  :     } else if( opndx->is_abs ) {  /* an (external) absolute symbol? */

	test	BYTE PTR [r8+72], 4
	je	SHORT $LN88@idata_fixu

; 972  :         Ofssize = USE16;

	xor	r11b, r11b

; 973  :     } else {

	jmp	SHORT $LN87@idata_fixu
$LN88@idata_fixu:

; 974  :         Ofssize = GetSymOfssize( opndx->sym );

	call	GetSymOfssize
	mov	r11d, eax
	jmp	SHORT $LN87@idata_fixu
$LN90@idata_fixu:

; 970  :         Ofssize = USE16;

	xor	r11b, r11b
$LN87@idata_fixu:

; 975  :     }
; 976  : 
; 977  :     if( opndx->instr == T_SHORT ) {

	cmp	DWORD PTR [rdi+56], 245			; 000000f5H
	jne	SHORT $LN86@idata_fixu

; 978  :         /* short works for branch instructions only */
; 979  :         return( EmitErr( INVALID_INSTRUCTION_OPERANDS ) );

	mov	ecx, 49					; 00000031H
	call	EmitErr
	jmp	$LN141@idata_fixu
$LN86@idata_fixu:

; 980  :     }
; 981  : 
; 982  :     /* the code below should be rewritten.
; 983  :      * - an address operator ( OFFSET, LROFFSET, IMAGEREL, SECTIONREL,
; 984  :      *   LOW, HIGH, LOWWORD, HIGHWORD, LOW32, HIGH32, SEG ) should not
; 985  :      *   force a magnitude, but may set a minimal magnitude - and the
; 986  :      *   fixup type, of course.
; 987  :      * - check if Codeinfo->mem_type really has to be set here!
; 988  :      */
; 989  : 
; 990  :     /* v2.06: added */
; 991  :     /* v2.10: modified */
; 992  :     //if ( opndx->explicit ) {
; 993  :     if ( opndx->explicit && !opndx->is_abs ) {

	mov	eax, DWORD PTR [rdi+72]
	test	al, 2
	je	SHORT $LN84@idata_fixu
	test	al, 4
	jne	SHORT $LN84@idata_fixu

; 994  :         CodeInfo->const_size_fixed = TRUE;

	or	BYTE PTR [rbx+142], 8

; 995  :         if ( CodeInfo->mem_type == MT_EMPTY )

	cmp	DWORD PTR [rbx+28], 192			; 000000c0H
	jne	SHORT $LN84@idata_fixu

; 996  :             CodeInfo->mem_type = opndx->mem_type;

	mov	eax, DWORD PTR [rdi+64]
	mov	DWORD PTR [rbx+28], eax
$LN84@idata_fixu:

; 997  :     }
; 998  :     /* v2.03: don't ignore a "NEAR32 ptr" qualifier */
; 999  :     //if ( CodeInfo->mem_type == MT_EMPTY && CurrOpnd > OPND1 ) {
; 1000 :     if ( CodeInfo->mem_type == MT_EMPTY && CurrOpnd > OPND1 && opndx->Ofssize == USE_EMPTY ) {

	cmp	DWORD PTR [rbx+28], 192			; 000000c0H
	mov	QWORD PTR [rsp+104], rbp
	mov	QWORD PTR [rsp+112], rsi
	mov	esi, 7
	lea	ebp, QWORD PTR [rsi-6]
	lea	r9d, QWORD PTR [rsi-4]
	jne	$LN71@idata_fixu
	test	r14d, r14d
	je	$LN71@idata_fixu
	cmp	BYTE PTR [rdi+69], 254			; 000000feH
	jne	$LN71@idata_fixu

; 1001 :         size = OperandSize( CodeInfo->opnd[OPND1].type, CodeInfo );

	mov	r10d, DWORD PTR [rbx+32]
	mov	rdx, rbx
	mov	ecx, r10d
	call	OperandSize

; 1002 :         /* may be a forward reference, so wait till pass 2 */
; 1003 :         if( Parse_Pass > PASS_1 && opndx->instr != EMPTY ) {

	cmp	DWORD PTR Parse_Pass, r12d
	mov	r9d, eax
	jbe	SHORT $LN76@idata_fixu
	mov	eax, DWORD PTR [rdi+56]
	cmp	eax, -2
	je	SHORT $LN76@idata_fixu

; 1004 :             switch ( opndx->instr ) {

	sub	eax, 233				; 000000e9H
	je	SHORT $LN77@idata_fixu
	sub	eax, 6
	je	SHORT $LN77@idata_fixu
	sub	eax, 2
	je	SHORT $LN77@idata_fixu
	sub	eax, 2
	je	SHORT $LN77@idata_fixu
	dec	eax
	jne	SHORT $LN76@idata_fixu

; 1005 :             case T_SEG: /* v2.04a: added */
; 1006 :                 if( size && (size < 2 ) ) {

	test	r9d, r9d
	je	SHORT $LN76@idata_fixu
	cmp	r9d, 2
	jge	SHORT $LN76@idata_fixu

; 1007 :                     return( EmitErr( OPERANDS_MUST_BE_THE_SAME_SIZE, size, 2 ) );

	lea	r8d, QWORD PTR [rsi-5]
	lea	ecx, QWORD PTR [rsi+41]
	mov	edx, r9d
	call	EmitErr
	jmp	$LN143@idata_fixu
$LN77@idata_fixu:

; 1008 :                 }
; 1009 :                 break;
; 1010 :             case T_OFFSET:
; 1011 :             case T_LROFFSET:
; 1012 : #if IMAGERELSUPP
; 1013 :             case T_IMAGEREL:
; 1014 : #endif
; 1015 : #if SECTIONRELSUPP
; 1016 :             case T_SECTIONREL:
; 1017 : #endif
; 1018 :                 if( size && (size < 2 || ( Ofssize && size < 4 ))) {

	test	r9d, r9d
	je	SHORT $LN76@idata_fixu
	cmp	r9d, 2
	jl	SHORT $LN75@idata_fixu
	test	r11b, r11b
	je	SHORT $LN76@idata_fixu
	cmp	r9d, 4
	jge	SHORT $LN76@idata_fixu
$LN75@idata_fixu:

; 1019 :                     return( EmitErr( OPERANDS_MUST_BE_THE_SAME_SIZE, size, ( 2 << Ofssize ) ) );

	movzx	ecx, r11b
	mov	r8d, 2
	mov	edx, r9d
	shl	r8d, cl
	mov	ecx, 48					; 00000030H
	call	EmitErr
	jmp	$LN143@idata_fixu
$LN76@idata_fixu:

; 1020 :                 }
; 1021 :             }
; 1022 :         }
; 1023 :         switch ( size ) {

	dec	r9d
	je	$LN72@idata_fixu
	dec	r9d
	je	SHORT $LN69@idata_fixu
	sub	r9d, 2
	je	SHORT $LN66@idata_fixu
	cmp	r9d, 4
	jne	$LN135@idata_fixu

; 1040 : #if AMD64_SUPPORT
; 1041 :         case 8:
; 1042 :             /* v2.05: it's questionable if size 8 is a good assumption for an
; 1043 :              * immediate constant. It's valid for MOV <reg>, <imm> only.
; 1044 :              */
; 1045 :             //case 8: CodeInfo->mem_type = MT_QWORD;break;
; 1046 :             /* v2.05a: added */
; 1047 :             if ( Ofssize == USE64 ) {

	cmp	r11b, 2
	jne	$LN138@idata_fixu

; 1048 :                 if ( CodeInfo->token == T_MOV &&
; 1049 :                     ( CodeInfo->opnd[OPND1].type & OP_R64 ) )

	cmp	DWORD PTR [rbx+24], 606			; 0000025eH
	jne	SHORT $LN63@idata_fixu
	test	r10b, 8
	je	SHORT $LN63@idata_fixu

; 1050 :                     CodeInfo->mem_type = MT_QWORD;

	mov	DWORD PTR [rbx+28], esi
	mov	r9d, 3
	jmp	$LN71@idata_fixu
$LN63@idata_fixu:

; 1051 :                 else if ( opndx->instr == T_LOW32 || opndx->instr == T_HIGH32 )

	mov	eax, DWORD PTR [rdi+56]
	cmp	eax, 237				; 000000edH
	je	SHORT $LN60@idata_fixu
	cmp	eax, 231				; 000000e7H
	jne	SHORT $LN137@idata_fixu
$LN60@idata_fixu:

; 1052 :                     /* v2.10:added; LOW32/HIGH32 in expreval.c won't set mem_type anymore. */
; 1053 :                     CodeInfo->mem_type = MT_DWORD;

	mov	r9d, 3
	mov	DWORD PTR [rbx+28], r9d

; 1054 :             }
; 1055 :             break;

	jmp	SHORT $LN71@idata_fixu
$LN66@idata_fixu:

; 1037 :         case 4:
; 1038 :             CodeInfo->mem_type = MT_DWORD;

	mov	r9d, 3
	mov	DWORD PTR [rbx+28], r9d

; 1039 :             break;

	jmp	SHORT $LN71@idata_fixu
$LN69@idata_fixu:

; 1028 :             break;
; 1029 :         case 2:
; 1030 :             /* v2.05: if () added */
; 1031 :             if ( opndx->is_abs ||
; 1032 :                 CodeInfo->Ofssize == USE16 ||
; 1033 :                 opndx->instr == T_LOWWORD ||
; 1034 :                 opndx->instr == T_HIGHWORD )

	test	BYTE PTR [rdi+72], 4
	jne	SHORT $LN67@idata_fixu
	cmp	BYTE PTR [rbx+106], r12b
	je	SHORT $LN67@idata_fixu
	mov	eax, DWORD PTR [rdi+56]
	cmp	eax, 238				; 000000eeH
	je	SHORT $LN67@idata_fixu
	cmp	eax, 232				; 000000e8H
	jne	SHORT $LN136@idata_fixu
$LN67@idata_fixu:

; 1035 :                 CodeInfo->mem_type = MT_WORD;

	mov	DWORD PTR [rbx+28], ebp

; 1036 :             break;

	mov	r9d, 3
	jmp	SHORT $LN71@idata_fixu
$LN72@idata_fixu:

; 1024 :         case 1:
; 1025 :             /* v2.05: if () added */
; 1026 :             if ( opndx->is_abs || opndx->instr == T_LOW || opndx->instr == T_HIGH )

	test	BYTE PTR [rdi+72], 4
	jne	SHORT $LN70@idata_fixu
	mov	eax, DWORD PTR [rdi+56]
	cmp	eax, 236				; 000000ecH
	je	SHORT $LN70@idata_fixu
	cmp	eax, 230				; 000000e6H
	jne	SHORT $LN139@idata_fixu
$LN70@idata_fixu:

; 1027 :                 CodeInfo->mem_type = MT_BYTE;

	mov	DWORD PTR [rbx+28], r12d
	mov	r9d, 3
	jmp	SHORT $LN71@idata_fixu
$LN135@idata_fixu:
	mov	r9d, 3
	jmp	SHORT $LN71@idata_fixu
$LN136@idata_fixu:
	mov	r9d, 3
	jmp	SHORT $LN71@idata_fixu
$LN137@idata_fixu:
	mov	r9d, 3
	jmp	SHORT $LN71@idata_fixu
$LN138@idata_fixu:
	mov	r9d, 3
	jmp	SHORT $LN71@idata_fixu
$LN139@idata_fixu:
	mov	r9d, 3
$LN71@idata_fixu:

; 1056 : #endif
; 1057 :         }
; 1058 :     }
; 1059 :     if ( CodeInfo->mem_type == MT_EMPTY ) {

	cmp	DWORD PTR [rbx+28], 192			; 000000c0H
	lea	r10, OFFSET FLAT:__ImageBase
	jne	$LN35@idata_fixu

; 1060 :         if( opndx->is_abs ) {

	mov	edx, DWORD PTR [rdi+72]
	test	dl, 4
	je	SHORT $LN58@idata_fixu

; 1061 :             //if( opndx->mem_type != MT_EMPTY && opndx->mem_type != MT_ABS ) {
; 1062 :             if( opndx->mem_type != MT_EMPTY ) {

	mov	eax, DWORD PTR [rdi+64]
	cmp	eax, 192				; 000000c0H
	je	SHORT $LN57@idata_fixu

; 1063 :                 CodeInfo->mem_type = opndx->mem_type;

	mov	DWORD PTR [rbx+28], eax
	jmp	$LN35@idata_fixu
$LN57@idata_fixu:

; 1064 :             } else if ( CodeInfo->token == T_PUSHW ) { /* v2.10: special handling PUSHW */

	cmp	DWORD PTR [rbx+24], 603			; 0000025bH
	jne	SHORT $LN55@idata_fixu

; 1065 :                 CodeInfo->mem_type = MT_WORD;

	mov	DWORD PTR [rbx+28], ebp

; 1066 :             } else {

	jmp	$LN35@idata_fixu
$LN55@idata_fixu:

; 1067 :                 CodeInfo->mem_type = ( IS_OPER_32( CodeInfo ) ? MT_DWORD : MT_WORD );

	cmp	BYTE PTR [rbx+106], r12b
	je	SHORT $LN97@idata_fixu
	mov	cl, BYTE PTR [rbx+9]
	mov	eax, ebp
	shr	ecx, 1
	not	ecx
	and	ecx, ebp
	test	ecx, ecx
	cmovne	eax, r9d
	mov	DWORD PTR [rbx+28], eax

; 1068 :             }
; 1069 :         } else {

	jmp	$LN35@idata_fixu
$LN97@idata_fixu:

; 1067 :                 CodeInfo->mem_type = ( IS_OPER_32( CodeInfo ) ? MT_DWORD : MT_WORD );

	movzx	eax, BYTE PTR [rbx+9]
	mov	ecx, r12d
	and	al, 2
	cmp	al, 2
	mov	eax, ebp
	sete	cl
	test	ecx, ecx
	cmovne	eax, r9d
	mov	DWORD PTR [rbx+28], eax

; 1068 :             }
; 1069 :         } else {

	jmp	$LN35@idata_fixu
$LN58@idata_fixu:

; 1070 :             switch ( CodeInfo->token ) {

	mov	ecx, DWORD PTR [rbx+24]
	sub	ecx, 565				; 00000235H
	je	SHORT $LN50@idata_fixu
	sub	ecx, 36					; 00000024H
	je	SHORT $LN50@idata_fixu
	cmp	ecx, 2
	jne	$LN39@idata_fixu
$LN50@idata_fixu:

; 1071 :             case T_PUSHW:
; 1072 :             case T_PUSHD:
; 1073 :             case T_PUSH:
; 1074 :                 /* for forward reference, assume BYTE */
; 1075 :                 /* v2.02: don't assume BYTE if it is SEG/GRP */
; 1076 :                 //if ( opndx->mem_type == MT_EMPTY ) {
; 1077 :                 /* v2.07: added cases IMAGEREL and SECTIONREL */
; 1078 :                 if ( opndx->mem_type == MT_EMPTY  ) {

	cmp	DWORD PTR [rdi+64], 192			; 000000c0H
	jne	SHORT $LN47@idata_fixu

; 1079 :                     switch( opndx->instr ) {

	mov	eax, DWORD PTR [rdi+56]
	add	eax, 2
	cmp	eax, 245				; 000000f5H
	ja	SHORT $LN47@idata_fixu
	cdqe
	movzx	eax, BYTE PTR $LN132@idata_fixu[r10+rax]
	mov	ecx, DWORD PTR $LN133@idata_fixu[r10+rax*4]
	add	rcx, r10
	jmp	rcx
$LN46@idata_fixu:

; 1080 :                     case EMPTY:
; 1081 :                     case T_LOW:
; 1082 :                     case T_HIGH:
; 1083 :                         opndx->mem_type = MT_BYTE;

	mov	DWORD PTR [rdi+64], r12d

; 1084 :                         break;

	jmp	SHORT $LN47@idata_fixu
$LN45@idata_fixu:

; 1085 :                     case T_LOW32: /* v2.10: added - low32_op() doesn't set mem_type anymore. */
; 1086 : #if IMAGERELSUPP
; 1087 :                     case T_IMAGEREL:
; 1088 : #endif
; 1089 : #if SECTIONRELSUPP
; 1090 :                     case T_SECTIONREL:
; 1091 : #endif
; 1092 :                         opndx->mem_type = MT_DWORD;

	mov	DWORD PTR [rdi+64], r9d
$LN47@idata_fixu:

; 1093 :                         break;
; 1094 :                     };
; 1095 :                 }
; 1096 :                 /* default: push offset only */
; 1097 :                 /* for PUSH + undefined symbol, assume BYTE */
; 1098 :                 if ( opndx->mem_type == MT_FAR && ( opndx->explicit == FALSE ) )

	cmp	DWORD PTR [rdi+64], 130			; 00000082H
	jne	SHORT $LN44@idata_fixu
	test	dl, 2
	jne	SHORT $LN44@idata_fixu

; 1099 :                     opndx->mem_type = MT_NEAR;

	mov	DWORD PTR [rdi+64], 129			; 00000081H
$LN44@idata_fixu:

; 1100 :                 /* v2.04: curly brackets added */
; 1101 :                 if ( CodeInfo->token == T_PUSHW ) {

	mov	eax, DWORD PTR [rbx+24]
	cmp	eax, 603				; 0000025bH
	jne	SHORT $LN43@idata_fixu

; 1102 :                     if ( SizeFromMemtype( opndx->mem_type, Ofssize, opndx->type ) < 2 )

	mov	r8, QWORD PTR [rdi+96]
	mov	ecx, DWORD PTR [rdi+64]
	movzx	edx, r11b
	call	SizeFromMemtype
	cmp	eax, 2
	jge	SHORT $LN39@idata_fixu

; 1103 :                         opndx->mem_type = MT_WORD;

	mov	DWORD PTR [rdi+64], ebp

; 1104 :                 } else if ( CodeInfo->token == T_PUSHD ) {

	jmp	SHORT $LN39@idata_fixu
$LN43@idata_fixu:
	cmp	eax, 565				; 00000235H
	jne	SHORT $LN39@idata_fixu

; 1105 :                     if ( SizeFromMemtype( opndx->mem_type, Ofssize, opndx->type ) < 4 )

	mov	r8, QWORD PTR [rdi+96]
	mov	ecx, DWORD PTR [rdi+64]
	movzx	edx, r11b
	call	SizeFromMemtype
	cmp	eax, 4
	jge	SHORT $LN39@idata_fixu

; 1106 :                         opndx->mem_type = MT_DWORD;

	mov	DWORD PTR [rdi+64], r9d
$LN39@idata_fixu:

; 1107 :                 }
; 1108 :                 break;
; 1109 :             }
; 1110 :             /* if a WORD size is given, don't override it with */
; 1111 :             /* anything what might look better at first glance */
; 1112 :             if( opndx->mem_type != MT_EMPTY )

	mov	eax, DWORD PTR [rdi+64]
	cmp	eax, 192				; 000000c0H
	je	SHORT $LN38@idata_fixu

; 1113 :                 CodeInfo->mem_type = opndx->mem_type;

	mov	DWORD PTR [rbx+28], eax
	jmp	SHORT $LN35@idata_fixu
$LN38@idata_fixu:

; 1114 :             /* v2.04: assume BYTE size if symbol is undefined */
; 1115 :             else if ( opndx->sym->state == SYM_UNDEFINED ) {

	mov	rax, QWORD PTR [rdi+80]
	cmp	DWORD PTR [rax+40], r12d
	jne	SHORT $LN36@idata_fixu

; 1116 :                 CodeInfo->mem_type = MT_BYTE;

	mov	DWORD PTR [rbx+28], r12d

; 1117 :                 fixup_option = OPTJ_PUSH;

	mov	DWORD PTR fixup_option$1$[rsp], 5

; 1118 :             } else

	jmp	SHORT $LN35@idata_fixu
$LN36@idata_fixu:

; 1119 : #if AMD64_SUPPORT
; 1120 :                 /* v2.06d: changed */
; 1121 :                    CodeInfo->mem_type = ( Ofssize == USE64 ? MT_QWORD : Ofssize == USE32 ? MT_DWORD : MT_WORD );

	cmp	r11b, 2
	jne	SHORT $LN99@idata_fixu
	mov	eax, esi
	jmp	SHORT $LN100@idata_fixu
$LN99@idata_fixu:
	mov	eax, ebp
	cmp	r11b, al
	cmove	eax, r9d
$LN100@idata_fixu:
	mov	DWORD PTR [rbx+28], eax
$LN35@idata_fixu:

; 1122 : #else
; 1123 :                 CodeInfo->mem_type = ( Ofssize > USE16 ? MT_DWORD : MT_WORD );
; 1124 : #endif
; 1125 :         }
; 1126 :     }
; 1127 :     size = SizeFromMemtype( CodeInfo->mem_type, Ofssize, NULL );

	mov	edx, DWORD PTR [rbx+28]
	movzx	r8d, r11b
	test	dl, dl
	js	SHORT $LN113@idata_fixu
	cmp	edx, 63					; 0000003fH
	jne	SHORT $LN114@idata_fixu
	mov	edx, 64					; 00000040H
	jmp	$LN110@idata_fixu
$LN114@idata_fixu:
	and	edx, 31
	inc	edx
	jmp	SHORT $LN110@idata_fixu
$LN113@idata_fixu:
	cmp	r8d, 254				; 000000feH
	jne	SHORT $LN112@idata_fixu
	movzx	r8d, BYTE PTR ModuleInfo+404
$LN112@idata_fixu:
	add	edx, -128				; ffffffffffffff80H
	je	SHORT $LN107@idata_fixu
	dec	edx
	je	SHORT $LN109@idata_fixu
	dec	edx
	je	SHORT $LN108@idata_fixu
	cmp	edx, 65					; 00000041H
	je	SHORT $LN106@idata_fixu
	mov	edx, r12d
	jmp	SHORT $LN110@idata_fixu
$LN106@idata_fixu:
	mov	ecx, DWORD PTR ModuleInfo+360
	mov	eax, 2
	shl	ebp, cl
	mov	ecx, r8d
	and	bpl, 104				; 00000068H
	neg	bpl
	sbb	edx, edx
	shl	eax, cl
	and	edx, 2
	add	edx, eax
	jmp	SHORT $LN110@idata_fixu
$LN108@idata_fixu:
	mov	ecx, r8d
	mov	edx, 2
	shl	edx, cl
	add	edx, 2
	jmp	SHORT $LN110@idata_fixu
$LN109@idata_fixu:
	mov	ecx, r8d
	mov	edx, 2
	shl	edx, cl
	jmp	SHORT $LN110@idata_fixu
$LN107@idata_fixu:
	mov	dl, BYTE PTR ds:55
	mov	ecx, r8d
	mov	eax, 2
	shr	edx, 3
	shl	eax, cl
	and	edx, 2
	add	edx, eax
$LN110@idata_fixu:

; 1128 :     switch( size ) {

	mov	ecx, edx
	dec	ecx
	je	$LN32@idata_fixu
	dec	ecx
	je	$LN31@idata_fixu
	sub	ecx, 2
	je	$LN30@idata_fixu
	cmp	ecx, 4
	jne	$LN33@idata_fixu

; 1135 : #if AMD64_SUPPORT
; 1136 :     case 8:
; 1137 :         /* v2.05: do only assume size 8 if the constant won't fit in 4 bytes. */
; 1138 :         if ( opndx->value64 > LONG_MAX || opndx->value64 < LONG_MIN ||
; 1139 :             (opndx->explicit && ( opndx->mem_type & MT_SIZE_MASK ) == 7 ) ) {

	mov	rax, QWORD PTR [rdi]
	cmp	rax, 2147483647				; 7fffffffH
	jg	SHORT $LN27@idata_fixu
	cmp	rax, -2147483648			; ffffffff80000000H
	jl	SHORT $LN27@idata_fixu
	test	BYTE PTR [rdi+72], 2
	je	SHORT $LN28@idata_fixu
	mov	eax, DWORD PTR [rdi+64]
	and	eax, 31
	cmp	al, sil
	je	SHORT $LN27@idata_fixu
$LN28@idata_fixu:

; 1142 :         //} else if ( Ofssize == USE64 ) { /* v2.11: assume 64-bit only for OFFSET or MOV r64, xxx */
; 1143 :         } else if ( Ofssize == USE64 && ( opndx->instr == T_OFFSET || ( CodeInfo->token == T_MOV && ( CodeInfo->opnd[OPND1].type & OP_R64 ) ) ) ) {

	cmp	r11b, 2
	jne	SHORT $LN25@idata_fixu
	cmp	DWORD PTR [rdi+56], 241			; 000000f1H
	je	SHORT $LN24@idata_fixu
	cmp	DWORD PTR [rbx+24], 606			; 0000025eH
	jne	SHORT $LN25@idata_fixu
	test	BYTE PTR [rbx+32], 8
	je	SHORT $LN25@idata_fixu
$LN24@idata_fixu:

; 1144 :             /* v2.06d: in 64-bit, ALWAYS set OP_I64, so "mov m64, ofs" will fail,
; 1145 :              * This was accepted in v2.05-v2.06c)
; 1146 :              */
; 1147 :             CodeInfo->opnd[CurrOpnd].type = OP_I64;

	mov	DWORD PTR [rbx+r13*8+32], 1048576	; 00100000H

; 1148 :             CodeInfo->opnd[CurrOpnd].data32h = opndx->hvalue;

	mov	eax, DWORD PTR [rdi+4]
	mov	DWORD PTR [rbx+r13*8+44], eax

; 1149 :         } else {

	jmp	SHORT $LN23@idata_fixu
$LN25@idata_fixu:

; 1150 :             CodeInfo->opnd[CurrOpnd].type = OP_I32;

	mov	DWORD PTR [rbx+r13*8+32], 524288	; 00080000H
	jmp	SHORT $LN23@idata_fixu
$LN27@idata_fixu:

; 1140 :             CodeInfo->opnd[CurrOpnd].type = OP_I64;

	mov	DWORD PTR [rbx+r13*8+32], 1048576	; 00100000H

; 1141 :             CodeInfo->opnd[CurrOpnd].data32h = opndx->hvalue;

	mov	eax, DWORD PTR [rdi+4]
	mov	DWORD PTR [rbx+r13*8+44], eax
$LN23@idata_fixu:

; 1151 :         }
; 1152 :         CodeInfo->prefix.opsiz = OPSIZE32( CodeInfo );

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], r12b
	sete	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al

; 1153 :         break;

	jmp	SHORT $LN33@idata_fixu
$LN30@idata_fixu:

; 1134 :     case 4:  CodeInfo->opnd[CurrOpnd].type = OP_I32; CodeInfo->prefix.opsiz = OPSIZE32( CodeInfo );  break;

	mov	DWORD PTR [rbx+r13*8+32], 524288	; 00080000H
	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], r12b
	sete	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al
	jmp	SHORT $LN33@idata_fixu
$LN31@idata_fixu:

; 1132 :         break;
; 1133 :     case 2:  CodeInfo->opnd[CurrOpnd].type = OP_I16; CodeInfo->prefix.opsiz = OPSIZE16( CodeInfo );  break;

	mov	DWORD PTR [rbx+r13*8+32], 262144	; 00040000H
	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], r12b
	setne	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al
	jmp	SHORT $LN33@idata_fixu
$LN32@idata_fixu:

; 1129 :     case 1:
; 1130 :         CodeInfo->opnd[CurrOpnd].type = OP_I8;

	mov	DWORD PTR [rbx+r13*8+32], 131072	; 00020000H

; 1131 :         CodeInfo->prefix.opsiz = FALSE; /* v2.10: reset opsize is not really a good idea - might have been set by previous operand */

	and	BYTE PTR [rbx+9], 253			; 000000fdH
$LN33@idata_fixu:

; 1154 : #endif
; 1155 : #ifdef DEBUG_OUT
; 1156 :     default:
; 1157 :         DebugMsg1(("idata_fixup, unexpected size %u\n", size ));
; 1158 :         /**/myassert( 0 );
; 1159 : #endif
; 1160 :     }
; 1161 : 
; 1162 :     /* set fixup_type */
; 1163 : 
; 1164 :     if( opndx->instr == T_SEG ) {

	mov	ecx, DWORD PTR [rdi+56]
	cmp	ecx, 244				; 000000f4H
	jne	SHORT $LN22@idata_fixu

; 1165 :         fixup_type = FIX_SEG;

	mov	esi, 8
	jmp	$LN8@idata_fixu
$LN22@idata_fixu:

; 1166 :     } else if( CodeInfo->mem_type == MT_BYTE ) {

	cmp	DWORD PTR [rbx+28], r12d
	jne	SHORT $LN20@idata_fixu

; 1167 :         DebugMsg1(("idata_fixup, mem_type=BYTE\n" ));
; 1168 :         if ( opndx->instr == T_HIGH ) {

	mov	esi, 4
	mov	eax, 11
	cmp	ecx, 230				; 000000e6H
	cmove	esi, eax

; 1169 :             DebugMsg1(("idata_fixup, FIX_HIBYTE\n" ));
; 1170 :             fixup_type = FIX_HIBYTE;
; 1171 :         } else {
; 1172 :             DebugMsg1(("idata_fixup, FIX_OFF8\n" ));
; 1173 :             fixup_type = FIX_OFF8;
; 1174 :         }

	jmp	SHORT $LN8@idata_fixu
$LN20@idata_fixu:

; 1175 : #if 0
; 1176 :     } else if( CodeInfo->mem_type == MT_FAR ) {
; 1177 :         /* v2.04: to be tested. this code is most likely obsolete.
; 1178 :          * There's never a PTR16|PTR32 fixup here. Far JMP/CALL are handled
; 1179 :          * elsewhere, and data items also.
; 1180 :          */
; 1181 :         /* temporary */
; 1182 :         printf("idata_fixup: MT_FAR occured at %s:%" I32_SPEC "u\n", CurrFName[ASM], LineNumber );
; 1183 :         fixup_type = ( Ofssize ) ? FIX_PTR32 : FIX_PTR16;
; 1184 :         CodeInfo->isfar = TRUE; /* needed for mark_fixupp() */
; 1185 :         if ( opndx->Ofssize != USE_EMPTY )
; 1186 :             CodeInfo->Ofssize = opndx->Ofssize;
; 1187 : #endif
; 1188 :     } else if( IS_OPER_32( CodeInfo ) ) {

	cmp	BYTE PTR [rbx+106], r12b
	je	SHORT $LN101@idata_fixu
	mov	r12b, BYTE PTR [rbx+9]
	shr	r12d, 1
	not	r12d
	and	r12d, 1
	jmp	SHORT $LN102@idata_fixu
$LN101@idata_fixu:
	movzx	eax, BYTE PTR [rbx+9]
	and	al, 2
	cmp	al, 2
	sete	r12b
$LN102@idata_fixu:
	test	r12d, r12d
	je	SHORT $LN16@idata_fixu

; 1189 : #if AMD64_SUPPORT
; 1190 :         /* v2.06: changed */
; 1191 :         //if ( Ofssize == USE64 && CodeInfo->mem_type == MT_QWORD )
; 1192 :         /* v2.10: changed */
; 1193 :         //if ( CodeInfo->opnd[CurrOpnd].type == OP_I64 )
; 1194 :         if ( CodeInfo->opnd[CurrOpnd].type == OP_I64 && ( opndx->instr == EMPTY || opndx->instr == T_OFFSET ) )

	cmp	DWORD PTR [rbx+r13*8+32], 1048576	; 00100000H
	jne	SHORT $LN15@idata_fixu
	cmp	ecx, -2
	je	SHORT $LN8@idata_fixu
	cmp	ecx, 241				; 000000f1H

; 1195 :             fixup_type = FIX_OFF64;
; 1196 :         else

	je	SHORT $LN8@idata_fixu
$LN15@idata_fixu:

; 1197 : #endif
; 1198 :             /* v2.04: changed, no longer depends on OfsSize */
; 1199 :             /* v2.05a: changed, so size==8 won't get a FIX_OFF16 type */
; 1200 :             //if ( size == 4 )
; 1201 :             if ( size >= 4 && opndx->instr != T_LOWWORD ) {

	cmp	edx, 4
	jl	SHORT $LN12@idata_fixu
	cmp	ecx, 238				; 000000eeH
	je	SHORT $LN12@idata_fixu

; 1202 :                 /* v2.06: added branch for PTR16 fixup.
; 1203 :                  * it's only done if type coercion is FAR (Masm-compat)
; 1204 :                  */
; 1205 :                 if ( opndx->explicit && Ofssize == USE16 && opndx->mem_type == MT_FAR )

	test	BYTE PTR [rdi+72], 2
	je	SHORT $LN11@idata_fixu
	test	r11b, r11b
	jne	SHORT $LN11@idata_fixu
	cmp	DWORD PTR [rdi+64], 130			; 00000082H
	jne	SHORT $LN11@idata_fixu

; 1206 :                     fixup_type = FIX_PTR16;

	mov	esi, 9

; 1207 :                 else

	jmp	SHORT $LN8@idata_fixu
$LN11@idata_fixu:

; 1208 :                     fixup_type = FIX_OFF32;

	mov	esi, 6

; 1209 :             } else

	jmp	SHORT $LN8@idata_fixu
$LN12@idata_fixu:

; 1210 :                 fixup_type = FIX_OFF16;

	mov	esi, 5

; 1211 :     } else {

	jmp	SHORT $LN8@idata_fixu
$LN16@idata_fixu:

; 1212 :         /* v2.04: changed, no longer depends on OfsSize */
; 1213 :         //if ( CodeInfo->mem_type == MT_DWORD ) {
; 1214 :             /* fixme !!!! warning
; 1215 :              * operand size is 16bit
; 1216 :              * but fixup is 32-bit */
; 1217 :         //    fixup_type = FIX_OFF32;
; 1218 :         //} else
; 1219 :             fixup_type = FIX_OFF16;

	mov	esi, 5
$LN8@idata_fixu:

; 1220 :     }
; 1221 :     /* v2.04: 'if' added, don't set W bit if size == 1
; 1222 :      * code example:
; 1223 :      *   extern x:byte
; 1224 :      *   or al,x
; 1225 :      * v2.11: set wide bit only if immediate is second operand.
; 1226 :      * and first operand is a memory reference with size > 1
; 1227 :      */
; 1228 :     //if ( size != 1 )
; 1229 :     if ( CurrOpnd == OPND2 && size != 1 )

	cmp	r14d, 1
	jne	SHORT $LN7@idata_fixu
	cmp	edx, r14d
	je	SHORT $LN7@idata_fixu

; 1230 :         CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], r14b
$LN7@idata_fixu:

; 1231 : 
; 1232 :     segm_override( opndx, NULL ); /* set SegOverride global var */

	mov	rcx, QWORD PTR [rdi+48]
	test	rcx, rcx
	je	SHORT $LN134@idata_fixu
	cmp	BYTE PTR [rcx], 2
	jne	SHORT $LN124@idata_fixu
	mov	eax, DWORD PTR [rcx+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	ecx, BYTE PTR SpecialTable[r10+rcx*4+10]
	mov	rax, rcx
	add	rax, rax
	cmp	BYTE PTR SegAssumeTable[r10+rax*8+8], 0
	je	SHORT $LN123@idata_fixu
	mov	ecx, 183				; 000000b7H
	call	EmitError
	mov	rax, QWORD PTR SegOverride
	jmp	SHORT $LN119@idata_fixu
$LN123@idata_fixu:
	call	GetOverrideAssume
	jmp	SHORT $LN120@idata_fixu
$LN124@idata_fixu:
	mov	rcx, QWORD PTR [rcx+8]
	call	SymFind
$LN120@idata_fixu:
	test	rax, rax
	je	SHORT $LN134@idata_fixu
	mov	ecx, DWORD PTR [rax+40]
	cmp	ecx, 4
	je	SHORT $LN118@idata_fixu
	cmp	ecx, 3
	jne	SHORT $LN134@idata_fixu
$LN118@idata_fixu:
	mov	QWORD PTR SegOverride, rax
	jmp	SHORT $LN119@idata_fixu
$LN134@idata_fixu:
	mov	rax, QWORD PTR SegOverride
$LN119@idata_fixu:

; 1233 : 
; 1234 :     /* set frame type in variables Frame_Type and Frame_Datum for fixup creation */
; 1235 :     if ( ModuleInfo.offsettype == OT_SEGMENT &&
; 1236 :         ( opndx->instr == T_OFFSET || opndx->instr == T_SEG ))

	cmp	DWORD PTR ModuleInfo+384, 2
	jne	SHORT $LN6@idata_fixu
	mov	ecx, DWORD PTR [rdi+56]
	cmp	ecx, 241				; 000000f1H
	je	SHORT $LN5@idata_fixu
	cmp	ecx, 244				; 000000f4H
	jne	SHORT $LN6@idata_fixu
$LN5@idata_fixu:

; 1237 :         set_frame2( opndx->sym );

	mov	rcx, QWORD PTR [rdi+80]
	test	rax, rax
	mov	dl, 1
	cmovne	rcx, rax
	call	SetFixupFrame

; 1238 :     else

	jmp	SHORT $LN130@idata_fixu
$LN6@idata_fixu:

; 1239 :         set_frame( opndx->sym );

	mov	rcx, QWORD PTR [rdi+80]
	test	rax, rax
	cmovne	rcx, rax
	xor	edx, edx
	call	SetFixupFrame
$LN130@idata_fixu:

; 1240 : 
; 1241 :     //DebugMsg1(("idata_fixup: calling CreateFixup(%s, %u)\n", opndx->sym->name, fixup_type ));
; 1242 :     CodeInfo->opnd[CurrOpnd].InsFixup = CreateFixup( opndx->sym, fixup_type, fixup_option );

	mov	r8d, DWORD PTR fixup_option$1$[rsp]
	mov	rcx, QWORD PTR [rdi+80]
	mov	edx, esi
	call	CreateFixup
	lea	rcx, QWORD PTR [r14+r14*2+6]
	mov	QWORD PTR [rbx+rcx*8], rax

; 1243 : 
; 1244 :     if ( opndx->instr == T_LROFFSET )

	cmp	DWORD PTR [rdi+56], 239			; 000000efH
	jne	SHORT $LN3@idata_fixu

; 1245 :         CodeInfo->opnd[CurrOpnd].InsFixup->loader_resolved = TRUE;

	or	BYTE PTR [rax+33], 1
$LN3@idata_fixu:

; 1246 : 
; 1247 : #if IMAGERELSUPP
; 1248 :     if ( opndx->instr == T_IMAGEREL && fixup_type == FIX_OFF32 )

	cmp	DWORD PTR [rdi+56], 233			; 000000e9H
	jne	SHORT $LN2@idata_fixu
	cmp	esi, 6
	jne	SHORT $LN2@idata_fixu

; 1249 :         CodeInfo->opnd[CurrOpnd].InsFixup->type = FIX_OFF32_IMGREL;

	mov	rax, QWORD PTR [rbx+rcx*8]
	mov	DWORD PTR [rax+24], 12
$LN2@idata_fixu:

; 1250 : #endif
; 1251 : #if SECTIONRELSUPP
; 1252 :     if ( opndx->instr == T_SECTIONREL && fixup_type == FIX_OFF32 )

	cmp	DWORD PTR [rdi+56], 243			; 000000f3H
	jne	SHORT $LN1@idata_fixu
	cmp	esi, 6
	jne	SHORT $LN1@idata_fixu

; 1253 :         CodeInfo->opnd[CurrOpnd].InsFixup->type = FIX_OFF32_SECREL;

	mov	rax, QWORD PTR [rbx+rcx*8]
	mov	DWORD PTR [rax+24], 13
$LN1@idata_fixu:

; 1254 : #endif
; 1255 :     DebugMsg1(("idata_fixup exit [CodeInfo.mem_type=%Xh Ofssize=%u opsiz=%u fixup.type=%u fixup.frame=%d]\n",
; 1256 :                CodeInfo->mem_type, CodeInfo->Ofssize, CodeInfo->prefix.opsiz,
; 1257 :                CodeInfo->opnd[CurrOpnd].InsFixup->type, CodeInfo->opnd[CurrOpnd].InsFixup->frame_type ));
; 1258 : 
; 1259 :     return( NOT_ERROR );

	xor	eax, eax
$LN143@idata_fixu:
	mov	rsi, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+104]
$LN141@idata_fixu:
	mov	r13, QWORD PTR [rsp+72]
	mov	r15, QWORD PTR [rsp+56]
$LN95@idata_fixu:
	mov	r14, QWORD PTR [rsp+64]
	mov	r12, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+120]
	mov	rbx, QWORD PTR [rsp+96]

; 1260 : }

	add	rsp, 88					; 00000058H
	ret	0
	npad	3
$LN133@idata_fixu:
	DD	$LN46@idata_fixu
	DD	$LN45@idata_fixu
	DD	$LN47@idata_fixu
$LN132@idata_fixu:
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	0
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
idata_fixup ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SetPtrMemtype DD 010201H
	DD	03002H
xdata	ENDS
pdata	SEGMENT
$pdata$SetPtrMemtype DD @imagerel(SetPtrMemtype#)
	DD	@imagerel(SetPtrMemtype#+512)
	DD	@imagerel($unwind$SetPtrMemtype#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
CodeInfo$ = 16
opndx$ = 24
SetPtrMemtype PROC NEAR

; 1270 : {

	push	rbx

; 1271 :     struct asym *sym = opndx->sym;
; 1272 :     int size = 0;
; 1273 : 
; 1274 :     if ( opndx->mbr )  /* the mbr field has higher priority */

	mov	rax, QWORD PTR [rdx+88]
	mov	r8, QWORD PTR [rdx+80]
	mov	rbx, rdx
	test	rax, rax
	mov	r9, rcx
	cmovne	r8, rax

; 1275 :         sym = opndx->mbr;
; 1276 : 
; 1277 :     /* v2.10: the "explicit" condition is now handled FIRST */
; 1278 : #if 1 /* v2.0: handle PF16 ptr [ebx], which didn't work in v1.96 */
; 1279 :     if ( opndx->explicit && opndx->type ) {

	test	BYTE PTR [rdx+72], 2
	je	SHORT $LN13@SetPtrMemt
	mov	rax, QWORD PTR [rdx+96]
	test	rax, rax
	je	SHORT $LN13@SetPtrMemt

; 1280 :         size = opndx->type->total_size;

	mov	edx, DWORD PTR [rax+64]

; 1281 :         CodeInfo->isfar = opndx->type->isfar;

	movzx	eax, BYTE PTR [rax+55]
	shr	al, 2
	xor	al, BYTE PTR [rcx+142]
	and	al, 4
	xor	BYTE PTR [rcx+142], al

; 1282 :     } else

	jmp	$LN3@SetPtrMemt
$LN13@SetPtrMemt:

; 1283 : #endif
; 1284 :     if ( sym ) {

	test	r8, r8
	je	$LN11@SetPtrMemt

; 1285 :         if ( sym->type ) {

	cmp	QWORD PTR [r8+88], 0
	je	SHORT $LN10@SetPtrMemt

; 1286 :             size = sym->type->total_size;

	mov	rax, QWORD PTR [r8+88]

; 1287 :             CodeInfo->isfar = sym->type->isfar;

	movzx	ecx, BYTE PTR [rax+55]
	mov	edx, DWORD PTR [rax+64]
	shr	cl, 2
	xor	cl, BYTE PTR [r9+142]
	and	cl, 4
	xor	BYTE PTR [r9+142], cl

; 1288 : 
; 1289 :             /* there's an ambiguity with pointers of size DWORD,
; 1290 :              since they can be either NEAR32 or FAR16 */
; 1291 :             if ( size == 4 && sym->type->Ofssize != CodeInfo->Ofssize )

	cmp	edx, 4
	jne	$LN3@SetPtrMemt
	mov	rax, QWORD PTR [r8+88]
	movzx	ecx, BYTE PTR [rax+52]
	cmp	cl, BYTE PTR [r9+106]
	je	$LN46@SetPtrMemt

; 1292 :                 opndx->Ofssize = sym->type->Ofssize;

	mov	BYTE PTR [rbx+69], cl

; 1293 : 
; 1294 :         } else if ( sym->mem_type == MT_PTR ) {

	jmp	$LN46@SetPtrMemt
$LN10@SetPtrMemt:
	cmp	DWORD PTR [r8+44], 195			; 000000c3H
	jne	$LN7@SetPtrMemt

; 1295 :             size = SizeFromMemtype( sym->isfar ? MT_FAR : MT_NEAR, sym->Ofssize, NULL );

	movzx	r11d, BYTE PTR [r8+55]
	movzx	r10d, BYTE PTR [r8+52]
	mov	edx, 0
	test	r11b, 16
	setne	dl
	add	edx, 129				; 00000081H
	test	dl, dl
	js	SHORT $LN27@SetPtrMemt
	cmp	edx, 63					; 0000003fH
	jne	SHORT $LN28@SetPtrMemt
	mov	edx, 64					; 00000040H
	jmp	SHORT $LN24@SetPtrMemt
$LN28@SetPtrMemt:
	and	edx, 31
	inc	edx
	jmp	SHORT $LN24@SetPtrMemt
$LN27@SetPtrMemt:
	cmp	r10d, 254				; 000000feH
	jne	SHORT $LN26@SetPtrMemt
	movzx	r10d, BYTE PTR ModuleInfo+404
$LN26@SetPtrMemt:
	add	edx, -128				; ffffffffffffff80H
	je	SHORT $LN21@SetPtrMemt
	dec	edx
	je	SHORT $LN23@SetPtrMemt
	dec	edx
	je	SHORT $LN22@SetPtrMemt
	cmp	edx, 65					; 00000041H
	je	SHORT $LN20@SetPtrMemt
	xor	edx, edx
	jmp	SHORT $LN24@SetPtrMemt
$LN20@SetPtrMemt:
	mov	ecx, DWORD PTR ModuleInfo+360
	mov	eax, 1
	shl	eax, cl
	and	al, 104					; 00000068H
	neg	al
	sbb	edx, edx
	jmp	SHORT $LN47@SetPtrMemt
$LN22@SetPtrMemt:
	mov	eax, 2
	mov	ecx, r10d
	mov	edx, eax
	shl	edx, cl
	jmp	SHORT $LN48@SetPtrMemt
$LN23@SetPtrMemt:
	mov	eax, 2
	mov	ecx, r10d
	mov	edx, eax
	shl	edx, cl
	jmp	SHORT $LN24@SetPtrMemt
$LN21@SetPtrMemt:
	mov	dl, BYTE PTR ds:55
	shr	edx, 3
$LN47@SetPtrMemt:
	mov	ecx, r10d
	mov	eax, 2
	shl	eax, cl
	and	edx, 2
$LN48@SetPtrMemt:
	add	edx, eax
$LN24@SetPtrMemt:

; 1296 :             CodeInfo->isfar = sym->isfar;

	and	BYTE PTR [r9+142], 251			; 000000fbH
	shr	r11b, 2
	and	r11b, 4
	or	BYTE PTR [r9+142], r11b

; 1297 :         } else  {

	jmp	SHORT $LN3@SetPtrMemt
$LN7@SetPtrMemt:

; 1298 :             if ( sym->isarray )

	test	BYTE PTR [r8+49], 2
	je	SHORT $LN5@SetPtrMemt

; 1299 :                 size = sym->total_size / sym->total_length;

	mov	eax, DWORD PTR [r8+64]
	xor	edx, edx
	div	DWORD PTR [r8+72]
	mov	edx, eax

; 1300 :             else

	jmp	SHORT $LN3@SetPtrMemt
$LN5@SetPtrMemt:

; 1301 :                 size = sym->total_size;

	mov	edx, DWORD PTR [r8+64]

; 1302 :         }
; 1303 :     } else {

	jmp	SHORT $LN3@SetPtrMemt
$LN11@SetPtrMemt:

; 1304 :         if ( SIZE_DATAPTR & ( 1 << ModuleInfo.model ) ) {

	mov	ecx, DWORD PTR ModuleInfo+360
	mov	eax, 1
	mov	edx, 0
	shl	al, cl

; 1305 :             DebugMsg1(("SetPtrMemtype: model with FAR data pointers\n" ));
; 1306 :             size = 2;
; 1307 :         }
; 1308 :         size += (2 << ModuleInfo.defOfssize );

	movzx	ecx, BYTE PTR ModuleInfo+405
	test	al, 104					; 00000068H
	mov	eax, 2
	cmovne	edx, eax
	shl	eax, cl
	add	edx, eax
$LN3@SetPtrMemt:

; 1309 :     }
; 1310 :     if ( size )

	test	edx, edx
	je	SHORT $LN37@SetPtrMemt
$LN46@SetPtrMemt:

; 1311 :         MemtypeFromSize( size, &opndx->mem_type );

	cmp	BYTE PTR SpecialTable+2471, 6
	mov	r8d, 205				; 000000cdH
	jne	SHORT $LN37@SetPtrMemt
	lea	rcx, OFFSET FLAT:SpecialTable+2470
	npad	4
$LL39@SetPtrMemt:
	movzx	eax, BYTE PTR [rcx]
	test	al, al
	js	SHORT $LN38@SetPtrMemt
	cmp	al, 63					; 0000003fH
	jne	SHORT $LN35@SetPtrMemt
	and	eax, 63					; 0000003fH
	jmp	SHORT $LN50@SetPtrMemt
$LN35@SetPtrMemt:
	and	eax, 31
$LN50@SetPtrMemt:
	inc	eax
	cmp	eax, edx
	je	SHORT $LN44@SetPtrMemt
$LN38@SetPtrMemt:
	add	rcx, 12
	inc	r8d
	cmp	BYTE PTR [rcx+1], 6
	je	SHORT $LL39@SetPtrMemt

; 1312 :     DebugMsg1(("SetPtrMemtype: size=%u, new memtype=0x%x\n", size, opndx->mem_type ));
; 1313 : }

	pop	rbx
	ret	0
$LN44@SetPtrMemt:

; 1311 :         MemtypeFromSize( size, &opndx->mem_type );

	movsxd	rax, r8d
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rax, OFFSET FLAT:SpecialTable
	movzx	eax, BYTE PTR [rax+rcx*4+10]
	mov	DWORD PTR [rbx+64], eax
$LN37@SetPtrMemt:

; 1312 :     DebugMsg1(("SetPtrMemtype: size=%u, new memtype=0x%x\n", size, opndx->mem_type ));
; 1313 : }

	pop	rbx
	ret	0
SetPtrMemtype ENDP
_TEXT	ENDS
EXTRN	opnd_clstab:BYTE
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
CodeInfo$ = 8
mem_type$ = 16
Set_Memtype PROC NEAR

; 1325 :     if( CodeInfo->token == T_LEA )

	mov	r8d, DWORD PTR [rcx+24]
	mov	r9, rcx
	cmp	r8d, 634				; 0000027aH
	je	$LN31@Set_Memtyp

; 1326 :         return;
; 1327 :     /* v2.05: changed. Set "data" types only. */
; 1328 :     if( mem_type == MT_EMPTY || mem_type == MT_TYPE ||
; 1329 :        mem_type == MT_NEAR || mem_type == MT_FAR )

	cmp	edx, 192				; 000000c0H
	je	$LN31@Set_Memtyp
	cmp	edx, 196				; 000000c4H
	je	$LN31@Set_Memtyp
	cmp	edx, 129				; 00000081H
	je	$LN31@Set_Memtyp
	cmp	edx, 130				; 00000082H
	je	$LN31@Set_Memtyp

; 1330 :         return;
; 1331 : 
; 1332 :     CodeInfo->mem_type = mem_type;
; 1333 : 
; 1334 :     if( CodeInfo->Ofssize > USE16 ) {

	cmp	BYTE PTR [rcx+106], 0
	mov	DWORD PTR [rcx+28], edx
	jbe	$LN30@Set_Memtyp

; 1335 :         /* if we are in use32 mode, we have to add OPSIZ prefix for
; 1336 :          * most of the 386 instructions when operand has type WORD.
; 1337 :          * Exceptions ( MOVSX and MOVZX ) are handled in check_size().
; 1338 :          */
; 1339 :         if ( IS_MEM_TYPE( mem_type, WORD ) )

	cmp	edx, 1
	je	$LN28@Set_Memtyp
	cmp	edx, 65					; 00000041H
	je	$LN28@Set_Memtyp

; 1341 : #if AMD64_SUPPORT
; 1342 :         /*
; 1343 :          * set rex Wide bit if a QWORD operand is found (not for FPU/MMX/SSE instr).
; 1344 :          * This looks pretty hackish now and is to be cleaned!
; 1345 :          * v2.01: also had issues with SSE2 MOVSD/CMPSD, now fixed!
; 1346 :          */
; 1347 :         /* v2.06: with AVX, SSE tokens may exist twice, one
; 1348 :          * for "legacy", the other for VEX encoding!
; 1349 :          */
; 1350 :         else if ( IS_MEMTYPE_SIZ( mem_type, sizeof( uint_64 ) ) ) {

	mov	eax, edx
	and	eax, 192				; 000000c0H
	cmp	eax, 128				; 00000080H
	jge	$LN31@Set_Memtyp
	and	edx, 31
	cmp	dl, 7
	jne	$LN31@Set_Memtyp

; 1351 :             switch( CodeInfo->token ) {

	cmp	r8d, 601				; 00000259H
	jl	SHORT $LN22@Set_Memtyp
	cmp	r8d, 602				; 0000025aH
	jle	$LN31@Set_Memtyp
	cmp	r8d, 617				; 00000269H
	je	$LN31@Set_Memtyp
	lea	eax, DWORD PTR [r8-1296]
	cmp	eax, 3

; 1352 :             case T_PUSH: /* for PUSH/POP, REX_W isn't needed (no 32-bit variants in 64-bit mode) */
; 1353 :             case T_POP:
; 1354 :             case T_CMPXCHG8B:
; 1355 : #if VMXSUPP
; 1356 :             case T_VMPTRLD:
; 1357 :             case T_VMPTRST:
; 1358 :             case T_VMCLEAR:
; 1359 :             case T_VMXON:
; 1360 : #endif
; 1361 :                 break;

	jbe	$LN31@Set_Memtyp
$LN22@Set_Memtyp:

; 1362 :             default:
; 1363 :                 /* don't set REX for opcodes that accept memory operands
; 1364 :                  * of any size.
; 1365 :                  */
; 1366 :                 if ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[OPND1] == OP_M_ANY ) {

	mov	r10, QWORD PTR [rcx+16]
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR [r10]
	lea	rcx, QWORD PTR [rax+rax*2]
	cmp	DWORD PTR opnd_clstab[rdx+rcx*4], -8388608 ; ffffffffff800000H
	je	$LN31@Set_Memtyp

; 1367 :                     //printf( "Set_Memtype: OP_M_ANY detected, file=%s, instr=%s\n", CurrFName[ASM], GetResWName( CodeInfo->token, NULL ) );
; 1368 :                     break;
; 1369 :                 }
; 1370 :                 /* don't set REX for FPU opcodes */
; 1371 :                 if ( CodeInfo->pinstr->cpu & P_FPU_MASK )

	movzx	eax, WORD PTR [r10+10]
	test	al, 7
	jne	$LN31@Set_Memtyp

; 1372 :                     break;
; 1373 :                 /* don't set REX for - most - MMX/SSE opcodes */
; 1374 :                 if ( CodeInfo->pinstr->cpu & P_EXT_MASK ) {

	test	ax, 65280				; 0000ff00H
	je	$LN16@Set_Memtyp

; 1375 :                     switch ( CodeInfo->token ) {

	cmp	r8d, 1482				; 000005caH
	jg	SHORT $LN36@Set_Memtyp
	je	$LN16@Set_Memtyp
	cmp	r8d, 1028				; 00000404H
	jl	$LN31@Set_Memtyp
	cmp	r8d, 1029				; 00000405H
	jle	$LN16@Set_Memtyp
	cmp	r8d, 1046				; 00000416H
	je	$LN16@Set_Memtyp
	cmp	r8d, 1092				; 00000444H
	je	$LN16@Set_Memtyp
	cmp	r8d, 1225				; 000004c9H
	je	$LN16@Set_Memtyp

; 1439 :         }
; 1440 : #endif
; 1441 :     }
; 1442 :     return;
; 1443 : }

	ret	0
$LN36@Set_Memtyp:

; 1375 :                     switch ( CodeInfo->token ) {

	cmp	r8d, 1955				; 000007a3H
	je	$LN16@Set_Memtyp
	cmp	r8d, 1977				; 000007b9H
	je	$LN16@Set_Memtyp
	cmp	r8d, 2038				; 000007f6H
	jle	$LN31@Set_Memtyp
	cmp	r8d, 2040				; 000007f8H

; 1376 :                         /* [V]CMPSD and [V]MOVSD are also candidates,
; 1377 :                          * but currently they are handled in HandleStringInstructions()
; 1378 :                          */
; 1379 :                     case T_CVTSI2SD: /* v2.06: added */
; 1380 :                     case T_CVTSI2SS: /* v2.06: added */
; 1381 :                     case T_PEXTRQ: /* v2.06: added */
; 1382 :                     case T_PINSRQ: /* v2.06: added */
; 1383 :                     case T_MOVD:
; 1384 : #if AVXSUPP
; 1385 :                     case T_VCVTSI2SD:
; 1386 :                     case T_VCVTSI2SS:
; 1387 :                     case T_VPEXTRQ:
; 1388 :                     case T_VPINSRQ:
; 1389 :                     case T_VMOVD:
; 1390 : #endif
; 1391 :                         CodeInfo->prefix.rex |= REX_W;
; 1392 :                         break;
; 1393 :                     default:
; 1394 :                         break;

	jg	$LN31@Set_Memtyp

; 1437 :                 /* setting REX.W will cause an error in codegen */
; 1438 :                 CodeInfo->prefix.rex |= REX_W;

	or	BYTE PTR [r9+8], 8

; 1439 :         }
; 1440 : #endif
; 1441 :     }
; 1442 :     return;
; 1443 : }

	ret	0
$LN28@Set_Memtyp:

; 1340 :             CodeInfo->prefix.opsiz = TRUE;

	or	BYTE PTR [rcx+9], 2

; 1439 :         }
; 1440 : #endif
; 1441 :     }
; 1442 :     return;
; 1443 : }

	ret	0
$LN30@Set_Memtyp:

; 1395 :                     }
; 1396 :                 }
; 1397 :                 else
; 1398 :                     CodeInfo->prefix.rex |= REX_W;
; 1399 :             }
; 1400 :         }
; 1401 : #endif
; 1402 : 
; 1403 :     /* v2.05: IS_MEM_TYPE() doesn't work with MT_REALx */
; 1404 :     //} else if( CodeInfo->Ofssize == USE16 && ( IS_MEM_TYPE( mem_type, DWORD ) ) ) {
; 1405 :     } else {
; 1406 :         if( IS_MEMTYPE_SIZ( mem_type, sizeof(uint_32) ) ) {

	mov	ecx, edx
	and	ecx, 192				; 000000c0H
	cmp	ecx, 128				; 00000080H
	jge	$LN31@Set_Memtyp
	mov	eax, edx
	and	eax, 31
	cmp	al, 3
	jne	SHORT $LN12@Set_Memtyp

; 1407 : 
; 1408 :             /* in 16bit mode, a DWORD memory access usually requires an OPSIZ
; 1409 :              * prefix. A few instructions, which access m16:16 operands,
; 1410 :              * are exceptions.
; 1411 :              */
; 1412 :             switch( CodeInfo->token ) {

	add	r8d, -455				; fffffffffffffe39H
	cmp	r8d, 183				; 000000b7H
	ja	SHORT $LN8@Set_Memtyp
	lea	rdx, OFFSET FLAT:__ImageBase
	movsxd	rax, r8d
	movzx	eax, BYTE PTR $LN37@Set_Memtyp[rdx+rax]
	mov	ecx, DWORD PTR $LN38@Set_Memtyp[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN8@Set_Memtyp:

; 1413 :             case T_LDS:
; 1414 :             case T_LES:
; 1415 :             case T_LFS:
; 1416 :             case T_LGS:
; 1417 :             case T_LSS:
; 1418 :             case T_CALL: /* v2.0: added */
; 1419 :             case T_JMP:  /* v2.0: added */
; 1420 :                 /* in these cases, opsize does NOT need to be changed  */
; 1421 :                 break;
; 1422 :             default:
; 1423 :                 CodeInfo->prefix.opsiz = TRUE;

	or	BYTE PTR [r9+9], 2

; 1439 :         }
; 1440 : #endif
; 1441 :     }
; 1442 :     return;
; 1443 : }

	ret	0
$LN12@Set_Memtyp:

; 1424 :                 break;
; 1425 :             }
; 1426 :         }
; 1427 : #if AMD64_SUPPORT
; 1428 :         /* v2.06: added because in v2.05, 64-bit memory operands were
; 1429 :          * accepted in 16-bit code
; 1430 :          */
; 1431 :         else if ( IS_MEMTYPE_SIZ( mem_type, sizeof(uint_64) ) ) {

	cmp	ecx, 128				; 00000080H
	jge	SHORT $LN31@Set_Memtyp
	and	edx, 31
	cmp	dl, 7
	jne	SHORT $LN31@Set_Memtyp

; 1432 :             if ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[OPND1] == OP_M_ANY ) {

	mov	r10, QWORD PTR [r9+16]
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR [r10]
	lea	rcx, QWORD PTR [rax+rax*2]
	cmp	DWORD PTR opnd_clstab[rdx+rcx*4], -8388608 ; ffffffffff800000H
	je	SHORT $LN31@Set_Memtyp

; 1433 :                 //printf( "Set_Memtype: OP_M_ANY detected, file=%s, instr=%s\n", CurrFName[ASM], GetResWName( CodeInfo->token, NULL ) );
; 1434 :             } else if ( CodeInfo->pinstr->cpu & ( P_FPU_MASK | P_EXT_MASK ) ) {

	test	WORD PTR [r10+10], 65287		; 0000ff07H
	jne	SHORT $LN31@Set_Memtyp

; 1435 :                 ;
; 1436 :             } else if ( CodeInfo->token != T_CMPXCHG8B )

	cmp	r8d, 617				; 00000269H
	je	SHORT $LN31@Set_Memtyp
$LN16@Set_Memtyp:

; 1437 :                 /* setting REX.W will cause an error in codegen */
; 1438 :                 CodeInfo->prefix.rex |= REX_W;

	or	BYTE PTR [r9+8], 8
$LN31@Set_Memtyp:

; 1439 :         }
; 1440 : #endif
; 1441 :     }
; 1442 :     return;
; 1443 : }

	ret	0
	npad	2
$LN38@Set_Memtyp:
	DD	$LN31@Set_Memtyp
	DD	$LN8@Set_Memtyp
$LN37@Set_Memtyp:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
Set_Memtype ENDP
_TEXT	ENDS
EXTRN	Frame_Datum:WORD
EXTRN	Frame_Type:BYTE
EXTRN	EmitWarn:NEAR
EXTRN	GetResWName:NEAR
xdata	SEGMENT
$unwind$memory_operand DD 092301H
	DD	09d423H
	DD	0ac41eH
	DD	0b7419H
	DD	0e3412H
	DD	0e20dH
xdata	ENDS
pdata	SEGMENT
$pdata$memory_operand DD @imagerel(memory_operand#)
	DD	@imagerel(memory_operand#+289)
	DD	@imagerel($unwind$memory_operand#)
pdata	ENDS
xdata	SEGMENT
$chain$7$memory_operand DD 081421H
	DD	07f414H
	DD	08e40fH
	DD	0c640aH
	DD	0d5405H
	DD	@imagerel(memory_operand#)
	DD	@imagerel(memory_operand#+289)
	DD	@imagerel($unwind$memory_operand#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$memory_operand DD @imagerel(memory_operand#+289)
	DD	@imagerel(memory_operand#+2556)
	DD	@imagerel($chain$7$memory_operand#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$1$ = 128
CodeInfo$ = 128
CurrOpnd$ = 136
tv1159 = 144
opndx$ = 144
with_fixup$ = 152
memory_operand PROC NEAR

; 1455 : {

	mov	BYTE PTR [rsp+32], r9b
	mov	DWORD PTR [rsp+16], edx
	sub	rsp, 120				; 00000078H
	mov	QWORD PTR [rsp+112], rbx

; 1456 :     char                ss = SCALE_FACTOR_1;
; 1457 :     int                 index;
; 1458 :     int                 base;
; 1459 :     int                 j;
; 1460 :     struct asym         *sym;
; 1461 :     uint_8              Ofssize;
; 1462 :     enum fixup_types    fixup_type;
; 1463 : 
; 1464 :     DebugMsg1(("memory_operand(opndx.value=%X / sym=%s / memtype=%Xh, with_fixup=%u) enter, [CodeInfo->memtype=%Xh, Ofssize=%u, adrsiz=%u]\n",
; 1465 :                opndx->value, opndx->sym ? opndx->sym->name : "NULL", opndx->mem_type, with_fixup, CodeInfo->mem_type, CodeInfo->Ofssize, CodeInfo->prefix.adrsiz ));
; 1466 : 
; 1467 :     /* v211: use full 64-bit value */
; 1468 :     //CodeInfo->opnd[CurrOpnd].data = opndx->value;
; 1469 :     CodeInfo->opnd[CurrOpnd].data64 = opndx->value64;

	mov	eax, edx
	mov	QWORD PTR [rsp+88], rdi
	mov	QWORD PTR [rsp+80], r12
	mov	QWORD PTR [rsp+72], r13
	lea	r13, QWORD PTR [rax+rax*2]
	mov	QWORD PTR tv1159[rsp], rax
	mov	rax, QWORD PTR [r8]

; 1470 :     CodeInfo->opnd[CurrOpnd].type = OP_M;

	mov	DWORD PTR [rcx+r13*8+32], -1887436800	; ffffffff8f800000H
	mov	QWORD PTR [rcx+r13*8+40], rax

; 1471 : 
; 1472 :     sym = opndx->sym;

	mov	rdx, QWORD PTR [r8+80]
	mov	rbx, rcx

; 1473 : 
; 1474 :     segm_override( opndx, CodeInfo );

	mov	rcx, QWORD PTR [r8+48]
	mov	r12, r8
	mov	QWORD PTR sym$1$[rsp], rdx
	test	rcx, rcx
	lea	r8, OFFSET FLAT:__ImageBase
	je	$LN113@memory_ope
	cmp	BYTE PTR [rcx], 2
	jne	SHORT $LN118@memory_ope
	mov	eax, DWORD PTR [rcx+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	edi, BYTE PTR SpecialTable[r8+rcx*4+10]
	mov	rax, rdi
	add	rax, rax
	cmp	BYTE PTR SegAssumeTable[r8+rax*8+8], 0
	je	SHORT $LN117@memory_ope
	mov	ecx, 183				; 000000b7H
	call	EmitError
	mov	rdx, QWORD PTR sym$1$[rsp]
	jmp	SHORT $LN113@memory_ope
$LN117@memory_ope:
	test	rbx, rbx
	je	SHORT $LN116@memory_ope
	cmp	BYTE PTR [rbx+106], 2
	jne	SHORT $LN116@memory_ope
	cmp	edi, 4
	jge	SHORT $LN116@memory_ope
	mov	ecx, 275				; 00000113H
	call	EmitError
	mov	rdx, QWORD PTR sym$1$[rsp]
	jmp	SHORT $LN113@memory_ope
$LN116@memory_ope:
	mov	ecx, edi
	call	GetOverrideAssume
	test	rbx, rbx
	je	SHORT $LN114@memory_ope
	mov	ecx, DWORD PTR [rbx+4]
	mov	DWORD PTR [rbx+4], edi
	mov	DWORD PTR LastRegOverride, ecx
	jmp	SHORT $LN114@memory_ope
$LN118@memory_ope:
	mov	rcx, QWORD PTR [rcx+8]
	call	SymFind
$LN114@memory_ope:
	test	rax, rax
	je	SHORT $LN187@memory_ope
	mov	ecx, DWORD PTR [rax+40]
	cmp	ecx, 4
	je	SHORT $LN112@memory_ope
	cmp	ecx, 3
	jne	SHORT $LN186@memory_ope
$LN112@memory_ope:
	mov	rdx, QWORD PTR sym$1$[rsp]
	mov	QWORD PTR SegOverride, rax
	jmp	SHORT $LN113@memory_ope
$LN186@memory_ope:
	mov	rdx, QWORD PTR sym$1$[rsp]
	jmp	SHORT $LN113@memory_ope
$LN187@memory_ope:
	mov	rdx, QWORD PTR sym$1$[rsp]
$LN113@memory_ope:

; 1475 : 
; 1476 :     /* change pointer types ( MT_NEAR, MT_FAR, MT_PTR */
; 1477 :     /* v2.04a: should not be called if OFFSET was used */
; 1478 :     //if ( opndx->mem_type == MT_PTR ) /* this was before v2.04 */
; 1479 :     //if ( ( opndx->mem_type & MT_SPECIAL_MASK ) == MT_ADDRESS )
; 1480 :     /* v2.05: change reverted */
; 1481 :     //if ( ( opndx->mem_type & MT_SPECIAL_MASK ) == MT_ADDRESS && opndx->instr == EMPTY )
; 1482 :     if ( opndx->mem_type == MT_PTR )

	mov	eax, DWORD PTR [r12+64]
	mov	QWORD PTR [rsp+104], rbp
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+64], r14
	mov	QWORD PTR [rsp+56], r15
	xor	r15d, r15d
	cmp	eax, 195				; 000000c3H
	lea	rsi, OFFSET FLAT:SpecialTable+2470
	mov	ebp, 205				; 000000cdH
	lea	r14d, QWORD PTR [r15+1]
	jne	SHORT $LN99@memory_ope

; 1483 :         SetPtrMemtype( CodeInfo, opndx );

	mov	rdx, r12
	mov	rcx, rbx
	call	SetPtrMemtype
	lea	r11, OFFSET FLAT:__ImageBase
	jmp	$LN142@memory_ope
$LN99@memory_ope:

; 1484 :     else if ( ( opndx->mem_type & MT_SPECIAL_MASK ) == MT_ADDRESS ) {

	and	eax, 192				; 000000c0H
	cmp	al, -128				; ffffffffffffff80H
	jne	$LN193@memory_ope

; 1485 :         int size;
; 1486 :         if ( opndx->Ofssize == USE_EMPTY && sym )

	cmp	BYTE PTR [r12+69], 254			; 000000feH
	jne	SHORT $LN96@memory_ope
	test	rdx, rdx
	je	SHORT $LN96@memory_ope

; 1487 :             opndx->Ofssize = GetSymOfssize( sym );

	mov	rcx, rdx
	call	GetSymOfssize
	mov	BYTE PTR [r12+69], al
$LN96@memory_ope:

; 1488 :         /* v2.09: use opndx->type ( for MT_PROC ) */
; 1489 :         //size = SizeFromMemtype( opndx->mem_type, opndx->Ofssize, NULL );
; 1490 :         size = SizeFromMemtype( opndx->mem_type, opndx->Ofssize, opndx->type );

	mov	edx, DWORD PTR [r12+64]
	movzx	r8d, BYTE PTR [r12+69]
	mov	rcx, QWORD PTR [r12+96]
	test	dl, dl
	js	SHORT $LN132@memory_ope
	cmp	edx, 63					; 0000003fH
	jne	SHORT $LN133@memory_ope
	mov	edx, 64					; 00000040H
	jmp	$LN129@memory_ope
$LN133@memory_ope:
	and	edx, 31
	inc	edx
	jmp	$LN129@memory_ope
$LN132@memory_ope:
	cmp	r8d, 254				; 000000feH
	jne	SHORT $LN131@memory_ope
	movzx	r8d, BYTE PTR ModuleInfo+404
$LN131@memory_ope:
	add	edx, -128				; ffffffffffffff80H
	je	SHORT $LN126@memory_ope
	dec	edx
	je	SHORT $LN128@memory_ope
	dec	edx
	je	SHORT $LN127@memory_ope
	sub	edx, 65					; 00000041H
	je	SHORT $LN125@memory_ope
	dec	edx
	jne	SHORT $LN123@memory_ope
	test	rcx, rcx
	je	SHORT $LN123@memory_ope
	mov	edx, DWORD PTR [rcx+64]
	jmp	SHORT $LN129@memory_ope
$LN123@memory_ope:
	mov	edx, r15d
	jmp	SHORT $LN129@memory_ope
$LN125@memory_ope:
	mov	ecx, DWORD PTR ModuleInfo+360
	mov	eax, r14d
	shl	eax, cl
	mov	ecx, r8d
	and	al, 104					; 00000068H
	neg	al
	mov	eax, 2
	sbb	edx, edx
	shl	eax, cl
	and	edx, 2
	add	edx, eax
	jmp	SHORT $LN129@memory_ope
$LN127@memory_ope:
	mov	ecx, r8d
	mov	edx, 2
	shl	edx, cl
	add	edx, 2
	jmp	SHORT $LN129@memory_ope
$LN128@memory_ope:
	mov	ecx, r8d
	mov	edx, 2
	shl	edx, cl
	jmp	SHORT $LN129@memory_ope
$LN126@memory_ope:
	mov	dl, BYTE PTR [rcx+55]
	mov	eax, 2
	mov	ecx, r8d
	shr	edx, 3
	shl	eax, cl
	and	edx, 2
	add	edx, eax
$LN129@memory_ope:

; 1491 :         MemtypeFromSize( size, &opndx->mem_type );

	cmp	BYTE PTR SpecialTable+2471, 6
	mov	r8d, ebp
	jne	SHORT $LN194@memory_ope
	mov	rcx, rsi
$LL144@memory_ope:
	movzx	eax, BYTE PTR [rcx]
	test	al, al
	js	SHORT $LN143@memory_ope
	cmp	al, 63					; 0000003fH
	jne	SHORT $LN140@memory_ope
	and	eax, 63					; 0000003fH
	inc	eax
	cmp	eax, edx
	jne	SHORT $LN143@memory_ope
	movsxd	rax, r8d
	lea	r11, OFFSET FLAT:__ImageBase
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR SpecialTable[r11+rcx*4+10]
	mov	DWORD PTR [r12+64], eax
	jmp	SHORT $LN142@memory_ope
$LN140@memory_ope:
	and	eax, 31
	inc	eax
	cmp	eax, edx
	je	SHORT $LN175@memory_ope
$LN143@memory_ope:
	add	rcx, 12
	inc	r8d
	cmp	BYTE PTR [rcx+1], 6
	je	SHORT $LL144@memory_ope

; 1512 : #endif
; 1513 :             if ( MemtypeFromSize( opndx->mbr->total_size, &mem_type ) == NOT_ERROR )

	lea	r11, OFFSET FLAT:__ImageBase
	jmp	SHORT $LN142@memory_ope
$LN175@memory_ope:

; 1491 :         MemtypeFromSize( size, &opndx->mem_type );

	movsxd	rax, r8d
	lea	r11, OFFSET FLAT:__ImageBase
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR SpecialTable[r11+rcx*4+10]
	mov	DWORD PTR [r12+64], eax
	jmp	SHORT $LN142@memory_ope
$LN193@memory_ope:

; 1455 : {

	lea	r11, OFFSET FLAT:__ImageBase
	jmp	SHORT $LN142@memory_ope
$LN194@memory_ope:

; 1491 :         MemtypeFromSize( size, &opndx->mem_type );

	lea	r11, OFFSET FLAT:__ImageBase
$LN142@memory_ope:

; 1492 :     }
; 1493 : 
; 1494 :     Set_Memtype( CodeInfo, opndx->mem_type );

	mov	edx, DWORD PTR [r12+64]
	mov	rcx, rbx
	call	Set_Memtype

; 1495 :     if( opndx->mbr != NULL ) {

	mov	rax, QWORD PTR [r12+88]
	mov	edi, 3
	test	rax, rax
	je	$LN90@memory_ope

; 1496 :         /* if the struct field is just another struct, use it's total size
; 1497 :          * to set CodeInfo->mem_type.
; 1498 :          */
; 1499 :         //if ( opndx->mbr->mem_type == MT_TYPE ) {
; 1500 :         /* v2: don't overwrite opndx->mem_type,
; 1501 :          *    testcase: cmp (dword ptr <struct_field>), 0
; 1502 :          */
; 1503 :         if ( opndx->mbr->mem_type == MT_TYPE && opndx->mem_type == MT_EMPTY ) {

	cmp	DWORD PTR [rax+44], 196			; 000000c4H
	jne	$LN91@memory_ope
	cmp	DWORD PTR [r12+64], 192			; 000000c0H
	jne	SHORT $LN91@memory_ope

; 1504 :             enum memtype mem_type;
; 1505 :             DebugMsg1(("memory_operand: mbr %s has mem_type MT_TYPE, total_size=%u\n", opndx->mbr->name, opndx->mbr->total_size ));
; 1506 : #if AVXSUPP
; 1507 :             if (CodeInfo->token == T_VMOVSS){       //MemtypeFromSize returns OP_M128

	cmp	DWORD PTR [rbx+24], 1988		; 000007c4H
	jne	SHORT $LN93@memory_ope

; 1508 :               mem_type = MT_DWORD;                  //but we need MT_DWORD ;habran
; 1509 :               Set_Memtype(CodeInfo, mem_type);

	mov	edx, edi
	mov	rcx, rbx
	call	Set_Memtype

; 1510 :          }
; 1511 :         else

	jmp	SHORT $LN91@memory_ope
$LN93@memory_ope:

; 1512 : #endif
; 1513 :             if ( MemtypeFromSize( opndx->mbr->total_size, &mem_type ) == NOT_ERROR )

	cmp	BYTE PTR SpecialTable+2471, 6
	mov	ecx, DWORD PTR [rax+64]
	jne	SHORT $LN91@memory_ope
	npad	7
$LL154@memory_ope:
	movzx	eax, BYTE PTR [rsi]
	test	al, al
	js	SHORT $LN153@memory_ope
	cmp	al, 63					; 0000003fH
	jne	SHORT $LN150@memory_ope
	and	eax, 63					; 0000003fH
	inc	eax
	cmp	eax, ecx
	jne	SHORT $LN153@memory_ope
	movsxd	rax, ebp
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	edx, BYTE PTR SpecialTable[r11+rcx*4+10]
	jmp	SHORT $LN181@memory_ope
$LN150@memory_ope:
	and	eax, 31
	inc	eax
	cmp	eax, ecx
	je	SHORT $LN177@memory_ope
$LN153@memory_ope:
	add	rsi, 12
	inc	ebp
	cmp	BYTE PTR [rsi+1], 6
	je	SHORT $LL154@memory_ope
	jmp	SHORT $LN91@memory_ope
$LN177@memory_ope:
	movsxd	rax, ebp
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	edx, BYTE PTR SpecialTable[r11+rcx*4+10]
$LN181@memory_ope:

; 1514 :                 Set_Memtype( CodeInfo, mem_type );

	mov	rcx, rbx
	call	Set_Memtype
$LN91@memory_ope:

; 1515 :         }
; 1516 :         //else  /* v2: obsolete */
; 1517 :         //    Set_Memtype( CodeInfo, opndx->mbr->mem_type );
; 1518 :         /* v2.06b: tell codegen that the member is a forward ref */
; 1519 :         if ( opndx->mbr->state == SYM_UNDEFINED )

	mov	rax, QWORD PTR [r12+88]
	cmp	DWORD PTR [rax+40], r15d
	jne	SHORT $LN90@memory_ope

; 1520 :             CodeInfo->undef_sym = TRUE;

	or	BYTE PTR [rbx+142], 64			; 00000040H
$LN90@memory_ope:

; 1521 :     }
; 1522 : 
; 1523 :     /* instruction-specific handling */
; 1524 :     switch ( CodeInfo->token ) {

	mov	eax, DWORD PTR [rbx+24]
	add	eax, -455				; fffffe39H
	cmp	eax, r14d
	ja	$LN82@memory_ope

; 1525 :     case T_JMP:
; 1526 :     case T_CALL:
; 1527 :         /* the 2 branch instructions are peculiar because they
; 1528 :          * will work with an unsized label.
; 1529 :          */
; 1530 :         /* v1.95: convert MT_NEAR/MT_FAR and display error if no type.
; 1531 :          * For memory operands, expressions of type MT_NEAR/MT_FAR are
; 1532 :          * call [bx+<code_label>]
; 1533 :          */
; 1534 :         if ( CodeInfo->mem_type == MT_EMPTY ) {

	cmp	DWORD PTR [rbx+28], 192			; 000000c0H
	jne	SHORT $LN86@memory_ope

; 1535 :             /* with -Zm, no size needed for indirect CALL/JMP */
; 1536 :             if ( ModuleInfo.m510 == FALSE &&
; 1537 :                 ( Parse_Pass > PASS_1 && opndx->sym == NULL ) ) {

	test	BYTE PTR ModuleInfo+408, 128		; 00000080H
	jne	SHORT $LN85@memory_ope
	cmp	DWORD PTR Parse_Pass, r15d
	jbe	SHORT $LN85@memory_ope
	cmp	QWORD PTR [r12+80], r15

; 1538 :                 DebugMsg1(("memory_operand, JMP/CALL: CodeInfo->memtype=empty, instruction operand must have size\n" ));
; 1539 :                 return( EmitError( INSTRUCTION_OPERAND_MUST_HAVE_SIZE ) );

	je	$LN195@memory_ope
$LN85@memory_ope:

; 1540 :             }
; 1541 : #if AMD64_SUPPORT
; 1542 :             opndx->mem_type = (CodeInfo->Ofssize == USE64) ? MT_QWORD : (CodeInfo->Ofssize == USE32) ? MT_DWORD : MT_WORD;

	mov	al, BYTE PTR [rbx+106]
	cmp	al, 2
	jne	SHORT $LN102@memory_ope
	mov	edx, 7
	jmp	SHORT $LN103@memory_ope
$LN102@memory_ope:
	mov	edx, r14d
	cmp	al, dl
	cmove	edx, edi
$LN103@memory_ope:

; 1543 : #else
; 1544 :             opndx->mem_type = (CodeInfo->Ofssize == USE32) ? MT_DWORD : MT_WORD;
; 1545 : #endif
; 1546 :             Set_Memtype( CodeInfo, opndx->mem_type );

	mov	rcx, rbx
	mov	DWORD PTR [r12+64], edx
	call	Set_Memtype
$LN86@memory_ope:

; 1547 :             DebugMsg1(("memory_operand, JMP/CALL: CodeInfo->memtype set to %Xh\n", CodeInfo->mem_type ));
; 1548 :         }
; 1549 :         j = SizeFromMemtype( CodeInfo->mem_type, CodeInfo->Ofssize, NULL );

	mov	r8d, DWORD PTR [rbx+28]
	movzx	r10d, BYTE PTR [rbx+106]
	test	r8b, r8b
	mov	r9d, r10d
	js	SHORT $LN167@memory_ope
	cmp	r8d, 63					; 0000003fH
	je	$LN83@memory_ope
	mov	edx, r8d
	and	edx, 31
	inc	edx
	jmp	SHORT $LN164@memory_ope
$LN167@memory_ope:
	cmp	r10d, 254				; 000000feH
	jne	SHORT $LN166@memory_ope
	movzx	r9d, BYTE PTR ModuleInfo+404
$LN166@memory_ope:
	mov	ecx, r8d
	add	ecx, -128				; ffffffffffffff80H
	je	SHORT $LN161@memory_ope
	dec	ecx
	je	SHORT $LN163@memory_ope
	dec	ecx
	je	SHORT $LN162@memory_ope
	cmp	ecx, 65					; 00000041H
	jne	SHORT $LN84@memory_ope
	mov	ecx, DWORD PTR ModuleInfo+360
	mov	eax, 2
	shl	r14d, cl
	mov	ecx, r9d
	and	r14b, 104				; 00000068H
	neg	r14b
	sbb	edx, edx
	shl	eax, cl
	and	edx, 2
	add	edx, eax
	jmp	SHORT $LN164@memory_ope
$LN162@memory_ope:
	mov	ecx, r9d
	mov	edx, 2
	shl	edx, cl
	add	edx, 2
	jmp	SHORT $LN164@memory_ope
$LN163@memory_ope:
	mov	ecx, r9d
	mov	edx, 2
	shl	edx, cl
	jmp	SHORT $LN164@memory_ope
$LN161@memory_ope:
	mov	dl, BYTE PTR ds:55
	mov	ecx, r9d
	mov	eax, 2
	shr	edx, 3
	shl	eax, cl
	and	edx, 2
	add	edx, eax
$LN164@memory_ope:

; 1550 :         if ( ( j == 1 || j > 6 )
; 1551 : #if AMD64_SUPPORT
; 1552 :             && ( CodeInfo->Ofssize != USE64 )
; 1553 : #endif
; 1554 :         ) {

	cmp	edx, 1
	je	SHORT $LN83@memory_ope
	cmp	edx, 6
	jle	SHORT $LN84@memory_ope
$LN83@memory_ope:
	cmp	r10b, 2
	je	SHORT $LN84@memory_ope

; 1555 :             /* CALL/JMP possible for WORD/DWORD/FWORD memory operands only */
; 1556 :             DebugMsg1(("memory_operand: invalid operand, size=%u\n", j ));
; 1557 :             return( EmitError( INVALID_OPERAND_SIZE ) );

	mov	ecx, 71					; 00000047H
	call	EmitError
	jmp	$LN100@memory_ope
$LN84@memory_ope:

; 1558 :         }
; 1559 : 
; 1560 :         if( opndx->mem_type == MT_FAR || CodeInfo->mem_type == MT_FWORD ||
; 1561 : #if AMD64_SUPPORT
; 1562 :            ( CodeInfo->mem_type == MT_TBYTE && CodeInfo->Ofssize == USE64 ) ||
; 1563 : #endif
; 1564 :             ( CodeInfo->mem_type == MT_DWORD &&
; 1565 :               (( CodeInfo->Ofssize == USE16 && opndx->Ofssize != USE32 ) ||
; 1566 :                ( CodeInfo->Ofssize == USE32 && opndx->Ofssize == USE16 )))) {

	cmp	DWORD PTR [r12+64], 130			; 00000082H
	je	SHORT $LN79@memory_ope
	cmp	r8d, 5
	je	SHORT $LN79@memory_ope
	cmp	r8d, 9
	jne	SHORT $LN80@memory_ope
	cmp	r10b, 2
	je	SHORT $LN79@memory_ope
$LN80@memory_ope:
	cmp	r8d, edi
	jne	SHORT $LN82@memory_ope
	test	r10b, r10b
	jne	SHORT $LN78@memory_ope
	cmp	BYTE PTR [r12+69], 1
	jne	SHORT $LN79@memory_ope
$LN78@memory_ope:
	cmp	r10b, 1
	jne	SHORT $LN82@memory_ope
	cmp	BYTE PTR [r12+69], r15b
	jne	SHORT $LN82@memory_ope
$LN79@memory_ope:

; 1567 :             CodeInfo->isfar = TRUE;

	or	BYTE PTR [rbx+142], 4
$LN82@memory_ope:

; 1568 :         }
; 1569 :         DebugMsg1(("memory_operand: JMP/CALL, CodeInfo->far=%u\n", CodeInfo->isfar ));
; 1570 :         break;
; 1571 :     }
; 1572 : 
; 1573 :     if ( ( CodeInfo->mem_type & MT_SPECIAL) == 0 ) {

	mov	eax, DWORD PTR [rbx+28]
	test	al, al
	js	$LN77@memory_ope

; 1574 : #if AVXSUPP
; 1575 :         if ((CodeInfo->mem_type & 0x3f) == MT_YMMWORD)

	mov	ecx, eax
	and	ecx, 63					; 0000003fH
	cmp	ecx, 31
	jne	SHORT $LN76@memory_ope

; 1576 :           CodeInfo->opnd[CurrOpnd].type = OP_M256;

	mov	DWORD PTR [rbx+r13*8+32], 268435456	; 10000000H
$LN58@memory_ope:

; 1617 :             }
; 1618 :             break;
; 1619 :         }
; 1620 :     }
; 1621 : 
; 1622 :     base = ( opndx->base_reg ? opndx->base_reg->tokval : EMPTY );

	mov	rax, QWORD PTR [r12+24]
	mov	esi, -2
	test	rax, rax
	je	$LN104@memory_ope
	mov	ebp, DWORD PTR [rax+16]
	jmp	$LN105@memory_ope
$LN76@memory_ope:

; 1577 :         else if ((CodeInfo->mem_type & 0x3f) == MT_ZMMWORD)

	cmp	ecx, 63					; 0000003fH
	jne	SHORT $LN74@memory_ope

; 1578 :           CodeInfo->opnd[CurrOpnd].type = OP_M512;

	mov	DWORD PTR [rbx+r13*8+32], 536870912	; 20000000H

; 1579 :         else {

	jmp	SHORT $LN58@memory_ope
$LN74@memory_ope:

; 1580 : #endif
; 1581 :           switch (CodeInfo->mem_type & MT_SIZE_MASK) {

	and	eax, 31
	cmp	eax, 15
	ja	SHORT $LN58@memory_ope
	cdqe
	mov	ecx, DWORD PTR $LN184@memory_ope[r11+rax*4]
	add	rcx, r11
	jmp	rcx
$LN70@memory_ope:

; 1582 :             /* size is encoded 0-based */
; 1583 :             case  MT_BYTE:    CodeInfo->opnd[CurrOpnd].type = OP_M08;  break;

	mov	DWORD PTR [rbx+r13*8+32], 8388608	; 00800000H
	jmp	SHORT $LN58@memory_ope
$LN69@memory_ope:

; 1584 :             case  MT_WORD:    CodeInfo->opnd[CurrOpnd].type = OP_M16;  break;

	mov	DWORD PTR [rbx+r13*8+32], 16777216	; 01000000H
	jmp	SHORT $LN58@memory_ope
$LN68@memory_ope:

; 1585 :             case  MT_DWORD:   CodeInfo->opnd[CurrOpnd].type = OP_M32;  break;

	mov	DWORD PTR [rbx+r13*8+32], 33554432	; 02000000H
	jmp	SHORT $LN58@memory_ope
$LN67@memory_ope:

; 1586 :             case  MT_FWORD:   CodeInfo->opnd[CurrOpnd].type = OP_M48;  break;

	mov	DWORD PTR [rbx+r13*8+32], 1073741824	; 40000000H
	jmp	SHORT $LN58@memory_ope
$LN66@memory_ope:

; 1587 :             case  MT_QWORD:   CodeInfo->opnd[CurrOpnd].type = OP_M64;  break;

	mov	DWORD PTR [rbx+r13*8+32], 67108864	; 04000000H
	jmp	SHORT $LN58@memory_ope
$LN65@memory_ope:

; 1588 :             case  MT_TBYTE:   CodeInfo->opnd[CurrOpnd].type = OP_M80;  break;

	mov	DWORD PTR [rbx+r13*8+32], -2147483648	; ffffffff80000000H
	jmp	$LN58@memory_ope
$LN64@memory_ope:

; 1589 :             case  MT_OWORD:   CodeInfo->opnd[CurrOpnd].type = OP_M128; break;

	mov	DWORD PTR [rbx+r13*8+32], 134217728	; 08000000H

; 1590 : #ifdef DEBUG_OUT
; 1591 :             default:
; 1592 :               DebugMsg1(("memory_operand: unexpected mem_type=%X\n", CodeInfo->mem_type));
; 1593 :               /**/myassert(0);
; 1594 : #endif
; 1595 :             }
; 1596 : #if AVXSUPP
; 1597 :           }

	jmp	$LN58@memory_ope
$LN77@memory_ope:

; 1598 : #endif
; 1599 : #if 0 /* v2.06: the wide flag isn't set for memory operands currently, */
; 1600 :         if ( CodeInfo->opnd_type[CurrOpnd] & ( OP_M16 | OP_M32 | OP_M64 ) )
; 1601 :             CodeInfo->iswide = 1;
; 1602 : #endif
; 1603 :     } else if ( CodeInfo->mem_type == MT_EMPTY ) {

	cmp	eax, 192				; 000000c0H
	jne	$LN58@memory_ope

; 1604 :         /* v2.05: added */
; 1605 :         switch ( CodeInfo->token ) {

	mov	eax, DWORD PTR [rbx+24]
	cmp	eax, 599				; 00000257H
	jl	$LN58@memory_ope
	cmp	eax, 600				; 00000258H
	jle	SHORT $LN59@memory_ope
	cmp	eax, 602				; 0000025aH
	jg	$LN58@memory_ope

; 1611 :             }
; 1612 :             break;
; 1613 :         case T_PUSH:
; 1614 :         case T_POP:
; 1615 :             if ( opndx->mem_type == MT_TYPE ) {

	cmp	DWORD PTR [r12+64], 196			; 000000c4H
	jne	$LN58@memory_ope

; 1616 :                 return( EmitError( INVALID_INSTRUCTION_OPERANDS ) );

	mov	ecx, 49					; 00000031H
	call	EmitError
	jmp	$LN100@memory_ope
$LN59@memory_ope:

; 1606 :         case T_INC:
; 1607 :         case T_DEC:
; 1608 :             /* hjwasm v1.94-v2.04 accepted unsized operand for INC/DEC */
; 1609 :             if ( opndx->sym == NULL ) {

	cmp	QWORD PTR [r12+80], r15
	jne	$LN58@memory_ope
$LN195@memory_ope:

; 1610 :                 return( EmitError( INSTRUCTION_OPERAND_MUST_HAVE_SIZE ) );

	mov	ecx, 182				; 000000b6H
	call	EmitError
	jmp	$LN100@memory_ope
$LN104@memory_ope:

; 1617 :             }
; 1618 :             break;
; 1619 :         }
; 1620 :     }
; 1621 : 
; 1622 :     base = ( opndx->base_reg ? opndx->base_reg->tokval : EMPTY );

	mov	ebp, esi
$LN105@memory_ope:

; 1623 :     index = ( opndx->idx_reg ? opndx->idx_reg->tokval : EMPTY );

	mov	rax, QWORD PTR [r12+32]
	test	rax, rax
	je	SHORT $LN106@memory_ope
	mov	esi, DWORD PTR [rax+16]
$LN106@memory_ope:

; 1624 :     CodeInfo->indexreg = GetRegNo( index );
; 1625 :     CodeInfo->basereg = GetRegNo( base );
; 1626 :     /* use base + index from here - don't use opndx-> base_reg/idx_reg! */
; 1627 : 
; 1628 : #if 0 /* v2.10: moved to expreval.c */
; 1629 :     if ( sym && sym->state == SYM_STACK ) {
; 1630 :         if( base != EMPTY ) {
; 1631 :             if( index != EMPTY ) {
; 1632 :                 /* no free index register */
; 1633 :                 return( EmitError( MULTIPLE_INDEX_REGISTERS_NOT_ALLOWED ) );
; 1634 :             } else {
; 1635 :                 index = base;
; 1636 :             }
; 1637 :         }
; 1638 :         base = basereg[CodeInfo->Ofssize];
; 1639 :     }
; 1640 : #endif
; 1641 : 
; 1642 :     /* check for base registers */
; 1643 : 
; 1644 :     if ( base != EMPTY ) {

	cmp	ebp, -2
	movsxd	rax, esi
	lea	rdx, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR SpecialTable[r11+rdx*4+10]
	mov	BYTE PTR [rbx+112], al
	movsxd	rax, ebp
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR SpecialTable[r11+rcx*4+10]
	mov	BYTE PTR [rbx+113], al
	je	SHORT $LN49@memory_ope

; 1645 :         if ( ( ( GetValueSp( base ) & OP_R32) && CodeInfo->Ofssize == USE32 ) ||
; 1646 : #if AMD64_SUPPORT
; 1647 :             ( ( GetValueSp( base ) & OP_R64) && CodeInfo->Ofssize == USE64 ) ||
; 1648 : #endif
; 1649 :             ( ( GetValueSp( base ) & OP_R16) && CodeInfo->Ofssize == USE16 ) )

	mov	eax, DWORD PTR SpecialTable[r11+rcx*4]
	test	al, 4
	je	SHORT $LN52@memory_ope
	cmp	BYTE PTR [rbx+106], 1
	je	SHORT $LN53@memory_ope
$LN52@memory_ope:
	test	al, 8
	je	SHORT $LN51@memory_ope
	cmp	BYTE PTR [rbx+106], 2
	je	SHORT $LN53@memory_ope
$LN51@memory_ope:
	test	al, 2
	je	SHORT $LN54@memory_ope
	cmp	BYTE PTR [rbx+106], r15b
	jne	SHORT $LN54@memory_ope
$LN53@memory_ope:

; 1650 :             CodeInfo->prefix.adrsiz = FALSE;

	and	BYTE PTR [rbx+9], 254			; 000000feH

; 1651 :         else {

	jmp	SHORT $LN49@memory_ope
$LN54@memory_ope:

; 1652 :             CodeInfo->prefix.adrsiz = TRUE;

	or	BYTE PTR [rbx+9], 1

; 1653 : #if AMD64_SUPPORT
; 1654 :             /* 16bit addressing modes don't exist in long mode */
; 1655 :             if ( ( GetValueSp( base ) & OP_R16) && CodeInfo->Ofssize == USE64 ) {

	test	BYTE PTR SpecialTable[r11+rcx*4], 2
	je	SHORT $LN49@memory_ope
	cmp	BYTE PTR [rbx+106], 2

; 1656 :                 return( EmitError( INVALID_ADDRESSING_MODE_WITH_CURRENT_CPU_SETTING ) );

	je	$LN36@memory_ope
$LN49@memory_ope:

; 1657 :             }
; 1658 : #endif
; 1659 :         }
; 1660 :     }
; 1661 : 
; 1662 :     /* check for index registers */
; 1663 : 
; 1664 :     if( index != EMPTY ) {

	cmp	esi, -2
	je	$LN191@memory_ope

; 1665 :         if ( ( ( GetValueSp( index ) & OP_R32) && CodeInfo->Ofssize == USE32 ) ||
; 1666 : #if AMD64_SUPPORT
; 1667 :             ( ( GetValueSp( index ) & OP_R64) && CodeInfo->Ofssize == USE64 ) ||
; 1668 : #endif
; 1669 :             ( ( GetValueSp( index ) & OP_R16) && CodeInfo->Ofssize == USE16 ) ) {

	mov	eax, DWORD PTR SpecialTable[r11+rdx*4]
	test	al, 4
	je	SHORT $LN45@memory_ope
	cmp	BYTE PTR [rbx+106], 1
	je	SHORT $LN46@memory_ope
$LN45@memory_ope:
	test	al, 8
	je	SHORT $LN44@memory_ope
	cmp	BYTE PTR [rbx+106], 2
	je	SHORT $LN46@memory_ope
$LN44@memory_ope:
	test	al, 2
	je	SHORT $LN47@memory_ope
	cmp	BYTE PTR [rbx+106], r15b
	jne	SHORT $LN47@memory_ope
$LN46@memory_ope:

; 1670 :             CodeInfo->prefix.adrsiz = FALSE;

	and	BYTE PTR [rbx+9], 254			; 000000feH

; 1671 :         } else {

	jmp	SHORT $LN43@memory_ope
$LN47@memory_ope:

; 1672 :             CodeInfo->prefix.adrsiz = TRUE;

	or	BYTE PTR [rbx+9], 1
$LN43@memory_ope:

; 1673 :         }
; 1674 : 
; 1675 :         /* v2.10: register swapping has been moved to expreval.c, index_connect().
; 1676 :          * what has remained here is the check if R/ESP is used as index reg.
; 1677 :          */
; 1678 : 		if ((GetRegNo(index) == 4)&& GetValueSp( index )< OP_XMM //Fixed error  CANNOT_BE_USED_AS_INDEX_REGISTER, HJWasm 2.16
; 1679 : #if 0
; 1680 : 			&& (GetResWName(index, NULL) <= T_RBP)
; 1681 : #endif
; 1682 : 			) { /* [E|R]SP? */

	cmp	BYTE PTR SpecialTable[r11+rdx*4+10], 4
	jne	SHORT $LN42@memory_ope
	cmp	DWORD PTR SpecialTable[r11+rdx*4], 32	; 00000020H
	jae	SHORT $LN42@memory_ope

; 1683 : 			
; 1684 : 				//if ( (GetRegNo( index ) == 4) && (GetResWName( index, NULL ) <= T_RBP )) { /* [E|R]SP? */ /* Removed in 2.13 in favour of above */
; 1685 : 
; 1686 :             DebugMsg(( "memory_operand: error, base regno=%u, index regno=%u, opnd.scale=%u\n", GetRegNo( base ), GetRegNo( index ), opndx->scale ));
; 1687 :             //int tmp = index;
; 1688 :             if( opndx->scale ) { /* no scale must be set */

	cmp	BYTE PTR [r12+68], r15b
	je	SHORT $LN41@memory_ope

; 1689 :                 EmitErr( CANNOT_BE_USED_AS_INDEX_REGISTER, GetResWName( index, NULL ) );

	xor	edx, edx
	mov	ecx, esi
	call	GetResWName
	mov	ecx, 37					; 00000025H
	mov	rdx, rax
	call	EmitErr

; 1694 :                 //return( ERROR );
; 1695 :             }
; 1696 :             return( ERROR );

	mov	eax, -1
	jmp	$LN100@memory_ope
$LN41@memory_ope:

; 1690 :                 //return( ERROR );
; 1691 :             } else {
; 1692 :             //if ( GetRegNo( base ) == 4 ) {
; 1693 :                 EmitErr( MULTIPLE_BASE_REGISTERS_NOT_ALLOWED );

	mov	ecx, 29
	call	EmitErr
$LN40@memory_ope:

; 1694 :                 //return( ERROR );
; 1695 :             }
; 1696 :             return( ERROR );

	mov	eax, -1
	jmp	$LN100@memory_ope
$LN42@memory_ope:

; 1697 :             /* swap base and index */
; 1698 :             //index = base;
; 1699 :             //base = tmp;
; 1700 : #if 0
; 1701 :         } else if ( Options.masm_compat_gencode && opndx->scale == 0 && GetRegNo( base ) != 4 ) {
; 1702 :             /* v2.08: Masm 6+ swaps base and index, even if -Zm is set (Masm 5.1 does NOT swap) */
; 1703 :             int tmp = index;
; 1704 :             /* swap base and index */
; 1705 :             index = base;
; 1706 :             base = tmp;
; 1707 : #endif
; 1708 :         }
; 1709 : 
; 1710 :         /* 32/64 bit indirect addressing? */
; 1711 :         if( ( CodeInfo->Ofssize == USE16 && CodeInfo->prefix.adrsiz == 1 ) ||
; 1712 : #if AMD64_SUPPORT
; 1713 :            CodeInfo->Ofssize == USE64  ||
; 1714 : #endif
; 1715 :            ( CodeInfo->Ofssize == USE32 && CodeInfo->prefix.adrsiz == 0 ) ) {

	mov	al, BYTE PTR [rbx+106]
	test	al, al
	jne	SHORT $LN37@memory_ope
	test	BYTE PTR [rbx+9], 1
	jne	SHORT $LN38@memory_ope
$LN37@memory_ope:
	cmp	al, 2
	je	SHORT $LN38@memory_ope
	cmp	al, 1
	jne	SHORT $LN39@memory_ope
	test	BYTE PTR [rbx+9], al
	je	SHORT $LN38@memory_ope
$LN39@memory_ope:

; 1732 :             /* v2.01: 16-bit addressing mode. No scale possible */
; 1733 :             if ( opndx->scale ) {

	cmp	BYTE PTR [r12+68], r15b
	je	SHORT $LN192@memory_ope

; 1734 :                 return( EmitError( INVALID_USE_OF_REGISTER ) );

	mov	ecx, 170				; 000000aaH
	call	EmitError
	jmp	$LN100@memory_ope
$LN38@memory_ope:

; 1716 :             if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN36@memory_ope

; 1717 :                 /* scale, 0 or 1->00, 2->40, 4->80, 8->C0 */
; 1718 :                 switch( opndx->scale ) {

	mov	al, BYTE PTR [r12+68]
	cmp	al, 1
	jbe	SHORT $LN190@memory_ope
	cmp	al, 2
	je	SHORT $LN32@memory_ope
	cmp	al, 4
	je	SHORT $LN31@memory_ope
	cmp	al, 8
	jne	SHORT $LN29@memory_ope

; 1723 :                 case 8: ss = SCALE_FACTOR_8; break; /* ss = 11 */

	mov	r14b, -64				; ffffffffffffffc0H
	jmp	SHORT $LN26@memory_ope
$LN31@memory_ope:

; 1722 :                 case 4: ss = SCALE_FACTOR_4; break; /* ss = 10 */

	mov	r14b, -128				; ffffffffffffff80H
	jmp	SHORT $LN26@memory_ope
$LN32@memory_ope:

; 1719 :                 case 0:
; 1720 :                 case 1:  break; /* ss = 00 */
; 1721 :                 case 2: ss = SCALE_FACTOR_2; break; /* ss = 01 */

	mov	r14b, 64				; 00000040H

; 1730 :             }
; 1731 :         } else {

	jmp	SHORT $LN26@memory_ope
$LN29@memory_ope:

; 1724 :                 default: /* must be * 1, 2, 4 or 8 */
; 1725 :                     return( EmitError( SCALE_FACTOR_MUST_BE_1_2_4_OR_8 ) );

	mov	ecx, 36					; 00000024H
	call	EmitError
	jmp	$LN100@memory_ope
$LN36@memory_ope:

; 1726 :                 }
; 1727 :             } else {
; 1728 :                 /* 286 and down cannot use this memory mode */
; 1729 :                 return( EmitError( INVALID_ADDRESSING_MODE_WITH_CURRENT_CPU_SETTING ) );

	mov	ecx, 31
	call	EmitError
	jmp	$LN100@memory_ope
$LN190@memory_ope:

; 1456 :     char                ss = SCALE_FACTOR_1;
; 1457 :     int                 index;
; 1458 :     int                 base;
; 1459 :     int                 j;
; 1460 :     struct asym         *sym;
; 1461 :     uint_8              Ofssize;
; 1462 :     enum fixup_types    fixup_type;
; 1463 : 
; 1464 :     DebugMsg1(("memory_operand(opndx.value=%X / sym=%s / memtype=%Xh, with_fixup=%u) enter, [CodeInfo->memtype=%Xh, Ofssize=%u, adrsiz=%u]\n",
; 1465 :                opndx->value, opndx->sym ? opndx->sym->name : "NULL", opndx->mem_type, with_fixup, CodeInfo->mem_type, CodeInfo->Ofssize, CodeInfo->prefix.adrsiz ));
; 1466 : 
; 1467 :     /* v211: use full 64-bit value */
; 1468 :     //CodeInfo->opnd[CurrOpnd].data = opndx->value;
; 1469 :     CodeInfo->opnd[CurrOpnd].data64 = opndx->value64;

	xor	r14b, r14b
	jmp	SHORT $LN26@memory_ope
$LN191@memory_ope:
	xor	r14b, r14b
	jmp	SHORT $LN26@memory_ope
$LN192@memory_ope:
	xor	r14b, r14b
$LN26@memory_ope:

; 1735 :             }
; 1736 :         }
; 1737 :     }
; 1738 : 
; 1739 :     if( with_fixup ) {

	cmp	BYTE PTR with_fixup$[rsp], r15b
	je	$LN185@memory_ope

; 1740 : 
; 1741 :         if( opndx->is_abs ) {

	test	BYTE PTR [r12+72], 4
	je	SHORT $LN24@memory_ope

; 1742 :             Ofssize = IS_ADDR32( CodeInfo );

	cmp	BYTE PTR [rbx+106], r15b
	je	SHORT $LN108@memory_ope
	mov	dl, BYTE PTR [rbx+9]
	mov	r13, QWORD PTR sym$1$[rsp]
	not	dl
	and	dl, 1
	jmp	SHORT $LN19@memory_ope
$LN108@memory_ope:
	movzx	eax, BYTE PTR [rbx+9]
	mov	r13, QWORD PTR sym$1$[rsp]
	and	al, 1
	cmp	al, 1
	sete	dl
	jmp	SHORT $LN19@memory_ope
$LN24@memory_ope:

; 1743 :         } else if ( sym ) {

	mov	r13, QWORD PTR sym$1$[rsp]
	test	r13, r13
	je	SHORT $LN22@memory_ope

; 1744 :             Ofssize = GetSymOfssize( sym );

	mov	rcx, r13
	call	GetSymOfssize
	mov	edx, eax
	jmp	SHORT $LN19@memory_ope
$LN22@memory_ope:

; 1745 :         } else if ( SegOverride ) {

	mov	rcx, QWORD PTR SegOverride
	test	rcx, rcx
	je	SHORT $LN20@memory_ope

; 1746 :             Ofssize = GetSymOfssize( SegOverride );

	call	GetSymOfssize
	mov	dl, al

; 1747 :         } else

	jmp	SHORT $LN19@memory_ope
$LN20@memory_ope:

; 1748 :             Ofssize = CodeInfo->Ofssize;

	mov	dl, BYTE PTR [rbx+106]
$LN19@memory_ope:

; 1749 : 
; 1750 :         /* now set fixup_type.
; 1751 :          * for direct addressing, the fixup type can easily be set by
; 1752 :          * the symbol's offset size.
; 1753 :          */
; 1754 :         if( base == EMPTY && index == EMPTY ) {

	cmp	ebp, -2
	jne	SHORT $LN18@memory_ope
	cmp	esi, ebp
	jne	SHORT $LN18@memory_ope

; 1755 :             CodeInfo->prefix.adrsiz = ADDRSIZE( CodeInfo->Ofssize, Ofssize );

	and	BYTE PTR [rbx+9], 254			; 000000feH
	movzx	eax, BYTE PTR [rbx+106]
	xor	al, dl
	setne	cl
	and	cl, 1
	or	BYTE PTR [rbx+9], cl

; 1756 : #if AMD64_SUPPORT
; 1757 :             if ( Ofssize == USE64 )

	cmp	dl, 2
	jne	SHORT $LN17@memory_ope

; 1758 :                 /* v2.03: override with a segment assumed != FLAT? */
; 1759 :                 if ( opndx->override != NULL &&
; 1760 :                     SegOverride != &ModuleInfo.flat_grp->sym )

	cmp	QWORD PTR [r12+48], r15
	je	$LN4@memory_ope
	mov	rax, QWORD PTR ModuleInfo+440
	cmp	QWORD PTR SegOverride, rax
	je	$LN4@memory_ope

; 1761 :                     fixup_type = FIX_OFF32;

	lea	edi, QWORD PTR [rbp+8]

; 1762 :                 else

	jmp	SHORT $LN183@memory_ope
$LN17@memory_ope:

; 1763 :                     fixup_type = FIX_RELOFF32;
; 1764 :             else
; 1765 : #endif
; 1766 :                 fixup_type = ( Ofssize ) ? FIX_OFF32 : FIX_OFF16;

	test	dl, dl
	mov	edi, r15d
	setne	dil
	add	edi, 5

; 1794 :                 }
; 1795 :             }
; 1796 :         }
; 1797 : 
; 1798 : #if IMAGERELSUPP || SECTIONRELSUPP /* v2.10: added; IMAGEREL/SECTIONREL for indirect memory operands */
; 1799 :         if ( fixup_type == FIX_OFF32 )

	cmp	edi, 6
	jne	SHORT $LN4@memory_ope
$LN183@memory_ope:

; 1800 :             if ( opndx->instr == T_IMAGEREL )

	mov	eax, DWORD PTR [r12+56]
	cmp	eax, 233				; 000000e9H
	jne	SHORT $LN6@memory_ope

; 1801 :                 fixup_type = FIX_OFF32_IMGREL;

	mov	edi, 12
	jmp	SHORT $LN4@memory_ope
$LN18@memory_ope:

; 1767 :             DebugMsg1(( "memory_operand: direct addressing, fixup type=%u\n", fixup_type ));
; 1768 :         } else {
; 1769 :             DebugMsg1(( "memory_operand: CodeInfo->Ofssize=%u/prefix.adrsize=%u, Ofssize=%u\n",
; 1770 :                       CodeInfo->Ofssize, CodeInfo->prefix.adrsiz, Ofssize ));
; 1771 : #if AMD64_SUPPORT
; 1772 :             if( Ofssize == USE64 ) {

	cmp	dl, 2
	jne	SHORT $LN12@memory_ope

; 1773 :                 fixup_type = FIX_OFF32;

	mov	edi, 6

; 1774 :             } else

	jmp	SHORT $LN183@memory_ope
$LN12@memory_ope:

; 1775 : #endif
; 1776 :             if( IS_ADDR32( CodeInfo ) ) { /* address prefix needed? */

	cmp	BYTE PTR [rbx+106], r15b
	je	SHORT $LN110@memory_ope
	mov	r15b, BYTE PTR [rbx+9]
	not	r15b
	and	r15d, 1
	jmp	SHORT $LN111@memory_ope
$LN110@memory_ope:
	movzx	eax, BYTE PTR [rbx+9]
	and	al, 1
	cmp	al, 1
	sete	r15b
$LN111@memory_ope:
	test	r15d, r15d
	je	SHORT $LN10@memory_ope

; 1777 :                 /* changed for v1.95. Probably more tests needed!
; 1778 :                  * test case:
; 1779 :                  *   mov eax,[ebx*2-10+offset var] ;code and var are 16bit!
; 1780 :                  * the old code usually works fine because HiWord of the
; 1781 :                  * symbol's offset is zero. However, if there's an additional
; 1782 :                  * displacement which makes the value stored at the location
; 1783 :                  * < 0, then the target's HiWord becomes <> 0.
; 1784 :                  */
; 1785 :                 //fixup_type = ( Ofssize ) ? FIX_OFF32 : FIX_OFF16;
; 1786 :                 fixup_type = FIX_OFF32;

	mov	edi, 6

; 1787 :             } else {

	jmp	SHORT $LN183@memory_ope
$LN10@memory_ope:

; 1788 :                 fixup_type = FIX_OFF16;
; 1789 :                 if( Ofssize && Parse_Pass == PASS_2 ) {

	test	dl, dl
	mov	edi, 5
	je	SHORT $LN4@memory_ope
	cmp	DWORD PTR Parse_Pass, 1
	jne	SHORT $LN4@memory_ope

; 1790 :                     /* address size is 16bit but label is 32-bit.
; 1791 :                      * example: use a 16bit register as base in FLAT model:
; 1792 :                      *   test buff[di],cl */
; 1793 :                     EmitWarn( 2, WORD_FIXUP_FOR_32BIT_LABEL, sym->name );

	mov	r8, QWORD PTR [r13+8]
	lea	ecx, QWORD PTR [rdi-3]
	mov	edx, 218				; 000000daH
	call	EmitWarn

; 1794 :                 }
; 1795 :             }
; 1796 :         }
; 1797 : 
; 1798 : #if IMAGERELSUPP || SECTIONRELSUPP /* v2.10: added; IMAGEREL/SECTIONREL for indirect memory operands */
; 1799 :         if ( fixup_type == FIX_OFF32 )

	jmp	SHORT $LN4@memory_ope
$LN6@memory_ope:

; 1802 :             else if ( opndx->instr == T_SECTIONREL )

	mov	ecx, 13
	cmp	eax, 243				; 000000f3H
	cmove	edi, ecx
$LN4@memory_ope:

; 1803 :                 fixup_type = FIX_OFF32_SECREL;
; 1804 : #endif
; 1805 :         /* no fixups are needed for memory operands of string instructions and XLAT/XLATB.
; 1806 :          * However, CMPSD and MOVSD are also SSE2 opcodes, so the fixups must be generated
; 1807 :          * anyways.
; 1808 :          */
; 1809 :         if ( CodeInfo->token != T_XLAT && CodeInfo->token != T_XLATB ) {

	mov	eax, DWORD PTR [rbx+24]
	cmp	eax, 667				; 0000029bH
	je	SHORT $LN189@memory_ope
	cmp	eax, 668				; 0000029cH
	je	SHORT $LN188@memory_ope

; 1810 :             //DebugMsg1(("memory_operand: calling CreateFixup(%s, fixup=%u) [CodeInfo->memtype=%Xh]\n", sym ? sym->name : "NULL", fixup_type, CodeInfo->mem_type));
; 1811 :             CodeInfo->opnd[CurrOpnd].InsFixup = CreateFixup( sym, fixup_type, OPTJ_NONE );

	xor	r8d, r8d
	mov	edx, edi
	mov	rcx, r13
	call	CreateFixup
	mov	rdi, QWORD PTR tv1159[rsp]
	lea	rcx, QWORD PTR [rdi+rdi*2+6]
	mov	QWORD PTR [rbx+rcx*8], rax
	jmp	SHORT $LN3@memory_ope
$LN185@memory_ope:

; 1758 :                 /* v2.03: override with a segment assumed != FLAT? */
; 1759 :                 if ( opndx->override != NULL &&
; 1760 :                     SegOverride != &ModuleInfo.flat_grp->sym )

	mov	r13, QWORD PTR sym$1$[rsp]
	mov	rdi, QWORD PTR tv1159[rsp]
	jmp	SHORT $LN3@memory_ope
$LN188@memory_ope:
	mov	rdi, QWORD PTR tv1159[rsp]
	jmp	SHORT $LN3@memory_ope
$LN189@memory_ope:
	mov	rdi, QWORD PTR tv1159[rsp]
$LN3@memory_ope:

; 1812 :         }
; 1813 :     }
; 1814 : 
; 1815 :     if( set_rm_sib( CodeInfo, CurrOpnd, ss, index, base, sym ) == ERROR ) {

	mov	edx, DWORD PTR CurrOpnd$[rsp]
	mov	r9d, esi
	movzx	r8d, r14b
	mov	rcx, rbx
	mov	QWORD PTR [rsp+40], r13
	mov	DWORD PTR [rsp+32], ebp
	call	set_rm_sib
	cmp	eax, -1

; 1816 :         return( ERROR );

	je	$LN40@memory_ope

; 1817 :     }
; 1818 :     /* set frame type/data in fixup if one was created */
; 1819 :     if ( CodeInfo->opnd[CurrOpnd].InsFixup ) {

	lea	rcx, QWORD PTR [rdi+rdi*2+6]
	mov	rdx, QWORD PTR [rbx+rcx*8]
	test	rdx, rdx
	je	SHORT $LN1@memory_ope

; 1820 :         CodeInfo->opnd[CurrOpnd].InsFixup->frame_type = Frame_Type;

	movzx	eax, BYTE PTR Frame_Type
	mov	BYTE PTR [rdx+40], al

; 1821 :         CodeInfo->opnd[CurrOpnd].InsFixup->frame_datum = Frame_Datum;

	mov	rcx, QWORD PTR [rbx+rcx*8]
	movzx	eax, WORD PTR Frame_Datum
	mov	WORD PTR [rcx+42], ax
$LN1@memory_ope:

; 1822 :     }
; 1823 : 
; 1824 :     DebugMsg1(("memory_operand exit, ok, opndx.type/value=%Xh/%Xh, CodeInfo.memtype/rmbyte=%X/%X opndtype=%Xh fix=%Xh\n",
; 1825 :               opndx->type, opndx->value, CodeInfo->mem_type, CodeInfo->rm_byte, CodeInfo->opnd[CurrOpnd].type, CodeInfo->opnd[CurrOpnd].InsFixup ));
; 1826 :     return( NOT_ERROR );

	xor	eax, eax
$LN100@memory_ope:
	mov	r15, QWORD PTR [rsp+56]
	mov	r14, QWORD PTR [rsp+64]
	mov	r13, QWORD PTR [rsp+72]
	mov	r12, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+112]

; 1827 : }

	add	rsp, 120				; 00000078H
	ret	0
$LN184@memory_ope:
	DD	$LN70@memory_ope
	DD	$LN69@memory_ope
	DD	$LN58@memory_ope
	DD	$LN68@memory_ope
	DD	$LN58@memory_ope
	DD	$LN67@memory_ope
	DD	$LN58@memory_ope
	DD	$LN66@memory_ope
	DD	$LN58@memory_ope
	DD	$LN65@memory_ope
	DD	$LN58@memory_ope
	DD	$LN58@memory_ope
	DD	$LN58@memory_ope
	DD	$LN58@memory_ope
	DD	$LN58@memory_ope
	DD	$LN64@memory_ope
memory_operand ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$process_address DD 071301H
	DD	097413H
	DD	08640eH
	DD	073409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$process_address DD @imagerel(process_address#)
	DD	@imagerel(process_address#+647)
	DD	@imagerel($unwind$process_address#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
CodeInfo$ = 48
CurrOpnd$ = 56
opndx$ = 64
process_address PROC NEAR

; 1836 : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx

; 1837 :     if( opndx->indirect ) {  /* indirect register operand or stack var */

	mov	ecx, DWORD PTR [r8+72]
	mov	rbx, r8
	test	cl, 1
	mov	esi, edx
	je	SHORT $LN43@process_ad

; 1838 : 
; 1839 :         DebugMsg1(("process_address: INDIRECT, sym=%s mbr=%s ci.adrsiz=%u\n",
; 1840 :                    opndx->sym ? opndx->sym->name : "NULL",
; 1841 :                    opndx->mbr ? opndx->mbr->name : "NULL",
; 1842 :                    CodeInfo->prefix.adrsiz ));
; 1843 :         /* if displacement doesn't fit in 32-bits:
; 1844 :          * Masm (both ML and ML64) just truncates.
; 1845 :          * HJWasm throws an error in 64bit mode and
; 1846 :          * warns (level 3) in the other modes.
; 1847 :          * todo: this check should also be done for direct addressing!
; 1848 :          */
; 1849 :         if ( opndx->hvalue && ( opndx->hvalue != -1 || opndx->value >= 0 ) ) {

	mov	eax, DWORD PTR [r8+4]
	test	eax, eax
	je	SHORT $LN42@process_ad
	cmp	eax, -1
	jne	SHORT $LN41@process_ad
	cmp	DWORD PTR [r8], 0
	jl	SHORT $LN42@process_ad
$LN41@process_ad:

; 1850 :             DebugMsg1(("process_address: displacement doesn't fit in 32 bits: %" I64_SPEC "X\n", opndx->value64 ));
; 1851 : #if AMD64_SUPPORT
; 1852 :             if ( ModuleInfo.Ofssize == USE64 ) {

	cmp	BYTE PTR ModuleInfo+404, 2
	jne	SHORT $LN40@process_ad

; 1853 :                 return( EmitConstError( opndx ) );

	mov	rcx, rbx
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 1971 : }

	add	rsp, 40					; 00000028H
	jmp	EmitConstError
$LN40@process_ad:

; 1854 :             }
; 1855 : #endif
; 1856 :             EmitWarn( 3, DISPLACEMENT_OUT_OF_RANGE, opndx->value64 );

	mov	r8, QWORD PTR [r8]
	mov	edx, 54					; 00000036H
	lea	ecx, QWORD PTR [rdx-51]
	call	EmitWarn
$LN42@process_ad:

; 1857 :         }
; 1858 :         if( opndx->sym == NULL || opndx->sym->state == SYM_STACK ) {

	mov	rax, QWORD PTR [rbx+80]
	test	rax, rax
	je	SHORT $LN38@process_ad
	cmp	DWORD PTR [rax+40], 5
	jne	$LN1@process_ad
$LN38@process_ad:

; 1859 :             return( memory_operand( CodeInfo, CurrOpnd, opndx, FALSE ) );

	xor	r9d, r9d
	mov	r8, rbx
	mov	edx, esi
	mov	rcx, rdi
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 1971 : }

	add	rsp, 40					; 00000028H
	jmp	memory_operand
$LN43@process_ad:

; 1860 :         }
; 1861 :         /* do default processing */
; 1862 : 
; 1863 :     } else if( opndx->instr != EMPTY ) {

	mov	eax, DWORD PTR [r8+56]
	cmp	eax, -2
	je	SHORT $LN36@process_ad

; 1864 :         /* instr is OFFSET | LROFFSET | SEG | LOW | LOWWORD, ... */
; 1865 :         DebugMsg1(("process_address: instr=%s\n", GetResWName( opndx->instr, NULL ) ));
; 1866 :         if( opndx->sym == NULL ) { /* better to check opndx->type? */

	cmp	QWORD PTR [r8+80], 0

; 1867 :             return( idata_nofixup( CodeInfo, CurrOpnd, opndx ) );

	je	SHORT $LN30@process_ad

; 1868 :         } else {
; 1869 :             /* allow "lea <reg>, [offset <sym>]" */
; 1870 :             if( CodeInfo->token == T_LEA && opndx->instr == T_OFFSET )

	cmp	DWORD PTR [rdi+24], 634			; 0000027aH
	jne	$LN2@process_ad
	cmp	eax, 241				; 000000f1H
	jne	$LN2@process_ad

; 1963 :                 return( memory_operand( CodeInfo, CurrOpnd, opndx, TRUE ) );

	mov	r9b, 1
	mov	rcx, rdi
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 1971 : }

	add	rsp, 40					; 00000028H
	jmp	memory_operand
$LN36@process_ad:

; 1871 :                 return( memory_operand( CodeInfo, CurrOpnd, opndx, TRUE ) );
; 1872 :             return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );
; 1873 :         }
; 1874 :     } else if( opndx->sym == NULL ) { /* direct operand without symbol */

	mov	rax, QWORD PTR [r8+80]
	test	rax, rax
	jne	SHORT $LN31@process_ad

; 1875 :         DebugMsg1(("process_address: symbol=NULL\n" ));
; 1876 :         if( opndx->override != NULL ) {

	mov	rax, QWORD PTR [r8+48]
	test	rax, rax
	je	SHORT $LN30@process_ad

; 1877 :             /* direct absolute memory without symbol.
; 1878 :              DS:[0] won't create a fixup, but
; 1879 :              DGROUP:[0] will create one! */
; 1880 : #if AMD64_SUPPORT
; 1881 :             /* for 64bit, always create a fixup, since RIP-relative addressing is used
; 1882 :              * v2.11: don't create fixup in 64-bit.
; 1883 :              */
; 1884 :             //if ( opndx->override->token == T_REG && CodeInfo->Ofssize != USE64 )
; 1885 :             if ( opndx->override->token == T_REG || CodeInfo->Ofssize == USE64 )

	cmp	BYTE PTR [rax], 2
	je	SHORT $LN28@process_ad
	cmp	BYTE PTR [rdi+106], 2

; 1890 :             else
; 1891 :                 return( memory_operand( CodeInfo, CurrOpnd, opndx, TRUE ) );

	jne	$LN48@process_ad
$LN28@process_ad:

; 1886 : #else
; 1887 :             if ( opndx->override->token == T_REG )
; 1888 : #endif
; 1889 :                 return( memory_operand( CodeInfo, CurrOpnd, opndx, FALSE ) );

	xor	r9d, r9d
	mov	rcx, rdi
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 1971 : }

	add	rsp, 40					; 00000028H
	jmp	memory_operand
$LN30@process_ad:

; 1892 :         } else {
; 1893 :             return( idata_nofixup( CodeInfo, CurrOpnd, opndx ) );

	mov	rcx, rdi
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 1971 : }

	add	rsp, 40					; 00000028H
	jmp	idata_nofixup
$LN31@process_ad:

; 1894 :         }
; 1895 :     } else if( ( opndx->sym->state == SYM_UNDEFINED ) && !opndx->explicit ) {

	mov	eax, DWORD PTR [rax+40]
	test	eax, eax
	jne	$LN24@process_ad
	test	cl, 2
	jne	$LN24@process_ad

; 1896 :         DebugMsg1(("process_address: sym=SYM_UNDEFINED, name=%s, state=%X\n", opndx->sym->name, opndx->sym->state ));
; 1897 :         /* v2.04: unnecessary, the expression evaluator will have emitted an error already */
; 1898 :         //if( Parse_Pass != PASS_1 ) {
; 1899 :         //    EmitErr( SYMBOL_NOT_DEFINED, opndx->sym->name );
; 1900 :         //    return( ERROR );
; 1901 :         //}
; 1902 :         /* undefined symbol, it's not possible to determine
; 1903 :          * operand type and size currently. However, for backpatching
; 1904 :          * a fixup should be created.
; 1905 :          */
; 1906 :         /* assume a code label for branch instructions! */
; 1907 :         if( IS_ANY_BRANCH( CodeInfo->token ) )

	mov	ecx, DWORD PTR [rdi+24]
	cmp	ecx, 455				; 000001c7H
	jl	SHORT $LN23@process_ad
	cmp	ecx, 504				; 000001f8H
	jg	SHORT $LN23@process_ad

; 1908 :             return( process_branch( CodeInfo, CurrOpnd, opndx ) );

	mov	rcx, rdi
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 1971 : }

	add	rsp, 40					; 00000028H
	jmp	process_branch
$LN23@process_ad:

; 1909 : 
; 1910 :         switch( CodeInfo->token ) {

	sub	ecx, 565				; 00000235H
	je	SHORT $LN20@process_ad
	sub	ecx, 36					; 00000024H
	je	SHORT $LN20@process_ad
	cmp	ecx, 2
	je	SHORT $LN20@process_ad

; 1918 :             }
; 1919 :             break;
; 1920 :         default:
; 1921 :             /* v2.04: if operand is the second argument (and the first is NOT
; 1922 :              * a segment register!), scan the
; 1923 :              * instruction table if the instruction allows an immediate!
; 1924 :              * If so, assume the undefined symbol is a constant.
; 1925 :              */
; 1926 :             if ( CurrOpnd == OPND2 && (( CodeInfo->opnd[OPND1].type & OP_SR ) == 0 ) ) {

	cmp	edx, 1
	jne	SHORT $LN14@process_ad
	test	DWORD PTR [rdi+32], 24576		; 00006000H
	jne	SHORT $LN1@process_ad

; 1927 :                 const struct instr_item  *p = CodeInfo->pinstr;

	mov	rdx, QWORD PTR [rdi+16]
	lea	r8, OFFSET FLAT:opnd_clstab+4
	npad	2
$LL16@process_ad:

; 1928 :                 do {
; 1929 :                     if ( opnd_clstab[p->opclsidx].opnd_type[OPND2] & OP_I ) {

	movzx	eax, BYTE PTR [rdx]
	lea	rcx, QWORD PTR [rax+rax*2]
	test	DWORD PTR [r8+rcx*4], 917504		; 000e0000H
	jne	SHORT $LN47@process_ad

; 1931 :                     }
; 1932 :                     p++;

	add	rdx, 14

; 1933 :                 } while ( p->first == FALSE );

	cmp	BYTE PTR [rdx+4], 0
	je	SHORT $LL16@process_ad
	jmp	SHORT $LN1@process_ad
$LN47@process_ad:

; 1930 :                         return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );

	mov	r8, rbx
	mov	edx, 1
	jmp	$LN2@process_ad
$LN14@process_ad:

; 1934 :             }
; 1935 :             /* v2.10: if current operand is the third argument, always assume an immediate */
; 1936 :             if ( CurrOpnd == OPND3 )

	cmp	edx, 2
	jne	SHORT $LN1@process_ad

; 1937 :                 return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );

	jmp	$LN2@process_ad
$LN20@process_ad:

; 1911 :         case T_PUSH:
; 1912 :         case T_PUSHW:
; 1913 :         case T_PUSHD:
; 1914 :             /* v2.0: don't assume immediate operand if cpu is 8086 */
; 1915 :             if ( ( ModuleInfo.curr_cpu & P_CPU_MASK ) > P_86 ) {

	test	DWORD PTR ModuleInfo+392, 240		; 000000f0H
	jle	SHORT $LN1@process_ad

; 1916 :                 //return( idata_nofixup( CodeInfo, opndx ) ); /* v1.96: changed */
; 1917 :                 return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );

	jmp	SHORT $LN2@process_ad
$LN24@process_ad:

; 1938 :         }
; 1939 :         /* do default processing */
; 1940 : 
; 1941 :     } else if( ( opndx->sym->state == SYM_SEG ) ||
; 1942 :                ( opndx->sym->state == SYM_GRP ) ) {

	cmp	eax, 3
	je	SHORT $LN9@process_ad
	cmp	eax, 4
	je	SHORT $LN9@process_ad

; 1948 :     } else {
; 1949 :         DebugMsg1(("process_address direct, sym=%s sym.memtype=%X opndx.memtype=%X\n", opndx->sym->name, opndx->sym->mem_type, opndx->mem_type ));
; 1950 : 
; 1951 :         /* symbol external, but absolute? */
; 1952 :         if( opndx->is_abs ) {

	test	cl, 4

; 1953 :             return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );

	jne	SHORT $LN2@process_ad

; 1954 :         }
; 1955 : 
; 1956 :         /* CODE location is converted to OFFSET symbol */
; 1957 :         if ( opndx->mem_type == MT_NEAR || opndx->mem_type == MT_FAR ) {

	mov	eax, DWORD PTR [r8+64]
	cmp	eax, 129				; 00000081H
	je	SHORT $LN5@process_ad
	cmp	eax, 130				; 00000082H
	je	SHORT $LN5@process_ad
$LN1@process_ad:

; 1964 :             } else {
; 1965 :                 return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );
; 1966 :             }
; 1967 :         }
; 1968 :     }
; 1969 :     /* default processing: memory with fixup */
; 1970 :     return( memory_operand( CodeInfo, CurrOpnd, opndx, TRUE ) );

	mov	r9b, 1
	mov	r8, rbx
	mov	edx, esi
	mov	rcx, rdi
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 1971 : }

	add	rsp, 40					; 00000028H
	jmp	memory_operand
$LN5@process_ad:

; 1958 :             if( CodeInfo->token == T_LEA ) {

	cmp	DWORD PTR [rdi+24], 634			; 0000027aH

; 1959 :                 return( memory_operand( CodeInfo, CurrOpnd, opndx, TRUE ) );

	je	SHORT $LN48@process_ad

; 1960 :             //} else if( opndx->sym == &symPC ) {
; 1961 :             //    return( idata_fixup( CodeInfo, opndx ) );
; 1962 :             } else if( opndx->mbr != NULL ) { /* structure field? */

	cmp	QWORD PTR [r8+88], 0
	je	SHORT $LN2@process_ad
$LN48@process_ad:

; 1963 :                 return( memory_operand( CodeInfo, CurrOpnd, opndx, TRUE ) );

	mov	r9b, 1
	mov	rcx, rdi
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 1971 : }

	add	rsp, 40					; 00000028H
	jmp	memory_operand
$LN9@process_ad:

; 1943 :         DebugMsg1(("process_address: sym->state=SEG/GROUP\n"));
; 1944 :         /* SEGMENT and GROUP symbol is converted to SEG symbol
; 1945 :          * for next processing */
; 1946 :         opndx->instr = T_SEG;

	mov	DWORD PTR [r8+56], 244			; 000000f4H
$LN2@process_ad:

; 1947 :         return( idata_fixup( CodeInfo, CurrOpnd, opndx ) );

	mov	rcx, rdi
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 1971 : }

	add	rsp, 40					; 00000028H
	jmp	idata_fixup
process_address ENDP
; Function compile flags: /Ogtpy
CodeInfo$ = 8
CurrOpnd$ = 16
opndx$ = 24
process_const PROC NEAR

; 1980 : #if 0 /* v2.06: obsolete */
; 1981 :     /* hack for IMUL: compress the operands so there are 2 only */
; 1982 :     if( ( CodeInfo->token == T_IMUL ) &&
; 1983 :        ( CodeInfo->opnd_type[OPND1] & OP_R ) ) {
; 1984 :         if( CurrOpnd == OPND2 ) {
; 1985 : #if AMD64_SUPPORT
; 1986 :             CodeInfo->prefix.rex |= ((CodeInfo->prefix.rex & REX_B) ? REX_R : 0);
; 1987 : #endif
; 1988 :             CodeInfo->rm_byte = ( CodeInfo->rm_byte & ~BIT_345 )
; 1989 :                           | ( ( CodeInfo->rm_byte & BIT_012 ) << 3 );
; 1990 :         } else if( CurrOpnd == OPND3 ) {
; 1991 :             /* v2.04b: if op2 was assumed an immediate due to fwd ref,
; 1992 :              * change it back to a mem ref now.
; 1993 :              */
; 1994 :             if ( ( CodeInfo->opnd_type[OPND2] & OP_I ) &&
; 1995 :                 CodeInfo->InsFixup[OPND2] &&
; 1996 :                 CodeInfo->InsFixup[OPND2]->sym->state == SYM_UNDEFINED )
; 1997 :                 CodeInfo->opnd_type[OPND2] = OP_M;
; 1998 :             CodeInfo->opnd_type[OPND1] = CodeInfo->opnd_type[OPND2];
; 1999 :             CodeInfo->opnd_type[OPND2] = OP_NONE;
; 2000 :             CodeInfo->data[OPND1] = CodeInfo->data[OPND2];
; 2001 :             CodeInfo->data[OPND2] = 0;
; 2002 :             CodeInfo->InsFixup[OPND1] = CodeInfo->InsFixup[OPND2];
; 2003 :             CodeInfo->InsFixup[OPND2] = NULL;
; 2004 :             CurrOpnd = OPND2;
; 2005 :         }
; 2006 :     }
; 2007 : #endif
; 2008 :     /* v2.11: don't accept an empty string */
; 2009 :     if ( opndx->quoted_string && opndx->quoted_string->stringlen == 0 )

	mov	rax, QWORD PTR [r8+16]
	mov	r9, rcx
	test	rax, rax
	je	SHORT $LN2@process_co
	cmp	DWORD PTR [rax+16], 0
	jne	SHORT $LN2@process_co

; 2010 :         return( EmitError( EMPTY_STRING ) );

	mov	ecx, 163				; 000000a3H

; 2025 : }

	jmp	EmitError
$LN2@process_co:

; 2011 : 
; 2012 :     /* optimization: skip <value> if it is 0 and instruction
; 2013 :      * is RET[W|D|N|F]. */
; 2014 :     /* v2.06: moved here and checked the opcode directly, so
; 2015 :      * RETD and RETW are also handled. */
; 2016 :     if ( ( ( CodeInfo->pinstr->opcode & 0xf7 ) == 0xc2 ) &&
; 2017 :         CurrOpnd == OPND1 && opndx->value == 0 ) {

	mov	rax, QWORD PTR [rcx+16]
	movzx	ecx, BYTE PTR [rax+12]
	and	cl, 247					; 000000f7H
	cmp	cl, 194					; 000000c2H
	jne	SHORT $LN1@process_co
	test	edx, edx
	jne	SHORT $LN1@process_co
	cmp	DWORD PTR [r8], edx
	jne	SHORT $LN1@process_co

; 2018 :         //     (CodeInfo.token == T_RET ||
; 2019 :         //      CodeInfo.token == T_RETN ||
; 2020 :         //      CodeInfo.token == T_RETF)) {
; 2021 :         //if ( opndx.sym == NULL || opndx.sym->state == SYM_INTERNAL ) {
; 2022 :         return( NOT_ERROR );

	xor	eax, eax

; 2025 : }

	ret	0
$LN1@process_co:

; 2023 :     }
; 2024 :     return( idata_nofixup( CodeInfo, CurrOpnd, opndx ) );

	mov	rcx, r9

; 2025 : }

	jmp	idata_nofixup
process_const ENDP
_TEXT	ENDS
EXTRN	StdAssumeTable:BYTE
xdata	SEGMENT
$unwind$process_register DD 0b2801H
	DD	04c428H
	DD	09741eH
	DD	086416H
	DD	07540eH
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$process_register DD @imagerel(process_register#)
	DD	@imagerel(process_register#+774)
	DD	@imagerel($unwind$process_register#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
CodeInfo$ = 48
CurrOpnd$ = 56
opndx$ = 64
process_register PROC NEAR

; 2037 : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	rbx, r8
	mov	QWORD PTR [rsp+64], rsi

; 2038 :     enum special_token regtok;
; 2039 :     int  regno;
; 2040 :     uint_32 flags;
; 2041 :     DebugMsg1(( "process_register enter (%s)\n", opndx[CurrOpnd].base_reg->string_ptr ));
; 2042 :     regtok = opndx[CurrOpnd].base_reg->tokval;

	mov	r8d, edx
	mov	QWORD PTR [rsp+72], rdi
	mov	ebp, edx
	mov	r10, rcx
	mov	QWORD PTR [rsp+32], r12
	imul	r8, 104					; 00000068H
	mov	rax, QWORD PTR [r8+rbx+24]

; 2043 :     regno = GetRegNo( regtok );

	lea	r12, OFFSET FLAT:__ImageBase

; 2044 :     /* the register's "OP-flags" are stored in the 'value' field */
; 2045 :     flags = GetValueSp( regtok );
; 2046 :     CodeInfo->opnd[CurrOpnd].type = flags;

	lea	rcx, QWORD PTR [rbp+rbp*2]
	movsxd	rsi, DWORD PTR [rax+16]
	mov	rax, rsi
	lea	rdi, QWORD PTR [rsi+rsi*2]
	mov	edx, DWORD PTR SpecialTable[r12+rdi*4]
	movzx	r11d, BYTE PTR SpecialTable[r12+rdi*4+10]

; 2047 : #if AVXSUPP
; 2048 : 	if (CodeInfo->opnd[CurrOpnd].type == OP_XMM || CodeInfo->opnd[CurrOpnd].type == OP_YMM)

	cmp	edx, 32					; 00000020H
	mov	DWORD PTR [r10+rcx*8+32], edx
	movzx	eax, BYTE PTR evex
	je	SHORT $LN40@process_re
	cmp	edx, 128				; 00000080H
	jne	SHORT $LN39@process_re
$LN40@process_re:

; 2049 : 	{
; 2050 : 		if (!evex && regno > 15)

	test	al, al
	jne	SHORT $LN39@process_re
	cmp	r11d, 15

; 2051 : 		{ 
; 2052 : 			return(EmitError(UNAUTHORISED_USE_OF_EVEX_REGISTERS));

	jg	SHORT $LN37@process_re
$LN39@process_re:

; 2053 : 		}
; 2054 : 	}
; 2055 : 	if (CodeInfo->opnd[CurrOpnd].type == OP_ZMM) {

	cmp	edx, 256				; 00000100H
	jne	SHORT $LN36@process_re

; 2056 : 		if (evex)

	test	al, al
	je	SHORT $LN37@process_re

; 2057 : 			CodeInfo->evex_flag = TRUE;

	mov	BYTE PTR [r10+136], 1
$LN36@process_re:

; 2060 : 	}
; 2061 : 	if (CodeInfo->opnd[CurrOpnd].type == OP_K && regno > 7) {

	cmp	DWORD PTR [r10+rcx*8+32], 64		; 00000040H
	jne	SHORT $LN35@process_re
	cmp	r11d, 7

; 2062 : 		DebugMsg(("process_register: assume error, reg=%u\n", regno));
; 2063 : 		return(EmitError(USE_OF_REGISTER_ASSUMED_TO_ERROR));

	jg	$LN47@process_re
$LN35@process_re:

; 2064 : 	}
; 2065 : #endif    
; 2066 : 	if ( flags & OP_R8 ) {

	test	dl, 1
	je	$LN34@process_re

; 2067 :         /* it's probably better to not reset the wide bit at all */
; 2068 :         if ( flags != OP_CL )      /* problem: SHL AX|AL, CL */

	cmp	edx, 1025				; 00000401H
	je	SHORT $LN33@process_re

; 2069 :             CodeInfo->iswide = 0;

	and	BYTE PTR [r10+142], 254			; 000000feH
$LN33@process_re:

; 2070 : 
; 2071 : #if AMD64_SUPPORT
; 2072 :         if ( CodeInfo->Ofssize == USE64 && regno >=4 && regno <=7 )

	cmp	BYTE PTR [r10+106], 2
	jne	SHORT $LN30@process_re
	lea	eax, DWORD PTR [r11-4]
	cmp	eax, 3
	ja	SHORT $LN30@process_re

; 2073 :             if ( SpecialTable[regtok].cpu == P_86 )

	cmp	WORD PTR SpecialTable[r12+rdi*4+8], 0
	jne	SHORT $LN31@process_re

; 2074 :                 CodeInfo->x86hi_used = 1; /* it's AH,BH,CH,DH */

	or	BYTE PTR [r10+142], 16

; 2075 :             else

	jmp	SHORT $LN30@process_re
$LN37@process_re:

; 2058 : 		else
; 2059 : 			return(EmitError(UNAUTHORISED_USE_OF_EVEX_REGISTERS));

	mov	ecx, 22
	call	EmitError
	jmp	$LN42@process_re
$LN31@process_re:

; 2076 :                 CodeInfo->x64lo_used = 1; /* it's SPL,BPL,SIL,DIL */

	or	BYTE PTR [r10+142], 32			; 00000020H
$LN30@process_re:

; 2077 : #endif
; 2078 :         if ( StdAssumeTable[regno].error & (( regtok >= T_AH && regtok <= T_BH ) ? RH_ERROR : RL_ERROR ) ) {

	lea	eax, DWORD PTR [rsi-5]
	mov	ecx, 1
	mov	r8d, 16
	cmp	eax, 3
	movsxd	rax, r11d
	cmovbe	ecx, r8d
	shl	rax, 4
	test	BYTE PTR StdAssumeTable[rax+r12+8], cl
	je	$LN12@process_re
$LN47@process_re:

; 2079 :             DebugMsg(("process_register: assume error, reg=%u\n", regno ));
; 2080 :             return( EmitError( USE_OF_REGISTER_ASSUMED_TO_ERROR ) );

	mov	ecx, 183				; 000000b7H
	call	EmitError
	jmp	$LN42@process_re
$LN34@process_re:

; 2081 :         }
; 2082 :     } else if ( flags & OP_R ) { /* 16-, 32- or 64-bit GPR? */

	test	dl, 15
	je	SHORT $LN27@process_re

; 2083 :         CodeInfo->iswide = 1;

	or	BYTE PTR [r10+142], 1

; 2084 :         if ( StdAssumeTable[regno].error & flags & OP_R ) {

	mov	rax, r11
	shl	rax, 4
	mov	al, BYTE PTR StdAssumeTable[rax+r12+8]
	and	eax, edx
	test	al, 15

; 2085 :             DebugMsg(("process_register: assume error, reg=%u\n", regno ));
; 2086 :             return( EmitError( USE_OF_REGISTER_ASSUMED_TO_ERROR ) );

	jne	SHORT $LN47@process_re

; 2087 :         }
; 2088 :         if ( flags & OP_R16 ) {

	test	dl, 2
	je	SHORT $LN25@process_re

; 2089 :             if ( CodeInfo->Ofssize > USE16 )

	cmp	BYTE PTR [r10+106], 0
	jbe	$LN12@process_re

; 2090 :                 CodeInfo->prefix.opsiz = TRUE;

	or	BYTE PTR [r10+9], 2

; 2091 :         } else {

	jmp	$LN12@process_re
$LN25@process_re:

; 2092 :             if( CodeInfo->Ofssize == USE16 )

	cmp	BYTE PTR [r10+106], 0
	jne	$LN12@process_re

; 2093 :                 CodeInfo->prefix.opsiz = TRUE;

	or	BYTE PTR [r10+9], 2

; 2094 :         }

	jmp	$LN12@process_re
$LN27@process_re:

; 2095 :     } else if ( flags & OP_SR ) {

	test	edx, 24576				; 00006000H
	je	SHORT $LN20@process_re

; 2096 :         if( regno == 1 ) { /* 1 is CS */

	cmp	r11d, 1
	jne	$LN12@process_re

; 2097 :             /* POP CS is not allowed */
; 2098 :             if( CodeInfo->token == T_POP ) {

	cmp	DWORD PTR [r10+24], 602			; 0000025aH
	jne	$LN12@process_re

; 2099 :                 return( EmitError( POP_CS_IS_NOT_ALLOWED ) );

	lea	ecx, QWORD PTR [r11+40]
	call	EmitError
	jmp	$LN42@process_re
$LN20@process_re:

; 2100 :             }
; 2101 :         }
; 2102 :     } else if ( flags & OP_ST ) {

	bt	edx, 15
	jae	SHORT $LN16@process_re

; 2103 : 
; 2104 :         regno = opndx[CurrOpnd].st_idx;

	mov	eax, DWORD PTR [r8+rbx]

; 2105 :         if ( regno > 7 ) { /* v1.96: index check added */

	cmp	eax, 7
	jle	SHORT $LN15@process_re

; 2106 :             return( EmitError( INVALID_COPROCESSOR_REGISTER ) );

	mov	ecx, 252				; 000000fcH
	call	EmitError
	jmp	$LN42@process_re
$LN15@process_re:

; 2107 :         }
; 2108 :         CodeInfo->rm_byte |= regno;

	or	BYTE PTR [r10+104], al

; 2109 :         if( regno != 0 )

	test	eax, eax
	je	$LN14@process_re

; 2110 :             CodeInfo->opnd[CurrOpnd].type = OP_ST_REG;

	mov	DWORD PTR [r10+rcx*8+32], 65536		; 00010000H

; 2111 :         /* v2.06: exit, rm_byte is already set. */
; 2112 :         return( NOT_ERROR );

	jmp	$LN14@process_re
$LN16@process_re:

; 2113 : 
; 2114 :     } else if ( flags & OP_RSPEC ) { /* CRx, DRx, TRx */

	bt	edx, 12
	jae	SHORT $LN12@process_re

; 2115 :         if( CodeInfo->token != T_MOV ) {

	cmp	DWORD PTR [r10+24], 606			; 0000025eH
	je	SHORT $LN11@process_re

; 2116 :             return( EmitError( ONLY_MOV_CAN_USE_SPECIAL_REGISTER ) );

	mov	ecx, 42					; 0000002aH
	call	EmitError
	jmp	$LN42@process_re
$LN11@process_re:

; 2117 :         }
; 2118 :         /* v2.04: previously there were 3 flags, OP_CR, OP_DR and OP_TR.
; 2119 :          * this was summoned to one flag OP_RSPEC to free 2 flags, which
; 2120 :          * are needed if AVC ( new YMM registers ) is to be supported.
; 2121 :          * To distinguish between CR, DR and TR, the register number is
; 2122 :          * used now: CRx are numbers 0-F, DRx are numbers 0x10-0x1F and
; 2123 :          * TRx are 0x20-0x2F.
; 2124 :          */
; 2125 : 		if (regno >= 0x20) { /* TRx? */

	cmp	r11d, 32				; 00000020H
	jl	SHORT $LN10@process_re

; 2126 : 			CodeInfo->opc_or |= 0x04;

	or	BYTE PTR [r10+107], 4

; 2127 : 			/* TR3-TR5 are available on 486-586
; 2128 : 			* TR6+TR7 are available on 386-586
; 2129 : 			* v2.11: simplified.
; 2130 : 			*/
; 2131 : 			if ((ModuleInfo.curr_cpu & P_CPU_MASK) >= P_686) {

	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 96					; 00000060H
	jl	SHORT $LN7@process_re

; 2132 : 				return(EmitErr(CANNOT_USE_TRN_TO_TRM_WITH_CURRENT_CPU_SETTING, regno > 0x25 ? 6 : 3, regno > 0x25 ? 7 : 5));

	mov	eax, 7
	cmp	r11d, 37				; 00000025H
	mov	r8d, 5
	cmovg	r8d, eax
	mov	eax, 6
	mov	edx, 3
	cmp	r11d, 37				; 00000025H
	lea	ecx, QWORD PTR [rax+26]
	cmovg	edx, eax
	call	EmitErr
	jmp	$LN42@process_re
$LN10@process_re:

; 2133 : 			}
; 2134 : 		}
; 2135 : 		else if (regno >= 0x10) { /* DRx? */

	cmp	r11d, 16
	jl	SHORT $LN7@process_re

; 2136 : 			CodeInfo->opc_or |= 0x01;

	or	BYTE PTR [r10+107], 1
$LN7@process_re:

; 2137 : 		}
; 2138 : 		regno &= 0x0F;

	and	r11d, 15
$LN12@process_re:

; 2139 : 	}
; 2140 : #if AMD64_SUPPORT
; 2141 : 
; 2142 :     /* if it's a x86-64 register (SIL, R8W, R8D, RSI, ... */
; 2143 :     if ( ( SpecialTable[regtok].cpu & P_CPU_MASK ) == P_64 ) {

	movzx	eax, BYTE PTR SpecialTable[r12+rdi*4+8]
	and	al, 240					; 000000f0H
	cmp	al, 112					; 00000070H
	jne	SHORT $LN5@process_re

; 2144 :         CodeInfo->prefix.rex |= 0x40;

	or	BYTE PTR [r10+8], 64			; 00000040H

; 2145 :         if ( flags & OP_R64 )

	test	dl, 8
	movzx	eax, BYTE PTR [r10+8]
	je	SHORT $LN5@process_re

; 2146 :             CodeInfo->prefix.rex |= REX_W;

	or	al, 8
	mov	BYTE PTR [r10+8], al
$LN5@process_re:

; 2147 :     }
; 2148 : #endif
; 2149 :     if( CurrOpnd == OPND1 ) {

	test	ebp, ebp
	jne	SHORT $LN4@process_re

; 2150 :         /* the first operand
; 2151 :          * r/m is treated as a 'reg' field */
; 2152 :         CodeInfo->rm_byte |= MOD_11;
; 2153 : #if AMD64_SUPPORT
; 2154 :         CodeInfo->prefix.rex |= (regno & 8 ) >> 3; /* set REX_B */

	mov	eax, r11d

; 2155 :         regno &= BIT_012;

	and	r11b, 7
	sar	eax, 3
	and	al, 1

; 2156 : #endif
; 2157 :         /* fill the r/m field */
; 2158 :         CodeInfo->rm_byte |= regno;

	or	r11b, 192				; 000000c0H

; 2159 :     } else {

	jmp	SHORT $LN46@process_re
$LN4@process_re:

; 2160 :         /* the second operand
; 2161 :          * XCHG can use short form if op1 is AX/EAX/RAX */
; 2162 :         if( ( CodeInfo->token == T_XCHG ) && ( CodeInfo->opnd[OPND1].type & OP_A ) &&
; 2163 :              ( 0 == (CodeInfo->opnd[OPND1].type & OP_R8 ) ) ) {

	cmp	DWORD PTR [r10+24], 666			; 0000029aH
	jne	SHORT $LN2@process_re
	mov	eax, DWORD PTR [r10+32]
	bt	eax, 9
	jae	SHORT $LN2@process_re
	and	eax, 1
	test	al, al
	jne	SHORT $LN2@process_re

; 2164 : #if AMD64_SUPPORT
; 2165 :             CodeInfo->prefix.rex |= (regno & 8 ) >> 3; /* set REX_B */
; 2166 :             regno &= BIT_012;
; 2167 : #endif
; 2168 :             CodeInfo->rm_byte = ( CodeInfo->rm_byte & BIT_67 ) | regno;

	and	BYTE PTR [r10+104], 192			; 000000c0H
	mov	eax, r11d
	sar	eax, 3
	and	al, 1
	and	r11b, 7

; 2169 :         } else {

	jmp	SHORT $LN46@process_re
$LN2@process_re:

; 2170 :             /* fill reg field with reg */
; 2171 : #if AMD64_SUPPORT
; 2172 :             CodeInfo->prefix.rex |= (regno & 8 ) >> 1; /* set REX_R */
; 2173 :             regno &= BIT_012;
; 2174 : #endif
; 2175 :             CodeInfo->rm_byte = ( CodeInfo->rm_byte & ~BIT_345 ) | ( regno << 3 );

	and	BYTE PTR [r10+104], 199			; 000000c7H
	mov	eax, r11d
	and	r11b, 7
	sar	eax, 1
	and	al, 4
	shl	r11b, 3
$LN46@process_re:
	or	BYTE PTR [r10+8], al
	or	BYTE PTR [r10+104], r11b
$LN14@process_re:

; 2176 :         }
; 2177 :     }
; 2178 :     return( NOT_ERROR );

	xor	eax, eax
$LN42@process_re:
	mov	r12, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 2179 : }

	add	rsp, 40					; 00000028H
	ret	0
process_register ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$HandleStringInstructions DD 071901H
	DD	097419H
	DD	08640eH
	DD	073409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$HandleStringInstructions DD @imagerel(HandleStringInstructions#)
	DD	@imagerel(HandleStringInstructions#+904)
	DD	@imagerel($unwind$HandleStringInstructions#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
CodeInfo$ = 48
opndx$ = 56
HandleStringInstructions PROC NEAR

; 2197 : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi
	mov	rbx, rcx

; 2198 :     int opndidx = OPND1;
; 2199 :     int op_size;
; 2200 : 
; 2201 :     switch( CodeInfo->token ) {

	mov	ecx, DWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+72], rdi
	xor	edi, edi
	cmp	ecx, 1220				; 000004c4H
	lea	rsi, OFFSET FLAT:__ImageBase
	jg	$LN53@HandleStri
	cmp	ecx, 1220				; 000004c4H
	je	$LN47@HandleStri
	cmp	ecx, 536				; 00000218H
	jg	SHORT $LN54@HandleStri
	cmp	ecx, 536				; 00000218H
	je	SHORT $LN37@HandleStri
	sub	ecx, 521				; 00000209H
	cmp	ecx, 14
	ja	$LN25@HandleStri
	movsxd	rax, ecx
	mov	ecx, DWORD PTR $LN56@HandleStri[rsi+rax*4]
	add	rcx, rsi
	jmp	rcx
$LN54@HandleStri:
	cmp	ecx, 537				; 00000219H
	jl	$LN25@HandleStri
	cmp	ecx, 540				; 0000021cH
	jle	SHORT $LN29@HandleStri
	cmp	ecx, 1047				; 00000417H
	je	SHORT $LN36@HandleStri
	cmp	ecx, 1053				; 0000041dH
	jne	$LN25@HandleStri
$LN37@HandleStri:

; 2243 :             }
; 2244 :         }
; 2245 :         break;
; 2246 : #if AVXSUPP
; 2247 :     case T_VMOVSD:
; 2248 :     case T_VMOVUPS:
; 2249 : #endif
; 2250 :     case T_MOVSD:
; 2251 :     case T_MOVUPS:
; 2252 : 
; 2253 :         /* filter SSE2 opcode MOVSD */
; 2254 :         if ( ( CodeInfo->opnd[OPND1].type & (OP_XMM | OP_MMX | OP_YMM | OP_ZMM) ) ||
; 2255 :             ( CodeInfo->opnd[OPND2].type & (OP_XMM | OP_MMX | OP_YMM | OP_ZMM) ) ) {

	test	DWORD PTR [rbx+32], 432			; 000001b0H
	jne	SHORT $LN35@HandleStri
	test	DWORD PTR [rbx+56], 432			; 000001b0H
	jne	SHORT $LN35@HandleStri
$LN36@HandleStri:

; 2256 :             /* v2.01: QWORD operand for CMPSD/MOVSD may have set REX_W! */
; 2257 : #if AMD64_SUPPORT
; 2258 :             CodeInfo->prefix.rex &= ~REX_W;
; 2259 : #endif
; 2260 :             return;
; 2261 :         }
; 2262 :         /* fall through */
; 2263 :     case T_MOVS:
; 2264 :     case T_MOVSB:
; 2265 :     case T_MOVSW:
; 2266 : #if AMD64_SUPPORT
; 2267 :     case T_MOVSQ:
; 2268 :     case T_MOVQ:
; 2269 : #endif
; 2270 :         /* movs allows prefix for the second operand (=source) only */
; 2271 :         if ( CodeInfo->prefix.RegOverride != EMPTY )

	mov	eax, DWORD PTR [rbx+4]
	cmp	eax, -2
	je	$LN38@HandleStri

; 2272 :             if ( opndx[OPND2].override == NULL )

	cmp	QWORD PTR [rdx+152], rdi
	jne	$LN32@HandleStri

; 2273 :                 EmitError( INVALID_INSTRUCTION_OPERANDS );

	mov	ecx, 49					; 00000031H
	call	EmitError
	jmp	$LN38@HandleStri
$LN29@HandleStri:

; 2277 :     case T_OUTS:
; 2278 :     case T_OUTSB:
; 2279 :     case T_OUTSW:
; 2280 :     case T_OUTSD:
; 2281 :         /* v2.01: remove default DS prefix */
; 2282 :         if ( CodeInfo->prefix.RegOverride == ASSUME_DS )

	cmp	DWORD PTR [rbx+4], 3
	jne	SHORT $LN28@HandleStri

; 2283 :             CodeInfo->prefix.RegOverride = EMPTY;

	mov	ecx, -2
	mov	DWORD PTR [rbx+4], ecx
$LN28@HandleStri:

; 2284 :         opndidx = OPND2;

	mov	edi, 1

; 2285 :         break;

	jmp	$LN38@HandleStri
$LN53@HandleStri:

; 2198 :     int opndidx = OPND1;
; 2199 :     int op_size;
; 2200 : 
; 2201 :     switch( CodeInfo->token ) {

	cmp	ecx, 1494				; 000005d6H
	jg	SHORT $LN55@HandleStri
	cmp	ecx, 1493				; 000005d5H
	jge	SHORT $LN48@HandleStri
	cmp	ecx, 1221				; 000004c5H
	je	SHORT $LN27@HandleStri
	cmp	ecx, 1222				; 000004c6H
	je	SHORT $LN36@HandleStri
	cmp	ecx, 1486				; 000005ceH
	jle	SHORT $LN25@HandleStri
	cmp	ecx, 1488				; 000005d0H
	jg	SHORT $LN25@HandleStri
$LN48@HandleStri:

; 2202 : #if AVXSUPP
; 2203 :     case T_VCMPSD:
; 2204 :     case T_VPCMPD:
; 2205 :     case T_VPCMPB:
; 2206 :     case T_VPCMPUD:
; 2207 :     case T_VPCMPUB:
; 2208 : #endif
; 2209 :     case T_CMPSD:
; 2210 :         /* filter SSE2 opcode CMPSD */
; 2211 :         if ( CodeInfo->opnd[OPND1].type & (OP_XMM | OP_MMX)) {

	test	BYTE PTR [rbx+32], 48			; 00000030H
	je	SHORT $LN47@HandleStri
$LN35@HandleStri:

; 2212 :             /* v2.01: QWORD operand for CMPSD/MOVSD may have set REX_W! */
; 2213 : #if AMD64_SUPPORT
; 2214 :             CodeInfo->prefix.rex &= ~REX_W;

	and	BYTE PTR [rbx+8], 247			; 000000f7H
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 2354 : #endif
; 2355 :         }
; 2356 :     }
; 2357 :     return;
; 2358 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN27@HandleStri:

; 2286 :     case T_LODS:
; 2287 :     case T_LODSB:
; 2288 :     case T_LODSW:
; 2289 :     case T_LODSD:
; 2290 : #if AMD64_SUPPORT
; 2291 :     case T_LODSQ:
; 2292 : #endif
; 2293 :         /* v2.10: remove unnecessary DS prefix ( Masm-compatible ) */
; 2294 :         if ( CodeInfo->prefix.RegOverride == ASSUME_DS )

	cmp	DWORD PTR [rbx+4], 3
	jne	$LN38@HandleStri

; 2295 :             CodeInfo->prefix.RegOverride = EMPTY;

	mov	ecx, -2
	mov	DWORD PTR [rbx+4], ecx

; 2296 :         break;

	jmp	$LN38@HandleStri
$LN55@HandleStri:

; 2198 :     int opndidx = OPND1;
; 2199 :     int op_size;
; 2200 : 
; 2201 :     switch( CodeInfo->token ) {

	sub	ecx, 1806				; 0000070eH
	je	SHORT $LN48@HandleStri
	sub	ecx, 181				; 000000b5H
	je	$LN37@HandleStri
	cmp	ecx, 11
	je	$LN37@HandleStri
$LN25@HandleStri:

; 2297 :     default: /*INS[B|W|D], SCAS[B|W|D|Q], STOS[B|W|D|Q] */
; 2298 :         /* INSx, SCASx and STOSx don't allow any segment prefix != ES
; 2299 :          for the memory operand.
; 2300 :          */
; 2301 :         if ( CodeInfo->prefix.RegOverride != EMPTY )

	mov	eax, DWORD PTR [rbx+4]
	cmp	eax, -2
	je	SHORT $LN38@HandleStri

; 2302 :             if ( CodeInfo->prefix.RegOverride == ASSUME_ES )

	test	eax, eax
	jne	SHORT $LN23@HandleStri

; 2303 :                 CodeInfo->prefix.RegOverride = EMPTY;

	mov	ecx, -2
	mov	DWORD PTR [rbx+4], ecx

; 2304 :             else

	jmp	SHORT $LN38@HandleStri
$LN23@HandleStri:

; 2305 :                 EmitError( INVALID_INSTRUCTION_OPERANDS );

	mov	ecx, 49					; 00000031H
	call	EmitError
	jmp	SHORT $LN38@HandleStri
$LN32@HandleStri:

; 2274 :             else if ( CodeInfo->prefix.RegOverride == ASSUME_DS )

	cmp	eax, 3
	jne	SHORT $LN38@HandleStri

; 2275 :                 CodeInfo->prefix.RegOverride = EMPTY;

	mov	ecx, -2
	mov	DWORD PTR [rbx+4], ecx

; 2276 :         break;

	jmp	SHORT $LN38@HandleStri
$LN47@HandleStri:

; 2215 : #endif
; 2216 :             return;
; 2217 :         }
; 2218 :         /* fall through */
; 2219 :     case T_CMPS:
; 2220 :     case T_CMPSB:
; 2221 :     case T_CMPSW:
; 2222 : #if AMD64_SUPPORT
; 2223 :     case T_CMPSQ:
; 2224 : #endif
; 2225 :          /* cmps allows prefix for the first operand (=source) only */
; 2226 :         if ( CodeInfo->prefix.RegOverride != EMPTY ) {

	mov	eax, DWORD PTR [rbx+4]
	cmp	eax, -2
	je	SHORT $LN38@HandleStri

; 2227 :             if ( opndx[OPND2].override != NULL ) {

	cmp	QWORD PTR [rdx+152], rdi
	je	SHORT $LN44@HandleStri

; 2228 :                 if ( CodeInfo->prefix.RegOverride == ASSUME_ES ) {

	test	eax, eax
	jne	SHORT $LN43@HandleStri

; 2229 :                     /* content of LastRegOverride is valid if
; 2230 :                      * CodeInfo->RegOverride is != EMPTY.
; 2231 :                      */
; 2232 :                     if ( LastRegOverride == ASSUME_DS )

	mov	eax, DWORD PTR LastRegOverride
	mov	ecx, -2
	cmp	eax, 3
	cmove	eax, ecx
	mov	DWORD PTR [rbx+4], eax

; 2233 :                         CodeInfo->prefix.RegOverride = EMPTY;
; 2234 :                     else
; 2235 :                         CodeInfo->prefix.RegOverride = LastRegOverride;
; 2236 :                 } else {

	jmp	SHORT $LN38@HandleStri
$LN43@HandleStri:

; 2237 :                     DebugMsg1(("HandleStringInstructions: CMPS: CodeInfo->RegOverride=%X, opndx->override=%s\n", CodeInfo->prefix.RegOverride, opndx[OPND2].override->string_ptr ));
; 2238 :                     EmitError( INVALID_INSTRUCTION_OPERANDS );

	mov	ecx, 49					; 00000031H
	call	EmitError

; 2239 :                 }

	jmp	SHORT $LN38@HandleStri
$LN44@HandleStri:

; 2240 :             } else if ( CodeInfo->prefix.RegOverride == ASSUME_DS ) {

	cmp	eax, 3
	jne	SHORT $LN38@HandleStri

; 2241 :                 /* prefix for first operand? */
; 2242 :                 CodeInfo->prefix.RegOverride = EMPTY;

	mov	ecx, -2
	mov	DWORD PTR [rbx+4], ecx
$LN38@HandleStri:

; 2306 :     }
; 2307 : 
; 2308 :     if ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[opndidx] == OP_NONE ) {

	mov	rdx, QWORD PTR [rbx+16]
	movsxd	r9, edi
	movzx	ecx, BYTE PTR [rdx]
	lea	rax, QWORD PTR [r9+rcx*2]
	add	rcx, rax
	cmp	DWORD PTR opnd_clstab[rsi+rcx*4], 0
	jne	SHORT $LN21@HandleStri

; 2309 :         CodeInfo->iswide = 0;

	and	BYTE PTR [rbx+142], 254			; 000000feH

; 2310 :         CodeInfo->prefix.opsiz = FALSE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH
$LN21@HandleStri:

; 2311 :     }
; 2312 : 
; 2313 :     /* if the instruction is the variant without suffix (MOVS, LODS, ..),
; 2314 :      * then use the operand's size to get further info.
; 2315 :      */
; 2316 :     //if ( CodeInfo->pinstr->opnd_type[opndidx] != OP_NONE &&
; 2317 :     if ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[opndidx] != OP_NONE &&
; 2318 :         CodeInfo->opnd[opndidx].type != OP_NONE ) {

	movzx	ecx, BYTE PTR [rdx]
	lea	rax, QWORD PTR [r9+rcx*2]
	add	rcx, rax
	cmp	DWORD PTR opnd_clstab[rsi+rcx*4], 0
	je	$LN6@HandleStri
	lea	rax, QWORD PTR [r9+r9*2]
	mov	ecx, DWORD PTR [rbx+rax*8+32]
	test	ecx, ecx
	je	$LN6@HandleStri

; 2319 :         if (CodeInfo->token == T_KMOVB) op_size = 1;

	mov	eax, DWORD PTR [rbx+24]
	cmp	eax, 1773				; 000006edH
	jne	SHORT $LN19@HandleStri
	mov	ecx, 1
	jmp	SHORT $LN10@HandleStri
$LN19@HandleStri:

; 2320 :         else if (CodeInfo->token == T_KMOVW) op_size = 2;

	cmp	eax, 1776				; 000006f0H
	jne	SHORT $LN17@HandleStri
	mov	ecx, 2
	jmp	SHORT $LN10@HandleStri
$LN17@HandleStri:

; 2321 :         else if (CodeInfo->token == T_KMOVD) op_size = 4;

	cmp	eax, 1774				; 000006eeH
	jne	SHORT $LN15@HandleStri
	mov	ecx, 4
	jmp	SHORT $LN10@HandleStri
$LN15@HandleStri:

; 2322 :         else if (CodeInfo->token == T_KMOVQ) op_size = 8;

	cmp	eax, 1775				; 000006efH
	jne	SHORT $LN13@HandleStri
	mov	ecx, 8
	jmp	SHORT $LN10@HandleStri
$LN13@HandleStri:

; 2323 :         else op_size = OperandSize( CodeInfo->opnd[opndidx].type, CodeInfo );

	mov	rdx, rbx
	call	OperandSize

; 2324 :         /* v2.06: added. if memory operand has no size */
; 2325 :         if ( op_size == 0 )

	test	eax, eax
	mov	ecx, eax
	jne	SHORT $LN10@HandleStri

; 2326 :           op_size = OperandSize( CodeInfo->opnd[opndidx+1].type, CodeInfo );

	lea	rax, QWORD PTR [r9+r9*2]
	mov	rdx, rbx
	mov	ecx, DWORD PTR [rbx+rax*8+56]
	call	OperandSize

; 2327 :         if ( op_size == 0 ) {

	test	eax, eax
	mov	ecx, eax
	jne	SHORT $LN10@HandleStri

; 2328 :             if ( CodeInfo->opnd[opndidx].InsFixup == NULL || CodeInfo->opnd[opndidx].InsFixup->sym->state != SYM_UNDEFINED )

	lea	rax, QWORD PTR [r9+r9*2+6]
	mov	rax, QWORD PTR [rbx+rax*8]
	test	rax, rax
	je	SHORT $LN8@HandleStri
	mov	rax, QWORD PTR [rax+56]
	cmp	DWORD PTR [rax+40], ecx
	je	SHORT $LN9@HandleStri
$LN8@HandleStri:

; 2329 :                 EmitError( INSTRUCTION_OPERAND_MUST_HAVE_SIZE );

	mov	ecx, 182				; 000000b6H
	call	EmitError
$LN9@HandleStri:

; 2330 :             op_size = 1; /* assume shortest format */

	mov	ecx, 1
$LN10@HandleStri:

; 2331 :         }
; 2332 :         switch( op_size ) {

	dec	ecx
	je	SHORT $LN5@HandleStri
	dec	ecx
	je	SHORT $LN4@HandleStri
	sub	ecx, 2
	je	SHORT $LN3@HandleStri
	cmp	ecx, 4
	jne	SHORT $LN6@HandleStri

; 2345 :             break;
; 2346 : #if AMD64_SUPPORT
; 2347 :         case 8:
; 2348 :             if ( CodeInfo->Ofssize == USE64 ) {

	cmp	BYTE PTR [rbx+106], 2
	jne	SHORT $LN6@HandleStri

; 2349 :                 CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], 1

; 2350 :                 CodeInfo->prefix.opsiz = FALSE;
; 2351 :                 CodeInfo->prefix.rex = REX_W;

	mov	BYTE PTR [rbx+8], 8

; 2352 :             }
; 2353 :             break;

	jmp	SHORT $LN57@HandleStri
$LN3@HandleStri:

; 2341 :             break;
; 2342 :         case 4:
; 2343 :             CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], 1

; 2344 :             CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? FALSE : TRUE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], 0
	sete	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 2354 : #endif
; 2355 :         }
; 2356 :     }
; 2357 :     return;
; 2358 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@HandleStri:

; 2337 :             break;
; 2338 :         case 2:
; 2339 :             CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], 1

; 2340 :             CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? TRUE : FALSE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], 0
	setne	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 2354 : #endif
; 2355 :         }
; 2356 :     }
; 2357 :     return;
; 2358 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN5@HandleStri:

; 2333 :         case 1:
; 2334 :             CodeInfo->iswide = 0;

	and	BYTE PTR [rbx+142], 254			; 000000feH
$LN57@HandleStri:

; 2335 :             //if( CodeInfo->Ofssize )
; 2336 :                 CodeInfo->prefix.opsiz = FALSE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH
$LN6@HandleStri:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 2354 : #endif
; 2355 :         }
; 2356 :     }
; 2357 :     return;
; 2358 : }

	add	rsp, 40					; 00000028H
	ret	0
	npad	2
$LN56@HandleStri:
	DD	$LN47@HandleStri
	DD	$LN47@HandleStri
	DD	$LN47@HandleStri
	DD	$LN48@HandleStri
	DD	$LN25@HandleStri
	DD	$LN25@HandleStri
	DD	$LN25@HandleStri
	DD	$LN25@HandleStri
	DD	$LN27@HandleStri
	DD	$LN27@HandleStri
	DD	$LN27@HandleStri
	DD	$LN27@HandleStri
	DD	$LN36@HandleStri
	DD	$LN36@HandleStri
	DD	$LN36@HandleStri
HandleStringInstructions ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$check_size DD 0113b01H
	DD	05f43bH
	DD	06e42dH
	DD	07d429H
	DD	08c425H
	DD	0d741eH
	DD	0c641aH
	DD	0b5413H
	DD	0a340fH
	DD	08207H
xdata	ENDS
pdata	SEGMENT
$pdata$check_size DD @imagerel(check_size#)
	DD	@imagerel(check_size#+2571)
	DD	@imagerel($unwind$check_size#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
CodeInfo$ = 80
opndx$ = 88
check_size PROC NEAR

; 2369 : {

	mov	rax, rsp
	sub	rsp, 72					; 00000048H

; 2370 :     enum operand_type op1 = CodeInfo->opnd[OPND1].type;
; 2371 :     enum operand_type op2 = CodeInfo->opnd[OPND2].type;
; 2372 :     ret_code    rc = NOT_ERROR;
; 2373 :     int         op1_size;
; 2374 :     int         op2_size;
; 2375 :     //int         op_size = 0;
; 2376 :     DebugMsg1(("check_size enter, optype1=%" I32_SPEC "X, optype2=%" I32_SPEC "X\n", op1, op2 ));
; 2377 :     if (CodeInfo->token >= T_KADDB && CodeInfo->token <= T_KUNPCKDQ){

	mov	r11d, DWORD PTR [rcx+24]
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	ebp, DWORD PTR [rcx+32]
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	edi, DWORD PTR [rcx+56]
	mov	QWORD PTR [rax-8], r12
	mov	QWORD PTR [rax-16], r13
	mov	QWORD PTR [rax-24], r14
	xor	r12d, r12d
	cmp	r11d, 1730				; 000006c2H
	mov	QWORD PTR [rax-32], r15
	mov	r15, rdx
	mov	rbx, rcx
	mov	r14d, 262144				; 00040000H
	jl	SHORT $LN135@check_size
	cmp	r11d, 1756				; 000006dcH
	jg	SHORT $LN135@check_size

; 2378 :       //int op3_size;
; 2379 :       if ((CodeInfo->opnd[OPND1].type != OP_K) && (CodeInfo->opnd[OPND2].type != OP_K) &&
; 2380 :         (CodeInfo->opnd[OPND3].type != OP_K))

	cmp	ebp, 64					; 00000040H
	je	SHORT $LN134@check_size
	cmp	edi, 64					; 00000040H
	je	SHORT $LN134@check_size
	cmp	DWORD PTR [rcx+80], 64			; 00000040H
	je	SHORT $LN134@check_size

; 2381 :         return(EmitError(INVALID_INSTRUCTION_OPERANDS));

	lea	ecx, QWORD PTR [r12+49]
	call	EmitError
	jmp	$LN136@check_size
$LN134@check_size:

; 2382 :       CodeInfo->indextype = OP_K;

	mov	DWORD PTR [rcx+132], 64			; 00000040H

; 2383 :       CodeInfo->basetype = OP_K;

	mov	BYTE PTR [rcx+108], 64			; 00000040H

; 2384 : 
; 2385 :       op1_size = CodeInfo->pinstr->prefix;
; 2386 :       op2_size = CodeInfo->pinstr->prefix;
; 2387 :       goto def_check;

	jmp	$def_check$6937
$LN135@check_size:

; 2388 :     }
; 2389 : 
; 2390 :     switch( CodeInfo->token ) {

	cmp	r11d, 1025				; 00000401H
	mov	ecx, r11d
	jg	$LN140@check_size
	cmp	r11d, 1024				; 00000400H
	jge	$LN6@check_size
	sub	ecx, 513				; 00000201H
	cmp	ecx, 131				; 00000083H
	ja	$def_check$6937
	lea	rdx, OFFSET FLAT:__ImageBase
	movsxd	rax, ecx
	movzx	eax, BYTE PTR $LN149@check_size[rdx+rax]
	mov	ecx, DWORD PTR $LN150@check_size[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN131@check_size:

; 2391 :     case T_IN:
; 2392 :         if( op2 == OP_DX ) {

	cmp	edi, 2050				; 00000802H
	jne	$LN6@check_size

; 2393 :             /* wide and size is NOT determined by DX, but
; 2394 :              * by the first operand, AL|AX|EAX
; 2395 :              */
; 2396 :             switch( op1 ) {

	sub	ebp, 513				; 00000201H
	je	SHORT $LN126@check_size
	cmp	ebp, 3
	je	SHORT $LN125@check_size
	jmp	$LN6@check_size
$LN126@check_size:

; 2397 :             case OP_AX:
; 2398 :                 break;
; 2399 :             case OP_AL:
; 2400 :                 CodeInfo->iswide = 0;         /* clear w-bit */

	and	BYTE PTR [rbx+142], 254			; 000000feH
$LN125@check_size:

; 2401 :             case OP_EAX:
; 2402 :                 if( CodeInfo->Ofssize ) {

	cmp	BYTE PTR [rbx+106], r12b
	je	$LN6@check_size
$LN151@check_size:

; 2403 :                     CodeInfo->prefix.opsiz = FALSE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH

; 2404 :                 }
; 2405 :                 break;
; 2406 :             }
; 2407 :         }
; 2408 :         break;

	jmp	$LN6@check_size
$LN123@check_size:

; 2409 :     case T_OUT:
; 2410 :         if( op1 == OP_DX ) {

	cmp	ebp, 2050				; 00000802H
	jne	$LN6@check_size

; 2411 :             switch( op2 ) {

	sub	edi, 513				; 00000201H
	je	SHORT $LN126@check_size
	cmp	edi, 3
	je	SHORT $LN125@check_size
	jmp	$LN6@check_size
$LN114@check_size:

; 2412 :             case OP_AX:
; 2413 :                 break;
; 2414 :             case OP_AL:
; 2415 :                 CodeInfo->iswide = 0;         /* clear w-bit */
; 2416 :             case OP_EAX:
; 2417 :                 if( CodeInfo->Ofssize ) {
; 2418 :                     CodeInfo->prefix.opsiz = FALSE;
; 2419 :                 }
; 2420 :             }
; 2421 :         }
; 2422 :         break;
; 2423 :     case T_LEA:
; 2424 : #if 0
; 2425 :         /* first op must be 16/32 register, but this condition is checked
; 2426 :          in CodeGen. operands 1 and 2 can be mixed:
; 2427 :          lea cx,[bp]
; 2428 :          lea cx,[ebp]
; 2429 :          lea ecx,[bp]
; 2430 :          lea ecx,[ebp]
; 2431 :          are all valid. However, Masm sometimes complains
; 2432 :          "cannot use 16-bit register with a 32-bit address"
; 2433 :          */
; 2434 :         switch( OperandSize( op1, CodeInfo ) ) {
; 2435 :         case 2:
; 2436 :         case 4:
; 2437 :             break;
; 2438 :         default:
; 2439 :             EmitErr( OPERANDS_MUST_BE_THE_SAME_SIZE, OperandSize( op1, CodeInfo ), ModuleInfo.Ofssize ? 4 : 2);
; 2440 :             rc = ERROR;
; 2441 :         }
; 2442 : #endif
; 2443 :         break;
; 2444 :     case T_RCL:
; 2445 :     case T_RCR:
; 2446 :     case T_ROL:
; 2447 :     case T_ROR:
; 2448 :     case T_SAL:
; 2449 :     case T_SAR:
; 2450 :     case T_SHL:
; 2451 :     case T_SHR:
; 2452 :         /* v2.11: added */
; 2453 :         if ( CodeInfo->opnd[OPND1].type == OP_M && CodeInfo->undef_sym == FALSE &&
; 2454 :             ( opndx[OPND1].sym == NULL || opndx[OPND1].sym->state != SYM_UNDEFINED ) ) {

	cmp	ebp, -1887436800			; ffffffff8f800000H
	jne	SHORT $LN113@check_size
	test	BYTE PTR [rbx+142], 64			; 00000040H
	jne	SHORT $LN113@check_size
	mov	rax, QWORD PTR [r15+80]
	test	rax, rax
	je	SHORT $LN112@check_size
	cmp	DWORD PTR [rax+40], r12d
	je	SHORT $LN113@check_size
$LN112@check_size:

; 2455 :             EmitErr( INSTRUCTION_OPERAND_MUST_HAVE_SIZE );

	mov	ecx, 182				; 000000b6H
	call	EmitErr

; 2456 :             rc = ERROR;

	mov	r12d, -1

; 2457 :             break;

	jmp	$LN6@check_size
$LN113@check_size:

; 2458 :         }
; 2459 :         //if ( CodeInfo->opnd[OPND1].type == OP_M && Parse_Pass == PASS_2 )
; 2460 :         //    EmitWarn( 2, SIZE_NOT_SPECIFIED_ASSUMING, "BYTE" );
; 2461 : 
; 2462 :         /* v2.0: if second argument is a forward reference,
; 2463 :          * change type to "immediate 1"
; 2464 :          */
; 2465 :         if ( opndx[OPND2].kind == EXPR_ADDR &&
; 2466 :             Parse_Pass == PASS_1 &&
; 2467 :             opndx[OPND2].indirect == FALSE &&
; 2468 :             opndx[OPND2].sym &&
; 2469 :             opndx[OPND2].sym->state == SYM_UNDEFINED ) {

	cmp	DWORD PTR [r15+164], 1
	jne	SHORT $LN111@check_size
	cmp	DWORD PTR Parse_Pass, r12d
	jne	SHORT $LN111@check_size
	test	BYTE PTR [r15+176], 1
	jne	SHORT $LN111@check_size
	mov	rax, QWORD PTR [r15+184]
	test	rax, rax
	je	SHORT $LN111@check_size
	cmp	DWORD PTR [rax+40], r12d
	jne	SHORT $LN111@check_size

; 2470 :             CodeInfo->opnd[OPND2].type = OP_I8;

	mov	eax, 131072				; 00020000H

; 2471 :             CodeInfo->opnd[OPND2].data32l = 1;

	mov	DWORD PTR [rbx+64], 1
	mov	DWORD PTR [rbx+56], eax
$LN111@check_size:

; 2472 :         }
; 2473 :         /* v2.06: added (because if first operand is memory, wide bit
; 2474 :          * isn't set!)
; 2475 :          */
; 2476 :         if ( OperandSize( op1, CodeInfo ) > 1 )

	mov	rdx, rbx
	mov	ecx, ebp
	call	OperandSize
	cmp	eax, 1
	jle	SHORT $LN110@check_size

; 2477 :             CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], 1
$LN110@check_size:

; 2478 :         /* v2.06: makes the OP_CL_ONLY case in codegen.c obsolete */
; 2479 :         if ( op2 == OP_CL ) {

	cmp	edi, 1025				; 00000401H
	jne	$LN6@check_size

; 2480 :             /* CL is encoded in bit 345 of rm_byte, but we don't need it
; 2481 :              * so clear it here */
; 2482 :             CodeInfo->rm_byte &= NOT_BIT_345;

	and	BYTE PTR [rbx+104], 199			; 000000c7H

; 2483 :         }
; 2484 :         break;

	jmp	$LN6@check_size
$LN108@check_size:

; 2485 :     case T_LDS:
; 2486 :     case T_LES:
; 2487 :     case T_LFS:
; 2488 :     case T_LGS:
; 2489 :     case T_LSS:
; 2490 :         op1_size = OperandSize( op1, CodeInfo ) + 2; /* add 2 for the impl. segment register */
; 2491 :         op2_size = OperandSize( op2, CodeInfo );

	mov	rdx, rbx
	mov	ecx, edi
	call	OperandSize

; 2492 :         if ( op2_size != 0 && op1_size != op2_size ) {

	test	eax, eax
	mov	r9d, eax
	je	$LN6@check_size
	mov	rdx, rbx
	mov	ecx, ebp
	call	OperandSize
	add	eax, 2
	cmp	eax, r9d
	je	$LN6@check_size
$LN153@check_size:

; 2493 :             return( EmitError( INVALID_OPERAND_SIZE ) );

	mov	ecx, 71					; 00000047H
	call	EmitError
	jmp	$LN136@check_size
$LN105@check_size:

; 2494 :         }
; 2495 :         break;
; 2496 :     case T_ENTER:
; 2497 : #if 0 /* v2.11: operand sizes are checked in codegen */
; 2498 :         /* ENTER has to be OP_I16, OP_I8_U */
; 2499 :         if( op1 == OP_I32 ) {
; 2500 :             /* parse_phase_1 will treat 16-bit data as OP_I32 if CPU is 386 */
; 2501 :             if( CodeInfo->opnd[OPND1].data32l > (int_32)USHRT_MAX ) {
; 2502 :                 /* if op1 is really 32-bit data, then error */
; 2503 :                 EmitError( INVALID_OPERAND_SIZE );
; 2504 :                 rc = ERROR;
; 2505 :             }
; 2506 :         }
; 2507 :         /* type cast op1 to OP_I16 */
; 2508 :         CodeInfo->opnd[OPND1].type = OP_I16;
; 2509 :         /* op2 have to be 8-bit data */
; 2510 :         if( op2 >= OP_I16 ) {
; 2511 :             if( CodeInfo->opnd[OPND2].data32l > UCHAR_MAX ) {
; 2512 :                 EmitError( INVALID_OPERAND_SIZE );
; 2513 :                 rc = ERROR;
; 2514 :             }
; 2515 :             CodeInfo->opnd[OPND2].type = OP_I8;
; 2516 :         }
; 2517 : #endif
; 2518 :         break;
; 2519 :     case T_MOVSX:
; 2520 :     case T_MOVZX:
; 2521 :         CodeInfo->iswide = 0;

	and	BYTE PTR [rbx+142], 254			; 000000feH

; 2522 :         op1_size = OperandSize( op1, CodeInfo );

	mov	rdx, rbx
	mov	ecx, ebp
	call	OperandSize

; 2523 :         op2_size = OperandSize( op2, CodeInfo );

	mov	rdx, rbx
	mov	ecx, edi
	mov	esi, eax
	call	OperandSize

; 2524 :         DebugMsg1(("check_size, MOVZX/MOVSX: op2_size=%u, opndx.memtype=%Xh, opndx.sym=%X\n", op2_size, opndx[OPND2].mem_type, opndx[OPND2].sym ));
; 2525 :         if ( op2_size == 0 && Parse_Pass == PASS_2 )

	test	eax, eax
	mov	edi, eax
	jne	SHORT $LN102@check_size
	cmp	DWORD PTR Parse_Pass, 1
	jne	SHORT $LN102@check_size

; 2526 :             if ( op1_size == 2 ) {

	cmp	esi, 2
	jne	SHORT $LN103@check_size

; 2527 :                 EmitWarn( 2, SIZE_NOT_SPECIFIED_ASSUMING, "BYTE" );

	lea	r8, OFFSET FLAT:$SG6976
	lea	edx, QWORD PTR [rax+73]
	mov	ecx, esi
	call	EmitWarn

; 2528 :             } else

	jmp	SHORT $LN93@check_size
$LN103@check_size:

; 2529 :                 EmitErr( INSTRUCTION_OPERAND_MUST_HAVE_SIZE );

	mov	ecx, 182				; 000000b6H
	call	EmitErr
$LN102@check_size:

; 2530 :         switch( op1_size ) {

	cmp	esi, 2
	je	SHORT $LN94@check_size
	cmp	esi, 4
	je	SHORT $LN99@check_size
	cmp	esi, 8
	je	SHORT $LN99@check_size

; 2553 :             break;
; 2554 :         default:
; 2555 :             /* op1 must be r16/r32/r64 */
; 2556 :             EmitError( OP1_TOO_SMALL );

	mov	ecx, 60					; 0000003cH
	call	EmitError

; 2557 :             rc = ERROR;

	mov	r12d, -1
	jmp	$LN6@check_size
$LN99@check_size:

; 2531 : #if AMD64_SUPPORT
; 2532 :         case 8:
; 2533 :             //if ( CodeInfo->Ofssize == USE64 )
; 2534 :             //    break;
; 2535 : #endif
; 2536 :         case 4:
; 2537 :             if (op2_size < 2)

	cmp	edi, 2
	jl	SHORT $LN95@check_size

; 2538 :                 ;
; 2539 :             else if (op2_size == 2)

	cmp	edi, 2
	jne	SHORT $LN96@check_size

; 2540 :                 CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], 1

; 2541 :             else {

	jmp	SHORT $LN95@check_size
$LN96@check_size:

; 2542 :                 EmitError( OP2_TOO_BIG );

	mov	ecx, 59					; 0000003bH
	call	EmitError

; 2543 :                 rc = ERROR;

	mov	r12d, -1
$LN95@check_size:

; 2544 :             }
; 2545 :             CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? FALSE : TRUE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], 0
	sete	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al

; 2546 :             break;

	jmp	$LN6@check_size
$LN94@check_size:

; 2547 :         case 2:
; 2548 :             if( op2_size >= 2 ) {

	cmp	edi, 2
	jl	SHORT $LN93@check_size

; 2549 :                 EmitError( OP2_TOO_BIG );

	mov	ecx, 59					; 0000003bH
	call	EmitError

; 2550 :                 rc = ERROR;

	mov	r12d, -1
$LN93@check_size:

; 2551 :             }
; 2552 :             CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? TRUE : FALSE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], 0
	setne	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al

; 2558 :         }
; 2559 :         break;

	jmp	$LN6@check_size
$LN90@check_size:

; 2560 : #if AMD64_SUPPORT
; 2561 :     case T_MOVSXD:
; 2562 :         break;
; 2563 : #endif
; 2564 :     case T_ARPL: /* v2.06: new, avoids the OP_R16 hack in codegen.c */
; 2565 :         CodeInfo->prefix.opsiz = 0;

	and	BYTE PTR [rbx+9], 253			; 000000fdH

; 2566 :         goto def_check;

	jmp	$def_check$6937
$LN89@check_size:

; 2567 :         break;
; 2568 : #if AMD64_SUPPORT
; 2569 :     case T_LAR: /* v2.04: added */
; 2570 :     case T_LSL: /* 19-sep-93 */
; 2571 : #if 1 /* v2.04: changed */
; 2572 :         if ( ModuleInfo.Ofssize != USE64 || ( ( op2 & OP_M ) == 0 ) )

	cmp	BYTE PTR ModuleInfo+404, 2
	jne	$def_check$6937
	test	edi, -1887436800			; ffffffff8f800000H
	je	$def_check$6937

; 2573 :             goto def_check;
; 2574 :         /* in 64-bit, if second argument is memory operand,
; 2575 :          * ensure it has size WORD ( or 0 if a forward ref )
; 2576 :          */
; 2577 :         op2_size = OperandSize( op2, CodeInfo );

	mov	rdx, rbx
	mov	ecx, edi
	call	OperandSize

; 2578 :         if ( op2_size != 2 && op2_size != 0 ) {

	cmp	eax, 2
	je	SHORT $LN86@check_size
	test	eax, eax

; 2579 :             return( EmitError( INVALID_OPERAND_SIZE ) );

	jne	$LN153@check_size
$LN86@check_size:

; 2580 :         }
; 2581 :         /* the opsize prefix depends on the FIRST operand only! */
; 2582 :         op1_size = OperandSize( op1, CodeInfo );

	mov	rdx, rbx
	mov	ecx, ebp
	call	OperandSize

; 2583 :         if ( op1_size != 2 )

	cmp	eax, 2
	je	$LN6@check_size

; 2584 :             CodeInfo->prefix.opsiz = FALSE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH

; 2585 : #else
; 2586 :         op1_size = OperandSize( op1, CodeInfo );
; 2587 :         switch( op1_size ) {
; 2588 :         case 2:
; 2589 :             if( CodeInfo->Ofssize )
; 2590 :                 CodeInfo->prefix.opsiz = TRUE;
; 2591 :             break;
; 2592 :         case 4:
; 2593 :             if( CodeInfo->Ofssize )
; 2594 :                 CodeInfo->prefix.opsiz = FALSE;
; 2595 :             break;
; 2596 :         default:
; 2597 :             return( EmitError( INVALID_OPERAND_SIZE ) );
; 2598 :         }
; 2599 :         op2_size = OperandSize( op2, CodeInfo );
; 2600 :         switch( op2_size ) {
; 2601 :         case 2:
; 2602 :         case 4:
; 2603 :             break;
; 2604 :         default:
; 2605 :             EmitError( INVALID_OPERAND_SIZE );
; 2606 :             rc = ERROR;
; 2607 :             break;
; 2608 :         }
; 2609 : #endif
; 2610 :         break;

	jmp	$LN6@check_size
$LN84@check_size:

; 2611 : #endif
; 2612 :     case T_IMUL: /* v2.06: check for 3rd operand must be done here */
; 2613 :         if ( CodeInfo->opnd[OPND3].type != OP_NONE ) {

	mov	r9d, DWORD PTR [rbx+80]
	test	r9d, r9d
	je	$def_check$6937

; 2614 :             int op3_size;
; 2615 :             op1_size = OperandSize( op1, CodeInfo );

	mov	rdx, rbx
	mov	ecx, ebp
	call	OperandSize

; 2616 :             op3_size = OperandSize( CodeInfo->opnd[OPND3].type, CodeInfo );

	mov	rdx, rbx
	mov	ecx, r9d
	mov	r10d, eax
	call	OperandSize

; 2617 :             /* the only case which must be checked here
; 2618 :              * is a WORD register as op1 and a DWORD immediate as op3 */
; 2619 :             if ( op1_size == 2 && op3_size > 2 ) {

	cmp	r10d, 2
	jne	SHORT $LN82@check_size
	cmp	eax, r10d
	jle	SHORT $LN82@check_size

; 2620 :                 EmitErr( OPERANDS_MUST_BE_THE_SAME_SIZE, op1_size, op3_size );

	lea	ecx, QWORD PTR [r10+46]
	mov	r8d, eax
	mov	edx, r10d
	call	EmitErr

; 2621 :                 rc = ERROR;

	mov	r12d, -1

; 2622 :                 break;

	jmp	$LN6@check_size
$LN82@check_size:

; 2623 :             }
; 2624 :             if ( CodeInfo->opnd[OPND3].type & ( OP_I16 | OP_I32 ) )

	test	r9d, 786432				; 000c0000H
	je	$def_check$6937

; 2625 :                 CodeInfo->opnd[OPND3].type = ( op1_size == 2 ? OP_I16 : OP_I32 );

	mov	eax, 524288				; 00080000H
	cmp	r10d, 2
	cmove	eax, r14d
	mov	DWORD PTR [rbx+80], eax

; 2626 :         }
; 2627 :         goto def_check;

	jmp	$def_check$6937
$LN66@check_size:

; 2697 :     case T_MOV:
; 2698 :         if( op1 & OP_SR ) { /* segment register as op1? */

	test	ebp, 24576				; 00006000H
	je	SHORT $LN65@check_size

; 2699 :             op2_size = OperandSize( op2, CodeInfo );

	mov	rdx, rbx
	mov	ecx, edi

; 2700 :             if( ( op2_size == 2 ) || ( op2_size == 4 )
; 2701 : #if AMD64_SUPPORT
; 2702 :                || ( op2_size == 8 && ModuleInfo.Ofssize == USE64 )
; 2703 : #endif
; 2704 :               ) {
; 2705 :                 return( NOT_ERROR );

	jmp	SHORT $LN152@check_size
$LN65@check_size:

; 2706 :             }
; 2707 :         } else if( op2 & OP_SR ) {

	test	edi, 24576				; 00006000H
	je	SHORT $LN61@check_size

; 2708 :             op1_size = OperandSize( op1, CodeInfo );

	mov	rdx, rbx
	mov	ecx, ebp
$LN152@check_size:
	call	OperandSize

; 2709 :             if( ( op1_size == 2 ) || ( op1_size == 4 )
; 2710 : #if AMD64_SUPPORT
; 2711 :                || ( op1_size == 8 && ModuleInfo.Ofssize == USE64 )
; 2712 : #endif
; 2713 :               ) {

	cmp	eax, 2
	je	SHORT $LN59@check_size
	cmp	eax, 4
	je	SHORT $LN59@check_size
	cmp	eax, 8
	jne	$def_check$6937
	cmp	BYTE PTR ModuleInfo+404, 2

; 2715 :             }

	jne	$def_check$6937
$LN59@check_size:

; 2714 :                 return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN136@check_size
$LN61@check_size:

; 2716 :         } else if( ( op1 & OP_M ) && ( op2 & OP_A ) ) { /* 1. operand memory reference, 2. AL|AX|EAX|RAX? */

	test	ebp, -1887436800			; ffffffff8f800000H
	je	SHORT $LN57@check_size
	bt	edi, 9
	jae	SHORT $LN57@check_size

; 2717 : 
; 2718 :             if ( CodeInfo->isdirect == FALSE ) {

	test	BYTE PTR [rbx+142], 2
	jne	SHORT $LN56@check_size

; 2719 :                 /* address mode is indirect.
; 2720 :                  * don't use the short format (opcodes A0-A3) - it exists for direct
; 2721 :                  * addressing only. Reset OP_A flag!
; 2722 :                  */
; 2723 :                 CodeInfo->opnd[OPND2].type &= ~OP_A;

	mov	eax, edi
	btr	eax, 9
	mov	DWORD PTR [rbx+56], eax
	jmp	$def_check$6937
$LN56@check_size:

; 2724 :                 DebugMsg1(("check_size: OP_A flag reset, new op2=%X\n", CodeInfo->opnd[OPND2].type ));
; 2725 : #if AMD64_SUPPORT
; 2726 :             } else if ( CodeInfo->Ofssize == USE64 && ( CodeInfo->opnd[OPND1].data64 < 0x80000000 || CodeInfo->opnd[OPND1].data64 >= 0xffffffff80000000 ) ) {

	cmp	BYTE PTR [rbx+106], 2
	jne	$def_check$6937
	mov	rcx, QWORD PTR [rbx+40]
	mov	eax, -2147483648			; 80000000H
	cmp	rcx, rax
	jb	SHORT $LN53@check_size
	cmp	rcx, -2147483648			; ffffffff80000000H
	jb	$def_check$6937
$LN53@check_size:

; 2727 :                 /* for 64bit, opcodes A0-A3 ( direct memory addressing with AL/AX/EAX/RAX )
; 2728 :                  * are followed by a full 64-bit moffs. This is only used if the offset won't fit
; 2729 :                  * in a 32-bit signed value.
; 2730 :                  */
; 2731 :                 CodeInfo->opnd[OPND2].type &= ~OP_A;

	mov	eax, edi
	btr	eax, 9
	mov	DWORD PTR [rbx+56], eax

; 2732 :                 DebugMsg1(("check_size: OP_A flag reset, new op2=%X\n", CodeInfo->opnd[OPND2].type ));
; 2733 : #endif
; 2734 :             }

	jmp	$def_check$6937
$LN57@check_size:

; 2735 : 
; 2736 :         } else if( ( op1 & OP_A ) && ( op2 & OP_M ) ) { /* 2. operand memory reference, 1. AL|AX|EAX|RAX? */

	bt	ebp, 9
	jae	$def_check$6937
	test	edi, -1887436800			; ffffffff8f800000H
	je	$def_check$6937

; 2737 : 
; 2738 :             if ( CodeInfo->isdirect == FALSE ) {

	test	BYTE PTR [rbx+142], 2
	jne	SHORT $LN50@check_size

; 2739 :                 CodeInfo->opnd[OPND1].type &= ~OP_A;

	mov	eax, ebp
	btr	eax, 9
	mov	DWORD PTR [rbx+32], eax
	jmp	$def_check$6937
$LN50@check_size:

; 2740 :                 DebugMsg1(("check_size: OP_A flag reset, new op1=%X\n", CodeInfo->opnd[OPND1].type ));
; 2741 : #if AMD64_SUPPORT
; 2742 :             } else if ( CodeInfo->Ofssize == USE64 && ( CodeInfo->opnd[OPND2].data64 < 0x80000000 || CodeInfo->opnd[OPND2].data64 >= 0xffffffff80000000 ) ) {

	cmp	BYTE PTR [rbx+106], 2
	jne	$def_check$6937
	mov	rcx, QWORD PTR [rbx+64]
	mov	eax, -2147483648			; 80000000H
	cmp	rcx, rax
	jb	SHORT $LN47@check_size
	cmp	rcx, -2147483648			; ffffffff80000000H
	jb	$def_check$6937
$LN47@check_size:

; 2743 :                 CodeInfo->opnd[OPND1].type &= ~OP_A;

	mov	eax, ebp
	btr	eax, 9
	mov	DWORD PTR [rbx+32], eax
	jmp	$def_check$6937
$LN140@check_size:

; 2388 :     }
; 2389 : 
; 2390 :     switch( CodeInfo->token ) {

	cmp	ecx, 1219				; 000004c3H
	jg	SHORT $LN141@check_size
	cmp	ecx, 1219				; 000004c3H
	je	$LN6@check_size
	cmp	ecx, 1032				; 00000408H
	jl	$def_check$6937
	cmp	ecx, 1033				; 00000409H
	jle	$LN6@check_size
	cmp	ecx, 1046				; 00000416H
	jne	$def_check$6937

; 2685 : #endif
; 2686 :     case T_MOVD:
; 2687 : #if 0
; 2688 :         op1_size = OperandSize( op1, CodeInfo );
; 2689 :         op2_size = OperandSize( op2, CodeInfo );
; 2690 :         if( ( op1_size != 0 ) && ( op1_size != 4 )
; 2691 :             || ( op2_size != 0 ) && ( op2_size != 4 ) ) {
; 2692 :             EmitErr( OPERANDS_MUST_BE_THE_SAME_SIZE, op1_size, op2_size );
; 2693 :             rc = ERROR;
; 2694 :         }
; 2695 : #endif
; 2696 :         break;

	jmp	$LN6@check_size
$LN141@check_size:

; 2388 :     }
; 2389 : 
; 2390 :     switch( CodeInfo->token ) {

	cmp	ecx, 1352				; 00000548H
	jg	SHORT $LN142@check_size
	cmp	ecx, 1352				; 00000548H
	je	$LN78@check_size
	sub	ecx, 1275				; 000004fbH
	cmp	ecx, 74					; 0000004aH
	ja	$def_check$6937
	lea	rdx, OFFSET FLAT:__ImageBase
	movsxd	rax, ecx
	movzx	eax, BYTE PTR $LN147@check_size[rdx+rax]
	mov	ecx, DWORD PTR $LN148@check_size[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN72@check_size:

; 2671 : #endif
; 2672 : #if SSE4SUPP
; 2673 :     case T_CRC32:
; 2674 :         /* v2.02: for CRC32, the second operand determines whether an
; 2675 :          * OPSIZE prefix byte is to be written.
; 2676 :          */
; 2677 :         op2_size = OperandSize( op2, CodeInfo );

	mov	rdx, rbx
	mov	ecx, edi
	call	OperandSize

; 2678 :         if ( op2_size < 2)

	cmp	eax, 2

; 2679 :             CodeInfo->prefix.opsiz = FALSE;

	jl	$LN151@check_size

; 2680 :         else if ( op2_size == 2 )

	cmp	eax, 2
	jne	SHORT $LN69@check_size

; 2681 :             CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? TRUE : FALSE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], r12b
	setne	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al

; 2682 :         else

	jmp	$LN6@check_size
$LN69@check_size:

; 2683 :             CodeInfo->prefix.opsiz = CodeInfo->Ofssize ? FALSE : TRUE;

	and	BYTE PTR [rbx+9], 253			; 000000fdH
	cmp	BYTE PTR [rbx+106], r12b
	sete	al
	and	al, 1
	add	al, al
	or	BYTE PTR [rbx+9], al

; 2684 :         break;

	jmp	$LN6@check_size
$LN142@check_size:

; 2388 :     }
; 2389 : 
; 2390 :     switch( CodeInfo->token ) {

	cmp	ecx, 1678				; 0000068eH
	jg	SHORT $LN143@check_size
	cmp	ecx, 1678				; 0000068eH
	je	$LN6@check_size
	sub	ecx, 1363				; 00000553H
	je	SHORT $LN78@check_size
	dec	ecx
	je	SHORT $LN76@check_size
	cmp	ecx, 280				; 00000118H
	jne	SHORT $def_check$6937

; 2652 : #if AVXSUPP
; 2653 :     case T_VCVTSD2USI:
; 2654 :           CodeInfo->evex_flag = TRUE;

	mov	BYTE PTR [rbx+136], 1

; 2655 :           break;

	jmp	$LN6@check_size
$LN76@check_size:

; 2661 :         }
; 2662 :         break;
; 2663 :     case T_VMOVDDUP:
; 2664 :         if ( !( op1 & OP_YMM ) )

	test	bpl, bpl
	jns	$LN6@check_size
$LN75@check_size:

; 2665 :             break;
; 2666 :         /* fall through */
; 2667 :     case T_VPERM2F128: /* has just one memory variant, and VX_L isnt set */
; 2668 :         if ( op2 == OP_M )

	cmp	edi, -1887436800			; ffffffff8f800000H
	jne	$LN6@check_size

; 2669 :             CodeInfo->opnd[OPND2].type |= OP_M256;

	bts	edi, 28
	mov	DWORD PTR [rbx+56], edi

; 2670 :         break;

	jmp	$LN6@check_size
$LN78@check_size:

; 2656 :     case T_VCVTPD2DQ:
; 2657 :     case T_VCVTTPD2DQ:
; 2658 :     case T_VCVTPD2PS:
; 2659 :         if ( op2 == OP_M && opndx[OPND2].indirect ) {

	cmp	edi, -1887436800			; ffffffff8f800000H
	jne	$LN6@check_size
	test	BYTE PTR [r15+176], 1
	je	$LN6@check_size

; 2660 :             return( EmitError( INSTRUCTION_OPERAND_MUST_HAVE_SIZE ) );

	mov	ecx, 182				; 000000b6H
	call	EmitError
	jmp	$LN136@check_size
$LN143@check_size:

; 2388 :     }
; 2389 : 
; 2390 :     switch( CodeInfo->token ) {

	cmp	ecx, 1952				; 000007a0H
	jl	SHORT $def_check$6937
	cmp	ecx, 1953				; 000007a1H
	jle	$LN6@check_size
	lea	eax, DWORD PTR [r11-1957]
	cmp	eax, 1

; 2628 :         break;
; 2629 :     case T_CVTSD2SI:
; 2630 :     case T_CVTTSD2SI:
; 2631 :     case T_CVTSS2SI:
; 2632 :     case T_CVTTSS2SI:
; 2633 :     //case T_MOVNTI: /* v2.05: removed */
; 2634 : #if AVXSUPP
; 2635 :     case T_VBROADCASTSD:
; 2636 :     case T_VBROADCASTF128:
; 2637 :     case T_VEXTRACTF128:
; 2638 :     case T_VINSERTF128:
; 2639 :     case T_VCVTSD2SI:
; 2640 :     case T_VCVTTSD2SI:
; 2641 :     case T_VCVTSS2SI:
; 2642 :     case T_VCVTTSS2SI:
; 2643 : #endif
; 2644 : #if VMXSUPP /* v2.09: added */
; 2645 :     case T_INVEPT:
; 2646 :     case T_INVVPID:
; 2647 : #endif
; 2648 : #if SVMSUPP /* v2.09: added */
; 2649 :     case T_INVLPGA:
; 2650 : #endif
; 2651 :         break;

	jbe	$LN6@check_size
$def_check$6937:

; 2744 :                 DebugMsg1(("check_size: OP_A flag reset, new op2=%X\n", CodeInfo->opnd[OPND1].type ));
; 2745 : #endif
; 2746 :             }
; 2747 :         }
; 2748 :         /* fall through */
; 2749 :     default:
; 2750 : //#if AMD64_SUPPORT
; 2751 :     def_check:
; 2752 : //#endif
; 2753 :         /* make sure the 2 opnds are of the same type */
; 2754 :         op1_size = OperandSize( op1, CodeInfo );

	mov	rdx, rbx
	mov	ecx, ebp
	call	OperandSize

; 2755 :         op2_size = OperandSize( op2, CodeInfo );

	mov	rdx, rbx
	mov	ecx, edi
	mov	r13d, eax
	call	OperandSize

; 2756 :         DebugMsg1(("check_size default: op1_size1=%u, op2_size=%u\n", op1_size, op2_size));
; 2757 :         if( op1_size > op2_size ) {

	cmp	r13d, eax
	mov	esi, eax
	jle	SHORT $LN44@check_size

; 2758 :             if( ( op2 >= OP_I8 ) && ( op2 <= OP_I32 ) ) {     /* immediate */

	lea	ecx, DWORD PTR [rdi-131072]
	cmp	ecx, 393216				; 00060000H
	cmovbe	esi, r13d
$LN44@check_size:

; 2759 :                 op2_size = op1_size;    /* promote to larger size */
; 2760 :             }
; 2761 :         }
; 2762 : #if 1
; 2763 :         /* v2.04: check in idata_nofixup was signed,
; 2764 :          * so now add -256 - -129 and 128-255 to acceptable byte range.
; 2765 :          * Since Masm v8, the check is more restrictive, -255 - -129
; 2766 :          * is no longer accepted.
; 2767 :          */
; 2768 :         if( ( op1_size == 1 ) && ( op2 == OP_I16 ) &&
; 2769 :             ( CodeInfo->opnd[OPND2].data32l <= UCHAR_MAX ) &&
; 2770 :             //CodeInfo->opnd[OPND2].data32l >= -128 ) ) {
; 2771 :             ( CodeInfo->opnd[OPND2].data32l >= -255 ) ) {

	cmp	r13d, 1
	jne	SHORT $LN43@check_size
	cmp	edi, r14d
	jne	SHORT $LN43@check_size
	mov	eax, DWORD PTR [rbx+64]
	cmp	eax, 255				; 000000ffH
	jg	SHORT $LN43@check_size
	cmp	eax, -255				; ffffffffffffff01H

; 2772 :             return( rc ); /* OK cause no sign extension */

	jge	$LN59@check_size
$LN43@check_size:

; 2773 :         }
; 2774 : #endif
; 2775 : #if 0
; 2776 :         /* v2.03: this "if" made HJWasm accept any 32-bit constant
; 2777 :          *        for 16-bit destinations, which is Masm compatibel,
; 2778 :          *      "mov ax, 12345h"
; 2779 :          * the test is a bit too liberal here, IMO, because
; 2780 :          * it makes HJWasm accept "mov ax, near32 ptr var",
; 2781 :          * which is rejected by Masm.
; 2782 :          */
; 2783 :         if( ( op1_size == 2 ) && ( op2 == OP_I32 )
; 2784 :             && ( CodeInfo->data[OPND2] <= USHRT_MAX ) ) {
; 2785 :             return( rc ); /* OK cause no sign extension */
; 2786 :         }
; 2787 : #endif
; 2788 :         if( op1_size != op2_size ) {

	cmp	r13d, esi
	je	$LN6@check_size

; 2789 :             /* if one or more are !defined, set them appropriately */
; 2790 : #if AVXSUPP
; 2791 :             if( ( op1 | op2 ) & ( OP_MMX | OP_XMM | OP_YMM | OP_K | OP_ZMM ) ) {

	mov	r14d, edi
	or	r14d, ebp
	test	r14d, 496				; 000001f0H
	jne	SHORT $LN36@check_size

; 2792 : #else
; 2793 :             if( ( op1 | op2 ) & ( OP_MMX | OP_XMM ) ) {
; 2794 : #endif
; 2795 :             }
; 2796 :             else if( ( op1_size != 0 ) && ( op2_size != 0 ) ) {

	test	r13d, r13d
	je	SHORT $LN145@check_size
	test	esi, esi
	je	SHORT $LN36@check_size

; 2797 :               if ((CodeInfo->token == T_VCVTSD2USI)||(CodeInfo->token == T_VCVTSS2USI)||
; 2798 :                 (CodeInfo->token == T_VCVTTSD2USI)||(CodeInfo->token == T_VCVTTSS2USI))

	cmp	r11d, 1644				; 0000066cH
	je	SHORT $LN37@check_size
	cmp	r11d, 1645				; 0000066dH
	je	SHORT $LN37@check_size
	cmp	r11d, 1664				; 00000680H
	je	SHORT $LN37@check_size
	cmp	r11d, 1665				; 00000681H
	je	SHORT $LN37@check_size

; 2800 :               else{
; 2801 :                 EmitErr(OPERANDS_MUST_BE_THE_SAME_SIZE, op1_size, op2_size);

	mov	r8d, esi
	mov	edx, r13d
	mov	ecx, 48					; 00000030H
	call	EmitErr

; 2802 :                 rc = ERROR;

	mov	r12d, -1
	jmp	SHORT $LN36@check_size
$LN37@check_size:

; 2799 :                 CodeInfo->evex_flag = TRUE;

	mov	BYTE PTR [rbx+136], 1
$LN36@check_size:

; 2803 :               }
; 2804 :             }
; 2805 :             /* size == 0 is assumed to mean "undefined", but there
; 2806 :              * is also the case of an "empty" struct or union. The
; 2807 :              * latter case isn't handled correctly.
; 2808 :              */
; 2809 :             if( op1_size == 0 ) {

	test	r13d, r13d
	jne	$LN6@check_size
$LN145@check_size:

; 2810 :                 if( ( op1 & OP_M_ANY ) && ( op2 & OP_I ) ) {

	mov	eax, ebp
	and	eax, -8388608				; ffffffffff800000H
	je	$LN34@check_size
	test	edi, 917504				; 000e0000H
	je	$LN34@check_size

; 2811 :                     char *p = "WORD";
; 2812 :                     if( (uint_32)CodeInfo->opnd[OPND2].data32l > USHRT_MAX || op2_size == 4 ) {

	mov	eax, DWORD PTR [rbx+64]
	lea	r8, OFFSET FLAT:$SG7050
	cmp	eax, 65535				; 0000ffffH
	ja	SHORT $LN32@check_size
	cmp	esi, 4
	je	SHORT $LN32@check_size

; 2826 :                         }
; 2827 :                     } else if( (uint_32)CodeInfo->opnd[OPND2].data32l > UCHAR_MAX || op2_size == 2 ) {

	cmp	eax, 255				; 000000ffH
	ja	SHORT $LN26@check_size
	cmp	esi, 2
	je	SHORT $LN26@check_size

; 2832 :                          CodeInfo->mem_type = MT_BYTE;
; 2833 :                          CodeInfo->opnd[OPND2].type = OP_I8;

	mov	eax, 131072				; 00020000H
	mov	DWORD PTR [rbx+28], 0

; 2834 : 						 CodeInfo->opnd[OPND1].type = OP_M08;

	mov	DWORD PTR [rbx+32], 8388608		; 00800000H
	mov	DWORD PTR [rbx+56], eax

; 2835 :                          p = "BYTE";

	lea	r8, OFFSET FLAT:$SG7063
	jmp	SHORT $LN29@check_size
$LN26@check_size:

; 2828 :                          CodeInfo->mem_type = MT_WORD;
; 2829 :                          CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], 1

; 2830 :                          CodeInfo->opnd[OPND2].type = OP_I16;

	mov	ecx, 262144				; 00040000H
	mov	DWORD PTR [rbx+28], 1
	mov	DWORD PTR [rbx+56], ecx

; 2831 :                     } else {

	jmp	SHORT $LN29@check_size
$LN32@check_size:

; 2813 :                         CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], 1

; 2814 :                         DebugMsg1(("check_size: op1=%X op1_size=0, op2=%X, op2_size=%u CodeInfo->data[2]=%X\n", op1, op2, op2_size, CodeInfo->opnd[OPND2].data32l ));
; 2815 : #if 1 /* added v1.95: in 16bit code, 'mov [di],8000h' should warn: assuming WORD */
; 2816 :                         if ( ModuleInfo.Ofssize == USE16 && op2_size > 2 && InWordRange( CodeInfo->opnd[OPND2].data32l ) )

	movzx	ecx, BYTE PTR ModuleInfo+404
	test	cl, cl
	jne	SHORT $LN31@check_size
	cmp	esi, 2
	jle	SHORT $LN144@check_size
	cmp	eax, 65535				; 0000ffffH
	jg	SHORT $LN31@check_size
	cmp	eax, -65535				; ffffffffffff0001H
	jge	SHORT $LN144@check_size
$LN31@check_size:

; 2817 :                             op2_size = 2;
; 2818 : #endif
; 2819 :                         if (op2_size <= 2 && CodeInfo->opnd[OPND2].data32l > SHRT_MIN && ModuleInfo.Ofssize == USE16 ) {

	cmp	esi, 2
	jg	SHORT $LN30@check_size
$LN144@check_size:
	cmp	eax, -32768				; ffffffffffff8000H
	jle	SHORT $LN30@check_size
	test	cl, cl
	jne	SHORT $LN30@check_size

; 2820 :                             CodeInfo->mem_type = MT_WORD;
; 2821 :                             CodeInfo->opnd[OPND2].type = OP_I16;

	mov	ecx, 262144				; 00040000H
	mov	DWORD PTR [rbx+28], 1
	mov	DWORD PTR [rbx+56], ecx

; 2822 :                         } else {

	jmp	SHORT $LN29@check_size
$LN30@check_size:

; 2823 :                             CodeInfo->mem_type = MT_DWORD;

	mov	DWORD PTR [rbx+28], 3

; 2824 :                             CodeInfo->opnd[OPND2].type = OP_I32;

	mov	DWORD PTR [rbx+56], 524288		; 00080000H

; 2825 :                             p = "DWORD";

	lea	r8, OFFSET FLAT:$SG7057
$LN29@check_size:

; 2836 :                     }
; 2837 :                     if( opndx[OPND2].explicit == FALSE ) {

	test	BYTE PTR [r15+176], 2
	jne	$LN6@check_size

; 2838 :                         /* v2.06: emit warning at pass one if mem op isn't a forward ref */
; 2839 :                         /* v2.06b: added "undefined" check */
; 2840 :                         if ( ( CodeInfo->opnd[OPND1].InsFixup == NULL && Parse_Pass == PASS_1 && CodeInfo->undef_sym == FALSE ) ||
; 2841 :                             ( CodeInfo->opnd[OPND1].InsFixup && Parse_Pass == PASS_2 ) )

	mov	rcx, QWORD PTR [rbx+48]
	mov	eax, DWORD PTR Parse_Pass
	test	rcx, rcx
	jne	SHORT $LN21@check_size
	test	eax, eax
	jne	SHORT $LN21@check_size
	test	BYTE PTR [rbx+142], 64			; 00000040H
	je	$LN22@check_size
$LN21@check_size:
	test	rcx, rcx
	je	$LN6@check_size
	cmp	eax, 1
	jne	$LN6@check_size

; 2842 :                                 EmitWarn( 1, SIZE_NOT_SPECIFIED_ASSUMING, p );  //ovde je greska
; 2843 :                     }

	jmp	$LN22@check_size
$LN34@check_size:

; 2844 :                 } else if( ( op1 & OP_M_ANY ) && ( op2 & ( OP_R | OP_SR ) ) ) {

	test	eax, eax
	je	SHORT $LN19@check_size
	test	edi, 24591				; 0000600fH
	jne	$LN6@check_size
$LN19@check_size:

; 2845 :                 } else if( ( op1 & ( OP_MMX | OP_XMM ) ) && ( op2 & OP_I ) ) {

	test	bpl, 48					; 00000030H
	je	SHORT $LN17@check_size
	test	edi, 917504				; 000e0000H
	je	SHORT $LN17@check_size

; 2846 :                     if( (uint_32)CodeInfo->opnd[OPND2].data32l > USHRT_MAX ) {

	mov	ecx, DWORD PTR [rbx+64]
	cmp	ecx, 65535				; 0000ffffH
	jbe	SHORT $LN16@check_size

; 2847 :                          CodeInfo->opnd[OPND2].type = OP_I32;

	mov	DWORD PTR [rbx+56], 524288		; 00080000H
	jmp	$LN6@check_size
$LN16@check_size:

; 2848 :                     } else if( (uint_32)CodeInfo->opnd[OPND2].data32l > UCHAR_MAX ) {

	cmp	ecx, 255				; 000000ffH
	mov	eax, 131072				; 00020000H
	mov	ecx, 262144				; 00040000H
	cmova	eax, ecx
	mov	DWORD PTR [rbx+56], eax

; 2849 :                          CodeInfo->opnd[OPND2].type = OP_I16;
; 2850 :                     } else {
; 2851 :                          CodeInfo->opnd[OPND2].type = OP_I8;
; 2852 :                     }

	jmp	$LN6@check_size
$LN17@check_size:

; 2853 :                 } else if( ( op1 | op2 ) & ( OP_MMX | OP_XMM ) ) {

	test	r14b, 48				; 00000030H
	jne	$LN6@check_size

; 2854 :                 } else {
; 2855 :                     //AsmIntErr( 1 ); /* printf("internal error = %u", 1 ) */
; 2856 :                     switch( op2_size ) {

	dec	esi
	je	SHORT $LN7@check_size
	dec	esi
	je	SHORT $LN5@check_size
	cmp	esi, 2
	jne	$LN6@check_size

; 2872 :                     case 4:
; 2873 :                         CodeInfo->mem_type = MT_DWORD;
; 2874 :                         CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], 1
	mov	DWORD PTR [rbx+28], 3

; 2875 :                         if( ( Parse_Pass == PASS_1 ) && ( op2 & OP_I ) ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN6@check_size
	test	edi, 917504				; 000e0000H
	je	SHORT $LN6@check_size

; 2876 :                             EmitWarn( 1, SIZE_NOT_SPECIFIED_ASSUMING, "DWORD" );

	lea	r8, OFFSET FLAT:$SG7095

; 2877 :                         }
; 2878 :                         break;

	jmp	SHORT $LN22@check_size
$LN5@check_size:

; 2861 :                         }
; 2862 :                         break;
; 2863 :                     case 2:
; 2864 :                         CodeInfo->mem_type = MT_WORD;
; 2865 :                         CodeInfo->iswide = 1;

	or	BYTE PTR [rbx+142], 1
	mov	DWORD PTR [rbx+28], 1

; 2866 :                         if( ( Parse_Pass == PASS_1 ) && ( op2 & OP_I ) ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN4@check_size
	test	edi, 917504				; 000e0000H
	je	SHORT $LN4@check_size

; 2867 :                             EmitWarn( 1, SIZE_NOT_SPECIFIED_ASSUMING, "WORD" );

	mov	edx, 73					; 00000049H
	lea	r8, OFFSET FLAT:$SG7091
	lea	ecx, QWORD PTR [rdx-72]
	call	EmitWarn
$LN4@check_size:

; 2868 :                         }
; 2869 :                         if( CodeInfo->Ofssize )

	cmp	BYTE PTR [rbx+106], 0
	je	SHORT $LN6@check_size

; 2870 :                             CodeInfo->prefix.opsiz = TRUE;

	or	BYTE PTR [rbx+9], 2

; 2871 :                         break;

	jmp	SHORT $LN6@check_size
$LN7@check_size:

; 2857 :                     case 1:
; 2858 :                         CodeInfo->mem_type = MT_BYTE;

	mov	DWORD PTR [rbx+28], 0

; 2859 :                         if( ( Parse_Pass == PASS_1 ) && ( op2 & OP_I ) ) {

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN6@check_size
	test	edi, 917504				; 000e0000H
	je	SHORT $LN6@check_size

; 2860 :                             EmitWarn( 1, SIZE_NOT_SPECIFIED_ASSUMING, "BYTE" );

	lea	r8, OFFSET FLAT:$SG7088
$LN22@check_size:
	mov	edx, 73					; 00000049H
	lea	ecx, QWORD PTR [rdx-72]
	call	EmitWarn
$LN6@check_size:

; 2879 :                     }
; 2880 :                 }
; 2881 :             }
; 2882 :         }
; 2883 :     }
; 2884 :     DebugMsg1(("check_size exit [CodeInfo->mem_type=%Xh]\n", CodeInfo->mem_type));
; 2885 :     return( rc );

	mov	eax, r12d
$LN136@check_size:
	mov	r15, QWORD PTR [rsp+40]
	mov	r14, QWORD PTR [rsp+48]
	mov	r13, QWORD PTR [rsp+56]
	mov	r12, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]

; 2886 : }

	add	rsp, 72					; 00000048H
	ret	0
	npad	3
$LN150@check_size:
	DD	$LN114@check_size
	DD	$LN108@check_size
	DD	$LN90@check_size
	DD	$LN66@check_size
	DD	$LN6@check_size
	DD	$LN84@check_size
	DD	$LN131@check_size
	DD	$LN89@check_size
	DD	$LN105@check_size
	DD	$LN123@check_size
	DD	$def_check$6937
$LN149@check_size:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	1
	DB	1
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	2
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	3
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	4
	DB	10
	DB	5
	DB	6
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	7
	DB	7
	DB	4
	DB	10
	DB	1
	DB	1
	DB	1
	DB	10
	DB	10
	DB	8
	DB	8
	DB	10
	DB	9
$LN148@check_size:
	DD	$LN72@check_size
	DD	$LN6@check_size
	DD	$LN75@check_size
	DD	$LN78@check_size
	DD	$def_check$6937
$LN147@check_size:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	1
	DB	4
	DB	1
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
check_size ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$IsType DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$IsType DD @imagerel(IsType#)
	DD	@imagerel(IsType#+27)
	DD	@imagerel($unwind$IsType#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
IsType	PROC NEAR

; 2890 : {

	sub	rsp, 40					; 00000028H

; 2891 :     struct asym *sym;
; 2892 : 
; 2893 :     sym = SymSearch( name );

	call	SymFind

; 2894 :     if ( sym && (sym->state == SYM_TYPE ) )

	test	rax, rax
	je	SHORT $LN1@IsType
	cmp	DWORD PTR [rax+40], 7

; 2895 :         return( sym );

	je	SHORT $LN2@IsType
$LN1@IsType:

; 2896 :     return( NULL );

	xor	eax, eax
$LN2@IsType:

; 2897 : }

	add	rsp, 40					; 00000028H
	ret	0
IsType	ENDP
_TEXT	ENDS
PUBLIC	ParseLine
EXTRN	codegen:NEAR
EXTRN	vex_flags:BYTE
EXTRN	atofloat:NEAR
EXTRN	EvalOperand:NEAR
EXTRN	Options:BYTE
EXTRN	omf_OutSelect:NEAR
EXTRN	optable_idx:BYTE
EXTRN	InstrTable:BYTE
EXTRN	RetInstr:NEAR
EXTRN	GetCurrOffset:NEAR
EXTRN	LstWriteSrcLine:NEAR
EXTRN	UseSavedState:BYTE
EXTRN	directive_tab:BYTE
EXTRN	StoreState:BYTE
EXTRN	data_dir:NEAR
EXTRN	CurrStruct:QWORD
EXTRN	sprintf:NEAR
EXTRN	malloc:NEAR
EXTRN	AddLineQueueX:NEAR
EXTRN	LstWrite:NEAR
EXTRN	CreateLabel:NEAR
EXTRN	CurrProc:QWORD
EXTRN	write_prologue:NEAR
EXTRN	ProcStatus:DWORD
EXTRN	StoreLine:NEAR
EXTRN	SetOfssize:NEAR
EXTRN	UpdateCurrSegVars:NEAR
EXTRN	strncmp:NEAR
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$ParseLine DD 0a1f01H
	DD	054c41fH
	DD	059741bH
	DD	0586417H
	DD	057540eH
	DD	055010aH
xdata	ENDS
pdata	SEGMENT
$pdata$ParseLine DD @imagerel($LN357#)
	DD	@imagerel($LN357#+1227)
	DD	@imagerel($unwind$ParseLine#)
pdata	ENDS
xdata	SEGMENT
$chain$5$ParseLine DD 041521H
	DD	053d415H
	DD	0563408H
	DD	@imagerel($LN357#)
	DD	@imagerel($LN357#+1227)
	DD	@imagerel($unwind$ParseLine#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$ParseLine DD @imagerel($LN357#+1227)
	DD	@imagerel($LN357#+2949)
	DD	@imagerel($chain$5$ParseLine#)
pdata	ENDS
xdata	SEGMENT
$chain$7$ParseLine DD 042021H
	DD	051f420H
	DD	052e408H
	DD	@imagerel($LN357#+1227)
	DD	@imagerel($LN357#+2949)
	DD	@imagerel($chain$5$ParseLine#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$ParseLine DD @imagerel($LN357#+2949)
	DD	@imagerel($LN357#+6407)
	DD	@imagerel($chain$7$ParseLine#)
pdata	ENDS
xdata	SEGMENT
$chain$8$ParseLine DD 021H
	DD	@imagerel($LN357#+1227)
	DD	@imagerel($LN357#+2949)
	DD	@imagerel($chain$5$ParseLine#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$ParseLine DD @imagerel($LN357#+6407)
	DD	@imagerel($LN357#+6423)
	DD	@imagerel($chain$8$ParseLine#)
pdata	ENDS
xdata	SEGMENT
$chain$9$ParseLine DD 021H
	DD	@imagerel($LN357#)
	DD	@imagerel($LN357#+1227)
	DD	@imagerel($unwind$ParseLine#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$ParseLine DD @imagerel($LN357#+6423)
	DD	@imagerel($LN357#+6463)
	DD	@imagerel($chain$9$ParseLine#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
j$1$ = 52
oldofs$1$ = 56
oldofs$ = 56
CodeInfo$ = 64
tv2642 = 208
opndx$ = 224
tokenarray$ = 688
ParseLine PROC NEAR

; 2910 : {

$LN357:
	mov	rax, rsp
	sub	rsp, 680				; 000002a8H
	mov	QWORD PTR [rax+16], rbp

; 2911 :   int                 i;
; 2912 :   int                 j;
; 2913 :   int                 k = 0;
; 2914 :   int                 n = 0;
; 2915 :   unsigned            dirflags;
; 2916 :   unsigned            CurrOpnd;
; 2917 :   ret_code            temp;
; 2918 :   struct asym         *sym;
; 2919 :   uint_32             oldofs;
; 2920 :   enum special_token regtok;
; 2921 :   int                c0;
; 2922 :   int                c1;
; 2923 : 
; 2924 : #ifdef DEBUG_OUT
; 2925 :   char                *instr;
; 2926 : #endif
; 2927 :   struct code_info    CodeInfo;
; 2928 : #if AVXSUPP
; 2929 :   struct expr         opndx[MAX_OPND + 1];
; 2930 : #else
; 2931 :   struct expr         opndx[MAX_OPND];
; 2932 : #endif
; 2933 :   char *pnlbl;
; 2934 : 
; 2935 :   DebugMsg1(("ParseLine enter, Token_Count=%u, ofs=%Xh\n",
; 2936 :     Token_Count, GetCurrOffset()));
; 2937 :   i = 0;

	xor	ebp, ebp

; 2938 :   
; 2939 :   if (tokenarray[0].token == T_ID && (strncmp(tokenarray[0].string_ptr, "use16", 5) == 0 || strncmp(tokenarray[0].string_ptr, "USE16", 5) == 0))

	cmp	BYTE PTR [rcx], 8
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	QWORD PTR [rax-8], r12
	lea	r12d, QWORD PTR [rbp+1]
	mov	rsi, rcx
	mov	edi, ebp
	mov	DWORD PTR i$[rsp], ebp
	jne	$LN220@ParseLine
	mov	rcx, QWORD PTR [rcx+8]
	lea	r8d, QWORD PTR [rbp+5]
	lea	rdx, OFFSET FLAT:$SG7123
	call	strncmp
	test	eax, eax
	je	SHORT $LN248@ParseLine
	mov	rcx, QWORD PTR [rsi+8]
	lea	r8d, QWORD PTR [rbp+5]
	lea	rdx, OFFSET FLAT:$SG7124
	call	strncmp
	test	eax, eax
	jne	$LN249@ParseLine
$LN248@ParseLine:

; 2940 :   {
; 2941 : 	  ModuleInfo.frame_auto = 0;
; 2942 : 	  ModuleInfo.win64_flags = 0;
; 2943 : 	  ModuleInfo.offsettype = OT_GROUP;
; 2944 : 	  ModuleInfo.Ofssize = USE16;
; 2945 : 	  ModuleInfo.wordsize = 2;
; 2946 : 	  ModuleInfo.defOfssize = USE16;
; 2947 : 	  ModuleInfo.basereg[ModuleInfo.Ofssize] = T_SP;
; 2948 : 	  if (ModuleInfo.currseg)

	mov	rax, QWORD PTR ModuleInfo+432
	btr	DWORD PTR ModuleInfo+408, 18
	mov	BYTE PTR ModuleInfo+413, dil
	test	rax, rax
	mov	DWORD PTR ModuleInfo+384, ebp
	mov	BYTE PTR ModuleInfo+404, dil
	mov	BYTE PTR ModuleInfo+406, 2
	mov	BYTE PTR ModuleInfo+405, dil
	mov	DWORD PTR ModuleInfo+500, 13
	je	SHORT $LN246@ParseLine

; 2949 : 	  {
; 2950 : 		  ModuleInfo.currseg->e.seginfo->Ofssize = USE16;

	mov	rax, QWORD PTR [rax+104]
	mov	BYTE PTR [rax+104], dil

; 2951 : 		  ModuleInfo.currseg->e.seginfo->segtype = SEGTYPE_CODE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	mov	DWORD PTR [rcx+72], r12d

; 2952 : 		  ModuleInfo.currseg->sym.segment->Ofssize = USE16;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+32]
	mov	BYTE PTR [rcx+52], dil

; 2953 : 	  }
; 2954 : 	  if (CurrSeg)

	mov	rax, QWORD PTR ModuleInfo+432
	test	rax, rax
	je	SHORT $LN246@ParseLine

; 2955 : 	  {
; 2956 : 		  CurrSeg->e.seginfo->Ofssize = USE16;

	mov	rax, QWORD PTR [rax+104]
	mov	BYTE PTR [rax+104], dil

; 2957 : 		  CurrSeg->e.seginfo->segtype = SEGTYPE_CODE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	mov	DWORD PTR [rcx+72], r12d

; 2958 : 		  CurrSeg->sym.segment->Ofssize = USE16;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+32]
	mov	BYTE PTR [rcx+52], dil

; 2959 : 		  CurrSeg->sym.Ofssize = USE16;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	BYTE PTR [rax+52], dil
$LN246@ParseLine:

; 2960 : 	  }
; 2961 : 	  sym = SymSearch("_flat");

	lea	rcx, OFFSET FLAT:$SG7127
	call	SymFind

; 2962 : 	  if (sym)

	test	rax, rax
	je	SHORT $LN245@ParseLine

; 2963 : 	  {
; 2964 : 		  sym->isdefined = TRUE;

	or	BYTE PTR [rax+48], 2

; 2965 : 		  UpdateCurrSegVars();

	call	UpdateCurrSegVars

; 2966 : 		  SetOfssize();

	call	SetOfssize
$LN245@ParseLine:

; 2967 : 	  }
; 2968 : 	  FStoreLine(1);

	cmp	DWORD PTR Parse_Pass, edi
	jne	$LN228@ParseLine
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	mov	edx, r12d
	call	StoreLine

; 2969 : 	  return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN250@ParseLine
$LN249@ParseLine:

; 2970 :   }
; 2971 :   else if (tokenarray[0].token == T_ID && (strncmp(tokenarray[0].string_ptr, "use32", 5) == 0 || strncmp(tokenarray[0].string_ptr, "USE32", 5) == 0))

	cmp	BYTE PTR [rsi], 8
	jne	$LN319@ParseLine
	mov	rcx, QWORD PTR [rsi+8]
	lea	rdx, OFFSET FLAT:$SG7134
	mov	r8d, 5
	call	strncmp
	test	eax, eax
	je	SHORT $LN240@ParseLine
	mov	rcx, QWORD PTR [rsi+8]
	lea	rdx, OFFSET FLAT:$SG7135
	mov	r8d, 5
	call	strncmp
	test	eax, eax
	jne	$LN241@ParseLine
$LN240@ParseLine:

; 2972 :   {
; 2973 : 	  ModuleInfo.frame_auto = 0;
; 2974 : 	  ModuleInfo.win64_flags = 0;
; 2975 : 	  ModuleInfo.offsettype = OT_GROUP;
; 2976 : 	  ModuleInfo.Ofssize = USE32;
; 2977 : 	  ModuleInfo.wordsize = 4;
; 2978 : 	  ModuleInfo.defOfssize = USE32;
; 2979 : 	  ModuleInfo.basereg[ModuleInfo.Ofssize] = T_ESP;
; 2980 : 	  if (ModuleInfo.currseg)

	mov	rax, QWORD PTR ModuleInfo+432
	btr	DWORD PTR ModuleInfo+408, 18
	mov	BYTE PTR ModuleInfo+413, dil
	test	rax, rax
	mov	DWORD PTR ModuleInfo+384, ebp
	mov	BYTE PTR ModuleInfo+404, r12b
	mov	BYTE PTR ModuleInfo+406, 4
	mov	BYTE PTR ModuleInfo+405, r12b
	mov	DWORD PTR ModuleInfo+504, 21
	je	SHORT $LN238@ParseLine

; 2981 : 	  {
; 2982 : 		  ModuleInfo.currseg->e.seginfo->Ofssize = USE32;

	mov	rax, QWORD PTR [rax+104]
	mov	BYTE PTR [rax+104], r12b

; 2983 : 		  ModuleInfo.currseg->e.seginfo->segtype = SEGTYPE_CODE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	mov	DWORD PTR [rcx+72], r12d

; 2984 : 		  ModuleInfo.currseg->sym.segment->Ofssize = USE32;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+32]
	mov	BYTE PTR [rcx+52], r12b

; 2985 : 	  }
; 2986 : 	  if (CurrSeg)

	mov	rax, QWORD PTR ModuleInfo+432
	test	rax, rax
	je	SHORT $LN238@ParseLine

; 2987 : 	  {
; 2988 : 		  CurrSeg->e.seginfo->Ofssize = USE32;

	mov	rax, QWORD PTR [rax+104]
	mov	BYTE PTR [rax+104], r12b

; 2989 : 		  CurrSeg->e.seginfo->segtype = SEGTYPE_CODE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	mov	DWORD PTR [rcx+72], r12d

; 2990 : 		  CurrSeg->sym.segment->Ofssize = USE32;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+32]
	mov	BYTE PTR [rcx+52], r12b

; 2991 : 		  CurrSeg->sym.Ofssize = USE32;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	BYTE PTR [rax+52], r12b
$LN238@ParseLine:

; 2992 : 	  }
; 2993 : 	  sym = SymSearch("_flat");

	lea	rcx, OFFSET FLAT:$SG7138
	call	SymFind

; 2994 : 	  if (sym)

	test	rax, rax
	je	SHORT $LN237@ParseLine

; 2995 : 	  {
; 2996 : 		  sym->isdefined = TRUE;

	or	BYTE PTR [rax+48], 2

; 2997 : 		  UpdateCurrSegVars();

	call	UpdateCurrSegVars

; 2998 : 		  SetOfssize();

	call	SetOfssize
$LN237@ParseLine:

; 2999 : 	  }
; 3000 : 	  FStoreLine(1);

	cmp	DWORD PTR Parse_Pass, edi
	jne	$LN228@ParseLine
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	mov	edx, r12d
	call	StoreLine

; 3001 : 	  return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN250@ParseLine
$LN241@ParseLine:

; 3002 :   }
; 3003 :   else if (tokenarray[0].token == T_ID && (strncmp(tokenarray[0].string_ptr, "use64", 5) == 0 || strncmp(tokenarray[0].string_ptr, "USE64", 5) == 0))

	cmp	BYTE PTR [rsi], 8
	jne	$LN319@ParseLine
	mov	rcx, QWORD PTR [rsi+8]
	lea	rdx, OFFSET FLAT:$SG7145
	mov	r8d, 5
	call	strncmp
	test	eax, eax
	je	SHORT $LN232@ParseLine
	mov	rcx, QWORD PTR [rsi+8]
	lea	rdx, OFFSET FLAT:$SG7146
	mov	r8d, 5
	call	strncmp
	test	eax, eax
	jne	$LN233@ParseLine
$LN232@ParseLine:

; 3004 :   {
; 3005 : 	  ModuleInfo.frame_auto = 1;
; 3006 : 	  ModuleInfo.win64_flags = 11;
; 3007 : 	  ModuleInfo.offsettype = OT_FLAT;
; 3008 : 	  ModuleInfo.Ofssize = USE64;
; 3009 : 	  ModuleInfo.wordsize = 8;
; 3010 : 	  ModuleInfo.defOfssize = USE64;
; 3011 : 	  ModuleInfo.basereg[ModuleInfo.Ofssize] = T_RSP;
; 3012 : 	  if (ModuleInfo.currseg)

	mov	rax, QWORD PTR ModuleInfo+432
	bts	DWORD PTR ModuleInfo+408, 18
	mov	BYTE PTR ModuleInfo+413, 11
	test	rax, rax
	mov	DWORD PTR ModuleInfo+384, r12d
	mov	BYTE PTR ModuleInfo+404, 2
	mov	BYTE PTR ModuleInfo+406, 8
	mov	BYTE PTR ModuleInfo+405, 2
	mov	DWORD PTR ModuleInfo+508, 119		; 00000077H
	je	SHORT $LN230@ParseLine

; 3013 : 	  {
; 3014 : 		  ModuleInfo.currseg->e.seginfo->Ofssize = USE64;

	mov	rax, QWORD PTR [rax+104]
	mov	BYTE PTR [rax+104], 2

; 3015 : 		  ModuleInfo.currseg->e.seginfo->segtype = SEGTYPE_CODE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	mov	DWORD PTR [rcx+72], r12d

; 3016 : 		  ModuleInfo.currseg->sym.segment->Ofssize = USE64;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+32]
	mov	BYTE PTR [rcx+52], 2

; 3017 : 	  }
; 3018 : 	  if (CurrSeg)

	mov	rax, QWORD PTR ModuleInfo+432
	test	rax, rax
	je	SHORT $LN230@ParseLine

; 3019 : 	  {
; 3020 : 		  CurrSeg->e.seginfo->Ofssize = USE64;

	mov	rax, QWORD PTR [rax+104]
	mov	BYTE PTR [rax+104], 2

; 3021 : 		  CurrSeg->e.seginfo->segtype = SEGTYPE_CODE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	mov	DWORD PTR [rcx+72], r12d

; 3022 : 		  CurrSeg->sym.segment->Ofssize = USE64;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+32]
	mov	BYTE PTR [rcx+52], 2

; 3023 : 		  CurrSeg->sym.Ofssize = USE64;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	BYTE PTR [rax+52], 2
$LN230@ParseLine:

; 3024 : 	  }
; 3025 : 	  sym = SymSearch("_flat");

	lea	rcx, OFFSET FLAT:$SG7149
	call	SymFind

; 3026 : 	  if (sym)

	test	rax, rax
	je	SHORT $LN229@ParseLine

; 3027 : 	  {
; 3028 : 		  sym->isdefined = TRUE;

	or	BYTE PTR [rax+48], 2

; 3029 : 		  UpdateCurrSegVars();

	call	UpdateCurrSegVars

; 3030 : 		  SetOfssize();

	call	SetOfssize
$LN229@ParseLine:

; 3031 : 	  }
; 3032 : 	  FStoreLine(1);

	cmp	DWORD PTR Parse_Pass, edi
	jne	SHORT $LN228@ParseLine
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	mov	edx, r12d
	call	StoreLine
$LN228@ParseLine:

; 3033 : 	  return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN250@ParseLine
$LN233@ParseLine:

; 3034 :   }
; 3035 : 
; 3036 :   /* Does line start with a code label? */
; 3037 :   if (tokenarray[0].token == T_ID && (tokenarray[1].token == T_COLON || tokenarray[1].token == T_DBL_COLON)) {

	cmp	BYTE PTR [rsi], 8
	jne	$LN319@ParseLine
	movzx	eax, BYTE PTR [rsi+32]
	cmp	al, 58					; 0000003aH
	je	SHORT $LN225@ParseLine
	cmp	al, 13
	jne	$LN319@ParseLine
$LN225@ParseLine:

; 3038 :     i = 2;
; 3039 :     DebugMsg1(("ParseLine T_COLON, code label=%s\n", tokenarray[0].string_ptr));
; 3040 :     if (ProcStatus & PRST_PROLOGUE_NOT_DONE) write_prologue(tokenarray);

	test	BYTE PTR ProcStatus, -128		; ffffffffffffff80H
	mov	DWORD PTR i$[rsp], 2
	je	SHORT $LN224@ParseLine
	mov	rcx, rsi
	call	write_prologue
$LN224@ParseLine:

; 3041 : 
; 3042 : 	/* If we're in the .data or .data? section force code style label to create <name> LABEL BYTE */
; 3043 : 	c0 = strncmp(ModuleInfo.currseg->sym.name, "_DATA", 5);

	mov	rcx, QWORD PTR ModuleInfo+432
	lea	rdx, OFFSET FLAT:$SG7156
	mov	r8d, 5
	mov	rcx, QWORD PTR [rcx+8]
	call	strncmp

; 3044 : 	c1 = strncmp(ModuleInfo.currseg->sym.name, "_BSS", 4);

	mov	rcx, QWORD PTR ModuleInfo+432
	lea	rdx, OFFSET FLAT:$SG7157
	mov	rcx, QWORD PTR [rcx+8]
	mov	r8d, 4
	mov	edi, eax
	call	strncmp

; 3045 : 	if (c0 == 0 || c1 == 0)

	test	edi, edi
	je	$LN222@ParseLine
	test	eax, eax
	je	$LN222@ParseLine

; 3049 : 	}
; 3050 : 
; 3051 :     /* create a global or local code label */
; 3052 :     if (CreateLabel(tokenarray[0].string_ptr, MT_NEAR, NULL,
; 3053 :       (ModuleInfo.scoped && CurrProc && tokenarray[1].token != T_DBL_COLON)) == NULL) {

	bt	DWORD PTR ModuleInfo+408, 8
	jae	SHORT $LN252@ParseLine
	cmp	QWORD PTR CurrProc, rbp
	je	SHORT $LN252@ParseLine
	cmp	BYTE PTR [rsi+32], 13
	je	SHORT $LN252@ParseLine
	mov	eax, r12d
	jmp	SHORT $LN253@ParseLine
$LN252@ParseLine:
	mov	eax, ebp
$LN253@ParseLine:
	mov	rcx, QWORD PTR [rsi+8]
	movzx	r9d, al
	xor	r8d, r8d
	mov	edx, 129				; 00000081H
	call	CreateLabel
	test	rax, rax
	jne	SHORT $LN221@ParseLine

; 3054 :       DebugMsg(("ParseLine, CreateLabel(%s) failed, exit\n", tokenarray[0].string_ptr));
; 3055 :       return(ERROR);

	mov	rax, -1
	jmp	$LN250@ParseLine
$LN221@ParseLine:

; 3056 :     }
; 3057 :     if (tokenarray[i].token == T_FINAL) {

	movsxd	rdi, DWORD PTR i$[rsp]
	mov	rax, rdi
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], bpl
	jne	SHORT $LN220@ParseLine

; 3058 :       /* v2.06: this is a bit too late. Should be done BEFORE
; 3059 :        * CreateLabel, because of '@@'. There's a flag supposed to
; 3060 :        * be used for this handling, LOF_STORED in line_flags.
; 3061 :        * It's only a problem if a '@@:' is the first line
; 3062 :        * in the code section.
; 3063 :        * v2.10: is no longer an issue because the label counter has
; 3064 :        * been moved to module_vars (see global.h).
; 3065 :        */
; 3066 :       FStoreLine(0);

	cmp	DWORD PTR Parse_Pass, ebp
	jne	SHORT $LN219@ParseLine
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	xor	edx, edx
	call	StoreLine
$LN219@ParseLine:

; 3067 :       if (CurrFile[LST]) {

	cmp	QWORD PTR ModuleInfo+112, rbp
	je	SHORT $LN217@ParseLine

; 3068 :         LstWrite(LSTTYPE_LABEL, 0, NULL);

	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+7]
	call	LstWrite
$LN217@ParseLine:

; 3069 :       }
; 3070 :       return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN250@ParseLine
$LN222@ParseLine:

; 3046 : 	{
; 3047 : 		AddLineQueueX("%s %s", tokenarray[0].string_ptr, "LABEL BYTE");

	mov	rdx, QWORD PTR [rsi+8]
	lea	r8, OFFSET FLAT:$SG7161
	lea	rcx, OFFSET FLAT:$SG7162
	call	AddLineQueueX

; 3048 : 		return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN250@ParseLine
$LN319@ParseLine:
	mov	edi, DWORD PTR i$[rsp]
$LN220@ParseLine:

; 3071 :     }
; 3072 :   }
; 3073 :   /* John: added support for code labels starting with a period v2.17 */
; 3074 :   if ((tokenarray[0].token == T_DOT && tokenarray[1].token == T_ID && (tokenarray[2].token == T_COLON || tokenarray[2].token == T_DBL_COLON))) {

	cmp	BYTE PTR [rsi], 46			; 0000002eH
	mov	QWORD PTR [rsp+688], rbx
	mov	ebx, 3
	mov	QWORD PTR [rsp+664], r13
	lea	r13, QWORD PTR [rbx-4]
	jne	$LN212@ParseLine
	cmp	BYTE PTR [rsi+32], 8
	jne	$LN212@ParseLine
	movzx	eax, BYTE PTR [rsi+64]
	cmp	al, 58					; 0000003aH
	je	SHORT $LN215@ParseLine
	cmp	al, 13
	jne	$LN212@ParseLine
$LN215@ParseLine:

; 3075 : 	 i = 3;
; 3076 : 	  
; 3077 : 	  pnlbl = malloc(strlen(tokenarray[1].string_ptr) + 2);

	mov	rdi, QWORD PTR [rsi+40]
	xor	eax, eax
	mov	DWORD PTR i$[rsp], ebx
	mov	rcx, r13
	repne scasb
	not	rcx
	inc	rcx
	call	malloc

; 3078 : 	  sprintf(pnlbl, "%s%s", ".", tokenarray[1].string_ptr);

	mov	r9, QWORD PTR [rsi+40]
	lea	r8, OFFSET FLAT:$SG7173
	lea	rdx, OFFSET FLAT:$SG7174
	mov	rcx, rax
	mov	rdi, rax
	call	sprintf

; 3079 : 
; 3080 : 	  DebugMsg1(("ParseLine T_COLON, code label=%s\n", pnlbl));
; 3081 : 	  if (ProcStatus & PRST_PROLOGUE_NOT_DONE) write_prologue(tokenarray);

	test	BYTE PTR ProcStatus, -128		; ffffffffffffff80H
	je	SHORT $LN214@ParseLine
	mov	rcx, rsi
	call	write_prologue
$LN214@ParseLine:

; 3082 : 
; 3083 : 	  /* create a global or local code label */
; 3084 : 	  if (CreateLabel(pnlbl, MT_NEAR, NULL,
; 3085 : 		  (ModuleInfo.scoped && CurrProc && tokenarray[2].token != T_DBL_COLON)) == NULL) {

	bt	DWORD PTR ModuleInfo+408, 8
	jae	SHORT $LN254@ParseLine
	cmp	QWORD PTR CurrProc, rbp
	je	SHORT $LN254@ParseLine
	cmp	BYTE PTR [rsi+64], 13
	je	SHORT $LN254@ParseLine
	mov	eax, r12d
	jmp	SHORT $LN255@ParseLine
$LN254@ParseLine:
	mov	eax, ebp
$LN255@ParseLine:
	movzx	r9d, al
	xor	r8d, r8d
	mov	edx, 129				; 00000081H
	mov	rcx, rdi
	call	CreateLabel
	test	rax, rax

; 3086 : 		  DebugMsg(("ParseLine, CreateLabel(%s) failed, exit\n", pnlbl));
; 3087 : 		  return(ERROR);

	je	$LN175@ParseLine

; 3088 : 	  }
; 3089 : 	  if (tokenarray[i].token == T_FINAL) {

	movsxd	rdi, DWORD PTR i$[rsp]
	mov	rax, rdi
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], bpl
	jne	SHORT $LN212@ParseLine

; 3090 : 		  /* v2.06: this is a bit too late. Should be done BEFORE
; 3091 : 		  * CreateLabel, because of '@@'. There's a flag supposed to
; 3092 : 		  * be used for this handling, LOF_STORED in line_flags.
; 3093 : 		  * It's only a problem if a '@@:' is the first line
; 3094 : 		  * in the code section.
; 3095 : 		  * v2.10: is no longer an issue because the label counter has
; 3096 : 		  * been moved to module_vars (see global.h).
; 3097 : 		  */
; 3098 : 		  FStoreLine(0);

	cmp	DWORD PTR Parse_Pass, ebp
	jne	SHORT $LN211@ParseLine
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	xor	edx, edx
	call	StoreLine
$LN211@ParseLine:

; 3099 : 		  if (CurrFile[LST]) {

	cmp	QWORD PTR ModuleInfo+112, rbp
	je	SHORT $LN209@ParseLine

; 3100 : 			  LstWrite(LSTTYPE_LABEL, 0, NULL);

	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+7]
	call	LstWrite
$LN209@ParseLine:

; 3101 : 		  }
; 3102 : 		  return(NOT_ERROR);

	xor	eax, eax
	jmp	$LN351@ParseLine
$LN212@ParseLine:

; 3103 : 	  }
; 3104 :   }
; 3105 : 
; 3106 :   /* handle directives and (anonymous) data items */
; 3107 :   if (tokenarray[i].token != T_INSTRUCTION) {

	movsxd	rax, edi
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], r12b
	je	$LN208@ParseLine

; 3108 :     /* a code label before a data item is only accepted in Masm5 compat mode */
; 3109 :     Frame_Type = FRAME_NONE;
; 3110 :     SegOverride = NULL;
; 3111 :     if (i == 0 && tokenarray[0].token == T_ID) {

	test	edi, edi
	mov	BYTE PTR Frame_Type, 6
	mov	QWORD PTR SegOverride, rbp
	jne	SHORT $LN202@ParseLine
	cmp	BYTE PTR [rsi], 8
	jne	SHORT $LN202@ParseLine

; 3112 :       /* token at pos 0 may be a label.
; 3113 :        * it IS a label if:
; 3114 :        * 1. token at pos 1 is a directive (lbl dd ...)
; 3115 :        * 2. token at pos 0 is NOT a userdef type ( lbl DWORD ...)
; 3116 :        * 3. inside a struct and token at pos 1 is a userdef type
; 3117 :        *    or a predefined type. (usertype DWORD|usertype ... )
; 3118 :        *    the separate namespace allows this syntax here.
; 3119 :        */
; 3120 :       if (tokenarray[1].token == T_DIRECTIVE)

	cmp	BYTE PTR [rsi+32], bl
	jne	SHORT $LN206@ParseLine

; 3121 :         i++;

	mov	edi, r12d
	mov	DWORD PTR i$[rsp], r12d

; 3122 :       else {

	jmp	SHORT $LN202@ParseLine
$LN206@ParseLine:

; 3123 :         sym = IsType(tokenarray[0].string_ptr);

	mov	rcx, QWORD PTR [rsi+8]
	call	SymFind
	test	rax, rax
	je	SHORT $LN308@ParseLine
	cmp	DWORD PTR [rax+40], 7
	je	SHORT $LN204@ParseLine
$LN308@ParseLine:

; 3124 :         if (sym == NULL)
; 3125 :           i++;

	mov	edi, DWORD PTR i$[rsp]
	inc	edi
	mov	DWORD PTR i$[rsp], edi

; 3126 :         else if (CurrStruct &&

	jmp	SHORT $LN202@ParseLine
$LN204@ParseLine:

; 3127 :           ((tokenarray[1].token == T_STYPE) ||
; 3128 :           (tokenarray[1].token == T_ID && (IsType(tokenarray[1].string_ptr)))))

	cmp	QWORD PTR CurrStruct, rbp
	je	SHORT $LN320@ParseLine
	movzx	eax, BYTE PTR [rsi+32]
	cmp	al, 6
	je	SHORT $LN263@ParseLine
	cmp	al, 8
	jne	SHORT $LN320@ParseLine
	mov	rcx, QWORD PTR [rsi+40]
	call	SymFind
	test	rax, rax
	je	SHORT $LN322@ParseLine
	cmp	DWORD PTR [rax+40], 7
	jne	SHORT $LN322@ParseLine
$LN263@ParseLine:

; 3129 :           i++;

	mov	edi, DWORD PTR i$[rsp]
	inc	edi
	mov	DWORD PTR i$[rsp], edi
	jmp	SHORT $LN202@ParseLine
$LN320@ParseLine:
	mov	edi, DWORD PTR i$[rsp]
	jmp	SHORT $LN202@ParseLine
$LN322@ParseLine:

; 3122 :       else {

	mov	edi, DWORD PTR i$[rsp]
$LN202@ParseLine:

; 3130 :       }
; 3131 :     }
; 3132 :     switch (tokenarray[i].token) {

	movsxd	rdx, edi
	shl	rdx, 5
	movzx	ecx, BYTE PTR [rdx+rsi]
	cmp	cl, bl
	mov	al, cl
	je	$LN198@ParseLine
	cmp	al, 6
	je	SHORT $LN173@ParseLine
	cmp	al, 8
	je	SHORT $LN172@ParseLine

; 3208 :       }
; 3209 :       break;
; 3210 :     default:
; 3211 :       if (tokenarray[i].token == T_COLON) {

	cmp	cl, 58					; 0000003aH
	jne	SHORT $LN171@ParseLine

; 3212 :         DebugMsg(("ParseLine: unexpected colon\n"));
; 3213 :         return(EmitError(SYNTAX_ERROR_UNEXPECTED_COLON));

	mov	ecx, 47					; 0000002fH
	call	EmitError
	jmp	$LN351@ParseLine
$LN172@ParseLine:

; 3204 :     case T_ID:
; 3205 :       DebugMsg1(("ParseLine: T_ID >%s<\n", tokenarray[i].string_ptr));
; 3206 :       if (sym = IsType(tokenarray[i].string_ptr)) {

	mov	rcx, QWORD PTR [rdx+rsi+8]
	call	SymFind
	test	rax, rax
	je	SHORT $LN323@ParseLine
	cmp	DWORD PTR [rax+40], 7
	jne	SHORT $LN323@ParseLine

; 3207 :         return(data_dir(i, tokenarray, sym));

	mov	ecx, DWORD PTR i$[rsp]
	mov	r8, rax
	mov	rdx, rsi
	call	data_dir
	jmp	$LN351@ParseLine
$LN323@ParseLine:
	mov	edi, DWORD PTR i$[rsp]
$LN171@ParseLine:

; 3214 :       }
; 3215 :       break;
; 3216 :     } /* end switch (tokenarray[i].token) */
; 3217 :     if (i && tokenarray[i - 1].token == T_ID)

	test	edi, edi
	je	SHORT $LN168@ParseLine
	movsxd	rax, edi
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi-32], 8
	jne	SHORT $LN168@ParseLine

; 3218 :       i--;

	dec	edi
	mov	DWORD PTR i$[rsp], edi
$LN168@ParseLine:

; 3219 :     DebugMsg(("ParseLine: unexpected token=%u, i=%u, string=%s\n", tokenarray[i].token, i, tokenarray[i].string_ptr));
; 3220 :     return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].string_ptr));

	movsxd	rdx, edi
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+8]
	call	EmitErr
	jmp	$LN351@ParseLine
$LN173@ParseLine:

; 3201 :     case T_STYPE:
; 3202 :       DebugMsg1(("ParseLine: T_STYPE >%s<\n", tokenarray[i].string_ptr));
; 3203 :       return(data_dir(i, tokenarray, NULL));

	xor	r8d, r8d
	mov	rdx, rsi
	mov	ecx, edi
	call	data_dir
	jmp	$LN351@ParseLine
$LN198@ParseLine:

; 3133 :     case T_DIRECTIVE:
; 3134 :       DebugMsg1(("ParseLine: T_DIRECTIVE >%s<\n", tokenarray[i].string_ptr));
; 3135 :       if (tokenarray[i].dirtype == DRT_DATADIR) {

	cmp	BYTE PTR [rdx+rsi+1], 8

; 3136 :         return(data_dir(i, tokenarray, NULL));

	je	SHORT $LN173@ParseLine

; 3137 :       }
; 3138 :       dirflags = GetValueSp(tokenarray[i].tokval);
; 3139 :       if (CurrStruct && (dirflags & DF_NOSTRUC)) {

	cmp	QWORD PTR CurrStruct, 0
	mov	eax, DWORD PTR [rdx+rsi+16]
	lea	rbp, OFFSET FLAT:__ImageBase
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	ebx, DWORD PTR SpecialTable[rbp+rcx*4]
	je	SHORT $LN196@ParseLine
	test	bl, 16
	je	SHORT $LN196@ParseLine
$LN356@ParseLine:

; 3140 :         return(EmitError(STATEMENT_NOT_ALLOWED_INSIDE_STRUCTURE_DEFINITION));

	mov	ecx, 141				; 0000008dH
	call	EmitError
	jmp	$LN351@ParseLine
$LN196@ParseLine:

; 3141 :       }
; 3142 :       /* label allowed for directive? */
; 3143 :       //if ( tokenarray[i].flags & DF_LABEL ) {
; 3144 :       if (dirflags & DF_LABEL) {

	test	bl, 8
	je	SHORT $LN195@ParseLine

; 3145 :         if (i && tokenarray[0].token != T_ID) {

	test	edi, edi
	je	SHORT $LN192@ParseLine
	cmp	BYTE PTR [rsi], 8
	je	SHORT $LN192@ParseLine

; 3146 :           return(EmitErr(SYNTAX_ERROR_EX, tokenarray[0].string_ptr));

	mov	rdx, QWORD PTR [rsi+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN351@ParseLine
$LN195@ParseLine:

; 3147 :         }
; 3148 :       }
; 3149 :       else if (i && tokenarray[i - 1].token != T_COLON && tokenarray[i - 1].token != T_DBL_COLON) {

	test	edi, edi
	je	SHORT $LN192@ParseLine
	movzx	eax, BYTE PTR [rdx+rsi-32]
	cmp	al, 58					; 0000003aH
	je	SHORT $LN192@ParseLine
	cmp	al, 13
	je	SHORT $LN192@ParseLine

; 3150 :         return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i - 1].string_ptr));

	mov	rdx, QWORD PTR [rdx+rsi-24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN351@ParseLine
$LN192@ParseLine:

; 3151 :       }
; 3152 :       /* must be done BEFORE FStoreLine()! */
; 3153 :       if ((ProcStatus & PRST_PROLOGUE_NOT_DONE) && (dirflags & DF_PROC)) write_prologue(tokenarray);

	test	BYTE PTR ProcStatus, -128		; ffffffffffffff80H
	je	SHORT $LN191@ParseLine
	test	bl, 64					; 00000040H
	je	SHORT $LN191@ParseLine
	mov	rcx, rsi
	call	write_prologue
	mov	edi, DWORD PTR i$[rsp]
$LN191@ParseLine:

; 3154 : #if FASTPASS
; 3155 :       if (StoreState || (dirflags & DF_STORE)) {

	cmp	BYTE PTR StoreState, 0
	jne	SHORT $LN189@ParseLine
	test	bl, bl
	jns	SHORT $LN184@ParseLine
$LN189@ParseLine:

; 3156 :         /* v2.07: the comment must be stored as well
; 3157 :          * if a listing (with -Sg) is to be written and
; 3158 :          * the directive will generate lines
; 3159 :          */
; 3160 :         if ((dirflags & DF_CGEN) && ModuleInfo.CurrComment && ModuleInfo.list_generated_code) {

	bt	ebx, 8
	jae	SHORT $LN188@ParseLine
	cmp	QWORD PTR ModuleInfo+472, 0
	je	SHORT $LN188@ParseLine
	bt	DWORD PTR ModuleInfo+408, 15
	jae	SHORT $LN188@ParseLine

; 3161 :           FStoreLine(1);

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN184@ParseLine
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	mov	edx, r12d
	call	StoreLine

; 3162 :         }
; 3163 :         else

	mov	edi, DWORD PTR i$[rsp]
	jmp	SHORT $LN184@ParseLine
$LN188@ParseLine:

; 3164 :           FStoreLine(0);

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN184@ParseLine
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	xor	edx, edx
	call	StoreLine
	mov	edi, DWORD PTR i$[rsp]
$LN184@ParseLine:

; 3165 :       }
; 3166 : #endif
; 3167 :       if (tokenarray[i].dirtype > DRT_DATADIR) {

	movsxd	rdx, edi
	shl	rdx, 5
	movzx	eax, BYTE PTR [rdx+rsi+1]
	cmp	al, 8
	jbe	SHORT $LN182@ParseLine

; 3168 :         temp = directive_tab[tokenarray[i].dirtype](i, tokenarray);

	movzx	eax, al
	mov	rdx, rsi
	mov	ecx, edi
	call	QWORD PTR directive_tab[rbp+rax*8]
	mov	r13d, eax

; 3169 :       }
; 3170 :       else {

	jmp	SHORT $LN179@ParseLine
$LN182@ParseLine:

; 3171 :         temp = ERROR;
; 3172 :         /* ENDM, EXITM and GOTO directives should never be seen here */
; 3173 :         switch (tokenarray[i].tokval) {

	mov	eax, DWORD PTR [rdx+rsi+16]
	sub	eax, 398				; 0000018eH
	je	SHORT $LN177@ParseLine
	dec	eax
	je	SHORT $LN178@ParseLine
	dec	eax
	je	SHORT $LN177@ParseLine

; 3180 :           break;
; 3181 :         default:
; 3182 :           /* this error may happen if
; 3183 :            * CATSTR, SUBSTR, MACRO, ...
; 3184 :            * aren't at pos 1
; 3185 :            */
; 3186 :           EmitErr(SYNTAX_ERROR_EX, tokenarray[i].string_ptr);

	mov	rdx, QWORD PTR [rdx+rsi+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 3187 :           break;

	jmp	SHORT $LN179@ParseLine
$LN178@ParseLine:

; 3174 :         case T_ENDM:
; 3175 :           EmitError(UNMATCHED_MACRO_NESTING);

	mov	ecx, 162				; 000000a2H
	call	EmitError

; 3176 :           break;

	jmp	SHORT $LN179@ParseLine
$LN177@ParseLine:

; 3177 :         case T_EXITM:
; 3178 :         case T_GOTO:
; 3179 :           EmitError(DIRECTIVE_MUST_APPEAR_INSIDE_A_MACRO);

	mov	ecx, 178				; 000000b2H
	call	EmitError
$LN179@ParseLine:

; 3188 :         }
; 3189 :       }
; 3190 :       /* v2.0: for generated code it's important that list file is
; 3191 :        * written in ALL passes, to update file position! */
; 3192 :       //if ( ModuleInfo.list && (( line_flags & LOF_LISTED ) == 0 ) && Parse_Pass == PASS_1 )
; 3193 : #if FASTPASS
; 3194 :       /* v2.08: UseSavedState == FALSE added */
; 3195 :       if (ModuleInfo.list && (Parse_Pass == PASS_1 || ModuleInfo.GeneratedCode || UseSavedState == FALSE))

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN175@ParseLine
	cmp	DWORD PTR Parse_Pass, 0
	je	SHORT $LN174@ParseLine
	cmp	DWORD PTR ModuleInfo+456, 0
	jne	SHORT $LN174@ParseLine
	cmp	BYTE PTR UseSavedState, 0
	jne	SHORT $LN175@ParseLine
$LN174@ParseLine:

; 3196 : #else
; 3197 :       if ( ModuleInfo.list )
; 3198 : #endif
; 3199 :         LstWriteSrcLine();

	call	LstWriteSrcLine
$LN175@ParseLine:

; 3200 :       return(temp);

	mov	eax, r13d
	jmp	$LN351@ParseLine
$LN208@ParseLine:

; 3221 :   }
; 3222 : 
; 3223 :   DebugMsg1(("ParseLine: %s\n", tokenarray[i].string_ptr));
; 3224 :   /* v2.04 added */
; 3225 :   if (CurrStruct) {

	cmp	QWORD PTR CurrStruct, rbp

; 3226 :     return(EmitError(STATEMENT_NOT_ALLOWED_INSIDE_STRUCTURE_DEFINITION));

	jne	$LN356@ParseLine

; 3227 :   }
; 3228 : 
; 3229 :   if (ProcStatus & PRST_PROLOGUE_NOT_DONE) write_prologue(tokenarray);

	test	BYTE PTR ProcStatus, -128		; ffffffffffffff80H
	je	SHORT $LN166@ParseLine
	mov	rcx, rsi
	call	write_prologue
	mov	edi, DWORD PTR i$[rsp]
$LN166@ParseLine:

; 3230 : 
; 3231 :   /* v2.07: moved because special handling is needed for RET/IRET */
; 3232 :   //FStoreLine(); /* must be placed AFTER write_prologue() */
; 3233 : 
; 3234 :   if (CurrFile[LST]) oldofs = GetCurrOffset();

	cmp	QWORD PTR ModuleInfo+112, rbp
	je	SHORT $LN324@ParseLine
	call	GetCurrOffset
	mov	edi, DWORD PTR i$[rsp]
	mov	DWORD PTR oldofs$1$[rsp], eax
	jmp	SHORT $LN165@ParseLine
$LN324@ParseLine:
	mov	eax, DWORD PTR oldofs$[rsp]
	mov	DWORD PTR oldofs$1$[rsp], eax
$LN165@ParseLine:

; 3235 : 
; 3236 :   /* init CodeInfo */
; 3237 :   CodeInfo.prefix.ins = EMPTY;
; 3238 :   CodeInfo.prefix.RegOverride = EMPTY;
; 3239 : #if AMD64_SUPPORT
; 3240 :   CodeInfo.prefix.rex = 0;
; 3241 : #endif
; 3242 :   CodeInfo.prefix.adrsiz = FALSE;
; 3243 :   CodeInfo.prefix.opsiz = FALSE;

	and	BYTE PTR CodeInfo$[rsp+9], 252		; 000000fcH
	mov	DWORD PTR CodeInfo$[rsp], -2
	mov	DWORD PTR CodeInfo$[rsp+4], -2
	mov	BYTE PTR CodeInfo$[rsp+8], bpl

; 3244 :   CodeInfo.mem_type = MT_EMPTY;

	mov	DWORD PTR CodeInfo$[rsp+28], 192	; 000000c0H
	lea	rax, QWORD PTR CodeInfo$[rsp+32]
$LL164@ParseLine:

; 3245 :   for (j = 0; j < MAX_OPND; j++) {
; 3246 :     CodeInfo.opnd[j].type = OP_NONE;

	mov	DWORD PTR [rax], ebp
	add	rax, 24
	dec	rbx
	jne	SHORT $LL164@ParseLine

; 3247 : #ifdef DEBUG_OUT
; 3248 :     CodeInfo.opnd[j].data32l = -1;
; 3249 :     /* make sure it's invalid */
; 3250 :     CodeInfo.opnd[j].InsFixup = (void *)0xffffffff;
; 3251 : #endif
; 3252 :   }
; 3253 :   CodeInfo.rm_byte = 0;
; 3254 :   CodeInfo.sib = 0;            /* assume ss is *1 */
; 3255 :   CodeInfo.Ofssize = ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR ModuleInfo+404
	mov	BYTE PTR CodeInfo$[rsp+104], bpl
	mov	BYTE PTR CodeInfo$[rsp+105], bpl
	mov	BYTE PTR CodeInfo$[rsp+106], al

; 3256 :   CodeInfo.opc_or = 0;
; 3257 :   CodeInfo.basetype = 0;
; 3258 :   CodeInfo.indextype = 0;
; 3259 : #if AVXSUPP
; 3260 :   CodeInfo.evex_sae = 0;
; 3261 :   CodeInfo.vexregop = 0;
; 3262 :   CodeInfo.tuple = 0;
; 3263 :   CodeInfo.vexconst = 0;
; 3264 :   CodeInfo.evex_flag = FALSE;  /* if TRUE will output 0x62 */
; 3265 :   CodeInfo.reg1 = 0;
; 3266 :   CodeInfo.reg2 = 0;
; 3267 :   CodeInfo.reg3 = 0xff;          /* if not reg3 make it negative  */
; 3268 :   CodeInfo.basereg = 0xff;
; 3269 :   CodeInfo.indexreg = 0xff;
; 3270 :   if (tokenarray[0].tokval >= T_KADDB && tokenarray[0].tokval <= T_KMOVW){

	mov	eax, DWORD PTR [rsi+16]
	mov	BYTE PTR CodeInfo$[rsp+107], bpl
	cmp	eax, 1730				; 000006c2H
	mov	BYTE PTR CodeInfo$[rsp+108], bpl
	mov	DWORD PTR CodeInfo$[rsp+132], ebp
	mov	BYTE PTR CodeInfo$[rsp+141], bpl
	mov	BYTE PTR CodeInfo$[rsp+128], bpl
	mov	BYTE PTR CodeInfo$[rsp+140], bpl
	mov	DWORD PTR CodeInfo$[rsp+124], ebp
	mov	BYTE PTR CodeInfo$[rsp+136], bpl
	mov	BYTE PTR CodeInfo$[rsp+109], bpl
	mov	BYTE PTR CodeInfo$[rsp+110], bpl
	mov	BYTE PTR CodeInfo$[rsp+111], 255	; 000000ffH
	mov	BYTE PTR CodeInfo$[rsp+113], 255	; 000000ffH
	mov	BYTE PTR CodeInfo$[rsp+112], 255	; 000000ffH
	jb	SHORT $LN161@ParseLine
	cmp	eax, 1776				; 000006f0H
	ja	SHORT $LN161@ParseLine

; 3271 :     CodeInfo.evex_flag = FALSE;

	mov	BYTE PTR CodeInfo$[rsp+136], bpl

; 3272 :   }
; 3273 :   else{

	jmp	SHORT $LN159@ParseLine
$LN161@ParseLine:

; 3274 :     //Init EVEX three bytes
; 3275 :     CodeInfo.evex_p0 = 0;      /* P0[3 : 2] Must be 0 */
; 3276 :     CodeInfo.evex_p1 = 0x4;    /* P1[2]    Must be 1  */
; 3277 :     CodeInfo.evex_p2 = 0;
; 3278 :     if (broadflags || decoflags)

	cmp	BYTE PTR broadflags, bpl
	mov	BYTE PTR CodeInfo$[rsp+137], bpl
	mov	BYTE PTR CodeInfo$[rsp+138], 4
	mov	BYTE PTR CodeInfo$[rsp+139], bpl
	jne	SHORT $LN158@ParseLine
	cmp	BYTE PTR decoflags, bpl
	je	SHORT $LN159@ParseLine
$LN158@ParseLine:

; 3279 :       CodeInfo.evex_flag = TRUE;   /* if TRUE will output 0x62 */

	mov	BYTE PTR CodeInfo$[rsp+136], r12b
$LN159@ParseLine:

; 3280 :   }
; 3281 : #endif
; 3282 :   CodeInfo.flags = 0;
; 3283 : 
; 3284 :   /* instruction prefix?
; 3285 :    * T_LOCK, T_REP, T_REPE, T_REPNE, T_REPNZ, T_REPZ */
; 3286 :   if (tokenarray[i].tokval >= T_LOCK && tokenarray[i].tokval <= T_REPZ) {

	movsxd	rcx, edi
	mov	BYTE PTR CodeInfo$[rsp+142], bpl
	shl	rcx, 5
	add	rcx, rsi
	mov	eax, DWORD PTR [rcx+16]
	cmp	eax, 582				; 00000246H
	jb	SHORT $LN156@ParseLine
	cmp	eax, 587				; 0000024bH
	ja	SHORT $LN156@ParseLine

; 3287 :     CodeInfo.prefix.ins = tokenarray[i].tokval;
; 3288 :     i++;

	inc	edi
	mov	DWORD PTR CodeInfo$[rsp], eax

; 3289 :     /* prefix has to be followed by an instruction */
; 3290 :     if (tokenarray[i].token != T_INSTRUCTION) {

	movsxd	rcx, edi
	mov	DWORD PTR i$[rsp], edi
	shl	rcx, 5
	add	rcx, rsi
	cmp	BYTE PTR [rcx], r12b
	je	SHORT $LN156@ParseLine

; 3291 :       DebugMsg(("ParseLine: unexpected token %u after prefix, exit, error\n", tokenarray[i].token));
; 3292 :       return(EmitError(PREFIX_MUST_BE_FOLLOWED_BY_AN_INSTRUCTION));

	mov	ecx, 46					; 0000002eH
	call	EmitError
	jmp	$LN351@ParseLine
$LN156@ParseLine:

; 3293 :     }
; 3294 :     DebugMsg1(("ParseLine: %s\n", tokenarray[i].tokpos));
; 3295 :   };
; 3296 : 
; 3297 :   if (CurrProc) {

	mov	rdx, QWORD PTR CurrProc
	test	rdx, rdx
	je	$LN148@ParseLine

; 3298 :     switch (tokenarray[i].tokval) {

	mov	eax, DWORD PTR [rcx+16]
	cmp	eax, 627				; 00000273H
	jb	$LN148@ParseLine
	cmp	eax, 628				; 00000274H
	jbe	SHORT $LN152@ParseLine
	cmp	eax, 649				; 00000289H
	je	SHORT $LN152@ParseLine
	cmp	eax, 1217				; 000004c1H
	jne	$LN148@ParseLine
$LN152@ParseLine:

; 3299 :     case T_RET:
; 3300 :     case T_IRET:  /* IRET is always 16-bit; OTOH, IRETW doesn't exist */
; 3301 :     case T_IRETD:
; 3302 : #if AMD64_SUPPORT
; 3303 :     case T_IRETQ:
; 3304 : #endif
; 3305 :       if (!(ProcStatus & PRST_INSIDE_EPILOGUE) && ModuleInfo.epiloguemode != PEM_NONE) {

	test	BYTE PTR ProcStatus, 2
	jne	SHORT $LN151@ParseLine
	cmp	BYTE PTR ModuleInfo+425, 2
	je	SHORT $LN151@ParseLine

; 3306 :         /* v2.07: special handling for RET/IRET */
; 3307 :         FStoreLine((ModuleInfo.CurrComment && ModuleInfo.list_generated_code) ? 1 : 0);

	cmp	DWORD PTR Parse_Pass, ebp
	jne	SHORT $LN150@ParseLine
	cmp	QWORD PTR ModuleInfo+472, rbp
	je	SHORT $LN256@ParseLine
	bt	DWORD PTR ModuleInfo+408, 15
	jb	SHORT $LN257@ParseLine
$LN256@ParseLine:
	mov	r12d, ebp
$LN257@ParseLine:
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	mov	edx, r12d
	call	StoreLine
	mov	edi, DWORD PTR i$[rsp]
$LN150@ParseLine:

; 3308 :         ProcStatus |= PRST_INSIDE_EPILOGUE;
; 3309 :         temp = RetInstr(i, tokenarray, Token_Count);

	mov	r8d, DWORD PTR ModuleInfo+496
	or	DWORD PTR ProcStatus, 2
	mov	rdx, rsi
	mov	ecx, edi
	call	RetInstr

; 3310 :         ProcStatus &= ~PRST_INSIDE_EPILOGUE;

	and	DWORD PTR ProcStatus, -3

; 3311 :         return(temp);

	jmp	$LN351@ParseLine
$LN151@ParseLine:

; 3312 :       }
; 3313 :       /* default translation: just RET to RETF if proc is far */
; 3314 :       /* v2.08: this code must run even if PRST_INSIDE_EPILOGUE is set */
; 3315 :       if (tokenarray[i].tokval == T_RET && CurrProc->sym.mem_type == MT_FAR)

	cmp	eax, 649				; 00000289H
	jne	SHORT $LN148@ParseLine
	cmp	DWORD PTR [rdx+44], 130			; 00000082H
	jne	SHORT $LN148@ParseLine

; 3316 :         tokenarray[i].tokval = T_RETF;

	mov	DWORD PTR [rcx+16], 651			; 0000028bH
	mov	edi, DWORD PTR i$[rsp]
$LN148@ParseLine:

; 3317 :     }
; 3318 :   }
; 3319 : 
; 3320 :   FStoreLine(0); /* must be placed AFTER write_prologue() */

	cmp	DWORD PTR Parse_Pass, ebp
	jne	SHORT $LN147@ParseLine
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	xor	edx, edx
	call	StoreLine
	mov	edi, DWORD PTR i$[rsp]
$LN147@ParseLine:

; 3321 : 
; 3322 : #ifdef DEBUG_OUT
; 3323 :   instr = tokenarray[i].string_ptr;
; 3324 : #endif
; 3325 :   CodeInfo.token = tokenarray[i].tokval;

	movsxd	rax, edi

; 3326 :   /* get the instruction's start position in InstrTable[] */
; 3327 :   CodeInfo.pinstr = &InstrTable[IndexFromToken(CodeInfo.token)];
; 3328 :   i++;

	inc	edi
	lea	rcx, OFFSET FLAT:__ImageBase
	shl	rax, 5
	movsxd	rbx, DWORD PTR [rax+rsi+16]
	lea	rax, OFFSET FLAT:InstrTable
	mov	DWORD PTR i$[rsp], edi
	movzx	ecx, WORD PTR optable_idx[rcx+rbx*2-910]
	mov	DWORD PTR CodeInfo$[rsp+24], ebx
	imul	rcx, 14
	add	rcx, rax

; 3329 : 
; 3330 :   if (CurrSeg == NULL) {

	mov	rax, QWORD PTR ModuleInfo+432
	test	rax, rax
	mov	QWORD PTR CodeInfo$[rsp+16], rcx
	jne	SHORT $LN145@ParseLine

; 3331 :     return(EmitError(MUST_BE_IN_SEGMENT_BLOCK));

	lea	ecx, QWORD PTR [rax+82]
	call	EmitError
	jmp	$LN351@ParseLine
$LN145@ParseLine:

; 3332 :   }
; 3333 :   if (CurrSeg->e.seginfo->segtype == SEGTYPE_UNDEF) {

	mov	rax, QWORD PTR [rax+104]
	cmp	DWORD PTR [rax+72], ebp
	jne	SHORT $LN144@ParseLine

; 3334 :     CurrSeg->e.seginfo->segtype = SEGTYPE_CODE;

	mov	DWORD PTR [rax+72], r12d
	mov	edi, DWORD PTR i$[rsp]
	mov	ebx, DWORD PTR CodeInfo$[rsp+24]
$LN144@ParseLine:

; 3335 :   }
; 3336 :   if (ModuleInfo.CommentDataInCode)

	cmp	BYTE PTR ModuleInfo+423, bpl
	je	SHORT $LN143@ParseLine

; 3337 :     omf_OutSelect(FALSE);

	xor	ecx, ecx
	call	omf_OutSelect
	mov	edi, DWORD PTR i$[rsp]
	mov	ebx, DWORD PTR CodeInfo$[rsp+24]
$LN143@ParseLine:

; 3338 : 
; 3339 :   /* get the instruction's arguments.
; 3340 :    * This loop accepts up to 4 arguments if AVXSUPP is on */
; 3341 :   for (j = 0; j < sizeof(opndx) / sizeof(opndx[0]) && tokenarray[i].token != T_FINAL; j++) {

	xor	r10d, r10d
	mov	QWORD PTR [rsp+656], r14
	lea	rax, QWORD PTR opndx$[rsp+64]
	lea	r12, QWORD PTR opndx$[rsp+72]
	mov	QWORD PTR [rsp+648], r15
	lea	r14, QWORD PTR opndx$[rsp+16]
	mov	QWORD PTR tv2642[rsp], rax
	mov	r9d, r10d
	mov	DWORD PTR j$1$[rsp], r10d
	sub	r12, 208				; 000000d0H
	lea	rbp, QWORD PTR opndx$[rsp+60]
	lea	r13, QWORD PTR opndx$[rsp+72]
	lea	r15, QWORD PTR opndx$[rsp+70]
	jmp	SHORT $LN142@ParseLine
	npad	2
$LL325@ParseLine:
	mov	edi, DWORD PTR i$[rsp]
$LN142@ParseLine:
	movsxd	r8, edi
	shl	r8, 5
	movzx	eax, BYTE PTR [r8+rsi]
	test	al, al
	je	$LN140@ParseLine

; 3342 :     if (j) 

	test	r9d, r9d
	je	$LN327@ParseLine

; 3343 : 	{
; 3344 : 		
; 3345 : 		if (tokenarray[i].token != T_COMMA)

	cmp	al, 44					; 0000002cH
	jne	$LN140@ParseLine

; 3346 : 			break;
; 3347 : 
; 3348 : 		/* inject xmmword ptr to relevant sse instructions */
; 3349 : 		if (Options.masm_compat_gencode && tokenarray[i].token == T_COMMA && (CodeInfo.token == T_SUBPD) ||(CodeInfo.token == T_SUBPS) || (CodeInfo.token == T_ADDPS) ||  (CodeInfo.token == T_ADDPD) || (CodeInfo.token == T_MULPD) || (CodeInfo.token == T_MULPS) || (CodeInfo.token == T_ANDPD) || (CodeInfo.token == T_ANDPS) || (CodeInfo.token == T_MOVAPD) || (CodeInfo.token == T_MOVAPS) || (CodeInfo.token == T_MOVUPS))

	cmp	BYTE PTR Options+137, 0
	je	SHORT $LN135@ParseLine
	cmp	ebx, 877				; 0000036dH
	je	SHORT $LN136@ParseLine
$LN135@ParseLine:
	cmp	ebx, 878				; 0000036eH
	je	SHORT $LN136@ParseLine
	cmp	ebx, 854				; 00000356H
	je	SHORT $LN136@ParseLine
	cmp	ebx, 853				; 00000355H
	je	SHORT $LN136@ParseLine
	cmp	ebx, 869				; 00000365H
	je	SHORT $LN136@ParseLine
	cmp	ebx, 870				; 00000366H
	je	SHORT $LN136@ParseLine
	cmp	ebx, 1014				; 000003f6H
	je	SHORT $LN136@ParseLine
	cmp	ebx, 1015				; 000003f7H
	je	SHORT $LN136@ParseLine
	cmp	ebx, 1048				; 00000418H
	je	SHORT $LN136@ParseLine
	cmp	ebx, 1049				; 00000419H
	je	SHORT $LN136@ParseLine
	cmp	ebx, 1053				; 0000041dH
	jne	$skipxmmsub$7273
$LN136@ParseLine:

; 3350 : 		{
; 3351 : 
; 3352 : 			xmmOver0.tokpos = tokenarray[i].tokpos;

	mov	rax, QWORD PTR [r8+rsi+24]

; 3353 : 			xmmOver1.tokpos = tokenarray[i].tokpos;
; 3354 : 			k = 0;
; 3355 : 			n = ModuleInfo.token_count+1;

	movsxd	rdx, DWORD PTR ModuleInfo+496

; 3356 : 			for (k = 0; k < n-1; k++)

	mov	ecx, r10d
	test	edx, edx
	mov	QWORD PTR xmmOver0+24, rax
	mov	rax, QWORD PTR [r8+rsi+24]
	mov	QWORD PTR xmmOver1+24, rax
	jle	SHORT $LN132@ParseLine

; 3350 : 		{
; 3351 : 
; 3352 : 			xmmOver0.tokpos = tokenarray[i].tokpos;

	lea	rax, QWORD PTR [rsi+48]
	npad	8
$LL134@ParseLine:

; 3357 : 			{
; 3358 : 				if (tokenarray[k].tokval == T_XMMWORD && tokenarray[k + 1].tokval == T_PTR)

	cmp	DWORD PTR [rax-32], 228			; 000000e4H
	jne	SHORT $LN133@ParseLine
	cmp	DWORD PTR [rax], 258			; 00000102H
	je	$skipxmmsub$7273
$LN133@ParseLine:

; 3356 : 			for (k = 0; k < n-1; k++)

	inc	ecx
	add	rax, 32					; 00000020H
	cmp	ecx, edx
	jl	SHORT $LL134@ParseLine
$LN132@ParseLine:

; 3359 : 					goto skipxmmsub;
; 3360 : 			}
; 3361 : 			for (k = n-1; k >= i+1; k--)

	inc	edi
	mov	rcx, rdx
	cmp	edx, edi
	jl	SHORT $LN128@ParseLine
	shl	rcx, 5
	sub	edx, edi
	add	rcx, rsi
	inc	edx
	npad	13
$LL130@ParseLine:

; 3362 : 			{
; 3363 : 				tokenarray[k+2] = tokenarray[k];

	mov	rax, QWORD PTR [rcx]
	sub	rcx, 32					; 00000020H
	dec	rdx
	mov	QWORD PTR [rcx+96], rax
	mov	rax, QWORD PTR [rcx+40]
	mov	QWORD PTR [rcx+104], rax
	mov	rax, QWORD PTR [rcx+48]
	mov	QWORD PTR [rcx+112], rax
	mov	rax, QWORD PTR [rcx+56]
	mov	QWORD PTR [rcx+120], rax
	jne	SHORT $LL130@ParseLine
$LN128@ParseLine:

; 3364 : 			}
; 3365 : 			tokenarray[i + 1] = xmmOver0;

	lea	rdx, OFFSET FLAT:__ImageBase
	mov	rax, QWORD PTR xmmOver0[rdx]
	mov	QWORD PTR [r8+rsi+32], rax
	mov	rax, QWORD PTR xmmOver0[rdx+8]
	mov	QWORD PTR [r8+rsi+40], rax
	mov	rax, QWORD PTR xmmOver0[rdx+16]
	mov	QWORD PTR [r8+rsi+48], rax
	mov	rax, QWORD PTR xmmOver0[rdx+24]
	mov	QWORD PTR [r8+rsi+56], rax

; 3366 : 			tokenarray[i + 2] = xmmOver1;

	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rax, QWORD PTR xmmOver1[rdx]
	add	rcx, 2
	shl	rcx, 5
	mov	QWORD PTR [rcx+rsi], rax
	mov	rax, QWORD PTR xmmOver1[rdx+8]
	mov	QWORD PTR [rcx+rsi+8], rax
	mov	rax, QWORD PTR xmmOver1[rdx+16]
	mov	QWORD PTR [rcx+rsi+16], rax
	mov	rax, QWORD PTR xmmOver1[rdx+24]
	mov	QWORD PTR [rcx+rsi+24], rax

; 3367 : 			ModuleInfo.token_count += 2;

	add	DWORD PTR ModuleInfo+496, 2
	mov	edi, DWORD PTR i$[rsp]
$skipxmmsub$7273:

; 3368 : 		}
; 3369 : 	skipxmmsub:
; 3370 : 		i++;

	inc	edi
	mov	DWORD PTR i$[rsp], edi
$LN327@ParseLine:

; 3371 : 
; 3372 : 
; 3373 :     }
; 3374 : 
; 3375 :     DebugMsg1(("ParseLine(%s): calling EvalOperand, i=%u\n", instr, i));
; 3376 : /*    if (CodeInfo.token == T_SUBPD) __debugbreak();*/
; 3377 :     if (EvalOperand(&i, tokenarray, Token_Count, &opndx[j], 0) == ERROR) {

	mov	r8d, DWORD PTR ModuleInfo+496
	movsxd	rax, r9d
	lea	rcx, QWORD PTR i$[rsp]
	imul	rax, 104				; 00000068H
	lea	rdi, QWORD PTR opndx$[rsp+rax]
	mov	rdx, rsi
	mov	r9, rdi
	mov	BYTE PTR [rsp+32], 0
	call	EvalOperand
	cmp	eax, -1
	je	$LN283@ParseLine

; 3380 :     }
; 3381 : 
; 3382 :     if (j == 2 && (opndx[j].kind == EXPR_REG)){

	mov	r9d, DWORD PTR j$1$[rsp]
	cmp	r9d, 2
	jne	SHORT $LN126@ParseLine
	cmp	DWORD PTR [rbp], r9d
	jne	SHORT $LN126@ParseLine

; 3383 :       regtok = opndx[OPND3].base_reg->tokval;
; 3384 :       CodeInfo.reg3 = GetRegNo(regtok);

	mov	rax, QWORD PTR opndx$[rsp+232]
	movsxd	rcx, DWORD PTR [rax+16]
	lea	rax, QWORD PTR [rcx+rcx*2]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR SpecialTable[rcx+rax*4+10]
	mov	BYTE PTR CodeInfo$[rsp+111], al
$LN126@ParseLine:

; 3385 :     }
; 3386 :     switch (opndx[j].kind) {

	mov	eax, DWORD PTR [rbp]
	cmp	eax, -2
	je	$LN116@ParseLine
	cmp	eax, -1
	je	$LN328@ParseLine
	cmp	eax, 3
	mov	ebx, DWORD PTR CodeInfo$[rsp+24]
	je	SHORT $LN123@ParseLine
	cmp	eax, 5
	je	SHORT $LN122@ParseLine
	mov	rcx, QWORD PTR tv2642[rsp]
	xor	r10d, r10d
	jmp	$LN141@ParseLine
$LN123@ParseLine:

; 3387 :     case EXPR_FLOAT:
; 3388 :       /* v2.06: accept float constants for PUSH */
; 3389 :       if (j == OPND2 || CodeInfo.token == T_PUSH || CodeInfo.token == T_PUSHD) {

	cmp	r9d, 1
	je	SHORT $LN121@ParseLine
	cmp	ebx, 601				; 00000259H
	je	SHORT $LN121@ParseLine
	cmp	ebx, 565				; 00000235H
	je	SHORT $LN121@ParseLine
$LN122@ParseLine:

; 3338 : 
; 3339 :   /* get the instruction's arguments.
; 3340 :    * This loop accepts up to 4 arguments if AVXSUPP is on */
; 3341 :   for (j = 0; j < sizeof(opndx) / sizeof(opndx[0]) && tokenarray[i].token != T_FINAL; j++) {

	add	r13, -104				; ffffffffffffff98H

; 3401 :       }
; 3402 : #if AVXSUPP
; 3403 :  /* here is handled EVEX Static Rounding Mode {sae}, {rn-sae}, {rd-sae}, {ru-sae}, {rz-sae} */
; 3404 :     case EXPR_DECORATOR:
; 3405 :       if (opndx[j - 1].indirect || opndx[j - 2].indirect)

	test	BYTE PTR [r13], 1
	jne	$LN284@ParseLine
	test	BYTE PTR [r12], 1
	jne	$LN284@ParseLine

; 3407 :         CodeInfo.evex_sae = opndx[j].saeflags;

	movzx	eax, BYTE PTR [r15]

; 3408 :         j--;

	mov	rcx, QWORD PTR tv2642[rsp]
	dec	r9d
	sub	r12, 104				; 00000068H
	sub	r15, 104				; 00000068H
	sub	rbp, 104				; 00000068H
	sub	rcx, 104				; 00000068H
	sub	r14, 104				; 00000068H
	mov	BYTE PTR CodeInfo$[rsp+141], al

; 3409 :         break;

	xor	r10d, r10d
	jmp	SHORT $LN141@ParseLine
$LN121@ParseLine:

; 3390 : #if FPIMMEDIATE
; 3391 :         if (Options.strict_masm_compat == FALSE) {

	cmp	BYTE PTR Options+136, 0
	jne	$LN120@ParseLine

; 3392 :           /* convert to REAL4, unless REAL8 coercion is requested */
; 3393 :           atofloat(&opndx[j].fvalue, opndx[j].float_tok->string_ptr, opndx[j].mem_type == MT_REAL8 ? 8 : 4, opndx[j].negative, opndx[j].float_tok->floattype);

	mov	rax, QWORD PTR tv2642[rsp]
	mov	rdx, QWORD PTR [r14]
	mov	r9d, DWORD PTR [r13]
	shr	r9d, 5
	mov	r8d, 4
	mov	rcx, rdi
	and	r9b, 1
	cmp	DWORD PTR [rax], 39			; 00000027H
	mov	eax, 8
	cmove	r8d, eax
	movzx	eax, BYTE PTR [rdx+1]
	mov	rdx, QWORD PTR [rdx+8]
	mov	BYTE PTR [rsp+32], al
	call	atofloat

; 3394 :           opndx[j].kind = EXPR_CONST;
; 3395 :           opndx[j].float_tok = NULL;

	mov	ebx, DWORD PTR CodeInfo$[rsp+24]
	mov	rcx, QWORD PTR tv2642[rsp]
	mov	r9d, DWORD PTR j$1$[rsp]
	xor	r10d, r10d
	mov	QWORD PTR [r14], r10
	mov	DWORD PTR [rbp], r10d
$LN141@ParseLine:
	inc	r9d
	add	rcx, 104				; 00000068H
	add	r12, 104				; 00000068H
	add	r15, 104				; 00000068H
	add	r13, 104				; 00000068H
	add	rbp, 104				; 00000068H
	add	r14, 104				; 00000068H
	cmp	r9d, 4
	mov	DWORD PTR j$1$[rsp], r9d
	mov	QWORD PTR tv2642[rsp], rcx
	jb	$LL325@ParseLine

; 3672 :           if ((CodeInfo.pinstr->first == TRUE)) {

	mov	edi, DWORD PTR i$[rsp]
$LN140@ParseLine:

; 3419 :     }
; 3420 :   }
; 3421 :   if (tokenarray[i].token != T_FINAL) {

	movsxd	rdx, edi
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rsi], 0

; 3422 :     DebugMsg(("ParseLine(%s): too many operands (%s) \n", instr, tokenarray[i].tokpos));
; 3423 :     return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos));

	jne	$LN354@ParseLine

; 3424 :   }
; 3425 :   for (CurrOpnd = 0; CurrOpnd < j && CurrOpnd < MAX_OPND; CurrOpnd++) {

	test	r9d, r9d
	mov	ebp, r10d
	mov	r14d, -1887436800			; ffffffff8f800000H
	je	$LN110@ParseLine
	lea	r12, QWORD PTR opndx$[rsp+24]
	lea	r13, QWORD PTR CodeInfo$[rsp+48]
$LL112@ParseLine:
	cmp	ebp, 3
	jae	$LN338@ParseLine

; 3426 : 
; 3427 :     Frame_Type = FRAME_NONE;
; 3428 :     SegOverride = NULL; /* segreg prefix is stored in RegOverride */
; 3429 :     CodeInfo.opnd[CurrOpnd].data32l = 0;

	mov	DWORD PTR [r13-8], r10d

; 3430 :     CodeInfo.opnd[CurrOpnd].InsFixup = NULL;

	mov	QWORD PTR [r13], r10

; 3431 : #if AVXSUPP
; 3432 :     /* if encoding is VEX and destination op is XMM, YMM or memory,
; 3433 :      * the second argument may be stored in the vexregop field.
; 3434 :      */
; 3435 :     if (CodeInfo.token >= VEX_START &&
; 3436 :       CurrOpnd == OPND2 &&
; 3437 :       (CodeInfo.opnd[OPND1].type & (OP_XMM | OP_YMM | OP_M | OP_M256 | OP_R32 | OP_R64 | OP_K | OP_ZMM | OP_M64 | OP_M512))) {

	movsxd	rbx, DWORD PTR CodeInfo$[rsp+24]
	cmp	ebx, 1304				; 00000518H
	mov	BYTE PTR Frame_Type, 6
	mov	QWORD PTR SegOverride, r10
	jl	$LN344@ParseLine
	cmp	ebp, 1
	jne	$LN345@ParseLine
	test	DWORD PTR CodeInfo$[rsp+32], -1082129940 ; ffffffffbf8001ecH
	je	$LN346@ParseLine

; 3438 :       //CodeInfo.indexreg = 0xff;
; 3439 :       //CodeInfo.basereg = 0xff;
; 3440 : 	    CodeInfo.r1type = 10000000;
; 3441 : 	    CodeInfo.r2type = 10000000;
; 3442 :       if (CodeInfo.token == T_VMOVSD || CodeInfo.token == T_VMOVSS){

	cmp	ebx, 1987				; 000007c3H
	mov	DWORD PTR CodeInfo$[rsp+116], 10000000	; 00989680H
	mov	DWORD PTR CodeInfo$[rsp+120], 10000000	; 00989680H
	je	SHORT $LN107@ParseLine
	cmp	ebx, 1988				; 000007c4H
	jne	SHORT $LN106@ParseLine
$LN107@ParseLine:

; 3443 :           if (opndx[1].kind == EXPR_CONST)

	cmp	DWORD PTR opndx$[rsp+164], 0
	je	$LN285@ParseLine
$LN106@ParseLine:

; 3445 :       if (opndx[OPND1].kind == EXPR_REG){

	cmp	DWORD PTR opndx$[rsp+60], 2
	jne	$LN329@ParseLine

; 3446 :         regtok = opndx[OPND1].base_reg->tokval;

	mov	rdi, QWORD PTR opndx$[rsp+24]

; 3447 :       CodeInfo.reg1 = GetRegNo(regtok);

	movsxd	rax, DWORD PTR [rdi+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rax, OFFSET FLAT:__ImageBase
	movzx	r8d, BYTE PTR SpecialTable[rax+rcx*4+10]

; 3448 :       if (opndx[OPND1].idx_reg) CodeInfo.indexreg = opndx[OPND1].idx_reg->bytval;

	mov	rax, QWORD PTR opndx$[rsp+32]
	test	rax, rax
	mov	BYTE PTR CodeInfo$[rsp+109], r8b
	je	SHORT $LN104@ParseLine
	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR CodeInfo$[rsp+112], al
$LN104@ParseLine:

; 3449 :       if (CodeInfo.reg1 > 15) CodeInfo.evex_flag = TRUE;

	movzx	edx, BYTE PTR CodeInfo$[rsp+136]
	cmp	r8b, 15
	mov	r10d, 1
	cmova	edx, r10d
	mov	BYTE PTR CodeInfo$[rsp+136], dl

; 3450 :       CodeInfo.r1type = GetValueSp(opndx[OPND1].base_reg->tokval);

	mov	eax, DWORD PTR [rdi+16]
	lea	rdi, OFFSET FLAT:__ImageBase
	lea	rcx, QWORD PTR [rax+rax*2]

; 3451 :       if (CodeInfo.r1type == OP_ZMM)CodeInfo.evex_flag = TRUE;

	movzx	edx, dl
	mov	eax, DWORD PTR SpecialTable[rdi+rcx*4]
	cmp	eax, 256				; 00000100H
	mov	DWORD PTR CodeInfo$[rsp+116], eax
	cmove	edx, r10d
	mov	BYTE PTR CodeInfo$[rsp+136], dl
	jmp	SHORT $LN102@ParseLine
$LN283@ParseLine:

; 3378 :       DebugMsg(("ParseLine(%s): EvalOperand() failed\n", instr));
; 3379 :       return(ERROR);

	mov	rax, -1
	jmp	$LN353@ParseLine
$LN284@ParseLine:

; 3406 :         return(EmitError(EMBEDDED_ROUNDING_IS_AVAILABLE_ONLY_WITH_REG_REG_OP));

	mov	ecx, 21
	call	EmitError
	jmp	$LN353@ParseLine
$LN120@ParseLine:

; 3396 :           break;
; 3397 :         }
; 3398 : #endif
; 3399 :         /* Masm message is: real or BCD number not allowed */
; 3400 :         return(EmitError(FP_INITIALIZER_IGNORED));

	mov	ecx, 74					; 0000004aH
	call	EmitError
	jmp	$LN353@ParseLine
$LN116@ParseLine:

; 3410 :       /* fall through */
; 3411 : #endif
; 3412 :     case EXPR_EMPTY:
; 3413 :       if (i == Token_Count)

	mov	eax, DWORD PTR i$[rsp]
	cmp	eax, DWORD PTR ModuleInfo+496
	jne	SHORT $LN115@ParseLine

; 3414 :         i--;  /* v2.08: if there was a terminating comma, display it */

	dec	eax
	mov	DWORD PTR i$[rsp], eax
	jmp	SHORT $LN115@ParseLine
$LN328@ParseLine:
	mov	eax, DWORD PTR i$[rsp]
$LN115@ParseLine:

; 3415 :       /* fall through */
; 3416 :     case EXPR_ERROR:
; 3417 :       DebugMsg(("ParseLine(%s): unexpected operand kind=%d, error, exit\n", instr, opndx[j].kind));
; 3418 :       return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].string_ptr));

	movsxd	rdx, eax
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+8]
	call	EmitErr
	jmp	$LN353@ParseLine
$LN329@ParseLine:

; 3451 :       if (CodeInfo.r1type == OP_ZMM)CodeInfo.evex_flag = TRUE;

	mov	dl, BYTE PTR CodeInfo$[rsp+136]
	lea	rdi, OFFSET FLAT:__ImageBase
	mov	r10d, 1
$LN102@ParseLine:

; 3452 :       }
; 3453 :       if (opndx[OPND2].kind == EXPR_REG){

	cmp	DWORD PTR opndx$[rsp+164], 2
	jne	$LN98@ParseLine

; 3454 :         regtok = opndx[OPND2].base_reg->tokval;

	mov	rdi, QWORD PTR opndx$[rsp+128]

; 3455 :       CodeInfo.reg2 = GetRegNo(regtok);

	movsxd	rax, DWORD PTR [rdi+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rax, OFFSET FLAT:__ImageBase
	movzx	r8d, BYTE PTR SpecialTable[rax+rcx*4+10]

; 3456 :       if (opndx[OPND2].idx_reg) CodeInfo.indexreg = opndx[OPND2].idx_reg->bytval;

	mov	rax, QWORD PTR opndx$[rsp+136]
	test	rax, rax
	mov	BYTE PTR CodeInfo$[rsp+110], r8b
	je	SHORT $LN100@ParseLine
	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR CodeInfo$[rsp+112], al
$LN100@ParseLine:

; 3457 :       if (CodeInfo.reg2 > 15) CodeInfo.evex_flag = TRUE;

	cmp	r8b, 15
	movzx	edx, dl
	cmova	edx, r10d
	mov	BYTE PTR CodeInfo$[rsp+136], dl

; 3458 :        CodeInfo.r2type = GetValueSp(opndx[OPND2].base_reg->tokval);

	mov	eax, DWORD PTR [rdi+16]
	lea	rdi, OFFSET FLAT:__ImageBase
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	eax, DWORD PTR SpecialTable[rdi+rcx*4]

; 3459 :        if (CodeInfo.r2type == OP_ZMM)CodeInfo.evex_flag = TRUE;

	movzx	ecx, dl
	cmp	eax, 256				; 00000100H
	mov	DWORD PTR CodeInfo$[rsp+120], eax
	cmove	ecx, r10d
	mov	BYTE PTR CodeInfo$[rsp+136], cl
$LN98@ParseLine:

; 3460 :        }
; 3461 :       if (((CodeInfo.token == T_ANDN)||(CodeInfo.token == T_MULX)||
; 3462 :         (CodeInfo.token == T_PEXT)||(CodeInfo.token == T_PDEP)) &&
; 3463 :         (CurrOpnd == OPND2 )) goto putinvex;

	cmp	ebx, 1717				; 000006b5H
	je	$putinvex$7314
	cmp	ebx, 1718				; 000006b6H
	je	$putinvex$7314
	cmp	ebx, 1728				; 000006c0H
	je	$putinvex$7314
	cmp	ebx, 1727				; 000006bfH
	je	$putinvex$7314

; 3464 :       if (vex_flags[CodeInfo.token - VEX_START] & VX_NND)

	movzx	edx, BYTE PTR vex_flags[rbx+rdi-1304]
	test	dl, 2
	jne	$LN331@ParseLine

; 3465 :         ;
; 3466 :       else if ((vex_flags[CodeInfo.token - VEX_START] & VX_IMM) &&
; 3467 :         (opndx[OPND3].kind == EXPR_CONST) && (j > 2))

	test	dl, 8
	je	SHORT $LN93@ParseLine
	cmp	DWORD PTR opndx$[rsp+268], 0
	jne	SHORT $LN93@ParseLine
	cmp	r9d, 2
	jg	$LN331@ParseLine
$LN93@ParseLine:

; 3468 :         ;
; 3469 :       else if ((vex_flags[CodeInfo.token - VEX_START] & VX_NMEM) &&
; 3470 :         ((CodeInfo.opnd[OPND1].type & OP_M) ||
; 3471 :         /* v2.11: VMOVSD and VMOVSS always have 2 ops if a memory op is involved */
; 3472 :         ((CodeInfo.token == T_VMOVSD || CodeInfo.token == T_VMOVSS) &&
; 3473 :         (opndx[OPND2].kind != EXPR_REG || opndx[OPND2].indirect == TRUE))))

	test	dl, 16
	je	SHORT $LN91@ParseLine
	test	DWORD PTR CodeInfo$[rsp+32], r14d
	jne	$LN331@ParseLine
	cmp	ebx, 1987				; 000007c3H
	je	SHORT $LN89@ParseLine
	cmp	ebx, 1988				; 000007c4H
	jne	SHORT $LN91@ParseLine
$LN89@ParseLine:
	cmp	DWORD PTR opndx$[rsp+164], 2
	jne	$LN331@ParseLine
	test	BYTE PTR opndx$[rsp+176], 1
	je	SHORT $LN309@ParseLine

; 3474 :          ;
; 3475 :       else {

	jmp	$LN331@ParseLine
$LN91@ParseLine:

; 3476 :         if (opndx[OPND2].kind != EXPR_REG ||
; 3477 :           (!(GetValueSp(opndx[CurrOpnd].base_reg->tokval) & (OP_R32 | OP_R64 |OP_K | OP_XMM | OP_YMM | OP_ZMM)))) {

	cmp	DWORD PTR opndx$[rsp+164], 2
	jne	SHORT $LN85@ParseLine
$LN309@ParseLine:
	mov	rax, QWORD PTR [r12]
	mov	ecx, DWORD PTR [rax+16]
	lea	rax, QWORD PTR [rcx+rcx*2]
	test	DWORD PTR SpecialTable[rdi+rax*4], 492	; 000001ecH
	jne	SHORT $LN84@ParseLine
$LN85@ParseLine:

; 3478 :           DebugMsg(("ParseLine(%s,%u): avx invalid operand, op2.kind=%u\n", instr, CurrOpnd, opndx[OPND2].kind));
; 3479 :           if ((CodeInfo.token < T_KMOVB) && (CodeInfo.token > T_KMOVW))

	cmp	ebx, 1773				; 000006edH
	jge	SHORT $LN84@ParseLine
	cmp	ebx, 1776				; 000006f0H
	jg	$LN285@ParseLine
$LN84@ParseLine:

; 3480 :             return(EmitErr(INVALID_INSTRUCTION_OPERANDS));
; 3481 :         }
; 3482 :         /* fixme: check if there's an operand behind OPND2 at all!
; 3483 :          * if no, there's no point to continue with switch (opndx[].kind).
; 3484 :          * v2.11: additional check for j <= 2 added
; 3485 :          */
; 3486 :         if (j <= 2) {

	cmp	r9d, 2
	jle	$LN330@ParseLine

; 3487 :           DebugMsg(("ParseLine(%s,%u): avx not enough operands (%u)\n", instr, CurrOpnd, opndx[OPND2].kind, j));
; 3488 :           /* v2.11: next line should be activated - currently the error is emitted below as syntax error */
; 3489 :           //return( EmitErr( INVALID_INSTRUCTION_OPERANDS ) );
; 3490 :         }
; 3491 :         else
; 3492 : 
; 3493 : 		  /* flag VX_DST is set if an immediate is expected as operand 3 */
; 3494 : 			if ((vex_flags[CodeInfo.token - VEX_START] & VX_DST) &&
; 3495 : 				(opndx[OPND3].kind == EXPR_CONST)) {

	test	dl, 4
	je	$LN81@ParseLine
	cmp	DWORD PTR opndx$[rsp+268], 0
	jne	$LN81@ParseLine

; 3496 : 				DebugMsg1(("ParseLine(%s,%u): avx VX_DST, op3.kind=CONST (value=%u), numops=%u\n", instr, CurrOpnd, opndx[OPND3].kind, opndx[OPND3].value, j));
; 3497 : 				if (opndx[OPND2].idx_reg)

	mov	rax, QWORD PTR opndx$[rsp+136]
	test	rax, rax
	je	SHORT $LN80@ParseLine

; 3498 : 					CodeInfo.indexreg = opndx[OPND2].idx_reg->bytval;

	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR CodeInfo$[rsp+112], al
$LN80@ParseLine:

; 3499 : 				if (opndx[OPND2].base_reg)

	mov	rax, QWORD PTR opndx$[rsp+128]
	test	rax, rax
	je	SHORT $LN79@ParseLine

; 3500 : 					CodeInfo.basereg = opndx[OPND2].base_reg->bytval;

	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR CodeInfo$[rsp+113], al
$LN79@ParseLine:

; 3501 : 				/* third operand data goes in CodeInfo.vexconst used in codegen.c */
; 3502 : 				CodeInfo.vexconst = opndx[CurrOpnd].value;

	mov	eax, DWORD PTR [r12-24]
	lea	rdx, QWORD PTR [r12-24]
	mov	DWORD PTR CodeInfo$[rsp+124], eax

; 3503 : 				if (opndx[OPND1].base_reg) {

	mov	rax, QWORD PTR opndx$[rsp+24]
	test	rax, rax
	je	$LN330@ParseLine

; 3504 : 					/* first operand register is moved to vexregop */
; 3505 : 					/* handle VEX.NDD */
; 3506 : 					CodeInfo.vexregop = opndx[OPND1].base_reg->bytval + 1;

	movzx	eax, BYTE PTR [rax+1]

; 3507 : 					memcpy(&opndx[OPND1], &opndx[CurrOpnd], sizeof(opndx[0]) * 3);

	lea	rcx, QWORD PTR opndx$[rsp]
	mov	r8d, 312				; 00000138H
	inc	al
	mov	BYTE PTR CodeInfo$[rsp+128], al
	call	memcpy

; 3508 : 					CodeInfo.rm_byte = 0;
; 3509 : 					if (process_register(&CodeInfo, OPND1, opndx) == ERROR)

	lea	r8, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	xor	edx, edx
	mov	BYTE PTR CodeInfo$[rsp+104], 0
	call	process_register
	cmp	eax, -1
	je	$LN283@ParseLine

; 3510 : 						return(ERROR);
; 3511 : 				}

	mov	r9d, DWORD PTR j$1$[rsp]
	mov	ebx, DWORD PTR CodeInfo$[rsp+24]

; 3545 :           }
; 3546 :           j--;

	dec	r9d
	mov	DWORD PTR j$1$[rsp], r9d
	jmp	$LN331@ParseLine
$LN81@ParseLine:

; 3512 : 			}
; 3513 : 
; 3514 :           else if (CodeInfo.token < T_VGETMANTPD || CodeInfo.token > T_VGETMANTPS ) {

	lea	eax, DWORD PTR [rbx-1470]
	cmp	eax, 1
	ja	SHORT $LN74@ParseLine

; 3540 :           }
; 3541 :           else
; 3542 :           {
; 3543 :             CodeInfo.vexconst = opndx[CurrOpnd + 1].value;

	mov	eax, DWORD PTR [r12+80]

; 3544 :             j++;

	inc	r9d

; 3545 :           }
; 3546 :           j--;

	dec	r9d
	mov	DWORD PTR CodeInfo$[rsp+124], eax
	mov	DWORD PTR j$1$[rsp], r9d
	jmp	$LN331@ParseLine
$LN74@ParseLine:

; 3515 :             unsigned flags = GetValueSp(opndx[CurrOpnd].base_reg->tokval);

	mov	rax, QWORD PTR [r12]
	mov	ecx, DWORD PTR [rax+16]
	lea	rax, QWORD PTR [rcx+rcx*2]
	mov	ecx, DWORD PTR SpecialTable[rdi+rax*4]

; 3516 :             //CodeInfo.rtype = GetValueSp(opndx[CurrOpnd].base_reg->tokval);
; 3517 :             DebugMsg1(("ParseLine(%s,%u): opnd2 is avx reg (%s), flags=%X ci.type[0]=%X numops=%u\n",
; 3518 :               instr, CurrOpnd, opndx[CurrOpnd].base_reg->string_ptr, flags, CodeInfo.opnd[OPND1].type, j));
; 3519 : //#if 1
; 3520 :             /* v2.08: no error here if first op is an untyped memory reference
; 3521 :              * note that OP_M includes OP_M128, but not OP_M256 (to be fixed?)
; 3522 :              */
; 3523 :             if (CodeInfo.opnd[OPND1].type == OP_M)

	mov	eax, DWORD PTR CodeInfo$[rsp+32]
	cmp	eax, r14d
	je	SHORT $putinvex$7314

; 3524 :               ; else
; 3525 : //#endif
; 3526 :               if ((flags & (OP_XMM | OP_M128)) &&
; 3527 :                 (CodeInfo.opnd[OPND1].type & (OP_YMM | OP_M256)) ||
; 3528 :                 (flags & (OP_YMM | OP_M256)) &&
; 3529 :                 (CodeInfo.opnd[OPND1].type & (OP_XMM | OP_M128))) {

	test	ecx, 134217760				; 08000020H
	je	SHORT $LN69@ParseLine
	test	eax, 268435584				; 10000080H
	jne	$LN285@ParseLine
$LN69@ParseLine:
	test	ecx, 268435584				; 10000080H
	je	SHORT $putinvex$7314
	test	DWORD PTR CodeInfo$[rsp+32], 134217760	; 08000020H
	jne	$LN285@ParseLine
$putinvex$7314:

; 3530 :                 DebugMsg(("ParseLine(%s,%u): avx invalid opnd 2, flags=%X ci.type[0]=%X\n", instr, CurrOpnd, flags, CodeInfo.opnd[OPND1].type));
; 3531 :                 return(EmitErr(INVALID_INSTRUCTION_OPERANDS));
; 3532 :               }
; 3533 :             /* second operand register is moved to vexregop */
; 3534 :             /* to be fixed: CurrOpnd is always OPND2, so use this const here */
; 3535 :             //CodeInfo.vexdata is containing I_U8 data of EXPR_CONST ,habran
; 3536 :        putinvex:
; 3537 :             CodeInfo.vexconst = opndx[CurrOpnd].value;

	mov	eax, DWORD PTR [r12-24]
	lea	rcx, QWORD PTR [r12-24]

; 3538 :             CodeInfo.vexregop = opndx[CurrOpnd].base_reg->bytval + 1;
; 3539 :             memcpy(&opndx[CurrOpnd], &opndx[CurrOpnd + 1], sizeof(opndx[0]) * 2);

	mov	r8d, 208				; 000000d0H
	mov	DWORD PTR CodeInfo$[rsp+124], eax
	mov	rax, QWORD PTR [r12]
	movzx	edx, BYTE PTR [rax+1]
	inc	dl
	mov	BYTE PTR CodeInfo$[rsp+128], dl
	lea	rdx, QWORD PTR [r12+80]
	call	memcpy
	mov	r9d, DWORD PTR j$1$[rsp]
$LN330@ParseLine:

; 3545 :           }
; 3546 :           j--;

	dec	r9d
	mov	DWORD PTR j$1$[rsp], r9d
	jmp	SHORT $LN331@ParseLine
$LN344@ParseLine:

; 3380 :     }
; 3381 : 
; 3382 :     if (j == 2 && (opndx[j].kind == EXPR_REG)){

	lea	rdi, OFFSET FLAT:__ImageBase
	jmp	SHORT $LN331@ParseLine
$LN345@ParseLine:

; 3545 :           }
; 3546 :           j--;

	lea	rdi, OFFSET FLAT:__ImageBase
	jmp	SHORT $LN331@ParseLine
$LN346@ParseLine:
	lea	rdi, OFFSET FLAT:__ImageBase
$LN331@ParseLine:

; 3547 :       }
; 3548 :     }
; 3549 : #endif
; 3550 :     DebugMsg1(("ParseLine(%s,%u): type/value/mem_type/ofssize=%Xh/%" I64_SPEC "Xh/%Xh/%d\n", instr, CurrOpnd, opndx[CurrOpnd].kind, opndx[CurrOpnd].value64, opndx[CurrOpnd].mem_type, opndx[CurrOpnd].Ofssize));
; 3551 :     switch (opndx[CurrOpnd].kind) {

	mov	ecx, DWORD PTR [r12+36]
	test	ecx, ecx
	je	$LN62@ParseLine
	dec	ecx
	je	$LN64@ParseLine
	dec	ecx
	je	SHORT $LN60@ParseLine
	sub	ecx, 3
	jne	$LN111@ParseLine

; 3552 :     case EXPR_DECORATOR:
; 3553 :       CodeInfo.evex_sae = opndx[CurrOpnd].saeflags;
; 3554 :       return( codegen( &CodeInfo, oldofs ) );

	mov	edx, DWORD PTR oldofs$1$[rsp]
	mov	eax, ebp
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	imul	rax, 104				; 00000068H
	movzx	eax, BYTE PTR opndx$[rsp+rax+70]
	mov	BYTE PTR CodeInfo$[rsp+141], al
	call	codegen
	jmp	$LN353@ParseLine
$LN60@ParseLine:

; 3564 :       break;
; 3565 :     case EXPR_REG:
; 3566 :       DebugMsg1(("ParseLine(%s,%u): type REG\n", instr, CurrOpnd));
; 3567 :       if (opndx[CurrOpnd].indirect) { /* indirect operand ( "[EBX+...]" )? */

	test	BYTE PTR [r12+48], 1
	je	SHORT $LN59@ParseLine

; 3568 :         if (process_address(&CodeInfo, CurrOpnd, &opndx[CurrOpnd]) == ERROR)

	mov	eax, ebp
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, ebp
	imul	rax, 104				; 00000068H
	lea	r8, QWORD PTR opndx$[rsp+rax]
	call	process_address
	cmp	eax, -1
	je	$LN283@ParseLine

; 3569 :           return(ERROR);
; 3570 :       }
; 3571 :       else {

	mov	ebx, DWORD PTR CodeInfo$[rsp+24]
	mov	r9d, DWORD PTR j$1$[rsp]
	jmp	$LN111@ParseLine
$LN59@ParseLine:

; 3572 :         /* process_register() can't handle 3rd operand */
; 3573 :         if (!CodeInfo.vexregop){

	cmp	BYTE PTR CodeInfo$[rsp+128], 0
	jne	$LN51@ParseLine

; 3574 :           if (CurrOpnd == OPND1){

	test	ebp, ebp
	jne	SHORT $LN55@ParseLine

; 3575 :             regtok = opndx[OPND1].base_reg->tokval;
; 3576 :             CodeInfo.reg1 = GetRegNo(regtok);

	mov	rax, QWORD PTR opndx$[rsp+24]
	movsxd	rcx, DWORD PTR [rax+16]
	lea	rax, QWORD PTR [rcx+rcx*2]
	movzx	eax, BYTE PTR SpecialTable[rdi+rax*4+10]

; 3577 :             if (CodeInfo.reg1 > 15) CodeInfo.evex_flag = TRUE;

	cmp	al, 15
	mov	BYTE PTR CodeInfo$[rsp+109], al
	jbe	SHORT $LN50@ParseLine
	mov	BYTE PTR CodeInfo$[rsp+136], 1
$LN50@ParseLine:

; 3591 :         }
; 3592 :         else if (process_register(&CodeInfo, CurrOpnd, opndx) == ERROR)

	lea	r8, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, ebp
	call	process_register
	cmp	eax, -1
	je	$LN283@ParseLine

; 3593 :           return(ERROR);
; 3594 :       }
; 3595 :       break;

	mov	ebx, DWORD PTR CodeInfo$[rsp+24]
	mov	r9d, DWORD PTR j$1$[rsp]
	jmp	$LN111@ParseLine
$LN55@ParseLine:

; 3578 :           }
; 3579 :           else if (CurrOpnd == OPND2){

	cmp	ebp, 1
	jne	SHORT $LN51@ParseLine

; 3580 :             regtok = opndx[OPND2].base_reg->tokval;
; 3581 :             CodeInfo.reg2 = GetRegNo(regtok);

	mov	rax, QWORD PTR opndx$[rsp+128]
	movsxd	rcx, DWORD PTR [rax+16]
	lea	rax, QWORD PTR [rcx+rcx*2]
	movzx	eax, BYTE PTR SpecialTable[rdi+rax*4+10]

; 3582 :             if (CodeInfo.reg2 > 15) CodeInfo.evex_flag = TRUE;

	cmp	al, 15
	mov	BYTE PTR CodeInfo$[rsp+110], al
	jbe	SHORT $LN50@ParseLine
	mov	BYTE PTR CodeInfo$[rsp+136], bpl

; 3583 :           }
; 3584 :         }
; 3585 :         if (CurrOpnd == OPND3) {

	jmp	SHORT $LN50@ParseLine
$LN51@ParseLine:
	cmp	ebp, 2
	jne	SHORT $LN50@ParseLine

; 3586 :           CodeInfo.opnd[OPND3].type = GetValueSp(opndx[OPND3].base_reg->tokval);

	mov	rdx, QWORD PTR opndx$[rsp+232]
	mov	eax, DWORD PTR [rdx+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	eax, DWORD PTR SpecialTable[rdi+rcx*4]
	mov	DWORD PTR CodeInfo$[rsp+80], eax

; 3587 :           CodeInfo.opnd[OPND3].data32l = opndx[OPND3].base_reg->bytval;

	movzx	eax, BYTE PTR [rdx+1]
	mov	DWORD PTR CodeInfo$[rsp+88], eax

; 3588 :           regtok = opndx[OPND3].base_reg->tokval;
; 3589 :           CodeInfo.reg3 = GetRegNo(regtok);

	movsxd	rax, DWORD PTR [rdx+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR SpecialTable[rdi+rcx*4+10]

; 3590 :           if (CodeInfo.reg3 > 15) CodeInfo.evex_flag = TRUE;

	cmp	al, 15
	mov	BYTE PTR CodeInfo$[rsp+111], al
	jbe	$LN111@ParseLine
	mov	BYTE PTR CodeInfo$[rsp+136], 1

; 3591 :         }
; 3592 :         else if (process_register(&CodeInfo, CurrOpnd, opndx) == ERROR)

	jmp	$LN111@ParseLine
$LN64@ParseLine:

; 3555 :     case EXPR_ADDR:
; 3556 :       DebugMsg1(("ParseLine(%s,%u): type ADDRESS\n", instr, CurrOpnd));
; 3557 :       if (process_address(&CodeInfo, CurrOpnd, &opndx[CurrOpnd]) == ERROR)

	mov	eax, ebp
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, ebp
	imul	rax, 104				; 00000068H
	lea	r8, QWORD PTR opndx$[rsp+rax]
	call	process_address
	cmp	eax, -1
	je	$LN283@ParseLine

; 3558 :         return(ERROR);
; 3559 :       break;

	mov	ebx, DWORD PTR CodeInfo$[rsp+24]
	mov	r9d, DWORD PTR j$1$[rsp]
	jmp	SHORT $LN111@ParseLine
$LN62@ParseLine:

; 3560 :     case EXPR_CONST:
; 3561 :       DebugMsg1(("ParseLine(%s,%u): type CONST, opndx.memtype=%Xh\n", instr, CurrOpnd, opndx[CurrOpnd].mem_type));
; 3562 :       if (process_const(&CodeInfo, CurrOpnd, &opndx[CurrOpnd]) == ERROR)

	mov	rax, QWORD PTR [r12-8]
	test	rax, rax
	je	SHORT $LN269@ParseLine
	cmp	DWORD PTR [rax+16], 0
	jne	SHORT $LN269@ParseLine
	mov	ecx, 163				; 000000a3H
	call	EmitError
	jmp	SHORT $LN270@ParseLine
$LN269@ParseLine:
	mov	rax, QWORD PTR CodeInfo$[rsp+16]
	movzx	ecx, BYTE PTR [rax+12]
	and	cl, 247					; 000000f7H
	cmp	cl, 194					; 000000c2H
	jne	SHORT $LN268@ParseLine
	test	ebp, ebp
	jne	SHORT $LN268@ParseLine
	cmp	DWORD PTR [r12-24], ebp
	je	SHORT $LN111@ParseLine
$LN268@ParseLine:
	lea	r8, QWORD PTR [r12-24]
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	mov	edx, ebp
	call	idata_nofixup
$LN270@ParseLine:
	cmp	eax, -1
	je	$LN283@ParseLine
	mov	ebx, DWORD PTR CodeInfo$[rsp+24]
	mov	r9d, DWORD PTR j$1$[rsp]
$LN111@ParseLine:
	inc	ebp
	add	r13, 24
	add	r12, 104				; 00000068H
	cmp	ebp, r9d
	mov	r10d, 0
	jb	$LL112@ParseLine

; 3672 :           if ((CodeInfo.pinstr->first == TRUE)) {

	mov	edi, DWORD PTR i$[rsp]
	jmp	SHORT $LN110@ParseLine
$LN285@ParseLine:

; 3444 :           return(EmitErr(INVALID_INSTRUCTION_OPERANDS));       }

	mov	ecx, 49					; 00000031H
	call	EmitErr
	jmp	$LN353@ParseLine
$LN338@ParseLine:

; 3563 :         return(ERROR);

	mov	edi, DWORD PTR i$[rsp]
$LN110@ParseLine:

; 3596 :     }
; 3597 :    } /* end for */
; 3598 : 
; 3599 : #if AVXSUPP
; 3600 : 	 /* 4 arguments are valid vor AVX only */
; 3601 :    if (CurrOpnd != j) {

	cmp	ebp, r9d
	je	SHORT $LN40@ParseLine

; 3602 : 	   for (; tokenarray[i].token != T_COMMA; i--);

	movsxd	rax, edi
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 44			; 0000002cH
	je	SHORT $LN43@ParseLine
	npad	2
$LL45@ParseLine:
	dec	edi
	movsxd	rax, edi
	mov	DWORD PTR i$[rsp], edi
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 44			; 0000002cH
	jne	SHORT $LL45@ParseLine
$LN43@ParseLine:

; 3603 : 	   DebugMsg(("ParseLine(%s): CurrOpnd != j ( %u - %u ) >%s<\n", instr, CurrOpnd, j, tokenarray[i].tokpos));
; 3604 : 	   if (CodeInfo.token < VEX_START)

	cmp	ebx, 1304				; 00000518H

; 3605 : 		   return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos));

	jl	$LN15@ParseLine

; 3606 : 	   else
; 3607 : 		   if ((CodeInfo.token == T_VMASKMOVPS || CodeInfo.token == T_VMASKMOVPD) && (j < 3))

	cmp	ebx, 1336				; 00000538H
	je	SHORT $LN39@ParseLine
	cmp	ebx, 1337				; 00000539H
	jne	SHORT $LN40@ParseLine
$LN39@ParseLine:
	cmp	r9d, 3
	jge	SHORT $LN40@ParseLine
$LN355@ParseLine:

; 3608 : 			   return(EmitErr(MISSING_OPERATOR_IN_EXPRESSION));

	mov	ecx, 150				; 00000096H
	call	EmitErr
	jmp	$LN353@ParseLine
$LN40@ParseLine:

; 3609 :    }
; 3610 :    if (CodeInfo.token == T_VBLENDVPS || CodeInfo.token == T_VBLENDVPD) {

	cmp	ebx, 1325				; 0000052dH
	je	SHORT $LN37@ParseLine
	cmp	ebx, 1324				; 0000052cH
	jne	SHORT $LN36@ParseLine
$LN37@ParseLine:

; 3611 : 	   DebugMsg(("ParseLine(%s): ( %u - %u ) >%s<\n", instr, CurrOpnd, j, tokenarray[i].tokpos));
; 3612 : 	   if (CodeInfo.opnd[OPND3].type == OP_NONE) {

	cmp	DWORD PTR CodeInfo$[rsp+80], 0

; 3613 : 		   return (EmitErr(MISSING_OPERATOR_IN_EXPRESSION));

	je	SHORT $LN355@ParseLine
$LN36@ParseLine:

; 3614 : 	   }
; 3615 :    }
; 3616 : 
; 3617 : #endif
; 3618 : 
; 3619 :   /* for FAR calls/jmps some special handling is required:
; 3620 :    * in the instruction tables, the "far" entries are located BEHIND
; 3621 :    * the "near" entries, that's why it's needed to skip all items
; 3622 :    * until the next "first" item is found.
; 3623 :    */
; 3624 :   if (CodeInfo.isfar) {

	movzx	ecx, BYTE PTR CodeInfo$[rsp+142]
	test	cl, 4
	je	SHORT $LN30@ParseLine

; 3625 :     if (CodeInfo.token == T_CALL || CodeInfo.token == T_JMP) {

	cmp	ebx, 455				; 000001c7H
	je	SHORT $LL32@ParseLine
	cmp	ebx, 456				; 000001c8H
	jne	SHORT $LN30@ParseLine
	npad	5
$LL32@ParseLine:

; 3626 :       do {
; 3627 :         CodeInfo.pinstr++;

	mov	rax, QWORD PTR CodeInfo$[rsp+16]
	add	rax, 14
	mov	QWORD PTR CodeInfo$[rsp+16], rax

; 3628 :       } while (CodeInfo.pinstr->first == FALSE);

	cmp	BYTE PTR [rax+4], 0
	je	SHORT $LL32@ParseLine
$LN30@ParseLine:

; 3629 :     }
; 3630 :   }
; 3631 :   /* special handling for string instructions */
; 3632 : 
; 3633 :   if (CodeInfo.pinstr->allowed_prefix == AP_REP ||
; 3634 :     CodeInfo.pinstr->allowed_prefix == AP_REPxx) {

	mov	rax, QWORD PTR CodeInfo$[rsp+16]
	movzx	edx, WORD PTR [rax+2]
	cmp	dx, 2
	je	$LN28@ParseLine
	cmp	dx, 3
	je	$LN28@ParseLine

; 3636 : #if SVMSUPP /* v2.09, not active because a bit too hackish yet - it "works", though. */
; 3637 :   } else if ( CodeInfo.token >= T_VMRUN && CodeInfo.token <= T_INVLPGA && CodeInfo.pinstr->opclsidx ) {
; 3638 :     /* the size of the first operand is to trigger the address size byte 67h,
; 3639 :      * not the operand size byte 66h!
; 3640 :      */
; 3641 :     CodeInfo.prefix.adrsiz = CodeInfo.prefix.opsiz;
; 3642 :     CodeInfo.prefix.opsiz = 0;
; 3643 :     /* the first op must be EAX/AX or RAX/EAX. The operand class
; 3644 :      * used in the instruction table is OP_A ( which is AL/AX/EAX/RAX ).
; 3645 :      */
; 3646 :     if ( ( CodeInfo.opnd[OPND1].type & ( CodeInfo.Ofssize == USE64 ? OP_R64 | OP_R32 : OP_R32 | OP_R16 ) ) == 0 ) {
; 3647 :       DebugMsg(("ParseLine(%s): opnd1 unexpected type=%X\n", instr, CodeInfo.opnd[OPND1].type ));
; 3648 :       return( EmitErr( INVALID_INSTRUCTION_OPERANDS ) );
; 3649 :     }
; 3650 :     /* the INVLPGA instruction has a fix second operand (=ECX). However, there's no
; 3651 :      * operand class for ECX alone. So it has to be ensured here that the register IS ecx.
; 3652 :      */
; 3653 :     if ( CodeInfo.token == T_INVLPGA )
; 3654 :       if ( ( CodeInfo.rm_byte & BIT_345 ) != ( 1 << 3 ) ) { /* ECX is register 1 */
; 3655 :         DebugMsg(("ParseLine(%s): opnd2 is not ecx\n", instr ));
; 3656 :         return( EmitErr( INVALID_INSTRUCTION_OPERANDS ) );
; 3657 :       }
; 3658 : #endif
; 3659 :   }
; 3660 :   else {
; 3661 :     if (CurrOpnd > 1) {

	cmp	ebp, 1
	jbe	$LN10@ParseLine

; 3662 :       /* v1.96: check if a third argument is ok */
; 3663 :       if (CurrOpnd > 2) {

	cmp	ebp, 2
	jbe	SHORT $LN22@ParseLine

; 3664 :         do {
; 3665 :           //if ( CodeInfo.pinstr->opnd_type_3rd != OP3_NONE )
; 3666 :           if ((opnd_clstab[CodeInfo.pinstr->opclsidx].opnd_type_3rd != OP3_NONE) ||
; 3667 :             (opndx[CurrOpnd].kind == EXPR_DECORATOR)){

	movzx	eax, BYTE PTR [rax]
	lea	r8, OFFSET FLAT:__ImageBase
	movsxd	rdx, ebp
	lea	rcx, QWORD PTR [rax+rax*2]
	cmp	BYTE PTR opnd_clstab[r8+rcx*4+8], 0
	jne	SHORT $LN20@ParseLine
	imul	rdx, 104				; 00000068H
	mov	edx, DWORD PTR opndx$[rsp+rdx+60]
$LL24@ParseLine:
	cmp	edx, 5
	je	SHORT $LN20@ParseLine

; 3669 :             break;
; 3670 :           }
; 3671 :           CodeInfo.pinstr++;           //work here for {sae}

	mov	rax, QWORD PTR CodeInfo$[rsp+16]
	add	rax, 14
	mov	QWORD PTR CodeInfo$[rsp+16], rax

; 3672 :           if ((CodeInfo.pinstr->first == TRUE)) {

	cmp	BYTE PTR [rax+4], 1
	je	$LN293@ParseLine
	movzx	eax, BYTE PTR [rax]
	lea	rcx, QWORD PTR [rax+rax*2]
	cmp	BYTE PTR opnd_clstab[r8+rcx*4+8], 0
	je	SHORT $LL24@ParseLine
$LN20@ParseLine:

; 3668 :             if (opndx[CurrOpnd].kind == EXPR_DECORATOR)CodeInfo.evex_sae = opndx[CurrOpnd].saeflags;

	mov	eax, ebp
	imul	rax, 104				; 00000068H
	cmp	DWORD PTR opndx$[rsp+rax+60], 5
	jne	SHORT $LN22@ParseLine
	movzx	eax, BYTE PTR opndx$[rsp+rax+70]
	mov	BYTE PTR CodeInfo$[rsp+141], al
$LN22@ParseLine:

; 3676 :           }
; 3677 :         } while (1);
; 3678 :       }
; 3679 :       /* v2.06: moved here from process_const() */
; 3680 :       if (CodeInfo.token == T_IMUL) {

	cmp	ebx, 621				; 0000026dH
	jne	$LN11@ParseLine

; 3681 :         /* the 2-operand form with an immediate as second op
; 3682 :          * is actually a 3-operand form. That's why the rm byte
; 3683 :          * has to be adjusted. */
; 3684 :         if (CodeInfo.opnd[OPND3].type == OP_NONE && (CodeInfo.opnd[OPND2].type & OP_I)) {

	cmp	DWORD PTR CodeInfo$[rsp+80], 0
	jne	$LN304@ParseLine
	test	DWORD PTR CodeInfo$[rsp+56], 917504	; 000e0000H
	je	$LN11@ParseLine

; 3685 : #if AMD64_SUPPORT
; 3686 :           CodeInfo.prefix.rex |= ((CodeInfo.prefix.rex & REX_B) ? REX_R : 0);

	movzx	ecx, BYTE PTR CodeInfo$[rsp+8]
	movzx	eax, cl
	and	al, 1
	shl	al, 2
	or	cl, al
	mov	BYTE PTR CodeInfo$[rsp+8], cl

; 3687 : #endif
; 3688 :           CodeInfo.rm_byte = (CodeInfo.rm_byte & ~BIT_345) | ((CodeInfo.rm_byte & BIT_012) << 3);

	movzx	ecx, BYTE PTR CodeInfo$[rsp+104]
	movzx	eax, cl
	shl	al, 3
	xor	al, cl
	and	al, 56					; 00000038H
	xor	cl, al
	mov	BYTE PTR CodeInfo$[rsp+104], cl

; 3689 :         }
; 3690 :         else if ((CodeInfo.opnd[OPND3].type != OP_NONE) &&

	jmp	SHORT $LN11@ParseLine
$LN293@ParseLine:

; 3673 :             DebugMsg(("ParseLine(%s): no third operand expected\n", instr));
; 3674 :             for (; tokenarray[i].token != T_COMMA; i--);

	movsxd	rax, edi
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 44			; 0000002cH
	je	SHORT $LN15@ParseLine
	npad	7
$LL17@ParseLine:
	dec	edi
	movsxd	rax, edi
	mov	DWORD PTR i$[rsp], edi
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 44			; 0000002cH
	jne	SHORT $LL17@ParseLine
$LN15@ParseLine:

; 3675 :             return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos));

	movsxd	rdx, edi
	shl	rdx, 5
$LN354@ParseLine:
	mov	rdx, QWORD PTR [rdx+rsi+24]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN353@ParseLine
$LN304@ParseLine:

; 3691 :           (CodeInfo.opnd[OPND2].type & OP_I) &&
; 3692 :           CodeInfo.opnd[OPND2].InsFixup &&
; 3693 :           CodeInfo.opnd[OPND2].InsFixup->sym->state == SYM_UNDEFINED)

	mov	ecx, DWORD PTR CodeInfo$[rsp+56]
	test	ecx, 917504				; 000e0000H
	je	SHORT $LN11@ParseLine
	mov	rax, QWORD PTR CodeInfo$[rsp+72]
	test	rax, rax
	je	SHORT $LN11@ParseLine
	mov	rax, QWORD PTR [rax+56]
	cmp	DWORD PTR [rax+40], 0
	cmove	ecx, r14d
	mov	DWORD PTR CodeInfo$[rsp+56], ecx
$LN11@ParseLine:

; 3694 :           CodeInfo.opnd[OPND2].type = OP_M;
; 3695 :       }
; 3696 :       if (check_size(&CodeInfo, opndx) == ERROR) {

	lea	rdx, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	call	check_size
	cmp	eax, -1

; 3697 :         DebugMsg(("ParseLine(%s): check_size() failed, exit\n", instr));
; 3698 :         return(ERROR);

	je	$LN283@ParseLine
	mov	cl, BYTE PTR CodeInfo$[rsp+142]
	mov	ebx, DWORD PTR CodeInfo$[rsp+24]
$LN10@ParseLine:

; 3699 :       }
; 3700 :     }
; 3701 : #if AMD64_SUPPORT
; 3702 :     if (CodeInfo.Ofssize == USE64) {

	cmp	BYTE PTR CodeInfo$[rsp+106], 2
	jne	$LN6@ParseLine

; 3703 : 
; 3704 :       //if ( CodeInfo.x86hi_used && ( CodeInfo.x64lo_used || CodeInfo.prefix.rex & 7 ))
; 3705 :       if (CodeInfo.x86hi_used && CodeInfo.prefix.rex)

	test	cl, 16
	je	SHORT $LN340@ParseLine
	movzx	eax, BYTE PTR CodeInfo$[rsp+8]
	test	al, al
	je	SHORT $LN8@ParseLine

; 3706 :         EmitError(INVALID_USAGE_OF_AHBHCHDH);

	mov	ecx, 254				; 000000feH
	call	EmitError
	mov	ebx, DWORD PTR CodeInfo$[rsp+24]
	mov	al, BYTE PTR CodeInfo$[rsp+8]
	jmp	SHORT $LN8@ParseLine
$LN340@ParseLine:
	mov	al, BYTE PTR CodeInfo$[rsp+8]
$LN8@ParseLine:

; 3707 : 
; 3708 :       /* for some instructions, the "wide" flag has to be removed selectively.
; 3709 :        * this is to be improved - by a new flag in struct instr_item.
; 3710 :        */
; 3711 :       switch (CodeInfo.token) {

	cmp	ebx, 606				; 0000025eH
	jg	SHORT $LN258@ParseLine
	cmp	ebx, 606				; 0000025eH
	je	SHORT $LN3@ParseLine
	cmp	ebx, 455				; 000001c7H
	jl	SHORT $LN6@ParseLine
	cmp	ebx, 456				; 000001c8H
	jle	SHORT $LN4@ParseLine
	cmp	ebx, 600				; 00000258H
	jle	SHORT $LN6@ParseLine
	cmp	ebx, 602				; 0000025aH
	jg	SHORT $LN6@ParseLine

; 3712 :       case T_PUSH:
; 3713 :       case T_POP:
; 3714 :         /* v2.06: REX.W prefix is always 0, because size is either 2 or 8 */
; 3715 :         //if ( CodeInfo.opnd_type[OPND1] & OP_R64 )
; 3716 :         CodeInfo.prefix.rex &= 0x7;

	and	al, 7
	mov	BYTE PTR CodeInfo$[rsp+8], al

; 3717 :         break;

	jmp	SHORT $LN6@ParseLine
$LN3@ParseLine:

; 3731 :       case T_MOV:
; 3732 :         /* don't use the Wide bit for moves to/from special regs */
; 3733 :         if (CodeInfo.opnd[OPND1].type & OP_RSPEC || CodeInfo.opnd[OPND2].type & OP_RSPEC)

	bt	DWORD PTR CodeInfo$[rsp+32], 12
	jb	SHORT $LN1@ParseLine
	bt	DWORD PTR CodeInfo$[rsp+56], 12
	jae	SHORT $LN6@ParseLine
$LN1@ParseLine:

; 3734 :           CodeInfo.prefix.rex &= 0x7;

	and	al, 7
	mov	BYTE PTR CodeInfo$[rsp+8], al

; 3735 :         break;

	jmp	SHORT $LN6@ParseLine
$LN258@ParseLine:

; 3707 : 
; 3708 :       /* for some instructions, the "wide" flag has to be removed selectively.
; 3709 :        * this is to be improved - by a new flag in struct instr_item.
; 3710 :        */
; 3711 :       switch (CodeInfo.token) {

	cmp	ebx, 1300				; 00000514H
	jl	SHORT $LN6@ParseLine
	cmp	ebx, 1301				; 00000515H
	jg	SHORT $LN6@ParseLine
$LN4@ParseLine:

; 3718 :       case T_CALL:
; 3719 :       case T_JMP:
; 3720 : #if VMXSUPP /* v2.09: added */
; 3721 :       case T_VMREAD:
; 3722 :       case T_VMWRITE:
; 3723 : #endif
; 3724 :         /* v2.02: previously rex-prefix was cleared entirely,
; 3725 :          * but bits 0-2 are needed to make "call rax" and "call r8"
; 3726 :          * distinguishable!
; 3727 :          */
; 3728 :         //CodeInfo.prefix.rex = 0;
; 3729 :         CodeInfo.prefix.rex &= 0x7;

	and	al, 7
	mov	BYTE PTR CodeInfo$[rsp+8], al

; 3730 :         break;

	jmp	SHORT $LN6@ParseLine
$LN28@ParseLine:

; 3635 :     HandleStringInstructions(&CodeInfo, opndx);

	lea	rdx, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	call	HandleStringInstructions
$LN6@ParseLine:

; 3736 :       }
; 3737 :     }
; 3738 : #endif
; 3739 :   }
; 3740 :   /* now call the code generator */
; 3741 :   temp = codegen( &CodeInfo, oldofs );

	mov	edx, DWORD PTR oldofs$1$[rsp]
	lea	rcx, QWORD PTR CodeInfo$[rsp]
	call	codegen

; 3742 :   /* now reset EVEX maskflags for the next line */
; 3743 :   decoflags = 0;

	mov	BYTE PTR decoflags, 0

; 3744 :   broadflags = 0;

	mov	BYTE PTR broadflags, 0
$LN353@ParseLine:
	mov	r14, QWORD PTR [rsp+656]
	mov	r15, QWORD PTR [rsp+648]
$LN351@ParseLine:
	mov	rbx, QWORD PTR [rsp+688]
	mov	r13, QWORD PTR [rsp+664]
$LN250@ParseLine:
	mov	r12, QWORD PTR [rsp+672]
	mov	rdi, QWORD PTR [rsp+712]
	mov	rsi, QWORD PTR [rsp+704]
	mov	rbp, QWORD PTR [rsp+696]

; 3745 :   return( temp );
; 3746 : }

	add	rsp, 680				; 000002a8H
	ret	0
ParseLine ENDP
_TEXT	ENDS
PUBLIC	ProcessFile
EXTRN	WritePreprocessedLine:NEAR
EXTRN	PreprocessLine:NEAR
EXTRN	GetTextLine:NEAR
xdata	SEGMENT
$unwind$ProcessFile DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$ProcessFile DD @imagerel($LN9#)
	DD	@imagerel($LN9#+186)
	DD	@imagerel($unwind$ProcessFile#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
tokenarray$ = 48
ProcessFile PROC NEAR

; 3752 : {

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H

; 3753 : 	/* Initialize xmmword override tokens each pass */
; 3754 : 	xmmOver0.token = 6;
; 3755 : 	xmmOver0.specval = 15;
; 3756 : 	xmmOver0.floattype = 15;
; 3757 : 	xmmOver0.numbase = 15;
; 3758 : 	xmmOver0.string_delim = 15;
; 3759 : 	xmmOver0.precedence = 15;
; 3760 : 	xmmOver0.bytval = 15;
; 3761 : 	xmmOver0.dirtype = 15;
; 3762 : 	xmmOver0.tokval = T_XMMWORD;
; 3763 : 	xmmOver0.string_ptr = "xmmword";
; 3764 : 	xmmOver0.stringlen = T_XMMWORD;
; 3765 : 	xmmOver0.idarg = T_XMMWORD;
; 3766 : 	xmmOver0.itemlen = T_XMMWORD;
; 3767 : 	xmmOver0.lastidx = T_XMMWORD;
; 3768 : 
; 3769 : 	xmmOver1.token = 5;
; 3770 : 	xmmOver1.specval = 4;
; 3771 : 	xmmOver1.floattype = 4;
; 3772 : 	xmmOver1.numbase = 4;
; 3773 : 	xmmOver1.string_delim = 4;
; 3774 : 	xmmOver1.precedence = 4;
; 3775 : 	xmmOver1.bytval = 4;
; 3776 : 	xmmOver1.dirtype = 4;
; 3777 : 	xmmOver1.tokval = T_PTR;
; 3778 : 	xmmOver1.string_ptr = "ptr";
; 3779 : 	xmmOver1.stringlen = T_PTR;
; 3780 : 	xmmOver1.idarg = T_PTR;
; 3781 : 	xmmOver1.itemlen = T_PTR;
; 3782 : 	xmmOver1.lastidx = T_PTR;
; 3783 : 
; 3784 :     while ( ModuleInfo.EndDirFound == FALSE && GetTextLine( CurrSource ) ) {

	bt	DWORD PTR ModuleInfo+408, 17
	lea	rax, OFFSET FLAT:$SG7418
	mov	rbx, rcx
	mov	QWORD PTR xmmOver0+8, rax
	lea	rax, OFFSET FLAT:$SG7419
	mov	BYTE PTR xmmOver0, 6
	mov	BYTE PTR xmmOver0+1, 15
	mov	DWORD PTR xmmOver0+16, 228		; 000000e4H
	mov	BYTE PTR xmmOver1, 5
	mov	QWORD PTR xmmOver1+8, rax
	mov	BYTE PTR xmmOver1+1, 4
	mov	DWORD PTR xmmOver1+16, 258		; 00000102H
	jb	SHORT $LN3@ProcessFil
	npad	1
$LL4@ProcessFil:
	mov	rcx, QWORD PTR ModuleInfo+464
	call	GetTextLine
	test	rax, rax
	je	SHORT $LN3@ProcessFil

; 3785 :         if ( PreprocessLine( CurrSource, tokenarray ) ) {

	mov	rcx, QWORD PTR ModuleInfo+464
	mov	rdx, rbx
	call	PreprocessLine
	test	eax, eax
	je	SHORT $LN1@ProcessFil

; 3786 :             ParseLine( tokenarray );

	mov	rcx, rbx
	call	ParseLine

; 3787 :             if ( Options.preprocessor_stdout == TRUE && Parse_Pass == PASS_1 )

	cmp	BYTE PTR Options+134, 1
	jne	SHORT $LN1@ProcessFil
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN1@ProcessFil

; 3788 :                 WritePreprocessedLine( CurrSource );

	mov	rcx, QWORD PTR ModuleInfo+464
	call	WritePreprocessedLine
$LN1@ProcessFil:

; 3753 : 	/* Initialize xmmword override tokens each pass */
; 3754 : 	xmmOver0.token = 6;
; 3755 : 	xmmOver0.specval = 15;
; 3756 : 	xmmOver0.floattype = 15;
; 3757 : 	xmmOver0.numbase = 15;
; 3758 : 	xmmOver0.string_delim = 15;
; 3759 : 	xmmOver0.precedence = 15;
; 3760 : 	xmmOver0.bytval = 15;
; 3761 : 	xmmOver0.dirtype = 15;
; 3762 : 	xmmOver0.tokval = T_XMMWORD;
; 3763 : 	xmmOver0.string_ptr = "xmmword";
; 3764 : 	xmmOver0.stringlen = T_XMMWORD;
; 3765 : 	xmmOver0.idarg = T_XMMWORD;
; 3766 : 	xmmOver0.itemlen = T_XMMWORD;
; 3767 : 	xmmOver0.lastidx = T_XMMWORD;
; 3768 : 
; 3769 : 	xmmOver1.token = 5;
; 3770 : 	xmmOver1.specval = 4;
; 3771 : 	xmmOver1.floattype = 4;
; 3772 : 	xmmOver1.numbase = 4;
; 3773 : 	xmmOver1.string_delim = 4;
; 3774 : 	xmmOver1.precedence = 4;
; 3775 : 	xmmOver1.bytval = 4;
; 3776 : 	xmmOver1.dirtype = 4;
; 3777 : 	xmmOver1.tokval = T_PTR;
; 3778 : 	xmmOver1.string_ptr = "ptr";
; 3779 : 	xmmOver1.stringlen = T_PTR;
; 3780 : 	xmmOver1.idarg = T_PTR;
; 3781 : 	xmmOver1.itemlen = T_PTR;
; 3782 : 	xmmOver1.lastidx = T_PTR;
; 3783 : 
; 3784 :     while ( ModuleInfo.EndDirFound == FALSE && GetTextLine( CurrSource ) ) {

	bt	DWORD PTR ModuleInfo+408, 17
	jae	SHORT $LL4@ProcessFil
$LN3@ProcessFil:

; 3789 :         }
; 3790 :     }
; 3791 :     return;
; 3792 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ProcessFile ENDP
_TEXT	ENDS
END
