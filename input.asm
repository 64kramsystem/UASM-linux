; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG5575	DB	01H DUP (?)
	ALIGN	4

$SG5574	DB	01H DUP (?)
	ALIGN	4

$SG5571	DB	01H DUP (?)
	ALIGN	4

$SG5567	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	token_stringbuf:QWORD
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	LineCur:QWORD
COMM	commentbuffer:QWORD
COMM	FileCur:QWORD
COMM	evex:BYTE
$SG5552	DB	'%s(%u) : ', 00H
	ORG $+2
$SG5553	DB	'%s : ', 00H
	ORG $+6
$SG5570	DB	'MacroLoop', 00H
	ORG $+2
$SG5599	DB	'rb', 00H
	ORG $+1
$SG5622	DB	'rb', 00H
	ORG $+1
$SG5625	DB	'rb', 00H
	ORG $+1
$SG5661	DB	';', 00H
_DATA	ENDS
PUBLIC	GetFNamePart
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\input.c
_TEXT	SEGMENT
fname$ = 8
GetFNamePart PROC NEAR

; 160  :     const char *rc;
; 161  :     for ( rc = fname; *fname; fname++ )

	movzx	eax, BYTE PTR [rcx]
	mov	rdx, rcx
	test	al, al
	je	SHORT $LN10@GetFNamePa
	npad	6
$LL5@GetFNamePa:

; 162  :         if ( ISPC( *fname ) )

	cmp	al, 47					; 0000002fH
	je	SHORT $LN1@GetFNamePa
	cmp	al, 92					; 0000005cH
	je	SHORT $LN1@GetFNamePa
	cmp	al, 58					; 0000003aH
	jne	SHORT $LN4@GetFNamePa
$LN1@GetFNamePa:

; 160  :     const char *rc;
; 161  :     for ( rc = fname; *fname; fname++ )

	lea	rdx, QWORD PTR [rcx+1]
$LN4@GetFNamePa:
	mov	al, BYTE PTR [rcx+1]
	inc	rcx
	test	al, al
	jne	SHORT $LL5@GetFNamePa
$LN10@GetFNamePa:

; 163  :             rc = fname + 1;
; 164  :     return( rc );

	mov	rax, rdx

; 165  : }

	ret	0
GetFNamePart ENDP
_TEXT	ENDS
PUBLIC	GetExtPart
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
fname$ = 8
GetExtPart PROC NEAR

; 172  :     char *rc;
; 173  :     for( rc = NULL; *fname; fname++ ) {

	movzx	eax, BYTE PTR [rcx]
	xor	edx, edx
	test	al, al
	je	SHORT $LN5@GetExtPart
	npad	7
$LL7@GetExtPart:

; 174  :         if( *fname == '.' ) {

	cmp	al, 46					; 0000002eH
	jne	SHORT $LN4@GetExtPart

; 175  :             rc = (char *)fname;

	mov	rdx, rcx
	jmp	SHORT $LN6@GetExtPart
$LN4@GetExtPart:

; 176  :         } else if( ISPC( *fname ) ) {

	cmp	al, 47					; 0000002fH
	je	SHORT $LN1@GetExtPart
	cmp	al, 92					; 0000005cH
	je	SHORT $LN1@GetExtPart
	cmp	al, 58					; 0000003aH
	jne	SHORT $LN6@GetExtPart
$LN1@GetExtPart:

; 177  :             rc = NULL;

	xor	edx, edx
$LN6@GetExtPart:

; 172  :     char *rc;
; 173  :     for( rc = NULL; *fname; fname++ ) {

	mov	al, BYTE PTR [rcx+1]
	inc	rcx
	test	al, al
	jne	SHORT $LL7@GetExtPart
$LN5@GetExtPart:

; 178  :         }
; 179  :     }
; 180  :     return( rc ? rc : (char *)fname );

	test	rdx, rdx
	cmovne	rcx, rdx
	mov	rax, rcx

; 181  : }

	ret	0
GetExtPart ENDP
_TEXT	ENDS
EXTRN	LclAlloc:NEAR
EXTRN	MemFree:NEAR
EXTRN	MemAlloc:NEAR
EXTRN	_stricmp:NEAR
EXTRN	ModuleInfo:BYTE
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$AddFile DD 071d01H
	DD	09741dH
	DD	086414H
	DD	07540fH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$AddFile DD @imagerel(AddFile#)
	DD	@imagerel(AddFile#+184)
	DD	@imagerel($unwind$AddFile#)
pdata	ENDS
xdata	SEGMENT
$chain$3$AddFile DD 020521H
	DD	063405H
	DD	@imagerel(AddFile#)
	DD	@imagerel(AddFile#+184)
	DD	@imagerel($unwind$AddFile#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$AddFile DD @imagerel(AddFile#+184)
	DD	@imagerel(AddFile#+240)
	DD	@imagerel($chain$3$AddFile#)
pdata	ENDS
xdata	SEGMENT
$chain$4$AddFile DD 021H
	DD	@imagerel(AddFile#)
	DD	@imagerel(AddFile#+184)
	DD	@imagerel($unwind$AddFile#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$AddFile DD @imagerel(AddFile#+240)
	DD	@imagerel(AddFile#+279)
	DD	@imagerel($chain$4$AddFile#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
fname$ = 48
AddFile	PROC NEAR

; 192  : {

	sub	rsp, 40					; 00000028H

; 193  :     unsigned    index;
; 194  : 
; 195  :     DebugMsg1(("AddFile(%s) enter, curr index=%u\n", fname, ModuleInfo.g.cnt_fnames ));
; 196  :     for( index = 0; index < ModuleInfo.g.cnt_fnames; index++ ) {

	mov	eax, DWORD PTR ModuleInfo+168
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	xor	esi, esi
	test	eax, eax
	mov	QWORD PTR [rsp+72], rdi
	mov	rbp, rcx
	je	SHORT $LN4@AddFile
	mov	rdi, rsi
	npad	11
$LL6@AddFile:

; 197  :         if( filecmp( fname, ModuleInfo.g.FNames[index].fname ) == 0 ) {

	mov	rdx, QWORD PTR ModuleInfo+160
	mov	rcx, rbp
	mov	rdx, QWORD PTR [rdi+rdx]
	call	_stricmp
	test	eax, eax
	je	$LN12@AddFile
	mov	eax, DWORD PTR ModuleInfo+168
	inc	esi
	add	rdi, 8
	cmp	esi, eax
	jb	SHORT $LL6@AddFile
$LN4@AddFile:

; 198  : #ifdef DEBUG_OUT
; 199  :             if ( Parse_Pass == PASS_1 )
; 200  :                 ModuleInfo.g.FNames[index].included++;
; 201  : #endif
; 202  :             return( index );
; 203  :         }
; 204  :     }
; 205  : 
; 206  :     if ( ( index % 64 ) == 0 ) {

	test	sil, 63					; 0000003fH
	jne	SHORT $LN2@AddFile

; 207  :         struct fname_item *newfn;
; 208  :         newfn = (struct fname_item *)MemAlloc( ( index + 64 ) * sizeof( struct fname_item ) );

	lea	ecx, DWORD PTR [rsi+64]
	shl	rcx, 3
	call	MemAlloc

; 209  :         if ( ModuleInfo.g.FNames ) {

	mov	rdx, QWORD PTR ModuleInfo+160
	test	rdx, rdx
	mov	rdi, rax
	je	SHORT $LN1@AddFile

; 210  :             memcpy( newfn, ModuleInfo.g.FNames, index * sizeof( struct fname_item ) );

	mov	r8d, esi
	mov	rcx, rax
	shl	r8, 3
	call	memcpy

; 211  :             MemFree( ModuleInfo.g.FNames );

	mov	rcx, QWORD PTR ModuleInfo+160
	call	MemFree
$LN1@AddFile:

; 212  :         }
; 213  :         ModuleInfo.g.FNames = newfn;

	mov	eax, DWORD PTR ModuleInfo+168
	mov	QWORD PTR ModuleInfo+160, rdi
$LN2@AddFile:

; 214  :     }
; 215  :     ModuleInfo.g.cnt_fnames++;

	inc	eax

; 216  : 
; 217  :     /* v2.11: use name directly - allows COFF .file entries with relative paths */
; 218  :     //_splitpath( fname, NULL, NULL, name, ext );
; 219  : 
; 220  :     ModuleInfo.g.FNames[index].fname = (char *)LclAlloc( strlen( fname ) + 1 );

	mov	rcx, -1
	mov	rdi, rbp
	mov	DWORD PTR ModuleInfo+168, eax
	xor	eax, eax
	mov	QWORD PTR [rsp+48], rbx
	repne scasb
	not	rcx
	call	LclAlloc
	mov	rcx, QWORD PTR ModuleInfo+160
	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rcx+rsi*8], rax

; 221  :     strcpy( ModuleInfo.g.FNames[index].fname, fname );

	mov	rax, QWORD PTR ModuleInfo+160
	mov	rcx, QWORD PTR [rax+rsi*8]
	npad	14
$LL9@AddFile:
	movzx	eax, BYTE PTR [rbp]
	inc	rcx
	inc	rbp
	test	al, al
	mov	BYTE PTR [rcx-1], al
	jne	SHORT $LL9@AddFile
$LN12@AddFile:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+56]

; 222  :     /* v2.11: field fullname removed */
; 223  :     //ModuleInfo.g.FNames[index].fullname = (char *)LclAlloc( strlen( fullname ) + 1 );
; 224  :     //strcpy( ModuleInfo.g.FNames[index].fullname, fullname );
; 225  :     DebugCmd( ModuleInfo.g.FNames[index].included = 1 );
; 226  :     return( index );

	mov	eax, esi
	mov	rsi, QWORD PTR [rsp+64]

; 227  : }

	add	rsp, 40					; 00000028H
	ret	0
AddFile	ENDP
_TEXT	ENDS
PUBLIC	GetFName
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
index$ = 8
GetFName PROC NEAR

; 232  :     return( ModuleInfo.g.FNames+index );

	mov	rax, QWORD PTR ModuleInfo+160
	mov	edx, ecx
	lea	rax, QWORD PTR [rax+rdx*8]

; 233  : }

	ret	0
GetFName ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$FreeFiles DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$FreeFiles DD @imagerel(FreeFiles#)
	DD	@imagerel(FreeFiles#+48)
	DD	@imagerel($unwind$FreeFiles#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
FreeFiles PROC NEAR

; 241  : {

	sub	rsp, 40					; 00000028H

; 242  : #if FASTMEM==0
; 243  :     int i;
; 244  : 
; 245  :     /* remove the main src item from src stack */
; 246  :     src_stack->next = SrcFree;
; 247  :     SrcFree = src_stack;
; 248  : #endif
; 249  :     /* v2.03: set src_stack=NULL to ensure that GetCurrSrcPos()
; 250  :      * won't find something when called from main().
; 251  :      */
; 252  :     src_stack = NULL;
; 253  : 
; 254  : #if FASTMEM==0
; 255  :     /* free the "free src_items"-heap */
; 256  :     while ( SrcFree ) {
; 257  :         struct src_item *next;
; 258  :         next = SrcFree->next;
; 259  :         LclFree( SrcFree );
; 260  :         SrcFree = next;
; 261  :     };
; 262  :     for ( i = 0; i < ModuleInfo.g.cnt_fnames; i++ ) {
; 263  :         LclFree( ModuleInfo.g.FNames[i].fname );
; 264  :         //LclFree( ModuleInfo.g.FNames[i].fullname );
; 265  :     }
; 266  : #endif
; 267  :     if ( ModuleInfo.g.FNames ) {

	mov	rcx, QWORD PTR ModuleInfo+160
	mov	QWORD PTR ModuleInfo+200, 0
	test	rcx, rcx
	je	SHORT $LN1@FreeFiles

; 268  :         MemFree( ModuleInfo.g.FNames );

	call	MemFree

; 269  :         ModuleInfo.g.FNames = NULL;

	mov	QWORD PTR ModuleInfo+160, 0
$LN1@FreeFiles:

; 270  :     }
; 271  :     return;
; 272  : }

	add	rsp, 40					; 00000028H
	ret	0
FreeFiles ENDP
_TEXT	ENDS
PUBLIC	ClearSrcStack
EXTRN	fclose:NEAR
EXTRN	DeleteLineQueue:NEAR
_BSS	SEGMENT
	ALIGN	8

SrcFree	DQ	01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$ClearSrcStack DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$ClearSrcStack DD @imagerel($LN9#)
	DD	@imagerel($LN9#+104)
	DD	@imagerel($unwind$ClearSrcStack#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
ClearSrcStack PROC NEAR

; 284  : {

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H

; 285  :     struct src_item   *nextfile;
; 286  : 
; 287  :     DeleteLineQueue();

	call	DeleteLineQueue

; 288  : 
; 289  :     /* dont close the last item (which is the main src file) */
; 290  :     for( ; src_stack->next ; src_stack = nextfile ) {

	mov	r11, QWORD PTR ModuleInfo+200
	cmp	QWORD PTR [r11], 0
	je	SHORT $LN2@ClearSrcSt
	npad	8
$LL4@ClearSrcSt:

; 291  :         nextfile = src_stack->next;
; 292  :         if ( src_stack->type == SIT_FILE ) {

	cmp	BYTE PTR [r11+8], 0
	mov	rbx, QWORD PTR [r11]
	jne	SHORT $LN1@ClearSrcSt

; 293  :             fclose( src_stack->file );

	mov	rcx, QWORD PTR [r11+16]
	call	fclose
	mov	r11, QWORD PTR ModuleInfo+200
$LN1@ClearSrcSt:

; 294  :         }
; 295  :         //LclFree( src_stack );
; 296  :         src_stack->next = SrcFree;

	mov	rax, QWORD PTR SrcFree
	mov	QWORD PTR [r11], rax

; 297  :         SrcFree = src_stack;

	mov	rax, QWORD PTR ModuleInfo+200
	mov	QWORD PTR ModuleInfo+200, rbx
	cmp	QWORD PTR [rbx], 0
	mov	r11, rbx
	mov	QWORD PTR SrcFree, rax
	jne	SHORT $LL4@ClearSrcSt
$LN2@ClearSrcSt:

; 298  :     }
; 299  :     return;
; 300  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ClearSrcStack ENDP
_TEXT	ENDS
PUBLIC	UpdateLineNumber
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
sym$ = 8
p$ = 16
UpdateLineNumber PROC NEAR

; 307  :     struct src_item *curr;
; 308  :     for ( curr = src_stack; curr ; curr = curr->next )

	mov	rax, QWORD PTR ModuleInfo+200
	test	rax, rax
	je	SHORT $LN2@UpdateLine
	npad	4
$LL4@UpdateLine:

; 309  :         if ( curr->type == SIT_FILE ) {

	cmp	BYTE PTR [rax+8], 0
	je	SHORT $LN8@UpdateLine
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL4@UpdateLine

; 311  :             break;
; 312  :         }
; 313  :     return;
; 314  : }

	ret	0
$LN8@UpdateLine:

; 310  :             sym->value = curr->line_num;

	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR [rcx+16], eax
$LN2@UpdateLine:

; 311  :             break;
; 312  :         }
; 313  :     return;
; 314  : }

	ret	0
UpdateLineNumber ENDP
_TEXT	ENDS
PUBLIC	GetLineNumber
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
GetLineNumber PROC NEAR

; 319  :     UpdateLineNumber( LineCur, NULL );

	mov	rax, QWORD PTR ModuleInfo+200
	test	rax, rax
	je	SHORT $LN12@GetLineNum
	npad	4
$LL6@GetLineNum:
	cmp	BYTE PTR [rax+8], 0
	je	SHORT $LN10@GetLineNum
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL6@GetLineNum

; 320  :     return( LineCur->uvalue );

	mov	rax, QWORD PTR LineCur
	mov	eax, DWORD PTR [rax+16]

; 321  : }

	ret	0
$LN10@GetLineNum:

; 319  :     UpdateLineNumber( LineCur, NULL );

	mov	ecx, DWORD PTR [rax+24]
	mov	rax, QWORD PTR LineCur
	mov	DWORD PTR [rax+16], ecx
$LN12@GetLineNum:

; 320  :     return( LineCur->uvalue );

	mov	rax, QWORD PTR LineCur
	mov	eax, DWORD PTR [rax+16]

; 321  : }

	ret	0
GetLineNumber ENDP
_TEXT	ENDS
EXTRN	EmitErr:NEAR
EXTRN	getc:NEAR
xdata	SEGMENT
$unwind$my_fgets DD 091e01H
	DD	09741eH
	DD	086413H
	DD	07540eH
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$my_fgets DD @imagerel(my_fgets#)
	DD	@imagerel(my_fgets#+151)
	DD	@imagerel($unwind$my_fgets#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buffer$ = 48
max$ = 56
fp$ = 64
my_fgets PROC NEAR

; 355  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi

; 356  :     char        *ptr = buffer;
; 357  :     char        *last = buffer + max;

	movsxd	rsi, edx
	mov	rbx, rcx
	mov	QWORD PTR [rsp+72], rdi
	add	rsi, rcx
	mov	rdi, rcx

; 358  :     int         c;
; 359  : 
; 360  :     c = getc( fp );

	mov	rcx, r8
	mov	rbp, r8
	call	getc

; 361  :     while( ptr < last ) {

	cmp	rbx, rsi
	jae	SHORT $LN7@my_fgets
$LL8@my_fgets:

; 362  :         switch ( c ) {

	cmp	eax, -1
	je	SHORT $LN2@my_fgets
	cmp	eax, 10
	je	SHORT $LN3@my_fgets
	cmp	eax, 13
	je	SHORT $LN4@my_fgets
	cmp	eax, 26
	je	SHORT $LN2@my_fgets

; 384  :         default:
; 385  :             *ptr++ = c;

	mov	BYTE PTR [rbx], al
	inc	rbx
$LN4@my_fgets:

; 386  :         }
; 387  :         c = getc( fp );

	mov	rcx, rbp
	call	getc
	cmp	rbx, rsi
	jb	SHORT $LL8@my_fgets
$LN7@my_fgets:

; 388  :     }
; 389  :     EmitErr( LINE_TOO_LONG );

	mov	ecx, 61					; 0000003dH
	call	EmitErr

; 390  :     *(ptr-1) = NULLC;

	mov	BYTE PTR [rbx-1], 0
$LN13@my_fgets:

; 391  :     return( buffer );

	mov	rax, rdi
$LN9@my_fgets:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 392  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@my_fgets:

; 363  :         case '\r':
; 364  :             break; /* don't store CR */
; 365  :         case '\n':
; 366  :             /* fall through */
; 367  :         //case '\0': /* v2.08: */
; 368  : #ifdef DEBUG_OUT
; 369  :             if ( Parse_Pass == PASS_1 )
; 370  :                 cntflines++;
; 371  : #endif
; 372  :             *ptr = NULLC;

	mov	BYTE PTR [rbx], 0

; 373  :             return( buffer );

	jmp	SHORT $LN13@my_fgets
$LN2@my_fgets:

; 374  : #if DETECTCTRLZ
; 375  :         case 0x1a:
; 376  :             /* since source files are opened in binary mode, ctrl-z
; 377  :              * handling must be done here.
; 378  :              */
; 379  :             /* no break */
; 380  : #endif
; 381  :         case EOF:
; 382  :             *ptr = NULLC;
; 383  :             return( ptr > buffer ? buffer : NULL );

	xor	eax, eax
	cmp	rbx, rdi
	mov	BYTE PTR [rbx], 0
	cmova	rax, rdi
	jmp	SHORT $LN9@my_fgets
my_fgets ENDP
_TEXT	ENDS
PUBLIC	PushSrcItem
xdata	SEGMENT
$unwind$PushSrcItem DD 051501H
	DD	097415H
	DD	083410H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$PushSrcItem DD @imagerel($LN5#)
	DD	@imagerel($LN5#+108)
	DD	@imagerel($unwind$PushSrcItem#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
type$ = 48
pv$ = 56
PushSrcItem PROC NEAR

; 416  : {

$LN5:
	sub	rsp, 40					; 00000028H

; 417  :     struct src_item   *curr;
; 418  : 
; 419  :     if ( SrcFree ) {

	mov	r8, QWORD PTR SrcFree
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	test	r8, r8
	mov	rbx, rdx
	movzx	edi, cl
	je	SHORT $LN2@PushSrcIte

; 420  :         curr = SrcFree;
; 421  :         SrcFree = curr->next;

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR SrcFree, rax

; 422  :     } else

	jmp	SHORT $LN1@PushSrcIte
$LN2@PushSrcIte:

; 423  :         curr = LclAlloc( sizeof( struct src_item ) );

	mov	ecx, 32					; 00000020H
	call	LclAlloc
	mov	r8, rax
$LN1@PushSrcIte:

; 424  :     curr->next = src_stack;

	mov	rcx, QWORD PTR ModuleInfo+200

; 425  :     src_stack = curr;
; 426  :     curr->type = type;
; 427  :     curr->content = pv;
; 428  :     curr->line_num = 0;
; 429  :     return( curr );

	mov	rax, r8
	mov	QWORD PTR [r8], rcx
	mov	QWORD PTR ModuleInfo+200, r8
	mov	BYTE PTR [r8+8], dil
	mov	rdi, QWORD PTR [rsp+72]
	mov	QWORD PTR [r8+16], rbx
	mov	rbx, QWORD PTR [rsp+64]
	mov	DWORD PTR [r8+24], 0

; 430  : }

	add	rsp, 40					; 00000028H
	ret	0
PushSrcItem ENDP
_TEXT	ENDS
PUBLIC	PushMacro
xdata	SEGMENT
$unwind$PushMacro DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$PushMacro DD @imagerel($LN7#)
	DD	@imagerel($LN7#+84)
	DD	@imagerel($unwind$PushMacro#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
mi$ = 48
PushMacro PROC NEAR

; 436  : {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H

; 437  :     DebugMsg1(( "PushMacro(%s)\n", mi->macro->name ));
; 438  :     PushSrcItem( SIT_MACRO, mi );

	mov	rdx, QWORD PTR SrcFree
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN4@PushMacro
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR SrcFree, rax
	jmp	SHORT $LN3@PushMacro
$LN4@PushMacro:
	mov	ecx, 32					; 00000020H
	call	LclAlloc
	mov	rdx, rax
$LN3@PushMacro:
	mov	rcx, QWORD PTR ModuleInfo+200
	mov	QWORD PTR [rdx], rcx
	mov	QWORD PTR ModuleInfo+200, rdx
	mov	BYTE PTR [rdx+8], 1
	mov	QWORD PTR [rdx+16], rbx
	mov	DWORD PTR [rdx+24], 0

; 439  :     return;
; 440  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
PushMacro ENDP
_TEXT	ENDS
PUBLIC	get_curr_srcfile
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
get_curr_srcfile PROC NEAR

; 459  :     struct src_item *curr;
; 460  :     for ( curr = src_stack; curr ; curr = curr->next )

	mov	rax, QWORD PTR ModuleInfo+200
	test	rax, rax
	je	SHORT $LN2@get_curr_s
	npad	4
$LL4@get_curr_s:

; 461  :         if ( curr->type == SIT_FILE )

	cmp	BYTE PTR [rax+8], 0
	je	SHORT $LN8@get_curr_s
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL4@get_curr_s
$LN2@get_curr_s:

; 463  :     return( ModuleInfo.srcfile );

	mov	eax, DWORD PTR ModuleInfo+428

; 464  : }

	ret	0
$LN8@get_curr_s:

; 462  :             return( curr->srcfile );

	movzx	eax, WORD PTR [rax+10]

; 464  : }

	ret	0
get_curr_srcfile ENDP
_TEXT	ENDS
PUBLIC	set_curr_srcfile
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
file$ = 8
line_num$ = 16
set_curr_srcfile PROC NEAR

; 470  :     if ( file != 0xFFF ) /* 0xFFF is the special value for macro lines */

	cmp	ecx, 4095				; 00000fffH

; 471  :         src_stack->srcfile = file;

	mov	rax, QWORD PTR ModuleInfo+200
	je	SHORT $LN4@set_curr_s
	mov	WORD PTR [rax+10], cx

; 472  :     src_stack->line_num = line_num;

	mov	rax, QWORD PTR ModuleInfo+200
$LN4@set_curr_s:
	mov	DWORD PTR [rax+24], edx

; 473  :     return;
; 474  : }

	ret	0
set_curr_srcfile ENDP
_TEXT	ENDS
PUBLIC	SetLineNumber
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
line$ = 8
SetLineNumber PROC NEAR

; 480  :     src_stack->line_num = line;

	mov	rax, QWORD PTR ModuleInfo+200
	mov	DWORD PTR [rax+24], ecx

; 481  :     return;
; 482  : }

	ret	0
SetLineNumber ENDP
_TEXT	ENDS
PUBLIC	GetCurrSrcPos
EXTRN	sprintf:NEAR
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
buffer$ = 8
GetCurrSrcPos PROC NEAR

; 491  :     struct src_item *curr;
; 492  : 
; 493  :     for( curr = src_stack; curr; curr = curr->next ) {

	mov	r9, QWORD PTR ModuleInfo+200
	test	r9, r9
	je	SHORT $LN2@GetCurrSrc
	npad	4
$LL4@GetCurrSrc:

; 494  :         if ( curr->type == SIT_FILE ) {

	cmp	BYTE PTR [r9+8], 0
	je	SHORT $LN10@GetCurrSrc
	mov	r9, QWORD PTR [r9]
	test	r9, r9
	jne	SHORT $LL4@GetCurrSrc
$LN2@GetCurrSrc:

; 496  :         }
; 497  :     }
; 498  :     *buffer = NULLC;

	mov	BYTE PTR [rcx], 0

; 499  :     return( 0 );

	xor	eax, eax

; 500  : }

	ret	0
$LN10@GetCurrSrc:

; 495  :             return( sprintf( buffer, ModuleInfo.EndDirFound == FALSE ? "%s(%" I32_SPEC "u) : " : "%s : ", GetFName( curr->srcfile )->fname , curr->line_num ) );

	movzx	eax, WORD PTR [r9+10]
	mov	r8, QWORD PTR ModuleInfo+160
	bt	DWORD PTR ModuleInfo+408, 17
	mov	r9d, DWORD PTR [r9+24]
	mov	r8, QWORD PTR [r8+rax*8]
	lea	r10, OFFSET FLAT:$SG5552
	lea	rdx, OFFSET FLAT:$SG5553
	cmovae	rdx, r10

; 500  : }

	jmp	sprintf
GetCurrSrcPos ENDP
_TEXT	ENDS
PUBLIC	print_source_nesting_structure
EXTRN	PrintNote:NEAR
xdata	SEGMENT
$unwind$print_source_nesting_structure DD 051501H
	DD	0b7415H
	DD	0a3409H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$print_source_nesting_structure DD @imagerel($LN29#)
	DD	@imagerel($LN29#+327)
	DD	@imagerel($unwind$print_source_nesting_structure#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
print_source_nesting_structure PROC NEAR

; 508  : {

$LN29:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR [rsp+80], rbx

; 509  :     struct src_item *curr;
; 510  :     unsigned        tab = 1;
; 511  : 
; 512  :     /* in main source file? */
; 513  :     if ( src_stack == NULL || src_stack->next == NULL )

	mov	rbx, QWORD PTR ModuleInfo+200
	mov	QWORD PTR [rsp+88], rdi
	test	rbx, rbx
	mov	edi, 1
	je	$LN8@print_sour
	cmp	QWORD PTR [rbx], 0
	je	$LN8@print_sour

; 514  :         return;
; 515  : 
; 516  :     for( curr = src_stack; curr->next ; curr = curr->next ) {

	cmp	QWORD PTR [rbx], 0
	je	$LN5@print_sour
$LL7@print_sour:

; 517  :         if( curr->type == SIT_FILE ) {

	cmp	BYTE PTR [rbx+8], 0
	jne	SHORT $LN4@print_sour

; 518  :             PrintNote( NOTE_INCLUDED_BY, tab, "", GetFName( curr->srcfile )->fname, curr->line_num );

	movzx	ecx, WORD PTR [rbx+10]
	mov	r9, QWORD PTR ModuleInfo+160
	mov	eax, DWORD PTR [rbx+24]
	mov	r9, QWORD PTR [r9+rcx*8]
	lea	r8, OFFSET FLAT:$SG5567
	mov	edx, edi
	mov	ecx, 123				; 0000007bH
	mov	DWORD PTR [rsp+32], eax
	call	PrintNote

; 519  :             tab++;

	inc	edi

; 520  :         } else {

	jmp	$LN6@print_sour
$LN4@print_sour:

; 521  :             //char fname[_MAX_FNAME+_MAX_EXT];
; 522  :             if (*(curr->mi->macro->name) == NULLC ) {

	mov	rax, QWORD PTR [rbx+16]
	mov	rax, QWORD PTR [rax+32]
	mov	r9, QWORD PTR [rax+8]
	cmp	BYTE PTR [r9], 0
	jne	SHORT $LN2@print_sour

; 523  :                 PrintNote( NOTE_ITERATION_MACRO_CALLED_FROM, tab, "", "MacroLoop", curr->line_num, curr->mi->macro->value + 1 );

	mov	eax, DWORD PTR [rax+16]
	lea	r9, OFFSET FLAT:$SG5570
	lea	r8, OFFSET FLAT:$SG5571
	inc	eax
	mov	edx, edi
	mov	ecx, 125				; 0000007dH
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR [rbx+24]
	mov	DWORD PTR [rsp+32], eax
	call	PrintNote

; 524  :             } else {

	jmp	SHORT $LN1@print_sour
$LN2@print_sour:

; 525  :                 PrintNote( NOTE_MACRO_CALLED_FROM, tab, "", curr->mi->macro->name, curr->line_num, GetFNamePart( GetFName(((struct dsym *)curr->mi->macro)->e.macroinfo->srcfile)->fname ) ) ;

	mov	rax, QWORD PTR [rax+104]
	mov	ecx, DWORD PTR [rax+24]
	mov	rax, QWORD PTR ModuleInfo+160
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	rcx, rdx
	movzx	eax, BYTE PTR [rdx]
	test	al, al
	je	SHORT $LN18@print_sour
$LL20@print_sour:
	cmp	al, 47					; 0000002fH
	je	SHORT $LN16@print_sour
	cmp	al, 92					; 0000005cH
	je	SHORT $LN16@print_sour
	cmp	al, 58					; 0000003aH
	jne	SHORT $LN19@print_sour
$LN16@print_sour:
	lea	rcx, QWORD PTR [rdx+1]
$LN19@print_sour:
	mov	al, BYTE PTR [rdx+1]
	inc	rdx
	test	al, al
	jne	SHORT $LL20@print_sour
$LN18@print_sour:
	mov	eax, DWORD PTR [rbx+24]
	mov	QWORD PTR [rsp+40], rcx
	lea	r8, OFFSET FLAT:$SG5574
	mov	edx, edi
	mov	ecx, 124				; 0000007cH
	mov	DWORD PTR [rsp+32], eax
	call	PrintNote
$LN1@print_sour:

; 526  :             }
; 527  :             tab++;

	inc	edi
$LN6@print_sour:

; 514  :         return;
; 515  : 
; 516  :     for( curr = src_stack; curr->next ; curr = curr->next ) {

	mov	rbx, QWORD PTR [rbx]
	cmp	QWORD PTR [rbx], 0
	jne	$LL7@print_sour
$LN5@print_sour:

; 528  :         }
; 529  :     }
; 530  :     PrintNote( NOTE_MAIN_LINE_CODE, tab, "", GetFName( curr->srcfile )->fname, curr->line_num );

	movzx	ecx, WORD PTR [rbx+10]
	mov	r9, QWORD PTR ModuleInfo+160
	mov	eax, DWORD PTR [rbx+24]
	mov	r9, QWORD PTR [r9+rcx*8]
	lea	r8, OFFSET FLAT:$SG5575
	mov	edx, edi
	mov	ecx, 126				; 0000007eH
	mov	DWORD PTR [rsp+32], eax
	call	PrintNote
$LN8@print_sour:
	mov	rdi, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]

; 531  : }

	add	rsp, 56					; 00000038H
	ret	0
print_source_nesting_structure ENDP
_TEXT	ENDS
EXTRN	fopen:NEAR
EXTRN	strchr:NEAR
EXTRN	isspace:NEAR
xdata	SEGMENT
$unwind$open_file_in_include_path DD 0d6701H
	DD	04e467H
	DD	0b7451H
	DD	0a6445H
	DD	05d419H
	DD	06c414H
	DD	083409H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$open_file_in_include_path DD @imagerel(open_file_in_include_path#)
	DD	@imagerel(open_file_in_include_path#+116)
	DD	@imagerel($unwind$open_file_in_include_path#)
pdata	ENDS
xdata	SEGMENT
$chain$6$open_file_in_include_path DD 020521H
	DD	095405H
	DD	@imagerel(open_file_in_include_path#)
	DD	@imagerel(open_file_in_include_path#+116)
	DD	@imagerel($unwind$open_file_in_include_path#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$open_file_in_include_path DD @imagerel(open_file_in_include_path#+116)
	DD	@imagerel(open_file_in_include_path#+313)
	DD	@imagerel($chain$6$open_file_in_include_path#)
pdata	ENDS
xdata	SEGMENT
$chain$7$open_file_in_include_path DD 021H
	DD	@imagerel(open_file_in_include_path#)
	DD	@imagerel(open_file_in_include_path#+116)
	DD	@imagerel($unwind$open_file_in_include_path#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$open_file_in_include_path DD @imagerel(open_file_in_include_path#+313)
	DD	@imagerel(open_file_in_include_path#+348)
	DD	@imagerel($chain$7$open_file_in_include_path#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 64
fullpath$ = 72
open_file_in_include_path PROC NEAR

; 538  : {

	sub	rsp, 56					; 00000038H
	mov	QWORD PTR [rsp+64], rbx
	mov	rbx, rcx

; 539  :     char            *curr;
; 540  :     char            *next;
; 541  :     int             i;
; 542  :     int             namelen;
; 543  :     FILE            *file = NULL;
; 544  : 
; 545  :     while( isspace( *name ) )

	movsx	ecx, BYTE PTR [rcx]
	mov	QWORD PTR [rsp+48], r12
	mov	QWORD PTR [rsp+40], r13
	mov	r13, rdx
	xor	r12d, r12d
	call	isspace
	test	eax, eax
	je	SHORT $LN10@open_file_
	npad	8
$LL11@open_file_:
	movsx	ecx, BYTE PTR [rbx+1]

; 546  :         name++;

	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL11@open_file_
$LN10@open_file_:
	mov	QWORD PTR [rsp+80], rsi

; 547  : 
; 548  :     curr = ModuleInfo.g.IncludePath;

	mov	rsi, QWORD PTR ModuleInfo+176
	mov	QWORD PTR [rsp+88], rdi

; 549  :     namelen = strlen( name );

	xor	eax, eax
	mov	rdi, rbx
	mov	rcx, -1
	repne scasb

; 550  : 
; 551  :     DebugMsg(("open_file_in_include_path(%s) enter\n", name ));
; 552  :     for ( ; curr; curr = next ) {

	test	rsi, rsi
	mov	QWORD PTR [rsp+32], r14
	not	rcx
	lea	r14, QWORD PTR [rcx-1]
	je	$LN18@open_file_
	mov	QWORD PTR [rsp+72], rbp
	npad	7
$LL9@open_file_:

; 553  :         next = strchr( curr, INC_PATH_DELIM );

	mov	edx, 59					; 0000003bH
	mov	rcx, rsi
	call	strchr

; 554  :         if ( next ) {

	test	rax, rax
	mov	rbp, rax
	je	SHORT $LN6@open_file_

; 555  :             i = next - curr;

	mov	edi, eax
	sub	edi, esi

; 556  :             next++; /* skip path delimiter char (; or :) */

	inc	rbp

; 557  :         } else {

	jmp	SHORT $LN5@open_file_
$LN6@open_file_:

; 558  :             i = strlen( curr );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rsi
	repne scasb
	not	rcx
	lea	rdi, QWORD PTR [rcx-1]
$LN5@open_file_:

; 559  :         }
; 560  : 
; 561  :         /* v2.06: ignore
; 562  :          * - "empty" entries in PATH
; 563  :          * - entries which would cause a buffer overflow
; 564  :          */
; 565  :         if ( i == 0 || ( ( i + namelen ) >= FILENAME_MAX ) )

	test	edi, edi
	je	SHORT $LN8@open_file_
	lea	eax, DWORD PTR [rdi+r14]
	cmp	eax, 260				; 00000104H
	jge	SHORT $LN8@open_file_

; 566  :             continue;
; 567  : 
; 568  :         memcpy( fullpath, curr, i );

	movsxd	r12, edi
	mov	rdx, rsi
	mov	rcx, r13
	mov	r8, r12
	call	memcpy

; 569  :         if( fullpath[i-1] != '/'
; 570  : #if !defined(__UNIX__)
; 571  :            && fullpath[i-1] != '\\' && fullpath[i-1] != ':'
; 572  : #endif
; 573  :         ) {

	movzx	eax, BYTE PTR [r12+r13-1]
	cmp	al, 47					; 0000002fH
	je	SHORT $LN2@open_file_
	cmp	al, 92					; 0000005cH
	je	SHORT $LN2@open_file_
	cmp	al, 58					; 0000003aH
	je	SHORT $LN2@open_file_

; 574  :             fullpath[i] = DIR_SEPARATOR;

	mov	BYTE PTR [r12+r13], 92			; 0000005cH

; 575  :             i++;

	inc	edi
$LN2@open_file_:

; 576  :         }
; 577  :         strcpy( fullpath+i, name );

	movsxd	rdx, edi
	mov	rcx, rbx
	sub	rdx, rbx
	add	rdx, r13
	npad	8
$LL14@open_file_:
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx+rcx-1], al
	jne	SHORT $LL14@open_file_

; 578  : 
; 579  :         DebugMsg(("open_file_in_include_path: >%s<\n", fullpath ));
; 580  :         file = fopen( fullpath, "rb" );

	lea	rdx, OFFSET FLAT:$SG5599
	mov	rcx, r13
	call	fopen

; 581  :         if( file ) {

	test	rax, rax
	mov	r12, rax
	jne	SHORT $LN23@open_file_
$LN8@open_file_:

; 550  : 
; 551  :     DebugMsg(("open_file_in_include_path(%s) enter\n", name ));
; 552  :     for ( ; curr; curr = next ) {

	test	rbp, rbp
	mov	rsi, rbp
	jne	$LL9@open_file_

; 582  :             break;
; 583  :         }
; 584  :     }
; 585  :     DebugMsg(("open_file_in_include_path()=%p\n", file ));
; 586  :     return( file );

	mov	rax, r12
$LN23@open_file_:
	mov	rbp, QWORD PTR [rsp+72]
$LN18@open_file_:
	mov	r14, QWORD PTR [rsp+32]
	mov	r13, QWORD PTR [rsp+40]
	mov	r12, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+64]

; 587  : }

	add	rsp, 56					; 00000038H
	ret	0
open_file_in_include_path ENDP
_TEXT	ENDS
PUBLIC	SearchFile
EXTRN	ErrnoStr:NEAR
xdata	SEGMENT
$unwind$SearchFile DD 0a3d01H
	DD	02a643dH
	DD	0283435H
	DD	02b7412H
	DD	029540eH
	DD	027010aH
xdata	ENDS
pdata	SEGMENT
$pdata$SearchFile DD @imagerel($LN53#)
	DD	@imagerel($LN53#+572)
	DD	@imagerel($unwind$SearchFile#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
fullpath$ = 32
path$ = 320
queue$ = 328
SearchFile PROC NEAR

; 597  : {

$LN53:
	mov	rax, rsp
	sub	rsp, 312				; 00000138H
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+32], rdi
	mov	rdi, rcx

; 598  :     FILE        *file = NULL;
; 599  :     struct src_item *fl;
; 600  :     const char  *fn;
; 601  :     bool        isabs;
; 602  :     char        fullpath[FILENAME_MAX];
; 603  : 
; 604  :     DebugMsg1(("SearchFile(%s) enter\n", path ));
; 605  : 
; 606  :     //_splitpath( path, drive, dir, fname, ext );
; 607  :     //DebugMsg1(("SearchFile(): drive=%s, dir=%s, fname=%s, ext=%s\n", drive, dir, fname, ext ));
; 608  :     fn = GetFNamePart( path );

	mov	rax, rcx
	movzx	ecx, BYTE PTR [rcx]
	movzx	ebp, dl
	test	cl, cl
	je	SHORT $LN22@SearchFile
$LL23@SearchFile:
	inc	rax
	cmp	BYTE PTR [rax], 0
	jne	SHORT $LL23@SearchFile
$LN22@SearchFile:

; 609  : 
; 610  :     /* if no absolute path is given, then search in the directory
; 611  :      * of the current source file first!
; 612  :      * v2.11: various changes because field fullpath has been removed.
; 613  :      */
; 614  : 
; 615  :     isabs = ISABS( path );

	cmp	cl, 47					; 0000002fH
	mov	QWORD PTR [rsp+320], rbx
	mov	QWORD PTR [rsp+336], rsi
	je	$LN15@SearchFile
	cmp	cl, 92					; 0000005cH
	je	$LN15@SearchFile
	test	cl, cl
	je	SHORT $LN16@SearchFile
	cmp	BYTE PTR [rdi+1], 58			; 0000003aH
	jne	SHORT $LN16@SearchFile
	movzx	eax, BYTE PTR [rdi+2]
	cmp	al, 47					; 0000002fH
	je	$LN15@SearchFile
	cmp	al, 92					; 0000005cH
	je	$LN15@SearchFile
$LN16@SearchFile:

; 618  :         for ( fl = src_stack; fl ; fl = fl->next ) {

	mov	rax, QWORD PTR ModuleInfo+200
	xor	sil, sil
	test	rax, rax
	je	SHORT $LN51@SearchFile
	npad	7
$LL11@SearchFile:

; 619  :             if ( fl->type == SIT_FILE ) {

	cmp	BYTE PTR [rax+8], 0
	je	SHORT $LN46@SearchFile
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL11@SearchFile
$LN51@SearchFile:

; 637  :                     }
; 638  : #ifdef DEBUG_OUT
; 639  :                     else
; 640  :                         DebugMsg1(("SearchFile(): fopen(%s) failed\n", fullpath ));
; 641  : #endif
; 642  :                 }
; 643  :                 break;
; 644  :             }
; 645  :         }
; 646  :     }
; 647  :     if ( file == NULL ) {
; 648  :         fullpath[0] = NULLC;
; 649  :         file = fopen( path, "rb" );

	lea	rdx, OFFSET FLAT:$SG5625
	mov	rcx, rdi
	mov	BYTE PTR fullpath$[rsp], 0
	call	fopen

; 650  :         DebugMsg1(("SearchFile(): fopen(%s)=%X\n", path, file ));
; 651  : 
; 652  :         /* if the file isn't found yet and include paths have been set,
; 653  :          * and NO absolute path is given, then search include dirs
; 654  :          */
; 655  :         if( file == NULL && ModuleInfo.g.IncludePath != NULL && !isabs ) {

	test	rax, rax
	mov	rbx, rax
	jne	$LN2@SearchFile
	cmp	QWORD PTR ModuleInfo+176, rax
	je	SHORT $LN3@SearchFile
	test	sil, sil
	jne	SHORT $LN3@SearchFile

; 656  :             if ( file = open_file_in_include_path( path, fullpath ) ) {

	lea	rdx, QWORD PTR fullpath$[rsp]
	mov	rcx, rdi
	call	open_file_in_include_path
	test	rax, rax
	mov	rbx, rax
	je	SHORT $LN50@SearchFile

; 657  :                 DebugMsg1(("SearchFile(): open_file_in_include_path(%s)=%X [%s]\n", path, file, fullpath ));
; 658  :                 path = fullpath;

	lea	rdi, QWORD PTR fullpath$[rsp]
$LN3@SearchFile:

; 659  :             }
; 660  : #ifdef DEBUG_OUT
; 661  :             else
; 662  :                 DebugMsg1(("SearchFile(): open_file_in_include_path(%s)=NULL\n", path ));
; 663  : #endif
; 664  :         }
; 665  :         if( file == NULL ) {

	test	rbx, rbx
	jne	$LN2@SearchFile
$LN50@SearchFile:

; 666  :             EmitErr( CANNOT_OPEN_FILE, path, ErrnoStr() );

	call	ErrnoStr
	mov	rdx, rdi
	mov	ecx, 106				; 0000006aH
	mov	r8, rax
	call	EmitErr

; 667  :             return( NULL );

	xor	eax, eax
	jmp	$LN13@SearchFile
$LN15@SearchFile:

; 609  : 
; 610  :     /* if no absolute path is given, then search in the directory
; 611  :      * of the current source file first!
; 612  :      * v2.11: various changes because field fullpath has been removed.
; 613  :      */
; 614  : 
; 615  :     isabs = ISABS( path );

	mov	sil, 1

; 616  :     //if ( dir[0] != '\\' && dir[0] != '/' ) {
; 617  :     if ( !isabs ) {

	jmp	SHORT $LN51@SearchFile
$LN46@SearchFile:

; 620  :                 const char  *fn2;
; 621  :                 char        *src;
; 622  :                 //_splitpath( GetFName( fl->srcfile )->fname, drive2, dir2, NULL, NULL );
; 623  :                 //DebugMsg1(("SearchFile(): curr src=%s, split into drive=%s, dir=%s\n", GetFName( fl->srcfile)->fname, drive2, dir2 ));
; 624  :                 src = GetFName( fl->srcfile )->fname;

	movzx	ecx, WORD PTR [rax+10]
	mov	rax, QWORD PTR ModuleInfo+160
	mov	r9, QWORD PTR [rax+rcx*8]

; 625  :                 fn2 = GetFNamePart( src );

	mov	rcx, r9
	mov	rdx, r9
	movzx	eax, BYTE PTR [r9]
	test	al, al
	je	$LN51@SearchFile
$LL33@SearchFile:
	cmp	al, 47					; 0000002fH
	je	SHORT $LN29@SearchFile
	cmp	al, 92					; 0000005cH
	je	SHORT $LN29@SearchFile
	cmp	al, 58					; 0000003aH
	jne	SHORT $LN32@SearchFile
$LN29@SearchFile:
	lea	rdx, QWORD PTR [rcx+1]
$LN32@SearchFile:
	mov	al, BYTE PTR [rcx+1]
	inc	rcx
	test	al, al
	jne	SHORT $LL33@SearchFile

; 626  :                 if ( fn2 != src ) {

	cmp	rdx, r9
	je	$LN51@SearchFile

; 627  :                     int i = fn2 - src;

	sub	edx, r9d

; 628  :                     /* v2.10: if there's a directory part, add it to the directory part of the current file.
; 629  :                      * fixme: check that both parts won't exceed FILENAME_MAX!
; 630  :                      * fixme: 'path' is relative, but it may contain a drive letter!
; 631  :                      */
; 632  :                     memcpy( fullpath, src, i );

	lea	rcx, QWORD PTR fullpath$[rsp]
	movsxd	rbx, edx
	mov	rdx, r9
	mov	r8, rbx
	call	memcpy

; 633  :                     strcpy( fullpath + i, path );

	sub	rbx, rdi
	mov	r11, rdi
	lea	rcx, QWORD PTR fullpath$[rsp+rbx]
	npad	11
$LL19@SearchFile:
	movzx	eax, BYTE PTR [r11]
	inc	r11
	test	al, al
	mov	BYTE PTR [rcx+r11-1], al
	jne	SHORT $LL19@SearchFile

; 634  :                     if ( file = fopen( fullpath, "rb" ) ) {

	lea	rdx, OFFSET FLAT:$SG5622
	lea	rcx, QWORD PTR fullpath$[rsp]
	call	fopen
	test	rax, rax
	mov	rbx, rax
	je	$LN51@SearchFile

; 635  :                         DebugMsg1(("SearchFile(): file found, fopen(%s)=%X\n", fullpath, file ));
; 636  :                         path = fullpath;

	lea	rdi, QWORD PTR fullpath$[rsp]
$LN2@SearchFile:

; 668  :         }
; 669  :     }
; 670  :     /* is the file to be added to the file stack?
; 671  :      * assembly files usually are, but binary files ( INCBIN ) aren't.
; 672  :      */
; 673  :     if ( queue ) {

	test	bpl, bpl
	je	SHORT $LN1@SearchFile

; 674  :         fl = PushSrcItem( SIT_FILE, file );

	mov	rsi, QWORD PTR SrcFree
	test	rsi, rsi
	je	SHORT $LN37@SearchFile
	mov	rax, QWORD PTR [rsi]
	mov	QWORD PTR SrcFree, rax
	jmp	SHORT $LN36@SearchFile
$LN37@SearchFile:
	mov	ecx, 32					; 00000020H
	call	LclAlloc
	mov	rsi, rax
$LN36@SearchFile:
	mov	rcx, QWORD PTR ModuleInfo+200
	mov	QWORD PTR [rsi], rcx
	mov	QWORD PTR ModuleInfo+200, rsi

; 675  :         fl->srcfile = AddFile( path );

	mov	rcx, rdi
	mov	BYTE PTR [rsi+8], 0
	mov	QWORD PTR [rsi+16], rbx
	mov	DWORD PTR [rsi+24], 0
	call	AddFile
	mov	WORD PTR [rsi+10], ax

; 676  :         FileCur->string_ptr = GetFName( fl->srcfile )->fname;

	movzx	ecx, ax
	mov	rax, QWORD PTR ModuleInfo+160
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	rax, QWORD PTR FileCur
	mov	QWORD PTR [rax+16], rdx
$LN1@SearchFile:

; 677  : #if FILESEQ
; 678  :         if ( Options.line_numbers && Parse_Pass == PASS_1 )
; 679  :             AddFileSeq( fl->srcfile );
; 680  : #endif
; 681  :     }
; 682  :     return( file );

	mov	rax, rbx
$LN13@SearchFile:
	mov	rdi, QWORD PTR [rsp+344]
	mov	rsi, QWORD PTR [rsp+336]
	mov	rbp, QWORD PTR [rsp+328]
	mov	rbx, QWORD PTR [rsp+320]

; 683  : }

	add	rsp, 312				; 00000138H
	ret	0
SearchFile ENDP
_TEXT	ENDS
PUBLIC	GetTextLine
EXTRN	fill_placeholders:NEAR
xdata	SEGMENT
$unwind$GetTextLine DD 051501H
	DD	0a6415H
	DD	083409H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$GetTextLine DD @imagerel($LN33#)
	DD	@imagerel($LN33#+34)
	DD	@imagerel($unwind$GetTextLine#)
pdata	ENDS
xdata	SEGMENT
$chain$4$GetTextLine DD 061621H
	DD	06c416H
	DD	0b740eH
	DD	095405H
	DD	@imagerel($LN33#)
	DD	@imagerel($LN33#+34)
	DD	@imagerel($unwind$GetTextLine#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$GetTextLine DD @imagerel($LN33#+34)
	DD	@imagerel($LN33#+171)
	DD	@imagerel($chain$4$GetTextLine#)
pdata	ENDS
xdata	SEGMENT
$chain$5$GetTextLine DD 021H
	DD	@imagerel($LN33#)
	DD	@imagerel($LN33#+34)
	DD	@imagerel($unwind$GetTextLine#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$GetTextLine DD @imagerel($LN33#+171)
	DD	@imagerel($LN33#+277)
	DD	@imagerel($chain$5$GetTextLine#)
pdata	ENDS
xdata	SEGMENT
$chain$6$GetTextLine DD 060021H
	DD	06c400H
	DD	0b7400H
	DD	095400H
	DD	@imagerel($LN33#)
	DD	@imagerel($LN33#+34)
	DD	@imagerel($unwind$GetTextLine#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$GetTextLine DD @imagerel($LN33#+277)
	DD	@imagerel($LN33#+305)
	DD	@imagerel($chain$6$GetTextLine#)
pdata	ENDS
xdata	SEGMENT
$chain$7$GetTextLine DD 021H
	DD	@imagerel($LN33#)
	DD	@imagerel($LN33#+34)
	DD	@imagerel($unwind$GetTextLine#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$GetTextLine DD @imagerel($LN33#+305)
	DD	@imagerel($LN33#+497)
	DD	@imagerel($chain$7$GetTextLine#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buffer$ = 64
GetTextLine PROC NEAR

; 694  : {

$LN33:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR [rsp+64], rbx

; 695  :     struct src_item *curr = src_stack;

	mov	rbx, QWORD PTR ModuleInfo+200
	mov	QWORD PTR [rsp+80], rsi

; 696  : 
; 697  :     if ( curr->type == SIT_FILE ) {

	cmp	BYTE PTR [rbx+8], 0
	mov	rsi, rcx
	jne	$LN10@GetTextLin
	mov	QWORD PTR [rsp+72], rbp

; 698  : 
; 699  :         if( my_fgets( buffer, MAX_LINE_LEN, curr->file ) ) {

	mov	rbp, QWORD PTR [rbx+16]
	mov	QWORD PTR [rsp+88], rdi
	mov	rdi, rcx
	mov	QWORD PTR [rsp+48], r12
	lea	r12, QWORD PTR [rcx+1024]
	mov	rcx, rbp
	call	getc
	cmp	rdi, r12
	jae	SHORT $LN22@GetTextLin
	npad	4
$LL23@GetTextLin:
	cmp	eax, -1
	je	$LN17@GetTextLin
	cmp	eax, 10
	je	$LN18@GetTextLin
	cmp	eax, 13
	je	SHORT $LN19@GetTextLin
	cmp	eax, 26
	je	$LN17@GetTextLin
	mov	BYTE PTR [rdi], al
	inc	rdi
$LN19@GetTextLin:
	mov	rcx, rbp
	call	getc
	cmp	rdi, r12
	jb	SHORT $LL23@GetTextLin
$LN22@GetTextLin:
	mov	ecx, 61					; 0000003dH
	call	EmitErr
	mov	BYTE PTR [rdi-1], 0
	mov	rax, rsi
$LN24@GetTextLin:
	test	rax, rax
	mov	r12, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+72]

; 700  :             curr->line_num++;
; 701  : #ifdef DEBUG_OUT
; 702  :             if ( Parse_Pass == PASS_1 ) cntlines++;
; 703  : #endif
; 704  :             return( buffer );

	jne	$LN1@GetTextLin

; 705  :         }
; 706  :         DebugCmd( ModuleInfo.g.FNames[curr->srcfile].lines = curr->line_num );
; 707  :         DebugMsg1(("GetTextLine: ***** EOF file %s (idx=%u) *****\n", GetFName( curr->srcfile )->fname, curr->srcfile ));
; 708  :         /* don't close and remove main source file */
; 709  :         if ( curr->next ) {

	cmp	QWORD PTR [rbx], rax
	je	SHORT $LN8@GetTextLin

; 710  :             fclose( curr->file );

	mov	rcx, QWORD PTR [rbx+16]
	call	fclose

; 711  :             src_stack = curr->next;

	mov	r11, QWORD PTR [rbx]

; 712  :             curr->next = SrcFree;

	mov	rax, QWORD PTR SrcFree
	mov	QWORD PTR ModuleInfo+200, r11

; 713  :             SrcFree = curr;

	mov	QWORD PTR SrcFree, rbx
	mov	QWORD PTR [rbx], rax
$LN8@GetTextLin:

; 714  :         }
; 715  :         /* update value of @FileCur variable */
; 716  :         for( curr = src_stack; curr->type != SIT_FILE; curr = curr->next );

	mov	rax, QWORD PTR ModuleInfo+200
	cmp	BYTE PTR [rax+8], 0
	je	SHORT $LN5@GetTextLin
$LL7@GetTextLin:
	mov	rax, QWORD PTR [rax]
	cmp	BYTE PTR [rax+8], 0
	jne	SHORT $LL7@GetTextLin
$LN5@GetTextLin:

; 717  :         FileCur->string_ptr = GetFName( curr->srcfile)->fname;

	movzx	ecx, WORD PTR [rax+10]
	mov	rax, QWORD PTR ModuleInfo+160
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	rax, QWORD PTR FileCur
	mov	QWORD PTR [rax+16], rdx

; 745  :     }
; 746  : 
; 747  :     return( NULL ); /* end of file or macro reached */

	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+64]

; 748  : }

	add	rsp, 56					; 00000038H
	ret	0

; 698  : 
; 699  :         if( my_fgets( buffer, MAX_LINE_LEN, curr->file ) ) {

$LN18@GetTextLin:
	mov	BYTE PTR [rdi], 0
	mov	rax, rsi
	jmp	$LN24@GetTextLin
$LN17@GetTextLin:
	xor	eax, eax
	cmp	rdi, rsi
	mov	BYTE PTR [rdi], 0
	cmova	rax, rsi
	jmp	$LN24@GetTextLin
$LN10@GetTextLin:

; 718  : #if FILESEQ
; 719  :         if ( Options.line_numbers && Parse_Pass == PASS_1 )
; 720  :             AddFileSeq( curr->srcfile );
; 721  : #endif
; 722  : 
; 723  :     } else {
; 724  : 
; 725  :         curr->mi->currline = ( curr->mi->currline ? curr->mi->currline->next : curr->mi->startline );

	mov	rcx, QWORD PTR [rbx+16]
	cmp	QWORD PTR [rcx], 0
	je	SHORT $LN13@GetTextLin
	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax]
	jmp	SHORT $LN14@GetTextLin
$LN13@GetTextLin:
	mov	rdx, QWORD PTR [rcx+8]
$LN14@GetTextLin:
	mov	QWORD PTR [rcx], rdx

; 726  :         if ( curr->mi->currline ) {

	mov	r8, QWORD PTR [rbx+16]
	cmp	QWORD PTR [r8], 0
	je	SHORT $LN3@GetTextLin

; 727  :             /* if line contains placeholders, replace them by current values */
; 728  :             if ( curr->mi->currline->ph_count ) {

	mov	rcx, QWORD PTR [r8]
	cmp	BYTE PTR [rcx+8], 0
	je	SHORT $LN2@GetTextLin

; 729  :                 fill_placeholders( buffer,
; 730  :                                   curr->mi->currline->line,
; 731  :                                   curr->mi->parmcnt,
; 732  :                                   curr->mi->localstart, curr->mi->parm_array );

	mov	rax, QWORD PTR [r8+24]
	mov	r9d, DWORD PTR [r8+16]
	mov	r8d, DWORD PTR [r8+40]
	lea	rdx, QWORD PTR [rcx+9]
	mov	rcx, rsi
	mov	QWORD PTR [rsp+32], rax
	call	fill_placeholders

; 735  :             }
; 736  :             curr->line_num++;

	inc	DWORD PTR [rbx+24]

; 737  : #ifdef DEBUG_OUT
; 738  :             if ( Parse_Pass == PASS_1 ) cntlines++;
; 739  : #endif
; 740  :             return( buffer );

	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+64]

; 748  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN2@GetTextLin:

; 733  :             } else {
; 734  :                 strcpy( buffer, curr->mi->currline->line );

	add	rcx, 9
	mov	rdx, rsi
	npad	10
$LL15@GetTextLin:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL15@GetTextLin
$LN1@GetTextLin:

; 735  :             }
; 736  :             curr->line_num++;

	inc	DWORD PTR [rbx+24]

; 737  : #ifdef DEBUG_OUT
; 738  :             if ( Parse_Pass == PASS_1 ) cntlines++;
; 739  : #endif
; 740  :             return( buffer );

	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+64]

; 748  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN3@GetTextLin:

; 741  :         }
; 742  :         src_stack = curr->next;

	mov	rax, QWORD PTR [rbx]
	mov	rsi, QWORD PTR [rsp+80]
	mov	QWORD PTR ModuleInfo+200, rax

; 743  :         curr->next = SrcFree;

	mov	rax, QWORD PTR SrcFree

; 744  :         SrcFree = curr;

	mov	QWORD PTR SrcFree, rbx
	mov	QWORD PTR [rbx], rax
	mov	rbx, QWORD PTR [rsp+64]

; 745  :     }
; 746  : 
; 747  :     return( NULL ); /* end of file or macro reached */

	xor	eax, eax

; 748  : }

	add	rsp, 56					; 00000038H
	ret	0
GetTextLine ENDP
_TEXT	ENDS
PUBLIC	AddStringToIncludePath
xdata	SEGMENT
$unwind$AddStringToIncludePath DD 053501H
	DD	097435H
	DD	073409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$AddStringToIncludePath DD @imagerel($LN17#)
	DD	@imagerel($LN17#+84)
	DD	@imagerel($unwind$AddStringToIncludePath#)
pdata	ENDS
xdata	SEGMENT
$chain$2$AddStringToIncludePath DD 020521H
	DD	086405H
	DD	@imagerel($LN17#)
	DD	@imagerel($LN17#+84)
	DD	@imagerel($unwind$AddStringToIncludePath#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$AddStringToIncludePath DD @imagerel($LN17#+84)
	DD	@imagerel($LN17#+164)
	DD	@imagerel($chain$2$AddStringToIncludePath#)
pdata	ENDS
xdata	SEGMENT
$chain$4$AddStringToIncludePath DD 020021H
	DD	086400H
	DD	@imagerel($LN17#)
	DD	@imagerel($LN17#+84)
	DD	@imagerel($unwind$AddStringToIncludePath#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$AddStringToIncludePath DD @imagerel($LN17#+164)
	DD	@imagerel($LN17#+332)
	DD	@imagerel($chain$4$AddStringToIncludePath#)
pdata	ENDS
xdata	SEGMENT
$chain$5$AddStringToIncludePath DD 021H
	DD	@imagerel($LN17#)
	DD	@imagerel($LN17#+84)
	DD	@imagerel($unwind$AddStringToIncludePath#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$AddStringToIncludePath DD @imagerel($LN17#+332)
	DD	@imagerel($LN17#+347)
	DD	@imagerel($chain$5$AddStringToIncludePath#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
string$ = 48
AddStringToIncludePath PROC NEAR

; 757  : {

$LN17:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+56], rbx
	mov	rbx, rcx

; 758  :     char *tmp;
; 759  :     int len;
; 760  : 
; 761  :     DebugMsg(("AddStringToIncludePath(%s) enter\n", string ));
; 762  :     while( isspace( *string ) )

	movsx	ecx, BYTE PTR [rcx]
	call	isspace
	test	eax, eax
	je	SHORT $LN4@AddStringT
	npad	8
$LL5@AddStringT:
	movsx	ecx, BYTE PTR [rbx+1]

; 763  :         string++;

	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL5@AddStringT
$LN4@AddStringT:
	mov	QWORD PTR [rsp+72], rdi

; 764  :     len = strlen( string );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	dec	rcx

; 765  :     if ( len == 0 )

	test	ecx, ecx
	mov	rdx, rcx
	je	$LN1@AddStringT
	mov	QWORD PTR [rsp+64], rsi

; 766  :         return;
; 767  :     if( ModuleInfo.g.IncludePath == NULL ) {

	mov	rsi, QWORD PTR ModuleInfo+176
	test	rsi, rsi
	jne	SHORT $LN2@AddStringT

; 768  :         ModuleInfo.g.IncludePath = MemAlloc( len + 1 );

	lea	eax, DWORD PTR [rcx+1]
	movsxd	rcx, eax
	call	MemAlloc
	mov	QWORD PTR ModuleInfo+176, rax
	npad	9
$LL8@AddStringT:

; 769  :         strcpy( ModuleInfo.g.IncludePath, string );

	movzx	ecx, BYTE PTR [rbx]
	inc	rax
	inc	rbx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL8@AddStringT
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+56]

; 778  :     }
; 779  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@AddStringT:

; 770  :     } else {
; 771  :         tmp = ModuleInfo.g.IncludePath;
; 772  :         ModuleInfo.g.IncludePath = MemAlloc( strlen( tmp ) + sizeof( INC_PATH_DELIM_STR ) +
; 773  :                                 len + 1 );

	mov	rcx, -1
	mov	rdi, rsi
	repne scasb
	movsxd	rax, edx
	not	rcx
	lea	rcx, QWORD PTR [rcx+rax+2]
	call	MemAlloc

; 774  :         strcpy( ModuleInfo.g.IncludePath, tmp );

	mov	rdx, rsi
	mov	QWORD PTR ModuleInfo+176, rax
	npad	6
$LL9@AddStringT:
	movzx	ecx, BYTE PTR [rdx]
	inc	rax
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL9@AddStringT

; 775  :         strcat( ModuleInfo.g.IncludePath, INC_PATH_DELIM_STR );

	mov	rdi, QWORD PTR ModuleInfo+176
	xor	eax, eax
	mov	rcx, -1
	repne scasb
	xor	edx, edx
	lea	r8, OFFSET FLAT:$SG5661
	npad	5
$LL15@AddStringT:
	movzx	eax, BYTE PTR [r8+rdx]
	inc	rdx
	test	al, al
	mov	BYTE PTR [rdi+rdx-2], al
	jne	SHORT $LL15@AddStringT

; 776  :         strcat( ModuleInfo.g.IncludePath, string );

	mov	rdi, QWORD PTR ModuleInfo+176
	xor	eax, eax
	mov	rcx, -1
	repne scasb
	xor	edx, edx
	npad	12
$LL14@AddStringT:
	movzx	eax, BYTE PTR [rbx+rdx]
	inc	rdx
	test	al, al
	mov	BYTE PTR [rdi+rdx-2], al
	jne	SHORT $LL14@AddStringT

; 777  :         MemFree( tmp );

	mov	rcx, rsi
	call	MemFree
	mov	rsi, QWORD PTR [rsp+64]
$LN1@AddStringT:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+56]

; 778  :     }
; 779  : }

	add	rsp, 40					; 00000028H
	ret	0
AddStringToIncludePath ENDP
_TEXT	ENDS
PUBLIC	PushInputStatus
xdata	SEGMENT
$unwind$PushInputStatus DD 010201H
	DD	07002H
xdata	ENDS
pdata	SEGMENT
$pdata$PushInputStatus DD @imagerel($LN7#)
	DD	@imagerel($LN7#+226)
	DD	@imagerel($unwind$PushInputStatus#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
oldstat$ = 16
PushInputStatus PROC NEAR

; 825  : {

$LN7:
	push	rdi

; 826  :     oldstat->token_stringbuf = token_stringbuf;

	mov	rax, QWORD PTR token_stringbuf
	mov	r8, rcx
	mov	QWORD PTR [rcx], rax

; 827  :     oldstat->token_count = Token_Count;

	mov	eax, DWORD PTR ModuleInfo+496
	mov	DWORD PTR [rcx+24], eax

; 828  :     oldstat->currsource = CurrSource;

	mov	rax, QWORD PTR ModuleInfo+464
	mov	QWORD PTR [rcx+8], rax

; 829  :     /* if there's a comment, attach it to current source */
; 830  :     if ( ModuleInfo.CurrComment ) {

	cmp	QWORD PTR ModuleInfo+472, 0
	je	SHORT $LN2@PushInputS

; 831  :         int i = strlen( CurrSource );

	mov	rdx, QWORD PTR ModuleInfo+464
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rdx
	repne scasb
	not	rcx
	dec	rcx

; 832  :         oldstat->CurrComment = CurrSource + i;

	movsxd	rcx, ecx
	add	rcx, rdx
	mov	QWORD PTR [r8+16], rcx

; 833  :         strcpy( oldstat->CurrComment, ModuleInfo.CurrComment );

	mov	rdx, QWORD PTR ModuleInfo+472
	npad	7
$LL5@PushInputS:
	movzx	eax, BYTE PTR [rdx]
	inc	rcx
	inc	rdx
	test	al, al
	mov	BYTE PTR [rcx-1], al
	jne	SHORT $LL5@PushInputS

; 834  :     } else

	jmp	SHORT $LN1@PushInputS
$LN2@PushInputS:

; 835  :         oldstat->CurrComment = NULL;

	mov	QWORD PTR [rcx+16], 0
$LN1@PushInputS:

; 836  :     oldstat->line_flags = ModuleInfo.line_flags; /* v2.08 */

	movzx	eax, BYTE PTR ModuleInfo+398

; 837  : #ifdef __I86__
; 838  :     oldstat->tokenarray = ModuleInfo.tokenarray;
; 839  :     oldstat->stringbufferend = StringBufferEnd;
; 840  :     CurrSource = MemAlloc( MAX_LINE_LEN + SIZE_TOKENARRAY + SIZE_STRINGBUFFER );
; 841  :     ModuleInfo.tokenarray = (struct asm_tok *)( CurrSource + MAX_LINE_LEN );
; 842  :     token_stringbuf = CurrSource + MAX_LINE_LEN + SIZE_TOKENARRAY;
; 843  : #else
; 844  :     token_stringbuf = StringBufferEnd;
; 845  :     ModuleInfo.tokenarray += Token_Count + 1;
; 846  :     CurrSource = GetAlignedPointer( CurrSource, strlen( CurrSource ) );

	mov	rcx, -1
	mov	BYTE PTR [r8+28], al
	mov	rax, QWORD PTR ModuleInfo+488
	mov	r8, QWORD PTR ModuleInfo+480
	mov	QWORD PTR token_stringbuf, rax
	mov	eax, DWORD PTR ModuleInfo+496
	inc	eax
	movsxd	rdx, eax
	xor	eax, eax
	shl	rdx, 5
	add	r8, rdx
	mov	rdx, QWORD PTR ModuleInfo+464
	mov	rdi, rdx
	mov	QWORD PTR ModuleInfo+480, r8
	repne scasb

; 847  :     /*myassert( ( CurrSource + MAX_LINE_LEN ) <= (char *)ModuleInfo.tokenarray );*/
; 848  :     /*myassert( ( ModuleInfo.tokenarray + sizeof( struct asm_tok ) * MAX_TOKEN ) <= end_tokenarray ); */
; 849  :     /*myassert( ( token_stringbuf + 2 * MAX_LINE_LEN ) <= end_stringbuf ); */
; 850  : #endif
; 851  :     DebugMsg1(("PushInputStatus() stringbuf-tokencnt-currsrc old=%X-%u-%X new=%X-%X-%X\n",
; 852  :                oldstat->token_stringbuf, oldstat->token_count, oldstat->currsource,
; 853  :                token_stringbuf, ModuleInfo.tokenarray, CurrSource ));
; 854  :     return( ModuleInfo.tokenarray );

	mov	rax, r8
	not	rcx
	add	rcx, 7
	and	rcx, -8
	add	rdx, rcx
	mov	QWORD PTR ModuleInfo+464, rdx

; 855  : }

	pop	rdi
	ret	0
PushInputStatus ENDP
_TEXT	ENDS
PUBLIC	PopInputStatus
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
newstat$ = 8
PopInputStatus PROC NEAR

; 860  :     DebugMsg1(("PopInputStatus() old=%X-%u-%X new=%X-%u-%X\n",
; 861  :                token_stringbuf, Token_Count, CurrSource,
; 862  :                newstat->token_stringbuf, newstat->token_count, newstat->currsource ));
; 863  : #ifdef __I86__
; 864  :     MemFree( CurrSource );
; 865  : #else
; 866  :     StringBufferEnd = token_stringbuf;

	mov	rax, QWORD PTR token_stringbuf
	mov	r8, rcx
	mov	QWORD PTR ModuleInfo+488, rax

; 867  : #endif
; 868  :     token_stringbuf = newstat->token_stringbuf;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR token_stringbuf, rax

; 869  :     Token_Count = newstat->token_count;

	mov	ecx, DWORD PTR [rcx+24]
	mov	DWORD PTR ModuleInfo+496, ecx

; 870  :     CurrSource = newstat->currsource;

	mov	rax, QWORD PTR [r8+8]
	mov	QWORD PTR ModuleInfo+464, rax

; 871  :     if ( newstat->CurrComment ) {

	cmp	QWORD PTR [r8+16], 0
	je	SHORT $LN2@PopInputSt

; 872  :         ModuleInfo.CurrComment = commentbuffer;

	mov	rdx, QWORD PTR commentbuffer
	mov	QWORD PTR ModuleInfo+472, rdx

; 873  :         strcpy( ModuleInfo.CurrComment, newstat->CurrComment );

	mov	rcx, QWORD PTR [r8+16]
	npad	8
$LL5@PopInputSt:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL5@PopInputSt

; 874  :         *newstat->CurrComment = NULLC;

	mov	rax, QWORD PTR [r8+16]
	mov	BYTE PTR [rax], 0

; 875  :     } else

	mov	ecx, DWORD PTR ModuleInfo+496
	jmp	SHORT $LN1@PopInputSt
$LN2@PopInputSt:

; 876  :         ModuleInfo.CurrComment = NULL;

	mov	QWORD PTR ModuleInfo+472, 0
$LN1@PopInputSt:

; 877  : #ifdef __I86__
; 878  :     StringBufferEnd = newstat->stringbufferend;
; 879  :     ModuleInfo.tokenarray = newstat->tokenarray;
; 880  : #else
; 881  :     ModuleInfo.tokenarray -= Token_Count + 1;

	lea	eax, DWORD PTR [rcx+1]
	movsxd	rcx, eax
	neg	rcx
	shl	rcx, 5
	add	QWORD PTR ModuleInfo+480, rcx

; 882  : #endif
; 883  :     ModuleInfo.line_flags = newstat->line_flags; /* v2.08 */

	movzx	eax, BYTE PTR [r8+28]
	mov	BYTE PTR ModuleInfo+398, al

; 884  :     return;
; 885  : }

	ret	0
PopInputStatus ENDP
_TEXT	ENDS
PUBLIC	InputInit
_BSS	SEGMENT
srclinebuffer DQ 01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$InputInit DD 051e01H
	DD	09741eH
	DD	08340eH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$InputInit DD @imagerel($LN9#)
	DD	@imagerel($LN9#+224)
	DD	@imagerel($unwind$InputInit#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
InputInit PROC NEAR

; 891  : {

$LN9:
	sub	rsp, 40					; 00000028H

; 892  :     struct src_item *fl;
; 893  : #if 0
; 894  :     char        path[FILENAME_MAX];
; 895  :     char        drive[_MAX_DRIVE];
; 896  :     char        dir[_MAX_DIR];
; 897  : #endif
; 898  : 
; 899  :     DebugMsg(( "InputInit() enter\n" ));
; 900  :     //ModuleInfo.g.cnt_fnames = 0;
; 901  :     //ModuleInfo.g.FNames = NULL;
; 902  :     //IncludePath = NULL;
; 903  :     //src_stack = NULL;
; 904  :     SrcFree = NULL; /* v2.11 */
; 905  : #if FILESEQ
; 906  :     FileSeq.head = NULL;
; 907  : #endif
; 908  : #ifdef DEBUG_OUT
; 909  :     cntppl0 = 0;
; 910  :     cntppl1 = 0;
; 911  :     cntppl2 = 0;
; 912  :     cnttok0 = 0;
; 913  :     cnttok1 = 0;
; 914  :     cntflines = 0;
; 915  :     cntlines = 0;
; 916  : #endif
; 917  : 
; 918  :     /* add path of main module to the include path.
; 919  :      * v2.12: unnecessary since v2.10, since the directory part of the
; 920  :      * current source is added if a file is to be included; see SearchFile().
; 921  :      */
; 922  :     //_splitpath( CurrFName[ASM], drive, dir, NULL, NULL );
; 923  :     //if ( drive[0] || dir[0] ) {
; 924  :     //    _makepath( path, drive, dir, NULL, NULL );
; 925  :     //    AddStringToIncludePath( path );
; 926  :     //}
; 927  : 
; 928  :     srclinebuffer = LclAlloc( SIZE_SRCLINES + SIZE_TOKENARRAY + SIZE_STRINGBUFFER );

	mov	ecx, 1311744				; 00140400H
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR SrcFree, 0
	mov	QWORD PTR [rsp+72], rdi
	call	LclAlloc

; 929  :     /* the comment buffer is at the end of the source line buffer */
; 930  :     commentbuffer = srclinebuffer + SIZE_SRCLINES - MAX_LINE_LEN;
; 931  :     /* behind the comment buffer is the token buffer */
; 932  :     ModuleInfo.tokenarray = (struct asm_tok *)( srclinebuffer + SIZE_SRCLINES );
; 933  :     token_stringbuf = srclinebuffer + SIZE_SRCLINES + SIZE_TOKENARRAY;
; 934  : #ifdef DEBUG_OUT
; 935  :     end_tokenarray = (struct asm_tok *)token_stringbuf;
; 936  :     end_stringbuf = token_stringbuf + SIZE_STRINGBUFFER;
; 937  :     DebugMsg(( "InputInit: srclinebuffer=%p, tokenarray=%p, token_stringbuf=%p end_stringbuf=%p\n", srclinebuffer, ModuleInfo.tokenarray, token_stringbuf, end_stringbuf ));
; 938  : #endif
; 939  : 
; 940  :     fl = PushSrcItem( SIT_FILE, CurrFile[ASM] );

	mov	rbx, QWORD PTR SrcFree
	mov	rdi, QWORD PTR ModuleInfo+96
	lea	rcx, QWORD PTR [rax+131072]
	mov	QWORD PTR srclinebuffer, rax
	mov	QWORD PTR commentbuffer, rcx
	lea	rcx, QWORD PTR [rax+132096]
	add	rax, 1180672				; 00120400H
	test	rbx, rbx
	mov	QWORD PTR ModuleInfo+480, rcx
	mov	QWORD PTR token_stringbuf, rax
	je	SHORT $LN4@InputInit
	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR SrcFree, rax
	jmp	SHORT $LN3@InputInit
$LN4@InputInit:
	mov	ecx, 32					; 00000020H
	call	LclAlloc
	mov	rbx, rax
$LN3@InputInit:
	mov	rcx, QWORD PTR ModuleInfo+200
	mov	QWORD PTR [rbx], rcx
	mov	QWORD PTR ModuleInfo+200, rbx
	mov	BYTE PTR [rbx+8], 0
	mov	QWORD PTR [rbx+16], rdi
	mov	DWORD PTR [rbx+24], 0

; 941  :     fl->srcfile = ModuleInfo.srcfile = AddFile( CurrFName[ASM] );

	mov	rcx, QWORD PTR ModuleInfo+128
	call	AddFile
	mov	rdi, QWORD PTR [rsp+72]
	mov	DWORD PTR ModuleInfo+428, eax
	mov	WORD PTR [rbx+10], ax
	mov	rbx, QWORD PTR [rsp+64]
	movzx	ecx, ax

; 942  :     /* setting a function pointer won't work for text macros! */
; 943  :     //FileCur->sfunc_ptr = &GetFileCur;
; 944  :     FileCur->string_ptr = GetFName( fl->srcfile )->fname;

	movzx	ecx, ax
	mov	rax, QWORD PTR ModuleInfo+160
	mov	rdx, QWORD PTR [rax+rcx*8]
	mov	rax, QWORD PTR FileCur
	mov	QWORD PTR [rax+16], rdx

; 945  : 
; 946  :     DebugMsg(( "InputInit() exit\n" ));
; 947  : }

	add	rsp, 40					; 00000028H
	ret	0
InputInit ENDP
_TEXT	ENDS
PUBLIC	InputPassInit
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
InputPassInit PROC NEAR

; 954  :     DebugMsg(( "InputPassInit() enter\n" ));
; 955  :     src_stack->line_num = 0;

	mov	rax, QWORD PTR ModuleInfo+200
	mov	DWORD PTR [rax+24], 0

; 956  :     //inside_comment = NULLC;
; 957  :     CurrSource = srclinebuffer;

	mov	rax, QWORD PTR srclinebuffer
	mov	QWORD PTR ModuleInfo+464, rax

; 958  :     *CurrSource = NULLC;

	mov	BYTE PTR [rax], 0

; 959  :     StringBufferEnd = token_stringbuf;

	mov	rax, QWORD PTR token_stringbuf
	mov	QWORD PTR ModuleInfo+488, rax

; 960  :     return;
; 961  : }

	ret	0
InputPassInit ENDP
_TEXT	ENDS
PUBLIC	InputFini
xdata	SEGMENT
$unwind$InputFini DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$InputFini DD @imagerel($LN8#)
	DD	@imagerel($LN8#+69)
	DD	@imagerel($unwind$InputFini#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
InputFini PROC NEAR

; 967  : {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 968  : #ifdef DEBUG_OUT
; 969  :     int   i;
; 970  : 
; 971  :     /* for the main source file, lines usually isn't filled yet */
; 972  :     if ( ModuleInfo.g.FNames )
; 973  :         ModuleInfo.g.FNames[ModuleInfo.srcfile].lines = src_stack->line_num;
; 974  :     for( i = 0; i < ModuleInfo.g.cnt_fnames; i++ ) {
; 975  :         if ( Options.log_all_files ) {
; 976  :             if ( ModuleInfo.g.FNames[i].included > 1 )
; 977  :                 printf("%2u: %5u *%2u %s\n", i+1, ModuleInfo.g.FNames[i].lines, ModuleInfo.g.FNames[i].included, ModuleInfo.g.FNames[i].fname );
; 978  :             else
; 979  :                 printf("%2u: %5u     %s\n", i+1, ModuleInfo.g.FNames[i].lines, ModuleInfo.g.FNames[i].fname );
; 980  :         }
; 981  :         DebugMsg(( "InputFini: idx=%u name=%s\n", i, ModuleInfo.g.FNames[i].fname ));
; 982  :     }
; 983  : #endif
; 984  :     if ( ModuleInfo.g.IncludePath )

	mov	rcx, QWORD PTR ModuleInfo+176
	test	rcx, rcx
	je	SHORT $LN1@InputFini

; 985  :         MemFree( ModuleInfo.g.IncludePath );

	call	MemFree
$LN1@InputFini:

; 986  : 
; 987  :     /* free items in ModuleInfo.g.FNames ( and FreeFile, if FASTMEM==0 ) */
; 988  :     FreeFiles();

	mov	rcx, QWORD PTR ModuleInfo+160
	xor	ebx, ebx
	test	rcx, rcx
	mov	QWORD PTR ModuleInfo+200, rbx
	je	SHORT $LN7@InputFini
	call	MemFree
	mov	QWORD PTR ModuleInfo+160, rbx
$LN7@InputFini:

; 989  : #ifdef DEBUG_OUT
; 990  :     if ( Options.quiet == FALSE ) {
; 991  :         printf("lines read(files)/processed in pass one: %" I32_SPEC "u / %" I32_SPEC "u\n", cntflines, cntlines );
; 992  :         printf("invokations: PreprocessLine=%" I32_SPEC "u/%" I32_SPEC "u/%" I32_SPEC "u, Tokenize=%" I32_SPEC "u/%" I32_SPEC "u\n", cntppl0, cntppl1, cntppl2, cnttok0, cnttok1 );
; 993  :     }
; 994  : #endif
; 995  :     ModuleInfo.tokenarray = NULL;

	mov	QWORD PTR ModuleInfo+480, rbx

; 996  : #ifdef DEBUG_OUT
; 997  :     token_stringbuf = NULL;
; 998  :     StringBufferEnd = NULL;
; 999  :     commentbuffer = NULL;
; 1000 :     CurrSource = NULL;
; 1001 : #endif
; 1002 :     LclFree( srclinebuffer );
; 1003 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
InputFini ENDP
_TEXT	ENDS
END
