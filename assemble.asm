; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	MOVE_SIMD_QWORD
PUBLIC	MOVE_SIMD_DWORD
PUBLIC	MOVE_DOUBLE
PUBLIC	MOVE_SINGLE
PUBLIC	MOVE_UNALIGNED_INT
PUBLIC	MOVE_UNALIGNED_FLOAT
PUBLIC	MOVE_ALIGNED_INT
PUBLIC	MOVE_ALIGNED_FLOAT
PUBLIC	jmpenv
EXTRN	elf_init:NEAR
EXTRN	coff_init:NEAR
EXTRN	omf_init:NEAR
EXTRN	bin_init:NEAR
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	ModuleInfo:BYTE:0308H
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
_DATA	ENDS
_BSS	SEGMENT
jmpenv	DB	0100H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	Parse_Pass:DWORD
COMM	write_to_file:BYTE
COMM	LinnumQueue:BYTE:010H
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
formatoptions DQ FLAT:bin_init
	DW	00H
	DB	'BIN', 00H
	ORG $+2
	DQ	FLAT:omf_init
	DW	00H
	DB	'OMF', 00H
	ORG $+2
	DQ	FLAT:coff_init
	DW	0e12H
	DB	'COFF', 00H
	ORG $+1
	DQ	FLAT:elf_init
	DW	0f00H
	DB	'ELF', 00H
	ORG $+2
CONST	ENDS
_DATA	SEGMENT
$SG6144	DB	'vmovaps', 00H
MOVE_ALIGNED_FLOAT DQ FLAT:$SG6144
$SG6145	DB	'vmovdqa', 00H
MOVE_ALIGNED_INT DQ FLAT:$SG6145
$SG6146	DB	'vmovups', 00H
MOVE_UNALIGNED_FLOAT DQ FLAT:$SG6146
$SG6147	DB	'vmovdqu', 00H
MOVE_UNALIGNED_INT DQ FLAT:$SG6147
$SG6148	DB	'vmovss', 00H
	ORG $+1
MOVE_SINGLE DQ	FLAT:$SG6148
$SG6149	DB	'vmovsd', 00H
	ORG $+1
MOVE_DOUBLE DQ	FLAT:$SG6149
$SG6150	DB	'vmovd', 00H
	ORG $+2
MOVE_SIMD_DWORD DQ FLAT:$SG6150
$SG6151	DB	'vmovq', 00H
	ORG $+2
MOVE_SIMD_QWORD DQ FLAT:$SG6151
$SG6165	DB	'_TEXT', 00H
	ORG $+2
$SG6166	DB	'.text', 00H
	ORG $+2
$SG6167	DB	'_DATA', 00H
	ORG $+2
$SG6168	DB	'.data', 00H
	ORG $+2
$SG6169	DB	'CONST', 00H
	ORG $+2
$SG6170	DB	'.rdata', 00H
	ORG $+1
$SG6171	DB	'_BSS', 00H
	ORG $+3
$SG6172	DB	'.bss', 00H
_DATA	ENDS
CONST	SEGMENT
cst	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG6165
	DQ	FLAT:$SG6166
	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG6167
	DQ	FLAT:$SG6168
	DB	05H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG6169
	DQ	FLAT:$SG6170
	DB	04H
	DB	00H
	ORG $+6
	DQ	FLAT:$SG6171
	DQ	FLAT:$SG6172
stt	DD	01H
	DD	02H
	DD	02H
	DD	03H
CONST	ENDS
_DATA	SEGMENT
	ORG $+3
$SG6323	DB	'w', 00H
	ORG $+6
$SG6333	DB	'import ''%s''  %s.%s', 0aH, 00H
	ORG $+4
$SG6381	DB	'INCLUDE', 00H
?PrintEmptyLine@?1??WritePreprocessedLine@@9@9 DB 01H	; `WritePreprocessedLine'::`2'::PrintEmptyLine
	ORG $+3
$SG6392	DB	'%s', 0aH, 00H
$SG6395	DB	0aH, 00H
	ORG $+2
$SG6416	DB	'%r %s', 00H
	ORG $+2
$SG6520	DB	'rb', 00H
	ORG $+1
$SG6524	DB	'wb', 00H
	ORG $+1
$SG6528	DB	'wb', 00H
	ORG $+1
$SG6562	DB	'EXE', 00H
$SG6564	DB	'BIN', 00H
$SG6565	DB	'obj', 00H
$SG6567	DB	'lst', 00H
$SG6569	DB	'err', 00H
$SG6638	DB	'%s', 0aH, 00H
_DATA	ENDS
PUBLIC	ConvertSectionName
EXTRN	memcmp:NEAR
xdata	SEGMENT
$unwind$ConvertSectionName DD 0114001H
	DD	0d5440H
	DD	07f427H
	DD	08e423H
	DD	09d41fH
	DD	0ac41bH
	DD	0f7417H
	DD	0e640fH
	DD	0c340bH
	DD	0a207H
xdata	ENDS
pdata	SEGMENT
$pdata$ConvertSectionName DD @imagerel($LN18#)
	DD	@imagerel($LN18#+327)
	DD	@imagerel($unwind$ConvertSectionName#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\assemble.c
pdata	ENDS
_TEXT	SEGMENT
sym$ = 96
pst$ = 104
buffer$ = 112
ConvertSectionName PROC NEAR

; 181  : {

$LN18:
	mov	rax, rsp
	sub	rsp, 88					; 00000058H
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	rsi, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+32], rdi
	mov	QWORD PTR [rax-8], r12
	mov	QWORD PTR [rax-16], r13
	mov	QWORD PTR [rax-24], r14
	mov	QWORD PTR [rax-32], r15

; 182  :     int i;
; 183  : 
; 184  :     for ( i = 0; i < sizeof( cst ) / sizeof( cst[0] ); i++ ) {

	lea	r15, OFFSET FLAT:cst
	mov	r14, r8
	mov	r13, rdx
	mov	r12, rcx
	mov	rbx, r15
	xor	edi, edi
	mov	QWORD PTR [rax+16], rbp
$LL10@ConvertSec:

; 185  :         if ( memcmp( sym->name, cst[i].src, cst[i].len ) == 0 ) {

	movzx	ebp, BYTE PTR [rbx]
	mov	rdx, QWORD PTR [rbx+8]
	mov	r9d, 1
	mov	rcx, rsi
	mov	r8, rbp
	mov	DWORD PTR [rsp+32], 1
	call	memcmp
	test	eax, eax
	jne	SHORT $LN9@ConvertSec

; 186  :             if ( sym->name[cst[i].len] == NULLC || ( sym->name[cst[i].len] == '$' && ( cst[i].flags & CSF_GRPCHK ) ) ) {

	movzx	eax, BYTE PTR [rsi+rbp]
	test	al, al
	je	SHORT $LN5@ConvertSec
	cmp	al, 36					; 00000024H
	jne	SHORT $LN9@ConvertSec
	test	BYTE PTR [rbx+1], 1
	jne	SHORT $LN5@ConvertSec
$LN9@ConvertSec:

; 182  :     int i;
; 183  : 
; 184  :     for ( i = 0; i < sizeof( cst ) / sizeof( cst[0] ); i++ ) {

	inc	edi
	add	rbx, 24
	cmp	edi, 4
	jb	SHORT $LL10@ConvertSec

; 207  :             }
; 208  :         }
; 209  :     }
; 210  :     return( sym->name );

	mov	rax, rsi
$LN11@ConvertSec:
	mov	r15, QWORD PTR [rsp+56]
	mov	r14, QWORD PTR [rsp+64]
	mov	r13, QWORD PTR [rsp+72]
	mov	r12, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+96]

; 211  : }

	add	rsp, 88					; 00000058H
	ret	0
$LN5@ConvertSec:

; 187  : 
; 188  :                 if ( pst ) {

	test	r13, r13
	je	SHORT $LN2@ConvertSec

; 189  :                     if ( i == CSI_BSS && ( (struct dsym *)sym)->e.seginfo->bytes_written != 0 )

	cmp	edi, 3
	jne	SHORT $LN3@ConvertSec
	mov	rax, QWORD PTR [r12+104]
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN2@ConvertSec
$LN3@ConvertSec:

; 190  :                         ; /* don't set segment type to BSS if the segment contains initialized data */
; 191  :                     else
; 192  :                         *pst = stt[i];

	lea	rcx, OFFSET FLAT:stt
	movsxd	rax, edi
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR [r13], eax
$LN2@ConvertSec:

; 193  :                 }
; 194  : 
; 195  :                 if ( sym->name[cst[i].len] == NULLC ) {

	movsxd	rax, edi
	lea	rdi, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR [r12+8]
	movzx	ecx, BYTE PTR [r15+rdi*8]
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LN1@ConvertSec

; 196  : #if DJGPP_SUPPORT
; 197  :                     /* DJGPP won't be happy with .rdata segment name */
; 198  :                     if( ModuleInfo.sub_format == SFORMAT_DJGPP && i == CSI_CONST )
; 199  :                         return( ".const" );
; 200  : #endif
; 201  :                     return( (char *)cst[i].dst );

	mov	rax, QWORD PTR [r15+rdi*8+16]
	jmp	SHORT $LN11@ConvertSec
$LN1@ConvertSec:

; 202  :                 }
; 203  : 
; 204  :                 strcpy( buffer, cst[i].dst );

	mov	rcx, QWORD PTR [r15+rdi*8+16]
	mov	rdx, r14
	npad	3
$LL13@ConvertSec:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL13@ConvertSec

; 205  :                 strcat( buffer, sym->name+cst[i].len );

	movzx	edx, BYTE PTR [r15+rdi*8]
	xor	eax, eax
	mov	rcx, -1
	add	rdx, QWORD PTR [r12+8]
	mov	rdi, r14
	repne scasb
	xor	ecx, ecx
	npad	6
$LL17@ConvertSec:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL17@ConvertSec

; 206  :                 return( buffer );

	mov	rax, r14
	jmp	$LN11@ConvertSec
ConvertSectionName ENDP
_TEXT	ENDS
PUBLIC	OutputByte
EXTRN	omf_FlushCurrSeg:NEAR
EXTRN	Options:BYTE
xdata	SEGMENT
$unwind$OutputByte DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$OutputByte DD @imagerel($LN8#)
	DD	@imagerel($LN8#+190)
	DD	@imagerel($unwind$OutputByte#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
byte$ = 48
OutputByte PROC NEAR

; 219  : {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 220  :     if( write_to_file == TRUE ) {

	cmp	BYTE PTR write_to_file, 1
	movzx	ebx, cl
	jne	SHORT $LN5@OutputByte

; 221  :         uint_32 idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	r11, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [r11+104]
	add	r11, 104				; 00000068H
	mov	edx, DWORD PTR [rax+12]
	sub	edx, DWORD PTR [rax+8]

; 222  : #ifdef DEBUG_OUT
; 223  :         if ( CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc ) {
; 224  :             ;//_asm int 3;
; 225  :         }
; 226  : #endif
; 227  :         /**/myassert( CurrSeg->e.seginfo->current_loc >= CurrSeg->e.seginfo->start_loc );
; 228  :         if( Options.output_format == OFORMAT_OMF && idx >= MAX_LEDATA_THRESHOLD ) {

	cmp	DWORD PTR Options+156, 1
	jne	SHORT $LN4@OutputByte
	cmp	edx, 1014				; 000003f6H
	jb	SHORT $LN4@OutputByte

; 229  :             omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 230  :             idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	r11, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [r11+104]
	add	r11, 104				; 00000068H
	mov	edx, DWORD PTR [rax+12]
	sub	edx, DWORD PTR [rax+8]
$LN4@OutputByte:

; 231  :         }
; 232  :         //DebugMsg(("OutputByte: buff=%p, idx=%" I32_SPEC "X, byte=%X, codebuff[0]=%X\n", CurrSeg->e.seginfo->CodeBuffer, idx, byte, *CurrSeg->e.seginfo->CodeBuffer ));
; 233  :         CurrSeg->e.seginfo->CodeBuffer[idx] = byte;

	mov	rax, QWORD PTR [r11]
	mov	rax, QWORD PTR [rax+16]
	mov	BYTE PTR [rdx+rax], bl
	jmp	SHORT $LN2@OutputByte
$LN5@OutputByte:

; 234  :     }
; 235  : #if 1
; 236  :     /* check this in pass 1 only */
; 237  :     else if( CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc ) {

	mov	rdx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rdx+104]
	mov	eax, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rcx+12], eax
	jae	SHORT $LN2@OutputByte

; 238  :         DebugMsg(("OutputByte: segment start loc changed from %" I32_SPEC "Xh to %" I32_SPEC "Xh\n",
; 239  :                   CurrSeg->e.seginfo->start_loc,
; 240  :                   CurrSeg->e.seginfo->current_loc));
; 241  :         CurrSeg->e.seginfo->start_loc = CurrSeg->e.seginfo->current_loc;

	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rcx+8], eax
$LN2@OutputByte:

; 242  :     }
; 243  : #endif
; 244  :     CurrSeg->e.seginfo->current_loc++;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	inc	DWORD PTR [rcx+12]

; 245  :     CurrSeg->e.seginfo->bytes_written++;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	inc	DWORD PTR [rcx+24]

; 246  :     CurrSeg->e.seginfo->written = TRUE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	or	BYTE PTR [rcx+107], 32			; 00000020H

; 247  :     if( CurrSeg->e.seginfo->current_loc > CurrSeg->sym.max_offset )

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rcx+104]
	mov	edx, DWORD PTR [rax+12]
	cmp	edx, DWORD PTR [rcx+64]
	jbe	SHORT $LN1@OutputByte

; 248  :         CurrSeg->sym.max_offset = CurrSeg->e.seginfo->current_loc;

	mov	DWORD PTR [rcx+64], edx
$LN1@OutputByte:

; 249  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
OutputByte ENDP
_TEXT	ENDS
PUBLIC	OutputBinBytes
xdata	SEGMENT
$unwind$OutputBinBytes DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$OutputBinBytes DD @imagerel($LN14#)
	DD	@imagerel($LN14#+11)
	DD	@imagerel($unwind$OutputBinBytes#)
pdata	ENDS
xdata	SEGMENT
$chain$1$OutputBinBytes DD 040a21H
	DD	09740aH
	DD	083405H
	DD	@imagerel($LN14#)
	DD	@imagerel($LN14#+11)
	DD	@imagerel($unwind$OutputBinBytes#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$OutputBinBytes DD @imagerel($LN14#+11)
	DD	@imagerel($LN14#+229)
	DD	@imagerel($chain$1$OutputBinBytes#)
pdata	ENDS
xdata	SEGMENT
$chain$2$OutputBinBytes DD 021H
	DD	@imagerel($LN14#)
	DD	@imagerel($LN14#+11)
	DD	@imagerel($unwind$OutputBinBytes#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$OutputBinBytes DD @imagerel($LN14#+229)
	DD	@imagerel($LN14#+237)
	DD	@imagerel($chain$2$OutputBinBytes#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pBytes$ = 48
len$ = 56
OutputBinBytes PROC NEAR

; 253  : {

$LN14:
	sub	rsp, 40					; 00000028H

; 254  : 	int i;
; 255  : 
; 256  : 	if (write_to_file == TRUE) {

	cmp	BYTE PTR write_to_file, 1
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	mov	edi, edx
	mov	rbx, rcx
	jne	SHORT $LN8@OutputBinB

; 257  : 		uint_32 idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	r8, QWORD PTR [rax+104]
	mov	r9d, DWORD PTR [r8+12]
	sub	r9d, DWORD PTR [r8+8]

; 258  : #ifdef DEBUG_OUT
; 259  : 		if (CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc) {
; 260  : 			;//_asm int 3;
; 261  : 		}
; 262  : #endif
; 263  : 		/**/myassert(CurrSeg->e.seginfo->current_loc >= CurrSeg->e.seginfo->start_loc);
; 264  : 		if (Options.output_format == OFORMAT_OMF && idx >= MAX_LEDATA_THRESHOLD) {

	cmp	DWORD PTR Options+156, 1
	jne	SHORT $LN7@OutputBinB
	cmp	r9d, 1014				; 000003f6H
	jb	SHORT $LN7@OutputBinB

; 265  : 			omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 266  : 			idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	r11, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [r11+104]
	mov	r9d, DWORD PTR [rax+12]
	sub	r9d, DWORD PTR [rax+8]
$LN7@OutputBinB:

; 267  : 		}
; 268  : 		//DebugMsg(("OutputByte: buff=%p, idx=%" I32_SPEC "X, byte=%X, codebuff[0]=%X\n", CurrSeg->e.seginfo->CodeBuffer, idx, byte, *CurrSeg->e.seginfo->CodeBuffer ));
; 269  : 		for (i = 0; i < len; i++)

	test	edi, edi
	je	SHORT $LN2@OutputBinB
	mov	r10, rdi
$LL13@OutputBinB:

; 270  : 		{
; 271  : 			CurrSeg->e.seginfo->CodeBuffer[idx++] = *(pBytes++);

	mov	rax, QWORD PTR ModuleInfo+432
	inc	rbx
	mov	rcx, QWORD PTR [rax+104]
	movzx	eax, BYTE PTR [rbx-1]
	mov	rdx, QWORD PTR [rcx+16]
	mov	BYTE PTR [r9+rdx], al
	inc	r9d
	dec	r10
	jne	SHORT $LL13@OutputBinB

; 272  : 		}
; 273  : 
; 274  : 	}
; 275  : #if 1
; 276  : 	/* check this in pass 1 only */
; 277  : 	else if (CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc) {

	jmp	SHORT $LN2@OutputBinB
$LN8@OutputBinB:
	mov	rdx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rdx+104]
	mov	eax, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rcx+12], eax
	jae	SHORT $LN2@OutputBinB

; 278  : 		DebugMsg(("OutputByte: segment start loc changed from %" I32_SPEC "Xh to %" I32_SPEC "Xh\n",
; 279  : 			CurrSeg->e.seginfo->start_loc,
; 280  : 			CurrSeg->e.seginfo->current_loc));
; 281  : 		CurrSeg->e.seginfo->start_loc = CurrSeg->e.seginfo->current_loc;

	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rcx+8], eax
$LN2@OutputBinB:

; 282  : 	}
; 283  : #endif
; 284  : 	CurrSeg->e.seginfo->current_loc+=len;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rbx, QWORD PTR [rsp+64]
	mov	rcx, QWORD PTR [rax+104]
	add	DWORD PTR [rcx+12], edi

; 285  : 	CurrSeg->e.seginfo->bytes_written+=len;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	add	DWORD PTR [rcx+24], edi

; 286  : 	CurrSeg->e.seginfo->written = TRUE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rdi, QWORD PTR [rsp+72]
	mov	rcx, QWORD PTR [rax+104]
	or	BYTE PTR [rcx+107], 32			; 00000020H

; 287  : 	if (CurrSeg->e.seginfo->current_loc > CurrSeg->sym.max_offset)

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rcx+104]
	mov	edx, DWORD PTR [rax+12]
	cmp	edx, DWORD PTR [rcx+64]
	jbe	SHORT $LN1@OutputBinB

; 288  : 		CurrSeg->sym.max_offset = CurrSeg->e.seginfo->current_loc;

	mov	DWORD PTR [rcx+64], edx
$LN1@OutputBinB:

; 289  : }

	add	rsp, 40					; 00000028H
	ret	0
OutputBinBytes ENDP
_TEXT	ENDS
PUBLIC	FillDataBytes
EXTRN	omf_OutSelect:NEAR
xdata	SEGMENT
$unwind$FillDataBytes DD 051501H
	DD	097415H
	DD	083410H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$FillDataBytes DD @imagerel($LN16#)
	DD	@imagerel($LN16#+251)
	DD	@imagerel($unwind$FillDataBytes#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
byte$ = 48
len$ = 56
FillDataBytes PROC NEAR

; 303  : {

$LN16:
	sub	rsp, 40					; 00000028H

; 304  :     if ( ModuleInfo.CommentDataInCode )

	cmp	BYTE PTR ModuleInfo+423, 0
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	movzx	edi, cl
	mov	ebx, edx
	je	SHORT $LN4@FillDataBy

; 305  :         omf_OutSelect( TRUE );

	mov	cl, 1
	call	omf_OutSelect
$LN4@FillDataBy:

; 306  :     for( ; len; len-- )

	test	ebx, ebx
	je	$LN1@FillDataBy
	mov	r8, QWORD PTR ModuleInfo+432
$LL3@FillDataBy:

; 307  :         OutputByte( byte );

	cmp	BYTE PTR write_to_file, 1
	jne	SHORT $LN11@FillDataBy
	mov	rax, QWORD PTR [r8+104]
	add	r8, 104					; 00000068H
	mov	ecx, DWORD PTR [rax+12]
	sub	ecx, DWORD PTR [rax+8]
	cmp	DWORD PTR Options+156, 1
	jne	SHORT $LN10@FillDataBy
	cmp	ecx, 1014				; 000003f6H
	jb	SHORT $LN10@FillDataBy
	call	omf_FlushCurrSeg
	mov	r8, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [r8+104]
	add	r8, 104					; 00000068H
	mov	ecx, DWORD PTR [rax+12]
	sub	ecx, DWORD PTR [rax+8]
$LN10@FillDataBy:
	mov	rax, QWORD PTR [r8]
	mov	rax, QWORD PTR [rax+16]
	mov	BYTE PTR [rcx+rax], dil
	mov	r8, QWORD PTR ModuleInfo+432
	jmp	SHORT $LN8@FillDataBy
$LN11@FillDataBy:
	mov	rcx, QWORD PTR [r8+104]
	mov	eax, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rcx+12], eax
	jae	SHORT $LN8@FillDataBy
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rcx+8], eax
	mov	r8, QWORD PTR ModuleInfo+432
$LN8@FillDataBy:
	mov	rax, QWORD PTR [r8+104]
	inc	DWORD PTR [rax+12]
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	inc	DWORD PTR [rcx+24]
	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	or	BYTE PTR [rcx+107], 32			; 00000020H
	mov	r8, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [r8+104]
	mov	ecx, DWORD PTR [rax+12]
	cmp	ecx, DWORD PTR [r8+64]
	jbe	SHORT $LN2@FillDataBy
	mov	DWORD PTR [r8+64], ecx
	mov	r8, QWORD PTR ModuleInfo+432
$LN2@FillDataBy:

; 306  :     for( ; len; len-- )

	dec	ebx
	jne	$LL3@FillDataBy
$LN1@FillDataBy:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 308  : }

	add	rsp, 40					; 00000028H
	ret	0
FillDataBytes ENDP
_TEXT	ENDS
PUBLIC	OutputSegmentBytes
EXTRN	store_fixup:NEAR
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$OutputSegmentBytes DD 031001H
	DD	063410H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$OutputSegmentBytes DD @imagerel($LN9#)
	DD	@imagerel($LN9#+16)
	DD	@imagerel($unwind$OutputSegmentBytes#)
pdata	ENDS
xdata	SEGMENT
$chain$3$OutputSegmentBytes DD 060f21H
	DD	04c40fH
	DD	08640aH
	DD	075405H
	DD	@imagerel($LN9#)
	DD	@imagerel($LN9#+16)
	DD	@imagerel($unwind$OutputSegmentBytes#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$OutputSegmentBytes DD @imagerel($LN9#+16)
	DD	@imagerel($LN9#+49)
	DD	@imagerel($chain$3$OutputSegmentBytes#)
pdata	ENDS
xdata	SEGMENT
$chain$4$OutputSegmentBytes DD 020521H
	DD	097405H
	DD	@imagerel($LN9#+16)
	DD	@imagerel($LN9#+49)
	DD	@imagerel($chain$3$OutputSegmentBytes#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$OutputSegmentBytes DD @imagerel($LN9#+49)
	DD	@imagerel($LN9#+143)
	DD	@imagerel($chain$4$OutputSegmentBytes#)
pdata	ENDS
xdata	SEGMENT
$chain$5$OutputSegmentBytes DD 021H
	DD	@imagerel($LN9#+16)
	DD	@imagerel($LN9#+49)
	DD	@imagerel($chain$3$OutputSegmentBytes#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$OutputSegmentBytes DD @imagerel($LN9#+143)
	DD	@imagerel($LN9#+207)
	DD	@imagerel($chain$5$OutputSegmentBytes#)
pdata	ENDS
xdata	SEGMENT
$chain$6$OutputSegmentBytes DD 021H
	DD	@imagerel($LN9#)
	DD	@imagerel($LN9#+16)
	DD	@imagerel($unwind$OutputSegmentBytes#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$OutputSegmentBytes DD @imagerel($LN9#+207)
	DD	@imagerel($LN9#+220)
	DD	@imagerel($chain$6$OutputSegmentBytes#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
segg$ = 48
pbytes$ = 56
len$ = 64
fixup$ = 72
OutputSegmentBytes PROC NEAR

; 312  : {

$LN9:
	sub	rsp, 40					; 00000028H

; 313  : 	if (write_to_file == TRUE) {

	cmp	BYTE PTR write_to_file, 1
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+32], r12
	movsxd	rbp, r8d
	mov	r12, rdx
	mov	rsi, r9
	mov	rbx, rcx
	jne	SHORT $LN6@OutputSegm

; 314  : 		uint_32 idx = segg->e.seginfo->current_loc - segg->e.seginfo->start_loc;

	mov	rax, QWORD PTR [rcx+104]
	mov	QWORD PTR [rsp+72], rdi
	mov	edi, DWORD PTR [rax+12]
	sub	edi, DWORD PTR [rax+8]

; 315  : #if 0 /* def DEBUG_OUT */
; 316  : 		if (CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc)
; 317  : 			_asm int 3;
; 318  : #endif
; 319  : 		/**/myassert(segg->e.seginfo->current_loc >= segg->e.seginfo->start_loc);
; 320  : 		if (Options.output_format == OFORMAT_OMF && ((idx + len) > MAX_LEDATA_THRESHOLD)) {

	cmp	DWORD PTR Options+156, 1
	jne	SHORT $LN5@OutputSegm
	lea	eax, DWORD PTR [rdi+rbp]
	cmp	eax, 1014				; 000003f6H
	jbe	SHORT $LN5@OutputSegm

; 321  : 			omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 322  : 			idx = segg->e.seginfo->current_loc - segg->e.seginfo->start_loc;

	mov	r11, QWORD PTR [rbx+104]
	mov	edi, DWORD PTR [r11+12]
	sub	edi, DWORD PTR [r11+8]
$LN5@OutputSegm:

; 323  : 		}
; 324  : 		if (fixup)

	test	rsi, rsi
	je	SHORT $LN4@OutputSegm

; 325  : 			store_fixup(fixup, segg, (int_32 *)pbytes);

	mov	r8, r12
	mov	rdx, rbx
	mov	rcx, rsi
	call	store_fixup
$LN4@OutputSegm:

; 326  : 		//DebugMsg(("OutputBytes: buff=%p, idx=%" I32_SPEC "X, byte=%X\n", CurrSeg->e.seginfo->CodeBuffer, idx, *pbytes ));
; 327  : 		memcpy(&segg->e.seginfo->CodeBuffer[idx], pbytes, len);

	mov	rax, QWORD PTR [rbx+104]
	mov	ecx, edi
	mov	r8, rbp
	add	rcx, QWORD PTR [rax+16]
	mov	rdx, r12
	call	memcpy
	mov	rdi, QWORD PTR [rsp+72]
	jmp	SHORT $LN2@OutputSegm
$LN6@OutputSegm:

; 328  : 	}
; 329  : #if 1
; 330  : 	/* check this in pass 1 only */
; 331  : 	else if (segg->e.seginfo->current_loc < segg->e.seginfo->start_loc) {

	mov	rax, QWORD PTR [rcx+104]
	mov	ecx, DWORD PTR [rax+12]
	cmp	ecx, DWORD PTR [rax+8]
	jae	SHORT $LN2@OutputSegm

; 332  : 		DebugMsg(("OutputBytes: segment start loc changed from %" I32_SPEC "Xh to %" I32_SPEC "Xh\n",
; 333  : 			segg->e.seginfo->start_loc,
; 334  : 			segg->e.seginfo->current_loc));
; 335  : 		segg->e.seginfo->start_loc = segg->e.seginfo->current_loc;

	mov	DWORD PTR [rax+8], ecx
$LN2@OutputSegm:

; 336  : 	}
; 337  : #endif
; 338  : 	segg->e.seginfo->current_loc += len;

	mov	rax, QWORD PTR [rbx+104]
	mov	r12, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+64]
	add	DWORD PTR [rax+12], ebp

; 339  : 	segg->e.seginfo->bytes_written += len;

	mov	rax, QWORD PTR [rbx+104]
	add	DWORD PTR [rax+24], ebp

; 340  : 	segg->e.seginfo->written = TRUE;

	mov	rax, QWORD PTR [rbx+104]
	mov	rbp, QWORD PTR [rsp+56]
	or	BYTE PTR [rax+107], 32			; 00000020H

; 341  : 	if (segg->e.seginfo->current_loc > segg->sym.max_offset)

	mov	rax, QWORD PTR [rbx+104]
	mov	ecx, DWORD PTR [rax+12]
	cmp	ecx, DWORD PTR [rbx+64]
	jbe	SHORT $LN1@OutputSegm

; 342  : 		segg->sym.max_offset = segg->e.seginfo->current_loc;

	mov	DWORD PTR [rbx+64], ecx
$LN1@OutputSegm:
	mov	rbx, QWORD PTR [rsp+48]

; 343  : }

	add	rsp, 40					; 00000028H
	ret	0
OutputSegmentBytes ENDP
_TEXT	ENDS
PUBLIC	OutputBytes
xdata	SEGMENT
$unwind$OutputBytes DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$OutputBytes DD @imagerel($LN9#)
	DD	@imagerel($LN9#+11)
	DD	@imagerel($unwind$OutputBytes#)
pdata	ENDS
xdata	SEGMENT
$chain$2$OutputBytes DD 060f21H
	DD	09740fH
	DD	08640aH
	DD	075405H
	DD	@imagerel($LN9#)
	DD	@imagerel($LN9#+11)
	DD	@imagerel($unwind$OutputBytes#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$OutputBytes DD @imagerel($LN9#+11)
	DD	@imagerel($LN9#+44)
	DD	@imagerel($chain$2$OutputBytes#)
pdata	ENDS
xdata	SEGMENT
$chain$3$OutputBytes DD 020521H
	DD	063405H
	DD	@imagerel($LN9#+11)
	DD	@imagerel($LN9#+44)
	DD	@imagerel($chain$2$OutputBytes#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$OutputBytes DD @imagerel($LN9#+44)
	DD	@imagerel($LN9#+151)
	DD	@imagerel($chain$3$OutputBytes#)
pdata	ENDS
xdata	SEGMENT
$chain$4$OutputBytes DD 021H
	DD	@imagerel($LN9#+11)
	DD	@imagerel($LN9#+44)
	DD	@imagerel($chain$2$OutputBytes#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$OutputBytes DD @imagerel($LN9#+151)
	DD	@imagerel($LN9#+253)
	DD	@imagerel($chain$4$OutputBytes#)
pdata	ENDS
xdata	SEGMENT
$chain$5$OutputBytes DD 021H
	DD	@imagerel($LN9#)
	DD	@imagerel($LN9#+11)
	DD	@imagerel($unwind$OutputBytes#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$OutputBytes DD @imagerel($LN9#+253)
	DD	@imagerel($LN9#+261)
	DD	@imagerel($chain$5$OutputBytes#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pbytes$ = 48
len$ = 56
fixup$ = 64
OutputBytes PROC NEAR

; 352  : {

$LN9:
	sub	rsp, 40					; 00000028H

; 353  :     if( write_to_file == TRUE ) {

	cmp	BYTE PTR write_to_file, 1
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	movsxd	rsi, edx
	mov	rbp, rcx
	mov	rdi, r8
	jne	SHORT $LN6@OutputByte@2

; 354  :         uint_32 idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rdx, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rsp+48], rbx
	mov	rax, QWORD PTR [rdx+104]
	mov	ebx, DWORD PTR [rax+12]
	sub	ebx, DWORD PTR [rax+8]

; 355  : #if 0 /* def DEBUG_OUT */
; 356  :         if ( CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc )
; 357  :             _asm int 3;
; 358  : #endif
; 359  :         /**/myassert( CurrSeg->e.seginfo->current_loc >= CurrSeg->e.seginfo->start_loc );
; 360  :         if( Options.output_format == OFORMAT_OMF && ((idx + len) > MAX_LEDATA_THRESHOLD ) ) {

	cmp	DWORD PTR Options+156, 1
	jne	SHORT $LN5@OutputByte@2
	lea	eax, DWORD PTR [rbx+rsi]
	cmp	eax, 1014				; 000003f6H
	jbe	SHORT $LN5@OutputByte@2

; 361  :             omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 362  :             idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	rdx, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rdx+104]
	mov	ebx, DWORD PTR [rax+12]
	sub	ebx, DWORD PTR [rax+8]
$LN5@OutputByte@2:

; 363  :         }
; 364  :         if ( fixup )

	test	rdi, rdi
	je	SHORT $LN4@OutputByte@2

; 365  :             store_fixup( fixup, CurrSeg, (int_32 *)pbytes );

	mov	r8, rbp
	mov	rcx, rdi
	call	store_fixup
	mov	rdx, QWORD PTR ModuleInfo+432
$LN4@OutputByte@2:

; 366  :         //DebugMsg(("OutputBytes: buff=%p, idx=%" I32_SPEC "X, byte=%X\n", CurrSeg->e.seginfo->CodeBuffer, idx, *pbytes ));
; 367  :         memcpy( &CurrSeg->e.seginfo->CodeBuffer[idx], pbytes, len );

	mov	rax, QWORD PTR [rdx+104]
	mov	ecx, ebx
	mov	r8, rsi
	add	rcx, QWORD PTR [rax+16]
	mov	rdx, rbp
	call	memcpy
	mov	rbx, QWORD PTR [rsp+48]
	jmp	SHORT $LN2@OutputByte@2
$LN6@OutputByte@2:

; 368  :     }
; 369  : #if 1
; 370  :     /* check this in pass 1 only */
; 371  :     else if( CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc ) {

	mov	rdx, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rdx+104]
	mov	eax, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rcx+12], eax
	jae	SHORT $LN2@OutputByte@2

; 372  :         DebugMsg(("OutputBytes: segment start loc changed from %" I32_SPEC "Xh to %" I32_SPEC "Xh\n",
; 373  :                   CurrSeg->e.seginfo->start_loc,
; 374  :                   CurrSeg->e.seginfo->current_loc));
; 375  :         CurrSeg->e.seginfo->start_loc = CurrSeg->e.seginfo->current_loc;

	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rcx+8], eax
$LN2@OutputByte@2:

; 376  :     }
; 377  : #endif
; 378  :     CurrSeg->e.seginfo->current_loc += len;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rcx, QWORD PTR [rax+104]
	add	DWORD PTR [rcx+12], esi

; 379  :     CurrSeg->e.seginfo->bytes_written += len;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	add	DWORD PTR [rcx+24], esi

; 380  :     CurrSeg->e.seginfo->written = TRUE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rsi, QWORD PTR [rsp+64]
	mov	rcx, QWORD PTR [rax+104]
	or	BYTE PTR [rcx+107], 32			; 00000020H

; 381  :     if( CurrSeg->e.seginfo->current_loc > CurrSeg->sym.max_offset )

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rcx+104]
	mov	edx, DWORD PTR [rax+12]
	cmp	edx, DWORD PTR [rcx+64]
	jbe	SHORT $LN1@OutputByte@2

; 382  :         CurrSeg->sym.max_offset = CurrSeg->e.seginfo->current_loc;

	mov	DWORD PTR [rcx+64], edx
$LN1@OutputByte@2:

; 383  : }

	add	rsp, 40					; 00000028H
	ret	0
OutputBytes ENDP
_TEXT	ENDS
PUBLIC	OutputInterleavedBytes
xdata	SEGMENT
$unwind$OutputInterleavedBytes DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$OutputInterleavedBytes DD @imagerel($LN16#)
	DD	@imagerel($LN16#+11)
	DD	@imagerel($unwind$OutputInterleavedBytes#)
pdata	ENDS
xdata	SEGMENT
$chain$2$OutputInterleavedBytes DD 060f21H
	DD	08640fH
	DD	07540aH
	DD	063405H
	DD	@imagerel($LN16#)
	DD	@imagerel($LN16#+11)
	DD	@imagerel($unwind$OutputInterleavedBytes#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$OutputInterleavedBytes DD @imagerel($LN16#+11)
	DD	@imagerel($LN16#+47)
	DD	@imagerel($chain$2$OutputInterleavedBytes#)
pdata	ENDS
xdata	SEGMENT
$chain$3$OutputInterleavedBytes DD 020521H
	DD	097405H
	DD	@imagerel($LN16#+11)
	DD	@imagerel($LN16#+47)
	DD	@imagerel($chain$2$OutputInterleavedBytes#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$OutputInterleavedBytes DD @imagerel($LN16#+47)
	DD	@imagerel($LN16#+160)
	DD	@imagerel($chain$3$OutputInterleavedBytes#)
pdata	ENDS
xdata	SEGMENT
$chain$4$OutputInterleavedBytes DD 021H
	DD	@imagerel($LN16#+11)
	DD	@imagerel($LN16#+47)
	DD	@imagerel($chain$2$OutputInterleavedBytes#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$OutputInterleavedBytes DD @imagerel($LN16#+160)
	DD	@imagerel($LN16#+307)
	DD	@imagerel($chain$4$OutputInterleavedBytes#)
pdata	ENDS
xdata	SEGMENT
$chain$5$OutputInterleavedBytes DD 021H
	DD	@imagerel($LN16#)
	DD	@imagerel($LN16#+11)
	DD	@imagerel($unwind$OutputInterleavedBytes#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$OutputInterleavedBytes DD @imagerel($LN16#+307)
	DD	@imagerel($LN16#+315)
	DD	@imagerel($chain$5$OutputInterleavedBytes#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pbytes$ = 48
len$ = 56
fixup$ = 64
OutputInterleavedBytes PROC NEAR

; 387  : {

$LN16:
	sub	rsp, 40					; 00000028H

; 388  : 	int i = 0;
; 389  : 	char *pOut = NULL;
; 390  : 
; 391  : 	if (write_to_file == TRUE) {

	cmp	BYTE PTR write_to_file, 1
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	ebp, edx
	mov	rbx, rcx
	mov	rsi, r8
	jne	$LN11@OutputInte

; 392  : 		uint_32 idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	r9, QWORD PTR ModuleInfo+432
	mov	QWORD PTR [rsp+72], rdi
	mov	rax, QWORD PTR [r9+104]
	mov	edi, DWORD PTR [rax+12]
	sub	edi, DWORD PTR [rax+8]

; 393  : #if 0 /* def DEBUG_OUT */
; 394  : 		if (CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc)
; 395  : 			_asm int 3;
; 396  : #endif
; 397  : 		/**/myassert(CurrSeg->e.seginfo->current_loc >= CurrSeg->e.seginfo->start_loc);
; 398  : 		if (Options.output_format == OFORMAT_OMF && ((idx + len) > MAX_LEDATA_THRESHOLD)) {

	cmp	DWORD PTR Options+156, 1
	jne	SHORT $LN10@OutputInte
	lea	eax, DWORD PTR [rdi+rdx]
	cmp	eax, 1014				; 000003f6H
	jbe	SHORT $LN10@OutputInte

; 399  : 			omf_FlushCurrSeg();

	call	omf_FlushCurrSeg

; 400  : 			idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;

	mov	r9, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [r9+104]
	mov	edi, DWORD PTR [rax+12]
	sub	edi, DWORD PTR [rax+8]
$LN10@OutputInte:

; 401  : 		}
; 402  : 		if (fixup)

	test	rsi, rsi
	je	SHORT $LN9@OutputInte

; 403  : 			store_fixup(fixup, CurrSeg, (int_32 *)pbytes);

	mov	r8, rbx
	mov	rdx, r9
	mov	rcx, rsi
	call	store_fixup
	mov	r9, QWORD PTR ModuleInfo+432
$LN9@OutputInte:

; 404  : 		pOut = &CurrSeg->e.seginfo->CodeBuffer[idx];

	mov	rax, QWORD PTR [r9+104]
	mov	ecx, edi
	mov	rdi, QWORD PTR [rsp+72]
	add	rcx, QWORD PTR [rax+16]

; 405  : 		for (i = 0; i < len*2; i++)

	lea	r8d, DWORD PTR [rbp+rbp]
	xor	edx, edx
	test	r8d, r8d
	jle	SHORT $LN2@OutputInte
	npad	4
$LL8@OutputInte:

; 406  : 		{
; 407  : 			if (i % 2 == 1)

	test	dl, 1
	je	SHORT $LN5@OutputInte

; 408  : 				*pOut++ = 0;

	mov	BYTE PTR [rcx], 0
	inc	rcx

; 409  : 			else

	jmp	SHORT $LN7@OutputInte
$LN5@OutputInte:

; 410  : 				*pOut++ = *pbytes++;

	movzx	eax, BYTE PTR [rbx]
	inc	rcx
	inc	rbx
	mov	BYTE PTR [rcx-1], al
$LN7@OutputInte:
	inc	edx
	cmp	edx, r8d
	jl	SHORT $LL8@OutputInte

; 411  : 		}
; 412  : 	}
; 413  : #if 1
; 414  : 	/* check this in pass 1 only */
; 415  : 	else if (CurrSeg->e.seginfo->current_loc < CurrSeg->e.seginfo->start_loc) {

	mov	r9, QWORD PTR ModuleInfo+432
	jmp	SHORT $LN2@OutputInte
$LN11@OutputInte:
	mov	r9, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [r9+104]
	mov	eax, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rcx+12], eax
	jae	SHORT $LN2@OutputInte

; 416  : 		DebugMsg(("OutputBytes: segment start loc changed from %" I32_SPEC "Xh to %" I32_SPEC "Xh\n",
; 417  : 			CurrSeg->e.seginfo->start_loc,
; 418  : 			CurrSeg->e.seginfo->current_loc));
; 419  : 		CurrSeg->e.seginfo->start_loc = CurrSeg->e.seginfo->current_loc;

	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rcx+8], eax
	mov	r9, QWORD PTR ModuleInfo+432
$LN2@OutputInte:

; 420  : 	}
; 421  : #endif
; 422  : 	CurrSeg->e.seginfo->current_loc += len*2;

	mov	rax, QWORD PTR [r9+104]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]
	lea	edx, DWORD PTR [rbp+rbp]
	mov	rbp, QWORD PTR [rsp+56]
	add	DWORD PTR [rax+12], edx

; 423  : 	CurrSeg->e.seginfo->bytes_written += len*2;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	add	DWORD PTR [rcx+24], edx

; 424  : 	CurrSeg->e.seginfo->written = TRUE;

	mov	rax, QWORD PTR ModuleInfo+432
	mov	rcx, QWORD PTR [rax+104]
	or	BYTE PTR [rcx+107], 32			; 00000020H

; 425  : 	if (CurrSeg->e.seginfo->current_loc > CurrSeg->sym.max_offset)

	mov	rcx, QWORD PTR ModuleInfo+432
	mov	rax, QWORD PTR [rcx+104]
	mov	edx, DWORD PTR [rax+12]
	cmp	edx, DWORD PTR [rcx+64]
	jbe	SHORT $LN1@OutputInte

; 426  : 		CurrSeg->sym.max_offset = CurrSeg->e.seginfo->current_loc;

	mov	DWORD PTR [rcx+64], edx
$LN1@OutputInte:

; 427  : }

	add	rsp, 40					; 00000028H
	ret	0
OutputInterleavedBytes ENDP
_TEXT	ENDS
PUBLIC	SetCurrOffset
EXTRN	LastCodeBufSize:DWORD
xdata	SEGMENT
$unwind$SetCurrOffset DD 030c01H
	DD	07340cH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetCurrOffset DD @imagerel($LN16#)
	DD	@imagerel($LN16#+12)
	DD	@imagerel($unwind$SetCurrOffset#)
pdata	ENDS
xdata	SEGMENT
$chain$2$SetCurrOffset DD 040a21H
	DD	09740aH
	DD	086405H
	DD	@imagerel($LN16#)
	DD	@imagerel($LN16#+12)
	DD	@imagerel($unwind$SetCurrOffset#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$SetCurrOffset DD @imagerel($LN16#+12)
	DD	@imagerel($LN16#+172)
	DD	@imagerel($chain$2$SetCurrOffset#)
pdata	ENDS
xdata	SEGMENT
$chain$3$SetCurrOffset DD 021H
	DD	@imagerel($LN16#)
	DD	@imagerel($LN16#+12)
	DD	@imagerel($unwind$SetCurrOffset#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$SetCurrOffset DD @imagerel($LN16#+172)
	DD	@imagerel($LN16#+187)
	DD	@imagerel($chain$3$SetCurrOffset#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
seg$ = 48
value$ = 56
relative$ = 64
select_data$ = 72
SetCurrOffset PROC NEAR

; 433  : {

$LN16:
	sub	rsp, 40					; 00000028H

; 434  :     if( relative )

	test	r8b, r8b
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	movzx	esi, r9b
	mov	rbx, rcx
	mov	edi, edx
	je	SHORT $LN12@SetCurrOff

; 435  :         value += seg->e.seginfo->current_loc;

	mov	rax, QWORD PTR [rcx+104]
	add	edi, DWORD PTR [rax+12]
$LN12@SetCurrOff:

; 436  : 
; 437  :     if ( Options.output_format == OFORMAT_OMF ) {

	cmp	DWORD PTR Options+156, 1
	jne	SHORT $LN11@SetCurrOff

; 438  :         if ( seg == CurrSeg ) {

	cmp	rcx, QWORD PTR ModuleInfo+432
	jne	SHORT $LN10@SetCurrOff

; 439  :             if ( write_to_file == TRUE )

	cmp	BYTE PTR write_to_file, 1
	jne	SHORT $LN9@SetCurrOff

; 440  :                 omf_FlushCurrSeg();

	call	omf_FlushCurrSeg
$LN9@SetCurrOff:

; 441  : 
; 442  :         /* for debugging, tell if data is located in code sections*/
; 443  :             if( select_data )

	test	sil, sil
	je	SHORT $LN7@SetCurrOff

; 444  :                 if ( ModuleInfo.CommentDataInCode )

	cmp	BYTE PTR ModuleInfo+423, 0
	je	SHORT $LN7@SetCurrOff

; 445  :                     omf_OutSelect( TRUE );

	mov	cl, 1
	call	omf_OutSelect
$LN7@SetCurrOff:

; 446  :             LastCodeBufSize = value;

	mov	DWORD PTR LastCodeBufSize, edi
$LN10@SetCurrOff:

; 447  :         }
; 448  :         seg->e.seginfo->start_loc = value;

	mov	rax, QWORD PTR [rbx+104]
	mov	DWORD PTR [rax+8], edi

; 449  :     /* for -bin, if there's an ORG (relative==false) and no initialized data
; 450  :      * has been set yet, set start_loc!
; 451  :      * v1.96: this is now also done for COFF and ELF
; 452  :      */
; 453  :     /* else if ( Options.output_format == OFORMAT_BIN && relative == FALSE ) { */
; 454  :     } else {

	jmp	SHORT $LN2@SetCurrOff
$LN11@SetCurrOff:

; 455  :         if ( write_to_file == FALSE ) {

	cmp	BYTE PTR write_to_file, 0
	jne	SHORT $LN2@SetCurrOff

; 456  :             if ( relative ) {

	test	r8b, r8b
	jne	SHORT $LN2@SetCurrOff

; 457  : #if 0 /* don't include "preceding" uninitialized data */
; 458  :                 if( seg->e.seginfo->current_loc < seg->e.seginfo->start_loc )
; 459  :                     seg->e.seginfo->start_loc = seg->e.seginfo->current_loc;
; 460  : #endif
; 461  :             } else {
; 462  :                 if ( seg->e.seginfo->bytes_written == 0 )

	mov	rax, QWORD PTR [rcx+104]
	cmp	DWORD PTR [rax+24], 0
	jne	SHORT $LN2@SetCurrOff

; 463  :                     seg->e.seginfo->start_loc = value;

	mov	DWORD PTR [rax+8], edi
$LN2@SetCurrOff:

; 464  :             }
; 465  :         }
; 466  :     }
; 467  : 
; 468  :     seg->e.seginfo->current_loc = value;

	mov	rax, QWORD PTR [rbx+104]
	mov	rsi, QWORD PTR [rsp+64]
	mov	DWORD PTR [rax+12], edi

; 469  :     seg->e.seginfo->written = FALSE;

	mov	rax, QWORD PTR [rbx+104]
	mov	rdi, QWORD PTR [rsp+72]
	and	BYTE PTR [rax+107], 223			; 000000dfH

; 470  : 
; 471  :     if( seg->e.seginfo->current_loc > seg->sym.max_offset )

	mov	rax, QWORD PTR [rbx+104]
	mov	ecx, DWORD PTR [rax+12]
	cmp	ecx, DWORD PTR [rbx+64]
	jbe	SHORT $LN15@SetCurrOff

; 472  :         seg->sym.max_offset = seg->e.seginfo->current_loc;

	mov	DWORD PTR [rbx+64], ecx
$LN15@SetCurrOff:

; 473  : 
; 474  :     return( NOT_ERROR );

	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+56]

; 475  : }

	add	rsp, 40					; 00000028H
	ret	0
SetCurrOffset ENDP
_TEXT	ENDS
EXTRN	fclose:NEAR
EXTRN	WriteError:NEAR
EXTRN	fwrite:NEAR
EXTRN	sprintf:NEAR
EXTRN	Mangle:NEAR
EXTRN	ErrnoStr:NEAR
EXTRN	fopen:NEAR
EXTRN	EmitWarn:NEAR
EXTRN	EmitErr:NEAR
EXTRN	SymTables:BYTE
xdata	SEGMENT
$unwind$WriteModule DD 077001H
	DD	0a6470H
	DD	0b7415H
	DD	093409H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$WriteModule DD @imagerel(WriteModule#)
	DD	@imagerel(WriteModule#+382)
	DD	@imagerel($unwind$WriteModule#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
modinfo$ = 64
WriteModule PROC NEAR

; 481  : {

	sub	rsp, 56					; 00000038H
	mov	QWORD PTR [rsp+72], rbx

; 482  :     struct dsym *curr;
; 483  : 
; 484  :     DebugMsg(("WriteModule enter\n"));
; 485  : 
; 486  :     /* final checks */
; 487  :     /* check limit of segments */
; 488  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rbx, QWORD PTR SymTables+32
	mov	QWORD PTR [rsp+88], rdi
	test	rbx, rbx
	mov	rdi, rcx
	je	SHORT $LN12@WriteModul
	npad	3
$LL14@WriteModul:

; 489  :         if ( curr->e.seginfo->Ofssize == USE16 && curr->sym.max_offset > 0x10000 ) {

	mov	rax, QWORD PTR [rbx+104]
	cmp	BYTE PTR [rax+104], 0
	jne	SHORT $LN13@WriteModul
	cmp	DWORD PTR [rbx+64], 65536		; 00010000H
	jle	SHORT $LN13@WriteModul

; 490  :             if ( Options.output_format == OFORMAT_OMF )

	cmp	DWORD PTR Options+156, 1
	jne	SHORT $LN10@WriteModul

; 491  :                 EmitErr( SEGMENT_EXCEEDS_64K_LIMIT, curr->sym.name );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 222				; 000000deH
	call	EmitErr

; 492  :             else

	jmp	SHORT $LN13@WriteModul
$LN10@WriteModul:

; 493  :                 EmitWarn( 2, SEGMENT_EXCEEDS_64K_LIMIT, curr->sym.name );

	mov	r8, QWORD PTR [rbx+8]
	mov	edx, 222				; 000000deH
	mov	ecx, 2
	call	EmitWarn
$LN13@WriteModul:
	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL14@WriteModul
$LN12@WriteModul:

; 494  :         }
; 495  :     }
; 496  : 
; 497  :     modinfo->g.WriteModule( modinfo );

	mov	rcx, rdi
	mov	QWORD PTR [rsp+80], rsi
	call	QWORD PTR [rdi+288]

; 498  : 
; 499  : #if DLLIMPORT
; 500  :     /* is the -Fd option given with a file name? */
; 501  :     if ( Options.names[OPTN_LNKDEF_FN] ) {

	mov	rcx, QWORD PTR Options+56
	test	rcx, rcx
	je	$LN8@WriteModul

; 502  :         FILE *ld;
; 503  :         ld = fopen( Options.names[OPTN_LNKDEF_FN], "w" );

	lea	rdx, OFFSET FLAT:$SG6323
	call	fopen

; 504  :         if ( ld == NULL ) {

	test	rax, rax
	mov	rsi, rax
	jne	SHORT $LN7@WriteModul

; 505  :             return( EmitErr( CANNOT_OPEN_FILE, Options.names[OPTN_LNKDEF_FN], ErrnoStr() ) );

	call	ErrnoStr
	mov	rdx, QWORD PTR Options+56
	lea	ecx, QWORD PTR [rsi+106]
	mov	r8, rax
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+72]

; 523  : }

	add	rsp, 56					; 00000038H
	jmp	EmitErr
$LN7@WriteModul:

; 506  :         }
; 507  :         for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next ) {

	mov	rdi, QWORD PTR SymTables+16
	test	rdi, rdi
	je	$LN4@WriteModul
$LL6@WriteModul:

; 508  :             DebugMsg(("WriteModule: ext=%s, isproc=%u, weak=%u\n", curr->sym.name, curr->sym.isproc, curr->sym.weak ));
; 509  :             if ( curr->sym.isproc && ( curr->sym.weak == FALSE || curr->sym.iat_used ) &&
; 510  :                 curr->sym.dll && *(curr->sym.dll->name) != NULLC ) {

	test	BYTE PTR [rdi+49], 8
	je	SHORT $LN5@WriteModul
	test	BYTE PTR [rdi+55], 8
	je	SHORT $LN2@WriteModul
	test	BYTE PTR [rdi+48], 8
	je	SHORT $LN5@WriteModul
$LN2@WriteModul:
	mov	rax, QWORD PTR [rdi+64]
	test	rax, rax
	je	SHORT $LN5@WriteModul
	cmp	BYTE PTR [rax+12], 0
	je	SHORT $LN5@WriteModul

; 511  :                 int size;
; 512  :                 Mangle( &curr->sym, StringBufferEnd );

	mov	rdx, QWORD PTR ModuleInfo+488
	mov	rcx, rdi
	call	Mangle

; 513  :                 size = sprintf( CurrSource, "import '%s'  %s.%s\n", StringBufferEnd, curr->sym.dll->name, curr->sym.name );

	mov	r9, QWORD PTR [rdi+64]
	mov	rax, QWORD PTR [rdi+8]
	mov	r8, QWORD PTR ModuleInfo+488
	mov	rcx, QWORD PTR ModuleInfo+464
	lea	rdx, OFFSET FLAT:$SG6333
	add	r9, 12
	mov	QWORD PTR [rsp+32], rax
	call	sprintf

; 514  :                 if ( fwrite( CurrSource, 1, size, ld ) != size )

	mov	rcx, QWORD PTR ModuleInfo+464
	mov	r9, rsi
	movsxd	rbx, eax
	mov	edx, 1
	mov	r8, rbx
	call	fwrite
	cmp	rax, rbx
	je	SHORT $LN5@WriteModul

; 515  :                     WriteError();

	call	WriteError
$LN5@WriteModul:

; 506  :         }
; 507  :         for ( curr = SymTables[TAB_EXT].head; curr != NULL ; curr = curr->next ) {

	mov	rdi, QWORD PTR [rdi+112]
	test	rdi, rdi
	jne	$LL6@WriteModul
$LN4@WriteModul:

; 516  :             }
; 517  :         }
; 518  :         fclose( ld );

	mov	rcx, rsi
	call	fclose
$LN8@WriteModul:
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+72]

; 519  :     }
; 520  : #endif
; 521  :     DebugMsg(("WriteModule exit\n"));
; 522  :     return( NOT_ERROR );

	xor	eax, eax

; 523  : }

	add	rsp, 56					; 00000038H
	ret	0
WriteModule ENDP
_TEXT	ENDS
EXTRN	isalnum:NEAR
EXTRN	isalpha:NEAR
xdata	SEGMENT
$unwind$is_valid_identifier DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$is_valid_identifier DD @imagerel(is_valid_identifier#)
	DD	@imagerel(is_valid_identifier#+125)
	DD	@imagerel($unwind$is_valid_identifier#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
id$ = 48
is_valid_identifier PROC NEAR

; 531  : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 532  :     /* special handling of first char of an id: it can't be a digit,
; 533  :      but can be a dot (don't care about ModuleInfo.dotname!). */
; 534  : 
; 535  :     if( is_valid_first_char( *id ) == 0 )

	movsx	ecx, BYTE PTR [rcx]
	call	isalpha
	test	eax, eax
	jne	SHORT $LN6@is_valid_i
	movzx	eax, BYTE PTR [rbx]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN6@is_valid_i
	cmp	al, 64					; 00000040H
	je	SHORT $LN6@is_valid_i
	cmp	al, 36					; 00000024H
	je	SHORT $LN6@is_valid_i
	cmp	al, 63					; 0000003fH
	je	SHORT $LN6@is_valid_i
	cmp	al, 46					; 0000002eH
	je	SHORT $LN6@is_valid_i

; 536  :         return( ERROR );

	mov	eax, -1

; 544  :         return( ERROR );
; 545  : 
; 546  :     return( NOT_ERROR );
; 547  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN6@is_valid_i:

; 537  :     id++;
; 538  :     for( ; *id != NULLC; id++ ) {

	movzx	eax, BYTE PTR [rbx+1]
	inc	rbx
	test	al, al
	je	SHORT $LN3@is_valid_i

; 539  :         if ( is_valid_id_char( *id ) == FALSE )

	movsx	ecx, al
	call	isalnum
	test	eax, eax
	jne	SHORT $LN6@is_valid_i
	movzx	eax, BYTE PTR [rbx]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN6@is_valid_i
	cmp	al, 64					; 00000040H
	je	SHORT $LN6@is_valid_i
	cmp	al, 36					; 00000024H
	je	SHORT $LN6@is_valid_i
	cmp	al, 63					; 0000003fH

; 537  :     id++;
; 538  :     for( ; *id != NULLC; id++ ) {

	je	SHORT $LN6@is_valid_i

; 540  :             return( ERROR );

	mov	eax, -1

; 544  :         return( ERROR );
; 545  : 
; 546  :     return( NOT_ERROR );
; 547  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@is_valid_i:

; 541  :     }
; 542  :     /* don't allow a single dot! */
; 543  :     if ( *(id-1) == '.' )

	xor	eax, eax
	cmp	BYTE PTR [rbx-1], 46			; 0000002eH
	setne	al
	dec	eax

; 544  :         return( ERROR );
; 545  : 
; 546  :     return( NOT_ERROR );
; 547  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
is_valid_identifier ENDP
_TEXT	ENDS
EXTRN	SymCreate:NEAR
EXTRN	SymFind:NEAR
EXTRN	strchr:NEAR
EXTRN	__chkstk:NEAR
xdata	SEGMENT
$unwind$add_cmdline_tmacros DD 0250d1f01H
	DD	05d41fH
	DD	0bc41bH
	DD	0a7417H
	DD	096413H
	DD	08340fH
	DD	05206230bH
	DD	05002H
xdata	ENDS
pdata	SEGMENT
$pdata$add_cmdline_tmacros DD @imagerel(add_cmdline_tmacros#)
	DD	@imagerel(add_cmdline_tmacros#+348)
	DD	@imagerel($unwind$add_cmdline_tmacros#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
add_cmdline_tmacros PROC NEAR

; 553  : {

	push	rbp
	sub	rsp, 48					; 00000030H
	lea	rbp, QWORD PTR [rsp+32]
	mov	QWORD PTR [rbp+32], rbx
	mov	QWORD PTR [rbp+40], rsi
	mov	QWORD PTR [rbp+48], rdi
	mov	QWORD PTR [rbp+56], r12
	mov	QWORD PTR [rbp+8], r13

; 554  :     struct qitem *p;
; 555  :     char *name;
; 556  :     char *value;
; 557  :     int len;
; 558  :     struct asym *sym;
; 559  : 
; 560  :     DebugMsg(("add_cmdline_tmacros enter\n"));
; 561  :     for ( p = Options.queues[OPTQ_MACRO]; p; p = p->next ) {

	mov	r13, QWORD PTR Options+104
	test	r13, r13
	je	$LN8@add_cmdlin
	npad	1
$LL10@add_cmdlin:

; 562  :         DebugMsg(("add_cmdline_tmacros: found >%s<\n", p->value));
; 563  :         name = p->value;
; 564  :         value = strchr( name, '=' );

	lea	rcx, QWORD PTR [r13+8]
	mov	edx, 61					; 0000003dH
	lea	rbx, QWORD PTR [r13+8]
	call	strchr

; 565  :         if( value == NULL ) {

	test	rax, rax
	mov	r12, rax
	jne	SHORT $LN7@add_cmdlin

; 566  :             /* v2.06: ensure that 'value' doesn't point to r/o space */
; 567  :             //value = "";
; 568  :             value = name + strlen( name ); /* use the terminating NULL */

	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	lea	r12, QWORD PTR [r13+rcx+7]

; 569  :         } else {

	jmp	SHORT $LN6@add_cmdlin
$LN7@add_cmdlin:

; 570  :             len = value - name;

	mov	ecx, eax
	sub	ecx, ebx

; 571  :             name = (char *)myalloca( len + 1 );

	lea	eax, DWORD PTR [rcx+1]
	cdqe
	add	rax, 15
	and	rax, -16
	call	__chkstk

; 572  :             memcpy( name, p->value, len );

	movsxd	rdi, ecx
	sub	rsp, rax
	lea	rbx, QWORD PTR [rsp+32]
	lea	rdx, QWORD PTR [r13+8]
	mov	r8, rdi
	mov	rcx, rbx
	call	memcpy

; 573  :             *(name + len) = NULLC;

	mov	BYTE PTR [rdi+rbx], 0

; 574  :             value++;

	inc	r12
$LN6@add_cmdlin:

; 575  :         }
; 576  : 
; 577  :         /* there's no check whether the name is a reserved word!
; 578  :          */
; 579  :         if( is_valid_identifier( name ) == ERROR ) {

	movsx	ecx, BYTE PTR [rbx]
	call	isalpha
	test	eax, eax
	jne	SHORT $LN18@add_cmdlin
	movzx	eax, BYTE PTR [rbx]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN18@add_cmdlin
	cmp	al, 64					; 00000040H
	je	SHORT $LN18@add_cmdlin
	cmp	al, 36					; 00000024H
	je	SHORT $LN18@add_cmdlin
	cmp	al, 63					; 0000003fH
	je	SHORT $LN18@add_cmdlin
	cmp	al, 46					; 0000002eH
	jne	SHORT $LN31@add_cmdlin
$LN18@add_cmdlin:
	movzx	eax, BYTE PTR [rbx+1]
	lea	rdi, QWORD PTR [rbx+1]
	test	al, al
	je	SHORT $LN15@add_cmdlin
$LL17@add_cmdlin:
	movsx	ecx, al
	call	isalnum
	test	eax, eax
	jne	SHORT $LN23@add_cmdlin
	movzx	eax, BYTE PTR [rdi]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN23@add_cmdlin
	cmp	al, 64					; 00000040H
	je	SHORT $LN23@add_cmdlin
	cmp	al, 36					; 00000024H
	je	SHORT $LN23@add_cmdlin
	cmp	al, 63					; 0000003fH
	jne	SHORT $LN31@add_cmdlin
$LN23@add_cmdlin:
	mov	al, BYTE PTR [rdi+1]
	inc	rdi
	test	al, al
	jne	SHORT $LL17@add_cmdlin
$LN15@add_cmdlin:
	cmp	BYTE PTR [rdi-1], 46			; 0000002eH
	jne	SHORT $LN5@add_cmdlin
$LN31@add_cmdlin:

; 580  :             DebugMsg(("add_cmdline_tmacros: name >%s< invalid\n", name ));
; 581  :             EmitErr( SYNTAX_ERROR_EX, name );

	mov	ecx, 209				; 000000d1H

; 582  :         } else {

	jmp	SHORT $LN35@add_cmdlin
$LN5@add_cmdlin:

; 583  :             sym = SymSearch( name );

	mov	rcx, rbx
	call	SymFind

; 584  :             if ( sym == NULL ) {

	test	rax, rax
	jne	SHORT $LN3@add_cmdlin

; 585  :                 sym = SymCreate( name );

	mov	rcx, rbx
	call	SymCreate

; 586  :                 sym->state = SYM_TMACRO;

	mov	DWORD PTR [rax+40], 10
$LN3@add_cmdlin:

; 587  :             }
; 588  :             if ( sym->state == SYM_TMACRO ) {

	cmp	DWORD PTR [rax+40], 10
	jne	SHORT $LN2@add_cmdlin

; 589  :                 sym->isdefined = TRUE;
; 590  :                 sym->predefined = TRUE;

	or	BYTE PTR [rax+48], 34			; 00000022H

; 591  :                 sym->string_ptr = value;

	mov	QWORD PTR [rax+16], r12

; 592  :             } else

	jmp	SHORT $LN9@add_cmdlin
$LN2@add_cmdlin:

; 593  :                 EmitErr( SYMBOL_ALREADY_DEFINED, name );

	mov	ecx, 56					; 00000038H
$LN35@add_cmdlin:
	mov	rdx, rbx
	call	EmitErr
$LN9@add_cmdlin:
	mov	r13, QWORD PTR [r13]
	test	r13, r13
	jne	$LL10@add_cmdlin
$LN8@add_cmdlin:

; 594  :         }
; 595  :     }
; 596  :     return;
; 597  : }

	mov	rbx, QWORD PTR [rbp+32]
	mov	rsi, QWORD PTR [rbp+40]
	mov	rdi, QWORD PTR [rbp+48]
	mov	r12, QWORD PTR [rbp+56]
	mov	r13, QWORD PTR [rbp+8]
	lea	rsp, QWORD PTR [rbp+16]
	pop	rbp
	ret	0
add_cmdline_tmacros ENDP
_TEXT	ENDS
EXTRN	AddStringToIncludePath:NEAR
xdata	SEGMENT
$unwind$add_incpaths DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$add_incpaths DD @imagerel(add_incpaths#)
	DD	@imagerel(add_incpaths#+41)
	DD	@imagerel($unwind$add_incpaths#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
add_incpaths PROC NEAR

; 603  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 604  :     struct qitem *p;
; 605  :     DebugMsg(("add_incpaths: enter\n"));
; 606  :     for ( p = Options.queues[OPTQ_INCPATH]; p; p = p->next ) {

	mov	rbx, QWORD PTR Options+112
	test	rbx, rbx
	je	SHORT $LN1@add_incpat
$LL3@add_incpat:

; 607  :         AddStringToIncludePath( p->value );

	lea	rcx, QWORD PTR [rbx+8]
	call	AddStringToIncludePath
	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL3@add_incpat
$LN1@add_incpat:

; 608  :     }
; 609  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
add_incpaths ENDP
_TEXT	ENDS
EXTRN	getenv:NEAR
xdata	SEGMENT
$unwind$CmdlParamsInit DD 020901H
	DD	030053209H
xdata	ENDS
pdata	SEGMENT
$pdata$CmdlParamsInit DD @imagerel(CmdlParamsInit#)
	DD	@imagerel(CmdlParamsInit#+91)
	DD	@imagerel($unwind$CmdlParamsInit#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pass$ = 48
CmdlParamsInit PROC NEAR

; 617  :     DebugMsg(("CmdlParamsInit(%u) enter\n", pass));
; 618  : 
; 619  : #if BUILD_TARGET
; 620  :     if ( pass == PASS_1 ) {
; 621  :         struct asym *sym;
; 622  :         char *tmp;
; 623  :         char *p;
; 624  : 
; 625  :         _strupr( Options.build_target );
; 626  :         tmp = myalloca( strlen( Options.build_target ) + 5 ); /* null + 4 uscores */
; 627  :         strcpy( tmp, uscores );
; 628  :         strcat( tmp, Options.build_target );
; 629  :         strcat( tmp, uscores );
; 630  : 
; 631  :         /* define target */
; 632  :         sym = CreateVariable( tmp, 0 );
; 633  :         sym->predefined = TRUE;
; 634  : 
; 635  :         p = NULL;
; 636  :         if( _stricmp( Options.build_target, "DOS" ) == 0 ) {
; 637  :             p = "__MSDOS__";
; 638  :         } else if( _stricmp( Options.build_target, "NETWARE" ) == 0 ) {
; 639  :             if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {
; 640  :                 p = "__NETWARE_386__";
; 641  :             } else {
; 642  :                 /* do nothing ... __NETWARE__ already defined */
; 643  :             }
; 644  :         } else if( _stricmp( Options.build_target, "WINDOWS" ) == 0 ) {
; 645  :             if( ( ModuleInfo.curr_cpu & P_CPU_MASK ) >= P_386 ) {
; 646  :                 p = "__WINDOWS_386__";
; 647  :             } else {
; 648  :                 /* do nothing ... __WINDOWS__ already defined */
; 649  :             }
; 650  :         } else if( _stricmp( Options.build_target, "QNX" ) == 0 ) {
; 651  :             p = "__UNIX__";
; 652  :         } else if( _stricmp( Options.build_target, "LINUX" ) == 0 ) {
; 653  :             p = "__UNIX__";
; 654  :         }
; 655  :         if ( p ) {
; 656  :             sym = CreateVariable( p, 0 );
; 657  :             sym->predefined = TRUE;
; 658  :         }
; 659  :     }
; 660  : #endif
; 661  : 
; 662  :     if ( pass == PASS_1 ) {

	test	ecx, ecx
	jne	SHORT $LN13@CmdlParams
	push	rbx
	sub	rsp, 32					; 00000020H

; 663  :         char *env;
; 664  :         /* v2.06: this is done in ModulePassInit now */
; 665  :         //SetCPU( Options.cpu );
; 666  :         add_cmdline_tmacros();

	call	add_cmdline_tmacros

; 667  :         add_incpaths();

	mov	rbx, QWORD PTR Options+112
	test	rbx, rbx
	je	SHORT $LN6@CmdlParams
	npad	6
$LL8@CmdlParams:
	lea	rcx, QWORD PTR [rbx+8]
	call	AddStringToIncludePath
	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL8@CmdlParams
$LN6@CmdlParams:

; 668  :         if ( Options.ignore_include == FALSE )

	cmp	BYTE PTR Options+152, 0
	jne	SHORT $LN1@CmdlParams

; 669  :             if ( env = getenv( "INCLUDE" ) )

	lea	rcx, OFFSET FLAT:$SG6381
	call	getenv
	test	rax, rax
	je	SHORT $LN1@CmdlParams

; 670  :                 AddStringToIncludePath( env );

	mov	rcx, rax
	call	AddStringToIncludePath
$LN1@CmdlParams:

; 671  :     }
; 672  :     DebugMsg(("CmdlParamsInit exit\n"));
; 673  :     return;
; 674  : }

	add	rsp, 32					; 00000020H
	pop	rbx
$LN13@CmdlParams:
	ret	0
CmdlParamsInit ENDP
_TEXT	ENDS
PUBLIC	WritePreprocessedLine
EXTRN	printf:NEAR
EXTRN	isspace:NEAR
xdata	SEGMENT
$unwind$WritePreprocessedLine DD 031001H
	DD	097410H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$WritePreprocessedLine DD @imagerel($LN13#)
	DD	@imagerel($LN13#+21)
	DD	@imagerel($unwind$WritePreprocessedLine#)
pdata	ENDS
xdata	SEGMENT
$chain$1$WritePreprocessedLine DD 020521H
	DD	083405H
	DD	@imagerel($LN13#)
	DD	@imagerel($LN13#+21)
	DD	@imagerel($unwind$WritePreprocessedLine#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$WritePreprocessedLine DD @imagerel($LN13#+21)
	DD	@imagerel($LN13#+110)
	DD	@imagerel($chain$1$WritePreprocessedLine#)
pdata	ENDS
xdata	SEGMENT
$chain$2$WritePreprocessedLine DD 021H
	DD	@imagerel($LN13#)
	DD	@imagerel($LN13#+21)
	DD	@imagerel($unwind$WritePreprocessedLine#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$WritePreprocessedLine DD @imagerel($LN13#+110)
	DD	@imagerel($LN13#+148)
	DD	@imagerel($chain$2$WritePreprocessedLine#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
string$ = 48
WritePreprocessedLine PROC NEAR

; 680  : {

$LN13:
	sub	rsp, 40					; 00000028H

; 681  :     static bool PrintEmptyLine = TRUE;
; 682  :     const char *p;
; 683  : 
; 684  : #if 0 /* v2.08: removed, obsolete */
; 685  :     /* filter some macro specific directives */
; 686  :     if ( tokenarray[0].token == T_DIRECTIVE &&
; 687  :          ( tokenarray[0].tokval == T_ENDM ||
; 688  :            tokenarray[0].tokval == T_EXITM))
; 689  :         return;
; 690  :     /* don't print generated code - with one exception:
; 691  :      if the code was generated as a result of structure initialization,
; 692  :      then do!
; 693  :      */
; 694  :     if ( GeneratedCode )
; 695  :         return;
; 696  : #endif
; 697  :     if ( Token_Count > 0 ) {

	cmp	DWORD PTR ModuleInfo+496, 0
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx
	jle	SHORT $LN6@WritePrepr
	mov	QWORD PTR [rsp+64], rbx

; 698  :         /* v2.08: don't print a leading % (this char is no longer filtered) */
; 699  :         for ( p = string; isspace( *p ); p++ );

	mov	rbx, rcx
	movsx	ecx, BYTE PTR [rcx]
	call	isspace
	test	eax, eax
	je	SHORT $LN3@WritePrepr
	npad	7
$LL5@WritePrepr:
	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL5@WritePrepr
$LN3@WritePrepr:

; 700  :         printf("%s\n", *p == '%' ? p+1 : string );

	cmp	BYTE PTR [rbx], 37			; 00000025H
	jne	SHORT $LN9@WritePrepr
	lea	rdi, QWORD PTR [rbx+1]
$LN9@WritePrepr:
	lea	rcx, OFFSET FLAT:$SG6392
	mov	rdx, rdi
	call	printf
	mov	rbx, QWORD PTR [rsp+64]

; 701  :         PrintEmptyLine = TRUE;

	mov	BYTE PTR ?PrintEmptyLine@?1??WritePreprocessedLine@@9@9, 1
	mov	rdi, QWORD PTR [rsp+72]

; 705  :     }
; 706  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@WritePrepr:

; 702  :     } else if ( PrintEmptyLine ) {

	cmp	BYTE PTR ?PrintEmptyLine@?1??WritePreprocessedLine@@9@9, 0
	je	SHORT $LN1@WritePrepr

; 703  :         PrintEmptyLine = FALSE;
; 704  :         printf("\n");

	lea	rcx, OFFSET FLAT:$SG6395
	mov	BYTE PTR ?PrintEmptyLine@?1??WritePreprocessedLine@@9@9, 0
	call	printf
$LN1@WritePrepr:
	mov	rdi, QWORD PTR [rsp+72]

; 705  :     }
; 706  : }

	add	rsp, 40					; 00000028H
	ret	0
WritePreprocessedLine ENDP
_TEXT	ENDS
PUBLIC	SetMasm510
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
value$ = 8
SetMasm510 PROC NEAR

; 712  : {

	mov	al, cl
	and	eax, 1

; 713  :     ModuleInfo.m510 = value;
; 714  :     ModuleInfo.oldstructs = value;
; 715  :     /* ModuleInfo.oldmacros = value; not implemented yet */
; 716  :     ModuleInfo.dotname = value;
; 717  :     ModuleInfo.setif2 = value;

	lea	edx, DWORD PTR [rax*4]
	or	edx, eax
	shl	edx, 2
	or	edx, eax
	shl	edx, 2
	or	edx, eax
	mov	eax, DWORD PTR ModuleInfo+408
	and	eax, -2721				; fffff55fH
	shl	edx, 5
	or	edx, eax

; 718  : 
; 719  :     if ( value ) {

	test	cl, cl
	mov	DWORD PTR ModuleInfo+408, edx
	je	SHORT $LN1@SetMasm510

; 720  :         if ( ModuleInfo.model == MODEL_NONE ) {

	cmp	DWORD PTR ModuleInfo+360, 0
	jne	SHORT $LN1@SetMasm510

; 721  :             /* if no model is specified, set OFFSET:SEGMENT */
; 722  :             ModuleInfo.offsettype = OT_SEGMENT;
; 723  :             if ( ModuleInfo.langtype == LANG_NONE ) {

	cmp	DWORD PTR ModuleInfo+364, 0
	mov	DWORD PTR ModuleInfo+384, 2
	jne	SHORT $LN1@SetMasm510

; 724  :                 ModuleInfo.scoped = FALSE;

	btr	edx, 8

; 725  :                 ModuleInfo.procs_private = TRUE;

	or	edx, 8
	mov	DWORD PTR ModuleInfo+408, edx
$LN1@SetMasm510:

; 726  :             }
; 727  :         }
; 728  :     }
; 729  :     return;
; 730  : }

	ret	0
SetMasm510 ENDP
_TEXT	ENDS
EXTRN	SymSetCmpFunc:NEAR
EXTRN	AddLineQueueX:NEAR
EXTRN	ModelToken:BYTE
EXTRN	SetCPU:NEAR
EXTRN	UseSavedState:BYTE
xdata	SEGMENT
$unwind$ModulePassInit DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$ModulePassInit DD @imagerel(ModulePassInit#)
	DD	@imagerel(ModulePassInit#+531)
	DD	@imagerel($unwind$ModulePassInit#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
ModulePassInit PROC NEAR

; 736  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 737  :     enum cpu_info cpu = Options.cpu;
; 738  :     enum model_type model = Options.model;
; 739  : #if DLLIMPORT
; 740  :     struct dsym *curr;
; 741  : #endif
; 742  : 
; 743  :     DebugMsg(( "ModulePassInit() enter\n" ));
; 744  :     /* set default values not affected by the masm 5.1 compat switch */
; 745  :     ModuleInfo.procs_private = FALSE;
; 746  :     ModuleInfo.procs_export = FALSE;

	mov	edx, DWORD PTR ModuleInfo+408
	mov	ecx, DWORD PTR Options+176
	mov	ebx, DWORD PTR Options+172
	and	edx, -25				; ffffffe7H

; 747  :     ModuleInfo.offsettype = OT_GROUP;

	mov	DWORD PTR ModuleInfo+384, 0

; 748  :     ModuleInfo.scoped = TRUE;

	bts	edx, 8

; 749  : 
; 750  : 
; 751  : #if FASTPASS
; 752  :     /* v2.03: don't generate the code if fastpass is active */
; 753  :     /* v2.08: query UseSavedState instead of StoreState */
; 754  :     //if ( StoreState == FALSE ) {
; 755  :     if ( UseSavedState == FALSE ) {

	cmp	BYTE PTR UseSavedState, 0
	mov	DWORD PTR ModuleInfo+408, edx
	jne	$LN5@ModulePass

; 756  : #endif
; 757  :         ModuleInfo.langtype = Options.langtype;
; 758  :         ModuleInfo.fctype = Options.fctype;
; 759  : 
; 760  : 		#if AMD64_SUPPORT
; 761  : 		if (Options.output_format == OFORMAT_ELF)

	mov	edx, DWORD PTR Options+156
	mov	r8d, DWORD PTR Options+168
	mov	eax, DWORD PTR Options+180
	cmp	edx, 3
	mov	DWORD PTR ModuleInfo+364, r8d
	mov	DWORD PTR ModuleInfo+376, eax
	jne	SHORT $LN11@ModulePass

; 762  : 		{
; 763  : 			ModuleInfo.fctype = FCT_WIN64;

	mov	DWORD PTR ModuleInfo+376, 2

; 764  : 			Options.fctype = FCT_WIN64;

	mov	DWORD PTR Options+180, 2
$LN11@ModulePass:

; 765  : 		}
; 766  : 		#endif /* John Hankinson 2016-02-10 force elf64 to use win64 abi */
; 767  : 
; 768  : #if AMD64_SUPPORT
; 769  :         if ( ModuleInfo.sub_format == SFORMAT_64BIT ) {

	cmp	DWORD PTR ModuleInfo+372, 3
	jne	SHORT $LN10@ModulePass

; 770  :             /* v2.06: force cpu to be at least P_64, without side effect to Options.cpu */
; 771  :             if ( ( cpu &  P_CPU_MASK ) < P_64 ) /* enforce cpu to be 64-bit */

	mov	r9d, 112				; 00000070H
	mov	eax, ecx
	and	eax, 240				; 000000f0H

; 772  :                 cpu = P_64;
; 773  :             /* ignore -m switch for 64-bit formats.
; 774  :              * there's no other model than FLAT possible.
; 775  :              */
; 776  :             model = MODEL_FLAT;

	lea	ebx, QWORD PTR [r9-105]
	cmp	eax, r9d
	cmovl	ecx, r9d

; 777  :             if ( ModuleInfo.langtype == LANG_NONE && Options.output_format == OFORMAT_COFF )

	test	r8d, r8d
	jne	SHORT $LN6@ModulePass
	cmp	edx, 2
	jne	SHORT $LN6@ModulePass

; 778  :                 ModuleInfo.langtype = LANG_FASTCALL;

	mov	DWORD PTR ModuleInfo+364, ebx

; 779  :         } else

	jmp	SHORT $LN6@ModulePass
$LN10@ModulePass:

; 780  : #endif
; 781  :             /* if model FLAT is to be set, ensure that cpu is compat. */
; 782  :             if ( model == MODEL_FLAT && ( cpu & P_CPU_MASK ) < P_386 ) /* cpu < 386? */

	cmp	ebx, 7
	jne	SHORT $LN6@ModulePass
	mov	eax, ecx
	mov	edx, 48					; 00000030H
	and	eax, 240				; 000000f0H
	cmp	eax, edx
	cmovl	ecx, edx
$LN6@ModulePass:

; 783  :                 cpu = P_386;
; 784  : 
; 785  :         SetCPU( cpu );

	call	SetCPU

; 786  :         /* table ModelToken starts with MODEL_TINY, which is index 1" */
; 787  :         if ( model != MODEL_NONE )

	test	ebx, ebx
	je	SHORT $LN22@ModulePass

; 788  :             AddLineQueueX( "%r %s", T_DOT_MODEL, ModelToken[model - 1] );

	lea	rax, OFFSET FLAT:ModelToken
	movsxd	r8, ebx
	lea	rcx, OFFSET FLAT:$SG6416
	mov	r8, QWORD PTR [rax+r8*8-8]
	mov	edx, 347				; 0000015bH
	call	AddLineQueueX
$LN22@ModulePass:
	mov	edx, DWORD PTR ModuleInfo+408
$LN5@ModulePass:
	movzx	ecx, BYTE PTR Options+135
	and	edx, -2721				; fffff55fH
	mov	al, cl
	and	eax, 1

; 789  : 
; 790  : #if FASTPASS
; 791  :     }
; 792  : #endif
; 793  : 
; 794  :     SetMasm510( Options.masm51_compat );

	lea	r8d, DWORD PTR [rax*4]
	or	r8d, eax
	shl	r8d, 2
	or	r8d, eax
	shl	r8d, 2
	or	r8d, eax
	shl	r8d, 5
	or	r8d, edx
	test	cl, cl
	je	SHORT $LN15@ModulePass
	cmp	DWORD PTR ModuleInfo+360, 0
	jne	SHORT $LN15@ModulePass
	cmp	DWORD PTR ModuleInfo+364, 0
	mov	DWORD PTR ModuleInfo+384, 2
	jne	SHORT $LN15@ModulePass
	btr	r8d, 8
	or	r8d, 8
$LN15@ModulePass:

; 795  :     ModuleInfo.defOfssize = USE16;
; 796  :     ModuleInfo.ljmp     = TRUE;
; 797  : 
; 798  :     ModuleInfo.list   = Options.write_listing;
; 799  :     ModuleInfo.cref   = TRUE;
; 800  :     ModuleInfo.listif = Options.listif;
; 801  :     ModuleInfo.list_generated_code = Options.list_generated_code;

	mov	dl, BYTE PTR Options+140
	mov	al, BYTE PTR Options+139

; 802  :     ModuleInfo.list_macro = Options.list_macro;
; 803  : 
; 804  :     ModuleInfo.case_sensitive = Options.case_sensitive;
; 805  :     ModuleInfo.convert_uppercase = Options.convert_uppercase;

	mov	cl, BYTE PTR Options+133
	and	edx, 1
	and	eax, 1
	and	ecx, 1
	add	edx, edx
	add	ecx, ecx
	and	r8d, -53249				; ffff2fffH
	or	edx, eax
	mov	al, BYTE PTR Options+129
	mov	BYTE PTR ModuleInfo+405, 0
	shl	edx, 2
	and	eax, 1
	or	edx, eax
	mov	eax, DWORD PTR Options+144
	shl	edx, 12
	mov	DWORD PTR ModuleInfo+400, eax
	mov	al, BYTE PTR Options+132
	or	edx, r8d
	and	eax, 1
	or	ecx, eax
	or	edx, 8256				; 00002040H
	add	ecx, ecx
	and	edx, -7					; fffffff9H
	or	ecx, edx
	mov	DWORD PTR ModuleInfo+408, ecx

; 806  :     SymSetCmpFunc();

	call	SymSetCmpFunc

; 807  : 
; 808  :     ModuleInfo.segorder = SEGORDER_SEQ;
; 809  :     ModuleInfo.radix = 10;
; 810  :     ModuleInfo.fieldalign = Options.fieldalign;
; 811  : #if PROCALIGN
; 812  :     ModuleInfo.procalign = 0;
; 813  : #endif
; 814  : #if DLLIMPORT
; 815  :     /* if OPTION DLLIMPORT was used, reset all iat_used flags */
; 816  :     if ( ModuleInfo.g.DllQueue )

	cmp	QWORD PTR ModuleInfo+80, 0
	movzx	eax, BYTE PTR Options+164
	mov	DWORD PTR ModuleInfo+380, 0
	mov	BYTE PTR ModuleInfo+396, 10
	mov	BYTE PTR ModuleInfo+397, al
	mov	BYTE PTR ModuleInfo+399, 0
	je	SHORT $LN1@ModulePass

; 817  :         for ( curr = SymTables[TAB_EXT].head; curr; curr = curr->next )

	mov	rax, QWORD PTR SymTables+16
	test	rax, rax
	je	SHORT $LN1@ModulePass
	npad	11
$LL3@ModulePass:

; 818  :             curr->sym.iat_used = FALSE;

	and	BYTE PTR [rax+48], 247			; 000000f7H
	mov	rax, QWORD PTR [rax+112]
	test	rax, rax
	jne	SHORT $LL3@ModulePass
$LN1@ModulePass:

; 819  : #endif
; 820  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ModulePassInit ENDP
_TEXT	ENDS
EXTRN	SymMakeAllSymbolsPublic:NEAR
EXTRN	sym_remove_table:NEAR
EXTRN	SkipSavedState:NEAR
EXTRN	EmitError:NEAR
EXTRN	CondCheckOpen:NEAR
EXTRN	HllCheckOpen:NEAR
xdata	SEGMENT
$unwind$PassOneChecks DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$PassOneChecks DD @imagerel(PassOneChecks#)
	DD	@imagerel(PassOneChecks#+479)
	DD	@imagerel($unwind$PassOneChecks#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
PassOneChecks PROC NEAR

; 869  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 870  :     struct dsym *curr;
; 871  :     struct dsym *next;
; 872  :     struct qnode *q;
; 873  :     struct qnode *qn;
; 874  : #ifdef DEBUG_OUT
; 875  :     int cntUnusedExt = 0;
; 876  : #endif
; 877  : 
; 878  :     /* check for open structures and segments has been done inside the
; 879  :      * END directive handling already
; 880  :      * v2.10: now done for PROCs as well, since procedures
; 881  :      * must be closed BEFORE segments are to be closed.
; 882  :      */
; 883  :     //ProcCheckOpen();
; 884  :     HllCheckOpen();

	call	HllCheckOpen

; 885  :     CondCheckOpen();

	call	CondCheckOpen

; 886  : 
; 887  : 	/* Don't require END directive for bin output */
; 888  :     if( ModuleInfo.EndDirFound == FALSE  && Options.output_format != OFORMAT_BIN)

	bt	DWORD PTR ModuleInfo+408, 17
	jb	SHORT $LN43@PassOneChe
	cmp	DWORD PTR Options+156, 0
	je	SHORT $LN43@PassOneChe

; 889  :         EmitError( END_DIRECTIVE_REQUIRED );

	mov	ecx, 99					; 00000063H
	call	EmitError
$LN43@PassOneChe:

; 890  : 
; 891  : #ifdef DEBUG_OUT
; 892  :     for ( curr = SymTables[TAB_UNDEF].head; curr; curr = curr->next ) {
; 893  :         DebugMsg(("PassOneChecks: undefined symbol %s\n", curr->sym.name ));
; 894  :     }
; 895  : #endif
; 896  :     /* v2.04: check the publics queue.
; 897  :      * - only internal symbols can be public.
; 898  :      * - weak external symbols are filtered ( since v2.11 )
; 899  :      * - anything else is an error
; 900  :      * v2.11: moved here ( from inside the "#if FASTPASS"-block )
; 901  :      * because the loop will now filter weak externals [ this
; 902  :      * was previously done in GetPublicSymbols() ]
; 903  :      */
; 904  :     for( q = ModuleInfo.g.PubQueue.head, qn = (struct qnode *)&ModuleInfo.g.PubQueue ; q; q = q->next ) {

	mov	rax, QWORD PTR ModuleInfo+16
	lea	rcx, OFFSET FLAT:ModuleInfo+16
	test	rax, rax
	je	SHORT $LN40@PassOneChe
$LL42@PassOneChe:

; 905  : 
; 906  :         if ( q->sym->state == SYM_INTERNAL )

	mov	r8, QWORD PTR [rax+8]
	mov	edx, DWORD PTR [r8+40]
	cmp	edx, 1
	jne	SHORT $LN39@PassOneChe

; 907  :             qn = q;

	mov	rcx, rax
	jmp	SHORT $LN41@PassOneChe
$LN39@PassOneChe:

; 908  :         else if ( q->sym->state == SYM_EXTERNAL && q->sym->weak == TRUE ) {

	cmp	edx, 2
	jne	SHORT $LN37@PassOneChe
	test	BYTE PTR [r8+55], 8
	je	SHORT $LN37@PassOneChe

; 909  :             DebugMsg(("PassOneChecks: public for weak external skipped: %s\n", q->sym->name ));
; 910  :             qn->next = q->next;

	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 911  :             LclFree( q );
; 912  :             q = qn;

	mov	rax, rcx
$LN41@PassOneChe:
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL42@PassOneChe

; 968  :             /* check if symbol is external or public */
; 969  :             if ( sym == NULL ||
; 970  :                 ( sym->state != SYM_EXTERNAL &&
; 971  :                  ( sym->state != SYM_INTERNAL || sym->ispublic == FALSE ))) {

	jmp	SHORT $LN40@PassOneChe
$LN37@PassOneChe:

; 913  :         } else {
; 914  :             DebugMsg(("PassOneChecks: invalid public attribute for %s [state=%u weak=%u]\n", q->sym->name, q->sym->state, q->sym->weak ));
; 915  : #if FASTPASS
; 916  :             SkipSavedState();

	call	SkipSavedState
$LN40@PassOneChe:

; 917  : #endif
; 918  :             break;
; 919  :         }
; 920  :     }
; 921  : #if FASTPASS
; 922  :     if ( SymTables[TAB_UNDEF].head ) {
; 923  :         /* to force a full second pass in case of missing symbols,
; 924  :          * activate the next line. It was implemented to have proper
; 925  :          * error displays if a forward reference wasn't found.
; 926  :          * However, v1.95 final won't need this anymore, because both
; 927  :          * filename + lineno for every line is known now in pass 2.
; 928  :          */
; 929  :         /* SkipSavedState(); */
; 930  :     }
; 931  : 
; 932  :     /* check if there's an undefined segment reference.
; 933  :      * This segment was an argument to a group definition then.
; 934  :      * Just do a full second pass, the GROUP directive will report
; 935  :      * the error.
; 936  :      */
; 937  :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {

	mov	rax, QWORD PTR SymTables+32
	test	rax, rax
	je	SHORT $LN32@PassOneChe
$LL34@PassOneChe:

; 938  :         if( curr->sym.segment == NULL ) {

	cmp	QWORD PTR [rax+32], 0
	je	SHORT $LN51@PassOneChe
	mov	rax, QWORD PTR [rax+112]
	test	rax, rax
	jne	SHORT $LL34@PassOneChe

; 968  :             /* check if symbol is external or public */
; 969  :             if ( sym == NULL ||
; 970  :                 ( sym->state != SYM_EXTERNAL &&
; 971  :                  ( sym->state != SYM_INTERNAL || sym->ispublic == FALSE ))) {

	jmp	SHORT $LN32@PassOneChe
$LN51@PassOneChe:

; 939  :             DebugMsg(("PassOneChecks: undefined segment %s\n", curr->sym.name ));
; 940  :             SkipSavedState();

	call	SkipSavedState
$LN32@PassOneChe:

; 941  :             break;
; 942  :         }
; 943  :     }
; 944  : #if COFF_SUPPORT
; 945  :     /* if there's an item in the safeseh list which is not an
; 946  :      * internal proc, make a full second pass to emit a proper
; 947  :      * error msg at the .SAFESEH directive
; 948  :      */
; 949  :     for ( q = ModuleInfo.g.SafeSEHQueue.head; q; q = q->next ) {

	mov	rax, QWORD PTR ModuleInfo+48
	test	rax, rax
	je	SHORT $LN28@PassOneChe
$LL30@PassOneChe:

; 950  :         if ( q->sym->state != SYM_INTERNAL || q->sym->isproc == FALSE ) {

	mov	rcx, QWORD PTR [rax+8]
	cmp	DWORD PTR [rcx+40], 1
	jne	SHORT $LN52@PassOneChe
	test	BYTE PTR [rcx+49], 8
	je	SHORT $LN52@PassOneChe
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL30@PassOneChe

; 968  :             /* check if symbol is external or public */
; 969  :             if ( sym == NULL ||
; 970  :                 ( sym->state != SYM_EXTERNAL &&
; 971  :                  ( sym->state != SYM_INTERNAL || sym->ispublic == FALSE ))) {

	jmp	SHORT $LN28@PassOneChe
$LN52@PassOneChe:

; 951  :             SkipSavedState();

	call	SkipSavedState
$LN28@PassOneChe:

; 952  :             break;
; 953  :         }
; 954  :     }
; 955  : #endif
; 956  : 
; 957  :     /* scan ALIASes for COFF/ELF */
; 958  : 
; 959  : #if COFF_SUPPORT || ELF_SUPPORT
; 960  :     if ( Options.output_format == OFORMAT_COFF
; 961  : #if ELF_SUPPORT
; 962  :         || Options.output_format == OFORMAT_ELF
; 963  : #endif
; 964  :        ) {

	mov	eax, DWORD PTR Options+156
	cmp	eax, 2
	je	SHORT $LN24@PassOneChe
	cmp	eax, 3
	jne	SHORT $LN21@PassOneChe
$LN24@PassOneChe:

; 965  :         for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {

	mov	rcx, QWORD PTR SymTables+80
	test	rcx, rcx
	je	SHORT $LN21@PassOneChe
$LL23@PassOneChe:

; 966  :             struct asym *sym;
; 967  :             sym = curr->sym.substitute;

	mov	rax, QWORD PTR [rcx+16]

; 968  :             /* check if symbol is external or public */
; 969  :             if ( sym == NULL ||
; 970  :                 ( sym->state != SYM_EXTERNAL &&
; 971  :                  ( sym->state != SYM_INTERNAL || sym->ispublic == FALSE ))) {

	test	rax, rax
	je	SHORT $LN53@PassOneChe
	mov	edx, DWORD PTR [rax+40]
	cmp	edx, 2
	je	SHORT $LN61@PassOneChe
	cmp	edx, 1
	jne	SHORT $LN53@PassOneChe
	test	BYTE PTR [rax+48], 128			; 00000080H
	je	SHORT $LN53@PassOneChe

; 973  :                 break;
; 974  :             }
; 975  :             /* make sure it becomes a strong external */
; 976  :             if ( sym->state == SYM_EXTERNAL )

	cmp	edx, 2
	jne	SHORT $LN22@PassOneChe
$LN61@PassOneChe:

; 977  :                 sym->used = TRUE;

	or	BYTE PTR [rax+48], 1
$LN22@PassOneChe:

; 965  :         for( curr = SymTables[TAB_ALIAS].head ; curr != NULL ;curr = curr->next ) {

	mov	rcx, QWORD PTR [rcx+112]
	test	rcx, rcx
	jne	SHORT $LL23@PassOneChe

; 968  :             /* check if symbol is external or public */
; 969  :             if ( sym == NULL ||
; 970  :                 ( sym->state != SYM_EXTERNAL &&
; 971  :                  ( sym->state != SYM_INTERNAL || sym->ispublic == FALSE ))) {

	jmp	SHORT $LN21@PassOneChe
$LN53@PassOneChe:

; 972  :                 SkipSavedState();

	call	SkipSavedState
$LN21@PassOneChe:

; 978  :         }
; 979  :     }
; 980  : #endif
; 981  : 
; 982  : #endif /* FASTPASS */
; 983  : 
; 984  :     /* scan the EXTERN/EXTERNDEF items */
; 985  : 
; 986  :     for( curr = SymTables[TAB_EXT].head ; curr; curr = next ) {

	mov	rax, QWORD PTR SymTables+16
	test	rax, rax
	je	SHORT $LN14@PassOneChe
$LL16@PassOneChe:

; 987  :         next = curr->next;
; 988  :         /* v2.01: externdefs which have been "used" become "strong" */
; 989  :         if ( curr->sym.used )

	movzx	ecx, BYTE PTR [rax+48]
	mov	rbx, QWORD PTR [rax+112]
	test	cl, 1
	je	SHORT $LN13@PassOneChe

; 990  :             curr->sym.weak = FALSE;

	and	BYTE PTR [rax+55], 247			; 000000f7H
$LN13@PassOneChe:

; 991  :         /* remove unused EXTERNDEF/PROTO items from queue. */
; 992  :         if ( curr->sym.weak == TRUE
; 993  : #if DLLIMPORT
; 994  :             && curr->sym.iat_used == FALSE
; 995  : #endif
; 996  :            ) {

	movzx	edx, BYTE PTR [rax+55]
	test	dl, 8
	je	SHORT $LN12@PassOneChe
	test	cl, 8
	jne	SHORT $LN12@PassOneChe

; 997  :             sym_remove_table( &SymTables[TAB_EXT], curr );

	lea	rcx, OFFSET FLAT:SymTables+16
	mov	rdx, rax
	call	sym_remove_table

; 998  : #ifdef DEBUG_OUT
; 999  :             cntUnusedExt++;
; 1000 : #endif
; 1001 :             continue;

	jmp	SHORT $LN15@PassOneChe
$LN12@PassOneChe:

; 1002 :         }
; 1003 : 
; 1004 : #if FASTMEM==0
; 1005 :         /* v2.05: clear fixup list (used for backpatching in pass one) */
; 1006 :         if ( curr->sym.bp_fixup ) {
; 1007 :             struct fixup *c;
; 1008 :             struct fixup *n;
; 1009 :             for( c = curr->sym.bp_fixup ; c; ) {
; 1010 :                 n = c->nextbp;
; 1011 :                 LclFree( c );
; 1012 :                 c = n;
; 1013 :             }
; 1014 :             curr->sym.bp_fixup = NULL;
; 1015 :         }
; 1016 : #endif
; 1017 : 
; 1018 :         if ( curr->sym.iscomm == TRUE )

	test	dl, 4
	jne	SHORT $LN15@PassOneChe

; 1019 :             continue;
; 1020 :         /* optional alternate symbol must be INTERNAL or EXTERNAL.
; 1021 :          * COFF ( and ELF? ) also wants internal symbols to be public
; 1022 :          * ( which is reasonable, since the linker won't know private
; 1023 :          * symbols and hence will search for a symbol of that name
; 1024 :          * "elsewhere" ).
; 1025 :          */
; 1026 : #if FASTPASS
; 1027 :         if ( curr->sym.altname ) {

	mov	rcx, QWORD PTR [rax+72]
	test	rcx, rcx
	je	SHORT $LN15@PassOneChe

; 1028 :             if ( curr->sym.altname->state == SYM_INTERNAL ) {

	mov	eax, DWORD PTR [rcx+40]
	cmp	eax, 1
	jne	SHORT $LN9@PassOneChe

; 1029 : #if COFF_SUPPORT || ELF_SUPPORT
; 1030 :                 /* for COFF/ELF, the altname must be public or external */
; 1031 :                 if ( curr->sym.altname->ispublic == FALSE &&
; 1032 :                     ( Options.output_format == OFORMAT_COFF
; 1033 : #if ELF_SUPPORT
; 1034 :                      || Options.output_format == OFORMAT_ELF
; 1035 : #endif
; 1036 :                     ) ) {

	test	BYTE PTR [rcx+48], 128			; 00000080H
	jne	SHORT $LN15@PassOneChe
	mov	eax, DWORD PTR Options+156
	cmp	eax, 2
	je	SHORT $LN7@PassOneChe
	cmp	eax, 3
	jne	SHORT $LN15@PassOneChe

; 1037 :                     SkipSavedState();
; 1038 :                 }

	jmp	SHORT $LN7@PassOneChe
$LN9@PassOneChe:

; 1039 : #endif
; 1040 :             } else if ( curr->sym.altname->state != SYM_EXTERNAL ) {

	cmp	eax, 2
	je	SHORT $LN15@PassOneChe
$LN7@PassOneChe:

; 1041 :                 /* do not use saved state, scan full source in second pass */
; 1042 :                 SkipSavedState();

	call	SkipSavedState
$LN15@PassOneChe:

; 978  :         }
; 979  :     }
; 980  : #endif
; 981  : 
; 982  : #endif /* FASTPASS */
; 983  : 
; 984  :     /* scan the EXTERN/EXTERNDEF items */
; 985  : 
; 986  :     for( curr = SymTables[TAB_EXT].head ; curr; curr = next ) {

	test	rbx, rbx
	mov	rax, rbx
	jne	SHORT $LL16@PassOneChe
$LN14@PassOneChe:

; 1043 :             }
; 1044 :         }
; 1045 : #endif
; 1046 :     }
; 1047 : 
; 1048 : #ifdef DEBUG_OUT
; 1049 :     DebugMsg(("PassOneChecks: removed unused externals: %u\n", cntUnusedExt ));
; 1050 :     DebugMsg(("PassOneChecks: forward references:\n"));
; 1051 :     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {
; 1052 :         int i;
; 1053 :         int j;
; 1054 :         struct asym * sym;
; 1055 :         struct fixup * fix;
; 1056 :         for ( i = 0, j = 0, sym = curr->e.seginfo->label_list; sym; sym = (struct asym *)((struct dsym *)sym)->next ) {
; 1057 :             i++;
; 1058 :             for ( fix = sym->bp_fixup; fix ; fix = fix->nextbp, j++ );
; 1059 :         }
; 1060 :         DebugMsg(("PassOneChecks: segm=%s, labels=%u forward refs=%u\n", curr->sym.name, i, j));
; 1061 :     }
; 1062 : #endif
; 1063 : 
; 1064 :     if ( ModuleInfo.g.error_count == 0 ) {

	cmp	DWORD PTR ModuleInfo, 0
	jne	SHORT $LN1@PassOneChe

; 1065 : 
; 1066 :         /* make all symbols of type SYM_INTERNAL, which aren't
; 1067 :          a constant, public.  */
; 1068 :         if ( Options.all_symbols_public )

	cmp	BYTE PTR Options+150, 0
	je	SHORT $LN3@PassOneChe

; 1069 :             SymMakeAllSymbolsPublic();

	call	SymMakeAllSymbolsPublic
$LN3@PassOneChe:

; 1070 : 
; 1071 :         if ( Options.syntax_check_only == FALSE )

	movzx	eax, BYTE PTR write_to_file
	cmp	BYTE PTR Options+184, 0
	mov	ecx, 1
	cmove	eax, ecx
	mov	BYTE PTR write_to_file, al

; 1072 :             write_to_file = TRUE;
; 1073 : 
; 1074 :         if ( ModuleInfo.g.Pass1Checks )

	mov	rax, QWORD PTR ModuleInfo+304
	test	rax, rax
	je	SHORT $LN1@PassOneChe

; 1075 :             ModuleInfo.g.Pass1Checks( &ModuleInfo );

	lea	rcx, OFFSET FLAT:ModuleInfo
	call	rax
$LN1@PassOneChe:

; 1076 :     }
; 1077 : 
; 1078 : 
; 1079 :     return;
; 1080 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
PassOneChecks ENDP
_TEXT	ENDS
EXTRN	ClearSrcStack:NEAR
EXTRN	LinnumFini:NEAR
EXTRN	ProcessFile:NEAR
EXTRN	SearchFile:NEAR
EXTRN	ParseLine:NEAR
EXTRN	Tokenize:NEAR
EXTRN	MacroLevel:BYTE
EXTRN	set_curr_srcfile:NEAR
EXTRN	LineStoreCurr:QWORD
EXTRN	RestoreState:NEAR
EXTRN	StoreState:BYTE
EXTRN	CompileMacros:NEAR
EXTRN	MacroRebuild:BYTE
EXTRN	InitAutoMacros:NEAR
EXTRN	RunLineQueue:NEAR
EXTRN	LinnumInit:NEAR
EXTRN	AssumeInit:NEAR
EXTRN	MacroInit:NEAR
EXTRN	HllInit:NEAR
EXTRN	TypesInit:NEAR
EXTRN	ProcInit:NEAR
EXTRN	ContextInit:NEAR
EXTRN	SegmentInit:NEAR
EXTRN	LabelInit:NEAR
EXTRN	SymPassInit:NEAR
EXTRN	InputPassInit:NEAR
xdata	SEGMENT
$unwind$OnePass DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$OnePass DD @imagerel(OnePass#)
	DD	@imagerel(OnePass#+563)
	DD	@imagerel($unwind$OnePass#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
OnePass	PROC NEAR

; 1096 : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 1097 : 	struct src_item *fl;
; 1098 : 
; 1099 :     InputPassInit();

	call	InputPassInit

; 1100 :     ModulePassInit();

	call	ModulePassInit

; 1101 :     SymPassInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	SymPassInit

; 1102 :     LabelInit();

	call	LabelInit

; 1103 :     SegmentInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	SegmentInit

; 1104 :     ContextInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	ContextInit

; 1105 :     ProcInit();

	call	ProcInit

; 1106 :     TypesInit();

	call	TypesInit

; 1107 :     HllInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	HllInit

; 1108 :     MacroInit( Parse_Pass ); /* insert predefined macros */

	mov	ecx, DWORD PTR Parse_Pass
	call	MacroInit

; 1109 :     AssumeInit( Parse_Pass );

	mov	ecx, DWORD PTR Parse_Pass
	call	AssumeInit

; 1110 :     CmdlParamsInit( Parse_Pass );

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN16@OnePass
	call	add_cmdline_tmacros
	mov	rbx, QWORD PTR Options+112
	test	rbx, rbx
	je	SHORT $LN21@OnePass
	npad	5
$LL23@OnePass:
	lea	rcx, QWORD PTR [rbx+8]
	call	AddStringToIncludePath
	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL23@OnePass
$LN21@OnePass:
	cmp	BYTE PTR Options+152, 0
	jne	SHORT $LN16@OnePass
	lea	rcx, OFFSET FLAT:$SG6381
	call	getenv
	test	rax, rax
	je	SHORT $LN16@OnePass
	mov	rcx, rax
	call	AddStringToIncludePath
$LN16@OnePass:

; 1111 : 
; 1112 :     ModuleInfo.EndDirFound = FALSE;

	btr	DWORD PTR ModuleInfo+408, 17

; 1113 :     ModuleInfo.PhaseError = FALSE;

	mov	BYTE PTR ModuleInfo+422, 0

; 1114 :     //Modend = FALSE;
; 1115 :     /* LineNumber = 0; */
; 1116 :     LinnumInit();

	call	LinnumInit

; 1117 : 
; 1118 : #ifdef DEBUG_OUT
; 1119 :     if ( Parse_Pass > PASS_1 ) {
; 1120 :         DebugMsg(("OnePass(%u) segments (current=%s):\n", Parse_Pass + 1, CurrSeg ? CurrSeg->sym.name : "NULL" ));
; 1121 :         {
; 1122 :             struct dsym *dir;
; 1123 :             for( dir = SymTables[TAB_SEG].head; dir; dir = dir->next ) {
; 1124 :                 DebugMsg(("OnePass(%u): segm=%-8s typ=%X start=%8X max_ofs=%8X\n", Parse_Pass + 1,
; 1125 :                           dir->sym.name, dir->e.seginfo->segtype, dir->e.seginfo->start_loc, dir->sym.max_offset ));
; 1126 :             }
; 1127 :         }
; 1128 :     }
; 1129 : #endif
; 1130 : 
; 1131 : 	/* the functions above might have written something to the line queue */
; 1132 :     if ( is_linequeue_populated() )

	cmp	QWORD PTR ModuleInfo+184, 0
	je	SHORT $LN13@OnePass

; 1133 :         RunLineQueue();

	call	RunLineQueue
$LN13@OnePass:

; 1134 : 
; 1135 : 	/* Process our built-in macro library to make it available to the rest of the source */
; 1136 : 	if (Parse_Pass == PASS_1)

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN12@OnePass

; 1137 : 	{	
; 1138 : 		InitAutoMacros();

	call	InitAutoMacros

; 1139 : 		MacroRebuild = FALSE;
; 1140 : 	}
; 1141 : 	if (MacroRebuild == TRUE)

	jmp	SHORT $LN32@OnePass
$LN12@OnePass:
	cmp	BYTE PTR MacroRebuild, 1
	jne	SHORT $LN11@OnePass

; 1142 : 	{
; 1143 : 		CompileMacros();

	call	CompileMacros
$LN32@OnePass:

; 1144 : 		MacroRebuild = FALSE;

	mov	BYTE PTR MacroRebuild, 0
$LN11@OnePass:

; 1145 : 	}
; 1146 : 
; 1147 : #if FASTPASS
; 1148 :     StoreState = FALSE;
; 1149 :     if ( Parse_Pass > PASS_1 && UseSavedState == TRUE ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	BYTE PTR StoreState, 0
	jbe	$LN10@OnePass
	cmp	BYTE PTR UseSavedState, 1
	jne	$LN10@OnePass

; 1150 :         LineStoreCurr = RestoreState();

	call	RestoreState

; 1151 :         while ( LineStoreCurr && ModuleInfo.EndDirFound == FALSE ) {

	test	rax, rax
	mov	QWORD PTR LineStoreCurr, rax
	je	$LN6@OnePass
	xor	ebx, ebx
	npad	13
$LL9@OnePass:
	bt	DWORD PTR ModuleInfo+408, 17
	jb	$LN6@OnePass

; 1152 :             /* the source line is modified in Tokenize() if it contains a comment! */
; 1153 : #if USELSLINE==0
; 1154 :             strcpy( CurrSource, LineStoreCurr->line );
; 1155 : #endif
; 1156 :             set_curr_srcfile( LineStoreCurr->srcfile, LineStoreCurr->lineno );

	mov	ecx, DWORD PTR [rax+8]
	mov	edx, ecx
	shr	ecx, 20
	and	edx, 1048575				; 000fffffH
	call	set_curr_srcfile

; 1157 :             /* v2.06: list flags now initialized on the top level */
; 1158 :             ModuleInfo.line_flags = 0;
; 1159 :             MacroLevel = ( LineStoreCurr->srcfile == 0xFFF ? 1 : 0 );

	mov	rcx, QWORD PTR LineStoreCurr

; 1160 :             DebugMsg1(("OnePass(%u) cur/nxt=%X/%X src=%X.%u mlvl=%u: >%s<\n", Parse_Pass+1, LineStoreCurr, LineStoreCurr->next, LineStoreCurr->srcfile, LineStoreCurr->lineno, MacroLevel, LineStoreCurr->line ));
; 1161 :             ModuleInfo.CurrComment = NULL; /* v2.08: added (var is never reset because GetTextLine() isn't called) */
; 1162 : #if USELSLINE
; 1163 :             if ( Token_Count = Tokenize( LineStoreCurr->line, 0, ModuleInfo.tokenarray, TOK_DEFAULT ) )

	mov	r8, QWORD PTR ModuleInfo+480
	mov	BYTE PTR ModuleInfo+398, bl
	mov	eax, DWORD PTR [rcx+8]
	mov	QWORD PTR ModuleInfo+472, rbx
	and	eax, -1048576				; fff00000H
	cmp	eax, -1048576				; fff00000H
	sete	BYTE PTR MacroLevel
	add	rcx, 16
	xor	r9d, r9d
	xor	edx, edx
	call	Tokenize
	test	eax, eax
	mov	DWORD PTR ModuleInfo+496, eax
	je	SHORT $LN7@OnePass

; 1164 : #else
; 1165 :             if ( Token_Count = Tokenize( CurrSource, 0, ModuleInfo.tokenarray, TOK_DEFAULT ) )
; 1166 : #endif
; 1167 :                 ParseLine( ModuleInfo.tokenarray );

	mov	rcx, QWORD PTR ModuleInfo+480
	call	ParseLine
$LN7@OnePass:

; 1168 :             LineStoreCurr = LineStoreCurr->next;

	mov	rax, QWORD PTR LineStoreCurr
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	mov	QWORD PTR LineStoreCurr, rax
	jne	$LL9@OnePass

; 1169 :         }
; 1170 :     } else

	jmp	SHORT $LN6@OnePass
$LN10@OnePass:

; 1171 : #endif
; 1172 :     {
; 1173 :         struct qitem *pq;
; 1174 :         /* v2.11: handle -Fi files here ( previously in CmdlParamsInit ) */
; 1175 :         for ( pq = Options.queues[OPTQ_FINCLUDE]; pq; pq = pq->next ) {

	mov	rbx, QWORD PTR Options+96
	test	rbx, rbx
	je	SHORT $LN3@OnePass
	npad	4
$LL5@OnePass:

; 1176 :             DebugMsg(("OnePass: force include of file: %s\n", pq->value ));
; 1177 :             if ( SearchFile( pq->value, TRUE ) )

	lea	rcx, QWORD PTR [rbx+8]
	mov	dl, 1
	call	SearchFile
	test	rax, rax
	je	SHORT $LN4@OnePass

; 1178 :                 ProcessFile( ModuleInfo.tokenarray );

	mov	rcx, QWORD PTR ModuleInfo+480
	call	ProcessFile
$LN4@OnePass:
	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL5@OnePass
$LN3@OnePass:

; 1179 :         }
; 1180 :         ProcessFile( ModuleInfo.tokenarray ); /* process the main source file */

	mov	rcx, QWORD PTR ModuleInfo+480
	call	ProcessFile
$LN6@OnePass:

; 1181 :     }
; 1182 : 
; 1183 :     LinnumFini();

	call	LinnumFini

; 1184 : 
; 1185 :     if ( Parse_Pass == PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN1@OnePass

; 1186 :         PassOneChecks();

	call	PassOneChecks
$LN1@OnePass:

; 1187 : 
; 1188 :     ClearSrcStack();

	call	ClearSrcStack

; 1189 : 
; 1190 :     return( 1 );

	mov	eax, 1

; 1191 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
OnePass	ENDP
_TEXT	ENDS
EXTRN	isdigit:NEAR
EXTRN	_strupr:NEAR
EXTRN	GetExtPart:NEAR
EXTRN	GetFNamePart:NEAR
EXTRN	strncpy:NEAR
xdata	SEGMENT
$unwind$get_module_name DD 031001H
	DD	083410H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$get_module_name DD @imagerel(get_module_name#)
	DD	@imagerel(get_module_name#+58)
	DD	@imagerel($unwind$get_module_name#)
pdata	ENDS
xdata	SEGMENT
$chain$1$get_module_name DD 020521H
	DD	097405H
	DD	@imagerel(get_module_name#)
	DD	@imagerel(get_module_name#+58)
	DD	@imagerel($unwind$get_module_name#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$get_module_name DD @imagerel(get_module_name#+58)
	DD	@imagerel(get_module_name#+115)
	DD	@imagerel($chain$1$get_module_name#)
pdata	ENDS
xdata	SEGMENT
$chain$2$get_module_name DD 021H
	DD	@imagerel(get_module_name#)
	DD	@imagerel(get_module_name#+58)
	DD	@imagerel($unwind$get_module_name#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$get_module_name DD @imagerel(get_module_name#+115)
	DD	@imagerel(get_module_name#+223)
	DD	@imagerel($chain$2$get_module_name#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
get_module_name PROC NEAR

; 1221 : {

	sub	rsp, 40					; 00000028H

; 1222 :     //char dummy[_MAX_EXT];
; 1223 :     char        *p;
; 1224 : 
; 1225 :     /* v2.08: prefer name given by -nm option */
; 1226 :     if ( Options.names[OPTN_MODULE_NAME] ) {

	mov	rdx, QWORD PTR Options+64
	mov	QWORD PTR [rsp+64], rbx
	test	rdx, rdx
	je	SHORT $LN7@get_module

; 1227 :         strncpy( ModuleInfo.name, Options.names[OPTN_MODULE_NAME], sizeof( ModuleInfo.name ) );

	lea	rbx, OFFSET FLAT:ModuleInfo+512
	mov	r8d, 260				; 00000104H
	mov	rcx, rbx
	call	strncpy

; 1228 :         ModuleInfo.name[ sizeof( ModuleInfo.name ) - 1] = NULLC;

	mov	BYTE PTR ModuleInfo+771, 0

; 1229 :     } else {

	jmp	SHORT $LN6@get_module
$LN7@get_module:

; 1230 :         /* v2.12: _splitpath()/_makepath() removed */
; 1231 :         const char *fn = GetFNamePart( CurrFName[ASM] );

	mov	rcx, QWORD PTR ModuleInfo+128
	mov	QWORD PTR [rsp+72], rdi
	call	GetFNamePart

; 1232 :         char *ext = GetExtPart( fn );

	mov	rcx, rax
	mov	rbx, rax
	call	GetExtPart

; 1233 :         memcpy( ModuleInfo.name, fn, ext - fn );

	mov	rdx, rbx
	mov	rdi, rax
	sub	rdi, rbx
	lea	rbx, OFFSET FLAT:ModuleInfo+512
	mov	rcx, rbx
	mov	r8, rdi
	call	memcpy

; 1234 :         ModuleInfo.name[ ext - fn ] = NULLC;

	mov	BYTE PTR [rdi+rbx], 0
	mov	rdi, QWORD PTR [rsp+72]
$LN6@get_module:

; 1235 :         //_splitpath( CurrFName[ASM], NULL, NULL, ModuleInfo.name, dummy );
; 1236 :     }
; 1237 : 
; 1238 :     _strupr( ModuleInfo.name );

	mov	rcx, rbx
	call	_strupr

; 1239 :     /* the module name must be a valid identifier, because it's used
; 1240 :      * as part of a segment name in certain memory models.
; 1241 :      */
; 1242 :     for( p = ModuleInfo.name; *p; ++p ) {

	movzx	eax, BYTE PTR ModuleInfo+512
	test	al, al
	je	SHORT $LN3@get_module
$LL5@get_module:

; 1243 :         if( !( isalnum( *p ) || ( *p == '_' ) || ( *p == '$' )
; 1244 :             || ( *p == '@' ) || ( *p == '?') ) ) {

	movsx	ecx, BYTE PTR [rbx]
	call	isalnum
	test	eax, eax
	jne	SHORT $LN4@get_module
	movzx	eax, BYTE PTR [rbx]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN4@get_module
	cmp	al, 36					; 00000024H
	je	SHORT $LN4@get_module
	cmp	al, 64					; 00000040H
	je	SHORT $LN4@get_module
	cmp	al, 63					; 0000003fH
	je	SHORT $LN4@get_module

; 1245 :             /* it's not a legal character for a symbol name */
; 1246 :             *p = '_';

	mov	BYTE PTR [rbx], 95			; 0000005fH
$LN4@get_module:

; 1239 :     /* the module name must be a valid identifier, because it's used
; 1240 :      * as part of a segment name in certain memory models.
; 1241 :      */
; 1242 :     for( p = ModuleInfo.name; *p; ++p ) {

	inc	rbx
	cmp	BYTE PTR [rbx], 0
	jne	SHORT $LL5@get_module
	mov	al, BYTE PTR ModuleInfo+512
$LN3@get_module:

; 1247 :         }
; 1248 :     }
; 1249 :     /* first character can't be a digit either */
; 1250 :     if( isdigit( ModuleInfo.name[0] ) ) {

	movsx	ecx, al
	call	isdigit
	movzx	ecx, BYTE PTR ModuleInfo+512
	mov	rbx, QWORD PTR [rsp+64]
	test	eax, eax
	mov	edx, 95					; 0000005fH
	cmovne	ecx, edx
	mov	BYTE PTR ModuleInfo+512, cl

; 1251 :         ModuleInfo.name[0] = '_';
; 1252 :     }
; 1253 : }

	add	rsp, 40					; 00000028H
	ret	0
get_module_name ENDP
_TEXT	ENDS
EXTRN	memset:NEAR
xdata	SEGMENT
$unwind$ModuleInit DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$ModuleInit DD @imagerel(ModuleInit#)
	DD	@imagerel(ModuleInit#+179)
	DD	@imagerel($unwind$ModuleInit#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
ModuleInit PROC NEAR

; 1260 : {

	sub	rsp, 40					; 00000028H

; 1261 :     ModuleInfo.sub_format = Options.sub_format;

	mov	eax, DWORD PTR Options+160

; 1262 :     ModuleInfo.fmtopt = &formatoptions[Options.output_format];

	movsxd	rcx, DWORD PTR Options+156
	lea	rdx, OFFSET FLAT:formatoptions
	mov	DWORD PTR ModuleInfo+372, eax
	mov	rax, rcx
	shl	rax, 4
	add	rax, rdx

; 1263 :     ModuleInfo.CommentDataInCode = (Options.output_format == OFORMAT_OMF &&
; 1264 :                          Options.no_comment_data_in_code_records == FALSE);

	cmp	ecx, 1
	mov	QWORD PTR ModuleInfo+344, rax
	jne	SHORT $LN3@ModuleInit
	cmp	BYTE PTR Options+120, 0
	mov	BYTE PTR ModuleInfo+423, cl
	je	SHORT $LN4@ModuleInit
$LN3@ModuleInit:
	mov	BYTE PTR ModuleInfo+423, 0
$LN4@ModuleInit:

; 1265 :     ModuleInfo.g.error_count = 0;
; 1266 :     ModuleInfo.g.warning_count = 0;
; 1267 :     ModuleInfo.model = MODEL_NONE;
; 1268 :     /* ModuleInfo.distance = STACK_NONE; */
; 1269 :     ModuleInfo.ostype = OPSYS_DOS;
; 1270 :     ModuleInfo.emulator = (Options.floating_point == FPO_EMULATION);

	mov	eax, DWORD PTR ModuleInfo+408
	xor	ecx, ecx
	cmp	DWORD PTR Options+4, 1
	mov	DWORD PTR ModuleInfo, ecx
	mov	DWORD PTR ModuleInfo+4, ecx
	mov	DWORD PTR ModuleInfo+360, ecx
	mov	DWORD PTR ModuleInfo+368, ecx
	sete	cl
	shl	ecx, 10
	xor	ecx, eax
	and	ecx, 1024				; 00000400H
	xor	eax, ecx
	mov	DWORD PTR ModuleInfo+408, eax

; 1271 :     //ModuleInfo.flatgrp_idx = 0;
; 1272 : 
; 1273 :     get_module_name(); /* set ModuleInfo.name */

	call	get_module_name

; 1274 : 
; 1275 :     /* v2.06: ST_PROC has been removed */
; 1276 :     //SimpleType[ST_PROC].mem_type = MT_NEAR;
; 1277 : 
; 1278 :     memset( SymTables, 0, sizeof( SymTables[0] ) * TAB_LAST );

	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+96]
	lea	rcx, OFFSET FLAT:SymTables
	call	memset

; 1279 :     ModuleInfo.fmtopt->init( &ModuleInfo );

	mov	rax, QWORD PTR ModuleInfo+344
	lea	rcx, OFFSET FLAT:ModuleInfo

; 1280 : 
; 1281 :     return;
; 1282 : }

	add	rsp, 40					; 00000028H
	rex_jmp	QWORD PTR [rax]
ModuleInit ENDP
_TEXT	ENDS
EXTRN	DisableKeyword:NEAR
EXTRN	ResWordsInit:NEAR
xdata	SEGMENT
$unwind$ReswTableInit DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$ReswTableInit DD @imagerel(ReswTableInit#)
	DD	@imagerel(ReswTableInit#+72)
	DD	@imagerel($unwind$ReswTableInit#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
ReswTableInit PROC NEAR

; 1286 : {

	sub	rsp, 40					; 00000028H

; 1287 :     ResWordsInit();

	call	ResWordsInit

; 1288 :     if ( Options.output_format == OFORMAT_OMF ) {

	cmp	DWORD PTR Options+156, 1
	jne	SHORT $LN2@ReswTableI

; 1289 :         /* DebugMsg(("InitAsm: disable IMAGEREL+SECTIONREL\n")); */
; 1290 :         /* for OMF, IMAGEREL and SECTIONREL are disabled */
; 1291 : #if IMAGERELSUPP
; 1292 :         DisableKeyword( T_IMAGEREL );

	mov	ecx, 233				; 000000e9H
	call	DisableKeyword

; 1293 : #endif
; 1294 : #if SECTIONRELSUPP
; 1295 :         DisableKeyword( T_SECTIONREL );

	mov	ecx, 243				; 000000f3H
	call	DisableKeyword
$LN2@ReswTableI:

; 1296 : #endif
; 1297 :     }
; 1298 : 
; 1299 :     if ( Options.strict_masm_compat == TRUE ) {

	cmp	BYTE PTR Options+136, 1
	jne	SHORT $LN1@ReswTableI

; 1300 :         DebugMsg(("ReswTableInit: disable INCBIN + FASTCALL keywords\n"));
; 1301 :         DisableKeyword( T_INCBIN );

	mov	ecx, 449				; 000001c1H
	call	DisableKeyword

; 1302 :         DisableKeyword( T_FASTCALL );

	mov	ecx, 270				; 0000010eH
	call	DisableKeyword
$LN1@ReswTableI:

; 1303 :     }
; 1304 : 
; 1305 :     return;
; 1306 : }

	add	rsp, 40					; 00000028H
	ret	0
ReswTableInit ENDP
_TEXT	ENDS
EXTRN	Fatal:NEAR
xdata	SEGMENT
$unwind$open_files DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$open_files DD @imagerel(open_files#)
	DD	@imagerel(open_files#+195)
	DD	@imagerel($unwind$open_files#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
open_files PROC NEAR

; 1310 : {

	sub	rsp, 40					; 00000028H

; 1311 :     /* open ASM file */
; 1312 :     DebugMsg(("open_files() enter\n" ));
; 1313 : 
; 1314 :     //memset( CurrFile, 0, sizeof( CurrFile ) );
; 1315 :     /* CurrFile[ASM] = fopen( CurrFName[ASM], "r" ); */
; 1316 :     CurrFile[ASM] = fopen( CurrFName[ASM], "rb" );

	mov	rcx, QWORD PTR ModuleInfo+128
	lea	rdx, OFFSET FLAT:$SG6520
	call	fopen

; 1317 :     if( CurrFile[ASM] == NULL ) {

	test	rax, rax
	mov	QWORD PTR ModuleInfo+96, rax
	jne	SHORT $LN5@open_files

; 1318 :         DebugMsg(("open_files(): cannot open source file, fopen(\"%s\") failed\n", CurrFName[ASM] ));
; 1319 :         Fatal( CANNOT_OPEN_FILE, CurrFName[ASM], ErrnoStr() );

	call	ErrnoStr
	mov	rdx, QWORD PTR ModuleInfo+128
	mov	ecx, 106				; 0000006aH
	mov	r8, rax
	call	Fatal
$LN5@open_files:

; 1320 :     }
; 1321 : 
; 1322 :     /* open OBJ file */
; 1323 :     if ( Options.syntax_check_only == FALSE ) {

	cmp	BYTE PTR Options+184, 0
	jne	SHORT $LN3@open_files

; 1324 :         CurrFile[OBJ] = fopen( CurrFName[OBJ], "wb" );

	mov	rcx, QWORD PTR ModuleInfo+136
	lea	rdx, OFFSET FLAT:$SG6524
	call	fopen

; 1325 :         if( CurrFile[OBJ] == NULL ) {

	test	rax, rax
	mov	QWORD PTR ModuleInfo+104, rax
	jne	SHORT $LN3@open_files

; 1326 :             DebugMsg(("open_files(): cannot open object file, fopen(\"%s\") failed\n", CurrFName[OBJ] ));
; 1327 :             Fatal( CANNOT_OPEN_FILE, CurrFName[OBJ], ErrnoStr() );

	call	ErrnoStr
	mov	rdx, QWORD PTR ModuleInfo+136
	mov	ecx, 106				; 0000006aH
	mov	r8, rax
	call	Fatal
$LN3@open_files:

; 1328 :         }
; 1329 :         DebugMsg(("open_files(): output, fopen(\"%s\") ok\n", CurrFName[OBJ] ));
; 1330 :     }
; 1331 : 
; 1332 :     if( Options.write_listing ) {

	cmp	BYTE PTR Options+129, 0
	je	SHORT $LN1@open_files

; 1333 :         CurrFile[LST] = fopen( CurrFName[LST], "wb" );

	mov	rcx, QWORD PTR ModuleInfo+144
	lea	rdx, OFFSET FLAT:$SG6528
	call	fopen

; 1334 :         if ( CurrFile[LST] == NULL )

	test	rax, rax
	mov	QWORD PTR ModuleInfo+112, rax
	jne	SHORT $LN1@open_files

; 1335 :             Fatal( CANNOT_OPEN_FILE, CurrFName[LST], ErrnoStr() );

	call	ErrnoStr
	mov	rdx, QWORD PTR ModuleInfo+144
	mov	ecx, 106				; 0000006aH
	mov	r8, rax
	call	Fatal
$LN1@open_files:

; 1336 :     }
; 1337 :     return;
; 1338 : }

	add	rsp, 40					; 00000028H
	ret	0
open_files ENDP
_TEXT	ENDS
PUBLIC	close_files
EXTRN	remove:NEAR
EXTRN	_errno:NEAR
xdata	SEGMENT
$unwind$close_files DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$close_files DD @imagerel($LN12#)
	DD	@imagerel($LN12#+217)
	DD	@imagerel($unwind$close_files#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
close_files PROC NEAR

; 1342 : {

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1343 :     /* v2.11: no fatal errors anymore if fclose() fails.
; 1344 :      * That's because Fatal() may cause close_files() to be
; 1345 :      * reentered and thus cause an endless loop.
; 1346 :      */
; 1347 : 
; 1348 :     /* close ASM file */
; 1349 :     if( CurrFile[ASM] != NULL ) {

	mov	rcx, QWORD PTR ModuleInfo+96
	xor	ebx, ebx
	test	rcx, rcx
	je	SHORT $LN9@close_file

; 1350 :         if( fclose( CurrFile[ASM] ) != 0 )

	call	fclose
	test	eax, eax
	je	SHORT $LN8@close_file

; 1351 :             EmitErr( CANNOT_CLOSE_FILE, CurrFName[ASM], errno );

	call	_errno
	mov	rdx, QWORD PTR ModuleInfo+128
	lea	ecx, QWORD PTR [rbx+107]
	mov	r8d, DWORD PTR [rax]
	call	EmitErr
$LN8@close_file:

; 1352 :         CurrFile[ASM] = NULL;

	mov	QWORD PTR ModuleInfo+96, rbx
$LN9@close_file:

; 1353 :     }
; 1354 : 
; 1355 :     /* close OBJ file */
; 1356 :     if ( CurrFile[OBJ] != NULL ) {

	mov	rcx, QWORD PTR ModuleInfo+104
	test	rcx, rcx
	je	SHORT $LN7@close_file

; 1357 :         if ( fclose( CurrFile[OBJ] ) != 0 )

	call	fclose
	test	eax, eax
	je	SHORT $LN6@close_file

; 1358 :             EmitErr( CANNOT_CLOSE_FILE, CurrFName[OBJ], errno );

	call	_errno
	mov	rdx, QWORD PTR ModuleInfo+136
	mov	ecx, 107				; 0000006bH
	mov	r8d, DWORD PTR [rax]
	call	EmitErr
$LN6@close_file:

; 1359 :         CurrFile[OBJ] = NULL;

	mov	QWORD PTR ModuleInfo+104, rbx
$LN7@close_file:

; 1360 :     }
; 1361 :     /* delete the object module if errors occured */
; 1362 :     if ( Options.syntax_check_only == FALSE &&
; 1363 :         ModuleInfo.g.error_count > 0 ) {

	cmp	BYTE PTR Options+184, bl
	jne	SHORT $LN5@close_file
	cmp	DWORD PTR ModuleInfo, ebx
	jbe	SHORT $LN5@close_file

; 1364 :         remove( CurrFName[OBJ] );

	mov	rcx, QWORD PTR ModuleInfo+136
	call	remove
$LN5@close_file:

; 1365 :     }
; 1366 : 
; 1367 :     if( CurrFile[LST] != NULL ) {

	mov	rcx, QWORD PTR ModuleInfo+112
	test	rcx, rcx
	je	SHORT $LN4@close_file

; 1368 :         fclose( CurrFile[LST] );

	call	fclose

; 1369 :         CurrFile[LST] = NULL;

	mov	QWORD PTR ModuleInfo+112, rbx
$LN4@close_file:

; 1370 :     }
; 1371 : 
; 1372 :     /* close ERR file */
; 1373 :     if ( CurrFile[ERR] != NULL ) {

	mov	rcx, QWORD PTR ModuleInfo+120
	test	rcx, rcx
	je	SHORT $LN3@close_file

; 1374 :         fclose( CurrFile[ERR] );

	call	fclose

; 1375 :         CurrFile[ERR] = NULL;

	mov	QWORD PTR ModuleInfo+120, rbx

; 1379 :     return;
; 1380 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@close_file:

; 1376 :     } else if ( CurrFName[ERR] )

	mov	rcx, QWORD PTR ModuleInfo+152
	test	rcx, rcx
	je	SHORT $LN1@close_file

; 1377 :         /* nothing written, delete any existing ERR file */
; 1378 :         remove( CurrFName[ERR] );

	call	remove
$LN1@close_file:

; 1379 :     return;
; 1380 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
close_files ENDP
; Function compile flags: /Ogtpy
type$ = 8
GetExt	PROC NEAR

; 1387 :     switch ( type ) {

	dec	ecx
	je	SHORT $LN7@GetExt
	dec	ecx
	je	SHORT $LN2@GetExt
	dec	ecx
	je	SHORT $LN1@GetExt

; 1407 :     }
; 1408 :     return( NULL );

	xor	eax, eax

; 1409 : }

	ret	0
$LN1@GetExt:

; 1405 :     case ERR:
; 1406 :         return( ERR_EXT );

	lea	rax, OFFSET FLAT:$SG6569

; 1409 : }

	ret	0
$LN2@GetExt:

; 1403 :     case LST:
; 1404 :         return( LST_EXT );

	lea	rax, OFFSET FLAT:$SG6567

; 1409 : }

	ret	0
$LN7@GetExt:

; 1388 :     case OBJ:
; 1389 : #if BIN_SUPPORT
; 1390 :         if ( Options.output_format == OFORMAT_BIN )

	cmp	DWORD PTR Options+156, 0
	jne	SHORT $LN3@GetExt

; 1391 : #if MZ_SUPPORT || PE_SUPPORT
; 1392 :             if ( Options.sub_format == SFORMAT_MZ
; 1393 : #if PE_SUPPORT
; 1394 :                 || Options.sub_format == SFORMAT_PE
; 1395 : #endif
; 1396 :                )

	mov	eax, DWORD PTR Options+160
	cmp	eax, 1
	je	SHORT $LN4@GetExt
	cmp	eax, 2
	je	SHORT $LN4@GetExt

; 1398 :             else
; 1399 : #endif
; 1400 :                 return( BIN_EXT );

	lea	rax, OFFSET FLAT:$SG6564

; 1409 : }

	ret	0
$LN4@GetExt:

; 1397 :                 return( EXE_EXT );

	lea	rax, OFFSET FLAT:$SG6562

; 1409 : }

	ret	0
$LN3@GetExt:

; 1401 : #endif
; 1402 :         return( OBJ_EXT );

	lea	rax, OFFSET FLAT:$SG6565

; 1409 : }

	ret	0
GetExt	ENDP
_TEXT	ENDS
EXTRN	DefaultDir:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	LclAlloc:NEAR
xdata	SEGMENT
$unwind$SetFilenames DD 0c6b01H
	DD	026c46bH
	DD	02a6463H
	DD	0295458H
	DD	02b7415H
	DD	028340eH
	DD	027010aH
xdata	ENDS
pdata	SEGMENT
$pdata$SetFilenames DD @imagerel(SetFilenames#)
	DD	@imagerel(SetFilenames#+687)
	DD	@imagerel($unwind$SetFilenames#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
path$ = 32
name$ = 320
SetFilenames PROC NEAR

; 1422 : {

	mov	rax, rsp
	sub	rsp, 312				; 00000138H
	mov	QWORD PTR [rax+8], rbx
	mov	rbx, rcx
	mov	QWORD PTR [rax+32], rdi

; 1423 :     int i;
; 1424 :     const char *fn;
; 1425 :     char *ext;
; 1426 :     char path[ FILENAME_MAX ];
; 1427 : 
; 1428 :     DebugMsg(("SetFilenames(\"%s\") enter\n", name ));
; 1429 : 
; 1430 :     /* set CurrFName[ASM] */
; 1431 :     CurrFName[ASM] = LclAlloc( strlen( name ) + 1 );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	call	LclAlloc

; 1432 :     strcpy( CurrFName[ASM], name );

	mov	rdx, rbx
	mov	QWORD PTR ModuleInfo+128, rax
	npad	11
$LL11@SetFilenam:
	movzx	ecx, BYTE PTR [rdx]
	inc	rax
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL11@SetFilenam
	mov	QWORD PTR [rsp+328], rbp

; 1433 : 
; 1434 :     /* set [OBJ], [ERR], [LST] */
; 1435 :     fn = GetFNamePart( name );

	mov	rcx, rbx
	mov	QWORD PTR [rsp+336], rsi
	mov	QWORD PTR [rsp+304], r12
	call	GetFNamePart

; 1436 :     for ( i = ASM+1; i < NUM_FILE_TYPES; i++ ) {

	mov	ebx, 1
	xor	ebp, ebp
	lea	r12, OFFSET FLAT:__ImageBase
	mov	rsi, rax
$LL8@SetFilenam:

; 1437 :         if( Options.names[i] == NULL ) {

	mov	rcx, QWORD PTR Options[r12+rbp+24]
	test	rcx, rcx
	jne	$LN5@SetFilenam

; 1438 :             path[0] = NULLC;

	mov	BYTE PTR path$[rsp], cl

; 1439 :             if ( DefaultDir[i])

	mov	rcx, QWORD PTR DefaultDir[r12+rbp+8]
	test	rcx, rcx
	je	SHORT $LN4@SetFilenam

; 1440 :                 strcpy( path, DefaultDir[i] );

	lea	rdx, QWORD PTR path$[rsp]
	sub	rdx, rcx
	npad	5
$LL12@SetFilenam:
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx+rcx-1], al
	jne	SHORT $LL12@SetFilenam
$LN4@SetFilenam:

; 1441 :             strcat( path, fn );

	xor	eax, eax
	lea	rdi, QWORD PTR path$[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
$LL49@SetFilenam:
	movzx	eax, BYTE PTR [rsi+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL49@SetFilenam

; 1442 :             ext = GetExtPart( path );

	lea	rcx, QWORD PTR path$[rsp]
	call	GetExtPart

; 1443 :             *ext++  = '.';

	mov	BYTE PTR [rax], 46			; 0000002eH
	lea	rdx, QWORD PTR [rax+1]

; 1444 :             strcpy( ext, GetExt( i ) );

	mov	eax, ebx
	dec	eax
	je	SHORT $LN24@SetFilenam
	dec	eax
	je	SHORT $LN19@SetFilenam
	dec	eax
	je	SHORT $LN18@SetFilenam
	xor	ecx, ecx
	jmp	SHORT $LL27@SetFilenam
$LN18@SetFilenam:
	lea	rcx, OFFSET FLAT:$SG6569
	jmp	SHORT $LL27@SetFilenam
$LN19@SetFilenam:
	lea	rcx, OFFSET FLAT:$SG6567
	jmp	SHORT $LL27@SetFilenam
$LN24@SetFilenam:
	cmp	DWORD PTR Options+156, 0
	jne	SHORT $LN20@SetFilenam
	mov	eax, DWORD PTR Options+160
	cmp	eax, 1
	je	SHORT $LN21@SetFilenam
	cmp	eax, 2
	je	SHORT $LN21@SetFilenam
	lea	rcx, OFFSET FLAT:$SG6564
	jmp	SHORT $LL27@SetFilenam
$LN21@SetFilenam:
	lea	rcx, OFFSET FLAT:$SG6562
	jmp	SHORT $LL27@SetFilenam
$LN20@SetFilenam:
	lea	rcx, OFFSET FLAT:$SG6565
	npad	10
$LL27@SetFilenam:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL27@SetFilenam

; 1445 : 
; 1446 :         } else {

	jmp	$LN1@SetFilenam
$LN5@SetFilenam:

; 1447 :             /* filename has been set by cmdline option -Fo, -Fl or -Fr */
; 1448 :             const char *fn2;
; 1449 :             strcpy( path, Options.names[i] );

	lea	rdx, QWORD PTR path$[rsp]
	sub	rdx, rcx
	npad	3
$LL14@SetFilenam:
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx+rcx-1], al
	jne	SHORT $LL14@SetFilenam

; 1450 :             fn2 = GetFNamePart( path );

	lea	rcx, QWORD PTR path$[rsp]
	call	GetFNamePart
	mov	rdi, rax

; 1451 :             if( *fn2 == NULLC )

	cmp	BYTE PTR [rax], 0
	jne	SHORT $LN2@SetFilenam

; 1452 :                 strcpy( (char *)fn2, fn );

	mov	rdx, rsi
	sub	rax, rsi
	npad	10
$LL15@SetFilenam:
	movzx	ecx, BYTE PTR [rdx]
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rax+rdx-1], cl
	jne	SHORT $LL15@SetFilenam
$LN2@SetFilenam:

; 1453 :             ext = GetExtPart( fn2 );

	mov	rcx, rdi
	call	GetExtPart
	mov	rdx, rax

; 1454 :             if( *ext == NULLC ) {

	cmp	BYTE PTR [rax], 0
	jne	SHORT $LN1@SetFilenam

; 1455 :                 *ext++  = '.';

	mov	BYTE PTR [rax], 46			; 0000002eH

; 1456 :                 strcpy( ext, GetExt( i ) );

	mov	eax, ebx
	inc	rdx
	dec	eax
	je	SHORT $LN35@SetFilenam
	dec	eax
	je	SHORT $LN30@SetFilenam
	dec	eax
	je	SHORT $LN29@SetFilenam
	xor	ecx, ecx
	jmp	SHORT $LL38@SetFilenam
$LN29@SetFilenam:
	lea	rcx, OFFSET FLAT:$SG6569
	jmp	SHORT $LL38@SetFilenam
$LN30@SetFilenam:
	lea	rcx, OFFSET FLAT:$SG6567
	jmp	SHORT $LL38@SetFilenam
$LN35@SetFilenam:
	cmp	DWORD PTR Options+156, 0
	jne	SHORT $LN31@SetFilenam
	mov	eax, DWORD PTR Options+160
	cmp	eax, 1
	je	SHORT $LN32@SetFilenam
	cmp	eax, 2
	je	SHORT $LN32@SetFilenam
	lea	rcx, OFFSET FLAT:$SG6564
	jmp	SHORT $LL38@SetFilenam
$LN32@SetFilenam:
	lea	rcx, OFFSET FLAT:$SG6562
	jmp	SHORT $LL38@SetFilenam
$LN31@SetFilenam:
	lea	rcx, OFFSET FLAT:$SG6565
	npad	6
$LL38@SetFilenam:
	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx-1], al
	jne	SHORT $LL38@SetFilenam
$LN1@SetFilenam:

; 1457 :             }
; 1458 :         }
; 1459 :         DebugMsg(("SetFilenames: i=%u >%s<\n", i, path ));
; 1460 :         CurrFName[i] = LclAlloc( strlen( path ) + 1 );

	xor	eax, eax
	lea	rdi, QWORD PTR path$[rsp]
	mov	rcx, -1
	repne scasb
	not	rcx
	call	LclAlloc

; 1461 :         strcpy( CurrFName[i], path );

	lea	rdx, QWORD PTR path$[rsp]
	mov	QWORD PTR ModuleInfo[r12+rbp+136], rax
	npad	11
$LL17@SetFilenam:
	movzx	ecx, BYTE PTR [rdx]
	inc	rax
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL17@SetFilenam
	inc	ebx
	add	rbp, 8
	cmp	ebx, 4
	jl	$LL8@SetFilenam
	mov	r12, QWORD PTR [rsp+304]
	mov	rdi, QWORD PTR [rsp+344]
	mov	rsi, QWORD PTR [rsp+336]
	mov	rbp, QWORD PTR [rsp+328]
	mov	rbx, QWORD PTR [rsp+320]

; 1462 :     }
; 1463 :     return;
; 1464 : }

	add	rsp, 312				; 00000138H
	ret	0
SetFilenames ENDP
_TEXT	ENDS
EXTRN	LstInit:NEAR
EXTRN	ExprEvalInit:NEAR
EXTRN	CondInit:NEAR
EXTRN	InputInit:NEAR
EXTRN	SymInit:NEAR
EXTRN	FastpassInit:NEAR
EXTRN	MemInit:NEAR
xdata	SEGMENT
$unwind$AssembleInit DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$AssembleInit DD @imagerel(AssembleInit#)
	DD	@imagerel(AssembleInit#+4)
	DD	@imagerel($unwind$AssembleInit#)
pdata	ENDS
xdata	SEGMENT
$chain$1$AssembleInit DD 040a21H
	DD	09740aH
	DD	083405H
	DD	@imagerel(AssembleInit#)
	DD	@imagerel(AssembleInit#+4)
	DD	@imagerel($unwind$AssembleInit#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$AssembleInit DD @imagerel(AssembleInit#+4)
	DD	@imagerel(AssembleInit#+87)
	DD	@imagerel($chain$1$AssembleInit#)
pdata	ENDS
xdata	SEGMENT
$chain$2$AssembleInit DD 020021H
	DD	097400H
	DD	@imagerel(AssembleInit#)
	DD	@imagerel(AssembleInit#+4)
	DD	@imagerel($unwind$AssembleInit#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$AssembleInit DD @imagerel(AssembleInit#+87)
	DD	@imagerel(AssembleInit#+510)
	DD	@imagerel($chain$2$AssembleInit#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
source$ = 48
AssembleInit PROC NEAR

; 1470 : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	mov	rbx, rcx

; 1471 :     DebugMsg(("AssembleInit(\"%s\") enter\n", source ));
; 1472 : 
; 1473 :     MemInit();

	call	MemInit

; 1474 :     //start_label   = NULL;
; 1475 :     //start_displ   = 0;
; 1476 :     write_to_file = FALSE;
; 1477 :     //GeneratedCode = 0;
; 1478 :     LinnumQueue.head = NULL;

	xor	edi, edi

; 1479 : 
; 1480 :     SetFilenames( source );

	mov	rcx, rbx
	mov	QWORD PTR LinnumQueue, rdi
	mov	BYTE PTR write_to_file, 0
	call	SetFilenames

; 1481 : 
; 1482 : #if FASTPASS
; 1483 :     FastpassInit();

	call	FastpassInit

; 1484 : #endif
; 1485 :     open_files();

	mov	rcx, QWORD PTR ModuleInfo+128
	lea	rdx, OFFSET FLAT:$SG6520
	call	fopen
	mov	rbx, QWORD PTR [rsp+64]
	test	rax, rax
	mov	QWORD PTR ModuleInfo+96, rax
	jne	SHORT $LN7@AssembleIn
	call	ErrnoStr
	mov	rdx, QWORD PTR ModuleInfo+128
	lea	ecx, QWORD PTR [rdi+106]
	mov	r8, rax
	call	Fatal
$LN7@AssembleIn:
	cmp	BYTE PTR Options+184, dil
	jne	SHORT $LN5@AssembleIn
	mov	rcx, QWORD PTR ModuleInfo+136
	lea	rdx, OFFSET FLAT:$SG6524
	call	fopen
	test	rax, rax
	mov	QWORD PTR ModuleInfo+104, rax
	jne	SHORT $LN5@AssembleIn
	call	ErrnoStr
	mov	rdx, QWORD PTR ModuleInfo+136
	mov	ecx, 106				; 0000006aH
	mov	r8, rax
	call	Fatal
$LN5@AssembleIn:
	cmp	BYTE PTR Options+129, dil
	je	SHORT $LN3@AssembleIn
	mov	rcx, QWORD PTR ModuleInfo+144
	lea	rdx, OFFSET FLAT:$SG6528
	call	fopen
	test	rax, rax
	mov	QWORD PTR ModuleInfo+112, rax
	jne	SHORT $LN3@AssembleIn
	call	ErrnoStr
	mov	rdx, QWORD PTR ModuleInfo+144
	mov	ecx, 106				; 0000006aH
	mov	r8, rax
	call	Fatal
$LN3@AssembleIn:

; 1486 : #if BUILD_TARGET
; 1487 :     get_os_include();
; 1488 : #endif
; 1489 :     ReswTableInit();

	call	ResWordsInit
	cmp	DWORD PTR Options+156, 1
	jne	SHORT $LN11@AssembleIn
	mov	ecx, 233				; 000000e9H
	call	DisableKeyword
	mov	ecx, 243				; 000000f3H
	call	DisableKeyword
$LN11@AssembleIn:
	cmp	BYTE PTR Options+136, 1
	jne	SHORT $LN10@AssembleIn
	mov	ecx, 449				; 000001c1H
	call	DisableKeyword
	mov	ecx, 270				; 0000010eH
	call	DisableKeyword
$LN10@AssembleIn:

; 1490 :     SymInit();

	call	SymInit

; 1491 :     InputInit();

	call	InputInit

; 1492 : 
; 1493 :     ModuleInit();

	movsxd	rcx, DWORD PTR Options+156
	mov	r11d, DWORD PTR Options+160
	mov	rax, rcx
	lea	rdx, OFFSET FLAT:formatoptions
	shl	rax, 4
	mov	DWORD PTR ModuleInfo+372, r11d
	add	rax, rdx
	cmp	ecx, 1
	mov	QWORD PTR ModuleInfo+344, rax
	jne	SHORT $LN16@AssembleIn
	cmp	BYTE PTR Options+120, dil
	jne	SHORT $LN16@AssembleIn
	mov	BYTE PTR ModuleInfo+423, cl
	jmp	SHORT $LN17@AssembleIn
$LN16@AssembleIn:
	mov	BYTE PTR ModuleInfo+423, dil
$LN17@AssembleIn:
	mov	eax, DWORD PTR ModuleInfo+408
	cmp	DWORD PTR Options+4, 1
	mov	DWORD PTR ModuleInfo, edi
	mov	DWORD PTR ModuleInfo+4, edi
	mov	DWORD PTR ModuleInfo+360, edi
	mov	DWORD PTR ModuleInfo+368, edi
	sete	dil
	shl	edi, 10
	xor	edi, eax
	and	edi, 1024				; 00000400H
	xor	eax, edi
	mov	DWORD PTR ModuleInfo+408, eax
	call	get_module_name
	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+96]
	lea	rcx, OFFSET FLAT:SymTables
	call	memset
	mov	rax, QWORD PTR ModuleInfo+344
	lea	rcx, OFFSET FLAT:ModuleInfo
	call	QWORD PTR [rax]

; 1494 :     CondInit();

	call	CondInit

; 1495 :     ExprEvalInit();

	call	ExprEvalInit

; 1496 :     LstInit();

	mov	rdi, QWORD PTR [rsp+72]

; 1497 : 
; 1498 :     DebugMsg(("AssembleInit() exit\n"));
; 1499 :     return;
; 1500 : }

	add	rsp, 40					; 00000028H
	jmp	LstInit
AssembleInit ENDP
_TEXT	ENDS
EXTRN	MemFini:NEAR
EXTRN	InputFini:NEAR
EXTRN	FreePubQueue:NEAR
EXTRN	ResWordsFini:NEAR
EXTRN	SymFini:NEAR
EXTRN	SegmentFini:NEAR
xdata	SEGMENT
$unwind$AssembleFini DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$AssembleFini DD @imagerel(AssembleFini#)
	DD	@imagerel(AssembleFini#+270)
	DD	@imagerel($unwind$AssembleFini#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
AssembleFini PROC NEAR

; 1510 : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 1511 :     int i;
; 1512 :     SegmentFini();

	call	SegmentFini

; 1513 :     SymFini();

	call	SymFini

; 1514 :     ResWordsFini();

	call	ResWordsFini

; 1515 : #ifdef DEBUG_OUT
; 1516 :     DumpInstrStats();
; 1517 :     MacroFini();
; 1518 : #endif
; 1519 :     FreePubQueue();

	call	FreePubQueue

; 1520 : #if FASTMEM==0
; 1521 :     FreeLibQueue();
; 1522 :     ContextFini();
; 1523 :     HllFini();
; 1524 : #endif
; 1525 :     InputFini();

	call	InputFini

; 1526 :     close_files();

	mov	rcx, QWORD PTR ModuleInfo+96
	xor	ebx, ebx
	test	rcx, rcx
	je	SHORT $LN14@AssembleFi
	call	fclose
	test	eax, eax
	je	SHORT $LN13@AssembleFi
	call	_errno
	mov	rdx, QWORD PTR ModuleInfo+128
	lea	ecx, QWORD PTR [rbx+107]
	mov	r8d, DWORD PTR [rax]
	call	EmitErr
$LN13@AssembleFi:
	mov	QWORD PTR ModuleInfo+96, rbx
$LN14@AssembleFi:
	mov	rcx, QWORD PTR ModuleInfo+104
	test	rcx, rcx
	je	SHORT $LN12@AssembleFi
	call	fclose
	test	eax, eax
	je	SHORT $LN11@AssembleFi
	call	_errno
	mov	rdx, QWORD PTR ModuleInfo+136
	mov	ecx, 107				; 0000006bH
	mov	r8d, DWORD PTR [rax]
	call	EmitErr
$LN11@AssembleFi:
	mov	QWORD PTR ModuleInfo+104, rbx
$LN12@AssembleFi:
	cmp	BYTE PTR Options+184, bl
	jne	SHORT $LN10@AssembleFi
	cmp	DWORD PTR ModuleInfo, ebx
	jbe	SHORT $LN10@AssembleFi
	mov	rcx, QWORD PTR ModuleInfo+136
	call	remove
$LN10@AssembleFi:
	mov	rcx, QWORD PTR ModuleInfo+112
	test	rcx, rcx
	je	SHORT $LN9@AssembleFi
	call	fclose
	mov	QWORD PTR ModuleInfo+112, rbx
$LN9@AssembleFi:
	mov	rcx, QWORD PTR ModuleInfo+120
	test	rcx, rcx
	je	SHORT $LN8@AssembleFi
	call	fclose
	mov	QWORD PTR ModuleInfo+120, rbx
	jmp	SHORT $LN6@AssembleFi
$LN8@AssembleFi:
	mov	rcx, QWORD PTR ModuleInfo+152
	test	rcx, rcx
	je	SHORT $LN6@AssembleFi
	call	remove
$LN6@AssembleFi:

; 1527 : 
; 1528 : #if FASTPASS
; 1529 : #if FASTMEM==0
; 1530 :     FreeLineStore();
; 1531 : #endif
; 1532 : #endif
; 1533 : 
; 1534 :     for ( i = 0; i < NUM_FILE_TYPES; i++ ) {
; 1535 :         LclFree( CurrFName[i] );
; 1536 :         /* v2.05: make sure the pointer for ERR is cleared */
; 1537 :         CurrFName[i] = NULL;

	mov	QWORD PTR ModuleInfo+128, rbx
	mov	QWORD PTR ModuleInfo+136, rbx
	mov	QWORD PTR ModuleInfo+144, rbx
	mov	QWORD PTR ModuleInfo+152, rbx

; 1538 :     }
; 1539 :     MemFini();
; 1540 :     return;
; 1541 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	MemFini
AssembleFini ENDP
_TEXT	ENDS
PUBLIC	AssembleModule
EXTRN	LstNL:NEAR
EXTRN	LstPrintf:NEAR
EXTRN	MsgGetEx:NEAR
EXTRN	GetLineNumber:NEAR
EXTRN	GetFName:NEAR
EXTRN	LstWriteCRef:NEAR
EXTRN	WriteSymbols:NEAR
EXTRN	omf_set_filepos:NEAR
EXTRN	rewind:NEAR
EXTRN	QueueDeleteLinnum:NEAR
EXTRN	ResetOrgFixup:NEAR
EXTRN	clock:NEAR
EXTRN	_setjmp:NEAR
xdata	SEGMENT
$unwind$AssembleModule DD 0d3301H
	DD	0ad433H
	DD	0bc420H
	DD	0c741cH
	DD	0116418H
	DD	0105414H
	DD	0f3410H
	DD	0c20cH
xdata	ENDS
pdata	SEGMENT
$pdata$AssembleModule DD @imagerel($LN60#)
	DD	@imagerel($LN60#+1010)
	DD	@imagerel($unwind$AssembleModule#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
prev_written$ = 64
source$ = 112
AssembleModule PROC NEAR

; 1547 : {

$LN60:
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, rsp
	sub	rsp, 104				; 00000068H
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rbp
	mov	QWORD PTR [rax+32], rsi
	mov	QWORD PTR [rax-8], rdi
	mov	QWORD PTR [rax-16], r12

; 1548 :     uint_32       prev_written = -1;
; 1549 :     uint_32       curr_written;
; 1550 :     int           starttime;
; 1551 :     int           endtime;
; 1552 :     struct dsym   *seg;
; 1553 : 
; 1554 :     DebugMsg(("AssembleModule(\"%s\") enter\n", source ));
; 1555 : 
; 1556 :     memset( &ModuleInfo, 0, sizeof(ModuleInfo) );

	lea	rcx, OFFSET FLAT:ModuleInfo
	xor	edx, edx
	mov	r8d, 776				; 00000308H
	mov	QWORD PTR [rax-24], r13
	mov	DWORD PTR [rax-40], -1			; ffffffffH
	call	memset

; 1557 : 
; 1558 : 	/* set architecture */
; 1559 : 	ModuleInfo.arch = MODULEARCH;

	mov	eax, DWORD PTR ModuleInfo+408
	mov	r11b, BYTE PTR MODULEARCH

; 1560 : 
; 1561 :     DebugCmd( ModuleInfo.cref = TRUE ); /* enable debug displays */
; 1562 : 
; 1563 : #if 1 //def __SW_BD
; 1564 :     /* fatal errors during assembly won't terminate the program,
; 1565 :      * just the assembly step.!
; 1566 :      */
; 1567 :     if ( setjmp( jmpenv ) ) {

	lea	rcx, OFFSET FLAT:jmpenv
	mov	rdx, rsp
	xor	r11d, eax
	and	r11d, 1
	xor	eax, r11d
	mov	DWORD PTR ModuleInfo+408, eax
	call	_setjmp
	xor	r12d, r12d
	test	eax, eax
	je	SHORT $LN25@AssembleMo

; 1568 :         if ( ModuleInfo.g.src_stack )

	cmp	QWORD PTR ModuleInfo+200, r12
	je	$done$6613

; 1569 :             ClearSrcStack(); /* avoid memory leaks! */

	call	ClearSrcStack

; 1570 :         goto done;

	jmp	$done$6613
$LN25@AssembleMo:

; 1571 :     }
; 1572 : #endif
; 1573 : 
; 1574 :     AssembleInit( source );

	mov	rcx, QWORD PTR source$[rsp]
	call	AssembleInit

; 1575 : 
; 1576 :     starttime = clock();

	call	clock

; 1577 : 
; 1578 : #if 0 /* 1=trigger a protection fault */
; 1579 :     seg = NULL;
; 1580 :     seg->sym.state = SYM_UNDEFINED;
; 1581 : #endif
; 1582 : 
; 1583 :     for( Parse_Pass = PASS_1; ; Parse_Pass++ ) {

	mov	DWORD PTR Parse_Pass, r12d
	mov	r13d, eax

; 1584 : 
; 1585 : 		ResetOrgFixup();

	call	ResetOrgFixup

; 1586 : 
; 1587 :         DebugMsg(( "*************\npass %u\n*************\n", Parse_Pass + 1 ));
; 1588 :         OnePass();

	call	OnePass

; 1589 : 
; 1590 :         if( ModuleInfo.g.error_count > 0 ) {

	cmp	DWORD PTR ModuleInfo, r12d
	ja	$LN49@AssembleMo
	mov	edi, DWORD PTR prev_written$[rsp]
	npad	3
$LL23@AssembleMo:

; 1591 :             DebugMsg(("AssembleModule(%u): errorcnt=%u\n", Parse_Pass + 1, ModuleInfo.g.error_count ));
; 1592 :             break;
; 1593 :         }
; 1594 : 
; 1595 :         /* calculate total size of segments */
; 1596 :         for ( curr_written = 0, seg = SymTables[TAB_SEG].head; seg ; seg = seg->next ) {

	mov	rbx, QWORD PTR SymTables+32
	mov	ecx, r12d
	test	rbx, rbx
	mov	rax, rbx
	je	SHORT $LN17@AssembleMo
$LL19@AssembleMo:

; 1597 :             /* v2.04: use <max_offset> instead of <bytes_written>
; 1598 :              * (the latter is not always reliable due to backpatching).
; 1599 :              */
; 1600 :             //curr_written += seg->e.seginfo->bytes_written;
; 1601 :             curr_written += seg->sym.max_offset;

	add	ecx, DWORD PTR [rax+64]
	mov	rax, QWORD PTR [rax+112]
	test	rax, rax
	jne	SHORT $LL19@AssembleMo
$LN17@AssembleMo:

; 1602 :             DebugMsg(("AssembleModule(%u): segm=%-8s start=%8" I32_SPEC "X max_ofs=%8" I32_SPEC "X written=%" I32_SPEC "X\n",
; 1603 :                       Parse_Pass + 1, seg->sym.name, seg->e.seginfo->start_loc, seg->sym.max_offset,
; 1604 :                       seg->e.seginfo->bytes_written ));
; 1605 :         }
; 1606 : 
; 1607 :         /* if there's no phase error and size of segments didn't change, we're done */
; 1608 :         DebugMsg(("AssembleModule(%u): PhaseError=%u, prev_written=%" I32_SPEC "X, curr_written=%" I32_SPEC "X\n", Parse_Pass + 1, ModuleInfo.PhaseError, prev_written, curr_written));
; 1609 :         if( !ModuleInfo.PhaseError && prev_written == curr_written )

	cmp	BYTE PTR ModuleInfo+422, r12b
	jne	SHORT $LN16@AssembleMo
	cmp	edi, ecx
	je	$LN49@AssembleMo
$LN16@AssembleMo:

; 1610 :             break;
; 1611 : 
; 1612 : #ifdef DEBUG_OUT
; 1613 :         if ( curr_written < prev_written && prev_written != -1 ) {
; 1614 :             printf( "size shrank from %" I32_SPEC "X to %" I32_SPEC "X in pass %u\n", prev_written, curr_written, Parse_Pass + 1 );
; 1615 :         }
; 1616 : #endif
; 1617 : 
; 1618 :         DebugMsg(("AssembleModule(%u): prepare for next pass\n", Parse_Pass + 1));
; 1619 :         prev_written = curr_written;
; 1620 : 
; 1621 :         if ( Parse_Pass % 200 == 199 )

	mov	r8d, DWORD PTR Parse_Pass
	mov	eax, 1374389535				; 51eb851fH
	mov	edi, ecx
	mov	DWORD PTR prev_written$[rsp], ecx
	mul	r8d
	shr	edx, 6
	mov	eax, r8d
	imul	edx, 200				; 000000c8H
	sub	eax, edx
	cmp	eax, 199				; 000000c7H
	jne	SHORT $LN15@AssembleMo

; 1622 :             EmitWarn( 2, ASSEMBLY_PASSES, Parse_Pass+1 );

	lea	edx, QWORD PTR [rax+41]
	inc	r8d
	mov	ecx, 2
	call	EmitWarn
	mov	rbx, QWORD PTR SymTables+32
$LN15@AssembleMo:

; 1623 : #ifdef DEBUG_OUT
; 1624 :         if ( Options.max_passes && Parse_Pass == (Options.max_passes - 1) )
; 1625 :             break;
; 1626 : #endif
; 1627 :         if ( Options.line_numbers ) {

	cmp	BYTE PTR Options+1, r12b
	je	SHORT $LN8@AssembleMo

; 1628 : #if COFF_SUPPORT
; 1629 :             if ( Options.output_format == OFORMAT_COFF ) {

	cmp	DWORD PTR Options+156, 2
	jne	SHORT $LN13@AssembleMo

; 1630 :                 for( seg = SymTables[TAB_SEG].head; seg; seg = seg->next ) {

	test	rbx, rbx
	je	SHORT $LN8@AssembleMo
	npad	9
$LL12@AssembleMo:

; 1631 :                     if ( seg->e.seginfo->LinnumQueue )

	mov	rax, QWORD PTR [rbx+104]
	mov	rcx, QWORD PTR [rax+56]
	test	rcx, rcx
	je	SHORT $LN9@AssembleMo

; 1632 :                         QueueDeleteLinnum( seg->e.seginfo->LinnumQueue );

	call	QueueDeleteLinnum
$LN9@AssembleMo:

; 1633 :                     seg->e.seginfo->LinnumQueue = NULL;

	mov	rax, QWORD PTR [rbx+104]
	mov	QWORD PTR [rax+56], r12
	mov	rbx, QWORD PTR [rbx+112]
	test	rbx, rbx
	jne	SHORT $LL12@AssembleMo

; 1634 :                 }
; 1635 :             } else {

	jmp	SHORT $LN8@AssembleMo
$LN13@AssembleMo:

; 1636 : #endif
; 1637 :                 QueueDeleteLinnum( &LinnumQueue );

	lea	rcx, OFFSET FLAT:LinnumQueue
	call	QueueDeleteLinnum

; 1638 :                 LinnumQueue.head = NULL;

	mov	QWORD PTR LinnumQueue, r12
$LN8@AssembleMo:

; 1639 : #if COFF_SUPPORT
; 1640 :             }
; 1641 : #endif
; 1642 :         }
; 1643 : 
; 1644 :         /* set file position of ASM and LST files for next pass */
; 1645 : 
; 1646 :         rewind( CurrFile[ASM] );

	mov	rcx, QWORD PTR ModuleInfo+96
	call	rewind

; 1647 :         if ( write_to_file && Options.output_format == OFORMAT_OMF )

	cmp	BYTE PTR write_to_file, r12b
	je	SHORT $LN7@AssembleMo
	cmp	DWORD PTR Options+156, 1
	jne	SHORT $LN7@AssembleMo

; 1648 :             omf_set_filepos();

	call	omf_set_filepos
$LN7@AssembleMo:

; 1649 : 
; 1650 : #if FASTPASS
; 1651 :         if ( UseSavedState == FALSE && CurrFile[LST] ) {

	cmp	BYTE PTR UseSavedState, r12b
	jne	SHORT $LN22@AssembleMo
	mov	rcx, QWORD PTR ModuleInfo+112
	test	rcx, rcx
	je	SHORT $LN22@AssembleMo

; 1652 : #else
; 1653 :         if ( CurrFile[LST] ) {
; 1654 : #endif
; 1655 :             rewind( CurrFile[LST] );

	call	rewind

; 1656 :             LstInit();

	call	LstInit
$LN22@AssembleMo:
	inc	DWORD PTR Parse_Pass
	call	ResetOrgFixup
	call	OnePass
	cmp	DWORD PTR ModuleInfo, r12d
	jbe	$LL23@AssembleMo
$LN49@AssembleMo:

; 1657 :         }
; 1658 :     } /* end for() */
; 1659 : 
; 1660 :     if ( ( Parse_Pass > PASS_1 ) && write_to_file )

	cmp	DWORD PTR Parse_Pass, r12d
	jbe	SHORT $LN5@AssembleMo
	cmp	BYTE PTR write_to_file, r12b
	je	SHORT $LN5@AssembleMo

; 1661 :         WriteModule( &ModuleInfo );

	lea	rcx, OFFSET FLAT:ModuleInfo
	call	WriteModule
$LN5@AssembleMo:

; 1662 : 
; 1663 : 	if (Options.dumpSymbols)

	cmp	BYTE PTR Options+130, r12b
	je	SHORT $LN4@AssembleMo

; 1664 : 		WriteSymbols();

	call	WriteSymbols
$LN4@AssembleMo:

; 1665 : 
; 1666 :     if ( ModuleInfo.pCodeBuff ) {
; 1667 :         LclFree( ModuleInfo.pCodeBuff );
; 1668 :     }
; 1669 :     DebugMsg(("AssembleModule: finished, cleanup\n"));
; 1670 : 
; 1671 :     /* Write a symbol listing file (if requested) */
; 1672 :     LstWriteCRef();

	call	LstWriteCRef

; 1673 : 
; 1674 :     endtime = clock(); /* is in ms already */

	call	clock

; 1675 : 
; 1676 :     sprintf( CurrSource, MsgGetEx( MSG_ASSEMBLY_RESULTS ),
; 1677 :              GetFName( ModuleInfo.srcfile )->fname,
; 1678 :              GetLineNumber(),
; 1679 :              Parse_Pass + 1,
; 1680 :              endtime - starttime,
; 1681 :              ModuleInfo.g.warning_count,
; 1682 :              ModuleInfo.g.error_count);

	mov	ecx, DWORD PTR ModuleInfo+428
	mov	esi, eax
	call	GetFName
	mov	edi, DWORD PTR Parse_Pass
	inc	edi
	mov	rbp, rax
	sub	esi, r13d
	call	GetLineNumber
	mov	ecx, 1
	mov	ebx, eax
	call	MsgGetEx
	mov	ecx, DWORD PTR ModuleInfo
	mov	r8, QWORD PTR [rbp]
	mov	DWORD PTR [rsp+56], ecx
	mov	ecx, DWORD PTR ModuleInfo+4
	mov	DWORD PTR [rsp+48], ecx
	mov	rcx, QWORD PTR ModuleInfo+464
	mov	rdx, rax
	mov	r9d, ebx
	mov	DWORD PTR [rsp+40], esi
	mov	DWORD PTR [rsp+32], edi
	call	sprintf

; 1683 :     if ( Options.quiet == FALSE )

	cmp	BYTE PTR Options, r12b
	jne	SHORT $LN2@AssembleMo

; 1684 :         printf( "%s\n", CurrSource );

	mov	rdx, QWORD PTR ModuleInfo+464
	lea	rcx, OFFSET FLAT:$SG6638
	call	printf
$LN2@AssembleMo:

; 1685 : 
; 1686 :     if ( CurrFile[LST] ) {

	cmp	QWORD PTR ModuleInfo+112, r12
	je	SHORT $done$6613

; 1687 :         LstPrintf( CurrSource );

	mov	rcx, QWORD PTR ModuleInfo+464
	call	LstPrintf

; 1688 :         LstNL();

	call	LstNL
$done$6613:

; 1689 :     }
; 1690 : #if 1 //def __SW_BD
; 1691 : done:
; 1692 : #endif
; 1693 :     AssembleFini();

	call	SegmentFini
	call	SymFini
	call	ResWordsFini
	call	FreePubQueue
	call	InputFini
	mov	rcx, QWORD PTR ModuleInfo+96
	test	rcx, rcx
	je	SHORT $LN41@AssembleMo
	call	fclose
	test	eax, eax
	je	SHORT $LN40@AssembleMo
	call	_errno
	mov	rdx, QWORD PTR ModuleInfo+128
	mov	ecx, 107				; 0000006bH
	mov	r8d, DWORD PTR [rax]
	call	EmitErr
$LN40@AssembleMo:
	mov	QWORD PTR ModuleInfo+96, r12
$LN41@AssembleMo:
	mov	rcx, QWORD PTR ModuleInfo+104
	test	rcx, rcx
	je	SHORT $LN39@AssembleMo
	call	fclose
	test	eax, eax
	je	SHORT $LN38@AssembleMo
	call	_errno
	mov	rdx, QWORD PTR ModuleInfo+136
	mov	ecx, 107				; 0000006bH
	mov	r8d, DWORD PTR [rax]
	call	EmitErr
$LN38@AssembleMo:
	mov	QWORD PTR ModuleInfo+104, r12
$LN39@AssembleMo:
	cmp	BYTE PTR Options+184, r12b
	jne	SHORT $LN37@AssembleMo
	cmp	DWORD PTR ModuleInfo, r12d
	jbe	SHORT $LN37@AssembleMo
	mov	rcx, QWORD PTR ModuleInfo+136
	call	remove
$LN37@AssembleMo:
	mov	rcx, QWORD PTR ModuleInfo+112
	test	rcx, rcx
	je	SHORT $LN36@AssembleMo
	call	fclose
	mov	QWORD PTR ModuleInfo+112, r12
$LN36@AssembleMo:
	mov	rcx, QWORD PTR ModuleInfo+120
	test	rcx, rcx
	je	SHORT $LN35@AssembleMo
	call	fclose
	mov	QWORD PTR ModuleInfo+120, r12
	jmp	SHORT $LN33@AssembleMo
$LN35@AssembleMo:
	mov	rcx, QWORD PTR ModuleInfo+152
	test	rcx, rcx
	je	SHORT $LN33@AssembleMo
	call	remove
$LN33@AssembleMo:
	mov	QWORD PTR ModuleInfo+128, r12
	mov	QWORD PTR ModuleInfo+136, r12
	mov	QWORD PTR ModuleInfo+144, r12
	mov	QWORD PTR ModuleInfo+152, r12
	call	MemFini

; 1694 : 	ResetOrgFixup();

	call	ResetOrgFixup

; 1695 :     DebugMsg(("AssembleModule exit\n"));
; 1696 :     return( ModuleInfo.g.error_count == 0 );

	cmp	DWORD PTR ModuleInfo, r12d

; 1697 : }

	mov	rbx, QWORD PTR [rsp+120]
	mov	rbp, QWORD PTR [rsp+128]
	mov	rsi, QWORD PTR [rsp+136]
	mov	rdi, QWORD PTR [rsp+96]
	mov	r13, QWORD PTR [rsp+80]
	sete	r12b
	mov	eax, r12d
	mov	r12, QWORD PTR [rsp+88]
	add	rsp, 104				; 00000068H
	ret	0
AssembleModule ENDP
_TEXT	ENDS
END
