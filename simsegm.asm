; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG5618	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
$SG5558	DB	'_TEXT', 00H
	ORG $+2
$SG5559	DB	'STACK', 00H
	ORG $+2
$SG5560	DB	'_DATA', 00H
	ORG $+2
$SG5561	DB	'_BSS', 00H
	ORG $+3
$SG5562	DB	'FAR_DATA', 00H
	ORG $+7
$SG5563	DB	'FAR_BSS', 00H
$SG5564	DB	'CONST', 00H
_DATA	ENDS
CONST	SEGMENT
SegmNamesDef DQ	FLAT:$SG5558
	DQ	FLAT:$SG5559
	DQ	FLAT:$SG5560
	DQ	FLAT:$SG5561
	DQ	FLAT:$SG5562
	DQ	FLAT:$SG5563
	DQ	FLAT:$SG5564
CONST	ENDS
_DATA	SEGMENT
	ORG $+2
$SG5566	DB	'CODE', 00H
	ORG $+3
$SG5567	DB	'STACK', 00H
	ORG $+2
$SG5568	DB	'DATA', 00H
	ORG $+3
$SG5569	DB	'BSS', 00H
	ORG $+4
$SG5570	DB	'FAR_DATA', 00H
	ORG $+7
$SG5571	DB	'FAR_BSS', 00H
$SG5572	DB	'CONST', 00H
_DATA	ENDS
CONST	SEGMENT
SegmClass DQ	FLAT:$SG5566
	DQ	FLAT:$SG5567
	DQ	FLAT:$SG5568
	DQ	FLAT:$SG5569
	DQ	FLAT:$SG5570
	DQ	FLAT:$SG5571
	DQ	FLAT:$SG5572
CONST	ENDS
_DATA	SEGMENT
	ORG $+2
$SG5574	DB	'PUBLIC', 00H
	ORG $+1
$SG5575	DB	'STACK', 00H
	ORG $+2
$SG5576	DB	'PUBLIC', 00H
	ORG $+1
$SG5577	DB	'PUBLIC', 00H
	ORG $+1
$SG5578	DB	'PRIVATE', 00H
$SG5579	DB	'PRIVATE', 00H
$SG5580	DB	'PUBLIC', 00H
_DATA	ENDS
CONST	SEGMENT
SegmCombine DQ	FLAT:$SG5574
	DQ	FLAT:$SG5575
	DQ	FLAT:$SG5576
	DQ	FLAT:$SG5577
	DQ	FLAT:$SG5578
	DQ	FLAT:$SG5579
	DQ	FLAT:$SG5580
CONST	ENDS
_DATA	SEGMENT
	ORG $+1
$SG5587	DB	'_flat', 00H
	ORG $+2
$SG5601	DB	'%s %r %s', 00H
	ORG $+3
$SG5606	DB	'%s %r', 00H
	ORG $+2
$SG5614	DB	'WORD', 00H
	ORG $+3
$SG5616	DB	'PARA', 00H
	ORG $+3
$SG5624	DB	'FLAT', 00H
	ORG $+3
$SG5626	DB	'USE32', 00H
	ORG $+2
$SG5628	DB	'DWORD', 00H
	ORG $+2
$SG5630	DB	'PARA', 00H
	ORG $+7
$SG5635	DB	'%s %r %s %s %s ''%s''', 00H
$SG5640	DB	'_flat', 00H
	ORG $+2
$SG5642	DB	'%s %r', 00H
	ORG $+2
$SG5647	DB	'%s %r', 00H
	ORG $+2
$SG5650	DB	'%s %r', 00H
	ORG $+2
$SG5652	DB	'USE64', 00H
	ORG $+6
$SG5653	DB	'%s %r %s %s %s ''%s''', 00H
$SG5654	DB	'CODE', 00H
	ORG $+3
$SG5655	DB	'PUBLIC', 00H
	ORG $+1
$SG5656	DB	'USE16', 00H
	ORG $+2
$SG5657	DB	'BYTE', 00H
	ORG $+3
$SG5658	DB	'_flat', 00H
	ORG $+14
$SG5659	DB	'assume cs:_flat, ds:_flat, es:_flat, ss:_flat, fs:_flat,'
	DB	' gs:_flat', 00H
	ORG $+6
$SG5662	DB	'@CodeSize', 00H
	ORG $+6
$SG5663	DB	'@DataSize', 00H
	ORG $+6
$SG5664	DB	'@ReservedStack', 00H
	ORG $+1
$SG5672	DB	'%s %r', 00H
	ORG $+2
$SG5708	DB	'FLAT', 00H
	ORG $+3
$SG5712	DB	'%r %r:%s', 00H
	ORG $+7
$SG5715	DB	'ORG 0%xh', 00H
	ORG $+7
$SG5720	DB	'%r %r:ERROR', 00H
	ORG $+4
$SG5724	DB	'%r %r:ERROR', 00H
	ORG $+4
$SG5741	DB	'%s %r %s', 00H
	ORG $+3
$SG5743	DB	', %s', 00H
_DATA	ENDS
PUBLIC	SimGetSegName
EXTRN	ModuleInfo:BYTE
_BSS	SEGMENT
	ALIGN	8

SegmNames DQ	07H DUP (?)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\simsegm.c
_BSS	ENDS
_TEXT	SEGMENT
segno$ = 8
SimGetSegName PROC NEAR

; 47   : 	char* segn;
; 48   : 	segn = SegmNames[segno];

	movsxd	rax, ecx
	lea	rcx, OFFSET FLAT:SegmNames
	mov	rcx, QWORD PTR [rcx+rax*8]

; 49   : 	if (segn == NULL && ModuleInfo.flat == TRUE)

	test	rcx, rcx
	jne	SHORT $LN4@SimGetSegN
	cmp	BYTE PTR ModuleInfo+772, 1
	lea	rax, OFFSET FLAT:$SG5587
	cmovne	rax, rcx

; 52   : }

	ret	0
$LN4@SimGetSegN:

; 50   : 		segn = "_flat";
; 51   :     return( segn );

	mov	rax, rcx

; 52   : }

	ret	0
SimGetSegName ENDP
_TEXT	ENDS
PUBLIC	GetCodeClass
EXTRN	Options:BYTE
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
GetCodeClass PROC NEAR

; 57   :     /* option -nc set? */
; 58   :     if ( Options.names[OPTN_CODE_CLASS] )

	mov	rax, QWORD PTR Options+88
	test	rax, rax

; 59   :         return( Options.names[OPTN_CODE_CLASS] );

	jne	SHORT $LN2@GetCodeCla

; 60   : 
; 61   :     return( SegmClass[SIM_CODE] );

	lea	rax, OFFSET FLAT:$SG5566
$LN2@GetCodeCla:

; 62   : }

	ret	0
GetCodeClass ENDP
_TEXT	ENDS
EXTRN	AddLineQueueX:NEAR
EXTRN	szDgroup:BYTE
xdata	SEGMENT
$unwind$AddToDgroup DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$AddToDgroup DD @imagerel(AddToDgroup#)
	DD	@imagerel(AddToDgroup#+81)
	DD	@imagerel($unwind$AddToDgroup#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
segm$ = 48
name$ = 56
AddToDgroup PROC NEAR

; 68   : {

	sub	rsp, 40					; 00000028H

; 69   :     /* no DGROUP for FLAT or COFF/ELF */
; 70   :     if( ModuleInfo.model == MODEL_FLAT
; 71   : #if COFF_SUPPORT
; 72   :        || Options.output_format == OFORMAT_COFF
; 73   : #endif
; 74   : #if ELF_SUPPORT
; 75   :        || Options.output_format == OFORMAT_ELF
; 76   : #endif
; 77   :       )

	cmp	DWORD PTR ModuleInfo+360, 7
	je	SHORT $LN2@AddToDgrou
	mov	eax, DWORD PTR Options+156
	cmp	eax, 2
	je	SHORT $LN2@AddToDgrou
	cmp	eax, 3
	je	SHORT $LN2@AddToDgrou

; 78   :         return;
; 79   : 
; 80   :     if( name == NULL )

	test	rdx, rdx
	jne	SHORT $LN1@AddToDgrou

; 81   :         name = SegmNames[segm];

	lea	rdx, OFFSET FLAT:SegmNames
	movsxd	rax, ecx
	mov	rdx, QWORD PTR [rdx+rax*8]
$LN1@AddToDgrou:

; 82   : 
; 83   :     AddLineQueueX( "%s %r %s", szDgroup, T_GROUP, name );

	mov	r9, rdx
	lea	rcx, OFFSET FLAT:$SG5601
	lea	rdx, OFFSET FLAT:szDgroup
	mov	r8d, 443				; 000001bbH
	call	AddLineQueueX
$LN2@AddToDgrou:

; 84   : }

	add	rsp, 40					; 00000028H
	ret	0
AddToDgroup ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$close_currseg DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$close_currseg DD @imagerel(close_currseg#)
	DD	@imagerel(close_currseg#+43)
	DD	@imagerel($unwind$close_currseg#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
close_currseg PROC NEAR

; 90   : {

	sub	rsp, 40					; 00000028H

; 91   :     if ( CurrSeg ) {

	mov	rdx, QWORD PTR ModuleInfo+432
	test	rdx, rdx
	je	SHORT $LN1@close_curr

; 92   :         DebugMsg1(("close_currseg: current seg=%s\n", CurrSeg->sym.name));
; 93   :         AddLineQueueX( "%s %r", CurrSeg->sym.name, T_ENDS );

	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, OFFSET FLAT:$SG5606
	mov	r8d, 442				; 000001baH
	call	AddLineQueueX
$LN1@close_curr:

; 94   :     }
; 95   : }

	add	rsp, 40					; 00000028H
	ret	0
close_currseg ENDP
_TEXT	ENDS
EXTRN	StoreLine:NEAR
EXTRN	sym_ReservedStack:QWORD
EXTRN	CreateVariable:NEAR
EXTRN	SymFind:NEAR
EXTRN	Parse_Pass:DWORD
EXTRN	__ImageBase:BYTE
_BSS	SEGMENT
sym_DataSize DQ	01H DUP (?)
sym_CodeSize DQ	01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$SetSimSeg DD 0dc301H
	DD	01064c3H
	DD	0bd47eH
	DD	0ae421H
	DD	011741aH
	DD	0f5416H
	DD	0e3412H
	DD	0c207H
xdata	ENDS
pdata	SEGMENT
$pdata$SetSimSeg DD @imagerel(SetSimSeg#)
	DD	@imagerel(SetSimSeg#+195)
	DD	@imagerel($unwind$SetSimSeg#)
pdata	ENDS
xdata	SEGMENT
$chain$7$SetSimSeg DD 040a21H
	DD	09f40aH
	DD	0cc405H
	DD	@imagerel(SetSimSeg#)
	DD	@imagerel(SetSimSeg#+195)
	DD	@imagerel($unwind$SetSimSeg#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$SetSimSeg DD @imagerel(SetSimSeg#+195)
	DD	@imagerel(SetSimSeg#+470)
	DD	@imagerel($chain$7$SetSimSeg#)
pdata	ENDS
xdata	SEGMENT
$chain$8$SetSimSeg DD 021H
	DD	@imagerel(SetSimSeg#)
	DD	@imagerel(SetSimSeg#+195)
	DD	@imagerel($unwind$SetSimSeg#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$SetSimSeg DD @imagerel(SetSimSeg#+470)
	DD	@imagerel(SetSimSeg#+759)
	DD	@imagerel($chain$8$SetSimSeg#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
segm$ = 112
name$ = 120
SetSimSeg PROC NEAR

; 103  : {

	mov	rax, rsp
	sub	rsp, 104				; 00000068H

; 104  :     char *pAlign = "WORD";
; 105  :     char *pAlignSt = "PARA";
; 106  :     char *pUse = "";
; 107  :     struct asym *sym;
; 108  :     const char *pFmt;
; 109  :     const char *pClass;
; 110  : 
; 111  :     if ( ModuleInfo.defOfssize > USE16 ) {

	cmp	BYTE PTR ModuleInfo+405, 0
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+32], rdi
	movsxd	rbx, ecx
	mov	QWORD PTR [rax-24], r14
	lea	r14, OFFSET FLAT:$SG5618
	mov	rbp, rdx
	lea	rdi, OFFSET FLAT:$SG5614
	lea	rcx, OFFSET FLAT:$SG5616
	jbe	SHORT $LN23@SetSimSeg

; 112  :         if ( ModuleInfo.model == MODEL_FLAT )

	cmp	DWORD PTR ModuleInfo+360, 7
	lea	rax, OFFSET FLAT:$SG5626

; 113  :             pUse = "FLAT";
; 114  :         else
; 115  :             pUse = "USE32";
; 116  :         if (( ModuleInfo.curr_cpu & P_CPU_MASK ) <= P_386 )

	lea	rcx, OFFSET FLAT:$SG5630
	lea	r14, OFFSET FLAT:$SG5624
	lea	rdi, OFFSET FLAT:$SG5628
	cmovne	r14, rax
	mov	eax, DWORD PTR ModuleInfo+392
	and	eax, 240				; 000000f0H
	cmp	eax, 48					; 00000030H
	cmovg	rdi, rcx

; 117  :             pAlign = "DWORD";
; 118  :         else
; 119  :             pAlign = "PARA";
; 120  :         pAlignSt = pAlign;

	mov	rcx, rdi
$LN23@SetSimSeg:

; 121  :     }
; 122  : 
; 123  :     if ( segm == SIM_CODE )

	test	ebx, ebx
	mov	QWORD PTR [rsp+88], r13
	lea	rdx, OFFSET FLAT:__ImageBase
	jne	SHORT $LN18@SetSimSeg

; 124  :         pClass = GetCodeClass();

	mov	rax, QWORD PTR Options+88
	lea	r13, OFFSET FLAT:$SG5566
	test	rax, rax
	cmovne	r13, rax

; 125  :     else

	jmp	SHORT $LN16@SetSimSeg
$LN18@SetSimSeg:

; 126  :         pClass = SegmClass[segm];
; 127  : 
; 128  :     if ( segm == SIM_STACK || segm == SIM_FARDATA || segm == SIM_FARDATA_UN )

	cmp	ebx, 1
	mov	r13, QWORD PTR SegmClass[rdx+rbx*8]
	je	SHORT $LN15@SetSimSeg
	cmp	ebx, 4
	je	SHORT $LN15@SetSimSeg
	cmp	ebx, 5
	jne	SHORT $LN16@SetSimSeg
$LN15@SetSimSeg:

; 129  :         pAlign = pAlignSt;

	mov	rdi, rcx
$LN16@SetSimSeg:

; 130  : 
; 131  :     pFmt = "%s %r %s %s %s '%s'";
; 132  :     if ( name == NULL ) {

	test	rbp, rbp
	mov	QWORD PTR [rsp+128], rsi
	mov	QWORD PTR [rsp+96], r12
	mov	QWORD PTR [rsp+72], r15
	lea	rsi, OFFSET FLAT:$SG5635
	jne	$LN14@SetSimSeg

; 133  :         name = SegmNames[segm];

	mov	rcx, QWORD PTR SegmNames[rdx+rbx*8]

; 134  : 		if (name == NULL) name = "_flat";

	lea	rbp, OFFSET FLAT:$SG5640

; 135  :         if ( ModuleInfo.simseg_init & ( 1 << segm ) )

	mov	r12d, 1
	test	rcx, rcx
	mov	rax, rbx
	movzx	eax, BYTE PTR ModuleInfo+420
	cmovne	rbp, rcx
	mov	ecx, ebx
	mov	r15d, r12d
	shl	r15d, cl
	test	al, r15b
	je	SHORT $LN12@SetSimSeg

; 136  :             pFmt = "%s %r";

	lea	rsi, OFFSET FLAT:$SG5642

; 137  :         else {

	jmp	$LN6@SetSimSeg
$LN12@SetSimSeg:

; 138  :             ModuleInfo.simseg_init |= ( 1 << segm );

	shl	r12b, cl
	or	al, r12b

; 139  :             /* v2.05: if segment exists already, use the current attribs.
; 140  :              * This allows a better mix of full and simplified segment
; 141  :              * directives. Masm behaves differently: the attributes
; 142  :              * of the simplified segment directives have highest priority.
; 143  :              */
; 144  :             if ( Parse_Pass == PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	BYTE PTR ModuleInfo+420, al
	jne	SHORT $LN31@SetSimSeg

; 145  :                 sym = SymSearch( name );

	mov	rcx, rbp
	call	SymFind

; 146  :                 /* v2.12: check 'isdefined' member instead of 'lname_idx' */
; 147  :                 //if ( sym && sym->state == SYM_SEG && ((struct dsym *)sym)->e.seginfo->lname_idx != 0 )
; 148  :                 if ( sym && sym->state == SYM_SEG && sym->isdefined == TRUE )

	test	rax, rax
	je	SHORT $LN31@SetSimSeg
	cmp	DWORD PTR [rax+40], 3
	jne	SHORT $LN31@SetSimSeg
	test	BYTE PTR [rax+48], 2
	je	SHORT $LN31@SetSimSeg

; 149  :                     ModuleInfo.simseg_defd |= ( 1 << segm );

	movzx	eax, BYTE PTR ModuleInfo+421
	or	al, r12b
	mov	BYTE PTR ModuleInfo+421, al
	jmp	SHORT $LN9@SetSimSeg
$LN31@SetSimSeg:
	mov	al, BYTE PTR ModuleInfo+421
$LN9@SetSimSeg:

; 150  :             }
; 151  :             if ( ModuleInfo.simseg_defd & ( 1 << segm ) )

	test	al, r15b
	je	SHORT $LN32@SetSimSeg

; 152  :                 pFmt = "%s %r";

	lea	rsi, OFFSET FLAT:$SG5647

; 153  :         }
; 154  :     } else {

	lea	rdx, OFFSET FLAT:__ImageBase
	jmp	SHORT $LN6@SetSimSeg
$LN14@SetSimSeg:

; 155  :         sym = SymSearch( name );

	mov	rcx, rbp
	call	SymFind

; 156  :         /* v2.04: testing for state SYM_SEG isn't enough. The segment
; 157  :          * might have been "defined" by a GROUP directive. Additional
; 158  :          * check for segment's lname index is needed.
; 159  :          * v2.12: check 'isdefined' member instead of 'lname_idx'
; 160  :          */
; 161  :         //if ( sym && sym->state == SYM_SEG )
; 162  :         //if ( sym && sym->state == SYM_SEG && ((struct dsym *)sym)->e.seginfo->lname_idx != 0 )
; 163  :         if ( sym && sym->state == SYM_SEG && sym->isdefined == TRUE )

	test	rax, rax
	je	SHORT $LN34@SetSimSeg
	cmp	DWORD PTR [rax+40], 3
	jne	SHORT $LN33@SetSimSeg
	movzx	eax, BYTE PTR [rax+48]
	lea	rcx, OFFSET FLAT:$SG5650
	lea	rdx, OFFSET FLAT:__ImageBase
	and	al, 2
	cmp	al, 2
	cmovne	rcx, rsi
	mov	rsi, rcx
	jmp	SHORT $LN6@SetSimSeg
$LN32@SetSimSeg:

; 135  :         if ( ModuleInfo.simseg_init & ( 1 << segm ) )

	lea	rdx, OFFSET FLAT:__ImageBase
	jmp	SHORT $LN6@SetSimSeg
$LN33@SetSimSeg:
	lea	rdx, OFFSET FLAT:__ImageBase
	jmp	SHORT $LN6@SetSimSeg
$LN34@SetSimSeg:
	lea	rdx, OFFSET FLAT:__ImageBase
$LN6@SetSimSeg:

; 164  :             pFmt = "%s %r";
; 165  :     }
; 166  : 
; 167  : 	if (ModuleInfo.flat)

	cmp	BYTE PTR ModuleInfo+772, 0
	mov	r15, QWORD PTR [rsp+72]
	mov	r12, QWORD PTR [rsp+96]
	je	$LN5@SetSimSeg

; 168  : 	{
; 169  : 		pUse = "USE64";
; 170  : 		pFmt = "%s %r %s %s %s '%s'";
; 171  : 		AddLineQueueX(pFmt, "_flat", T_SEGMENT, "BYTE", "USE16", "PUBLIC", "CODE");

	lea	rax, OFFSET FLAT:$SG5654
	lea	r9, OFFSET FLAT:$SG5657
	lea	rdx, OFFSET FLAT:$SG5658
	mov	QWORD PTR [rsp+48], rax
	lea	rax, OFFSET FLAT:$SG5655
	lea	rcx, OFFSET FLAT:$SG5653
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:$SG5656
	mov	r8d, 441				; 000001b9H
	mov	QWORD PTR [rsp+32], rax
	call	AddLineQueueX

; 172  : 		AddLineQueueX("assume cs:_flat, ds:_flat, es:_flat, ss:_flat, fs:_flat, gs:_flat");

	lea	rcx, OFFSET FLAT:$SG5659
	call	AddLineQueueX

; 173  : 		if (Parse_Pass == PASS_1)

	cmp	DWORD PTR Parse_Pass, 0
	jne	$LN1@SetSimSeg

; 174  : 		{
; 175  : 			sym_CodeSize = CreateVariable("@CodeSize", 0);

	lea	rcx, OFFSET FLAT:$SG5662
	xor	edx, edx
	call	CreateVariable

; 176  : 			sym_CodeSize->predefined = TRUE;
; 177  : 			sym_DataSize = CreateVariable("@DataSize", 0);

	xor	edx, edx
	movsxd	rcx, eax
	mov	QWORD PTR sym_CodeSize, rcx
	or	BYTE PTR [rcx+48], 32			; 00000020H
	lea	rcx, OFFSET FLAT:$SG5663
	call	CreateVariable

; 178  : 			sym_DataSize->predefined = TRUE;
; 179  : 			sym_ReservedStack = CreateVariable("@ReservedStack", 0);

	xor	edx, edx
	movsxd	rcx, eax
	mov	QWORD PTR sym_DataSize, rcx
	or	BYTE PTR [rcx+48], 32			; 00000020H
	lea	rcx, OFFSET FLAT:$SG5664
	call	CreateVariable
	movsxd	rcx, eax
	mov	QWORD PTR sym_ReservedStack, rcx

; 180  : 			sym_ReservedStack->predefined = TRUE;

	or	BYTE PTR [rcx+48], 32			; 00000020H

; 181  : 		}
; 182  : 		FStoreLine(0);

	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN1@SetSimSeg
	mov	rcx, QWORD PTR ModuleInfo+464
	xor	r8d, r8d
	xor	edx, edx
	call	StoreLine

; 183  : 	}
; 184  : 	else

	jmp	SHORT $LN1@SetSimSeg
$LN5@SetSimSeg:

; 185  : 	{
; 186  : 		AddLineQueueX(pFmt, name, T_SEGMENT, pAlign, pUse, SegmCombine[segm], pClass);

	mov	rax, QWORD PTR SegmCombine[rdx+rbx*8]
	mov	QWORD PTR [rsp+48], r13
	mov	r9, rdi
	mov	QWORD PTR [rsp+40], rax
	mov	r8d, 441				; 000001b9H
	mov	rdx, rbp
	mov	rcx, rsi
	mov	QWORD PTR [rsp+32], r14
	call	AddLineQueueX
$LN1@SetSimSeg:
	mov	r14, QWORD PTR [rsp+80]
	mov	r13, QWORD PTR [rsp+88]
	mov	rdi, QWORD PTR [rsp+136]
	mov	rsi, QWORD PTR [rsp+128]
	mov	rbp, QWORD PTR [rsp+120]
	mov	rbx, QWORD PTR [rsp+112]

; 187  : 	}
; 188  : 	
; 189  :     return;
; 190  : }

	add	rsp, 104				; 00000068H
	ret	0
SetSimSeg ENDP
; Function compile flags: /Ogtpy
segm$ = 8
EndSimSeg PROC NEAR

; 195  :     AddLineQueueX( "%s %r", SegmNames[segm], T_ENDS );

	movsxd	rdx, ecx
	lea	rax, OFFSET FLAT:SegmNames
	lea	rcx, OFFSET FLAT:$SG5672
	mov	rdx, QWORD PTR [rax+rdx*8]
	mov	r8d, 442				; 000001baH

; 196  :     return;
; 197  : }

	jmp	AddLineQueueX
EndSimSeg ENDP
_TEXT	ENDS
PUBLIC	SimplifiedSegDir
EXTRN	RunLineQueue:NEAR
EXTRN	EmitErr:NEAR
EXTRN	EvalOperand:NEAR
EXTRN	SpecialTable:BYTE
EXTRN	EmitError:NEAR
EXTRN	LstWrite:NEAR
xdata	SEGMENT
$unwind$SimplifiedSegDir DD 061601H
	DD	0186416H
	DD	01c3412H
	DD	019010eH
xdata	ENDS
pdata	SEGMENT
$pdata$SimplifiedSegDir DD @imagerel($LN50#)
	DD	@imagerel($LN50#+72)
	DD	@imagerel($unwind$SimplifiedSegDir#)
pdata	ENDS
xdata	SEGMENT
$chain$3$SimplifiedSegDir DD 041c21H
	DD	017741cH
	DD	01d5408H
	DD	@imagerel($LN50#)
	DD	@imagerel($LN50#+72)
	DD	@imagerel($unwind$SimplifiedSegDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$SimplifiedSegDir DD @imagerel($LN50#+72)
	DD	@imagerel($LN50#+770)
	DD	@imagerel($chain$3$SimplifiedSegDir#)
pdata	ENDS
xdata	SEGMENT
$chain$4$SimplifiedSegDir DD 021H
	DD	@imagerel($LN50#)
	DD	@imagerel($LN50#+72)
	DD	@imagerel($unwind$SimplifiedSegDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$SimplifiedSegDir DD @imagerel($LN50#+770)
	DD	@imagerel($LN50#+796)
	DD	@imagerel($chain$4$SimplifiedSegDir#)
pdata	ENDS
xdata	SEGMENT
$chain$5$SimplifiedSegDir DD 040021H
	DD	0177400H
	DD	01d5400H
	DD	@imagerel($LN50#)
	DD	@imagerel($LN50#+72)
	DD	@imagerel($unwind$SimplifiedSegDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$SimplifiedSegDir DD @imagerel($LN50#+796)
	DD	@imagerel($LN50#+824)
	DD	@imagerel($chain$5$SimplifiedSegDir#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
init$ = 48
opndx$ = 64
i$ = 208
tokenarray$ = 216
SimplifiedSegDir PROC NEAR

; 205  : {

$LN50:
	mov	DWORD PTR [rsp+8], ecx
	mov	rax, rsp
	sub	rsp, 200				; 000000c8H
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax-8], rsi
	mov	rsi, rdx

; 206  :     const char  *name = NULL;

	xor	ebx, ebx

; 207  :     char        init;
; 208  :     int         type;
; 209  :     struct expr opndx;
; 210  : 
; 211  :     DebugMsg1(("SimplifiedSegDir(%s) enter\n", tokenarray[i].string_ptr ));
; 212  : 
; 213  :     LstWrite( LSTTYPE_DIRECTIVE, 0, NULL );

	xor	r8d, r8d
	xor	edx, edx
	lea	ecx, QWORD PTR [rbx+4]
	call	LstWrite

; 214  : 
; 215  :     if( ModuleInfo.model == MODEL_NONE ) {

	cmp	DWORD PTR ModuleInfo+360, ebx
	jne	SHORT $LN30@Simplified

; 216  :         EmitError( MODEL_IS_NOT_DECLARED );

	lea	ecx, QWORD PTR [rbx+96]
	call	EmitError

; 217  :         return( ERROR );

	lea	eax, QWORD PTR [rbx-1]
	jmp	$LN31@Simplified
$LN30@Simplified:

; 218  :     }
; 219  : 
; 220  :     //type = tokenarray[i].value;
; 221  :     type = GetSflagsSp( tokenarray[i].tokval );

	movsxd	rdx, DWORD PTR i$[rsp]
	mov	QWORD PTR [rsp+232], rbp
	lea	rbp, OFFSET FLAT:__ImageBase
	mov	rax, rdx

; 222  :     i++; /* get past the directive token */

	inc	edx
	mov	QWORD PTR [rsp+184], rdi
	shl	rax, 5
	mov	eax, DWORD PTR [rax+rsi+16]
	mov	DWORD PTR i$[rsp], edx
	lea	rcx, QWORD PTR [rax+rax*2]
	movsxd	rdi, DWORD PTR SpecialTable[rbp+rcx*4+4]

; 223  : 
; 224  :     if( type == SIM_STACK ) {

	cmp	edi, 1
	jne	SHORT $LN29@Simplified

; 225  :         if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rsi
	mov	BYTE PTR [rsp+32], bl
	call	EvalOperand
	cmp	eax, -1

; 226  :             return( ERROR );

	je	SHORT $LN49@Simplified

; 227  :         if( opndx.kind == EXPR_EMPTY )

	mov	eax, DWORD PTR opndx$[rsp+60]
	cmp	eax, -2
	jne	SHORT $LN27@Simplified

; 228  :             opndx.value = DEFAULT_STACK_SIZE;

	mov	edx, DWORD PTR i$[rsp]
	mov	DWORD PTR opndx$[rsp], 1024		; 00000400H
	jmp	SHORT $LN23@Simplified
$LN27@Simplified:

; 229  :         else if( opndx.kind != EXPR_CONST ) {

	test	eax, eax
	je	SHORT $LN45@Simplified

; 230  :             EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError
$LN49@Simplified:

; 231  :             return( ERROR );

	mov	eax, -1
	jmp	$LN48@Simplified
$LN29@Simplified:

; 232  :         }
; 233  :     } else {
; 234  :         /* Masm accepts a name argument for .CODE and .FARDATA[?] only.
; 235  :          * HJWasm also accepts this for .DATA[?] and .CONST unless
; 236  :          * option -Zne is set.
; 237  :          */
; 238  :         if( tokenarray[i].token == T_ID &&
; 239  :            ( type == SIM_CODE || type == SIM_FARDATA || type == SIM_FARDATA_UN
; 240  :             || ( Options.strict_masm_compat == FALSE &&
; 241  :                 ( type == SIM_DATA || type == SIM_DATA_UN || type == SIM_CONST )))) {

	movsxd	rax, edx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 8
	jne	SHORT $LN23@Simplified
	test	edi, edi
	je	SHORT $LN21@Simplified
	cmp	edi, 4
	je	SHORT $LN21@Simplified
	cmp	edi, 5
	je	SHORT $LN21@Simplified
	cmp	BYTE PTR Options+136, bl
	jne	SHORT $LN23@Simplified
	cmp	edi, 2
	je	SHORT $LN21@Simplified
	cmp	edi, 3
	je	SHORT $LN21@Simplified
	cmp	edi, 6
	jne	SHORT $LN23@Simplified
$LN21@Simplified:

; 242  :             name = tokenarray[i].string_ptr;

	mov	rbx, QWORD PTR [rax+rsi+8]

; 243  :             i++;

	inc	edx
	mov	DWORD PTR i$[rsp], edx
	jmp	SHORT $LN23@Simplified
$LN45@Simplified:

; 228  :             opndx.value = DEFAULT_STACK_SIZE;

	mov	edx, DWORD PTR i$[rsp]
$LN23@Simplified:

; 244  :         }
; 245  :     }
; 246  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, edx
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rsi], 0
	je	SHORT $LN20@Simplified

; 247  :         EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	mov	rdx, QWORD PTR [rdx+rsi+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 248  :         return( ERROR );

	mov	eax, -1
	jmp	$LN48@Simplified
$LN20@Simplified:

; 249  :     }
; 250  : 
; 251  :     if( type != SIM_STACK )

	cmp	edi, 1
	je	SHORT $LN33@Simplified

; 252  :         close_currseg();  /* emit a "xxx ENDS" line to close current seg */

	mov	rdx, QWORD PTR ModuleInfo+432
	test	rdx, rdx
	je	SHORT $LN33@Simplified
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, OFFSET FLAT:$SG5606
	mov	r8d, 442				; 000001baH
	call	AddLineQueueX
$LN33@Simplified:

; 253  : 
; 254  :     if ( name == NULL )

	test	rbx, rbx
	jne	SHORT $LN46@Simplified

; 255  :         init = ( ModuleInfo.simseg_init & ( 1 << type ) );

	mov	ecx, edi
	mov	esi, 1
	shl	sil, cl
	and	sil, BYTE PTR ModuleInfo+420
	jmp	SHORT $LN18@Simplified
$LN46@Simplified:
	mov	sil, BYTE PTR init$[rsp]
$LN18@Simplified:

; 256  : 
; 257  :     switch( type ) {

	cmp	edi, 6
	ja	$LN1@Simplified
	mov	ecx, DWORD PTR $LN44@Simplified[rbp+rdi*4]
	add	rcx, rbp
	jmp	rcx
$LN15@Simplified:

; 258  :     case SIM_CODE: /* .code */
; 259  :         SetSimSeg( SIM_CODE, name );

	mov	rdx, rbx
	xor	ecx, ecx
	call	SetSimSeg

; 260  : 
; 261  :         if( ModuleInfo.model == MODEL_TINY ) {

	mov	r11d, DWORD PTR ModuleInfo+360
	cmp	r11d, 1
	jne	SHORT $LN14@Simplified

; 262  :             /* v2.05: add the named code segment to DGROUP */
; 263  :             if ( name )

	test	rbx, rbx
	je	SHORT $LN13@Simplified

; 264  :                 AddToDgroup( SIM_CODE, name );

	mov	rdx, rbx
	xor	ecx, ecx
	call	AddToDgroup
$LN13@Simplified:

; 265  :             name = szDgroup;

	lea	rbx, OFFSET FLAT:szDgroup
	jmp	SHORT $LN9@Simplified
$LN14@Simplified:

; 266  :         } else if( ModuleInfo.model == MODEL_FLAT ) {

	cmp	r11d, 7
	jne	SHORT $LN11@Simplified

; 267  :             name = "FLAT";

	lea	rbx, OFFSET FLAT:$SG5708

; 268  :         } else {

	jmp	SHORT $LN9@Simplified
$LN11@Simplified:

; 269  :             if( name == NULL )

	test	rbx, rbx
	cmove	rbx, QWORD PTR SegmNames
$LN9@Simplified:

; 270  :                 name = SegmNames[SIM_CODE];
; 271  :         }
; 272  :         AddLineQueueX( "%r %r:%s", T_ASSUME, T_CS, name );

	lea	rcx, OFFSET FLAT:$SG5712
	mov	r9, rbx
	mov	edx, 444				; 000001bcH
	mov	r8d, 26
	call	AddLineQueueX

; 273  :         break;

	jmp	$LN1@Simplified
$LN8@Simplified:

; 274  :     case SIM_STACK: /* .stack */
; 275  :         /* if code is generated which does "emit" bytes,
; 276  :          * the original source line has to be saved.
; 277  :          * v2.05: must not be done after LstWrite() has been called!
; 278  :          * Also, there are no longer bytes "emitted".
; 279  :          */
; 280  :         //FStoreLine();
; 281  :         SetSimSeg( SIM_STACK, NULL );

	xor	edx, edx
	lea	ecx, QWORD PTR [rdx+1]
	call	SetSimSeg

; 282  :         AddLineQueueX( "ORG 0%xh", opndx.value );

	mov	edx, DWORD PTR opndx$[rsp]
	lea	rcx, OFFSET FLAT:$SG5715
	call	AddLineQueueX

; 283  :         EndSimSeg( SIM_STACK );

	mov	rdx, QWORD PTR SegmNames+8
	lea	rcx, OFFSET FLAT:$SG5672
	mov	r8d, 442				; 000001baH
	call	AddLineQueueX

; 284  :         /* add stack to dgroup for some segmented models */
; 285  :         if ( !init )

	test	sil, sil
	jne	$LN1@Simplified

; 286  :             if ( ModuleInfo.distance != STACK_FAR )

	cmp	DWORD PTR ModuleInfo+356, 1
	je	$LN1@Simplified

; 287  :                 AddToDgroup( SIM_STACK, NULL );

	cmp	DWORD PTR ModuleInfo+360, 7
	je	$LN1@Simplified
	mov	eax, DWORD PTR Options+156
	cmp	eax, 2
	je	SHORT $LN1@Simplified
	cmp	eax, 3
	je	SHORT $LN1@Simplified
	mov	r9, QWORD PTR SegmNames+8
	lea	rdx, OFFSET FLAT:szDgroup
	lea	rcx, OFFSET FLAT:$SG5601
	mov	r8d, 443				; 000001bbH
	call	AddLineQueueX

; 288  :         break;

	jmp	SHORT $LN1@Simplified
$LN5@Simplified:

; 289  :     case SIM_DATA:    /* .data  */
; 290  :     case SIM_DATA_UN: /* .data? */
; 291  :     case SIM_CONST:   /* .const */
; 292  :         SetSimSeg( type, name );

	mov	rdx, rbx
	mov	ecx, edi
	call	SetSimSeg

; 293  :         AddLineQueueX( "%r %r:ERROR", T_ASSUME, T_CS );

	lea	rcx, OFFSET FLAT:$SG5720
	mov	edx, 444				; 000001bcH
	mov	r8d, 26
	call	AddLineQueueX

; 294  :         if ( name || (!init) )

	test	rbx, rbx
	jne	SHORT $LN3@Simplified
	test	sil, sil
	jne	SHORT $LN1@Simplified
$LN3@Simplified:

; 295  :             AddToDgroup( type, name );

	mov	rdx, rbx
	mov	ecx, edi
	call	AddToDgroup

; 296  :         break;

	jmp	SHORT $LN1@Simplified
$LN2@Simplified:

; 297  :     case SIM_FARDATA:     /* .fardata  */
; 298  :     case SIM_FARDATA_UN:  /* .fardata? */
; 299  :         SetSimSeg( type, name );

	mov	rdx, rbx
	mov	ecx, edi
	call	SetSimSeg

; 300  :         AddLineQueueX( "%r %r:ERROR", T_ASSUME, T_CS );

	lea	rcx, OFFSET FLAT:$SG5724
	mov	edx, 444				; 000001bcH
	mov	r8d, 26
	call	AddLineQueueX
$LN1@Simplified:

; 301  :         break;
; 302  :     default: /* shouldn't happen */
; 303  :         /**/myassert( 0 );
; 304  :         break;
; 305  :     }
; 306  : 
; 307  :     RunLineQueue();

	call	RunLineQueue

; 308  : 
; 309  :     DebugMsg1(("SimplifiedSegDir exit\n"));
; 310  :     return( NOT_ERROR );

	xor	eax, eax
$LN48@Simplified:
	mov	rbp, QWORD PTR [rsp+232]
	mov	rdi, QWORD PTR [rsp+184]
$LN31@Simplified:
	mov	rsi, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [rsp+224]

; 311  : }

	add	rsp, 200				; 000000c8H
	ret	0
	npad	2
$LN44@Simplified:
	DD	$LN15@Simplified
	DD	$LN8@Simplified
	DD	$LN5@Simplified
	DD	$LN5@Simplified
	DD	$LN2@Simplified
	DD	$LN2@Simplified
	DD	$LN5@Simplified
SimplifiedSegDir ENDP
_TEXT	ENDS
PUBLIC	SetModelDefaultSegNames
EXTRN	LclAlloc:NEAR
xdata	SEGMENT
$unwind$SetModelDefaultSegNames DD 031001H
	DD	097410H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetModelDefaultSegNames DD @imagerel($LN14#)
	DD	@imagerel($LN14#+204)
	DD	@imagerel($unwind$SetModelDefaultSegNames#)
pdata	ENDS
xdata	SEGMENT
$chain$2$SetModelDefaultSegNames DD 040a21H
	DD	08640aH
	DD	073405H
	DD	@imagerel($LN14#)
	DD	@imagerel($LN14#+204)
	DD	@imagerel($unwind$SetModelDefaultSegNames#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$SetModelDefaultSegNames DD @imagerel($LN14#+204)
	DD	@imagerel($LN14#+336)
	DD	@imagerel($chain$2$SetModelDefaultSegNames#)
pdata	ENDS
xdata	SEGMENT
$chain$3$SetModelDefaultSegNames DD 020021H
	DD	086400H
	DD	@imagerel($LN14#)
	DD	@imagerel($LN14#+204)
	DD	@imagerel($unwind$SetModelDefaultSegNames#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$SetModelDefaultSegNames DD @imagerel($LN14#+336)
	DD	@imagerel($LN14#+356)
	DD	@imagerel($chain$3$SetModelDefaultSegNames#)
pdata	ENDS
xdata	SEGMENT
$chain$4$SetModelDefaultSegNames DD 021H
	DD	@imagerel($LN14#)
	DD	@imagerel($LN14#+204)
	DD	@imagerel($unwind$SetModelDefaultSegNames#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$SetModelDefaultSegNames DD @imagerel($LN14#+356)
	DD	@imagerel($LN14#+427)
	DD	@imagerel($chain$4$SetModelDefaultSegNames#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
SetModelDefaultSegNames PROC NEAR

; 320  : {

$LN14:
	sub	rsp, 40					; 00000028H

; 321  :     /* init segment names with default values */
; 322  :     memcpy( SegmNames, SegmNamesDef, sizeof(SegmNames) );

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [rsp+72], rdi

; 323  : 
; 324  :     /* option -nt set? */
; 325  :     if( Options.names[OPTN_TEXT_SEG] ) {

	mov	rdi, QWORD PTR Options+72
	test	rdi, rdi
	mov	rax, QWORD PTR SegmNamesDef[rcx]
	mov	QWORD PTR SegmNames[rcx], rax
	mov	rax, QWORD PTR SegmNamesDef[rcx+8]
	mov	QWORD PTR SegmNames[rcx+8], rax
	mov	rax, QWORD PTR SegmNamesDef[rcx+16]
	mov	QWORD PTR SegmNames[rcx+16], rax
	mov	rax, QWORD PTR SegmNamesDef[rcx+24]
	mov	QWORD PTR SegmNames[rcx+24], rax
	mov	rax, QWORD PTR SegmNamesDef[rcx+32]
	mov	QWORD PTR SegmNames[rcx+32], rax
	mov	rax, QWORD PTR SegmNamesDef[rcx+40]
	mov	QWORD PTR SegmNames[rcx+40], rax
	mov	rax, QWORD PTR SegmNamesDef[rcx+48]
	mov	QWORD PTR SegmNames[rcx+48], rax
	je	SHORT $LN4@SetModelDe

; 326  :         SegmNames[SIM_CODE] = LclAlloc( strlen( Options.names[OPTN_TEXT_SEG] ) + 1 );

	xor	eax, eax
	mov	rcx, -1
	repne scasb
	not	rcx
	call	LclAlloc

; 327  :         strcpy( SegmNames[SIM_CODE], Options.names[OPTN_TEXT_SEG] );

	mov	rdx, QWORD PTR Options+72
	mov	QWORD PTR SegmNames, rax
	npad	1
$LL7@SetModelDe:
	movzx	ecx, BYTE PTR [rdx]
	inc	rax
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL7@SetModelDe

; 328  :     } else {

	jmp	$LN2@SetModelDe
$LN4@SetModelDe:

; 329  :         if ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ) {

	mov	ecx, DWORD PTR ModuleInfo+360
	mov	eax, 1
	shl	eax, cl
	test	al, 112					; 00000070H
	je	$LN2@SetModelDe

; 330  :             /* for some models, the code segment contains the module name */
; 331  :             SegmNames[SIM_CODE] = LclAlloc( strlen( SegmNamesDef[SIM_CODE] ) + strlen( ModuleInfo.name ) + 1 );

	xor	eax, eax
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi
	lea	rsi, OFFSET FLAT:$SG5558
	mov	rcx, -1
	lea	rbx, OFFSET FLAT:ModuleInfo+512
	mov	rdi, rsi
	repne scasb
	mov	rdi, rbx
	not	rcx
	lea	rdx, QWORD PTR [rcx-1]
	mov	rcx, -1
	repne scasb
	not	rcx
	add	rcx, rdx
	call	LclAlloc
	mov	QWORD PTR SegmNames, rax
	npad	11
$LL8@SetModelDe:

; 332  :             strcpy( SegmNames[SIM_CODE], ModuleInfo.name );

	movzx	ecx, BYTE PTR [rbx]
	inc	rax
	inc	rbx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL8@SetModelDe

; 333  :             strcat( SegmNames[SIM_CODE], SegmNamesDef[SIM_CODE] );

	mov	rdi, QWORD PTR SegmNames
	mov	rbx, QWORD PTR [rsp+56]
	xor	eax, eax
	mov	rcx, -1
	repne scasb
	xor	edx, edx
	npad	7
$LL13@SetModelDe:
	movzx	eax, BYTE PTR [rsi+rdx]
	inc	rdx
	test	al, al
	mov	BYTE PTR [rdi+rdx-2], al
	jne	SHORT $LL13@SetModelDe
	mov	rsi, QWORD PTR [rsp+64]
$LN2@SetModelDe:

; 334  :         }
; 335  :     }
; 336  : 
; 337  :     /* option -nd set? */
; 338  :     if ( Options.names[OPTN_DATA_SEG] ) {

	mov	rdi, QWORD PTR Options+80
	test	rdi, rdi
	je	SHORT $LN1@SetModelDe

; 339  :         SegmNames[SIM_DATA] = LclAlloc( strlen( Options.names[OPTN_DATA_SEG] ) + 1 );

	xor	eax, eax
	mov	rcx, -1
	repne scasb
	not	rcx
	call	LclAlloc

; 340  :         strcpy( SegmNames[SIM_DATA], Options.names[OPTN_DATA_SEG] );

	mov	rdx, QWORD PTR Options+80
	mov	QWORD PTR SegmNames+16, rax
$LL9@SetModelDe:
	movzx	ecx, BYTE PTR [rdx]
	inc	rax
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL9@SetModelDe
$LN1@SetModelDe:
	mov	rdi, QWORD PTR [rsp+72]

; 341  :     }
; 342  :     return;
; 343  : }

	add	rsp, 40					; 00000028H
	ret	0
SetModelDefaultSegNames ENDP
_TEXT	ENDS
PUBLIC	ModelSimSegmInit
xdata	SEGMENT
$unwind$ModelSimSegmInit DD 020601H
	DD	070029206H
xdata	ENDS
pdata	SEGMENT
$pdata$ModelSimSegmInit DD @imagerel($LN14#)
	DD	@imagerel($LN14#+279)
	DD	@imagerel($unwind$ModelSimSegmInit#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
buffer$ = 48
model$ = 96
ModelSimSegmInit PROC NEAR

; 352  : {

$LN14:
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	edi, ecx

; 353  :     char buffer[20];
; 354  : 
; 355  :     ModuleInfo.simseg_init = 0; /* v2.09: reset init flags */
; 356  :     /* v2.09: execute always, to make a proper listing if fastpass is off */
; 357  :     //if ( Parse_Pass == PASS_1 ) {
; 358  :         DebugMsg1(("ModelSimSegmInit() enter, pass one\n" ));
; 359  :         /* create default code segment (_TEXT) */
; 360  :         SetSimSeg( SIM_CODE, NULL );

	xor	edx, edx
	xor	ecx, ecx
	mov	BYTE PTR ModuleInfo+420, 0
	call	SetSimSeg

; 361  :         EndSimSeg( SIM_CODE );

	mov	rdx, QWORD PTR SegmNames
	lea	rcx, OFFSET FLAT:$SG5672
	mov	r8d, 442				; 000001baH
	call	AddLineQueueX

; 362  : 
; 363  :         /* create default data segment (_DATA) */
; 364  :         SetSimSeg( SIM_DATA, NULL ) ;

	xor	edx, edx
	lea	ecx, QWORD PTR [rdx+2]
	call	SetSimSeg

; 365  :         EndSimSeg( SIM_DATA );

	mov	rdx, QWORD PTR SegmNames+16
	lea	rcx, OFFSET FLAT:$SG5672
	mov	r8d, 442				; 000001baH
	call	AddLineQueueX

; 366  : 
; 367  :         /* create DGROUP for BIN/OMF if model isn't FLAT */
; 368  :         if( model != MODEL_FLAT &&
; 369  :            ( Options.output_format == OFORMAT_OMF
; 370  : #if BIN_SUPPORT
; 371  :             || Options.output_format == OFORMAT_BIN
; 372  : #endif
; 373  :            )) {

	cmp	edi, 7
	je	$LN13@ModelSimSe
	mov	eax, DWORD PTR Options+156
	cmp	eax, 1
	je	SHORT $LN3@ModelSimSe
	test	eax, eax
	jne	$LN13@ModelSimSe
$LN3@ModelSimSe:

; 374  :             strcpy( buffer, "%s %r %s" );
; 375  :             if( model == MODEL_TINY ) {

	cmp	edi, 1
	mov	rax, QWORD PTR $SG5741
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR $SG5741+8
	mov	BYTE PTR [rcx+8], al
	jne	SHORT $LN2@ModelSimSe

; 376  :                 strcat( buffer, ", %s" );

	xor	eax, eax
	lea	rdi, QWORD PTR buffer$[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, OFFSET FLAT:$SG5743
	npad	9
$LL11@ModelSimSe:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL11@ModelSimSe

; 377  :                 AddLineQueueX( buffer, szDgroup, T_GROUP, SegmNames[SIM_CODE], SegmNames[SIM_DATA] );

	mov	rax, QWORD PTR SegmNames+16
	mov	r9, QWORD PTR SegmNames
	lea	rdx, OFFSET FLAT:szDgroup
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	r8d, 443				; 000001bbH
	mov	QWORD PTR [rsp+32], rax
	call	AddLineQueueX

; 380  :         }
; 381  :         DebugMsg1(("ModelSimSegmInit() exit\n" ));
; 382  :     //}
; 383  :     return( NOT_ERROR );

	xor	eax, eax

; 384  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
$LN2@ModelSimSe:

; 378  :             } else
; 379  :                 AddLineQueueX( buffer, szDgroup, T_GROUP, SegmNames[SIM_DATA] );

	mov	r9, QWORD PTR SegmNames+16
	lea	rdx, OFFSET FLAT:szDgroup
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	r8d, 443				; 000001bbH
	call	AddLineQueueX
$LN13@ModelSimSe:

; 380  :         }
; 381  :         DebugMsg1(("ModelSimSegmInit() exit\n" ));
; 382  :     //}
; 383  :     return( NOT_ERROR );

	xor	eax, eax

; 384  : }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
ModelSimSegmInit ENDP
_TEXT	ENDS
PUBLIC	ModelSimSegmExit
xdata	SEGMENT
$unwind$ModelSimSegmExit DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$ModelSimSegmExit DD @imagerel($LN8#)
	DD	@imagerel($LN8#+48)
	DD	@imagerel($unwind$ModelSimSegmExit#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
ModelSimSegmExit PROC NEAR

; 390  : {

$LN8:
	sub	rsp, 40					; 00000028H

; 391  :     /* a model is set. Close current segment if one is open. */
; 392  :     if ( CurrSeg ) {

	mov	rdx, QWORD PTR ModuleInfo+432
	test	rdx, rdx
	je	SHORT $LN1@ModelSimSe@2

; 393  :         close_currseg();

	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, OFFSET FLAT:$SG5606
	mov	r8d, 442				; 000001baH
	call	AddLineQueueX

; 394  :         RunLineQueue();

	call	RunLineQueue
$LN1@ModelSimSe@2:

; 395  :     }
; 396  : }

	add	rsp, 40					; 00000028H
	ret	0
ModelSimSegmExit ENDP
_TEXT	ENDS
END
