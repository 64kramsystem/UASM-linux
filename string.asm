; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
$SG5852	DB	'@CatStr', 00H
$SG5855	DB	'@InStr', 00H
	ORG $+1
$SG5861	DB	'@SizeStr', 00H
	ORG $+7
$SG5864	DB	'@SubStr', 00H
_DATA	ENDS
PUBLIC	TextItemError
EXTRN	EmitErr:NEAR
EXTRN	SymFind:NEAR
EXTRN	EmitError:NEAR
xdata	SEGMENT
$unwind$TextItemError DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$TextItemError DD @imagerel($LN8#)
	DD	@imagerel($LN8#+100)
	DD	@imagerel($unwind$TextItemError#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\string.c
pdata	ENDS
_TEXT	SEGMENT
item$ = 48
TextItemError PROC NEAR

; 53   : {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 54   :     if ( item->token == T_STRING && *item->string_ptr == '<' ) {

	movzx	ecx, BYTE PTR [rcx]
	cmp	cl, 9
	jne	SHORT $LN4@TextItemEr
	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax], 60			; 0000003cH
	jne	SHORT $LN4@TextItemEr

; 55   :         return( EmitError( MISSING_ANGLE_BRACKET_OR_BRACE_IN_LITERAL ) );

	mov	ecx, 216				; 000000d8H

; 65   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	EmitError
$LN4@TextItemEr:

; 56   :     }
; 57   :     /* v2.05: better error msg if (text) symbol isn't defined */
; 58   :     if ( item->token == T_ID ) {

	cmp	cl, 8
	jne	SHORT $LN2@TextItemEr

; 59   :         struct asym *sym = SymSearch( item->string_ptr );

	mov	rcx, QWORD PTR [rbx+8]
	call	SymFind

; 60   :         if ( sym == NULL || sym->state == SYM_UNDEFINED ) {

	test	rax, rax
	je	SHORT $LN1@TextItemEr
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN2@TextItemEr
$LN1@TextItemEr:

; 61   :             return( EmitErr( SYMBOL_NOT_DEFINED, item->string_ptr ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 102				; 00000066H

; 65   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	EmitErr
$LN2@TextItemEr:

; 62   :         }
; 63   :     }
; 64   :     return( EmitError( TEXT_ITEM_REQUIRED ) );

	mov	ecx, 144				; 00000090H

; 65   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	EmitError
TextItemError ENDP
_TEXT	ENDS
PUBLIC	CatStrDir
EXTRN	EmitWarn:NEAR
EXTRN	SkipSavedState:NEAR
EXTRN	sym_remove_table:NEAR
EXTRN	SymTables:BYTE
EXTRN	LstWrite:NEAR
EXTRN	LclAlloc:NEAR
EXTRN	SymCreate:NEAR
EXTRN	ModuleInfo:BYTE
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$CatStrDir DD 051c01H
	DD	04c41cH
	DD	063412H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$CatStrDir DD @imagerel($LN34#)
	DD	@imagerel($LN34#+121)
	DD	@imagerel($unwind$CatStrDir#)
pdata	ENDS
xdata	SEGMENT
$chain$3$CatStrDir DD 040a21H
	DD	09740aH
	DD	075405H
	DD	@imagerel($LN34#)
	DD	@imagerel($LN34#+121)
	DD	@imagerel($unwind$CatStrDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$CatStrDir DD @imagerel($LN34#+121)
	DD	@imagerel($LN34#+205)
	DD	@imagerel($chain$3$CatStrDir#)
pdata	ENDS
xdata	SEGMENT
$chain$4$CatStrDir DD 020521H
	DD	086405H
	DD	@imagerel($LN34#+121)
	DD	@imagerel($LN34#+205)
	DD	@imagerel($chain$3$CatStrDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$CatStrDir DD @imagerel($LN34#+205)
	DD	@imagerel($LN34#+278)
	DD	@imagerel($chain$4$CatStrDir#)
pdata	ENDS
xdata	SEGMENT
$chain$5$CatStrDir DD 021H
	DD	@imagerel($LN34#+121)
	DD	@imagerel($LN34#+205)
	DD	@imagerel($chain$3$CatStrDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$CatStrDir DD @imagerel($LN34#+278)
	DD	@imagerel($LN34#+318)
	DD	@imagerel($chain$5$CatStrDir#)
pdata	ENDS
xdata	SEGMENT
$chain$6$CatStrDir DD 021H
	DD	@imagerel($LN34#)
	DD	@imagerel($LN34#+121)
	DD	@imagerel($unwind$CatStrDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$CatStrDir DD @imagerel($LN34#+318)
	DD	@imagerel($LN34#+506)
	DD	@imagerel($chain$6$CatStrDir#)
pdata	ENDS
xdata	SEGMENT
$chain$7$CatStrDir DD 040021H
	DD	097400H
	DD	075400H
	DD	@imagerel($LN34#)
	DD	@imagerel($LN34#+121)
	DD	@imagerel($unwind$CatStrDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$CatStrDir DD @imagerel($LN34#+506)
	DD	@imagerel($LN34#+582)
	DD	@imagerel($chain$7$CatStrDir#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
CatStrDir PROC NEAR

; 75   : {

$LN34:
	sub	rsp, 40					; 00000028H

; 76   :     struct asym *sym;
; 77   :     int count;
; 78   :     char *p;
; 79   :     /* struct expr opndx; */
; 80   : 
; 81   :     DebugMsg1(("CatStrDir(%u) enter\n", i ));
; 82   :     DebugCmd( catstrcnt++ );
; 83   : 
; 84   : #if 0 /* can't happen */
; 85   :     /* syntax must be <id> CATSTR textitem[,textitem,...] */
; 86   :     if ( i != 1 ) {
; 87   :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );
; 88   :     }
; 89   :     if ( tokenarray[0].token != T_ID ) {
; 90   :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );
; 91   :     }
; 92   : #endif
; 93   :     i++; /* go past CATSTR/TEXTEQU */
; 94   : 
; 95   :     /* v2.08: don't copy to temp buffer */
; 96   :     //*StringBufferEnd = NULLC;
; 97   :     /* check correct syntax and length of items */
; 98   :     for ( count = 0; i < Token_Count; ) {

	mov	r9d, DWORD PTR ModuleInfo+496
	inc	ecx
	mov	QWORD PTR [rsp+48], rbx
	xor	ebx, ebx
	cmp	ecx, r9d
	mov	QWORD PTR [rsp+32], r12
	mov	r12, rdx
	movsxd	r8, ecx
	jge	SHORT $LN15@CatStrDir
	shl	r8, 5
	add	r8, rdx
	npad	5
$LL16@CatStrDir:

; 99   :         DebugMsg1(("CatStrDir(%s): item[%u]=%s delim=0x%x\n", tokenarray[0].string_ptr, i, tokenarray[i].string_ptr, tokenarray[i].string_delim ));
; 100  :         if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	cmp	BYTE PTR [r8], 9
	jne	$LN13@CatStrDir
	cmp	BYTE PTR [r8+1], 60			; 0000003cH
	jne	$LN13@CatStrDir

; 103  :         }
; 104  :         /* v2.08: using tokenarray.stringlen is not quite correct, since some chars
; 105  :          * are stored in 2 bytes (!) */
; 106  :         if ( ( count + tokenarray[i].stringlen ) >= MAX_LINE_LEN ) {

	mov	eax, DWORD PTR [r8+16]
	add	ebx, eax
	cmp	ebx, 1024				; 00000400H
	jae	$LN28@CatStrDir

; 109  :         }
; 110  :         /* v2.08: don't copy to temp buffer */
; 111  :         //strcpy( StringBufferEnd + count, tokenarray[i].string_ptr );
; 112  :         count = count + tokenarray[i].stringlen;
; 113  :         i++;
; 114  :         if ( ( tokenarray[i].token != T_COMMA ) &&
; 115  :             ( tokenarray[i].token != T_FINAL ) ) {

	movzx	eax, BYTE PTR [r8+32]
	inc	ecx
	cmp	al, 44					; 0000002cH
	je	SHORT $LN11@CatStrDir
	test	al, al
	jne	$LN29@CatStrDir
$LN11@CatStrDir:

; 117  :         }
; 118  :         i++;

	inc	ecx
	add	r8, 64					; 00000040H
	cmp	ecx, r9d
	jl	SHORT $LL16@CatStrDir
$LN15@CatStrDir:

; 119  :     }
; 120  : 
; 121  :     sym = SymSearch( tokenarray[0].string_ptr );

	mov	rcx, QWORD PTR [rdx+8]
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+72], rdi
	call	SymFind

; 122  :     if ( sym == NULL ) {

	mov	ebp, 2
	test	rax, rax
	mov	rdi, rax
	jne	$LN10@CatStrDir

; 123  :         sym = SymCreate( tokenarray[0].string_ptr );

	mov	rcx, QWORD PTR [r12+8]
	call	SymCreate
	mov	rdi, rax
$LN6@CatStrDir:

; 139  :     }
; 140  : 
; 141  : 
; 142  :     sym->state = SYM_TMACRO;
; 143  :     sym->isdefined = TRUE;

	or	BYTE PTR [rdi+48], bpl

; 144  : #if FASTMEM==0
; 145  :     if ( sym->string_ptr )
; 146  :         LclFree( sym->string_ptr );
; 147  :     sym->string_ptr = (char *)LclAlloc( count + 1 );
; 148  : #else
; 149  :     /* v2.08: reuse string space if fastmem is on */
; 150  :     if ( sym->total_size < ( count+1 ) ) {

	inc	ebx
	mov	DWORD PTR [rdi+40], 10
	cmp	DWORD PTR [rdi+64], ebx
	jae	SHORT $LN5@CatStrDir

; 151  :         LclFree( sym->string_ptr ); /* is a noop if fastmem is on */
; 152  :         sym->string_ptr = (char *)LclAlloc( count + 1 );

	movsxd	rcx, ebx
	call	LclAlloc

; 153  :         sym->total_size = count + 1;

	mov	DWORD PTR [rdi+64], ebx
	mov	QWORD PTR [rdi+16], rax
$LN5@CatStrDir:

; 154  :     }
; 155  : #endif
; 156  :     /* v2.08: don't use temp buffer */
; 157  :     //memcpy( sym->string_ptr, StringBufferEnd, count + 1 );
; 158  :     for ( i = 2, p = sym->string_ptr; i < Token_Count; i += 2 ) {

	cmp	DWORD PTR ModuleInfo+496, ebp
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, QWORD PTR [rdi+16]
	jle	SHORT $LN2@CatStrDir
	lea	rbx, QWORD PTR [r12+80]
	npad	3
$LL4@CatStrDir:

; 159  :         memcpy( p, tokenarray[i].string_ptr, tokenarray[i].stringlen );

	mov	r8d, DWORD PTR [rbx]
	mov	rdx, QWORD PTR [rbx-8]
	mov	rcx, rsi
	call	memcpy

; 160  :         p += tokenarray[i].stringlen;

	mov	r11d, DWORD PTR [rbx]
	add	ebp, 2
	add	rsi, r11
	add	rbx, 64					; 00000040H
	cmp	ebp, DWORD PTR ModuleInfo+496
	jl	SHORT $LL4@CatStrDir
$LN2@CatStrDir:

; 161  :     }
; 162  :     *p = NULLC;

	mov	BYTE PTR [rsi], 0

; 163  :     DebugMsg1(("CatStrDir(%s) (new) value: >%s<\n", sym->name, sym->string_ptr ));
; 164  : 
; 165  :     if ( ModuleInfo.list )

	bt	DWORD PTR ModuleInfo+408, 12
	mov	rsi, QWORD PTR [rsp+64]
	jae	SHORT $LN1@CatStrDir

; 166  :         LstWrite( LSTTYPE_TMACRO, 0, sym );

	xor	edx, edx
	mov	r8, rdi
	lea	ecx, QWORD PTR [rdx+3]
	call	LstWrite
$LN1@CatStrDir:

; 167  : 
; 168  :     return( NOT_ERROR );

	xor	eax, eax
$LN33@CatStrDir:
	mov	rbp, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+72]
	mov	r12, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+48]

; 169  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@CatStrDir:

; 107  :             DebugMsg(("CatStrDir: error, literal too long: %u + %u >= %u\n", count, tokenarray[i].stringlen, MAX_LINE_LEN ));
; 108  :             return( EmitError( STRING_OR_TEXT_LITERAL_TOO_LONG ) );

	mov	ecx, 155				; 0000009bH
	mov	r12, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+48]

; 169  : }

	add	rsp, 40					; 00000028H
	jmp	EmitError
$LN29@CatStrDir:

; 116  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+r12+8]
	mov	r12, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+48]

; 169  : }

	add	rsp, 40					; 00000028H
	jmp	EmitErr
$LN13@CatStrDir:

; 101  :             DebugMsg(("CatStrDir: error, not a <>-literal: %s\n", tokenarray[i].tokpos ));
; 102  :             return( TextItemError( &tokenarray[i] ) );

	movsxd	rbx, ecx
	shl	rbx, 5
	add	rbx, rdx
	movzx	ecx, BYTE PTR [rbx]
	cmp	cl, 9
	jne	SHORT $LN22@CatStrDir
	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax], 60			; 0000003cH
	jne	SHORT $LN22@CatStrDir
	mov	ecx, 216				; 000000d8H
	mov	r12, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+48]

; 169  : }

	add	rsp, 40					; 00000028H
	jmp	EmitError

; 101  :             DebugMsg(("CatStrDir: error, not a <>-literal: %s\n", tokenarray[i].tokpos ));
; 102  :             return( TextItemError( &tokenarray[i] ) );

$LN22@CatStrDir:
	cmp	cl, 8
	jne	SHORT $LN20@CatStrDir
	mov	rcx, QWORD PTR [rbx+8]
	call	SymFind
	test	rax, rax
	je	SHORT $LN19@CatStrDir
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN20@CatStrDir
$LN19@CatStrDir:
	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 102				; 00000066H
	mov	r12, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+48]

; 169  : }

	add	rsp, 40					; 00000028H
	jmp	EmitErr

; 101  :             DebugMsg(("CatStrDir: error, not a <>-literal: %s\n", tokenarray[i].tokpos ));
; 102  :             return( TextItemError( &tokenarray[i] ) );

$LN20@CatStrDir:
	mov	ecx, 144				; 00000090H
	mov	r12, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+48]

; 169  : }

	add	rsp, 40					; 00000028H
	jmp	EmitError
$LN10@CatStrDir:

; 124  :         DebugMsg1(( "CatStrDir: new symbol %s created\n", sym->name));
; 125  :     } else if( sym->state == SYM_UNDEFINED ) {

	mov	eax, DWORD PTR [rax+40]
	test	eax, eax
	jne	SHORT $LN8@CatStrDir

; 126  :         /* v2.01: symbol has been used already. Using
; 127  :          * a textmacro before it has been defined is
; 128  :          * somewhat problematic.
; 129  :          */
; 130  :         sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rdi
	call	sym_remove_table

; 131  : #if FASTPASS
; 132  :         SkipSavedState(); /* further passes must be FULL! */

	call	SkipSavedState

; 133  : #endif
; 134  :         EmitWarn( 2, TEXT_MACRO_USED_PRIOR_TO_DEFINITION, sym->name );

	mov	r8, QWORD PTR [rdi+8]
	mov	edx, 236				; 000000ecH
	mov	ecx, ebp
	call	EmitWarn
	jmp	$LN6@CatStrDir
$LN8@CatStrDir:

; 135  :     } else if( sym->state != SYM_TMACRO ) {

	cmp	eax, 10
	je	$LN6@CatStrDir

; 136  :         /* it is defined as something else, get out */
; 137  :         DebugMsg(( "CatStrDir(%s) exit, symbol redefinition\n", sym->name));
; 138  :         return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rdi+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN33@CatStrDir
CatStrDir ENDP
_TEXT	ENDS
PUBLIC	SetTextMacro
EXTRN	isspace:NEAR
xdata	SEGMENT
$unwind$SetTextMacro DD 071601H
	DD	086416H
	DD	075411H
	DD	06340cH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetTextMacro DD @imagerel($LN21#)
	DD	@imagerel($LN21#+59)
	DD	@imagerel($unwind$SetTextMacro#)
pdata	ENDS
xdata	SEGMENT
$chain$3$SetTextMacro DD 020521H
	DD	097405H
	DD	@imagerel($LN21#)
	DD	@imagerel($LN21#+59)
	DD	@imagerel($unwind$SetTextMacro#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$SetTextMacro DD @imagerel($LN21#+59)
	DD	@imagerel($LN21#+99)
	DD	@imagerel($chain$3$SetTextMacro#)
pdata	ENDS
xdata	SEGMENT
$chain$4$SetTextMacro DD 021H
	DD	@imagerel($LN21#)
	DD	@imagerel($LN21#+59)
	DD	@imagerel($unwind$SetTextMacro#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$SetTextMacro DD @imagerel($LN21#+99)
	DD	@imagerel($LN21#+184)
	DD	@imagerel($chain$4$SetTextMacro#)
pdata	ENDS
xdata	SEGMENT
$chain$5$SetTextMacro DD 020021H
	DD	097400H
	DD	@imagerel($LN21#)
	DD	@imagerel($LN21#+59)
	DD	@imagerel($unwind$SetTextMacro#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$SetTextMacro DD @imagerel($LN21#+184)
	DD	@imagerel($LN21#+322)
	DD	@imagerel($chain$5$SetTextMacro#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
tokenarray$ = 48
sym$ = 56
name$ = 64
value$ = 72
SetTextMacro PROC NEAR

; 179  : {

$LN21:
	sub	rsp, 40					; 00000028H

; 180  :     int count;
; 181  :     //char *p;
; 182  : 
; 183  :     DebugCmd( equcnt++ );
; 184  : 
; 185  :     if ( sym == NULL )

	test	rdx, rdx
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	rbp, r9
	mov	rbx, rcx
	mov	rsi, rdx
	jne	SHORT $LN13@SetTextMac

; 186  :         sym = SymCreate( name );

	mov	rcx, r8
	call	SymCreate
	mov	rsi, rax
$LN9@SetTextMac:

; 200  :     }
; 201  : 
; 202  :     sym->state = SYM_TMACRO;
; 203  :     sym->isdefined = TRUE;

	or	BYTE PTR [rsi+48], 2
	mov	DWORD PTR [rsi+40], 10

; 204  : 
; 205  :     if ( tokenarray[2].token == T_STRING && tokenarray[2].string_delim == '<' ) {

	cmp	BYTE PTR [rbx+64], 9
	mov	QWORD PTR [rsp+72], rdi
	jne	SHORT $LN8@SetTextMac
	cmp	BYTE PTR [rbx+65], 60			; 0000003cH
	jne	SHORT $LN8@SetTextMac

; 206  : 
; 207  :         /* the simplest case: value is a literal. define a text macro! */
; 208  :         /* just ONE literal is allowed */
; 209  :         if ( tokenarray[3].token != T_FINAL ) {

	cmp	BYTE PTR [rbx+96], 0
	je	SHORT $LN7@SetTextMac

; 210  :             EmitErr( SYNTAX_ERROR_EX, tokenarray[3].tokpos );

	mov	rdx, QWORD PTR [rbx+120]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 211  :             return( NULL );

	xor	eax, eax
	jmp	$LN20@SetTextMac
$LN13@SetTextMac:

; 187  :     else if ( sym->state == SYM_UNDEFINED ) {

	mov	eax, DWORD PTR [rdx+40]
	test	eax, eax
	jne	SHORT $LN11@SetTextMac

; 188  :         sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table

; 189  : #if FASTPASS
; 190  :         /* the text macro was referenced before being defined.
; 191  :          * this is valid usage, but it requires a full second pass.
; 192  :          * just simply deactivate the fastpass feature for this module!
; 193  :          */
; 194  :         SkipSavedState();

	call	SkipSavedState

; 195  : #endif
; 196  :         EmitWarn( 2, TEXT_MACRO_USED_PRIOR_TO_DEFINITION, sym->name );

	mov	r8, QWORD PTR [rsi+8]
	mov	edx, 236				; 000000ecH
	mov	ecx, 2
	call	EmitWarn
	jmp	SHORT $LN9@SetTextMac
$LN11@SetTextMac:

; 197  :     } else if ( sym->state != SYM_TMACRO ) {

	cmp	eax, 10
	je	SHORT $LN9@SetTextMac

; 198  :         EmitErr( SYMBOL_REDEFINITION, name );

	mov	rdx, r8
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 199  :         return( NULL );

	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 243  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN7@SetTextMac:

; 212  :         }
; 213  :         value = tokenarray[2].string_ptr;

	mov	rbp, QWORD PTR [rbx+72]

; 214  :         count = tokenarray[2].stringlen;

	mov	ebx, DWORD PTR [rbx+80]

; 215  :     } else {

	jmp	SHORT $LN19@SetTextMac
$LN8@SetTextMac:

; 216  :         /*
; 217  :          * the original source is used, since the tokenizer has
; 218  :          * deleted some information.
; 219  :          */
; 220  :         //while ( isspace( *value ) ) value++; /* probably obsolete */
; 221  :         count = strlen( value );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbp
	repne scasb
	not	rcx
	dec	rcx

; 222  :         /* skip trailing spaces */
; 223  :         for ( ; count; count-- )

	test	ecx, ecx
	mov	rbx, rcx
	movsxd	rdi, ecx
	je	SHORT $LN19@SetTextMac
	npad	1
$LL5@SetTextMac:

; 224  :             if ( isspace( *( value + count - 1 ) ) == FALSE )

	movsx	ecx, BYTE PTR [rdi+rbp-1]
	call	isspace
	test	eax, eax
	je	SHORT $LN19@SetTextMac
	dec	ebx
	dec	rdi
	jne	SHORT $LL5@SetTextMac
$LN19@SetTextMac:

; 225  :                 break;
; 226  :     }
; 227  : #if FASTMEM==0
; 228  :     if ( sym->string_ptr )
; 229  :         LclFree( sym->string_ptr );
; 230  :     sym->string_ptr = (char *)LclAlloc( count + 1 );
; 231  : #else
; 232  :     if ( sym->total_size < ( count + 1 ) ) {

	lea	edi, DWORD PTR [rbx+1]
	cmp	DWORD PTR [rsi+64], edi
	jae	SHORT $LN1@SetTextMac

; 233  :         LclFree( sym->string_ptr ); /* is a noop if fastmem is on */
; 234  :         sym->string_ptr = (char *)LclAlloc( count + 1 );

	movsxd	rcx, edi
	call	LclAlloc

; 235  :         sym->total_size = count + 1;

	mov	DWORD PTR [rsi+64], edi
	mov	QWORD PTR [rsi+16], rax
$LN1@SetTextMac:

; 236  :     }
; 237  : #endif
; 238  :     memcpy( sym->string_ptr, value, count );

	mov	rcx, QWORD PTR [rsi+16]
	movsxd	rdi, ebx
	mov	rdx, rbp
	mov	r8, rdi
	call	memcpy

; 239  :     *(sym->string_ptr + count) = NULLC;

	mov	rdx, QWORD PTR [rsi+16]

; 240  : 
; 241  :     DebugMsg1(( "SetTextMacro(%s): value is >%s<, exit\n", sym->name, sym->string_ptr ));
; 242  :     return( sym );

	mov	rax, rsi
	mov	BYTE PTR [rdi+rdx], 0
$LN20@SetTextMac:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 243  : }

	add	rsp, 40					; 00000028H
	ret	0
SetTextMacro ENDP
_TEXT	ENDS
PUBLIC	AddPredefinedText
xdata	SEGMENT
$unwind$AddPredefinedText DD 050e01H
	DD	09740eH
	DD	083409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$AddPredefinedText DD @imagerel($LN4#)
	DD	@imagerel($LN4#+75)
	DD	@imagerel($unwind$AddPredefinedText#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
value$ = 56
AddPredefinedText PROC NEAR

; 254  : {

$LN4:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx
	mov	rbx, rdx

; 255  :     struct asym *sym;
; 256  : 
; 257  :     DebugMsg1(("AddPredefinedText(%s): >%s<\n", name, value ));
; 258  :     /* v2.08: ignore previous setting */
; 259  :     if ( NULL == ( sym = SymSearch( name ) ) )

	call	SymFind
	test	rax, rax
	jne	SHORT $LN1@AddPredefi

; 260  :         sym = SymCreate( name );

	mov	rcx, rdi
	call	SymCreate
$LN1@AddPredefi:

; 261  :     sym->state = SYM_TMACRO;
; 262  :     sym->isdefined = TRUE;
; 263  :     sym->predefined = TRUE;

	or	BYTE PTR [rax+48], 34			; 00000022H
	mov	rdi, QWORD PTR [rsp+72]

; 264  :     sym->string_ptr = (char *)value;

	mov	QWORD PTR [rax+16], rbx
	mov	rbx, QWORD PTR [rsp+64]
	mov	DWORD PTR [rax+40], 10

; 265  :     /* to ensure that a new buffer is used if the string is modified */
; 266  :     sym->total_size = 0;

	mov	DWORD PTR [rax+64], 0

; 267  :     return( sym );
; 268  : }

	add	rsp, 40					; 00000028H
	ret	0
AddPredefinedText ENDP
_TEXT	ENDS
PUBLIC	SubStrDir
EXTRN	EvalOperand:NEAR
xdata	SEGMENT
$unwind$SubStrDir DD 081e01H
	DD	016c41eH
	DD	0177414H
	DD	01c340eH
	DD	019010aH
xdata	ENDS
pdata	SEGMENT
$pdata$SubStrDir DD @imagerel($LN34#)
	DD	@imagerel($LN34#+64)
	DD	@imagerel($unwind$SubStrDir#)
pdata	ENDS
xdata	SEGMENT
$chain$4$SubStrDir DD 040c21H
	DD	015d40cH
	DD	01d5404H
	DD	@imagerel($LN34#)
	DD	@imagerel($LN34#+64)
	DD	@imagerel($unwind$SubStrDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$SubStrDir DD @imagerel($LN34#+64)
	DD	@imagerel($LN34#+182)
	DD	@imagerel($chain$4$SubStrDir#)
pdata	ENDS
xdata	SEGMENT
$chain$5$SubStrDir DD 020821H
	DD	0186408H
	DD	@imagerel($LN34#+64)
	DD	@imagerel($LN34#+182)
	DD	@imagerel($chain$4$SubStrDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$SubStrDir DD @imagerel($LN34#+182)
	DD	@imagerel($LN34#+216)
	DD	@imagerel($chain$5$SubStrDir#)
pdata	ENDS
xdata	SEGMENT
$chain$6$SubStrDir DD 021H
	DD	@imagerel($LN34#+64)
	DD	@imagerel($LN34#+182)
	DD	@imagerel($chain$4$SubStrDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$SubStrDir DD @imagerel($LN34#+216)
	DD	@imagerel($LN34#+232)
	DD	@imagerel($chain$6$SubStrDir#)
pdata	ENDS
xdata	SEGMENT
$chain$7$SubStrDir DD 021H
	DD	@imagerel($LN34#)
	DD	@imagerel($LN34#+64)
	DD	@imagerel($unwind$SubStrDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$SubStrDir DD @imagerel($LN34#+232)
	DD	@imagerel($LN34#+264)
	DD	@imagerel($chain$7$SubStrDir#)
pdata	ENDS
xdata	SEGMENT
$chain$8$SubStrDir DD 060021H
	DD	015d400H
	DD	0186400H
	DD	01d5400H
	DD	@imagerel($LN34#)
	DD	@imagerel($LN34#+64)
	DD	@imagerel($unwind$SubStrDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$SubStrDir DD @imagerel($LN34#+264)
	DD	@imagerel($LN34#+713)
	DD	@imagerel($chain$8$SubStrDir#)
pdata	ENDS
xdata	SEGMENT
$chain$9$SubStrDir DD 021H
	DD	@imagerel($LN34#)
	DD	@imagerel($LN34#+64)
	DD	@imagerel($unwind$SubStrDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$SubStrDir DD @imagerel($LN34#+713)
	DD	@imagerel($LN34#+808)
	DD	@imagerel($chain$9$SubStrDir#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
opndx$ = 48
i$ = 208
tokenarray$ = 216
SubStrDir PROC NEAR

; 276  : {

$LN34:
	mov	rax, rsp
	sub	rsp, 200				; 000000c8H
	mov	QWORD PTR [rax+24], rbx

; 277  :     struct asym         *sym;
; 278  :     char                *name;
; 279  :     char                *p;
; 280  :     //char                *newvalue;
; 281  :     int                 pos;
; 282  :     int                 size;
; 283  :     int                 cnt;
; 284  :     bool                chksize;
; 285  :     struct expr         opndx;
; 286  : 
; 287  :     DebugMsg1(("SubStrDir enter\n"));
; 288  :     DebugCmd( substrcnt++ );
; 289  : 
; 290  :     /* at least 5 items are needed
; 291  :      * 0  1      2      3 4    5   6
; 292  :      * ID SUBSTR SRC_ID , POS [, LENGTH]
; 293  :      */
; 294  : #if 0 /* can't happen */
; 295  :     if ( i != 1 ) {
; 296  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );
; 297  :     }
; 298  :     if ( tokenarray[0].token != T_ID ) {
; 299  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );
; 300  :     }
; 301  : #endif
; 302  :     name = tokenarray[0].string_ptr;
; 303  : 
; 304  :     i++; /* go past SUBSTR */

	inc	ecx
	mov	QWORD PTR [rax-16], rdi

; 305  : 
; 306  :     /* third item must be a string */
; 307  : 
; 308  :     if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rbx, ecx
	mov	DWORD PTR [rax+8], ecx
	mov	QWORD PTR [rax-24], r12
	mov	r12, QWORD PTR [rdx+8]
	shl	rbx, 5
	mov	rdi, rdx
	cmp	BYTE PTR [rbx+rdx], 9
	jne	$LN21@SubStrDir
	cmp	BYTE PTR [rbx+rdx+1], 60		; 0000003cH
	jne	$LN21@SubStrDir

; 311  :     }
; 312  :     p = tokenarray[i].string_ptr;
; 313  :     cnt = tokenarray[i].stringlen;
; 314  : 
; 315  :     i++;

	inc	ecx
	mov	QWORD PTR [rax+32], rbp
	mov	ebp, DWORD PTR [rbx+rdx+16]
	mov	QWORD PTR [rax-32], r13
	mov	r13, QWORD PTR [rbx+rdx+8]

; 316  :     DebugMsg1(("SubStrDir(%s): src=>%s<\n", name, p));
; 317  : 
; 318  :     if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rdx, ecx
	shl	rdx, 5
	mov	DWORD PTR [rax+8], ecx
	cmp	BYTE PTR [rdx+rdi], 44			; 0000002cH
	je	SHORT $LN20@SubStrDir

; 319  :         return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rdi+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	SHORT $LN32@SubStrDir
$LN20@SubStrDir:

; 320  :     }
; 321  :     i++;
; 322  : 
; 323  :     /* get pos, must be a numeric value and > 0 */
; 324  :     /* v2.11: flag NOUNDEF added - no forward ref possible */
; 325  : 
; 326  :     if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR ) {

	mov	r8d, DWORD PTR ModuleInfo+496
	inc	ecx
	lea	r9, QWORD PTR opndx$[rsp]
	mov	DWORD PTR i$[rsp], ecx
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rdi
	mov	BYTE PTR [rsp+32], 2
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN19@SubStrDir

; 327  :         DebugMsg(("SubStrDir(%s): invalid pos value\n", name));
; 328  :         return( ERROR );

	jmp	SHORT $LN32@SubStrDir
$LN19@SubStrDir:

; 329  :     }
; 330  : 
; 331  :     /* v2.04: "string" constant allowed as second argument */
; 332  :     //if ( opndx.kind != EXPR_CONST || opndx.string != NULL ) {
; 333  :     if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN18@SubStrDir

; 334  :         DebugMsg(("SubStrDir(%s): pos value is not a constant\n", name));
; 335  :         return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	SHORT $LN32@SubStrDir
$LN18@SubStrDir:
	mov	QWORD PTR [rsp+192], rsi

; 336  :     }
; 337  : 
; 338  :     /* pos is expected to be 1-based */
; 339  :     pos = opndx.value;

	mov	esi, DWORD PTR opndx$[rsp]

; 340  :     if ( pos <= 0 ) {

	test	esi, esi
	jg	SHORT $LN17@SubStrDir

; 341  :         return( EmitError( POSITIVE_VALUE_EXPECTED ) );

	mov	ecx, 175				; 000000afH
	call	EmitError
$LN33@SubStrDir:
	mov	rsi, QWORD PTR [rsp+192]
$LN32@SubStrDir:
	mov	rbp, QWORD PTR [rsp+232]
	mov	r13, QWORD PTR [rsp+168]
$LN23@SubStrDir:
	mov	r12, QWORD PTR [rsp+176]
	mov	rdi, QWORD PTR [rsp+184]
	mov	rbx, QWORD PTR [rsp+224]

; 447  : }

	add	rsp, 200				; 000000c8H
	ret	0
$LN17@SubStrDir:

; 342  :     }
; 343  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, rcx
	shl	rdx, 5
	movzx	eax, BYTE PTR [rdx+rdi]
	test	al, al
	je	$LN16@SubStrDir

; 344  :         if ( tokenarray[i].token != T_COMMA ) {

	cmp	al, 44					; 0000002cH
	je	SHORT $LN15@SubStrDir

; 345  :             return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rdi+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	SHORT $LN33@SubStrDir
$LN15@SubStrDir:

; 346  :         }
; 347  :         i++;
; 348  :         /* get size, must be a constant */
; 349  :         /* v2.11: flag NOUNDEF added - no forward ref possible */
; 350  :         if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR ) {

	mov	r8d, DWORD PTR ModuleInfo+496
	inc	ecx
	lea	r9, QWORD PTR opndx$[rsp]
	mov	DWORD PTR i$[rsp], ecx
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rdi
	mov	BYTE PTR [rsp+32], 2
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN14@SubStrDir

; 351  :             DebugMsg(("SubStrDir(%s): invalid size value\n", name));
; 352  :             return( ERROR );

	jmp	$LN33@SubStrDir
$LN14@SubStrDir:

; 353  :         }
; 354  :         /* v2.04: string constant ok */
; 355  :         //if ( opndx.kind != EXPR_CONST || opndx.string != NULL ) {
; 356  :         if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN13@SubStrDir

; 357  :             DebugMsg(("SubStrDir(%s): size value is not a constant\n", name));
; 358  :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	$LN33@SubStrDir
$LN13@SubStrDir:

; 359  :         }
; 360  :         size = opndx.value;
; 361  :         if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, DWORD PTR i$[rsp]
	mov	ebx, DWORD PTR opndx$[rsp]
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rdi], 0
	je	SHORT $LN12@SubStrDir

; 362  :             DebugMsg(("SubStrDir(%s): additional items found\n", name));
; 363  :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+rdi+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN33@SubStrDir
$LN12@SubStrDir:

; 364  :         }
; 365  :         if ( size < 0 ) {

	test	ebx, ebx
	jns	SHORT $LN11@SubStrDir

; 366  :             return( EmitError( COUNT_MUST_BE_POSITIVE_OR_ZERO ) );

	mov	ecx, 208				; 000000d0H
	call	EmitError
	jmp	$LN33@SubStrDir
$LN11@SubStrDir:

; 367  :         }
; 368  :         chksize = TRUE;

	mov	al, 1

; 369  :     } else {

	jmp	SHORT $LN10@SubStrDir
$LN16@SubStrDir:

; 370  :         size = -1;

	mov	ebx, -1

; 371  :         chksize = FALSE;

	xor	al, al
$LN10@SubStrDir:

; 372  :     }
; 373  : #if 0
; 374  :     cnt = pos;
; 375  :     /* position p to start of substring */
; 376  :     for ( pos--; pos > 0 && *p ; pos--, p++ )
; 377  :         if ( *p == '!' && *(p+1) != NULLC )
; 378  :             p++;
; 379  :     if ( *p == NULLC ) {
; 380  :         return( EmitErr( INDEX_VALUE_PAST_END_OF_STRING, cnt ) );
; 381  :     }
; 382  :     if ( *p == '!' && *(p+1) != NULLC )
; 383  :         p++;
; 384  :     for ( newvalue = p, cnt = size; *p && cnt; cnt--, p++ )
; 385  :         if ( *p == '!' && *(p+1) != NULLC )
; 386  :             p++;
; 387  :     /* v2.04: check added */
; 388  :     if ( chksize && cnt ) {
; 389  :         return( EmitError( COUNT_VALUE_TOO_LARGE ) );
; 390  :     }
; 391  :     size = p - newvalue;
; 392  :     p = newvalue;
; 393  : #else
; 394  :     if ( pos > cnt ) {

	cmp	esi, ebp
	jle	SHORT $LN9@SubStrDir

; 395  :         return( EmitErr( INDEX_VALUE_PAST_END_OF_STRING, pos ) );

	mov	edx, esi
	mov	ecx, 206				; 000000ceH
	call	EmitErr
	jmp	$LN33@SubStrDir
$LN9@SubStrDir:

; 396  :     }
; 397  :     if ( chksize && (pos+size-1) > cnt )  {

	test	al, al
	je	SHORT $LN8@SubStrDir
	lea	eax, DWORD PTR [rbx+rsi-1]
	cmp	eax, ebp
	jle	SHORT $LN8@SubStrDir

; 398  :         return( EmitError( COUNT_VALUE_TOO_LARGE ) );

	mov	ecx, 207				; 000000cfH
	call	EmitError
	jmp	$LN33@SubStrDir
$LN8@SubStrDir:

; 399  :     }
; 400  :     p += pos - 1;

	lea	eax, DWORD PTR [rsi-1]
	movsxd	rcx, eax
	add	r13, rcx

; 401  :     if ( size == -1 )

	cmp	ebx, -1
	jne	SHORT $LN7@SubStrDir

; 402  :         size = cnt - pos + 1;

	mov	ebx, ebp
	sub	ebx, esi
	inc	ebx
$LN7@SubStrDir:

; 403  : #endif
; 404  : 
; 405  :     sym = SymSearch( name );

	mov	rcx, r12
	call	SymFind

; 406  : 
; 407  :     /* if we've never seen it before, put it in */
; 408  :     if( sym == NULL ) {

	test	rax, rax
	mov	rdi, rax
	jne	SHORT $LN6@SubStrDir

; 409  :         sym = SymCreate( name );

	mov	rcx, r12
	call	SymCreate
	mov	rdi, rax
$LN2@SubStrDir:

; 424  :     }
; 425  : 
; 426  :     sym->state = SYM_TMACRO;
; 427  :     sym->isdefined = TRUE;

	or	BYTE PTR [rdi+48], 2

; 428  : 
; 429  : #if FASTMEM==0
; 430  :     if ( sym->string_ptr )
; 431  :         LclFree( sym->string_ptr );
; 432  :     sym->string_ptr = (char *)LclAlloc( size + 1 );
; 433  : #else
; 434  :     if ( sym->total_size < ( size + 1 ) ) {

	lea	esi, DWORD PTR [rbx+1]
	mov	DWORD PTR [rdi+40], 10
	cmp	DWORD PTR [rdi+64], esi
	jae	SHORT $LN1@SubStrDir

; 435  :         LclFree( sym->string_ptr );
; 436  :         sym->string_ptr = LclAlloc ( size + 1 );

	movsxd	rcx, esi
	call	LclAlloc

; 437  :         sym->total_size = size + 1;

	mov	DWORD PTR [rdi+64], esi
	mov	QWORD PTR [rdi+16], rax
$LN1@SubStrDir:

; 438  :     }
; 439  : #endif
; 440  :     memcpy( sym->string_ptr, p, size );

	mov	rcx, QWORD PTR [rdi+16]
	movsxd	rbx, ebx
	mov	rdx, r13
	mov	r8, rbx
	call	memcpy

; 441  :     *(sym->string_ptr + size) = NULLC;

	mov	r11, QWORD PTR [rdi+16]

; 442  :     DebugMsg1(("SubStrDir(%s): result=>%s<\n", sym->name, sym->string_ptr ));
; 443  : 
; 444  :     LstWrite( LSTTYPE_TMACRO, 0, sym );

	xor	edx, edx
	lea	ecx, QWORD PTR [rdx+3]
	mov	r8, rdi
	mov	BYTE PTR [rbx+r11], 0
	call	LstWrite

; 445  : 
; 446  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN33@SubStrDir
$LN6@SubStrDir:

; 410  :     } else if( sym->state == SYM_UNDEFINED ) {

	mov	eax, DWORD PTR [rax+40]
	test	eax, eax
	jne	SHORT $LN4@SubStrDir

; 411  :         /* it was referenced before being defined. This is
; 412  :          * a bad idea for preprocessor text items, because it
; 413  :          * will require a full second pass!
; 414  :          */
; 415  :         sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rdi
	call	sym_remove_table

; 416  : #if FASTPASS
; 417  :         SkipSavedState();

	call	SkipSavedState

; 418  :         EmitWarn( 2, TEXT_MACRO_USED_PRIOR_TO_DEFINITION, sym->name );

	mov	r8, QWORD PTR [rdi+8]
	mov	edx, 236				; 000000ecH
	mov	ecx, 2
	call	EmitWarn
	jmp	$LN2@SubStrDir
$LN4@SubStrDir:

; 419  : #endif
; 420  :     } else if( sym->state != SYM_TMACRO ) {

	cmp	eax, 10
	je	$LN2@SubStrDir

; 421  :         /* it is defined as something incompatible, get out */
; 422  :         DebugMsg(( "SubStrDir(%s) error, incompatible type\n", sym->name));
; 423  :         return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rdi+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN33@SubStrDir
$LN21@SubStrDir:

; 309  :         DebugMsg(("SubStrDir: error, no text item\n"));
; 310  :         return( TextItemError( &tokenarray[i] ) );

	movzx	ecx, BYTE PTR [rbx+rdx]
	cmp	cl, 9
	jne	SHORT $LN28@SubStrDir
	mov	rax, QWORD PTR [rbx+rdx+8]
	cmp	BYTE PTR [rax], 60			; 0000003cH
	jne	SHORT $LN28@SubStrDir
	mov	ecx, 216				; 000000d8H
	call	EmitError
	jmp	$LN23@SubStrDir
$LN28@SubStrDir:
	cmp	cl, 8
	jne	SHORT $LN26@SubStrDir
	mov	rcx, QWORD PTR [rbx+rdx+8]
	call	SymFind
	test	rax, rax
	je	SHORT $LN25@SubStrDir
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN26@SubStrDir
$LN25@SubStrDir:
	mov	rdx, QWORD PTR [rbx+rdi+8]
	mov	ecx, 102				; 00000066H
	call	EmitErr
	jmp	$LN23@SubStrDir
$LN26@SubStrDir:
	mov	ecx, 144				; 00000090H
	call	EmitError
	jmp	$LN23@SubStrDir
SubStrDir ENDP
_TEXT	ENDS
PUBLIC	SizeStrDir
EXTRN	CreateVariable:NEAR
xdata	SEGMENT
$unwind$SizeStrDir DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$SizeStrDir DD @imagerel($LN15#)
	DD	@imagerel($LN15#+222)
	DD	@imagerel($unwind$SizeStrDir#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
SizeStrDir PROC NEAR

; 454  : {

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H

; 455  :     struct asym *sym;
; 456  :     int sizestr;
; 457  : 
; 458  :     DebugMsg1(("SizeStrDir entry\n"));
; 459  :     DebugCmd( sizstrcnt++ );
; 460  : 
; 461  :     if ( i != 1 ) {

	cmp	ecx, 1
	mov	rbx, rdx
	je	SHORT $LN5@SizeStrDir

; 462  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbx+8]

; 486  : 
; 487  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	EmitErr
$LN5@SizeStrDir:

; 463  :     }
; 464  : #if 0 /* this is checked in ParseLine() */
; 465  :     if ( tokenarray[0].token != T_ID ) {
; 466  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );
; 467  :     }
; 468  : #endif
; 469  :     if ( tokenarray[2].token != T_STRING || tokenarray[2].string_delim != '<' ) {

	cmp	BYTE PTR [rdx+64], 9
	jne	SHORT $LN3@SizeStrDir
	cmp	BYTE PTR [rdx+65], 60			; 0000003cH
	jne	SHORT $LN3@SizeStrDir

; 471  :     }
; 472  :     if ( Token_Count > 3 ) {

	cmp	DWORD PTR ModuleInfo+496, 3
	jle	SHORT $LN2@SizeStrDir

; 473  :         DebugMsg(("SizeStrDir: syntax error, name=%s, Token_Count=%u\n", tokenarray[0].string_ptr, Token_Count));
; 474  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[3].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+104]
	mov	ecx, 209				; 000000d1H

; 486  : 
; 487  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	EmitErr
$LN2@SizeStrDir:

; 475  :     }
; 476  : 
; 477  :     //sizestr = GetLiteralValue( StringBufferEnd, tokenarray[2].string_ptr );
; 478  :     sizestr = tokenarray[2].stringlen;
; 479  : 
; 480  :     if ( sym = CreateVariable( tokenarray[0].string_ptr, sizestr ) ) {

	mov	edx, DWORD PTR [rdx+80]
	mov	rcx, QWORD PTR [rbx+8]
	call	CreateVariable
	test	rax, rax
	je	SHORT $LN1@SizeStrDir

; 481  :         DebugMsg1(("SizeStrDir(%s) exit, value=%u\n", tokenarray[0].string_ptr, sizestr));
; 482  :         LstWrite( LSTTYPE_EQUATE, 0, sym );

	xor	edx, edx
	mov	r8, rax
	lea	ecx, QWORD PTR [rdx+2]
	call	LstWrite

; 483  :         return( NOT_ERROR );

	xor	eax, eax

; 486  : 
; 487  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN1@SizeStrDir:

; 484  :     }
; 485  :     return( ERROR );

	mov	eax, -1

; 486  : 
; 487  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@SizeStrDir:

; 470  :         return( TextItemError( &tokenarray[2] ) );

	movzx	ecx, BYTE PTR [rdx+64]
	cmp	cl, 9
	jne	SHORT $LN11@SizeStrDir
	mov	rax, QWORD PTR [rdx+72]
	cmp	BYTE PTR [rax], 60			; 0000003cH
	jne	SHORT $LN11@SizeStrDir
	mov	ecx, 216				; 000000d8H

; 486  : 
; 487  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	EmitError

; 470  :         return( TextItemError( &tokenarray[2] ) );

$LN11@SizeStrDir:
	cmp	cl, 8
	jne	SHORT $LN9@SizeStrDir
	mov	rcx, QWORD PTR [rdx+72]
	call	SymFind
	test	rax, rax
	je	SHORT $LN8@SizeStrDir
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN9@SizeStrDir
$LN8@SizeStrDir:
	mov	rdx, QWORD PTR [rbx+72]
	mov	ecx, 102				; 00000066H

; 486  : 
; 487  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	EmitErr

; 470  :         return( TextItemError( &tokenarray[2] ) );

$LN9@SizeStrDir:
	mov	ecx, 144				; 00000090H

; 486  : 
; 487  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	EmitError
SizeStrDir ENDP
_TEXT	ENDS
PUBLIC	InStrDir
EXTRN	strstr:NEAR
xdata	SEGMENT
$unwind$InStrDir DD 061601H
	DD	0166416H
	DD	01a3412H
	DD	017010eH
xdata	ENDS
pdata	SEGMENT
$pdata$InStrDir DD @imagerel($LN27#)
	DD	@imagerel($LN27#+220)
	DD	@imagerel($unwind$InStrDir#)
pdata	ENDS
xdata	SEGMENT
$chain$2$InStrDir DD 020821H
	DD	0157408H
	DD	@imagerel($LN27#)
	DD	@imagerel($LN27#+220)
	DD	@imagerel($unwind$InStrDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$InStrDir DD @imagerel($LN27#+220)
	DD	@imagerel($LN27#+261)
	DD	@imagerel($chain$2$InStrDir#)
pdata	ENDS
xdata	SEGMENT
$chain$3$InStrDir DD 020821H
	DD	01b5408H
	DD	@imagerel($LN27#+220)
	DD	@imagerel($LN27#+261)
	DD	@imagerel($chain$2$InStrDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$InStrDir DD @imagerel($LN27#+261)
	DD	@imagerel($LN27#+299)
	DD	@imagerel($chain$3$InStrDir#)
pdata	ENDS
xdata	SEGMENT
$chain$4$InStrDir DD 021H
	DD	@imagerel($LN27#+220)
	DD	@imagerel($LN27#+261)
	DD	@imagerel($chain$2$InStrDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$InStrDir DD @imagerel($LN27#+299)
	DD	@imagerel($LN27#+307)
	DD	@imagerel($chain$4$InStrDir#)
pdata	ENDS
xdata	SEGMENT
$chain$5$InStrDir DD 021H
	DD	@imagerel($LN27#)
	DD	@imagerel($LN27#+220)
	DD	@imagerel($unwind$InStrDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$InStrDir DD @imagerel($LN27#+307)
	DD	@imagerel($LN27#+331)
	DD	@imagerel($chain$5$InStrDir#)
pdata	ENDS
xdata	SEGMENT
$chain$6$InStrDir DD 040021H
	DD	0157400H
	DD	01b5400H
	DD	@imagerel($LN27#)
	DD	@imagerel($LN27#+220)
	DD	@imagerel($unwind$InStrDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$InStrDir DD @imagerel($LN27#+331)
	DD	@imagerel($LN27#+558)
	DD	@imagerel($chain$6$InStrDir#)
pdata	ENDS
xdata	SEGMENT
$chain$7$InStrDir DD 020021H
	DD	0157400H
	DD	@imagerel($LN27#)
	DD	@imagerel($LN27#+220)
	DD	@imagerel($unwind$InStrDir#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$InStrDir DD @imagerel($LN27#+558)
	DD	@imagerel($LN27#+653)
	DD	@imagerel($chain$7$InStrDir#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
opndx$ = 48
i$ = 192
tokenarray$ = 200
InStrDir PROC NEAR

; 496  : {

$LN27:
	mov	DWORD PTR [rsp+8], ecx
	mov	rax, rsp
	sub	rsp, 184				; 000000b8H
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax-8], rsi

; 497  :     struct asym *sym;
; 498  :     int sizestr;
; 499  :     int j;
; 500  :     /* int commas; */
; 501  :     char *src;
; 502  :     char *p;
; 503  :     char *q;
; 504  :     char *string1;
; 505  :     struct expr opndx;
; 506  :     int start = 1;

	mov	esi, 1

; 507  :     int strpos;
; 508  : 
; 509  :     DebugMsg1(("InStrDir entry\n"));
; 510  :     DebugCmd( instrcnt++ );
; 511  : 
; 512  :     if ( i != 1) {

	cmp	ecx, esi
	mov	rbx, rdx
	je	SHORT $LN16@InStrDir

; 513  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbx+8]
	call	EmitErr
	jmp	$LN17@InStrDir
$LN16@InStrDir:

; 514  :     }
; 515  : #if 0 /* this is checked in ParseLine() */
; 516  :     if ( tokenarray[0].token != T_ID ) {
; 517  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );
; 518  :     }
; 519  : #endif
; 520  : 
; 521  :     i++; /* go past INSTR */

	mov	ecx, 2
	mov	DWORD PTR i$[rsp], ecx

; 522  : 
; 523  :     if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	cmp	BYTE PTR [rdx+64], 9
	jne	SHORT $LN14@InStrDir
	cmp	BYTE PTR [rdx+65], 60			; 0000003cH
	je	$LN15@InStrDir
$LN14@InStrDir:

; 524  :         /* v2.11: flag NOUNDEF added - no forward reference accepted */
; 525  :         if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, EXPF_NOUNDEF ) == ERROR )

	mov	r8d, DWORD PTR ModuleInfo+496
	mov	BYTE PTR [rsp+32], cl
	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN13@InStrDir

; 526  :             return( ERROR );

	jmp	$LN17@InStrDir
$LN13@InStrDir:

; 527  :         if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN12@InStrDir

; 528  :             return( EmitError( CONSTANT_EXPECTED ) );

	mov	ecx, 65					; 00000041H
	call	EmitError
	jmp	$LN17@InStrDir
$LN12@InStrDir:

; 529  :         }
; 530  :         start = opndx.value;

	mov	esi, DWORD PTR opndx$[rsp]

; 531  :         if ( start <= 0 ) {

	test	esi, esi
	jg	SHORT $LN11@InStrDir

; 532  :             /* v2.05: don't change the value. if it's invalid, the result
; 533  :              * is to be 0. Emit a level 3 warning instead.
; 534  :              */
; 535  :             //start = 1;
; 536  :             EmitWarn( 3, POSITIVE_VALUE_EXPECTED );

	mov	edx, 175				; 000000afH
	mov	ecx, 3
	call	EmitWarn
$LN11@InStrDir:

; 537  :         }
; 538  :         if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, rcx
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbx], 44			; 0000002cH
	je	SHORT $LN10@InStrDir

; 539  :             return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rbx+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	SHORT $LN17@InStrDir
$LN10@InStrDir:

; 540  :         }
; 541  :         i++; /* skip comma */

	inc	ecx
	mov	DWORD PTR i$[rsp], ecx
$LN15@InStrDir:
	mov	QWORD PTR [rsp+168], rdi

; 542  :     }
; 543  : 
; 544  :     if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rdi, ecx
	shl	rdi, 5
	cmp	BYTE PTR [rdi+rbx], 9
	jne	$LN8@InStrDir
	cmp	BYTE PTR [rdi+rbx+1], 60		; 0000003cH
	jne	$LN8@InStrDir

; 546  :     }
; 547  : 
; 548  :     /* to compare the strings, the "visible" format is needed, since
; 549  :      * the possible '!' operators inside the strings is optional and
; 550  :      * must be ignored.
; 551  :      */
; 552  :     //src = StringBufferEnd;
; 553  :     //sizestr = GetLiteralValue( src, tokenarray[i].string_ptr );
; 554  :     src = tokenarray[i].string_ptr;
; 555  :     sizestr = tokenarray[i].stringlen;

	mov	r8d, DWORD PTR [rdi+rbx+16]
	mov	QWORD PTR [rsp+216], rbp
	mov	rbp, QWORD PTR [rdi+rbx+8]

; 556  :     DebugMsg1(("InStrDir: first string >%s< \n", src ));
; 557  : 
; 558  :     if ( start > sizestr ) {

	cmp	esi, r8d
	jle	SHORT $LN7@InStrDir

; 559  :         return( EmitErr( INDEX_VALUE_PAST_END_OF_STRING, start ) );

	mov	edx, esi
	mov	ecx, 206				; 000000ceH
	call	EmitErr
$LN26@InStrDir:
	mov	rbp, QWORD PTR [rsp+216]
$LN25@InStrDir:
	mov	rdi, QWORD PTR [rsp+168]
$LN17@InStrDir:
	mov	rsi, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [rsp+208]

; 594  : }

	add	rsp, 184				; 000000b8H
	ret	0
$LN7@InStrDir:

; 560  :     }
; 561  :     p = src + start - 1;
; 562  : 
; 563  :     i++;

	inc	ecx

; 564  :     if ( tokenarray[i].token != T_COMMA ) {

	movsxd	rdx, ecx
	mov	DWORD PTR i$[rsp], ecx
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbx], 44			; 0000002cH
	je	SHORT $LN6@InStrDir

; 565  :         return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rbx+24]
	mov	ecx, 39					; 00000027H
	call	EmitErr
	jmp	SHORT $LN26@InStrDir
$LN6@InStrDir:

; 566  :     }
; 567  :     i++;

	inc	ecx

; 568  : 
; 569  :     if ( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rdx, ecx
	mov	DWORD PTR i$[rsp], ecx
	shl	rdx, 5
	add	rdx, rbx
	cmp	BYTE PTR [rdx], 9
	jne	$LN4@InStrDir
	cmp	BYTE PTR [rdx+1], 60			; 0000003cH
	jne	$LN4@InStrDir

; 571  :     }
; 572  :     //q = GetAlignedPointer( src, sizestr );
; 573  :     //j = GetLiteralValue( q, tokenarray[i].string_ptr );
; 574  :     q = tokenarray[i].string_ptr;

	mov	r9, QWORD PTR [rdx+8]

; 575  :     j = tokenarray[i].stringlen;

	mov	eax, DWORD PTR [rdx+16]

; 576  :     DebugMsg1(("InStrDir: second string >%s< \n", q ));
; 577  :     i++;

	inc	ecx

; 578  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, ecx
	mov	DWORD PTR i$[rsp], ecx
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbx], 0
	je	SHORT $LN3@InStrDir

; 579  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+rbx+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN26@InStrDir
$LN3@InStrDir:

; 580  :     }
; 581  : 
; 582  :     strpos = 0;

	xor	edi, edi

; 583  :     /* v2.05: check for start > 0 added */
; 584  :     /* v2.08: check for j > 0 added */
; 585  :     if ( ( start > 0 ) && ( sizestr >= j ) && j && ( string1 = strstr( p, q ) ))

	test	esi, esi
	jle	SHORT $LN2@InStrDir
	cmp	r8d, eax
	jl	SHORT $LN2@InStrDir
	test	eax, eax
	je	SHORT $LN2@InStrDir
	movsxd	rax, esi
	mov	rdx, r9
	lea	rcx, QWORD PTR [rax+rbp-1]
	call	strstr
	test	rax, rax
	je	SHORT $LN2@InStrDir

; 586  :         strpos = string1 - src + 1;

	mov	edi, eax
	sub	edi, ebp
	inc	edi
$LN2@InStrDir:

; 587  : 
; 588  :     if ( sym = CreateVariable( tokenarray[0].string_ptr, strpos ) ) {

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, edi
	call	CreateVariable
	test	rax, rax
	je	SHORT $LN1@InStrDir

; 589  :         DebugMsg1(("InStrDir(%s) exit, value=%u\n", tokenarray[0].string_ptr, strpos));
; 590  :         LstWrite( LSTTYPE_EQUATE, 0, sym );

	xor	edx, edx
	mov	r8, rax
	lea	ecx, QWORD PTR [rdx+2]
	call	LstWrite

; 591  :         return ( NOT_ERROR );

	xor	eax, eax
	jmp	$LN26@InStrDir
$LN1@InStrDir:

; 592  :     }
; 593  :     return( ERROR );

	mov	eax, -1
	jmp	$LN26@InStrDir
$LN4@InStrDir:

; 570  :         return( TextItemError( &tokenarray[i] ) );

	mov	rcx, rdx
	call	TextItemError
	jmp	$LN26@InStrDir
$LN8@InStrDir:

; 545  :         return( TextItemError( &tokenarray[i] ) );

	movzx	ecx, BYTE PTR [rdi+rbx]
	cmp	cl, 9
	jne	SHORT $LN22@InStrDir
	mov	rax, QWORD PTR [rdi+rbx+8]
	cmp	BYTE PTR [rax], 60			; 0000003cH
	jne	SHORT $LN22@InStrDir
	mov	ecx, 216				; 000000d8H
	call	EmitError
	jmp	$LN25@InStrDir
$LN22@InStrDir:
	cmp	cl, 8
	jne	SHORT $LN20@InStrDir
	mov	rcx, QWORD PTR [rdi+rbx+8]
	call	SymFind
	test	rax, rax
	je	SHORT $LN19@InStrDir
	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN20@InStrDir
$LN19@InStrDir:
	mov	rdx, QWORD PTR [rdi+rbx+8]
	mov	ecx, 102				; 00000066H
	call	EmitErr
	jmp	$LN25@InStrDir
$LN20@InStrDir:
	mov	ecx, 144				; 00000090H
	call	EmitError
	jmp	$LN25@InStrDir
InStrDir ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$CatStrFunc DD 071b01H
	DD	05c41bH
	DD	076416H
	DD	085411H
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$CatStrFunc DD @imagerel(CatStrFunc#)
	DD	@imagerel(CatStrFunc#+38)
	DD	@imagerel($unwind$CatStrFunc#)
pdata	ENDS
xdata	SEGMENT
$chain$4$CatStrFunc DD 040a21H
	DD	06740aH
	DD	0d3405H
	DD	@imagerel(CatStrFunc#)
	DD	@imagerel(CatStrFunc#+38)
	DD	@imagerel($unwind$CatStrFunc#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$CatStrFunc DD @imagerel(CatStrFunc#+38)
	DD	@imagerel(CatStrFunc#+132)
	DD	@imagerel($chain$4$CatStrFunc#)
pdata	ENDS
xdata	SEGMENT
$chain$5$CatStrFunc DD 021H
	DD	@imagerel(CatStrFunc#)
	DD	@imagerel(CatStrFunc#+38)
	DD	@imagerel($unwind$CatStrFunc#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$CatStrFunc DD @imagerel(CatStrFunc#+132)
	DD	@imagerel(CatStrFunc#+157)
	DD	@imagerel($chain$5$CatStrFunc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
mi$ = 80
buffer$ = 88
tokenarray$ = 96
CatStrFunc PROC NEAR

; 602  : {

	sub	rsp, 72					; 00000048H

; 603  : #ifdef DEBUG_OUT
; 604  :     int cnt = 0;
; 605  : #endif
; 606  :     int i;
; 607  :     char *p;
; 608  : 
; 609  :     DebugMsg1(("@CatStr( %s )\n", mi->parm_array[0] ? mi->parm_array[0] : "NULL" ));
; 610  : 
; 611  :     for ( p = mi->parm_array[0]; mi->parmcnt; mi->parmcnt-- ) {

	cmp	DWORD PTR [rcx+40], 0
	mov	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+64], rbp
	mov	QWORD PTR [rsp+56], rsi
	mov	QWORD PTR [rsp+40], r12
	mov	r12, QWORD PTR [rax]
	mov	rsi, rdx
	mov	rbp, rcx
	je	SHORT $LN8@CatStrFunc
	mov	QWORD PTR [rsp+104], rbx
	mov	QWORD PTR [rsp+48], rdi
$LL3@CatStrFunc:

; 612  :         DebugMsg1(("@CatStr.%u: >%s<\n", cnt++, p ));
; 613  :         i = strlen( p );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, r12
	repne scasb

; 614  :         memcpy( buffer, p, i );

	mov	rdx, r12
	not	rcx
	dec	rcx
	movsxd	rbx, ecx
	mov	rdi, rcx
	mov	rcx, rsi
	mov	r8, rbx
	call	memcpy
	add	DWORD PTR [rbp+40], -1			; ffffffffH

; 615  :         p = GetAlignedPointer( p, i );

	lea	eax, DWORD PTR [rdi+1]
	cdqe

; 616  :         buffer += i;

	add	rsi, rbx
	add	rax, 7
	and	rax, -8
	add	r12, rax
	cmp	DWORD PTR [rbp+40], 0
	jne	SHORT $LL3@CatStrFunc
	mov	rdi, QWORD PTR [rsp+48]
	mov	rbx, QWORD PTR [rsp+104]

; 617  :     }
; 618  :     *buffer = NULLC;

	mov	BYTE PTR [rsi], 0

; 619  :     return( NOT_ERROR );

	jmp	SHORT $LN9@CatStrFunc
$LN8@CatStrFunc:

; 617  :     }
; 618  :     *buffer = NULLC;

	mov	BYTE PTR [rdx], 0
$LN9@CatStrFunc:
	mov	r12, QWORD PTR [rsp+40]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]

; 619  :     return( NOT_ERROR );

	xor	eax, eax

; 620  : }

	add	rsp, 72					; 00000048H
	ret	0
CatStrFunc ENDP
_TEXT	ENDS
EXTRN	Tokenize:NEAR
xdata	SEGMENT
$unwind$GetNumber DD 081601H
	DD	01b7416H
	DD	01a6412H
	DD	019340eH
	DD	017010aH
xdata	ENDS
pdata	SEGMENT
$pdata$GetNumber DD @imagerel(GetNumber#)
	DD	@imagerel(GetNumber#+175)
	DD	@imagerel($unwind$GetNumber#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
opndx$ = 64
string$ = 192
pi$ = 200
tokenarray$ = 208
GetNumber PROC NEAR

; 629  : {

	mov	rax, rsp
	sub	rsp, 184				; 000000b8H
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	rdi, rdx

; 630  :     struct expr opndx;
; 631  :     int i;
; 632  :     int last;
; 633  : 
; 634  :     last = Tokenize( string, Token_Count+1, tokenarray, TOK_RESCAN );

	mov	edx, DWORD PTR ModuleInfo+496
	mov	r9d, 1
	inc	edx
	mov	rbx, r8
	mov	rsi, rcx
	call	Tokenize

; 635  :     i = Token_Count+1;

	mov	r9d, DWORD PTR ModuleInfo+496

; 636  :     if( EvalOperand( &i, tokenarray, last, &opndx, EXPF_NOUNDEF ) == ERROR ) {

	lea	rcx, QWORD PTR i$[rsp]
	inc	r9d
	mov	r8d, eax
	mov	rdx, rbx
	mov	DWORD PTR i$[rsp], r9d
	lea	r9, QWORD PTR opndx$[rsp]
	mov	BYTE PTR [rsp+32], 2
	call	EvalOperand
	cmp	eax, -1
	jne	SHORT $LN3@GetNumber

; 637  :         return( ERROR );

	jmp	SHORT $LN4@GetNumber
$LN3@GetNumber:

; 638  :     }
; 639  :     /* v2.11: string constants are accepted ( although hardly useful ) */
; 640  :     //if( opndx.kind != EXPR_CONST || opndx.quoted_string != NULL || tokenarray[i].token != T_FINAL ) {
; 641  :     if( opndx.kind != EXPR_CONST || tokenarray[i].token != T_FINAL ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	jne	SHORT $LN1@GetNumber
	movsxd	rax, DWORD PTR i$[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+rbx], 0
	jne	SHORT $LN1@GetNumber

; 643  :     }
; 644  :     *pi = opndx.value;

	mov	eax, DWORD PTR opndx$[rsp]
	mov	DWORD PTR [rdi], eax

; 645  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN4@GetNumber
$LN1@GetNumber:

; 642  :         return( EmitErr( SYNTAX_ERROR_EX, string ) );

	mov	rdx, rsi
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN4@GetNumber:
	mov	rdi, QWORD PTR [rsp+216]
	mov	rsi, QWORD PTR [rsp+208]
	mov	rbx, QWORD PTR [rsp+200]

; 646  : }

	add	rsp, 184				; 000000b8H
	ret	0
GetNumber ENDP
_TEXT	ENDS
EXTRN	myltoa:NEAR
xdata	SEGMENT
$unwind$InStrFunc DD 0c2501H
	DD	016c425H
	DD	01b741aH
	DD	01a6416H
	DD	0195412H
	DD	018340eH
	DD	017010aH
xdata	ENDS
pdata	SEGMENT
$pdata$InStrFunc DD @imagerel(InStrFunc#)
	DD	@imagerel(InStrFunc#+347)
	DD	@imagerel($unwind$InStrFunc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$6097 = 48
opndx$6096 = 64
mi$ = 192
buffer$ = 200
tokenarray$ = 208
InStrFunc PROC NEAR

; 654  : {

	mov	rax, rsp
	sub	rsp, 184				; 000000b8H
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi

; 655  :     int pos = 1;
; 656  :     char *p;
; 657  :     uint_32 found;
; 658  : 
; 659  :     DebugMsg1(("@InStr( %s, %s, %s)\n",
; 660  :               mi->parm_array[0] ? mi->parm_array[0] : "",
; 661  :               mi->parm_array[1] ? mi->parm_array[1] : "",
; 662  :               mi->parm_array[2] ? mi->parm_array[2] : "" ));
; 663  : 
; 664  :     /* init buffer with "0" */
; 665  :     *buffer = '0';

	mov	BYTE PTR [rdx], 48			; 00000030H

; 666  :     *(buffer+1) = NULLC;

	mov	BYTE PTR [rdx+1], 0
	mov	QWORD PTR [rax-8], r12

; 667  : 
; 668  :     if ( mi->parm_array[0] ) {

	mov	rax, QWORD PTR [rcx+24]
	mov	rdi, r8
	cmp	QWORD PTR [rax], 0
	mov	rbp, rdx
	mov	rsi, rcx
	mov	ebx, 1
	je	SHORT $LN4@InStrFunc

; 669  :         if ( GetNumber( mi->parm_array[0], &pos, tokenarray ) == ERROR )

	mov	r12, QWORD PTR [rax]
	mov	edx, DWORD PTR ModuleInfo+496
	mov	r9d, ebx
	inc	edx
	mov	rcx, r12
	call	Tokenize
	mov	ecx, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$6096[rsp]
	inc	ecx
	mov	r8d, eax
	mov	rdx, rdi
	mov	DWORD PTR i$6097[rsp], ecx
	lea	rcx, QWORD PTR i$6097[rsp]
	mov	BYTE PTR [rsp+32], 2
	call	EvalOperand
	cmp	eax, -1
	je	SHORT $LN14@InStrFunc
	cmp	DWORD PTR opndx$6096[rsp+60], 0
	jne	SHORT $LN9@InStrFunc
	movsxd	rax, DWORD PTR i$6097[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 0
	jne	SHORT $LN9@InStrFunc
	mov	eax, DWORD PTR opndx$6096[rsp]

; 671  :         if ( pos == 0 ) {

	test	eax, eax
	cmove	eax, ebx
	mov	ebx, eax
$LN4@InStrFunc:

; 672  :             /* adjust index 0. Masm also accepts 0 (and any negative index),
; 673  :              * but the result will always be 0 then */
; 674  :             DebugMsg(( "@InStr(): index value is 0, changed to 1\n" ));
; 675  :             pos++;
; 676  :         }
; 677  :     }
; 678  : 
; 679  :     if ( pos > strlen( mi->parm_array[1] ) ) {

	mov	rdx, QWORD PTR [rsi+24]
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, QWORD PTR [rdx+8]
	movsxd	r8, ebx
	repne scasb
	not	rcx
	dec	rcx
	cmp	r8, rcx
	jbe	SHORT $LN3@InStrFunc

; 680  :         return( EmitErr( INDEX_VALUE_PAST_END_OF_STRING, pos ) );

	mov	edx, ebx
	mov	ecx, 206				; 000000ceH
	call	EmitErr
	jmp	SHORT $LN7@InStrFunc

; 669  :         if ( GetNumber( mi->parm_array[0], &pos, tokenarray ) == ERROR )

$LN9@InStrFunc:
	mov	rdx, r12
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	cmp	eax, -1
	jne	SHORT $LN4@InStrFunc
$LN14@InStrFunc:

; 670  :             return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN7@InStrFunc
$LN3@InStrFunc:

; 681  :     }
; 682  :     /* v2.08: if() added, empty searchstr is to return 0 */
; 683  :     if ( *(mi->parm_array[2]) != NULLC ) {

	mov	rax, QWORD PTR [rdx+16]
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN1@InStrFunc

; 684  :         p = strstr( mi->parm_array[1] + pos - 1, mi->parm_array[2] );

	mov	rax, QWORD PTR [rdx+8]
	mov	rdx, QWORD PTR [rdx+16]
	lea	rcx, QWORD PTR [rax+r8-1]
	call	strstr

; 685  :         if ( p ) {

	test	rax, rax
	je	SHORT $LN1@InStrFunc

; 686  :             found = p - mi->parm_array[1] + 1;
; 687  :             myltoa( found, buffer, ModuleInfo.radix, FALSE, TRUE );

	mov	rcx, QWORD PTR [rsi+24]
	movzx	r8d, BYTE PTR ModuleInfo+396
	xor	r9d, r9d
	sub	eax, DWORD PTR [rcx+8]
	mov	rdx, rbp
	mov	BYTE PTR [rsp+32], 1
	lea	ecx, DWORD PTR [rax+1]
	call	myltoa
$LN1@InStrFunc:

; 688  :         }
; 689  :     }
; 690  : 
; 691  :     DebugMsg1(( "@InStr()=>%s<\n", buffer ));
; 692  : 
; 693  :     return( NOT_ERROR );

	xor	eax, eax
$LN7@InStrFunc:
	mov	r12, QWORD PTR [rsp+176]
	mov	rdi, QWORD PTR [rsp+216]
	mov	rsi, QWORD PTR [rsp+208]
	mov	rbp, QWORD PTR [rsp+200]
	mov	rbx, QWORD PTR [rsp+192]

; 694  : }

	add	rsp, 184				; 000000b8H
	ret	0
InStrFunc ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SizeStrFunc DD 020601H
	DD	070025206H
xdata	ENDS
pdata	SEGMENT
$pdata$SizeStrFunc DD @imagerel(SizeStrFunc#)
	DD	@imagerel(SizeStrFunc#+77)
	DD	@imagerel($unwind$SizeStrFunc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
mi$ = 64
buffer$ = 72
tokenarray$ = 80
SizeStrFunc PROC NEAR

; 702  : {

	push	rdi
	sub	rsp, 48					; 00000030H

; 703  :     DebugMsg1(("@SizeStr(%s)\n", mi->parm_array[0] ? mi->parm_array[0] : "" ));
; 704  :     if ( mi->parm_array[0] )

	mov	rdi, QWORD PTR [rcx+24]

; 705  :         myltoa( strlen( mi->parm_array[0] ), buffer, ModuleInfo. radix, FALSE, TRUE );

	xor	eax, eax
	cmp	QWORD PTR [rdi], rax
	je	SHORT $LN2@SizeStrFun
	mov	rdi, QWORD PTR [rdi]
	movzx	r8d, BYTE PTR ModuleInfo+396
	mov	rcx, -1
	repne scasb
	xor	r9d, r9d
	mov	BYTE PTR [rsp+32], 1
	not	rcx
	dec	rcx
	call	myltoa

; 709  :     }
; 710  :     return( NOT_ERROR );

	xor	eax, eax

; 711  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN2@SizeStrFun:

; 706  :     else {
; 707  :         buffer[0] = '0';

	mov	BYTE PTR [rdx], 48			; 00000030H

; 708  :         buffer[1] = NULLC;

	mov	BYTE PTR [rdx+1], 0

; 711  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
SizeStrFunc ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$SubStrFunc DD 0e2201H
	DD	017d422H
	DD	018c41eH
	DD	01d741aH
	DD	01c6416H
	DD	01b5412H
	DD	01a340eH
	DD	019010aH
xdata	ENDS
pdata	SEGMENT
$pdata$SubStrFunc DD @imagerel(SubStrFunc#)
	DD	@imagerel(SubStrFunc#+506)
	DD	@imagerel($unwind$SubStrFunc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$6139 = 48
i$6128 = 48
sizereq$5844 = 48
pos$ = 48
opndx$6138 = 64
opndx$6127 = 64
mi$ = 208
buffer$ = 216
tokenarray$ = 224
SubStrFunc PROC NEAR

; 719  : {

	mov	rax, rsp
	sub	rsp, 200				; 000000c8H
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	QWORD PTR [rax-8], r12
	mov	QWORD PTR [rax-16], r13

; 720  :     int pos;
; 721  :     int size;
; 722  :     char *src = mi->parm_array[0];

	mov	rax, QWORD PTR [rcx+24]
	mov	r12, rdx

; 723  : 
; 724  :     DebugMsg1(("@SubStr( %s, %s, %s)\n",
; 725  :               src ? src : "",
; 726  :               mi->parm_array[1] ? mi->parm_array[1] : "",
; 727  :               mi->parm_array[2] ? mi->parm_array[2] : "" ));
; 728  : 
; 729  :     if ( GetNumber( mi->parm_array[1], &pos, tokenarray ) == ERROR )

	mov	edx, DWORD PTR ModuleInfo+496
	mov	rdi, QWORD PTR [rax+8]
	mov	r13, QWORD PTR [rax]
	mov	rbp, rcx
	inc	edx
	mov	r9d, 1
	mov	rcx, rdi
	mov	rsi, r8
	call	Tokenize
	mov	edx, DWORD PTR ModuleInfo+496
	inc	edx
	lea	r9, QWORD PTR opndx$6127[rsp]
	lea	rcx, QWORD PTR i$6128[rsp]
	mov	DWORD PTR i$6128[rsp], edx
	mov	r8d, eax
	mov	rdx, rsi
	mov	BYTE PTR [rsp+32], 2
	call	EvalOperand
	cmp	eax, -1
	je	$LN22@SubStrFunc
	cmp	DWORD PTR opndx$6127[rsp+60], 0
	jne	SHORT $LN11@SubStrFunc
	movsxd	rax, DWORD PTR i$6128[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 0
	jne	SHORT $LN11@SubStrFunc
	mov	ebx, DWORD PTR opndx$6127[rsp]
	jmp	SHORT $LN8@SubStrFunc
$LN11@SubStrFunc:
	mov	rdx, rdi
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	cmp	eax, -1

; 730  :         return( ERROR );

	je	$LN22@SubStrFunc
	mov	ebx, DWORD PTR pos$[rsp]
$LN8@SubStrFunc:

; 731  : 
; 732  :     if ( pos <= 0 ) {

	test	ebx, ebx
	jg	SHORT $LN7@SubStrFunc

; 733  :         /* Masm doesn't check if index is < 0;
; 734  :          * might cause an "internal assembler error".
; 735  :          * v2.09: negative index no longer silently changed to 1.
; 736  :          */
; 737  :         if ( pos ) {

	test	ebx, ebx

; 738  :             return( EmitErr( INDEX_VALUE_PAST_END_OF_STRING, pos ) );

	jne	SHORT $LN25@SubStrFunc

; 739  :         }
; 740  :         DebugMsg(( "@SubStr(): index value 0 changed to 1\n", pos ));
; 741  :         pos = 1;

	mov	ebx, 1
$LN7@SubStrFunc:

; 742  :     }
; 743  : 
; 744  :     size = strlen( src );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, r13
	repne scasb
	not	rcx
	dec	rcx

; 745  :     if ( pos > size ) {

	cmp	ebx, ecx
	mov	rdi, rcx
	jle	SHORT $LN5@SubStrFunc
$LN25@SubStrFunc:

; 746  :         return( EmitErr( INDEX_VALUE_PAST_END_OF_STRING, pos ) );

	mov	edx, ebx
	mov	ecx, 206				; 000000ceH
	call	EmitErr
	jmp	$LN9@SubStrFunc
$LN5@SubStrFunc:

; 747  :     }
; 748  : 
; 749  :     size = size - pos + 1;

	mov	eax, 1
	sub	eax, ebx
	add	edi, eax

; 750  : 
; 751  :     if ( mi->parm_array[2] ) {

	mov	rax, QWORD PTR [rbp+24]
	cmp	QWORD PTR [rax+16], 0
	je	$LN4@SubStrFunc

; 752  :         int sizereq;
; 753  :         if ( GetNumber( mi->parm_array[2], &sizereq, tokenarray ) == ERROR )

	mov	rbp, QWORD PTR [rax+16]
	mov	edx, DWORD PTR ModuleInfo+496
	mov	r9d, 1
	inc	edx
	mov	rcx, rbp
	mov	r8, rsi
	call	Tokenize
	mov	ecx, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$6138[rsp]
	inc	ecx
	mov	r8d, eax
	mov	rdx, rsi
	mov	DWORD PTR i$6139[rsp], ecx
	lea	rcx, QWORD PTR i$6139[rsp]
	mov	BYTE PTR [rsp+32], 2
	call	EvalOperand
	cmp	eax, -1
	je	SHORT $LN22@SubStrFunc
	cmp	DWORD PTR opndx$6138[rsp+60], 0
	jne	SHORT $LN16@SubStrFunc
	movsxd	rax, DWORD PTR i$6139[rsp]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 0
	jne	SHORT $LN16@SubStrFunc
	mov	eax, DWORD PTR opndx$6138[rsp]
	jmp	SHORT $LN3@SubStrFunc
$LN16@SubStrFunc:
	mov	rdx, rbp
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	cmp	eax, -1
	jne	SHORT $LN24@SubStrFunc
$LN22@SubStrFunc:

; 754  :             return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN9@SubStrFunc
$LN24@SubStrFunc:
	mov	eax, DWORD PTR sizereq$5844[rsp]
$LN3@SubStrFunc:

; 755  :         if ( sizereq < 0 ) {

	test	eax, eax
	jns	SHORT $LN2@SubStrFunc

; 756  :             return( EmitError( COUNT_MUST_BE_POSITIVE_OR_ZERO ) );

	mov	ecx, 208				; 000000d0H
	call	EmitError
	jmp	SHORT $LN9@SubStrFunc
$LN2@SubStrFunc:

; 757  :         }
; 758  :         if ( sizereq > size ) {

	cmp	eax, edi
	jle	SHORT $LN1@SubStrFunc

; 759  :             return( EmitError( COUNT_VALUE_TOO_LARGE ) );

	mov	ecx, 207				; 000000cfH
	call	EmitError
	jmp	SHORT $LN9@SubStrFunc
$LN1@SubStrFunc:

; 760  :         }
; 761  :         size = sizereq;

	mov	edi, eax
$LN4@SubStrFunc:

; 762  :     }
; 763  : #if 1
; 764  :     memcpy( buffer, src + pos - 1, size );

	movsxd	rax, ebx
	movsxd	rdi, edi
	mov	rcx, r12
	lea	rdx, QWORD PTR [rax+r13-1]
	mov	r8, rdi
	call	memcpy

; 765  :     *(buffer+size) = NULLC;

	mov	BYTE PTR [rdi+r12], 0

; 766  : #else
; 767  :     for( src += pos - 1; size; size-- )
; 768  :         *buffer++ = *src++;
; 769  :     *buffer = NULLC;
; 770  : #endif
; 771  :     return( NOT_ERROR );

	xor	eax, eax
$LN9@SubStrFunc:
	mov	r13, QWORD PTR [rsp+184]
	mov	r12, QWORD PTR [rsp+192]
	mov	rdi, QWORD PTR [rsp+232]
	mov	rsi, QWORD PTR [rsp+224]
	mov	rbp, QWORD PTR [rsp+216]
	mov	rbx, QWORD PTR [rsp+208]

; 772  : }

	add	rsp, 200				; 000000c8H
	ret	0
SubStrFunc ENDP
_TEXT	ENDS
PUBLIC	StringInit
EXTRN	CreateMacro:NEAR
xdata	SEGMENT
$unwind$StringInit DD 051501H
	DD	097415H
	DD	083410H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$StringInit DD @imagerel($LN19#)
	DD	@imagerel($LN19#+477)
	DD	@imagerel($unwind$StringInit#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
StringInit PROC NEAR

; 779  : {

$LN19:
	sub	rsp, 40					; 00000028H

; 780  :     int i;
; 781  :     struct dsym *macro;
; 782  : 
; 783  :     DebugMsg(( "StringInit() enter\n" ));
; 784  : 
; 785  : #ifdef DEBUG_OUT
; 786  :     catstrcnt = 0;
; 787  :     substrcnt = 0;
; 788  :     sizstrcnt = 0;
; 789  :     instrcnt = 0;
; 790  :     equcnt = 0;
; 791  : #endif
; 792  : 
; 793  :     /* add @CatStr() macro func */
; 794  : 
; 795  :     macro = CreateMacro( "@CatStr" );

	lea	rcx, OFFSET FLAT:$SG5852
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	call	CreateMacro
	mov	rbx, rax

; 796  :     macro->sym.isdefined = TRUE;
; 797  :     macro->sym.predefined = TRUE;

	or	BYTE PTR [rax+48], 34			; 00000022H

; 798  :     macro->sym.func_ptr = CatStrFunc;

	lea	rax, OFFSET FLAT:CatStrFunc

; 799  :     macro->sym.isfunc = TRUE;
; 800  :     /* v2.08: @CatStr() changed to VARARG */
; 801  :     macro->sym.mac_vararg = TRUE;
; 802  :     macro->e.macroinfo->parmcnt = 1;

	mov	rcx, QWORD PTR [rbx+104]
	or	BYTE PTR [rbx+52], 3
	mov	QWORD PTR [rbx+16], rax
	mov	WORD PTR [rcx], 1

; 803  :     macro->e.macroinfo->parmlist = LclAlloc( sizeof( struct mparm_list ) * 1 );

	mov	ecx, 16
	call	LclAlloc
	mov	rcx, QWORD PTR [rbx+104]

; 804  :     macro->e.macroinfo->parmlist[0].deflt = NULL;

	xor	edi, edi
	mov	QWORD PTR [rcx+8], rax
	mov	rax, QWORD PTR [rbx+104]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx], rdi

; 805  :     macro->e.macroinfo->parmlist[0].required = FALSE;

	mov	rax, QWORD PTR [rbx+104]
	mov	rcx, QWORD PTR [rax+8]
	and	BYTE PTR [rcx+8], 254			; 000000feH

; 806  : 
; 807  :     /* add @InStr() macro func */
; 808  : 
; 809  :     macro = CreateMacro( "@InStr" );

	lea	rcx, OFFSET FLAT:$SG5855
	call	CreateMacro
	mov	rbx, rax

; 810  :     macro->sym.isdefined = TRUE;
; 811  :     macro->sym.predefined = TRUE;

	or	BYTE PTR [rax+48], 34			; 00000022H

; 812  :     macro->sym.func_ptr = InStrFunc;

	lea	rax, OFFSET FLAT:InStrFunc

; 813  :     macro->sym.isfunc = TRUE;
; 814  :     macro->e.macroinfo->parmcnt = 3;

	mov	rcx, QWORD PTR [rbx+104]
	or	BYTE PTR [rbx+52], 2
	mov	QWORD PTR [rbx+16], rax
	mov	WORD PTR [rcx], 3

; 815  :     macro->e.macroinfo->autoexp = 1; /* param 1 (pos) is expanded */

	mov	rcx, QWORD PTR [rbx+104]
	mov	WORD PTR [rcx+2], 1

; 816  :     macro->e.macroinfo->parmlist = LclAlloc(sizeof( struct mparm_list) * 3);

	lea	ecx, QWORD PTR [rdi+48]
	call	LclAlloc
	mov	rcx, QWORD PTR [rbx+104]
	mov	QWORD PTR [rcx+8], rax

; 817  :     for (i = 0; i < 3; i++) {
; 818  :         macro->e.macroinfo->parmlist[i].deflt = NULL;

	mov	rax, QWORD PTR [rbx+104]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx], rdi

; 819  :         //macro->e.macroinfo->parmlist[i].label = parmnames[i];
; 820  :         macro->e.macroinfo->parmlist[i].required = (i != 0);

	mov	rax, QWORD PTR [rbx+104]
	mov	rcx, QWORD PTR [rax+8]
	and	BYTE PTR [rcx+8], 254			; 000000feH
	mov	rax, QWORD PTR [rbx+104]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+16], rdi
	mov	rax, QWORD PTR [rbx+104]
	mov	rcx, QWORD PTR [rax+8]
	or	BYTE PTR [rcx+24], 1
	mov	rax, QWORD PTR [rbx+104]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+32], rdi
	mov	rax, QWORD PTR [rbx+104]

; 821  :     }
; 822  : 
; 823  :     /* add @SizeStr() macro func */
; 824  : 
; 825  :     macro = CreateMacro( "@SizeStr" );

	lea	rcx, OFFSET FLAT:$SG5861
	mov	rdx, QWORD PTR [rax+8]
	or	BYTE PTR [rdx+40], 1
	call	CreateMacro

; 826  :     macro->sym.isdefined = TRUE;
; 827  :     macro->sym.predefined = TRUE;
; 828  :     macro->sym.func_ptr = SizeStrFunc;
; 829  :     macro->sym.isfunc = TRUE;
; 830  :     macro->e.macroinfo->parmcnt = 1;
; 831  :     macro->e.macroinfo->parmlist = LclAlloc(sizeof( struct mparm_list));

	lea	ecx, QWORD PTR [rdi+16]
	or	BYTE PTR [rax+48], 34			; 00000022H
	mov	rbx, rax
	lea	rax, OFFSET FLAT:SizeStrFunc
	mov	rdx, QWORD PTR [rbx+104]
	or	BYTE PTR [rbx+52], 2
	mov	QWORD PTR [rbx+16], rax
	mov	WORD PTR [rdx], 1
	call	LclAlloc
	mov	rcx, QWORD PTR [rbx+104]
	mov	QWORD PTR [rcx+8], rax

; 832  :     macro->e.macroinfo->parmlist[0].deflt = NULL;

	mov	rax, QWORD PTR [rbx+104]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx], rdi

; 833  :     //macro->e.macroinfo->parmlist[0].label = parmnames[0];
; 834  :     /* macro->e.macroinfo->parmlist[0].required = TRUE; */
; 835  :     /* the string parameter is NOT required, '@SizeStr()' is valid */
; 836  :     macro->e.macroinfo->parmlist[0].required = FALSE;

	mov	rax, QWORD PTR [rbx+104]
	mov	rcx, QWORD PTR [rax+8]
	and	BYTE PTR [rcx+8], 254			; 000000feH

; 837  : 
; 838  :     /* add @SubStr() macro func */
; 839  : 
; 840  :     macro = CreateMacro( "@SubStr" );

	lea	rcx, OFFSET FLAT:$SG5864
	call	CreateMacro
	mov	rbx, rax

; 841  :     macro->sym.isdefined = TRUE;
; 842  :     macro->sym.predefined = TRUE;

	or	BYTE PTR [rax+48], 34			; 00000022H

; 843  :     macro->sym.func_ptr = SubStrFunc;

	lea	rax, OFFSET FLAT:SubStrFunc

; 844  :     macro->sym.isfunc = TRUE;

	or	BYTE PTR [rbx+52], 2
	mov	QWORD PTR [rbx+16], rax

; 845  :     macro->e.macroinfo->parmcnt = 3;

	mov	rdx, QWORD PTR [rbx+104]

; 846  :     macro->e.macroinfo->autoexp = 2 + 4; /* param 2 (pos) and 3 (size) are expanded */
; 847  :     macro->e.macroinfo->parmlist = LclAlloc(sizeof( struct mparm_list) * 3);

	lea	ecx, QWORD PTR [rdi+48]
	mov	WORD PTR [rdx], 3
	mov	rdx, QWORD PTR [rbx+104]
	mov	WORD PTR [rdx+2], 6
	call	LclAlloc
	mov	rcx, QWORD PTR [rbx+104]
	mov	QWORD PTR [rcx+8], rax

; 848  :     for (i = 0; i < 3; i++) {
; 849  :         macro->e.macroinfo->parmlist[i].deflt = NULL;

	mov	rax, QWORD PTR [rbx+104]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx], rdi

; 850  :         //macro->e.macroinfo->parmlist[i].label = parmnames[i];
; 851  :         macro->e.macroinfo->parmlist[i].required = (i < 2);

	mov	rax, QWORD PTR [rbx+104]
	mov	rcx, QWORD PTR [rax+8]
	or	BYTE PTR [rcx+8], 1
	mov	rax, QWORD PTR [rbx+104]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+16], rdi
	mov	rax, QWORD PTR [rbx+104]
	mov	rcx, QWORD PTR [rax+8]
	or	BYTE PTR [rcx+24], 1
	mov	rax, QWORD PTR [rbx+104]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+32], rdi
	mov	rax, QWORD PTR [rbx+104]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rcx, QWORD PTR [rax+8]
	mov	rbx, QWORD PTR [rsp+64]
	and	BYTE PTR [rcx+40], 254			; 000000feH

; 852  :     }
; 853  : 
; 854  :     return;
; 855  : }

	add	rsp, 40					; 00000028H
	ret	0
StringInit ENDP
_TEXT	ENDS
END
