; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	DefaultDir
PUBLIC	Options
_BSS	SEGMENT
$SG6247	DB	01H DUP (?)
	ALIGN	4

$SG6220	DB	01H DUP (?)
	ALIGN	4

rspidx	DD	01H DUP (?)
	ALIGN	8

DefaultDir DQ	04H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
Options	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	00H
	DD	032H
	DB	00H
	DB	02H
	DB	00H
	ORG $+1
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	01H
	DD	00H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	ORG $+7
_DATA	ENDS
CONST	SEGMENT
cpuoption DD	00H
	DD	010H
	DD	020H
	DD	030H
	DD	040H
	DD	050H
	DD	060H
	DD	0160H
	DD	0560H
	DD	0d60H
	DD	070H
CONST	ENDS
_DATA	SEGMENT
$SG5827	DB	'movaps', 00H
	ORG $+1
$SG5828	DB	'movdqa', 00H
	ORG $+1
$SG5829	DB	'movups', 00H
	ORG $+1
$SG5830	DB	'movdqu', 00H
	ORG $+1
$SG5831	DB	'movss', 00H
	ORG $+2
$SG5832	DB	'movsd', 00H
	ORG $+2
$SG5833	DB	'movd', 00H
	ORG $+3
$SG5834	DB	'movq', 00H
	ORG $+3
$SG5838	DB	'vmovaps', 00H
$SG5839	DB	'vmovdqa', 00H
$SG5840	DB	'vmovups', 00H
$SG5841	DB	'vmovdqu', 00H
$SG5842	DB	'vmovss', 00H
	ORG $+1
$SG5843	DB	'vmovsd', 00H
	ORG $+1
$SG5844	DB	'vmovd', 00H
	ORG $+2
$SG5845	DB	'vmovq', 00H
	ORG $+2
$SG5854	DB	'Zi', 00H
	ORG $+1
$SG5863	DB	'Zp', 00H
	ORG $+1
$SG5934	DB	'W', 00H
	ORG $+2
$SG5956	DB	'?', 00H
	ORG $+2
$SG5957	DB	'bin', 00H
$SG5958	DB	'Cp', 00H
	ORG $+1
$SG5959	DB	'Cu', 00H
	ORG $+1
$SG5960	DB	'Cx', 00H
	ORG $+1
$SG5961	DB	'archSSE', 00H
$SG5962	DB	'archAVX', 00H
$SG5963	DB	'coff', 00H
	ORG $+3
$SG5964	DB	'c', 00H
	ORG $+2
$SG5965	DB	'D^$', 00H
$SG5966	DB	'elf64', 00H
	ORG $+2
$SG5967	DB	'elf', 00H
$SG5968	DB	'EP', 00H
	ORG $+1
$SG5969	DB	'eq', 00H
	ORG $+1
$SG5973	DB	'e=#', 00H
$SG5974	DB	'Fd=@', 00H
	ORG $+3
$SG5975	DB	'Fi=^@', 00H
	ORG $+2
$SG5976	DB	'Fs=@', 00H
	ORG $+3
$SG5977	DB	'Fl=@', 00H
	ORG $+3
$SG5978	DB	'Fo=^@', 00H
	ORG $+2
$SG5979	DB	'FPi87', 00H
	ORG $+2
$SG5980	DB	'FPi', 00H
$SG5981	DB	'fp0', 00H
$SG5982	DB	'fp2', 00H
$SG5983	DB	'fp3', 00H
$SG5984	DB	'fpc', 00H
$SG5985	DB	'Fw=^@', 00H
	ORG $+2
$SG5986	DB	'Gc', 00H
	ORG $+1
$SG5987	DB	'Gd', 00H
	ORG $+1
$SG5988	DB	'Gr', 00H
	ORG $+1
$SG5989	DB	'Gz', 00H
	ORG $+1
$SG5990	DB	'h', 00H
	ORG $+2
$SG5991	DB	'I=^@', 00H
	ORG $+3
$SG5992	DB	'mc', 00H
	ORG $+1
$SG5993	DB	'mf', 00H
	ORG $+1
$SG5994	DB	'mh', 00H
	ORG $+1
$SG5995	DB	'ml', 00H
	ORG $+1
$SG5996	DB	'mm', 00H
	ORG $+1
$SG5997	DB	'ms', 00H
	ORG $+1
$SG5998	DB	'mt', 00H
	ORG $+1
$SG5999	DB	'mz', 00H
	ORG $+1
$SG6000	DB	'nc=$', 00H
	ORG $+3
$SG6001	DB	'nd=$', 00H
	ORG $+3
$SG6002	DB	'nm=$', 00H
	ORG $+3
$SG6003	DB	'nologo', 00H
	ORG $+1
$SG6004	DB	'nt=$', 00H
	ORG $+3
$SG6005	DB	'omf', 00H
$SG6006	DB	'pe', 00H
	ORG $+1
$SG6007	DB	'q', 00H
	ORG $+2
$SG6008	DB	'Sa', 00H
	ORG $+1
$SG6009	DB	'Sf', 00H
	ORG $+1
$SG6013	DB	'Sg', 00H
	ORG $+1
$SG6017	DB	'Sn', 00H
	ORG $+1
$SG6021	DB	'Sx', 00H
	ORG $+1
$SG6025	DB	'safeseh', 00H
$SG6029	DB	'WX', 00H
	ORG $+1
$SG6030	DB	'W=#', 00H
$SG6031	DB	'win64', 00H
	ORG $+2
$SG6032	DB	'w', 00H
	ORG $+2
$SG6033	DB	'X', 00H
	ORG $+2
$SG6037	DB	'Zd', 00H
	ORG $+1
$SG6038	DB	'Zf', 00H
	ORG $+1
$SG6042	DB	'Zg', 00H
	ORG $+1
$SG6046	DB	'Zi=#', 00H
	ORG $+3
$SG6047	DB	'Zm', 00H
	ORG $+1
$SG6051	DB	'Zne', 00H
$SG6055	DB	'Zp=#', 00H
	ORG $+3
$SG6056	DB	'zcm', 00H
$SG6057	DB	'zcw', 00H
$SG6061	DB	'zf0', 00H
$SG6062	DB	'zf1', 00H
$SG6063	DB	'zlc', 00H
$SG6067	DB	'zld', 00H
$SG6071	DB	'zlf', 00H
$SG6075	DB	'zlp', 00H
$SG6079	DB	'zls', 00H
$SG6083	DB	'Zs', 00H
	ORG $+1
$SG6087	DB	'zt0', 00H
$SG6088	DB	'zt1', 00H
$SG6089	DB	'zt2', 00H
$SG6090	DB	'Zv8', 00H
$SG6094	DB	'zze', 00H
$SG6098	DB	'zzs', 00H
_DATA	ENDS
CONST	SEGMENT
	ORG $+4
cmdl_options DQ	FLAT:$SG5956
	DD	00H
	ORG $+4
	DQ	FLAT:Set_h
	DQ	FLAT:$SG5957
	DD	00H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG5958
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Cp
	DQ	FLAT:$SG5959
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Cu
	DQ	FLAT:$SG5960
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Cx
	DQ	FLAT:$SG5961
	DD	00H
	ORG $+4
	DQ	FLAT:Set_SSE
	DQ	FLAT:$SG5962
	DD	00H
	ORG $+4
	DQ	FLAT:Set_AVX
	DQ	FLAT:$SG5963
	DD	02H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG5964
	DD	00H
	ORG $+4
	DQ	FLAT:Set_c
	DQ	FLAT:$SG5965
	DD	00H
	ORG $+4
	DQ	FLAT:Set_D
	DQ	FLAT:$SG5966
	DD	0303H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG5967
	DD	03H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG5968
	DD	00H
	ORG $+4
	DQ	FLAT:Set_EP
	DQ	FLAT:$SG5969
	DD	0cH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG5973
	DD	00H
	ORG $+4
	DQ	FLAT:Set_e
	DQ	FLAT:$SG5974
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fd
	DQ	FLAT:$SG5975
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fi
	DQ	FLAT:$SG5976
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fs
	DQ	FLAT:$SG5977
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fl
	DQ	FLAT:$SG5978
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fo
	DQ	FLAT:$SG5979
	DD	00H
	ORG $+4
	DQ	FLAT:Set_FPx
	DQ	FLAT:$SG5980
	DD	01H
	ORG $+4
	DQ	FLAT:Set_FPx
	DQ	FLAT:$SG5981
	DD	02H
	ORG $+4
	DQ	FLAT:Set_fp
	DQ	FLAT:$SG5982
	DD	03H
	ORG $+4
	DQ	FLAT:Set_fp
	DQ	FLAT:$SG5983
	DD	04H
	ORG $+4
	DQ	FLAT:Set_fp
	DQ	FLAT:$SG5984
	DD	01H
	ORG $+4
	DQ	FLAT:Set_fp
	DQ	FLAT:$SG5985
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Fw
	DQ	FLAT:$SG5986
	DD	04H
	ORG $+4
	DQ	FLAT:Set_G
	DQ	FLAT:$SG5987
	DD	01H
	ORG $+4
	DQ	FLAT:Set_G
	DQ	FLAT:$SG5988
	DD	07H
	ORG $+4
	DQ	FLAT:Set_G
	DQ	FLAT:$SG5989
	DD	03H
	ORG $+4
	DQ	FLAT:Set_G
	DQ	FLAT:$SG5990
	DD	00H
	ORG $+4
	DQ	FLAT:Set_h
	DQ	FLAT:$SG5991
	DD	00H
	ORG $+4
	DQ	FLAT:Set_I
	DQ	FLAT:$SG5992
	DD	03H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG5993
	DD	07H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG5994
	DD	06H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG5995
	DD	05H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG5996
	DD	04H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG5997
	DD	02H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG5998
	DD	01H
	ORG $+4
	DQ	FLAT:Set_m
	DQ	FLAT:$SG5999
	DD	0100H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG6000
	DD	09H
	ORG $+4
	DQ	FLAT:Set_n
	DQ	FLAT:$SG6001
	DD	08H
	ORG $+4
	DQ	FLAT:Set_n
	DQ	FLAT:$SG6002
	DD	06H
	ORG $+4
	DQ	FLAT:Set_n
	DQ	FLAT:$SG6003
	DD	00H
	ORG $+4
	DQ	FLAT:Set_nologo
	DQ	FLAT:$SG6004
	DD	07H
	ORG $+4
	DQ	FLAT:Set_n
	DQ	FLAT:$SG6005
	DD	01H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG6006
	DD	0200H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG6007
	DD	00H
	ORG $+4
	DQ	FLAT:Set_q
	DQ	FLAT:$SG6008
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Sa
	DQ	FLAT:$SG6009
	DD	095H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG6013
	DD	08cH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG6017
	DD	094H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG6021
	DD	08bH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG6025
	DD	097H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG6029
	DD	00H
	ORG $+4
	DQ	FLAT:Set_WX
	DQ	FLAT:$SG6030
	DD	00H
	ORG $+4
	DQ	FLAT:Set_W
	DQ	FLAT:$SG6031
	DD	0302H
	ORG $+4
	DQ	FLAT:Set_ofmt
	DQ	FLAT:$SG6032
	DD	00H
	ORG $+4
	DQ	FLAT:Set_w
	DQ	FLAT:$SG6033
	DD	098H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG6037
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Zd
	DQ	FLAT:$SG6038
	DD	096H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG6042
	DD	089H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG6046
	DD	02H
	ORG $+4
	DQ	FLAT:Set_Zi
	DQ	FLAT:$SG6047
	DD	087H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG6051
	DD	088H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG6055
	DD	00H
	ORG $+4
	DQ	FLAT:Set_Zp
	DQ	FLAT:$SG6056
	DD	00H
	ORG $+4
	DQ	FLAT:Set_zcm
	DQ	FLAT:$SG6057
	DD	07dH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG6061
	DD	00H
	ORG $+4
	DQ	FLAT:Set_zf
	DQ	FLAT:$SG6062
	DD	01H
	ORG $+4
	DQ	FLAT:Set_zf
	DQ	FLAT:$SG6063
	DD	078H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG6067
	DD	079H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG6071
	DD	07aH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG6075
	DD	07bH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG6079
	DD	07cH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG6083
	DD	0b8H
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG6087
	DD	01H
	ORG $+4
	DQ	FLAT:Set_zt
	DQ	FLAT:$SG6088
	DD	02H
	ORG $+4
	DQ	FLAT:Set_zt
	DQ	FLAT:$SG6089
	DD	00H
	ORG $+4
	DQ	FLAT:Set_zt
	DQ	FLAT:$SG6090
	DD	08aH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG6094
	DD	07fH
	ORG $+4
	DQ	FLAT:Set_True
	DQ	FLAT:$SG6098
	DD	080H
	ORG $+4
	DQ	FLAT:Set_True
CONST	ENDS
_DATA	SEGMENT
$SG6143	DB	'rb', 00H
_DATA	ENDS
EXTRN	EmitWarn:NEAR
xdata	SEGMENT
$unwind$SetCpuCmdline DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SetCpuCmdline DD @imagerel(SetCpuCmdline#)
	DD	@imagerel(SetCpuCmdline#+88)
	DD	@imagerel($unwind$SetCpuCmdline#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\cmdline.c
pdata	ENDS
_TEXT	SEGMENT
value$ = 48
parm$ = 56
SetCpuCmdline PROC NEAR

; 228  : {

	sub	rsp, 40					; 00000028H

; 229  : 
; 230  :     Options.cpu &= ~(P_CPU_MASK | P_EXT_MASK | P_PM);

	mov	eax, DWORD PTR Options+176
	and	eax, -65529				; ffffffffffff0007H

; 231  :     Options.cpu |= value;

	or	eax, ecx
	mov	DWORD PTR Options+176, eax

; 232  : 
; 233  :     for( ; *parm ; parm++ ) {

	movzx	ecx, BYTE PTR [rdx]
	test	cl, cl
	je	SHORT $LN3@SetCpuCmdl
	npad	2
$LL5@SetCpuCmdl:

; 234  :         if( *parm == 'p' && Options.cpu >= P_286 ) {

	cmp	cl, 112					; 00000070H
	jne	SHORT $LN2@SetCpuCmdl
	cmp	eax, 32					; 00000020H
	jl	SHORT $LN2@SetCpuCmdl

; 235  :             Options.cpu |= P_PM;      /* set privileged mode */

	or	eax, 8
	inc	rdx
	mov	DWORD PTR Options+176, eax
	mov	cl, BYTE PTR [rdx]
	test	cl, cl
	jne	SHORT $LL5@SetCpuCmdl

; 253  :             break;
; 254  :         }
; 255  :     }
; 256  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@SetCpuCmdl:

; 236  : #if MANGLERSUPP
; 237  :         } else if( *parm == '"' ) {       /* set default mangler */
; 238  :             char *dest;
; 239  :             parm++;
; 240  :             dest = strchr( parm, '"' );
; 241  :             if( Options.names[OPTN_DEFNAME_MANGLER] != NULL ) {
; 242  :                 MemFree( Options.names[OPTN_DEFNAME_MANGLER );
; 243  :             }
; 244  :             Options.names[OPTN_DEFNAME_MANGLER = MemAlloc( dest - parm + 1 );
; 245  :             dest = Options.names[OPTN_DEFNAME_MANGLER];
; 246  :             for( ; *parm != '"'; dest++, parm++ ) {
; 247  :                 *dest = *parm;
; 248  :             }
; 249  :             *dest = NULLC;
; 250  : #endif
; 251  :         } else {
; 252  :             EmitWarn( 1, CPU_OPTION_INVALID, parm );

	mov	r8, rdx
	mov	ecx, 1
	mov	edx, 134				; 00000086H
	call	EmitWarn
$LN3@SetCpuCmdl:

; 253  :             break;
; 254  :         }
; 255  :     }
; 256  : }

	add	rsp, 40					; 00000028H
	ret	0
SetCpuCmdline ENDP
_TEXT	ENDS
EXTRN	MemAlloc:NEAR
xdata	SEGMENT
$unwind$queue_item DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$queue_item DD @imagerel(queue_item#)
	DD	@imagerel(queue_item#+4)
	DD	@imagerel($unwind$queue_item#)
pdata	ENDS
xdata	SEGMENT
$chain$2$queue_item DD 061221H
	DD	097412H
	DD	08640aH
	DD	073405H
	DD	@imagerel(queue_item#)
	DD	@imagerel(queue_item#+4)
	DD	@imagerel($unwind$queue_item#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$queue_item DD @imagerel(queue_item#+4)
	DD	@imagerel(queue_item#+123)
	DD	@imagerel($chain$2$queue_item#)
pdata	ENDS
xdata	SEGMENT
$chain$3$queue_item DD 020021H
	DD	097400H
	DD	@imagerel(queue_item#)
	DD	@imagerel(queue_item#+4)
	DD	@imagerel($unwind$queue_item#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$queue_item DD @imagerel(queue_item#+123)
	DD	@imagerel(queue_item#+169)
	DD	@imagerel($chain$3$queue_item#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
string$ = 56
queue_item PROC NEAR

; 264  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi
	movsxd	rsi, ecx
	mov	QWORD PTR [rsp+72], rdi

; 265  :     struct qitem *p;
; 266  :     struct qitem *q;
; 267  : 
; 268  :     DebugMsg(("queue_item(%u, %s) enter\n", i, string));
; 269  :     p = MemAlloc( sizeof(struct qitem) + strlen( string ) );

	xor	eax, eax
	mov	rdi, rdx
	mov	rcx, -1
	mov	rbx, rdx
	repne scasb
	not	rcx
	add	rcx, 15
	call	MemAlloc
	mov	rdi, rax

; 270  :     p->next = NULL;
; 271  :     strcpy( p->value, string );

	lea	rdx, QWORD PTR [rax+8]
	mov	QWORD PTR [rax], 0
	sub	rdx, rbx
	npad	12
$LL8@queue_item:
	movzx	ecx, BYTE PTR [rbx]
	inc	rbx
	test	cl, cl
	mov	BYTE PTR [rdx+rbx-1], cl
	jne	SHORT $LL8@queue_item
	mov	rbx, QWORD PTR [rsp+56]

; 272  :     q = Options.queues[i];

	lea	rdx, OFFSET FLAT:Options+96
	mov	rax, rsi
	mov	rcx, QWORD PTR [rdx+rsi*8]
	mov	rsi, QWORD PTR [rsp+64]

; 273  :     if ( q ) {

	test	rcx, rcx
	je	SHORT $LN5@queue_item

; 274  :         for ( ; q->next; q = q->next );

	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	je	SHORT $LN2@queue_item
$LL4@queue_item:
	mov	rcx, rax
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL4@queue_item
$LN2@queue_item:

; 275  :         q->next = p;

	mov	QWORD PTR [rcx], rdi
	mov	rdi, QWORD PTR [rsp+72]

; 278  :     return;
; 279  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN5@queue_item:

; 276  :     } else
; 277  :         Options.queues[i] = p;

	mov	QWORD PTR [rdx+rax*8], rdi
	mov	rdi, QWORD PTR [rsp+72]

; 278  :     return;
; 279  : }

	add	rsp, 40					; 00000028H
	ret	0
queue_item ENDP
_TEXT	ENDS
EXTRN	MemFree:NEAR
EXTRN	__ImageBase:BYTE
EXTRN	GetFNamePart:NEAR
xdata	SEGMENT
$unwind$get_fname DD 0a2001H
	DD	02b7420H
	DD	02a6416H
	DD	0295412H
	DD	028340eH
	DD	027010aH
xdata	ENDS
pdata	SEGMENT
$pdata$get_fname DD @imagerel(get_fname#)
	DD	@imagerel(get_fname#+344)
	DD	@imagerel($unwind$get_fname#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 32
type$ = 320
token$ = 328
get_fname PROC NEAR

; 288  : {

	mov	rax, rsp
	sub	rsp, 312				; 00000138H
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	movsxd	rsi, ecx

; 289  :     const char  *pName;
; 290  :     char        name [ FILENAME_MAX ];
; 291  : 
; 292  :     DebugMsg(("get_fname( type=%u, >%s< ) enter\n", type, token ));
; 293  :     //_splitpath( token, drive, dir, fname, ext );
; 294  :     pName = GetFNamePart( token );

	mov	rcx, rdx
	mov	QWORD PTR [rax+32], rdi
	mov	rbx, rdx
	call	GetFNamePart

; 295  :     /*
; 296  :      * If name's ending with a '\' (or '/' in Unix), it's supposed
; 297  :      * to be a directory name only.
; 298  :      */
; 299  :     if( *pName == NULLC ) {

	cmp	BYTE PTR [rax], 0
	jne	SHORT $LN5@get_fname

; 300  :         DebugMsg(("get_fname(%u, >%s< ) name is empty or a directory\n", type, token ));
; 301  :         /* v2.10: ensure type is < NUM_FILE_TYPES */
; 302  :         if ( type < NUM_FILE_TYPES ) {

	cmp	esi, 4
	jge	$LN6@get_fname

; 303  :             if ( DefaultDir[type] )

	lea	rbp, OFFSET FLAT:__ImageBase
	mov	rcx, QWORD PTR DefaultDir[rbp+rsi*8]
	test	rcx, rcx
	je	SHORT $LN3@get_fname

; 304  :                 MemFree( DefaultDir[type]);

	call	MemFree
$LN3@get_fname:

; 305  :             DefaultDir[type] = MemAlloc( strlen( token ) + 1 );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	call	MemAlloc
	mov	QWORD PTR DefaultDir[rbp+rsi*8], rax
	npad	3
$LL8@get_fname:

; 306  :             strcpy( DefaultDir[type], token );

	movzx	ecx, BYTE PTR [rbx]
	inc	rax
	inc	rbx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL8@get_fname

; 307  :         }
; 308  :         return;

	jmp	$LN6@get_fname
$LN5@get_fname:

; 309  :     }
; 310  :     /* v2.10: ensure type is < NUM_FILE_TYPES */
; 311  :     //if ( drive[0] == NULLC && dir[0] == NULLC && type < NUM_FILE_TYPES && DefaultDir[type] ) {
; 312  :     name[0] = NULLC;
; 313  :     if ( pName == token && type < NUM_FILE_TYPES && DefaultDir[type] ) {

	cmp	rax, rbx
	mov	BYTE PTR name$[rsp], 0
	lea	rbp, OFFSET FLAT:__ImageBase
	jne	SHORT $LN2@get_fname
	cmp	esi, 4
	jge	SHORT $LN2@get_fname
	mov	rcx, QWORD PTR DefaultDir[rbp+rsi*8]
	test	rcx, rcx
	je	SHORT $LN2@get_fname

; 314  :         DebugMsg(("get_fname: default drive+dir used: %s\n" ));
; 315  :         //_splitpath( DefaultDir[type], drive, dir, NULL, NULL );
; 316  :         strcpy( name, DefaultDir[type] );

	lea	rdx, QWORD PTR name$[rsp]
	sub	rdx, rcx
$LL9@get_fname:
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx+rcx-1], al
	jne	SHORT $LL9@get_fname
$LN2@get_fname:

; 317  :     }
; 318  :     strcat( name, token );

	xor	eax, eax
	lea	rdi, QWORD PTR name$[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
$LL14@get_fname:
	movzx	eax, BYTE PTR [rbx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL14@get_fname

; 319  : #if 0 /* v2.12: extension will be set in SetFileNames() */
; 320  :     if( type && type < NUM_FILE_TYPES ) {
; 321  :         char *pExt = GetExtPart( name );
; 322  :         if ( *pExt == NULLC ) {
; 323  :             *pExt++ = '.';
; 324  :             strcpy( pExt, DefaultExt[type-1] );
; 325  :         }
; 326  :     }
; 327  : #endif
; 328  :     //_makepath( name, drive, dir, fname, pExt );
; 329  :     if( Options.names[type] != NULL ) {

	mov	rcx, QWORD PTR Options[rbp+rsi*8+16]
	test	rcx, rcx
	je	SHORT $LN1@get_fname

; 330  :         MemFree( Options.names[type] );

	call	MemFree
$LN1@get_fname:

; 331  :     }
; 332  :     Options.names[type] = MemAlloc( strlen( name ) + 1 );

	xor	eax, eax
	lea	rdi, QWORD PTR name$[rsp]
	mov	rcx, -1
	repne scasb
	not	rcx
	call	MemAlloc

; 333  :     strcpy( Options.names[type], name );

	lea	rdx, QWORD PTR name$[rsp]
	mov	QWORD PTR Options[rbp+rsi*8+16], rax
	npad	10
$LL10@get_fname:
	movzx	ecx, BYTE PTR [rdx]
	inc	rax
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL10@get_fname
$LN6@get_fname:
	mov	rdi, QWORD PTR [rsp+344]
	mov	rsi, QWORD PTR [rsp+336]
	mov	rbp, QWORD PTR [rsp+328]
	mov	rbx, QWORD PTR [rsp+320]

; 334  : }

	add	rsp, 312				; 00000138H
	ret	0
get_fname ENDP
_TEXT	ENDS
EXTRN	EmitError:NEAR
EXTRN	isalnum:NEAR
xdata	SEGMENT
$unwind$set_option_n_name DD 051101H
	DD	097411H
	DD	06340cH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$set_option_n_name DD @imagerel(set_option_n_name#)
	DD	@imagerel(set_option_n_name#+82)
	DD	@imagerel($unwind$set_option_n_name#)
pdata	ENDS
xdata	SEGMENT
$chain$3$set_option_n_name DD 041121H
	DD	086411H
	DD	075405H
	DD	@imagerel(set_option_n_name#)
	DD	@imagerel(set_option_n_name#+82)
	DD	@imagerel($unwind$set_option_n_name#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$set_option_n_name DD @imagerel(set_option_n_name#+82)
	DD	@imagerel(set_option_n_name#+160)
	DD	@imagerel($chain$3$set_option_n_name#)
pdata	ENDS
xdata	SEGMENT
$chain$4$set_option_n_name DD 021H
	DD	@imagerel(set_option_n_name#)
	DD	@imagerel(set_option_n_name#+82)
	DD	@imagerel($unwind$set_option_n_name#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$set_option_n_name DD @imagerel(set_option_n_name#+160)
	DD	@imagerel(set_option_n_name#+191)
	DD	@imagerel($chain$4$set_option_n_name#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
idx$ = 48
name$ = 56
set_option_n_name PROC NEAR

; 344  : {

	sub	rsp, 40					; 00000028H

; 345  :     if ( *name != '.' && !is_valid_id_char( *name ) ) {

	movzx	eax, BYTE PTR [rdx]
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+72], rdi
	cmp	al, 46					; 0000002eH
	mov	rbx, rdx
	movsxd	rdi, ecx
	je	SHORT $LN2@set_option
	movsx	ecx, al
	call	isalnum
	test	eax, eax
	jne	SHORT $LN2@set_option
	movzx	eax, BYTE PTR [rbx]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN2@set_option
	cmp	al, 64					; 00000040H
	je	SHORT $LN2@set_option
	cmp	al, 36					; 00000024H
	je	SHORT $LN2@set_option
	cmp	al, 63					; 0000003fH
	je	SHORT $LN2@set_option

; 346  :         EmitError( N_OPTION_NEEDS_A_NAME_PARAMETER );

	mov	ecx, 234				; 000000eaH
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+48]

; 355  : }

	add	rsp, 40					; 00000028H
	jmp	EmitError
$LN2@set_option:
	mov	QWORD PTR [rsp+56], rbp

; 347  :         return;
; 348  :     }
; 349  : 
; 350  :     if( Options.names[idx] != NULL ) {

	lea	rbp, OFFSET FLAT:Options+16
	mov	QWORD PTR [rsp+64], rsi
	mov	rcx, QWORD PTR [rbp+rdi*8]
	mov	rsi, rdi
	test	rcx, rcx
	je	SHORT $LN1@set_option

; 351  :         MemFree( Options.names[idx] );

	call	MemFree
$LN1@set_option:

; 352  :     }
; 353  :     Options.names[idx] = MemAlloc( strlen( name ) + 1 );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	call	MemAlloc
	mov	QWORD PTR [rbp+rsi*8], rax
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	npad	6
$LL5@set_option:

; 354  :     strcpy( Options.names[idx], name );

	movzx	ecx, BYTE PTR [rbx]
	inc	rax
	inc	rbx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL5@set_option
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+48]

; 355  : }

	add	rsp, 40					; 00000028H
	ret	0
set_option_n_name ENDP
; Function compile flags: /Ogtpy
Set_c	PROC NEAR

; 363  : static void OPTQUAL Set_c( void ) { }

	ret	0
Set_c	ENDP
; Function compile flags: /Ogtpy
Set_Cp	PROC NEAR

; 369  : static void OPTQUAL Set_Cp( void ) { Options.case_sensitive = TRUE;   Options.convert_uppercase = FALSE; }

	mov	BYTE PTR Options+132, 1
	mov	BYTE PTR Options+133, 0
	ret	0
Set_Cp	ENDP
; Function compile flags: /Ogtpy
Set_Cu	PROC NEAR

; 370  : static void OPTQUAL Set_Cu( void ) { Options.case_sensitive = FALSE;  Options.convert_uppercase = TRUE;  }

	mov	BYTE PTR Options+132, 0
	mov	BYTE PTR Options+133, 1
	ret	0
Set_Cu	ENDP
; Function compile flags: /Ogtpy
Set_Cx	PROC NEAR

; 371  : static void OPTQUAL Set_Cx( void ) { Options.case_sensitive = FALSE;  Options.convert_uppercase = FALSE; }

	mov	BYTE PTR Options+132, 0
	mov	BYTE PTR Options+133, 0
	ret	0
Set_Cx	ENDP
_TEXT	ENDS
EXTRN	MOVE_SIMD_QWORD:QWORD
EXTRN	MOVE_SIMD_DWORD:QWORD
EXTRN	MOVE_DOUBLE:QWORD
EXTRN	MOVE_SINGLE:QWORD
EXTRN	MOVE_UNALIGNED_INT:QWORD
EXTRN	MOVE_UNALIGNED_FLOAT:QWORD
EXTRN	MOVE_ALIGNED_INT:QWORD
EXTRN	ModuleInfo:BYTE
EXTRN	MOVE_ALIGNED_FLOAT:QWORD
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
Set_SSE	PROC NEAR

; 375  : 	ModuleInfo.arch = ARCH_SSE; 
; 376  : 	MODULEARCH = ARCH_SSE; 
; 377  : 	strcpy(MOVE_ALIGNED_FLOAT, "movaps");

	mov	rcx, QWORD PTR MOVE_ALIGNED_FLOAT
	and	DWORD PTR ModuleInfo+408, -2		; fffffffeH
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $SG5827[rdx]
	mov	BYTE PTR MODULEARCH, 0
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG5827[rdx+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR $SG5827[rdx+6]
	mov	BYTE PTR [rcx+6], al

; 378  : 	strcpy(MOVE_ALIGNED_INT, "movdqa");

	mov	eax, DWORD PTR $SG5828[rdx]
	mov	rcx, QWORD PTR MOVE_ALIGNED_INT
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG5828[rdx+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR $SG5828[rdx+6]
	mov	BYTE PTR [rcx+6], al

; 379  : 	strcpy(MOVE_UNALIGNED_FLOAT, "movups");

	mov	eax, DWORD PTR $SG5829[rdx]
	mov	rcx, QWORD PTR MOVE_UNALIGNED_FLOAT
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG5829[rdx+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR $SG5829[rdx+6]
	mov	BYTE PTR [rcx+6], al

; 380  : 	strcpy(MOVE_UNALIGNED_INT, "movdqu");

	mov	eax, DWORD PTR $SG5830[rdx]
	mov	rcx, QWORD PTR MOVE_UNALIGNED_INT
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG5830[rdx+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR $SG5830[rdx+6]
	mov	BYTE PTR [rcx+6], al

; 381  : 	strcpy(MOVE_SINGLE, "movss");

	mov	eax, DWORD PTR $SG5831[rdx]
	mov	rcx, QWORD PTR MOVE_SINGLE
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG5831[rdx+4]
	mov	WORD PTR [rcx+4], ax

; 382  : 	strcpy(MOVE_DOUBLE, "movsd");

	mov	eax, DWORD PTR $SG5832[rdx]
	mov	rcx, QWORD PTR MOVE_DOUBLE
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG5832[rdx+4]
	mov	WORD PTR [rcx+4], ax

; 383  : 	strcpy(MOVE_SIMD_DWORD, "movd");

	mov	eax, DWORD PTR $SG5833[rdx]
	mov	rcx, QWORD PTR MOVE_SIMD_DWORD
	mov	DWORD PTR [rcx], eax
	movzx	eax, BYTE PTR $SG5833[rdx+4]
	mov	BYTE PTR [rcx+4], al

; 384  : 	strcpy(MOVE_SIMD_QWORD, "movq");

	mov	eax, DWORD PTR $SG5834[rdx]
	mov	rcx, QWORD PTR MOVE_SIMD_QWORD
	mov	DWORD PTR [rcx], eax
	movzx	eax, BYTE PTR $SG5834[rdx+4]
	mov	BYTE PTR [rcx+4], al

; 385  : }

	ret	0
Set_SSE	ENDP
; Function compile flags: /Ogtpy
Set_AVX PROC NEAR

; 389  : 	ModuleInfo.arch = ARCH_AVX; 
; 390  : 	MODULEARCH = ARCH_AVX;
; 391  : 	strcpy(MOVE_ALIGNED_FLOAT, "vmovaps");

	mov	rax, QWORD PTR MOVE_ALIGNED_FLOAT
	mov	rcx, QWORD PTR $SG5838
	or	DWORD PTR ModuleInfo+408, 1
	mov	BYTE PTR MODULEARCH, 1
	mov	QWORD PTR [rax], rcx

; 392  : 	strcpy(MOVE_ALIGNED_INT, "vmovdqa");

	mov	rax, QWORD PTR MOVE_ALIGNED_INT
	mov	rcx, QWORD PTR $SG5839

; 393  : 	strcpy(MOVE_UNALIGNED_FLOAT, "vmovups");
; 394  : 	strcpy(MOVE_UNALIGNED_INT, "vmovdqu");
; 395  : 	strcpy(MOVE_SINGLE, "vmovss");

	lea	rdx, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR MOVE_UNALIGNED_FLOAT
	mov	rcx, QWORD PTR $SG5840
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR MOVE_UNALIGNED_INT
	mov	rcx, QWORD PTR $SG5841
	mov	QWORD PTR [rax], rcx
	mov	eax, DWORD PTR $SG5842[rdx]
	mov	rcx, QWORD PTR MOVE_SINGLE
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG5842[rdx+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR $SG5842[rdx+6]
	mov	BYTE PTR [rcx+6], al

; 396  : 	strcpy(MOVE_DOUBLE, "vmovsd");

	mov	eax, DWORD PTR $SG5843[rdx]
	mov	rcx, QWORD PTR MOVE_DOUBLE
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG5843[rdx+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR $SG5843[rdx+6]
	mov	BYTE PTR [rcx+6], al

; 397  : 	strcpy(MOVE_SIMD_DWORD, "vmovd");

	mov	eax, DWORD PTR $SG5844[rdx]
	mov	rcx, QWORD PTR MOVE_SIMD_DWORD
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG5844[rdx+4]
	mov	WORD PTR [rcx+4], ax

; 398  : 	strcpy(MOVE_SIMD_QWORD, "vmovq");

	mov	eax, DWORD PTR $SG5845[rdx]
	mov	rcx, QWORD PTR MOVE_SIMD_QWORD
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR $SG5845[rdx+4]
	mov	WORD PTR [rcx+4], ax

; 399  : }

	ret	0
Set_AVX	ENDP
; Function compile flags: /Ogtpy
Set_Zd	PROC NEAR

; 401  : static void OPTQUAL Set_Zd( void ) { Options.line_numbers = TRUE; }

	mov	BYTE PTR Options+1, 1
	ret	0
Set_Zd	ENDP
_TEXT	ENDS
_BSS	SEGMENT
OptValue DD	01H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
_TEXT	SEGMENT
Set_Zi	PROC NEAR

; 404  :     Set_Zd();
; 405  :     Options.debug_symbols = CV_SIGNATURE;
; 406  :     /* v2.10: added optional numeric argument for -Zi */
; 407  :     if ( OptValue <= CVEX_MAX )

	mov	eax, DWORD PTR OptValue
	mov	BYTE PTR Options+1, 1
	mov	BYTE PTR Options+2, 1
	cmp	eax, 3
	ja	SHORT $LN2@Set_Zi

; 408  :         Options.debug_ext = OptValue;

	mov	BYTE PTR Options+3, al

; 411  : }

	ret	0
$LN2@Set_Zi:

; 409  :     else
; 410  :         EmitWarn( 1, INVALID_CMDLINE_VALUE, "Zi" );

	lea	r8, OFFSET FLAT:$SG5854
	mov	edx, 195				; 000000c3H
	mov	ecx, 1

; 411  : }

	jmp	EmitWarn
Set_Zi	ENDP
; Function compile flags: /Ogtpy
Set_Zp	PROC NEAR

; 416  :     uint_8 power;
; 417  :     for ( power = 0; (1 << power) <= MAX_STRUCT_ALIGN; power++ )

	mov	edx, DWORD PTR OptValue
	xor	cl, cl
	mov	eax, 1
	npad	3
$LL4@Set_Zp:

; 418  :         if ( ( 1 << power ) == OptValue ) {

	cmp	eax, edx
	je	SHORT $LN8@Set_Zp
	inc	cl
	mov	eax, 1
	shl	eax, cl
	cmp	eax, 32					; 00000020H
	jle	SHORT $LL4@Set_Zp

; 420  :             return;
; 421  :         }
; 422  :     EmitWarn( 1, INVALID_CMDLINE_VALUE, "Zp" );

	lea	r8, OFFSET FLAT:$SG5863
	mov	edx, 195				; 000000c3H
	mov	ecx, 1

; 423  :     return;
; 424  : }

	jmp	EmitWarn
$LN8@Set_Zp:

; 419  :             Options.fieldalign = power;

	mov	BYTE PTR Options+164, cl

; 423  :     return;
; 424  : }

	ret	0
Set_Zp	ENDP
_TEXT	ENDS
_BSS	SEGMENT
	ALIGN	8

OptName	DQ	01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$Set_D DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$Set_D DD	@imagerel(Set_D#)
	DD	@imagerel(Set_D#+4)
	DD	@imagerel($unwind$Set_D#)
pdata	ENDS
xdata	SEGMENT
$chain$1$Set_D DD 041121H
	DD	097411H
	DD	083405H
	DD	@imagerel(Set_D#)
	DD	@imagerel(Set_D#+4)
	DD	@imagerel($unwind$Set_D#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$Set_D DD @imagerel(Set_D#+4)
	DD	@imagerel(Set_D#+95)
	DD	@imagerel($chain$1$Set_D#)
pdata	ENDS
xdata	SEGMENT
$chain$2$Set_D DD 020021H
	DD	097400H
	DD	@imagerel(Set_D#)
	DD	@imagerel(Set_D#+4)
	DD	@imagerel($unwind$Set_D#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$Set_D DD @imagerel(Set_D#+95)
	DD	@imagerel(Set_D#+153)
	DD	@imagerel($chain$2$Set_D#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
Set_D	PROC NEAR

; 426  : static void OPTQUAL Set_D( void )  { queue_item( OPTQ_MACRO,    GetAFileName() ); }

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rbx
	mov	rbx, QWORD PTR OptName
	mov	QWORD PTR [rsp+72], rdi
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	add	rcx, 15
	call	MemAlloc
	mov	rdi, rax
	lea	rdx, QWORD PTR [rax+8]
	mov	QWORD PTR [rax], 0
	sub	rdx, rbx
$LL10@Set_D:
	movzx	ecx, BYTE PTR [rbx]
	inc	rbx
	test	cl, cl
	mov	BYTE PTR [rdx+rbx-1], cl
	jne	SHORT $LL10@Set_D
	mov	rcx, QWORD PTR Options+104
	mov	rbx, QWORD PTR [rsp+64]
	test	rcx, rcx
	je	SHORT $LN7@Set_D
	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	je	SHORT $LN4@Set_D
	npad	9
$LL6@Set_D:
	mov	rcx, rax
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL6@Set_D
$LN4@Set_D:
	mov	QWORD PTR [rcx], rdi
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 40					; 00000028H
	ret	0
$LN7@Set_D:
	mov	QWORD PTR Options+104, rax
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 40					; 00000028H
	ret	0
Set_D	ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$Set_Fi DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$Set_Fi DD @imagerel(Set_Fi#)
	DD	@imagerel(Set_Fi#+4)
	DD	@imagerel($unwind$Set_Fi#)
pdata	ENDS
xdata	SEGMENT
$chain$1$Set_Fi DD 041121H
	DD	097411H
	DD	083405H
	DD	@imagerel(Set_Fi#)
	DD	@imagerel(Set_Fi#+4)
	DD	@imagerel($unwind$Set_Fi#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$Set_Fi DD @imagerel(Set_Fi#+4)
	DD	@imagerel(Set_Fi#+95)
	DD	@imagerel($chain$1$Set_Fi#)
pdata	ENDS
xdata	SEGMENT
$chain$2$Set_Fi DD 020021H
	DD	097400H
	DD	@imagerel(Set_Fi#)
	DD	@imagerel(Set_Fi#+4)
	DD	@imagerel($unwind$Set_Fi#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$Set_Fi DD @imagerel(Set_Fi#+95)
	DD	@imagerel(Set_Fi#+153)
	DD	@imagerel($chain$2$Set_Fi#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
Set_Fi	PROC NEAR

; 427  : static void OPTQUAL Set_Fi( void ) { queue_item( OPTQ_FINCLUDE, GetAFileName() ); }

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rbx
	mov	rbx, QWORD PTR OptName
	mov	QWORD PTR [rsp+72], rdi
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	add	rcx, 15
	call	MemAlloc
	mov	rdi, rax
	lea	rdx, QWORD PTR [rax+8]
	mov	QWORD PTR [rax], 0
	sub	rdx, rbx
$LL10@Set_Fi:
	movzx	ecx, BYTE PTR [rbx]
	inc	rbx
	test	cl, cl
	mov	BYTE PTR [rdx+rbx-1], cl
	jne	SHORT $LL10@Set_Fi
	mov	rcx, QWORD PTR Options+96
	mov	rbx, QWORD PTR [rsp+64]
	test	rcx, rcx
	je	SHORT $LN7@Set_Fi
	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	je	SHORT $LN4@Set_Fi
	npad	9
$LL6@Set_Fi:
	mov	rcx, rax
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL6@Set_Fi
$LN4@Set_Fi:
	mov	QWORD PTR [rcx], rdi
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 40					; 00000028H
	ret	0
$LN7@Set_Fi:
	mov	QWORD PTR Options+96, rax
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 40					; 00000028H
	ret	0
Set_Fi	ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$Set_I DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$Set_I DD	@imagerel(Set_I#)
	DD	@imagerel(Set_I#+4)
	DD	@imagerel($unwind$Set_I#)
pdata	ENDS
xdata	SEGMENT
$chain$1$Set_I DD 041121H
	DD	097411H
	DD	083405H
	DD	@imagerel(Set_I#)
	DD	@imagerel(Set_I#+4)
	DD	@imagerel($unwind$Set_I#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$Set_I DD @imagerel(Set_I#+4)
	DD	@imagerel(Set_I#+95)
	DD	@imagerel($chain$1$Set_I#)
pdata	ENDS
xdata	SEGMENT
$chain$2$Set_I DD 020021H
	DD	097400H
	DD	@imagerel(Set_I#)
	DD	@imagerel(Set_I#+4)
	DD	@imagerel($unwind$Set_I#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$Set_I DD @imagerel(Set_I#+95)
	DD	@imagerel(Set_I#+153)
	DD	@imagerel($chain$2$Set_I#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
Set_I	PROC NEAR

; 428  : static void OPTQUAL Set_I( void )  { queue_item( OPTQ_INCPATH,  GetAFileName() ); }

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rbx
	mov	rbx, QWORD PTR OptName
	mov	QWORD PTR [rsp+72], rdi
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	add	rcx, 15
	call	MemAlloc
	mov	rdi, rax
	lea	rdx, QWORD PTR [rax+8]
	mov	QWORD PTR [rax], 0
	sub	rdx, rbx
$LL10@Set_I:
	movzx	ecx, BYTE PTR [rbx]
	inc	rbx
	test	cl, cl
	mov	BYTE PTR [rdx+rbx-1], cl
	jne	SHORT $LL10@Set_I
	mov	rcx, QWORD PTR Options+112
	mov	rbx, QWORD PTR [rsp+64]
	test	rcx, rcx
	je	SHORT $LN7@Set_I
	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	je	SHORT $LN4@Set_I
	npad	9
$LL6@Set_I:
	mov	rcx, rax
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL6@Set_I
$LN4@Set_I:
	mov	QWORD PTR [rcx], rdi
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 40					; 00000028H
	ret	0
$LN7@Set_I:
	mov	QWORD PTR Options+112, rax
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 40					; 00000028H
	ret	0
Set_I	ENDP
; Function compile flags: /Ogtpy
Set_e	PROC NEAR

; 430  : static void OPTQUAL Set_e( void ) { Options.error_limit = OptValue; }

	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+8, eax
	ret	0
Set_e	ENDP
_TEXT	ENDS
EXTRN	banner_printed:BYTE
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
Set_nologo PROC NEAR

; 432  : static void OPTQUAL Set_nologo( void ) { banner_printed = TRUE; }

	mov	BYTE PTR banner_printed, 1
	ret	0
Set_nologo ENDP
; Function compile flags: /Ogtpy
Set_q	PROC NEAR

; 433  : static void OPTQUAL Set_q( void )      { Set_nologo(); Options.quiet = TRUE; }

	mov	BYTE PTR banner_printed, 1
	mov	BYTE PTR Options, 1
	ret	0
Set_q	ENDP
; Function compile flags: /Ogtpy
Set_EP	PROC NEAR

; 434  : static void OPTQUAL Set_EP( void ) { Options.preprocessor_stdout = TRUE; Set_q(); }

	mov	BYTE PTR Options+134, 1
	mov	BYTE PTR banner_printed, 1
	mov	BYTE PTR Options, 1
	ret	0
Set_EP	ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$Set_Fd DD 040f01H
	DD	02a340fH
	DD	0270107H
xdata	ENDS
pdata	SEGMENT
$pdata$Set_Fd DD @imagerel(Set_Fd#)
	DD	@imagerel(Set_Fd#+39)
	DD	@imagerel($unwind$Set_Fd#)
pdata	ENDS
xdata	SEGMENT
$chain$1$Set_Fd DD 020821H
	DD	02b7408H
	DD	@imagerel(Set_Fd#)
	DD	@imagerel(Set_Fd#+39)
	DD	@imagerel($unwind$Set_Fd#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$Set_Fd DD @imagerel(Set_Fd#+39)
	DD	@imagerel(Set_Fd#+160)
	DD	@imagerel($chain$1$Set_Fd#)
pdata	ENDS
xdata	SEGMENT
$chain$2$Set_Fd DD 021H
	DD	@imagerel(Set_Fd#)
	DD	@imagerel(Set_Fd#+39)
	DD	@imagerel($unwind$Set_Fd#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$Set_Fd DD @imagerel(Set_Fd#+160)
	DD	@imagerel(Set_Fd#+199)
	DD	@imagerel($chain$2$Set_Fd#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$6525 = 32
Set_Fd	PROC NEAR

; 437  : static void OPTQUAL Set_Fd( void ) { get_fname( OPTN_LNKDEF_FN, GetAFileName() ); Options.write_impdef = TRUE;}

	sub	rsp, 312				; 00000138H
	mov	QWORD PTR [rsp+336], rbx
	mov	rbx, QWORD PTR OptName
	mov	rcx, rbx
	call	GetFNamePart
	cmp	BYTE PTR [rax], 0
	je	$LN15@Set_Fd
	mov	QWORD PTR [rsp+344], rdi
	xor	eax, eax
	lea	rdi, QWORD PTR name$6525[rsp]
	mov	rcx, -1
	mov	BYTE PTR name$6525[rsp], 0
	repne scasb
	xor	edx, edx
	npad	10
$LL14@Set_Fd:
	movzx	eax, BYTE PTR [rbx+rdx]
	inc	rdx
	test	al, al
	mov	BYTE PTR [rdi+rdx-2], al
	jne	SHORT $LL14@Set_Fd
	mov	rcx, QWORD PTR Options+56
	test	rcx, rcx
	je	SHORT $LN3@Set_Fd
	call	MemFree
$LN3@Set_Fd:
	xor	eax, eax
	lea	rdi, QWORD PTR name$6525[rsp]
	mov	rcx, -1
	repne scasb
	not	rcx
	call	MemAlloc
	mov	rdi, QWORD PTR [rsp+344]
	lea	rdx, QWORD PTR name$6525[rsp]
	mov	QWORD PTR Options+56, rax
	npad	4
$LL12@Set_Fd:
	movzx	ecx, BYTE PTR [rdx]
	inc	rax
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL12@Set_Fd
$LN15@Set_Fd:
	mov	BYTE PTR Options+131, 1
	mov	rbx, QWORD PTR [rsp+336]
	add	rsp, 312				; 00000138H
	ret	0
Set_Fd	ENDP
; Function compile flags: /Ogtpy
Set_Fw	PROC NEAR

; 439  : static void OPTQUAL Set_Fw( void ) { get_fname( OPTN_ERR_FN, GetAFileName() ); }

	mov	rdx, QWORD PTR OptName
	mov	ecx, 3
	jmp	get_fname
Set_Fw	ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$Set_Fs DD 040f01H
	DD	02a340fH
	DD	0270107H
xdata	ENDS
pdata	SEGMENT
$pdata$Set_Fs DD @imagerel(Set_Fs#)
	DD	@imagerel(Set_Fs#+39)
	DD	@imagerel($unwind$Set_Fs#)
pdata	ENDS
xdata	SEGMENT
$chain$1$Set_Fs DD 020821H
	DD	02b7408H
	DD	@imagerel(Set_Fs#)
	DD	@imagerel(Set_Fs#+39)
	DD	@imagerel($unwind$Set_Fs#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$Set_Fs DD @imagerel(Set_Fs#+39)
	DD	@imagerel(Set_Fs#+160)
	DD	@imagerel($chain$1$Set_Fs#)
pdata	ENDS
xdata	SEGMENT
$chain$2$Set_Fs DD 021H
	DD	@imagerel(Set_Fs#)
	DD	@imagerel(Set_Fs#+39)
	DD	@imagerel($unwind$Set_Fs#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$Set_Fs DD @imagerel(Set_Fs#+160)
	DD	@imagerel(Set_Fs#+199)
	DD	@imagerel($chain$2$Set_Fs#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$6564 = 32
Set_Fs	PROC NEAR

; 440  : static void OPTQUAL Set_Fs( void ) { get_fname( OPTN_SYM_FN, GetAFileName() ); Options.dumpSymbols = TRUE; }

	sub	rsp, 312				; 00000138H
	mov	QWORD PTR [rsp+336], rbx
	mov	rbx, QWORD PTR OptName
	mov	rcx, rbx
	call	GetFNamePart
	cmp	BYTE PTR [rax], 0
	je	$LN15@Set_Fs
	mov	QWORD PTR [rsp+344], rdi
	xor	eax, eax
	lea	rdi, QWORD PTR name$6564[rsp]
	mov	rcx, -1
	mov	BYTE PTR name$6564[rsp], 0
	repne scasb
	xor	edx, edx
	npad	10
$LL14@Set_Fs:
	movzx	eax, BYTE PTR [rbx+rdx]
	inc	rdx
	test	al, al
	mov	BYTE PTR [rdi+rdx-2], al
	jne	SHORT $LL14@Set_Fs
	mov	rcx, QWORD PTR Options+48
	test	rcx, rcx
	je	SHORT $LN3@Set_Fs
	call	MemFree
$LN3@Set_Fs:
	xor	eax, eax
	lea	rdi, QWORD PTR name$6564[rsp]
	mov	rcx, -1
	repne scasb
	not	rcx
	call	MemAlloc
	mov	rdi, QWORD PTR [rsp+344]
	lea	rdx, QWORD PTR name$6564[rsp]
	mov	QWORD PTR Options+48, rax
	npad	4
$LL12@Set_Fs:
	movzx	ecx, BYTE PTR [rdx]
	inc	rax
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL12@Set_Fs
$LN15@Set_Fs:
	mov	BYTE PTR Options+130, 1
	mov	rbx, QWORD PTR [rsp+336]
	add	rsp, 312				; 00000138H
	ret	0
Set_Fs	ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$Set_Fl DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$Set_Fl DD @imagerel(Set_Fl#)
	DD	@imagerel(Set_Fl#+33)
	DD	@imagerel($unwind$Set_Fl#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
Set_Fl	PROC NEAR

; 441  : static void OPTQUAL Set_Fl( void ) { get_fname( OPTN_LST_FN, GetAFileName() ); Options.write_listing = TRUE;}

	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR OptName
	mov	ecx, 2
	call	get_fname
	mov	BYTE PTR Options+129, 1
	add	rsp, 40					; 00000028H
	ret	0
Set_Fl	ENDP
; Function compile flags: /Ogtpy
Set_Fo	PROC NEAR

; 442  : static void OPTQUAL Set_Fo( void ) { get_fname( OPTN_OBJ_FN, GetAFileName() ); }

	mov	rdx, QWORD PTR OptName
	mov	ecx, 1
	jmp	get_fname
Set_Fo	ENDP
; Function compile flags: /Ogtpy
Set_fp	PROC NEAR

; 444  : static void OPTQUAL Set_fp( void ) { Options.cpu &= ~P_FPU_MASK; Options.cpu = OptValue; }

	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+176, eax
	ret	0
Set_fp	ENDP
; Function compile flags: /Ogtpy
Set_FPx PROC NEAR

; 445  : static void OPTQUAL Set_FPx( void ) { Options.floating_point = OptValue; }

	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+4, eax
	ret	0
Set_FPx	ENDP
; Function compile flags: /Ogtpy
Set_G	PROC NEAR

; 446  : static void OPTQUAL Set_G( void ) { Options.langtype = OptValue; }

	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+168, eax
	ret	0
Set_G	ENDP
; Function compile flags: /Ogtpy
Set_Sa	PROC NEAR

; 451  :     Options.listif = TRUE;

	mov	BYTE PTR Options+139, 1

; 452  :     Options.list_generated_code = TRUE;

	mov	BYTE PTR Options+140, 1

; 453  :     Options.list_macro = LM_LISTMACROALL;

	mov	DWORD PTR Options+144, 2

; 454  : }

	ret	0
Set_Sa	ENDP
; Function compile flags: /Ogtpy
Set_True PROC NEAR

; 459  :     char *p = ((char *)&Options) + OptValue;
; 460  :     *p = TRUE;

	mov	eax, DWORD PTR OptValue
	lea	rcx, OFFSET FLAT:Options
	mov	BYTE PTR [rax+rcx], 1

; 461  : }

	ret	0
Set_True ENDP
; Function compile flags: /Ogtpy
Set_m	PROC NEAR

; 463  : static void OPTQUAL Set_m( void ) { Options.model = OptValue; }

	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+172, eax
	ret	0
Set_m	ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$Set_n DD 051501H
	DD	097415H
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$Set_n DD	@imagerel(Set_n#)
	DD	@imagerel(Set_n#+90)
	DD	@imagerel($unwind$Set_n#)
pdata	ENDS
xdata	SEGMENT
$chain$3$Set_n DD 041121H
	DD	086411H
	DD	075405H
	DD	@imagerel(Set_n#)
	DD	@imagerel(Set_n#+90)
	DD	@imagerel($unwind$Set_n#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$Set_n DD @imagerel(Set_n#+90)
	DD	@imagerel(Set_n#+162)
	DD	@imagerel($chain$3$Set_n#)
pdata	ENDS
xdata	SEGMENT
$chain$4$Set_n DD 021H
	DD	@imagerel(Set_n#)
	DD	@imagerel(Set_n#+90)
	DD	@imagerel($unwind$Set_n#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$Set_n DD @imagerel(Set_n#+162)
	DD	@imagerel(Set_n#+193)
	DD	@imagerel($chain$4$Set_n#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
Set_n	PROC NEAR

; 464  : static void OPTQUAL Set_n( void ) { set_option_n_name( OptValue, OptName ); }

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	rbx, QWORD PTR OptName
	mov	QWORD PTR [rsp+72], rdi
	movzx	eax, BYTE PTR [rbx]
	movsxd	rdi, DWORD PTR OptValue
	cmp	al, 46					; 0000002eH
	je	SHORT $LN4@Set_n
	movsx	ecx, al
	call	isalnum
	test	eax, eax
	jne	SHORT $LN4@Set_n
	movzx	eax, BYTE PTR [rbx]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN4@Set_n
	cmp	al, 64					; 00000040H
	je	SHORT $LN4@Set_n
	cmp	al, 36					; 00000024H
	je	SHORT $LN4@Set_n
	cmp	al, 63					; 0000003fH
	je	SHORT $LN4@Set_n
	mov	ecx, 234				; 000000eaH
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 40					; 00000028H
	jmp	EmitError
$LN4@Set_n:
	mov	QWORD PTR [rsp+56], rbp
	lea	rbp, OFFSET FLAT:Options+16
	mov	QWORD PTR [rsp+64], rsi
	mov	rcx, QWORD PTR [rbp+rdi*8]
	mov	rsi, rdi
	test	rcx, rcx
	je	SHORT $LN3@Set_n
	call	MemFree
$LN3@Set_n:
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	call	MemAlloc
	mov	QWORD PTR [rbp+rsi*8], rax
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
$LL7@Set_n:
	movzx	ecx, BYTE PTR [rbx]
	inc	rax
	inc	rbx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL7@Set_n
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 40					; 00000028H
	ret	0
Set_n	ENDP
; Function compile flags: /Ogtpy
Set_WX	PROC NEAR

; 470  : static void OPTQUAL Set_WX( void ) { Options.warning_error = TRUE; }

	mov	BYTE PTR Options+14, 1
	ret	0
Set_WX	ENDP
; Function compile flags: /Ogtpy
Set_w	PROC NEAR

; 472  : static void OPTQUAL Set_w( void ) { Set_WX(); Options.warning_level = 0; }

	mov	BYTE PTR Options+14, 1
	mov	BYTE PTR Options+13, 0
	ret	0
Set_w	ENDP
; Function compile flags: /Ogtpy
Set_W	PROC NEAR

; 477  :     if ( OptValue <= 4 )

	mov	eax, DWORD PTR OptValue
	cmp	eax, 4
	ja	SHORT $LN2@Set_W

; 478  :         Options.warning_level = OptValue;

	mov	BYTE PTR Options+13, al

; 481  : }

	ret	0
$LN2@Set_W:

; 479  :     else
; 480  :         EmitWarn( 1, INVALID_CMDLINE_VALUE, "W" );

	lea	r8, OFFSET FLAT:$SG5934
	mov	edx, 195				; 000000c3H
	mov	ecx, 1

; 481  : }

	jmp	EmitWarn
Set_W	ENDP
; Function compile flags: /Ogtpy
Set_ofmt PROC NEAR

; 486  :     Options.output_format = OptValue & 0xff;

	mov	ecx, DWORD PTR OptValue
	movzx	eax, cl

; 487  :     Options.sub_format = OptValue >> 8;

	shr	ecx, 8
	mov	DWORD PTR Options+160, ecx
	mov	DWORD PTR Options+156, eax

; 488  : }

	ret	0
Set_ofmt ENDP
; Function compile flags: /Ogtpy
Set_zcm PROC NEAR

; 490  : static void OPTQUAL Set_zcm( void ) { Options.no_cdecl_decoration = FALSE; }

	mov	BYTE PTR Options+125, 0
	ret	0
Set_zcm	ENDP
; Function compile flags: /Ogtpy
Set_zf	PROC NEAR

; 492  : static void OPTQUAL Set_zf( void )  { Options.fctype = OptValue; }

	mov	eax, DWORD PTR OptValue
	mov	DWORD PTR Options+180, eax
	ret	0
Set_zf	ENDP
; Function compile flags: /Ogtpy
Set_zt	PROC NEAR

; 495  : static void OPTQUAL Set_zt( void ) { Options.stdcall_decoration = OptValue; }

	movzx	eax, BYTE PTR OptValue
	mov	BYTE PTR Options+126, al
	ret	0
Set_zt	ENDP
_TEXT	ENDS
EXTRN	exit:NEAR
EXTRN	PrintUsage:NEAR
xdata	SEGMENT
$unwind$Set_h DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$Set_h DD	@imagerel(Set_h#)
	DD	@imagerel(Set_h#+20)
	DD	@imagerel($unwind$Set_h#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
Set_h	PROC NEAR

; 497  : static void OPTQUAL Set_h( void ) {  PrintUsage();  exit(1); }

	sub	rsp, 40					; 00000028H
	call	PrintUsage
	mov	ecx, 1
	call	exit
	int	3
$LN3@Set_h:
Set_h	ENDP
; Function compile flags: /Ogtpy
dst$ = 8
str$ = 16
max$ = 24
type$ = 32
GetNameToken PROC NEAR

; 714  :     bool equatefound = FALSE;

	xor	r10b, r10b

; 715  : 
; 716  :     DebugMsg(("GetNameToken( %s, %u, '%c' ) enter, rspidx=%u\n", str, max, type, rspidx ));
; 717  :     //while( isspace( *str ) ) ++str;  /* no spaces allowed! */
; 718  : is_quote:
; 719  :     if( *str == '"' ) {

	cmp	BYTE PTR [rdx], 34			; 00000022H
	je	SHORT $LN29@GetNameTok
	mov	r11d, DWORD PTR rspidx
	npad	1
$is_quote$6113:

; 731  :         }
; 732  :     } else {
; 733  :         for( ; max; max-- ) {

	test	r8d, r8d
	je	$LN16@GetNameTok

; 734  :             /* v2.10: don't stop for white spaces */
; 735  :             //if ( *str == NULLC || *str == ' ' || *str == '\t' )
; 736  :             if ( *str == NULLC )

	movzx	eax, BYTE PTR [rdx]
	test	al, al
	je	$LN16@GetNameTok

; 737  :                 break;
; 738  :             /* v2.10: don't stop for white spaces if filename is expected and true cmdline is parsed */
; 739  :             if ( ( *str == ' ' || *str == '\t' ) && ( rspidx || type != '@' ) )

	cmp	al, 32					; 00000020H
	je	SHORT $LN7@GetNameTok
	cmp	al, 9
	jne	SHORT $LN8@GetNameTok
$LN7@GetNameTok:
	test	r11d, r11d
	jne	$LN16@GetNameTok
	cmp	r9b, 64					; 00000040H
	jne	SHORT $LN16@GetNameTok
$LN8@GetNameTok:

; 740  :                 break;
; 741  :             if ( type == 0 )

	test	r9b, r9b
	jne	SHORT $LN4@GetNameTok

; 742  :                 if ( *str == '-'
; 743  : #if SWITCHCHAR
; 744  :                     || *str == '/'
; 745  : #endif
; 746  :                    )

	cmp	al, 45					; 0000002dH
	je	SHORT $LN16@GetNameTok
	cmp	al, 47					; 0000002fH
	je	SHORT $LN16@GetNameTok
$LN4@GetNameTok:

; 747  :                     break;
; 748  :             if ( *str == '=' && type == '$' && equatefound == FALSE ) {

	cmp	al, 61					; 0000003dH
	jne	SHORT $LN1@GetNameTok
	cmp	r9b, 36					; 00000024H
	jne	SHORT $LN1@GetNameTok
	test	r10b, r10b
	jne	SHORT $LN1@GetNameTok

; 749  :                 equatefound = TRUE;
; 750  :                 *dst++ = *str++;

	inc	rdx
	mov	BYTE PTR [rcx], al
	inc	rcx

; 751  :                 if (*str == '"')

	mov	al, BYTE PTR [rdx]
	mov	r10b, 1
	cmp	al, 34					; 00000022H
	je	SHORT $LN29@GetNameTok
$LN1@GetNameTok:

; 752  :                     goto is_quote;
; 753  :             }
; 754  :             *dst++ = *str++;

	mov	BYTE PTR [rcx], al
	inc	rcx
	inc	rdx
	dec	r8d
	jmp	SHORT $is_quote$6113
$LN29@GetNameTok:

; 720  :         ++str;

	inc	rdx

; 721  :         for( ; max && *str; max-- ) {

	test	r8d, r8d
	je	SHORT $LN16@GetNameTok
	npad	3
$LL18@GetNameTok:
	movzx	eax, BYTE PTR [rdx]
	test	al, al
	je	SHORT $LN16@GetNameTok

; 722  :             if ( *str == '"' ) {

	cmp	al, 34					; 00000022H
	je	SHORT $LN30@GetNameTok

; 724  :                 break;
; 725  :             }
; 726  :             /* handle the \" case */
; 727  :             if ( *str == '\\' && *(str+1) == '"' ) {

	cmp	al, 92					; 0000005cH
	jne	SHORT $LN14@GetNameTok
	cmp	BYTE PTR [rdx+1], 34			; 00000022H
	lea	rax, QWORD PTR [rdx+1]
	cmove	rdx, rax
$LN14@GetNameTok:

; 728  :                 ++str;
; 729  :             }
; 730  :             *dst++ = *str++;

	movzx	eax, BYTE PTR [rdx]
	inc	rcx
	inc	rdx
	dec	r8d
	mov	BYTE PTR [rcx-1], al
	jne	SHORT $LL18@GetNameTok

; 755  :         }
; 756  :     }
; 757  :     *dst = NULLC;

	mov	BYTE PTR [rcx], r8b

; 758  :     return( str );

	mov	rax, rdx

; 759  : }

	ret	0
$LN30@GetNameTok:

; 723  :                 ++str;

	inc	rdx
$LN16@GetNameTok:

; 755  :         }
; 756  :     }
; 757  :     *dst = NULLC;

	mov	BYTE PTR [rcx], 0

; 758  :     return( str );

	mov	rax, rdx

; 759  : }

	ret	0
GetNameToken ENDP
_TEXT	ENDS
EXTRN	fclose:NEAR
EXTRN	fread:NEAR
EXTRN	rewind:NEAR
EXTRN	ftell:NEAR
EXTRN	fseek:NEAR
EXTRN	Fatal:NEAR
EXTRN	ErrnoStr:NEAR
EXTRN	fopen:NEAR
xdata	SEGMENT
$unwind$ReadParamFile DD 071a01H
	DD	09741aH
	DD	086415H
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$ReadParamFile DD @imagerel(ReadParamFile#)
	DD	@imagerel(ReadParamFile#+90)
	DD	@imagerel($unwind$ReadParamFile#)
pdata	ENDS
xdata	SEGMENT
$chain$3$ReadParamFile DD 020521H
	DD	075405H
	DD	@imagerel(ReadParamFile#)
	DD	@imagerel(ReadParamFile#+90)
	DD	@imagerel($unwind$ReadParamFile#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$ReadParamFile DD @imagerel(ReadParamFile#+90)
	DD	@imagerel(ReadParamFile#+185)
	DD	@imagerel($chain$3$ReadParamFile#)
pdata	ENDS
xdata	SEGMENT
$chain$4$ReadParamFile DD 021H
	DD	@imagerel(ReadParamFile#)
	DD	@imagerel(ReadParamFile#+90)
	DD	@imagerel($unwind$ReadParamFile#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$ReadParamFile DD @imagerel(ReadParamFile#+185)
	DD	@imagerel(ReadParamFile#+250)
	DD	@imagerel($chain$4$ReadParamFile#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
ReadParamFile PROC NEAR

; 768  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx

; 769  :     char        *env;
; 770  :     char        *str;
; 771  :     FILE        *file;
; 772  :     int         len;
; 773  :     char        ch;
; 774  : 
; 775  :     DebugMsg(("ReadParamFile(%s) enter\n"));
; 776  :     env = NULL;
; 777  :     file = fopen( name, "rb" );

	lea	rdx, OFFSET FLAT:$SG6143
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	mov	rbx, rcx
	xor	edi, edi
	call	fopen

; 778  :     if( file == NULL ) {

	test	rax, rax
	mov	rsi, rax
	jne	SHORT $LN8@ReadParamF

; 779  :         /* v2.10: changed to fatal error */
; 780  :         //EmitErr( CANNOT_OPEN_FILE, name, ErrnoStr() );
; 781  :         Fatal( CANNOT_OPEN_FILE, name, ErrnoStr() );

	call	ErrnoStr
	lea	ecx, QWORD PTR [rdi+106]
	mov	rdx, rbx
	mov	r8, rax
	call	Fatal
$LN14@ReadParamF:

; 782  :         return( NULL );

	xor	eax, eax
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]

; 815  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@ReadParamF:

; 783  :     }
; 784  :     len = 0;
; 785  :     if ( fseek( file, 0, SEEK_END ) == 0 ) {

	xor	edx, edx
	mov	rcx, rax
	mov	QWORD PTR [rsp+56], rbp
	lea	r8d, QWORD PTR [rdx+2]
	mov	ebp, edi
	call	fseek
	test	eax, eax
	jne	SHORT $LN7@ReadParamF

; 786  :         len = ftell( file );

	mov	rcx, rsi
	call	ftell

; 787  :         rewind( file );

	mov	rcx, rsi
	movsxd	rbp, eax
	call	rewind

; 788  :         env = MemAlloc( len + 1 );

	lea	r11d, DWORD PTR [rbp+1]
	movsxd	rcx, r11d
	call	MemAlloc

; 789  : #if defined(__GNUC__) /* gcc warns if return value of fread() is "ignored" */
; 790  :         if ( fread( env, 1, len, file ) );
; 791  : #else
; 792  :         fread( env, 1, len, file );

	mov	r9, rsi
	mov	r8, rbp
	mov	rcx, rax
	mov	edx, 1
	mov	rdi, rax
	call	fread

; 793  : #endif
; 794  :         env[len] = NULLC;

	mov	BYTE PTR [rbp+rdi], 0
$LN7@ReadParamF:

; 795  :     }
; 796  :     fclose( file );

	mov	rcx, rsi
	call	fclose

; 797  :     if ( len == 0)

	test	ebp, ebp
	mov	rbp, QWORD PTR [rsp+56]

; 798  :         return( NULL );

	je	SHORT $LN14@ReadParamF

; 799  :     /* zip through characters changing \r, \n etc into ' ' */
; 800  :     str = env;
; 801  :     while( *str ) {

	cmp	BYTE PTR [rdi], 0
	mov	rax, rdi
	je	SHORT $LN4@ReadParamF
$LL5@ReadParamF:

; 802  :         ch = *str;

	movzx	ecx, BYTE PTR [rax]

; 803  :         if( ch == '\r' || ch == '\n' ) {

	cmp	cl, 13
	je	SHORT $LN2@ReadParamF
	cmp	cl, 10
	jne	SHORT $LN3@ReadParamF
$LN2@ReadParamF:

; 804  :             *str = ' ';

	mov	BYTE PTR [rax], 32			; 00000020H
$LN3@ReadParamF:

; 805  :         }
; 806  : #if HANDLECTRLZ
; 807  :         if( ch == 0x1A ) {      /* if end of file */

	cmp	cl, 26
	je	SHORT $LN12@ReadParamF

; 809  :             break;
; 810  :         }
; 811  : #endif
; 812  :         ++str;

	inc	rax
	cmp	BYTE PTR [rax], 0
	jne	SHORT $LL5@ReadParamF

; 805  :         }
; 806  : #if HANDLECTRLZ
; 807  :         if( ch == 0x1A ) {      /* if end of file */

	jmp	SHORT $LN4@ReadParamF
$LN12@ReadParamF:

; 808  :             *str = '\0';        /* - mark end of str */

	mov	BYTE PTR [rax], 0
$LN4@ReadParamF:
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]

; 813  :     }
; 814  :     return( env );

	mov	rax, rdi
	mov	rdi, QWORD PTR [rsp+72]

; 815  : }

	add	rsp, 40					; 00000028H
	ret	0
ReadParamFile ENDP
_TEXT	ENDS
_BSS	SEGMENT
cmdsave	DQ	0fH DUP (?)
cmdbuffers DQ	0fH DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$getnextcmdstring DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$getnextcmdstring DD @imagerel(getnextcmdstring#)
	DD	@imagerel(getnextcmdstring#+130)
	DD	@imagerel($unwind$getnextcmdstring#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
cmdline$ = 48
getnextcmdstring PROC NEAR

; 821  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 822  :     const char **src;
; 823  :     const char **dst;
; 824  : 
; 825  :     /* something onto the response file stack? */
; 826  :     if ( rspidx ) {

	mov	edx, DWORD PTR rspidx
	mov	r8, rcx
	test	edx, edx
	je	SHORT $LN4@getnextcmd

; 827  :         rspidx--;

	dec	edx

; 828  :         if ( cmdbuffers[rspidx] )

	lea	rbx, OFFSET FLAT:__ImageBase
	movsxd	rax, edx
	mov	DWORD PTR rspidx, edx
	mov	rcx, QWORD PTR cmdbuffers[rbx+rax*8]
	test	rcx, rcx
	je	SHORT $LN3@getnextcmd

; 829  :             MemFree( (void *)cmdbuffers[rspidx] );

	call	MemFree
	mov	edx, DWORD PTR rspidx
$LN3@getnextcmd:

; 830  :         return( cmdsave[rspidx] );

	movsxd	rax, edx
	mov	rax, QWORD PTR cmdsave[rbx+rax*8]

; 836  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@getnextcmd:

; 831  :     }
; 832  :     for ( dst = cmdline, src = cmdline+1; *src; )

	mov	rdx, QWORD PTR [r8+8]
	lea	rax, QWORD PTR [r8+8]
	test	rdx, rdx
	je	SHORT $LN1@getnextcmd
	npad	5
$LL2@getnextcmd:

; 833  :         *dst++ = *src++;

	add	rax, 8
	mov	QWORD PTR [rcx], rdx
	add	rcx, 8
	mov	rdx, QWORD PTR [rax]
	test	rdx, rdx
	jne	SHORT $LL2@getnextcmd
$LN1@getnextcmd:

; 834  :     *dst = *src;

	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 835  :     return( *cmdline );

	mov	rax, QWORD PTR [r8]

; 836  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
getnextcmdstring ENDP
; Function compile flags: /Ogtpy
p$ = 8
GetNumber PROC NEAR

; 841  :     OptValue = 0;
; 842  :     for( ;*p >= '0' && *p <= '9'; p++ )

	movzx	eax, BYTE PTR [rcx]
	xor	edx, edx
	cmp	al, 48					; 00000030H
	mov	DWORD PTR OptValue, edx
	jl	SHORT $LN9@GetNumber
	npad	1
$LL3@GetNumber:
	cmp	al, 57					; 00000039H
	jg	SHORT $LN9@GetNumber

; 843  :         OptValue = OptValue * 10 + *p - '0';

	movsx	eax, al
	inc	rcx
	lea	edx, DWORD PTR [rdx+rdx*4]
	lea	edx, DWORD PTR [rax+rdx*2-48]
	mov	al, BYTE PTR [rcx]
	cmp	al, 48					; 00000030H
	mov	DWORD PTR OptValue, edx
	jge	SHORT $LL3@GetNumber
$LN9@GetNumber:

; 844  :     return( p );

	mov	rax, rcx

; 845  : }

	ret	0
GetNumber ENDP
_TEXT	ENDS
EXTRN	isspace:NEAR
xdata	SEGMENT
$unwind$ProcessOption DD 091e01H
	DD	05f41eH
	DD	06e419H
	DD	0d7411H
	DD	0a3409H
	DD	08204H
xdata	ENDS
pdata	SEGMENT
$pdata$ProcessOption DD @imagerel(ProcessOption#)
	DD	@imagerel(ProcessOption#+333)
	DD	@imagerel($unwind$ProcessOption#)
pdata	ENDS
xdata	SEGMENT
$chain$7$ProcessOption DD 081421H
	DD	07d414H
	DD	0c640fH
	DD	08c40aH
	DD	0b5405H
	DD	@imagerel(ProcessOption#)
	DD	@imagerel(ProcessOption#+333)
	DD	@imagerel($unwind$ProcessOption#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$ProcessOption DD @imagerel(ProcessOption#+333)
	DD	@imagerel(ProcessOption#+511)
	DD	@imagerel($chain$7$ProcessOption#)
pdata	ENDS
xdata	SEGMENT
$chain$8$ProcessOption DD 021H
	DD	@imagerel(ProcessOption#)
	DD	@imagerel(ProcessOption#+333)
	DD	@imagerel($unwind$ProcessOption#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$ProcessOption DD @imagerel(ProcessOption#+511)
	DD	@imagerel(ProcessOption#+536)
	DD	@imagerel($chain$8$ProcessOption#)
pdata	ENDS
xdata	SEGMENT
$chain$9$ProcessOption DD 080021H
	DD	07d400H
	DD	08c400H
	DD	0c6400H
	DD	0b5400H
	DD	@imagerel(ProcessOption#)
	DD	@imagerel(ProcessOption#+333)
	DD	@imagerel($unwind$ProcessOption#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$ProcessOption DD @imagerel(ProcessOption#+536)
	DD	@imagerel(ProcessOption#+1267)
	DD	@imagerel($chain$9$ProcessOption#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
cmdline$ = 80
buffer$ = 88
ProcessOption PROC NEAR

; 857  : {

	sub	rsp, 72					; 00000048H
	mov	QWORD PTR [rsp+80], rbx

; 858  :     int   i;
; 859  :     int   j;
; 860  :     const char *p = *cmdline;

	mov	rbx, QWORD PTR [rcx]
	mov	QWORD PTR [rsp+104], rdi

; 861  :     const char *opt;
; 862  :     //char  c;
; 863  : 
; 864  :     DebugMsg(("ProcessOption(%s)\n", p ));
; 865  : 
; 866  :     /* numeric option (-0, -1, ... ) handled separately since
; 867  :      * the value can be >= 10.
; 868  :      */
; 869  :     if ( *p >= '0' && *p <= '9' ) {

	movzx	eax, BYTE PTR [rbx]
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], r15
	cmp	al, 48					; 00000030H
	mov	r14, rdx
	mov	r15, rcx
	jl	$LN28@ProcessOpt
	cmp	al, 57					; 00000039H
	jg	$LN28@ProcessOpt

; 870  :         p = GetNumber( p );

	xor	r9d, r9d
	mov	rdx, rbx
	mov	DWORD PTR OptValue, r9d
$LL34@ProcessOpt:
	cmp	al, 57					; 00000039H
	jg	SHORT $LN32@ProcessOpt
	movsx	eax, al
	inc	rdx
	lea	ecx, DWORD PTR [r9+r9*4]
	lea	r9d, DWORD PTR [rax+rcx*2-48]
	mov	al, BYTE PTR [rdx]
	cmp	al, 48					; 00000030H
	jge	SHORT $LL34@ProcessOpt
$LN32@ProcessOpt:

; 871  :         if ( OptValue < sizeof(cpuoption)/sizeof(cpuoption[0]) ) {

	cmp	r9d, 11
	mov	DWORD PTR OptValue, r9d
	jae	$LN28@ProcessOpt

; 872  :             p = GetNameToken( buffer, p, 16, 0 ); /* get optional 'p' */

	cmp	BYTE PTR [rdx], 34			; 00000022H
	mov	rcx, r14
	mov	r8d, 16
	je	SHORT $LN116@ProcessOpt
	npad	7
$is_quote$6765:
	test	r8d, r8d
	je	SHORT $LN52@ProcessOpt
	movzx	eax, BYTE PTR [rdx]
	test	al, al
	je	SHORT $LN52@ProcessOpt
	cmp	al, 32					; 00000020H
	je	SHORT $LN52@ProcessOpt
	cmp	al, 9
	je	SHORT $LN52@ProcessOpt
	cmp	al, 45					; 0000002dH
	je	SHORT $LN52@ProcessOpt
	cmp	al, 47					; 0000002fH
	je	SHORT $LN52@ProcessOpt
	mov	BYTE PTR [rcx], al
	inc	rcx
	inc	rdx
	dec	r8d
	jmp	SHORT $is_quote$6765
$LN116@ProcessOpt:
	inc	rdx
	npad	4
$LL54@ProcessOpt:
	movzx	eax, BYTE PTR [rdx]
	test	al, al
	je	SHORT $LN52@ProcessOpt
	cmp	al, 34					; 00000022H
	je	SHORT $LN117@ProcessOpt
	cmp	al, 92					; 0000005cH
	jne	SHORT $LN50@ProcessOpt
	cmp	BYTE PTR [rdx+1], 34			; 00000022H
	lea	rax, QWORD PTR [rdx+1]
	cmove	rdx, rax
$LN50@ProcessOpt:
	movzx	eax, BYTE PTR [rdx]
	inc	rcx
	inc	rdx
	dec	r8d
	mov	BYTE PTR [rcx-1], al
	jne	SHORT $LL54@ProcessOpt

; 927  :                         if ( p == NULL ) {

	jmp	SHORT $LN52@ProcessOpt
$LN117@ProcessOpt:

; 872  :             p = GetNameToken( buffer, p, 16, 0 ); /* get optional 'p' */

	inc	rdx
$LN52@ProcessOpt:
	mov	BYTE PTR [rcx], 0

; 873  :             *cmdline = p;

	mov	QWORD PTR [r15], rdx

; 874  :             SetCpuCmdline( cpuoption[OptValue], buffer );

	mov	eax, DWORD PTR Options+176
	and	eax, -65529				; ffffffffffff0007H
	lea	rdi, OFFSET FLAT:__ImageBase
	mov	edx, DWORD PTR cpuoption[rdi+r9*4]
	or	edx, eax
	mov	DWORD PTR Options+176, edx
	movzx	eax, BYTE PTR [r14]
	test	al, al
	je	$LN30@ProcessOpt
$LL62@ProcessOpt:
	cmp	al, 112					; 00000070H
	jne	SHORT $LN59@ProcessOpt
	cmp	edx, 32					; 00000020H
	jl	SHORT $LN59@ProcessOpt
	or	edx, 8
	inc	r14
	mov	DWORD PTR Options+176, edx
	mov	al, BYTE PTR [r14]
	test	al, al
	jne	SHORT $LL62@ProcessOpt

; 927  :                         if ( p == NULL ) {

	jmp	$LN30@ProcessOpt

; 874  :             SetCpuCmdline( cpuoption[OptValue], buffer );

$LN59@ProcessOpt:
	mov	r8, r14
	mov	edx, 134				; 00000086H
	mov	ecx, 1
	call	EmitWarn

; 875  :             return;

	jmp	$LN30@ProcessOpt
$LN28@ProcessOpt:
	mov	QWORD PTR [rsp+88], rbp
	mov	QWORD PTR [rsp+64], r12
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+56], r13

; 876  :         }
; 877  :         p = *cmdline; /* v2.11: restore option pointer */
; 878  :     }
; 879  :     for( i = 0; i < ( sizeof(cmdl_options) / sizeof(cmdl_options[0]) ); i++ ) {

	xor	ebp, ebp
	lea	r12, OFFSET FLAT:cmdl_options
	npad	6
$LL27@ProcessOpt:

; 880  :         //DebugMsg(("ProcessOption(%s): %s\n", p, opt ));
; 881  :         if( *p == *cmdl_options[i].name ) {

	mov	rcx, QWORD PTR [r12]
	movzx	eax, BYTE PTR [rcx]
	cmp	BYTE PTR [rbx], al
	jne	SHORT $LN26@ProcessOpt

; 882  :             for ( opt = cmdl_options[i].name+1, j = 1 ; isalnum(*opt) && *opt == p[j]; opt++, j++ );

	lea	r13, QWORD PTR [rcx+1]
	mov	esi, 1
	movsx	ecx, BYTE PTR [r13]
	call	isalnum
	test	eax, eax
	je	SHORT $LN137@ProcessOpt
	lea	rdi, QWORD PTR [rbx+1]
$LL23@ProcessOpt:
	movzx	eax, BYTE PTR [rdi]
	cmp	BYTE PTR [r13], al
	jne	SHORT $LN137@ProcessOpt
	movsx	ecx, BYTE PTR [r13+1]
	inc	r13
	inc	esi
	inc	rdi
	call	isalnum
	test	eax, eax
	jne	SHORT $LL23@ProcessOpt
$LN137@ProcessOpt:

; 883  :             /* make sure end of option is reached */
; 884  :             if ( isalnum(*opt) )

	movsx	ecx, BYTE PTR [r13]
	call	isalnum
	test	eax, eax
	je	SHORT $LN20@ProcessOpt
$LN26@ProcessOpt:

; 876  :         }
; 877  :         p = *cmdline; /* v2.11: restore option pointer */
; 878  :     }
; 879  :     for( i = 0; i < ( sizeof(cmdl_options) / sizeof(cmdl_options[0]) ); i++ ) {

	inc	ebp
	add	r12, 24
	cmp	ebp, 83					; 00000053H
	jb	SHORT $LL27@ProcessOpt
$opt_error_exit$6204:

; 930  :                         }
; 931  :                     }
; 932  :                     break;
; 933  :                 default:
; 934  :                     /* internal error: unknown format of option item! */
; 935  :                     DebugMsg(( "ProcessOption: unknown option specifier: %s\n", opt ));
; 936  :                     /**/myassert( 0 );
; 937  :                     break;
; 938  :                 }
; 939  :             }
; 940  :         }
; 941  :     }
; 942  : opt_error_exit:
; 943  :     EmitWarn( 1, INVALID_CMDLINE_OPTION, *cmdline - 1 );

	mov	r8, QWORD PTR [r15]
	mov	edx, 109				; 0000006dH
	lea	ecx, QWORD PTR [rdx-108]
	dec	r8
	call	EmitWarn

; 944  :     *cmdline = "";

	lea	r11, OFFSET FLAT:$SG6220
	mov	QWORD PTR [r15], r11
$LN141@ProcessOpt:
	mov	rsi, QWORD PTR [rsp+96]
	mov	r13, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+88]
	mov	r12, QWORD PTR [rsp+64]
$LN30@ProcessOpt:
	mov	r15, QWORD PTR [rsp+40]
	mov	r14, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+80]

; 945  :     return;
; 946  : }

	add	rsp, 72					; 00000048H
	ret	0
$LN20@ProcessOpt:

; 885  :                 continue;
; 886  :             p += j;
; 887  :             OptValue = cmdl_options[i].value;

	mov	r10d, DWORD PTR rspidx
	movsxd	rax, esi
	lea	rdi, OFFSET FLAT:__ImageBase
	add	rbx, rax
	movsxd	rax, ebp
	lea	rbp, OFFSET FLAT:cmdl_options
	lea	rsi, QWORD PTR [rax+rax*2]
	mov	eax, DWORD PTR [rbp+rsi*8+8]
	mov	DWORD PTR OptValue, eax
$LL19@ProcessOpt:

; 890  :                 switch ( *opt ) {

	movsx	r8, BYTE PTR [r13]
	cmp	r8d, 94					; 0000005eH
	mov	rax, r8
	ja	$LN18@ProcessOpt
	movzx	eax, BYTE PTR $LN134@ProcessOpt[rdi+r8]
	mov	ecx, DWORD PTR $LN135@ProcessOpt[rdi+rax*4]
	add	rcx, rdi
	jmp	rcx
$LN12@ProcessOpt:

; 898  :                     break;
; 899  :                 case '#':             /* collect a number */
; 900  :                     if( *p >= '0' && *p <= '9' )

	movzx	eax, BYTE PTR [rbx]
	cmp	al, 48					; 00000030H
	jl	$LN18@ProcessOpt
	cmp	al, 57					; 00000039H
	jg	$LN18@ProcessOpt

; 901  :                         p = GetNumber( p );

	xor	ecx, ecx
	mov	DWORD PTR OptValue, ecx
$LL67@ProcessOpt:
	cmp	al, 57					; 00000039H
	jg	SHORT $LN65@ProcessOpt
	movsx	eax, al
	inc	rbx
	lea	ecx, DWORD PTR [rcx+rcx*4]
	lea	ecx, DWORD PTR [rax+rcx*2-48]
	mov	al, BYTE PTR [rbx]
	cmp	al, 48					; 00000030H
	jge	SHORT $LL67@ProcessOpt
$LN65@ProcessOpt:
	mov	DWORD PTR OptValue, ecx
	inc	r13
	jmp	SHORT $LL19@ProcessOpt
$LN10@ProcessOpt:

; 902  :                     break;
; 903  :                 case '$':      /* collect an identifer+value */
; 904  :                 case '@':      /* collect a filename */
; 905  :                     OptName = buffer;
; 906  : #if 0  /* v2.05: removed */
; 907  :                     if ( rspidx )
; 908  :                         p = GetNameToken( buffer, p, FILENAME_MAX - 1, *opt );
; 909  :                     else {
; 910  :                         j = strlen( p );
; 911  :                         memcpy( buffer, p, (j >= FILENAME_MAX) ? FILENAME_MAX : j + 1 );
; 912  :                         p += j;
; 913  :                     }
; 914  : #else
; 915  :                     /* v2.10: spaces in filename now handled inside GetNameToken() */
; 916  :                     p = GetNameToken( buffer, p, FILENAME_MAX - 1, *opt );

	xor	r9b, r9b
	cmp	BYTE PTR [rbx], 34			; 00000022H
	mov	QWORD PTR OptName, r14
	mov	rcx, r14
	mov	edx, 259				; 00000103H
	je	SHORT $LN121@ProcessOpt
	npad	1
$is_quote$6809:
	test	edx, edx
	je	$LN85@ProcessOpt
	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	$LN85@ProcessOpt
	cmp	al, 32					; 00000020H
	je	SHORT $LN76@ProcessOpt
	cmp	al, 9
	jne	SHORT $LN77@ProcessOpt
$LN76@ProcessOpt:
	test	r10d, r10d
	jne	$LN85@ProcessOpt
	cmp	r8b, 64					; 00000040H
	jne	$LN85@ProcessOpt
$LN77@ProcessOpt:
	test	r8b, r8b
	jne	SHORT $LN73@ProcessOpt
	cmp	al, 45					; 0000002dH
	je	SHORT $LN85@ProcessOpt
	cmp	al, 47					; 0000002fH
	je	SHORT $LN85@ProcessOpt
$LN73@ProcessOpt:
	cmp	al, 61					; 0000003dH
	jne	SHORT $LN70@ProcessOpt
	cmp	r8b, 36					; 00000024H
	jne	SHORT $LN70@ProcessOpt
	test	r9b, r9b
	jne	SHORT $LN70@ProcessOpt
	inc	rbx
	mov	BYTE PTR [rcx], al
	inc	rcx
	mov	al, BYTE PTR [rbx]
	mov	r9b, 1
	cmp	al, 34					; 00000022H
	je	SHORT $LN121@ProcessOpt
$LN70@ProcessOpt:
	mov	BYTE PTR [rcx], al
	inc	rcx
	inc	rbx
	dec	edx
	jmp	SHORT $is_quote$6809
$LN121@ProcessOpt:
	inc	rbx
	test	edx, edx
	je	SHORT $LN85@ProcessOpt
	npad	2
$LL87@ProcessOpt:
	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	SHORT $LN85@ProcessOpt
	cmp	al, 34					; 00000022H
	je	SHORT $LN122@ProcessOpt
	cmp	al, 92					; 0000005cH
	jne	SHORT $LN83@ProcessOpt
	cmp	BYTE PTR [rbx+1], 34			; 00000022H
	lea	rax, QWORD PTR [rbx+1]
	cmove	rbx, rax
$LN83@ProcessOpt:
	movzx	eax, BYTE PTR [rbx]
	inc	rcx
	inc	rbx
	dec	edx
	mov	BYTE PTR [rcx-1], al
	jne	SHORT $LL87@ProcessOpt
	mov	BYTE PTR [rcx], dl
	inc	r13
	jmp	$LL19@ProcessOpt
$LN122@ProcessOpt:
	inc	rbx
$LN85@ProcessOpt:
	mov	BYTE PTR [rcx], 0
	inc	r13
	jmp	$LL19@ProcessOpt
$LN9@ProcessOpt:

; 917  : #endif
; 918  :                     break;
; 919  :                 case '=':    /* collect an optional '=' */
; 920  :                     if ( *p == '=' || *p == '#' )

	movzx	eax, BYTE PTR [rbx]
	cmp	al, 61					; 0000003dH
	je	SHORT $LN7@ProcessOpt
	cmp	al, 35					; 00000023H
	jne	$LN18@ProcessOpt
$LN7@ProcessOpt:

; 921  :                         p++;

	inc	rbx
	inc	r13
	jmp	$LL19@ProcessOpt
$LN109@ProcessOpt:

; 922  :                     break;
; 923  :                 case '^':    /* skip spaces before argument */
; 924  :                     while ( isspace(*p) ) p++;

	movsx	ecx, BYTE PTR [rbx]
	call	isspace
	test	eax, eax
	je	SHORT $LN4@ProcessOpt
	npad	7
$LL5@ProcessOpt:
	movsx	ecx, BYTE PTR [rbx+1]
	inc	rbx
	call	isspace
	test	eax, eax
	jne	SHORT $LL5@ProcessOpt
$LN4@ProcessOpt:

; 925  :                     if ( *p == NULLC ) {

	cmp	BYTE PTR [rbx], 0
	jne	$LN136@ProcessOpt

; 926  :                         p = getnextcmdstring( cmdline );

	mov	r10d, DWORD PTR rspidx
	test	r10d, r10d
	je	SHORT $LN94@ProcessOpt
	dec	r10d
	movsxd	rax, r10d
	mov	DWORD PTR rspidx, r10d
	mov	rcx, QWORD PTR cmdbuffers[rdi+rax*8]
	test	rcx, rcx
	je	SHORT $LN93@ProcessOpt
	call	MemFree
	mov	r10d, DWORD PTR rspidx
$LN93@ProcessOpt:
	movsxd	rax, r10d
	mov	rbx, QWORD PTR cmdsave[rdi+rax*8]
	jmp	SHORT $LN95@ProcessOpt
$LN94@ProcessOpt:
	mov	rdx, QWORD PTR [r15+8]
	lea	rax, QWORD PTR [r15+8]
	mov	rcx, r15
	test	rdx, rdx
	je	SHORT $LN91@ProcessOpt
	npad	8
$LL92@ProcessOpt:
	add	rax, 8
	mov	QWORD PTR [rcx], rdx
	add	rcx, 8
	mov	rdx, QWORD PTR [rax]
	test	rdx, rdx
	jne	SHORT $LL92@ProcessOpt
$LN91@ProcessOpt:
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
	mov	rbx, QWORD PTR [r15]
$LN95@ProcessOpt:

; 927  :                         if ( p == NULL ) {

	test	rbx, rbx
	jne	SHORT $LN18@ProcessOpt

; 928  :                             EmitWarn( 1, MISSING_ARGUMENT_FOR_CMDLINE_OPTION );

	lea	ecx, QWORD PTR [rbx+1]
	mov	edx, 251				; 000000fbH
	call	EmitWarn

; 929  :                             return;

	jmp	$LN141@ProcessOpt
$LN136@ProcessOpt:

; 927  :                         if ( p == NULL ) {

	mov	r10d, DWORD PTR rspidx
$LN18@ProcessOpt:

; 888  :             //DebugMsg(("ProcessOption(%s): Option found\n", p ));
; 889  :             for( ;; opt++) {

	inc	r13
	jmp	$LL19@ProcessOpt
$LN14@ProcessOpt:

; 891  :                 //case '*': /* don't know what this is supposed to do? */
; 892  :                 case NULLC:
; 893  :                     if ( !IsOptionDelimiter( *p ) )

	movzx	eax, BYTE PTR [rbx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN13@ProcessOpt
	cmp	al, 45					; 0000002dH
	je	SHORT $LN13@ProcessOpt
	cmp	al, 47					; 0000002fH
	je	SHORT $LN13@ProcessOpt
	test	al, al
	je	SHORT $LN13@ProcessOpt
	cmp	al, 9
	jne	$opt_error_exit$6204
$LN13@ProcessOpt:

; 894  :                         goto opt_error_exit;
; 895  :                     *cmdline = p;

	mov	QWORD PTR [r15], rbx

; 896  :                     cmdl_options[i].function();

	call	QWORD PTR [rbp+rsi*8+16]

; 897  :                     return; /* option processed successfully */

	jmp	$LN141@ProcessOpt
	npad	3
$LN135@ProcessOpt:

; 945  :     return;
; 946  : }

	DD	$LN14@ProcessOpt
	DD	$LN12@ProcessOpt
	DD	$LN10@ProcessOpt
	DD	$LN9@ProcessOpt
	DD	$LN109@ProcessOpt
	DD	$LN18@ProcessOpt
$LN134@ProcessOpt:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	5
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
ProcessOption ENDP
_TEXT	ENDS
PUBLIC	ParseCmdline
EXTRN	EmitErr:NEAR
EXTRN	getenv:NEAR
xdata	SEGMENT
$unwind$ParseCmdline DD 0126c01H
	DD	049f46cH
	DD	04cc464H
	DD	04ae425H
	DD	04bd421H
	DD	051741dH
	DD	0506419H
	DD	04f5415H
	DD	04e340eH
	DD	04d010aH
xdata	ENDS
pdata	SEGMENT
$pdata$ParseCmdline DD @imagerel($LN146#)
	DD	@imagerel($LN146#+1777)
	DD	@imagerel($unwind$ParseCmdline#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
paramfile$ = 32
name$7024 = 304
name$7007 = 304
cmdline$ = 624
pCntArgs$ = 632
ParseCmdline PROC NEAR

; 1000 : {

$LN146:
	mov	rax, rsp
	sub	rsp, 616				; 00000268H
	mov	QWORD PTR [rax+8], rbx

; 1001 :     int i;
; 1002 :     const char *str = *cmdline;

	mov	rbx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	QWORD PTR [rax-16], r13
	mov	QWORD PTR [rax-24], r14
	mov	r13, rcx
	lea	rdi, OFFSET FLAT:Options+16
	mov	r14, rdx
	xor	ebp, ebp
	lea	rsi, OFFSET FLAT:Options+48
	npad	5
$LL21@ParseCmdli:

; 1003 :     char paramfile[FILENAME_MAX];
; 1004 : 
; 1005 :     for ( i = 0; i < NUM_FILE_TYPES; i++ )
; 1006 :         if ( Options.names[i] != NULL ) {

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN20@ParseCmdli

; 1007 :             MemFree( Options.names[i] );

	call	MemFree

; 1008 :             Options.names[i] = NULL;

	mov	QWORD PTR [rdi], rbp
$LN20@ParseCmdli:
	add	rdi, 8
	cmp	rdi, rsi
	jl	SHORT $LL21@ParseCmdli

; 1009 :         }
; 1010 : 
; 1011 :     /* enable next line if debug log is to be active, but -dt cannot be set */
; 1012 :     //Set_dt();
; 1013 : 
; 1014 :     for( ; str; ) {

	test	rbx, rbx
	mov	QWORD PTR [rsp+608], r12
	mov	QWORD PTR [rsp+584], r15
	je	$LN16@ParseCmdli
	mov	r8d, DWORD PTR rspidx
	lea	r15, OFFSET FLAT:__ImageBase
	mov	r12d, 259				; 00000103H
	npad	10
$LL17@ParseCmdli:

; 1015 :         switch( *str ) {

	movsx	rax, BYTE PTR [rbx]
	cmp	eax, 64					; 00000040H
	ja	$LN3@ParseCmdli
	movzx	eax, BYTE PTR $LN142@ParseCmdli[r15+rax]
	mov	ecx, DWORD PTR $LN143@ParseCmdli[r15+rax*4]
	add	rcx, r15
	jmp	rcx
$LN13@ParseCmdli:

; 1016 :         case ' ':
; 1017 :         case '\t':
; 1018 :             str++;

	inc	rbx

; 1019 :             break;

	jmp	$LN14@ParseCmdli
$LN12@ParseCmdli:

; 1020 :         case NULLC:
; 1021 :             str = getnextcmdstring( cmdline );

	test	r8d, r8d
	je	SHORT $LN28@ParseCmdli
	dec	r8d
	movsxd	rax, r8d
	mov	DWORD PTR rspidx, r8d
	mov	rcx, QWORD PTR cmdbuffers[r15+rax*8]
	test	rcx, rcx
	je	SHORT $LN27@ParseCmdli
	call	MemFree
	mov	r8d, DWORD PTR rspidx
$LN27@ParseCmdli:
	movsxd	rax, r8d
	mov	rbx, QWORD PTR cmdsave[r15+rax*8]
	jmp	$LN14@ParseCmdli
$LN28@ParseCmdli:
	mov	rdx, QWORD PTR [r13+8]
	lea	rax, QWORD PTR [r13+8]
	mov	rcx, r13
	test	rdx, rdx
	je	SHORT $LN25@ParseCmdli
	npad	10
$LL26@ParseCmdli:
	add	rax, 8
	mov	QWORD PTR [rcx], rdx
	add	rcx, 8
	mov	rdx, QWORD PTR [rax]
	test	rdx, rdx
	jne	SHORT $LL26@ParseCmdli
$LN25@ParseCmdli:
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
	mov	rbx, QWORD PTR [r13]

; 1022 :             break;

	jmp	$LN14@ParseCmdli
$LN11@ParseCmdli:

; 1023 :         case '-':
; 1024 : #if SWITCHCHAR
; 1025 :         case '/':
; 1026 : #endif
; 1027 :             str++;

	lea	rax, QWORD PTR [rbx+1]

; 1028 :             *cmdline = str;
; 1029 :             ProcessOption( cmdline, paramfile );

	lea	rdx, QWORD PTR paramfile$[rsp]
	mov	rcx, r13
	mov	QWORD PTR [r13], rax
	call	ProcessOption

; 1030 :             (*pCntArgs)++;

	inc	DWORD PTR [r14]

; 1031 :             str = *cmdline;

	mov	rbx, QWORD PTR [r13]

; 1032 :             break;

	mov	r8d, DWORD PTR rspidx
	jmp	$LN14@ParseCmdli
$LN10@ParseCmdli:

; 1033 :         case '@':
; 1034 :             if ( rspidx >= MAX_RSP_NESTING ) {

	cmp	r8d, 15
	jge	$LN128@ParseCmdli

; 1038 :             }
; 1039 :             str++;

	inc	rbx

; 1040 : #if 1 /* v2.06: was '0' in v2.05, now '1' again since it didn't work with quoted names */
; 1041 :             /* todo: might be unnecessary since v.2.10, since GetNameToken() handles spaces inside filenames differently */
; 1042 :             if ( rspidx ) {

	test	r8d, r8d
	je	$LN8@ParseCmdli

; 1043 :                 cmdsave[rspidx] = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );

	cmp	BYTE PTR [rbx], 34			; 00000022H
	lea	rcx, QWORD PTR paramfile$[rsp]
	mov	edx, r12d
	je	SHORT $LN125@ParseCmdli
	npad	3
$is_quote$6935:
	test	edx, edx
	je	SHORT $LN46@ParseCmdli
	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	SHORT $LN46@ParseCmdli
	cmp	al, 32					; 00000020H
	je	SHORT $LN46@ParseCmdli
	cmp	al, 9
	je	SHORT $LN46@ParseCmdli
	mov	BYTE PTR [rcx], al
	inc	rcx
	inc	rbx
	dec	edx
	jmp	SHORT $is_quote$6935
$LN125@ParseCmdli:
	inc	rbx
$LL48@ParseCmdli:
	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	SHORT $LN46@ParseCmdli
	cmp	al, 34					; 00000022H
	je	SHORT $LN126@ParseCmdli
	cmp	al, 92					; 0000005cH
	jne	SHORT $LN44@ParseCmdli
	cmp	BYTE PTR [rbx+1], 34			; 00000022H
	lea	rax, QWORD PTR [rbx+1]
	cmove	rbx, rax
$LN44@ParseCmdli:
	movzx	eax, BYTE PTR [rbx]
	inc	rcx
	inc	rbx
	dec	edx
	mov	BYTE PTR [rcx-1], al
	jne	SHORT $LL48@ParseCmdli
	movsxd	rax, r8d
	mov	BYTE PTR [rcx], dl
	mov	QWORD PTR cmdsave[r15+rax*8], rbx

; 1044 :             } else {

	jmp	SHORT $LN7@ParseCmdli
$LN126@ParseCmdli:

; 1043 :                 cmdsave[rspidx] = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );

	inc	rbx
$LN46@ParseCmdli:
	movsxd	rax, r8d
	mov	BYTE PTR [rcx], 0
	mov	QWORD PTR cmdsave[r15+rax*8], rbx

; 1044 :             } else {

	jmp	SHORT $LN7@ParseCmdli
$LN8@ParseCmdli:

; 1045 :                 strcpy( paramfile, str ); /* fixme: no overflow check */

	lea	rdx, QWORD PTR paramfile$[rsp]
	mov	rcx, rbx
	sub	rdx, rbx
	npad	6
$LL24@ParseCmdli:
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx+rcx-1], al
	jne	SHORT $LL24@ParseCmdli

; 1046 :                 cmdsave[rspidx] = str + strlen(str);

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	dec	rcx
	add	rcx, rbx
	mov	QWORD PTR cmdsave, rcx
$LN7@ParseCmdli:

; 1047 :             }
; 1048 : #else
; 1049 :             cmdsave[rspidx] = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );
; 1050 : #endif
; 1051 :             cmdbuffers[rspidx] = NULL;
; 1052 :             str = NULL;
; 1053 :             if ( paramfile[0] )

	cmp	BYTE PTR paramfile$[rsp], 0
	movsxd	rax, r8d
	mov	QWORD PTR cmdbuffers[r15+rax*8], rbp
	je	SHORT $LN139@ParseCmdli

; 1054 :                 str = getenv( paramfile );

	lea	rcx, QWORD PTR paramfile$[rsp]
	call	getenv

; 1055 :             if( str == NULL ) {

	test	rax, rax
	mov	rbx, rax
	jne	$LN144@ParseCmdli
$LN139@ParseCmdli:

; 1056 :                 str = ReadParamFile( paramfile );

	lea	rdx, OFFSET FLAT:$SG6143
	lea	rcx, QWORD PTR paramfile$[rsp]
	mov	rbx, rbp
	call	fopen
	test	rax, rax
	mov	rsi, rax
	jne	SHORT $LN59@ParseCmdli
	call	ErrnoStr
	lea	rdx, QWORD PTR paramfile$[rsp]
	lea	ecx, QWORD PTR [rsi+106]
	mov	r8, rax
	call	Fatal
	jmp	$LN60@ParseCmdli
$LN59@ParseCmdli:
	xor	edx, edx
	mov	rcx, rax
	lea	r8d, QWORD PTR [rdx+2]
	call	fseek
	test	eax, eax
	jne	SHORT $LN58@ParseCmdli
	mov	rcx, rsi
	call	ftell
	mov	rcx, rsi
	movsxd	rbp, eax
	call	rewind
	lea	edx, DWORD PTR [rbp+1]
	movsxd	rcx, edx
	call	MemAlloc
	mov	r9, rsi
	mov	r8, rbp
	mov	rcx, rax
	mov	edx, 1
	mov	rbx, rax
	call	fread
	mov	BYTE PTR [rbp+rbx], 0
$LN58@ParseCmdli:
	mov	rcx, rsi
	call	fclose
	test	ebp, ebp
	jne	SHORT $LN57@ParseCmdli
	mov	rbx, rbp
	jmp	SHORT $LN60@ParseCmdli
$LN57@ParseCmdli:
	cmp	BYTE PTR [rbx], 0
	mov	rax, rbx
	je	SHORT $LN55@ParseCmdli
	npad	2
$LL56@ParseCmdli:
	movzx	ecx, BYTE PTR [rax]
	cmp	cl, 13
	je	SHORT $LN53@ParseCmdli
	cmp	cl, 10
	jne	SHORT $LN54@ParseCmdli
$LN53@ParseCmdli:
	mov	BYTE PTR [rax], 32			; 00000020H
$LN54@ParseCmdli:
	cmp	cl, 26
	je	SHORT $LN127@ParseCmdli
	inc	rax
	cmp	BYTE PTR [rax], 0
	jne	SHORT $LL56@ParseCmdli

; 1071 :                 str = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );

	jmp	SHORT $LN55@ParseCmdli
$LN127@ParseCmdli:

; 1056 :                 str = ReadParamFile( paramfile );

	mov	BYTE PTR [rax], 0
$LN55@ParseCmdli:
	xor	ebp, ebp
$LN60@ParseCmdli:

; 1057 :                 cmdbuffers[rspidx] = str;
; 1058 :                 if ( str == NULL ) {

	test	rbx, rbx
	movsxd	r8, DWORD PTR rspidx
	mov	QWORD PTR cmdbuffers[r15+r8*8], rbx
	jne	SHORT $LN4@ParseCmdli

; 1059 :                     str = cmdsave[rspidx];

	mov	rbx, QWORD PTR cmdsave[r15+r8*8]

; 1060 :                     break;

	jmp	SHORT $LN14@ParseCmdli
$LN144@ParseCmdli:
	mov	r8d, DWORD PTR rspidx
$LN4@ParseCmdli:

; 1061 :                 }
; 1062 :             }
; 1063 :             rspidx++;

	inc	r8d
	mov	DWORD PTR rspidx, r8d
$LN14@ParseCmdli:

; 1009 :         }
; 1010 : 
; 1011 :     /* enable next line if debug log is to be active, but -dt cannot be set */
; 1012 :     //Set_dt();
; 1013 : 
; 1014 :     for( ; str; ) {

	test	rbx, rbx
	jne	$LL17@ParseCmdli
$LN16@ParseCmdli:

; 1088 :         }
; 1089 :     }
; 1090 :     *cmdline = str;

	mov	QWORD PTR [r13], rbx
$LN145@ParseCmdli:

; 1091 :     return( NULL );

	xor	eax, eax
$LN22@ParseCmdli:
	mov	r15, QWORD PTR [rsp+584]
	mov	r14, QWORD PTR [rsp+592]
	mov	r13, QWORD PTR [rsp+600]
	mov	r12, QWORD PTR [rsp+608]
	mov	rdi, QWORD PTR [rsp+648]
	mov	rsi, QWORD PTR [rsp+640]
	mov	rbp, QWORD PTR [rsp+632]
	mov	rbx, QWORD PTR [rsp+624]

; 1092 : }

	add	rsp, 616				; 00000268H
	ret	0
$LN128@ParseCmdli:

; 1035 :                 EmitErr( NESTING_LEVEL_TOO_DEEP );

	mov	ecx, 100				; 00000064H
	call	EmitErr

; 1036 :                 *cmdline = "";

	lea	rdx, OFFSET FLAT:$SG6247
	mov	QWORD PTR [r13], rdx

; 1037 :                 return( NULL );

	jmp	SHORT $LN145@ParseCmdli
$LN3@ParseCmdli:

; 1064 :             break;
; 1065 :         default: /* collect  file name */
; 1066 : #if BUILD_TARGET
; 1067 :             set_default_build_target();
; 1068 : #endif
; 1069 : #if 1 /* v2.06: activated (was removed in v2.05). Needed for quoted filenames */
; 1070 :             if ( rspidx ) {

	test	r8d, r8d
	je	$LN2@ParseCmdli

; 1071 :                 str = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );

	cmp	BYTE PTR [rbx], 34			; 00000022H
	lea	rcx, QWORD PTR paramfile$[rsp]
	je	SHORT $LN132@ParseCmdli
$is_quote$6978:
	test	r12d, r12d
	je	SHORT $LN77@ParseCmdli
	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	SHORT $LN77@ParseCmdli
	cmp	al, 32					; 00000020H
	je	SHORT $LN77@ParseCmdli
	cmp	al, 9
	je	SHORT $LN77@ParseCmdli
	mov	BYTE PTR [rcx], al
	inc	rcx
	inc	rbx
	dec	r12d
	jmp	SHORT $is_quote$6978
$LN132@ParseCmdli:
	inc	rbx
$LL79@ParseCmdli:
	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	SHORT $LN77@ParseCmdli
	cmp	al, 34					; 00000022H
	je	SHORT $LN133@ParseCmdli
	cmp	al, 92					; 0000005cH
	jne	SHORT $LN75@ParseCmdli
	cmp	BYTE PTR [rbx+1], 34			; 00000022H
	lea	rax, QWORD PTR [rbx+1]
	cmove	rbx, rax
$LN75@ParseCmdli:
	movzx	eax, BYTE PTR [rbx]
	inc	rcx
	inc	rbx
	dec	r12d
	mov	BYTE PTR [rcx-1], al
	jne	SHORT $LL79@ParseCmdli
	jmp	SHORT $LN77@ParseCmdli
$LN133@ParseCmdli:
	inc	rbx
$LN77@ParseCmdli:
	mov	BYTE PTR [rcx], 0

; 1072 :                 get_fname( OPTN_ASM_FN, paramfile );

	lea	rcx, QWORD PTR paramfile$[rsp]
	call	GetFNamePart
	cmp	BYTE PTR [rax], 0
	jne	SHORT $LN87@ParseCmdli
	mov	rcx, QWORD PTR DefaultDir
	test	rcx, rcx
	je	SHORT $LN85@ParseCmdli
	call	MemFree
$LN85@ParseCmdli:
	xor	eax, eax
	lea	rdi, QWORD PTR paramfile$[rsp]
	mov	rcx, -1
	repne scasb
	not	rcx
	call	MemAlloc
	lea	rdx, QWORD PTR paramfile$[rsp]
	mov	QWORD PTR DefaultDir, rax
$LL90@ParseCmdli:
	movzx	ecx, BYTE PTR [rdx]
	inc	rax
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL90@ParseCmdli

; 1078 :             }
; 1079 : #else
; 1080 :             str = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );
; 1081 :             Options.names[ASM] = MemAlloc( strlen( paramfile ) + 1 );
; 1082 :             strcpy( Options.names[ASM], paramfile );
; 1083 : #endif
; 1084 :             DebugMsg(("ParseCmdLine: file=>%s< rest=>%s<\n", Options.names[ASM], str ? str : "NULL" ));
; 1085 :             (*pCntArgs)++;

	inc	DWORD PTR [r14]

; 1086 :             *cmdline = str;

	mov	QWORD PTR [r13], rbx

; 1087 :             return( Options.names[ASM] );

	mov	rax, QWORD PTR Options+16
	jmp	$LN22@ParseCmdli

; 1072 :                 get_fname( OPTN_ASM_FN, paramfile );

$LN87@ParseCmdli:
	lea	rcx, QWORD PTR paramfile$[rsp]
	mov	BYTE PTR name$7007[rsp], 0
	cmp	rax, rcx
	jne	SHORT $LN84@ParseCmdli
	mov	rcx, QWORD PTR DefaultDir
	test	rcx, rcx
	je	SHORT $LN84@ParseCmdli
	lea	rdx, QWORD PTR name$7007[rsp]
	sub	rdx, rcx
	npad	4
$LL91@ParseCmdli:
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx+rcx-1], al
	jne	SHORT $LL91@ParseCmdli
$LN84@ParseCmdli:
	xor	eax, eax
	lea	rdi, QWORD PTR name$7007[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	lea	rdx, QWORD PTR paramfile$[rsp]
	npad	8
$LL141@ParseCmdli:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL141@ParseCmdli
	mov	rcx, QWORD PTR Options+16
	test	rcx, rcx
	je	SHORT $LN83@ParseCmdli
	call	MemFree
$LN83@ParseCmdli:
	xor	eax, eax
	lea	rdi, QWORD PTR name$7007[rsp]
	mov	rcx, -1
	repne scasb
	not	rcx
	call	MemAlloc
	lea	rdx, QWORD PTR name$7007[rsp]
	mov	QWORD PTR Options+16, rax
	npad	6
$LL92@ParseCmdli:
	movzx	ecx, BYTE PTR [rdx]
	inc	rax
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL92@ParseCmdli

; 1078 :             }
; 1079 : #else
; 1080 :             str = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );
; 1081 :             Options.names[ASM] = MemAlloc( strlen( paramfile ) + 1 );
; 1082 :             strcpy( Options.names[ASM], paramfile );
; 1083 : #endif
; 1084 :             DebugMsg(("ParseCmdLine: file=>%s< rest=>%s<\n", Options.names[ASM], str ? str : "NULL" ));
; 1085 :             (*pCntArgs)++;

	inc	DWORD PTR [r14]

; 1086 :             *cmdline = str;

	mov	QWORD PTR [r13], rbx

; 1087 :             return( Options.names[ASM] );

	mov	rax, QWORD PTR Options+16
	jmp	$LN22@ParseCmdli
$LN2@ParseCmdli:

; 1073 :             } else {
; 1074 :                 int len;
; 1075 :                 len = strlen( str );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	lea	rsi, QWORD PTR [rcx-1]

; 1076 :                 get_fname( OPTN_ASM_FN, str );

	mov	rcx, rbx
	call	GetFNamePart
	cmp	BYTE PTR [rax], 0
	jne	SHORT $LN97@ParseCmdli
	mov	rcx, QWORD PTR DefaultDir
	test	rcx, rcx
	je	SHORT $LN95@ParseCmdli
	call	MemFree
$LN95@ParseCmdli:
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	call	MemAlloc
	mov	rdx, rbx
	mov	QWORD PTR DefaultDir, rax
	npad	10
$LL100@ParseCmdli:
	movzx	ecx, BYTE PTR [rdx]
	inc	rax
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL100@ParseCmdli
	jmp	$LN98@ParseCmdli
$LN97@ParseCmdli:
	cmp	rax, rbx
	mov	BYTE PTR name$7024[rsp], 0
	jne	SHORT $LN94@ParseCmdli
	mov	rcx, QWORD PTR DefaultDir
	test	rcx, rcx
	je	SHORT $LN94@ParseCmdli
	lea	rdx, QWORD PTR name$7024[rsp]
	sub	rdx, rcx
	npad	7
$LL101@ParseCmdli:
	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdx+rcx-1], al
	jne	SHORT $LL101@ParseCmdli
$LN94@ParseCmdli:
	xor	eax, eax
	lea	rdi, QWORD PTR name$7024[rsp]
	mov	rcx, -1
	repne scasb
	xor	ecx, ecx
	npad	13
$LL140@ParseCmdli:
	movzx	eax, BYTE PTR [rbx+rcx]
	inc	rcx
	test	al, al
	mov	BYTE PTR [rdi+rcx-2], al
	jne	SHORT $LL140@ParseCmdli
	mov	rcx, QWORD PTR Options+16
	test	rcx, rcx
	je	SHORT $LN93@ParseCmdli
	call	MemFree
$LN93@ParseCmdli:
	xor	eax, eax
	lea	rdi, QWORD PTR name$7024[rsp]
	mov	rcx, -1
	repne scasb
	not	rcx
	call	MemAlloc
	lea	rdx, QWORD PTR name$7024[rsp]
	mov	QWORD PTR Options+16, rax
	npad	6
$LL102@ParseCmdli:
	movzx	ecx, BYTE PTR [rdx]
	inc	rax
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL102@ParseCmdli
$LN98@ParseCmdli:

; 1077 :                 str += len;

	movsxd	rax, esi
	add	rbx, rax

; 1078 :             }
; 1079 : #else
; 1080 :             str = GetNameToken( paramfile, str, sizeof( paramfile ) - 1, '@' );
; 1081 :             Options.names[ASM] = MemAlloc( strlen( paramfile ) + 1 );
; 1082 :             strcpy( Options.names[ASM], paramfile );
; 1083 : #endif
; 1084 :             DebugMsg(("ParseCmdLine: file=>%s< rest=>%s<\n", Options.names[ASM], str ? str : "NULL" ));
; 1085 :             (*pCntArgs)++;

	inc	DWORD PTR [r14]

; 1086 :             *cmdline = str;

	mov	QWORD PTR [r13], rbx

; 1087 :             return( Options.names[ASM] );

	mov	rax, QWORD PTR Options+16
	jmp	$LN22@ParseCmdli
	npad	3
$LN143@ParseCmdli:

; 1092 : }

	DD	$LN12@ParseCmdli
	DD	$LN13@ParseCmdli
	DD	$LN11@ParseCmdli
	DD	$LN10@ParseCmdli
	DD	$LN3@ParseCmdli
$LN142@ParseCmdli:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
ParseCmdline ENDP
_TEXT	ENDS
PUBLIC	CmdlineFini
xdata	SEGMENT
$unwind$CmdlineFini DD 096e01H
	DD	07546eH
	DD	097413H
	DD	08640eH
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$CmdlineFini DD @imagerel($LN24#)
	DD	@imagerel($LN24#+181)
	DD	@imagerel($unwind$CmdlineFini#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
CmdlineFini PROC NEAR

; 1097 : {

$LN24:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi

; 1098 :     int i;
; 1099 :     DebugMsg(("CmdLineFini enter\n" ));
; 1100 :     for ( i = 0; i < NUM_FILE_TYPES; i++ ) {

	lea	rdi, OFFSET FLAT:DefaultDir+32
	lea	rbx, OFFSET FLAT:DefaultDir
	xor	esi, esi
$LL13@CmdlineFin:

; 1101 :         if ( DefaultDir[i] != NULL ) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN12@CmdlineFin

; 1102 :             MemFree( DefaultDir[i] );

	call	MemFree

; 1103 :             DefaultDir[i] = NULL;

	mov	QWORD PTR [rbx], rsi
$LN12@CmdlineFin:
	add	rbx, 8
	cmp	rbx, rdi
	jl	SHORT $LL13@CmdlineFin

; 1104 :         }
; 1105 :     }
; 1106 :     for ( i = 0; i < OPTN_LAST; i++ )

	lea	rbx, OFFSET FLAT:Options+16
	lea	rdi, OFFSET FLAT:Options+96
	npad	6
$LL9@CmdlineFin:

; 1107 :         if ( Options.names[i] != NULL ) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN8@CmdlineFin

; 1108 :             MemFree( Options.names[i] );

	call	MemFree

; 1109 :             Options.names[i] = NULL;

	mov	QWORD PTR [rbx], rsi
$LN8@CmdlineFin:
	add	rbx, 8
	cmp	rbx, rdi
	jl	SHORT $LL9@CmdlineFin
	mov	QWORD PTR [rsp+56], rbp

; 1110 :         }
; 1111 :     for ( i = 0; i < OPTQ_LAST; i++ ) {

	lea	rbp, OFFSET FLAT:Options+120
$LL5@CmdlineFin:

; 1112 :         struct qitem *p;
; 1113 :         struct qitem *q;
; 1114 :         for ( q = Options.queues[i]; q; ) {

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN1@CmdlineFin
	npad	3
$LL2@CmdlineFin:

; 1115 :             p = q->next;

	mov	rbx, QWORD PTR [rcx]

; 1116 :             MemFree( q );

	call	MemFree
	test	rbx, rbx

; 1117 :             q = p;

	mov	rcx, rbx
	jne	SHORT $LL2@CmdlineFin
$LN1@CmdlineFin:

; 1118 :         }
; 1119 :         Options.queues[i] = NULL;

	mov	QWORD PTR [rdi], rsi
	add	rdi, 8
	cmp	rdi, rbp
	jl	SHORT $LL5@CmdlineFin
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 1120 :     }
; 1121 :     DebugMsg(("CmdLineFini exit\n" ));
; 1122 :     return;
; 1123 : }

	add	rsp, 40					; 00000028H
	ret	0
CmdlineFini ENDP
_TEXT	ENDS
END
