; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	banner_printed
_BSS	SEGMENT
banner_printed DB 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
usage	DB	'   HJWasm [options] asm-file [options] [asm-file] ... [@'
	DB	'env_var]', 0aH, 0aH, 00H, 'options:', 00H, '-<0|1|..|10>[p]', 00H
	DB	'Set CPU: 0=8086 (default), 1=80186, 2=80286, 3=80386,', 00H, 00H
	DB	'4=80486, 5=Pentium, 6=PPro, 7=P2, 8=P3, 9=P4, 10=x86-64;', 00H
	DB	00H, '<p> allows privileged instructions', 00H, '-c', 00H, 'As'
	DB	'semble without linking (always set)', 00H, '-C<p|u|x>', 00H, 'S'
	DB	'et OPTION CASEMAP: p=NONE, u=ALL, x=NOTPUBLIC (default)', 00H
	DB	'-archSSE', 00H, 'Set OPTION ARCH: SSE = Use SSE in generated '
	DB	'code', 00H, '-archAVX', 00H, 'Set OPTION ARCH: AVX = Use AVX '
	DB	'in generated code (default)', 00H, '-D<name>[=text]', 00H, 'D'
	DB	'efine text macro', 00H, '-e<number>', 00H, 'Set error limit n'
	DB	'umber (default=50)', 00H, '-EP', 00H, 'Output preprocessed li'
	DB	'sting to stdout', 00H, '-eq', 00H, 'don''t display error mess'
	DB	'ages', 00H, '-Fd[=<file_name>]', 00H, 'Write import definitio'
	DB	'n file', 00H, '-Fi<file_name>', 00H, 'Force <file_name> to be'
	DB	' included', 00H, '-Fs[=<file_name>]', 00H, 'Write symbolic de'
	DB	'bug info', 00H, '-Fl[=<file_name>]', 00H, 'Write listing file'
	DB	00H, '-Fo<file_name>', 00H, 'Set object file name', 00H, '-Fw<'
	DB	'file_name>', 00H, 'Set errors file name', 00H, '-FPi', 00H, '8'
	DB	'0x87 instructions with emulation fixups', 00H, '-FPi87', 00H, '8'
	DB	'0x87 instructions (default)', 00H, '-fpc', 00H, 'Disallow flo'
	DB	'ating-point instructions (.NO87)', 00H, '-fp<n>', 00H, 'Set F'
	DB	'PU, <n> is: 0=8087 (default), 2=80287, 3=80387', 00H, '-G<c|d'
	DB	'|r|z>', 00H, 'Use Pascal, C, Fastcall or Stdcall calling conv'
	DB	'ention', 00H, '-I<directory>', 00H, 'Add directory to list of'
	DB	' include directories', 00H, '-m<t|s|c|m|l|h|f>', 00H, 'Set me'
	DB	'mory model:', 00H, 00H, '(Tiny, Small, Compact, Medium, Large'
	DB	', Huge, Flat)', 00H, '-nc=<name>', 00H, 'Set class name of co'
	DB	'de segment', 00H, '-n<d|m|t>=<name>', 00H, 'Set name of d)ata'
	DB	' segment, m)odule or t)ext segment', 00H, '-q, -nologo', 00H, 'D'
	DB	'on''t display version and copyright information', 00H, '-Sa', 00H
	DB	'Maximize source listing', 00H, '-safeseh', 00H, 'Assert all e'
	DB	'xception handlers are declared', 00H, '-Sf', 00H, 'Generate f'
	DB	'irst pass listing', 00H, '-Sg', 00H, 'Display generated code '
	DB	'in listing', 00H, '-Sn', 00H, 'Suppress symbol-table listing', 00H
	DB	'-Sx', 00H, 'List false conditionals', 00H, '-w', 00H, 'Same a'
	DB	's /W0 /WX', 00H, '-W<number>', 00H, 'Set warning level number'
	DB	' (default=2, max=4)', 00H, '-WX', 00H, 'Treat all warnings as'
	DB	' errors', 00H, '-X', 00H, 'Ignore INCLUDE environment path', 00H
	DB	'-zcm', 00H, 'C names are decorated with ''_'' prefix (default'
	DB	')', 00H, '-zcw', 00H, 'No name decoration for C symbols', 00H
	DB	'-Zd', 00H, 'Add line number debug info (OMF & COFF only)', 00H
	DB	'-Zf', 00H, 'Make all symbols public', 00H, '-zf<0|1>', 00H, 'S'
	DB	'et FASTCALL type: 0=MS VC style (default),', 00H, 00H, '1=OW '
	DB	'register calling convention', 00H, '-Zg', 00H, 'Generated cod'
	DB	'e is to exactly match Masm''s one', 00H, '-Zi[0|1|2|3]', 00H, 'A'
	DB	'dd symbolic debug info (OMF & COFF): 0=globals', 00H, 00H, '1'
	DB	'= +locals, 2= +types (default), 3= +constants', 00H, '-zlc', 00H
	DB	'No OMF records about data in code', 00H, '-zld', 00H, 'No OMF'
	DB	' records about far call optimization', 00H, '-zl<f|p|s>', 00H
	DB	'Suppress items in COFF symbol table: f=no .file entry,', 00H, 00H
	DB	'p=no static procs, s=no auxiliary entries for sections', 00H, '-'
	DB	'Zm', 00H, 'Masm v5.1 compatibility', 00H, '-Zne', 00H, 'Disab'
	DB	'le syntax extensions not supported by Masm', 00H, '-Zp[n]', 00H
	DB	'Set structure alignment, n=<1|2|4|8|16|32>', 00H, '-Zs', 00H, 'P'
	DB	'erform syntax check only', 00H, '-zt<0|1|2>', 00H, 'Set STDCA'
	DB	'LL symbol decoration: 0=No name decoration,', 00H, 00H, '1=No'
	DB	' ''@size'' suffix for functions, 2=Full (default)', 00H, '-Zv'
	DB	'8', 00H, 'Enable Masm v8+ PROC visibility', 00H, '-zze', 00H, 'N'
	DB	'o name decoration for exported symbols', 00H, '-zzs', 00H, 'S'
	DB	'tore decorated name of start address (COFF only)', 00H, '@env'
	DB	'_var', 00H, 'Environment variable or file containing further '
	DB	'commands', 00H, 'output formats:', 00H, 00H, '-bin', 00H, 'pl'
	DB	'ain binary file', 00H, '-coff', 00H, 'COFF object file', 00H, '-'
	DB	'elf', 00H, '32-bit ELF object file', 00H, '-elf64', 00H, '64-'
	DB	'bit ELF object file', 00H, '-mz', 00H, 'DOS MZ binary file', 00H
	DB	'-omf', 00H, 'OMF object file (default)', 00H, '-pe', 00H, 'PE'
	DB	' binary file, 32/64-bit', 00H, '-win64', 00H, '64-bit COFF ob'
	DB	'ject file', 00H, 0aH, 00H
CONST	ENDS
_DATA	SEGMENT
$SG5561	DB	'%s, %s', 0aH, 00H
$SG5569	DB	'%-20s %s', 0aH, 00H
	ORG $+6
$SG5598	DB	'%s A%4u: ', 00H
	ORG $+2
$SG5599	DB	0aH, 00H
	ORG $+2
$SG5601	DB	'                           %s', 00H
	ORG $+2
$SG5615	DB	'w', 00H
	ORG $+2
$SG5656	DB	'ENOENT', 00H
_DATA	ENDS
PUBLIC	write_logo
EXTRN	printf:NEAR
EXTRN	MsgGetEx:NEAR
xdata	SEGMENT
$unwind$write_logo DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$write_logo DD @imagerel($LN4#)
	DD	@imagerel($LN4#+82)
	DD	@imagerel($unwind$write_logo#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\errmsg.c
pdata	ENDS
_TEXT	SEGMENT
write_logo PROC NEAR

; 139  : {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 140  :     if( banner_printed == FALSE ) {

	cmp	BYTE PTR banner_printed, 0
	jne	SHORT $LN1@write_logo

; 141  :         banner_printed = TRUE;
; 142  :         printf( "%s, %s\n", MsgGetEx( MSG_HJWASM ), MsgGetEx( MSG_HJWASM2 ) );

	mov	ecx, 3
	mov	BYTE PTR banner_printed, 1
	call	MsgGetEx
	mov	ecx, 2
	mov	rbx, rax
	call	MsgGetEx
	lea	rcx, OFFSET FLAT:$SG5561
	mov	rdx, rax
	mov	r8, rbx
	call	printf

; 143  :         return( 4 ); /* return number of lines printed */

	mov	eax, 4

; 146  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN1@write_logo:

; 144  :     }
; 145  :     return( 0 );

	xor	eax, eax

; 146  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
write_logo ENDP
_TEXT	ENDS
PUBLIC	PrintUsage
xdata	SEGMENT
$unwind$PrintUsage DD 054e01H
	DD	08344eH
	DD	097410H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$PrintUsage DD @imagerel($LN10#)
	DD	@imagerel($LN10#+157)
	DD	@imagerel($unwind$PrintUsage#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
PrintUsage PROC NEAR

; 150  : {

$LN10:
	sub	rsp, 40					; 00000028H

; 151  :     const char *p;
; 152  :     write_logo();

	cmp	BYTE PTR banner_printed, 0
	mov	QWORD PTR [rsp+72], rdi
	jne	SHORT $LN5@PrintUsage
	mov	ecx, 3
	mov	BYTE PTR banner_printed, 1
	call	MsgGetEx
	mov	ecx, 2
	mov	rdi, rax
	call	MsgGetEx
	lea	rcx, OFFSET FLAT:$SG5561
	mov	rdx, rax
	mov	r8, rdi
	call	printf
$LN5@PrintUsage:

; 153  :     for ( p = usage; *p != '\n'; ) {

	lea	rdx, OFFSET FLAT:usage
	mov	QWORD PTR [rsp+64], rbx
	npad	2
$LL2@PrintUsage:

; 154  :         const char *p2 = p + strlen( p ) + 1;

	xor	eax, eax
	mov	rdi, rdx
	mov	rcx, -1
	repne scasb
	not	rcx
	lea	rbx, QWORD PTR [rcx+rdx]

; 155  :         printf("%-20s %s\n", p, p2 );

	lea	rcx, OFFSET FLAT:$SG5569
	mov	r8, rbx
	call	printf

; 156  :         p = p2 + strlen( p2 ) + 1;

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	lea	rdx, QWORD PTR [rcx+rbx]
	cmp	BYTE PTR [rdx], 10
	jne	SHORT $LL2@PrintUsage
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 157  :     }
; 158  : }

	add	rsp, 40					; 00000028H
	ret	0
PrintUsage ENDP
_TEXT	ENDS
EXTRN	LstNL:NEAR
EXTRN	LstPrintf:NEAR
EXTRN	LstWrite:NEAR
EXTRN	GetCurrOffset:NEAR
EXTRN	Parse_Pass:DWORD
EXTRN	ModuleInfo:BYTE
EXTRN	vsprintf:NEAR
EXTRN	sprintf:NEAR
EXTRN	fwrite:NEAR
EXTRN	GetCurrSrcPos:NEAR
xdata	SEGMENT
$unwind$PutMsg DD 0a1d01H
	DD	096c41dH
	DD	09b7419H
	DD	09a6415H
	DD	0983411H
	DD	097010aH
xdata	ENDS
pdata	SEGMENT
$pdata$PutMsg DD @imagerel(PutMsg#)
	DD	@imagerel(PutMsg#+87)
	DD	@imagerel($unwind$PutMsg#)
pdata	ENDS
xdata	SEGMENT
$chain$4$PutMsg DD 020821H
	DD	0995408H
	DD	@imagerel(PutMsg#)
	DD	@imagerel(PutMsg#+87)
	DD	@imagerel($unwind$PutMsg#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$PutMsg DD @imagerel(PutMsg#+87)
	DD	@imagerel(PutMsg#+285)
	DD	@imagerel($chain$4$PutMsg#)
pdata	ENDS
xdata	SEGMENT
$chain$5$PutMsg DD 021H
	DD	@imagerel(PutMsg#)
	DD	@imagerel(PutMsg#+87)
	DD	@imagerel($unwind$PutMsg#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$PutMsg DD @imagerel(PutMsg#+285)
	DD	@imagerel(PutMsg#+388)
	DD	@imagerel($chain$5$PutMsg#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 32
buffer$ = 48
fp$ = 1216
severity$ = 1224
msgnum$ = 1232
args$ = 1240
PutMsg	PROC NEAR

; 162  : {

	mov	rax, rsp
	sub	rsp, 1208				; 000004b8H

; 163  :     int             i,j;
; 164  :     const char      *type;
; 165  :     const char      *pMsg;
; 166  :     char            buffer[MAX_LINE_LEN+128];
; 167  : 
; 168  :     if( fp != NULL ) {

	test	rcx, rcx
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	QWORD PTR [rax-8], r12
	mov	esi, r8d
	mov	r12, r9
	mov	ebx, edx
	mov	rdi, rcx
	je	$LN1@PutMsg

; 169  : 
; 170  :         if ( severity && ( j = GetCurrSrcPos( buffer ) ) ) {

	test	edx, edx
	je	SHORT $LN9@PutMsg
	lea	rcx, QWORD PTR buffer$[rsp]
	call	GetCurrSrcPos
	test	eax, eax
	je	SHORT $LN9@PutMsg

; 171  :             fwrite( buffer, 1, j, fp );

	lea	rcx, QWORD PTR buffer$[rsp]
	movsxd	r8, eax
	mov	r9, rdi
	mov	edx, 1
	call	fwrite
$LN9@PutMsg:

; 172  :         }
; 173  :         pMsg = MsgGetEx( msgnum );

	mov	ecx, esi
	mov	QWORD PTR [rsp+1224], rbp
	call	MsgGetEx

; 174  :         switch (severity ) {

	mov	edx, ebx
	dec	edx
	mov	rbp, rax
	je	SHORT $LN6@PutMsg
	dec	edx
	je	SHORT $LN5@PutMsg
	cmp	edx, 2
	je	SHORT $LN4@PutMsg

; 178  :         default:  type = NULL; i = 0; break;

	xor	esi, esi
	jmp	SHORT $LN2@PutMsg
$LN4@PutMsg:

; 177  :         case 4:  type = MsgGetEx( MSG_WARNING_PREFIX ); break;

	mov	ecx, 5
	call	MsgGetEx
	jmp	SHORT $LN7@PutMsg
$LN5@PutMsg:

; 176  :         case 2:  type = MsgGetEx( MSG_ERROR_PREFIX );   break;

	mov	ecx, 4
	call	MsgGetEx
	jmp	SHORT $LN7@PutMsg
$LN6@PutMsg:

; 175  :         case 1:  type = MsgGetEx( MSG_FATAL_PREFIX );   break;

	mov	ecx, 6
	call	MsgGetEx
$LN7@PutMsg:

; 179  :         }
; 180  :         if ( type )

	test	rax, rax
	je	SHORT $LN13@PutMsg

; 181  :             i = sprintf( buffer, "%s A%4u: ", type, severity * 1000 + msgnum );

	mov	r9d, ebx
	lea	rdx, OFFSET FLAT:$SG5598
	lea	rcx, QWORD PTR buffer$[rsp]
	mov	r8, rax
	imul	r9d, 1000				; 000003e8H
	add	r9d, esi
	call	sprintf
	mov	esi, eax
	jmp	SHORT $LN2@PutMsg
$LN13@PutMsg:
	mov	esi, DWORD PTR i$[rsp]
$LN2@PutMsg:

; 182  :         i += vsprintf( buffer+i, pMsg, args );

	movsxd	rax, esi
	mov	r8, r12
	mov	rdx, rbp
	lea	rcx, QWORD PTR buffer$[rsp+rax]
	call	vsprintf

; 183  :         //buffer[i] = NULLC;
; 184  : 
; 185  :         fwrite( buffer, 1, i, fp );

	lea	rcx, QWORD PTR buffer$[rsp]
	mov	r9, rdi
	add	esi, eax
	mov	edx, 1
	movsxd	r8, esi
	call	fwrite

; 186  :         fwrite( "\n", 1, 1, fp );

	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG5599
	mov	r8, rdx
	mov	r9, rdi
	call	fwrite

; 187  : 
; 188  :         /* if in Pass 1, add the error msg to the listing */
; 189  :         if ( CurrFile[LST] &&
; 190  :              severity &&
; 191  :              Parse_Pass == PASS_1 &&
; 192  :              fp == CurrFile[ERR] ) {

	cmp	QWORD PTR ModuleInfo+112, 0
	mov	rbp, QWORD PTR [rsp+1224]
	je	SHORT $LN1@PutMsg
	test	ebx, ebx
	je	SHORT $LN1@PutMsg
	cmp	DWORD PTR Parse_Pass, 0
	jne	SHORT $LN1@PutMsg
	cmp	rdi, QWORD PTR ModuleInfo+120
	jne	SHORT $LN1@PutMsg

; 193  :             LstWrite( LSTTYPE_DIRECTIVE, GetCurrOffset(), 0 );

	call	GetCurrOffset
	xor	r8d, r8d
	lea	ecx, QWORD PTR [r8+4]
	mov	edx, eax
	call	LstWrite

; 194  :             /* size of "blank" prefix to be explained! */
; 195  :             LstPrintf( "                           %s", buffer );

	lea	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, OFFSET FLAT:$SG5601
	call	LstPrintf

; 196  :             LstNL();

	call	LstNL
$LN1@PutMsg:
	mov	r12, QWORD PTR [rsp+1200]
	mov	rdi, QWORD PTR [rsp+1240]
	mov	rsi, QWORD PTR [rsp+1232]
	mov	rbx, QWORD PTR [rsp+1216]

; 197  :         }
; 198  :     }
; 199  : }

	add	rsp, 1208				; 000004b8H
	ret	0
PutMsg	ENDP
_TEXT	ENDS
PUBLIC	Fatal
PUBLIC	EmitErr
EXTRN	Options:BYTE
EXTRN	print_source_nesting_structure:NEAR
EXTRN	write_to_file:BYTE
xdata	SEGMENT
$unwind$EmitErr DD 011701H
	DD	04217H
xdata	ENDS
pdata	SEGMENT
$pdata$EmitErr DD @imagerel($LN43#)
	DD	@imagerel($LN43#+104)
	DD	@imagerel($unwind$EmitErr#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
msgnum$ = 48
EmitErr	PROC NEAR

; 248  : {

$LN43:
	mov	DWORD PTR [rsp+8], ecx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 40					; 00000028H

; 249  :     va_list args1, args2;
; 250  : 
; 251  : #ifdef DEBUG_OUT
; 252  :     printf( "%s\n", ModuleInfo.tokenarray ? ModuleInfo.tokenarray[0].tokpos : "" );
; 253  : #endif
; 254  :     va_start( args1, msgnum );
; 255  :     va_start( args2, msgnum );
; 256  :     PrtMsg( 2, msgnum, args1, args2 );

	mov	edx, ecx
	lea	r8, QWORD PTR msgnum$[rsp+8]
	lea	r9, QWORD PTR msgnum$[rsp+8]
	mov	ecx, 2
	call	PrtMsg

; 257  :     va_end( args1 );
; 258  :     va_end( args2 );
; 259  :     ModuleInfo.g.error_count++;

	inc	DWORD PTR ModuleInfo

; 260  :     write_to_file = FALSE;

	mov	BYTE PTR write_to_file, 0

; 261  :     print_source_nesting_structure();

	call	print_source_nesting_structure

; 262  :     if( Options.error_limit != -1  &&  ModuleInfo.g.error_count == Options.error_limit+1 )

	mov	eax, DWORD PTR Options+8
	cmp	eax, -1
	je	SHORT $LN42@EmitErr
	inc	eax
	cmp	DWORD PTR ModuleInfo, eax
	jne	SHORT $LN42@EmitErr

; 263  :         Fatal( TOO_MANY_ERRORS );

	mov	ecx, 113				; 00000071H
	call	Fatal
$LN42@EmitErr:

; 264  :     return( ERROR );

	mov	eax, -1

; 265  : }

	add	rsp, 40					; 00000028H
	ret	0
EmitErr	ENDP
_TEXT	ENDS
PUBLIC	EmitError
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
msgnum$ = 8
EmitError PROC NEAR

; 270  :     return( EmitErr( msgnum ) );
; 271  : }

	jmp	EmitErr
EmitError ENDP
_TEXT	ENDS
PUBLIC	ErrnoStr
EXTRN	myltoa:NEAR
EXTRN	_errno:NEAR
_BSS	SEGMENT
	ALIGN	4

?buffer@?1??ErrnoStr@@9@9 DB 020H DUP (?)		; `ErrnoStr'::`2'::buffer
_BSS	ENDS
xdata	SEGMENT
$unwind$ErrnoStr DD 010401H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$ErrnoStr DD @imagerel($LN5#)
	DD	@imagerel($LN5#+62)
	DD	@imagerel($unwind$ErrnoStr#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
ErrnoStr PROC NEAR

; 299  : {

$LN5:
	sub	rsp, 56					; 00000038H

; 300  :     static char buffer[32];
; 301  :     return( ( errno == ENOENT ) ? "ENOENT" : myltoa( errno, buffer, 10, FALSE, FALSE ) );

	call	_errno
	cmp	DWORD PTR [rax], 2
	jne	SHORT $LN3@ErrnoStr
	lea	rax, OFFSET FLAT:$SG5656

; 302  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN3@ErrnoStr:

; 300  :     static char buffer[32];
; 301  :     return( ( errno == ENOENT ) ? "ENOENT" : myltoa( errno, buffer, 10, FALSE, FALSE ) );

	call	_errno
	xor	r9d, r9d
	lea	rdx, OFFSET FLAT:?buffer@?1??ErrnoStr@@9@9
	mov	ecx, DWORD PTR [rax]
	lea	r8d, QWORD PTR [r9+10]
	mov	BYTE PTR [rsp+32], 0
	call	myltoa

; 302  : }

	add	rsp, 56					; 00000038H
	ret	0
ErrnoStr ENDP
_TEXT	ENDS
EXTRN	fflush:NEAR
EXTRN	_iob:BYTE
EXTRN	fopen:NEAR
xdata	SEGMENT
$unwind$PrtMsg DD 010401H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$PrtMsg DD @imagerel(PrtMsg#)
	DD	@imagerel(PrtMsg#+11)
	DD	@imagerel($unwind$PrtMsg#)
pdata	ENDS
xdata	SEGMENT
$chain$4$PrtMsg DD 0a1921H
	DD	06c419H
	DD	0b7414H
	DD	0a640fH
	DD	09540aH
	DD	083405H
	DD	@imagerel(PrtMsg#)
	DD	@imagerel(PrtMsg#+11)
	DD	@imagerel($unwind$PrtMsg#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$PrtMsg DD @imagerel(PrtMsg#+11)
	DD	@imagerel(PrtMsg#+255)
	DD	@imagerel($chain$4$PrtMsg#)
pdata	ENDS
xdata	SEGMENT
$chain$5$PrtMsg DD 080021H
	DD	06c400H
	DD	0b7400H
	DD	0a6400H
	DD	095400H
	DD	@imagerel(PrtMsg#)
	DD	@imagerel(PrtMsg#+11)
	DD	@imagerel($unwind$PrtMsg#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$PrtMsg DD @imagerel(PrtMsg#+255)
	DD	@imagerel(PrtMsg#+304)
	DD	@imagerel($chain$5$PrtMsg#)
pdata	ENDS
xdata	SEGMENT
$chain$6$PrtMsg DD 060021H
	DD	0b7400H
	DD	0a6400H
	DD	095400H
	DD	@imagerel(PrtMsg#)
	DD	@imagerel(PrtMsg#+11)
	DD	@imagerel($unwind$PrtMsg#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$PrtMsg DD @imagerel(PrtMsg#+304)
	DD	@imagerel(PrtMsg#+340)
	DD	@imagerel($chain$6$PrtMsg#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
severity$ = 64
msgnum$ = 72
args1$ = 80
args2$ = 88
PrtMsg	PROC NEAR

; 203  : {

	sub	rsp, 56					; 00000038H

; 204  : #ifndef __SW_BD
; 205  :     write_logo();

	cmp	BYTE PTR banner_printed, 0
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+88], rdi
	mov	QWORD PTR [rsp+48], r12
	mov	r12, r8
	mov	rbp, r9
	mov	edi, edx
	mov	esi, ecx
	jne	SHORT $LN7@PrtMsg
	mov	ecx, 3
	mov	BYTE PTR banner_printed, 1
	call	MsgGetEx
	mov	ecx, 2
	mov	rbx, rax
	call	MsgGetEx
	lea	rcx, OFFSET FLAT:$SG5561
	mov	rdx, rax
	mov	r8, rbx
	call	printf
$LN7@PrtMsg:

; 206  : #endif
; 207  :     /* open .err file if not already open and a name is given */
; 208  :     if( CurrFile[ERR] == NULL && CurrFName[ERR] != NULL ) {

	mov	rax, QWORD PTR ModuleInfo+120
	test	rax, rax
	jne	$LN3@PrtMsg
	mov	rcx, QWORD PTR ModuleInfo+152
	test	rcx, rcx
	je	SHORT $LN3@PrtMsg

; 209  :         CurrFile[ERR] = fopen( CurrFName[ERR], "w" );

	lea	rdx, OFFSET FLAT:$SG5615
	call	fopen

; 210  :         if( CurrFile[ERR] == NULL ) {

	test	rax, rax
	mov	QWORD PTR ModuleInfo+120, rax
	jne	SHORT $LN3@PrtMsg

; 211  :             /* v2.06: no fatal error anymore if error file cannot be written */
; 212  :             char *p = CurrFName[ERR];

	mov	rbx, QWORD PTR ModuleInfo+152

; 213  :             CurrFName[ERR] = NULL; /* set to NULL before EmitErr()! */
; 214  :             Options.no_error_disp = FALSE; /* disable -eq! */

	mov	BYTE PTR Options+12, al
	mov	QWORD PTR ModuleInfo+152, rax

; 215  :             EmitErr( CANNOT_OPEN_FILE, p, ErrnoStr() );

	call	_errno
	cmp	DWORD PTR [rax], 2
	jne	SHORT $LN12@PrtMsg
	lea	rax, OFFSET FLAT:$SG5656
	jmp	SHORT $LN13@PrtMsg
$LN12@PrtMsg:
	call	_errno
	xor	r9d, r9d
	lea	rdx, OFFSET FLAT:?buffer@?1??ErrnoStr@@9@9
	mov	ecx, DWORD PTR [rax]
	lea	r8d, QWORD PTR [r9+10]
	mov	BYTE PTR [rsp+32], 0
	call	myltoa
$LN13@PrtMsg:
	mov	r8, rax
	mov	rdx, rbx
	mov	ecx, 106				; 0000006aH
	call	EmitErr
	mov	rax, QWORD PTR ModuleInfo+120
$LN3@PrtMsg:

; 216  :             LclFree( p );
; 217  :         }
; 218  :     }
; 219  : 
; 220  :     /* v2.05: new option -eq */
; 221  :     if ( Options.no_error_disp == FALSE ) {

	cmp	BYTE PTR Options+12, 0
	mov	rbx, QWORD PTR [rsp+64]
	jne	SHORT $LN2@PrtMsg

; 222  :         PutMsg( errout, severity, msgnum, args1 );

	lea	rcx, OFFSET FLAT:_iob+48
	mov	r9, r12
	mov	r8d, edi
	mov	edx, esi
	call	PutMsg

; 223  :         fflush( errout );                       /* 27-feb-90 */

	lea	rcx, OFFSET FLAT:_iob+48
	call	fflush
	mov	rax, QWORD PTR ModuleInfo+120
$LN2@PrtMsg:

; 224  :     }
; 225  :     if( CurrFile[ERR] ) {

	test	rax, rax
	mov	r12, QWORD PTR [rsp+48]
	je	SHORT $LN1@PrtMsg

; 226  :         //Errfile_Written = TRUE;
; 227  :         PutMsg( CurrFile[ERR], severity, msgnum, args2 );

	mov	r9, rbp
	mov	r8d, edi
	mov	edx, esi
	mov	rcx, rax
	call	PutMsg
$LN1@PrtMsg:
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+72]

; 228  :     }
; 229  : }

	add	rsp, 56					; 00000038H
	ret	0
PrtMsg	ENDP
_TEXT	ENDS
PUBLIC	PrintNote
xdata	SEGMENT
$unwind$PrintNote DD 011701H
	DD	04217H
xdata	ENDS
pdata	SEGMENT
$pdata$PrintNote DD @imagerel($LN3#)
	DD	@imagerel($LN3#+47)
	DD	@imagerel($unwind$PrintNote#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
msgnum$ = 48
PrintNote PROC NEAR

; 235  : {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 40					; 00000028H

; 236  :     va_list args1, args2;
; 237  : 
; 238  :     va_start( args1, msgnum );
; 239  :     va_start( args2, msgnum );
; 240  : 
; 241  :     PrtMsg( 0, msgnum, args1, args2 );

	mov	edx, ecx
	lea	r8, QWORD PTR msgnum$[rsp+8]
	lea	r9, QWORD PTR msgnum$[rsp+8]
	xor	ecx, ecx
	call	PrtMsg

; 242  :     va_end( args1 );
; 243  :     va_end( args2 );
; 244  : }

	add	rsp, 40					; 00000028H
	ret	0
PrintNote ENDP
_TEXT	ENDS
PUBLIC	EmitWarn
xdata	SEGMENT
$unwind$EmitWarn DD 011201H
	DD	04212H
xdata	ENDS
pdata	SEGMENT
$pdata$EmitWarn DD @imagerel($LN6#)
	DD	@imagerel($LN6#+100)
	DD	@imagerel($unwind$EmitWarn#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
level$ = 48
msgnum$ = 56
EmitWarn PROC NEAR

; 275  : {

$LN6:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 40					; 00000028H

; 276  :     va_list args1, args2;
; 277  : 
; 278  :     if( level <= Options.warning_level ) {

	movzx	eax, BYTE PTR Options+13
	cmp	ecx, eax
	jg	SHORT $LN3@EmitWarn

; 279  : #ifdef DEBUG_OUT
; 280  :         printf( "%s\n", ModuleInfo.tokenarray ? ModuleInfo.tokenarray[0].tokpos : "" );
; 281  : #endif
; 282  :         va_start( args1, msgnum );
; 283  :         va_start( args2, msgnum );
; 284  :         if( !Options.warning_error ) {

	cmp	BYTE PTR Options+14, 0
	lea	r8, QWORD PTR msgnum$[rsp+8]
	lea	r9, QWORD PTR msgnum$[rsp+8]
	jne	SHORT $LN2@EmitWarn

; 285  :             PrtMsg( 4, msgnum, args1, args2 );

	mov	ecx, 4
	call	PrtMsg

; 286  :             ModuleInfo.g.warning_count++;

	inc	DWORD PTR ModuleInfo+4

; 290  :         }
; 291  :         va_end( args1 );
; 292  :         va_end( args2 );
; 293  :         print_source_nesting_structure();

	call	print_source_nesting_structure

; 294  :     }
; 295  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@EmitWarn:

; 287  :         } else {
; 288  :             PrtMsg( 2, msgnum, args1, args2 );

	mov	ecx, 2
	call	PrtMsg

; 289  :             ModuleInfo.g.error_count++;

	inc	DWORD PTR ModuleInfo

; 290  :         }
; 291  :         va_end( args1 );
; 292  :         va_end( args2 );
; 293  :         print_source_nesting_structure();

	call	print_source_nesting_structure
$LN3@EmitWarn:

; 294  :     }
; 295  : }

	add	rsp, 40					; 00000028H
	ret	0
EmitWarn ENDP
_TEXT	ENDS
EXTRN	exit:NEAR
EXTRN	longjmp:NEAR
EXTRN	jmpenv:BYTE
xdata	SEGMENT
$unwind$Fatal DD 011701H
	DD	04217H
xdata	ENDS
pdata	SEGMENT
$pdata$Fatal DD	@imagerel($LN5#)
	DD	@imagerel($LN5#+90)
	DD	@imagerel($unwind$Fatal#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
msgnum$ = 48
Fatal	PROC NEAR

; 310  : {

$LN5:
	mov	DWORD PTR [rsp+8], ecx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 40					; 00000028H

; 311  :     va_list     args1, args2;
; 312  : 
; 313  :     /* v2.11: call PrtMsg() instead of PutMsg().
; 314  :      * Makes the fatal error appear in the .ERR and .LST files
; 315  :      */
; 316  :     va_start( args1, msgnum );
; 317  :     va_start( args2, msgnum );
; 318  :     PrtMsg( 1, msgnum, args1, args2 );

	mov	edx, ecx
	lea	r8, QWORD PTR msgnum$[rsp+8]
	lea	r9, QWORD PTR msgnum$[rsp+8]
	mov	ecx, 1
	call	PrtMsg

; 319  :     va_end( args1 );
; 320  :     va_end( args2 );
; 321  : 
; 322  :     ModuleInfo.g.error_count++;

	inc	DWORD PTR ModuleInfo

; 323  :     //write_to_file = FALSE;
; 324  : 
; 325  :     /* setjmp() has been called in AssembleModule().
; 326  :      * if a fatal error happens outside of this function, longjmp()
; 327  :      * is NOT to be used ( out of memory condition, @cmd file open error, ... )
; 328  :      */
; 329  :     if ( CurrFName[ASM] )

	cmp	QWORD PTR ModuleInfo+128, 0
	je	SHORT $LN1@Fatal

; 330  :         longjmp( jmpenv, 2 );

	lea	rcx, OFFSET FLAT:jmpenv
	mov	edx, 2
	call	longjmp
	int	3
$LN1@Fatal:

; 331  : 
; 332  :     exit(1);

	mov	ecx, 1
	call	exit
	int	3
$LN4@Fatal:
Fatal	ENDP
_TEXT	ENDS
PUBLIC	WriteError
xdata	SEGMENT
$unwind$WriteError DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$WriteError DD @imagerel($LN4#)
	DD	@imagerel($LN4#+30)
	DD	@imagerel($unwind$WriteError#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
WriteError PROC NEAR

; 346  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 347  :     DebugMsg(("WriteError occured\n"));
; 348  :     Fatal( FILE_WRITE_ERROR, CurrFName[OBJ], errno );

	call	_errno
	mov	rdx, QWORD PTR ModuleInfo+136
	mov	ecx, 108				; 0000006cH
	mov	r8d, DWORD PTR [rax]
	call	Fatal
	int	3
$LN3@WriteError:
WriteError ENDP
_TEXT	ENDS
END
