; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omffixup.c
_DATA	ENDS
_TEXT	SEGMENT
p$ = 8
index$ = 16
putIndex PROC NEAR

; 57   :     if( index > 0x7f ) {

	cmp	dx, 127					; 0000007fH
	jbe	SHORT $LN1@putIndex

; 58   :         *p++ = 0x80 | ( index >> 8 );

	movzx	eax, dx
	shr	ax, 8
	or	al, 128					; 00000080H
	inc	rcx
	mov	BYTE PTR [rcx-1], al
$LN1@putIndex:

; 59   :     }
; 60   :     *p++ = index;

	mov	BYTE PTR [rcx], dl
	lea	rax, QWORD PTR [rcx+1]

; 61   :     return( p );
; 62   : }

	ret	0
putIndex ENDP
; Function compile flags: /Ogtpy
p$ = 8
value$ = 16
put16	PROC NEAR

; 67   :     WriteU16( p, value );

	mov	WORD PTR [rcx], dx

; 68   :     return( p + sizeof( uint_16 ) );

	lea	rax, QWORD PTR [rcx+2]

; 69   : }

	ret	0
put16	ENDP
; Function compile flags: /Ogtpy
p$ = 8
value$ = 16
put32	PROC NEAR

; 74   :     WriteU32( p, value );

	mov	DWORD PTR [rcx], edx

; 75   :     return( p + sizeof( uint_32 ) );

	lea	rax, QWORD PTR [rcx+4]

; 76   : }

	ret	0
put32	ENDP
; Function compile flags: /Ogtpy
p$ = 8
method$ = 16
datum$ = 24
putFrameDatum PROC NEAR

; 81   :     switch( method ) {

	cmp	dl, 2
	ja	SHORT $LN2@putFrameDa

; 82   :     case FRAME_SEG:
; 83   :     case FRAME_GRP:
; 84   :     case FRAME_EXT:
; 85   :         return( putIndex( p, datum ) );

	cmp	r8w, 127				; 0000007fH
	jbe	SHORT $LN6@putFrameDa
	movzx	eax, r8w
	shr	ax, 8
	or	al, 128					; 00000080H
	inc	rcx
	mov	BYTE PTR [rcx-1], al
$LN6@putFrameDa:
	mov	BYTE PTR [rcx], r8b
	lea	rax, QWORD PTR [rcx+1]

; 93   : }

	ret	0
$LN2@putFrameDa:

; 86   : #if 0  /* v2.12: FRAME_ABS is invalid according to TIS OMF docs. */
; 87   :     case FRAME_ABS:
; 88   :         return( put16( p, datum ) );
; 89   : #endif
; 90   :     }
; 91   :     /* for FRAME_LOC & FRAME_TARG ( & FRAME_NONE ) there's no datum to write. */
; 92   :     return( p );

	mov	rax, rcx

; 93   : }

	ret	0
putFrameDatum ENDP
; Function compile flags: /Ogtpy
p$ = 8
method$ = 16
datum$ = 24
putTargetDatum PROC NEAR

; 98   : #if 0 /* v2.12: HJWasm won't use TARGE_ABSxx; also, it's not defined for FIXUP sub-records */
; 99   :     if( ( method & 0x03 ) == TARGET_ABSWD ) {
; 100  :         return( put16( p, datum ) );
; 101  :     }
; 102  : #endif
; 103  :     return( putIndex( p, datum ) );

	cmp	r8w, 127				; 0000007fH
	jbe	SHORT $LN3@putTargetD
	movzx	eax, r8w
	shr	ax, 8
	or	al, 128					; 00000080H
	inc	rcx
	mov	BYTE PTR [rcx-1], al
$LN3@putTargetD:
	mov	BYTE PTR [rcx], r8b
	lea	rax, QWORD PTR [rcx+1]

; 104  : }

	ret	0
putTargetDatum ENDP
; Function compile flags: /Ogtpy
lr$ = 8
buf$ = 16
type$ = 24
TranslateLogref PROC NEAR

; 121  :     uint_8  *p;
; 122  :     uint_8  target;
; 123  : 
; 124  :     /**/myassert( lr != NULL );
; 125  :     /**/myassert( buf != NULL );
; 126  :     /**/myassert( type == FIX_GEN_INTEL || type == FIX_GEN_MS386 );
; 127  : 
; 128  :     /*
; 129  :      * According to the discussion on p102 of the Intel OMF document, we
; 130  :      * cannot just arbitrarily write fixups without a displacment if their
; 131  :      * displacement field is 0.  So we use the is_secondary field.
; 132  :      */
; 133  :     target = lr->target;
; 134  :     if( lr->target_offset == 0 && lr->is_secondary ) {

	cmp	DWORD PTR [rcx+8], 0
	movzx	r9d, BYTE PTR [rcx+5]
	mov	r11d, r8d
	mov	r10, rdx
	jne	SHORT $LN4@TranslateL
	cmp	BYTE PTR [rcx+4], 0
	je	SHORT $LN4@TranslateL

; 135  :         target |= 0x04; /* P=1 -> no displacement field */

	or	r9b, 4
$LN4@TranslateL:

; 136  :     }
; 137  :     p = buf;
; 138  :     /* write the "Fix Data" field, FfffTPtt:
; 139  :      * F  : 0 = frame method is defined in fff field ( F0-F5)
; 140  :      *      1 = frame is defined by a thread ( won't occur here )
; 141  :      * fff: frame method
; 142  :      * T  : 0 = target is defined by tt
; 143  :      *      1 = target is defined by thread# in tt, P is used as bit 2 for method
; 144  :      * P  : 0 = target displacement field is present
; 145  :      *      1 = no displacement field
; 146  :      * tt : target method
; 147  :      */
; 148  :     *p++ = ( lr->frame << 4 ) | ( target );

	movzx	eax, BYTE PTR [rcx]
	inc	rdx
	shl	al, 4
	or	al, r9b
	mov	BYTE PTR [rdx-1], al

; 149  :     p = putFrameDatum( p, lr->frame, lr->frame_datum );

	cmp	BYTE PTR [rcx], 2
	movzx	r8d, WORD PTR [rcx+2]
	ja	SHORT $LN8@TranslateL
	cmp	r8w, 127				; 0000007fH
	jbe	SHORT $LN12@TranslateL
	movzx	eax, r8w
	shr	ax, 8
	or	al, 128					; 00000080H
	inc	rdx
	mov	BYTE PTR [rdx-1], al
$LN12@TranslateL:
	mov	BYTE PTR [rdx], r8b
	inc	rdx
$LN8@TranslateL:

; 150  :     p = putTargetDatum( p, target, lr->target_datum );

	movzx	r8d, WORD PTR [rcx+6]
	cmp	r8w, 127				; 0000007fH
	jbe	SHORT $LN17@TranslateL
	movzx	eax, r8w
	shr	ax, 8
	or	al, 128					; 00000080H
	inc	rdx
	mov	BYTE PTR [rdx-1], al
$LN17@TranslateL:
	mov	BYTE PTR [rdx], r8b
	inc	rdx

; 151  :     if( ( target & 0x04 ) == 0 ) {

	test	r9b, 4
	jne	SHORT $LN1@TranslateL

; 152  :         if( type == FIX_GEN_MS386 ) {

	cmp	r11d, 1
	jne	SHORT $LN2@TranslateL

; 153  :             p = put32( p, (uint_32)lr->target_offset );

	mov	eax, DWORD PTR [rcx+8]
	add	rdx, 4
	mov	DWORD PTR [rdx-4], eax

; 156  :         }
; 157  :     }
; 158  :     return( p - buf );

	sub	rdx, r10
	mov	eax, edx

; 159  : }

	ret	0
$LN2@TranslateL:

; 154  :         } else {
; 155  :             p = put16( p, (uint_16)lr->target_offset );

	movzx	ecx, WORD PTR [rcx+8]
	add	rdx, 2
	mov	WORD PTR [rdx-2], cx
$LN1@TranslateL:

; 156  :         }
; 157  :     }
; 158  :     return( p - buf );

	sub	rdx, r10
	mov	eax, edx

; 159  : }

	ret	0
TranslateLogref ENDP
_TEXT	ENDS
PUBLIC	OmfFixGenFixModend
EXTRN	GetSegIdx:NEAR
EXTRN	omf_GetGrpIdx:NEAR
xdata	SEGMENT
$unwind$OmfFixGenFixModend DD 010701H
	DD	08207H
xdata	ENDS
pdata	SEGMENT
$pdata$OmfFixGenFixModend DD @imagerel($LN31#)
	DD	@imagerel($LN31#+7)
	DD	@imagerel($unwind$OmfFixGenFixModend#)
pdata	ENDS
xdata	SEGMENT
$chain$1$OmfFixGenFixModend DD 040821H
	DD	0b5408H
	DD	0a3404H
	DD	@imagerel($LN31#)
	DD	@imagerel($LN31#+7)
	DD	@imagerel($unwind$OmfFixGenFixModend#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$OmfFixGenFixModend DD @imagerel($LN31#+7)
	DD	@imagerel($LN31#+15)
	DD	@imagerel($chain$1$OmfFixGenFixModend#)
pdata	ENDS
xdata	SEGMENT
$chain$6$OmfFixGenFixModend DD 0a2621H
	DD	06e426H
	DD	07d41bH
	DD	08c40cH
	DD	0d7408H
	DD	0c6404H
	DD	@imagerel($LN31#+7)
	DD	@imagerel($LN31#+15)
	DD	@imagerel($chain$1$OmfFixGenFixModend#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$OmfFixGenFixModend DD @imagerel($LN31#+15)
	DD	@imagerel($LN31#+144)
	DD	@imagerel($chain$6$OmfFixGenFixModend#)
pdata	ENDS
xdata	SEGMENT
$chain$7$OmfFixGenFixModend DD 080021H
	DD	06e400H
	DD	07d400H
	DD	08c400H
	DD	0d7400H
	DD	@imagerel($LN31#+7)
	DD	@imagerel($LN31#+15)
	DD	@imagerel($chain$1$OmfFixGenFixModend#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$OmfFixGenFixModend DD @imagerel($LN31#+144)
	DD	@imagerel($LN31#+216)
	DD	@imagerel($chain$7$OmfFixGenFixModend#)
pdata	ENDS
xdata	SEGMENT
$chain$8$OmfFixGenFixModend DD 060021H
	DD	06e400H
	DD	07d400H
	DD	08c400H
	DD	@imagerel($LN31#+7)
	DD	@imagerel($LN31#+15)
	DD	@imagerel($chain$1$OmfFixGenFixModend#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$OmfFixGenFixModend DD @imagerel($LN31#+216)
	DD	@imagerel($LN31#+256)
	DD	@imagerel($chain$8$OmfFixGenFixModend#)
pdata	ENDS
xdata	SEGMENT
$chain$9$OmfFixGenFixModend DD 060021H
	DD	06e400H
	DD	07d400H
	DD	08c400H
	DD	@imagerel($LN31#)
	DD	@imagerel($LN31#+7)
	DD	@imagerel($unwind$OmfFixGenFixModend#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$OmfFixGenFixModend DD @imagerel($LN31#+256)
	DD	@imagerel($LN31#+307)
	DD	@imagerel($chain$9$OmfFixGenFixModend#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
lr$ = 32
fixup$ = 80
buf$ = 88
displ$ = 96
type$ = 104
OmfFixGenFixModend PROC NEAR

; 194  : {

$LN31:
	mov	r11, rsp
	sub	rsp, 72					; 00000048H
	mov	QWORD PTR [r11+8], rbx
	mov	QWORD PTR [r11+16], rbp
	mov	QWORD PTR [r11+24], rsi
	mov	QWORD PTR [r11+32], rdi
	mov	QWORD PTR [r11-8], r12
	mov	rsi, rcx

; 195  :     struct asym *sym = fixup->sym;

	mov	rcx, QWORD PTR [rcx+56]

; 196  :     struct logref lr;
; 197  : 
; 198  :     lr.is_secondary = FALSE;
; 199  :     lr.target_offset = sym->offset + displ;
; 200  : 
; 201  :     lr.frame_datum = fixup->frame_datum;

	mov	di, WORD PTR [rsi+42]
	mov	QWORD PTR [r11-16], r13

; 202  : 
; 203  :     /* symbol is always a code label (near or far), internal or external */
; 204  :     /* now set Target and Frame */
; 205  : 
; 206  :     if( sym->state == SYM_EXTERNAL ) {

	cmp	DWORD PTR [rcx+40], 2
	mov	eax, DWORD PTR [rcx+16]
	mov	QWORD PTR [r11-24], r14
	lea	r13d, DWORD PTR [r8+rax]
	mov	r14d, r9d
	mov	r12, rdx
	mov	DWORD PTR [r11-32], r13d
	mov	WORD PTR lr$[rsp+2], di
	jne	SHORT $LN5@OmfFixGenF

; 207  :         DebugMsg(("omf_write_modend(%p): fixup->frame_type/datum=%u/%u, EXTERNAL sym=%s\n",
; 208  :                   fixup, fixup->frame_type, fixup->frame_datum, sym->name));
; 209  : 
; 210  :         lr.target = TARGET_EXT & TARGET_WITH_DISPL;
; 211  :         lr.target_datum = sym->ext_idx1;
; 212  : 
; 213  :         if( fixup->frame_type == FRAME_GRP && fixup->frame_datum == 0 ) {

	cmp	BYTE PTR [rsi+40], 1
	mov	bx, WORD PTR [rcx+96]
	mov	bpl, 2
	mov	WORD PTR lr$[rsp+6], bx
	jne	SHORT $LN3@OmfFixGenF
	test	di, di
	jne	SHORT $LN3@OmfFixGenF

; 214  :             /* set the frame to the frame of the corresponding segment */
; 215  :             lr.frame_datum = omf_GetGrpIdx( sym );

	call	omf_GetGrpIdx
	mov	edi, eax
	mov	WORD PTR lr$[rsp+2], ax

; 216  :         }
; 217  :     } else { /* SYM_INTERNAL */

	jmp	SHORT $LN3@OmfFixGenF
$LN5@OmfFixGenF:

; 218  :         DebugMsg(("OmfFixGenFixModend(%p): fixup->frame_type/datum=%u/%u sym->name=%s state=%X segm=%s\n",
; 219  :                   fixup, fixup->frame_type, fixup->frame_datum, sym->name, sym->state, sym->segment ? sym->segment->name : "NULL" ));
; 220  :         /**/myassert( sym->state == SYM_INTERNAL );
; 221  : 
; 222  :         lr.target = TARGET_SEG & TARGET_WITH_DISPL;
; 223  :         lr.target_datum = GetSegIdx( sym->segment );

	mov	rcx, QWORD PTR [rcx+32]
	xor	bpl, bpl
	call	GetSegIdx
	mov	ebx, eax
	mov	WORD PTR lr$[rsp+6], ax
$LN3@OmfFixGenF:

; 224  :     }
; 225  : 
; 226  :     if( fixup->frame_type != FRAME_NONE && fixup->frame_type != FRAME_SEG ) {

	movzx	edx, BYTE PTR [rsi+40]
	mov	rsi, QWORD PTR [rsp+96]
	cmp	dl, 6
	je	SHORT $LN2@OmfFixGenF
	test	dl, dl
	jne	SHORT $LN1@OmfFixGenF
$LN2@OmfFixGenF:

; 227  :         lr.frame = (uint_8)fixup->frame_type;
; 228  :     } else {
; 229  :         lr.frame = FRAME_TARG;

	mov	dl, 5
$LN1@OmfFixGenF:

; 230  :     }
; 231  :     return( TranslateLogref( &lr, buf, type ) );

	movzx	eax, dl
	lea	rcx, QWORD PTR [r12+1]
	shl	al, 4
	or	al, bpl
	cmp	dl, 2
	mov	BYTE PTR [r12], al
	ja	SHORT $LN15@OmfFixGenF
	cmp	di, 127					; 0000007fH
	jbe	SHORT $LN19@OmfFixGenF
	shr	di, 8
	or	dil, 128				; 00000080H
	inc	rcx
	mov	BYTE PTR [rcx-1], dil
$LN19@OmfFixGenF:
	movzx	eax, BYTE PTR lr$[rsp+2]
	inc	rcx
	mov	BYTE PTR [rcx-1], al
$LN15@OmfFixGenF:
	cmp	bx, 127					; 0000007fH
	mov	rdi, QWORD PTR [rsp+104]
	jbe	SHORT $LN24@OmfFixGenF
	shr	bx, 8
	or	bl, 128					; 00000080H
	inc	rcx
	mov	BYTE PTR [rcx-1], bl
$LN24@OmfFixGenF:
	movzx	eax, BYTE PTR lr$[rsp+6]
	mov	rbx, QWORD PTR [rsp+80]
	test	bpl, 4
	mov	rbp, QWORD PTR [rsp+88]
	mov	BYTE PTR [rcx], al
	lea	rax, QWORD PTR [rcx+1]
	jne	SHORT $LN8@OmfFixGenF
	cmp	r14d, 1
	jne	SHORT $LN9@OmfFixGenF
	mov	DWORD PTR [rax], r13d
	add	rax, 4
	jmp	SHORT $LN8@OmfFixGenF
$LN9@OmfFixGenF:
	movzx	ecx, WORD PTR lr$[rsp+8]
	add	rax, 2
	mov	WORD PTR [rax-2], cx
$LN8@OmfFixGenF:
	mov	r14, QWORD PTR [rsp+48]
	mov	r13, QWORD PTR [rsp+56]
	sub	rax, r12
	mov	r12, QWORD PTR [rsp+64]

; 232  : }

	add	rsp, 72					; 00000048H
	ret	0
OmfFixGenFixModend ENDP
_TEXT	ENDS
EXTRN	EmitErr:NEAR
xdata	SEGMENT
$unwind$omf_fill_logref DD 050e01H
	DD	09740eH
	DD	083409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$omf_fill_logref DD @imagerel(omf_fill_logref#)
	DD	@imagerel(omf_fill_logref#+456)
	DD	@imagerel($unwind$omf_fill_logref#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
fixup$ = 48
lr$ = 56
omf_fill_logref PROC NEAR

; 238  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx

; 239  :     struct asym      *sym;
; 240  : 
; 241  :     sym = fixup->sym; /* may be NULL! */

	mov	rcx, QWORD PTR [rcx+56]
	mov	rbx, rdx

; 242  : 
; 243  :     DebugMsg1(("omf_fill_logref: sym=%s, state=%d, fixup->type=%u\n",
; 244  :                sym ? sym->name : "NULL", sym ? sym->state : -1, fixup->type ));
; 245  : 
; 246  :     /*------------------------------------*/
; 247  :     /* Determine the Target and the Frame */
; 248  :     /*------------------------------------*/
; 249  : 
; 250  :     if( sym == NULL ) {

	test	rcx, rcx
	jne	SHORT $LN25@omf_fill_l

; 251  : 
; 252  :         DebugMsg(("omf_fill_logref: sym is NULL, frame_type=%u\n", fixup->frame_type ));
; 253  :         if ( fixup->frame_type == FRAME_NONE ) /* v1.96: nothing to do without a frame */

	mov	al, BYTE PTR [rdi+40]
	cmp	al, 6

; 254  :             return( 0 );

	je	$LN28@omf_fill_l

; 255  :         lr->target = fixup->frame_type;

	mov	BYTE PTR [rdx+5], al

; 256  :         lr->target_datum = fixup->frame_datum;

	movzx	eax, WORD PTR [rdi+42]

; 257  :         lr->frame = FRAME_TARG;

	mov	BYTE PTR [rdx], 5
	mov	WORD PTR [rdx+6], ax
	jmp	$LN3@omf_fill_l
$LN25@omf_fill_l:

; 258  : 
; 259  :     } else if( sym->state == SYM_UNDEFINED ) { /* shouldn't happen */

	mov	eax, DWORD PTR [rcx+40]
	test	eax, eax
	jne	SHORT $LN22@omf_fill_l

; 260  : 
; 261  :         DebugMsg(("omf_fill_logref: sym->state is SYM_UNDEFINED\n" ));
; 262  :         EmitErr( SYMBOL_NOT_DEFINED, sym->name );

	mov	rdx, QWORD PTR [rcx+8]
	lea	ecx, QWORD PTR [rax+102]
	call	EmitErr

; 263  :         return( 0 );

	xor	eax, eax
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 347  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN22@omf_fill_l:

; 264  : 
; 265  :     } else if( sym->state == SYM_GRP ) {

	cmp	eax, 4
	jne	SHORT $LN20@omf_fill_l

; 266  : 
; 267  :         DebugMsg1(("omf_fill_logref: sym->state is SYM_GRP\n" ));
; 268  :         lr->target = TARGET_GRP;

	mov	BYTE PTR [rdx+5], 5

; 269  :         lr->target_datum = ((struct dsym *)sym)->e.grpinfo->grp_idx;

	mov	rax, QWORD PTR [rcx+104]
	movzx	ecx, WORD PTR [rax+8]
	mov	WORD PTR [rdx+6], cx

; 270  :         if( fixup->frame_type != FRAME_NONE ) {

	mov	al, BYTE PTR [rdi+40]
	cmp	al, 6
	je	SHORT $LN19@omf_fill_l

; 271  :             lr->frame = fixup->frame_type;

	mov	BYTE PTR [rdx], al

; 272  :             lr->frame_datum = fixup->frame_datum;

	movzx	eax, WORD PTR [rdi+42]
	mov	WORD PTR [rdx+2], ax

; 273  :         } else {

	jmp	$LN3@omf_fill_l
$LN19@omf_fill_l:

; 274  :             lr->frame = FRAME_GRP;

	mov	BYTE PTR [rdx], 1

; 275  :             lr->frame_datum = lr->target_datum;

	mov	WORD PTR [rdx+2], cx

; 276  :         }

	jmp	$LN3@omf_fill_l
$LN20@omf_fill_l:

; 277  : 
; 278  :     } else if( sym->state == SYM_SEG ) {

	cmp	eax, 3
	jne	SHORT $LN16@omf_fill_l

; 279  : 
; 280  :         DebugMsg1(("omf_fill_logref: sym->state is SYM_SEG %s\n" ));
; 281  :         lr->target = TARGET_SEG;

	mov	BYTE PTR [rdx+5], 4

; 282  :         lr->target_datum = GetSegIdx( sym );

	call	GetSegIdx
	mov	WORD PTR [rbx+6], ax

; 283  :         if( fixup->frame_type != FRAME_NONE ) {

	mov	cl, BYTE PTR [rdi+40]
	cmp	cl, 6
	je	SHORT $LN15@omf_fill_l

; 284  :             lr->frame = fixup->frame_type;

	mov	BYTE PTR [rbx], cl

; 285  :             lr->frame_datum = fixup->frame_datum;

	movzx	eax, WORD PTR [rdi+42]
	mov	WORD PTR [rbx+2], ax

; 286  :         } else {

	jmp	$LN3@omf_fill_l
$LN15@omf_fill_l:

; 287  :             lr->frame = FRAME_SEG;

	mov	BYTE PTR [rbx], 0

; 288  :             lr->frame_datum = lr->target_datum;

	mov	WORD PTR [rbx+2], ax

; 289  :         }
; 290  : 
; 291  :     } else {

	jmp	$LN3@omf_fill_l
$LN16@omf_fill_l:

; 292  : 
; 293  :         /* symbol is a label */
; 294  : 
; 295  :         lr->frame_datum = fixup->frame_datum;

	movzx	eax, WORD PTR [rdi+42]
	mov	WORD PTR [rdx+2], ax

; 296  :         if( sym->state == SYM_EXTERNAL ) {

	cmp	DWORD PTR [rcx+40], 2
	jne	SHORT $LN12@omf_fill_l

; 297  :             DebugMsg1(("omf_fill_logref: sym->state is SYM_EXTERNAL, fixup->frame_type/datum=%u/%u\n",
; 298  :                       fixup->frame_type, fixup->frame_datum ));
; 299  :             lr->target = TARGET_EXT;

	mov	BYTE PTR [rdx+5], 6

; 300  :             lr->target_datum = sym->ext_idx1;

	movzx	eax, WORD PTR [rcx+96]
	mov	WORD PTR [rdx+6], ax

; 301  : 
; 302  :             if( fixup->frame_type == FRAME_GRP && fixup->frame_datum == 0 ) {

	cmp	BYTE PTR [rdi+40], 1
	jne	$LN4@omf_fill_l
	cmp	WORD PTR [rdi+42], 0
	jne	$LN4@omf_fill_l

; 303  :                 /* set the frame to the frame of the corresponding segment */
; 304  :                 lr->frame_datum = omf_GetGrpIdx( sym );

	call	omf_GetGrpIdx
	mov	WORD PTR [rbx+2], ax

; 305  :             }
; 306  :         } else {

	jmp	$LN4@omf_fill_l
$LN12@omf_fill_l:

; 307  :             /* must be SYM_INTERNAL */
; 308  :             /**/myassert( sym->state == SYM_INTERNAL );
; 309  :             DebugMsg1(("omf_fill_logref: sym->state is SYM_INTERNAL, sym->segment=%s, fixup->frame/datum=%u/%u\n",
; 310  :                        sym->segment ? sym->segment->name : "NULL", fixup->frame_type, fixup->frame_datum ));
; 311  :             /* v2.08: don't use info from assembly-time variables */
; 312  :             if ( sym->variable ) {

	test	BYTE PTR [rcx+48], 64			; 00000040H
	je	SHORT $LN9@omf_fill_l

; 313  :                 lr->target = ( fixup->frame_type == FRAME_GRP ? TARGET_GRP : TARGET_SEG );

	cmp	BYTE PTR [rdi+40], 1
	sete	al
	add	al, 4
	mov	BYTE PTR [rdx+5], al

; 314  :                 lr->target_datum = fixup->frame_datum;

	movzx	eax, WORD PTR [rdi+42]
	mov	WORD PTR [rdx+6], ax
	jmp	SHORT $LN4@omf_fill_l
$LN9@omf_fill_l:

; 315  :             } else if ( sym->segment == NULL ) { /* shouldn't happen */

	mov	rax, QWORD PTR [rcx+32]
	test	rax, rax
	jne	SHORT $LN7@omf_fill_l

; 316  :                 EmitErr( SEGMENT_MISSING_FOR_FIXUP, sym->name );

	mov	rdx, QWORD PTR [rcx+8]
	mov	ecx, 164				; 000000a4H
	call	EmitErr
$LN28@omf_fill_l:

; 317  :                 return ( 0 );

	xor	eax, eax
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 347  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN7@omf_fill_l:

; 318  : #if COMDATSUPP
; 319  :             } else if ( ( (struct dsym *)sym->segment)->e.seginfo->comdat_selection ) {

	mov	rax, QWORD PTR [rax+104]
	test	BYTE PTR [rax+108], 56			; 00000038H
	je	SHORT $LN5@omf_fill_l

; 320  :                 lr->target = TARGET_EXT;

	mov	BYTE PTR [rdx+5], 6

; 321  :                 lr->target_datum = ((struct dsym *)sym->segment)->e.seginfo->seg_idx;

	mov	rax, QWORD PTR [rcx+32]
	mov	rcx, QWORD PTR [rax+104]
	movzx	eax, WORD PTR [rcx+68]

; 322  :                 lr->frame = FRAME_TARG;

	mov	BYTE PTR [rdx], 5
	mov	WORD PTR [rdx+6], ax

; 344  :     }
; 345  : 
; 346  :     return( 1 );

	mov	eax, 1
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 347  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN5@omf_fill_l:

; 323  :                 return( 1 );
; 324  : #endif
; 325  :             } else {
; 326  :                 lr->target = TARGET_SEG;

	mov	BYTE PTR [rdx+5], 4

; 327  :                 lr->target_datum = GetSegIdx( sym->segment );

	mov	rcx, QWORD PTR [rcx+32]
	call	GetSegIdx
	mov	WORD PTR [rbx+6], ax
$LN4@omf_fill_l:

; 328  :             }
; 329  :         }
; 330  : 
; 331  :         if( fixup->frame_type != FRAME_NONE ) {

	movzx	ecx, BYTE PTR [rdi+40]
	mov	eax, 5
	cmp	cl, 6
	cmovne	eax, ecx
	mov	BYTE PTR [rbx], al
$LN3@omf_fill_l:

; 332  :             lr->frame = (uint_8)fixup->frame_type;
; 333  :         } else {
; 334  :             lr->frame = FRAME_TARG;
; 335  :         }
; 336  :     }
; 337  : 
; 338  :     /*--------------------*/
; 339  :     /* Optimize the fixup */
; 340  :     /*--------------------*/
; 341  : 
; 342  :     if( lr->frame == ( lr->target - TARGET_SEG ) ) {

	movzx	ecx, BYTE PTR [rbx+5]
	movzx	eax, BYTE PTR [rbx]
	sub	ecx, 4
	cmp	eax, ecx
	jne	SHORT $LN1@omf_fill_l

; 343  :         lr->frame = FRAME_TARG;

	mov	BYTE PTR [rbx], 5
$LN1@omf_fill_l:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 344  :     }
; 345  : 
; 346  :     return( 1 );

	mov	eax, 1

; 347  : }

	add	rsp, 40					; 00000028H
	ret	0
omf_fill_logref ENDP
_TEXT	ENDS
PUBLIC	OmfFixGenFix
EXTRN	ModuleInfo:BYTE
EXTRN	szNull:BYTE
EXTRN	__ImageBase:BYTE
xdata	SEGMENT
$unwind$OmfFixGenFix DD 0d1f01H
	DD	07d41fH
	DD	08c41bH
	DD	0d7417H
	DD	0c6413H
	DD	0b540fH
	DD	0a340bH
	DD	08207H
xdata	ENDS
pdata	SEGMENT
$pdata$OmfFixGenFix DD @imagerel($LN44#)
	DD	@imagerel($LN44#+508)
	DD	@imagerel($unwind$OmfFixGenFix#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
lr$ = 32
fixup$ = 80
start_loc$ = 88
buf$ = 96
type$ = 104
OmfFixGenFix PROC NEAR

; 370  : {

$LN44:
	mov	rax, rsp
	sub	rsp, 72					; 00000048H
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	QWORD PTR [rax-8], r12
	mov	QWORD PTR [rax-16], r13

; 371  :     uint_8  locat1;
; 372  :     uint_8  self_relative = FALSE;
; 373  :     unsigned data_rec_offset;
; 374  :     struct logref lr;
; 375  : 
; 376  :     /**/myassert( fixup != NULL );
; 377  :     /**/myassert( buf != NULL );
; 378  :     /**/myassert( type == FIX_GEN_INTEL || type == FIX_GEN_MS386 );
; 379  : 
; 380  :     lr.is_secondary = TRUE;

	mov	BYTE PTR [rax-36], 1

; 381  :     lr.target_offset = 0;

	mov	DWORD PTR [rax-32], 0

; 382  : 
; 383  :     switch( fixup->type ) {

	mov	eax, DWORD PTR [rcx+24]
	xor	sil, sil
	dec	eax
	mov	ebp, r9d
	cmp	eax, 10
	mov	r12, r8
	mov	r13d, edx
	mov	rdi, rcx
	ja	$LN2@OmfFixGenF@2
	lea	rcx, OFFSET FLAT:__ImageBase
	cdqe
	mov	r9d, DWORD PTR $LN42@OmfFixGenF@2[rcx+rax*4]
	add	r9, rcx
	jmp	r9
$LN12@OmfFixGenF@2:

; 384  :     case FIX_RELOFF8:
; 385  :         self_relative = TRUE;

	mov	sil, 1
$LN11@OmfFixGenF@2:

; 386  :         /* no break */
; 387  :     case FIX_OFF8:
; 388  :         locat1 = ( LOC_OFFSET_LO << 2 );

	xor	bl, bl

; 389  :         break;

	jmp	SHORT $LN13@OmfFixGenF@2
$LN10@OmfFixGenF@2:

; 390  :     case FIX_RELOFF16:
; 391  :         self_relative = TRUE;

	mov	sil, 1
$LN9@OmfFixGenF@2:

; 392  :         /* no break */
; 393  :     case FIX_OFF16:
; 394  :         locat1 = ( fixup->loader_resolved ? LOC_MS_LINK_OFFSET << 2 : LOC_OFFSET << 2 );

	movzx	ebx, BYTE PTR [rdi+33]
	and	bl, 1
	shl	bl, 4
	or	bl, 4

; 395  :         break;

	jmp	SHORT $LN13@OmfFixGenF@2
$LN8@OmfFixGenF@2:

; 396  :     case FIX_RELOFF32:
; 397  :         self_relative = TRUE;

	mov	sil, 1
$LN7@OmfFixGenF@2:

; 398  :         /* no break */
; 399  :     case FIX_OFF32:
; 400  :         locat1 = ( fixup->loader_resolved ? LOC_MS_LINK_OFFSET_32 << 2 : LOC_MS_OFFSET_32 << 2 );

	mov	bl, BYTE PTR [rdi+33]
	and	bl, 1
	shl	bl, 4
	or	bl, 36					; 00000024H

; 401  :         break;

	jmp	SHORT $LN13@OmfFixGenF@2
$LN6@OmfFixGenF@2:

; 402  :     case FIX_HIBYTE:
; 403  :         locat1 = ( LOC_OFFSET_HI << 2 );

	mov	bl, 16

; 404  :         break;

	jmp	SHORT $LN13@OmfFixGenF@2
$LN5@OmfFixGenF@2:

; 405  :     case FIX_SEG:
; 406  :         locat1 = ( LOC_BASE << 2 );

	mov	bl, 8

; 407  :         break;

	jmp	SHORT $LN13@OmfFixGenF@2
$LN4@OmfFixGenF@2:

; 408  :     case FIX_PTR16:
; 409  :         locat1 = ( LOC_BASE_OFFSET << 2 );

	mov	bl, 12

; 410  :         break;

	jmp	SHORT $LN13@OmfFixGenF@2
$LN3@OmfFixGenF@2:

; 411  :     case FIX_PTR32:
; 412  :         locat1 = ( LOC_MS_BASE_OFFSET_32 << 2 );

	mov	bl, 44					; 0000002cH
$LN13@OmfFixGenF@2:

; 419  :     }
; 420  :     locat1 |= self_relative ? 0x80 : 0xc0; /* bit 7: 1=is a fixup subrecord */
; 421  : 
; 422  :     if ( omf_fill_logref( fixup, &lr ) == 0 )

	lea	rdx, QWORD PTR lr$[rsp]
	mov	rcx, rdi
	call	omf_fill_logref
	test	eax, eax

; 423  :         return( 0 );

	je	$LN43@OmfFixGenF@2

; 424  : 
; 425  :     /* magnitude of fixup's position is 10! */
; 426  :     /**/myassert( fixup->locofs - start_loc < 1024 );
; 427  : 
; 428  :     /* calculate the fixup's position in current LEDATA */
; 429  :     data_rec_offset = fixup->locofs - start_loc;

	mov	edx, DWORD PTR [rdi+20]

; 430  : 
; 431  :     locat1 |= data_rec_offset >> 8;
; 432  :     *buf = locat1;
; 433  :     *(buf+1) = (uint_8)data_rec_offset;
; 434  :     return( 2 + TranslateLogref( &lr, buf+2, type ) );

	mov	r10d, DWORD PTR lr$[rsp+8]
	movzx	r8d, BYTE PTR lr$[rsp+5]
	sub	edx, r13d
	mov	eax, 128				; 00000080H
	test	sil, sil
	mov	ecx, 192				; 000000c0H
	lea	r9, QWORD PTR [r12+2]
	mov	BYTE PTR [r12+1], dl
	cmovne	ecx, eax
	mov	eax, edx
	shr	eax, 8
	or	cl, al
	or	cl, bl
	test	r10d, r10d
	mov	BYTE PTR [r12], cl
	jne	SHORT $LN22@OmfFixGenF@2
	cmp	BYTE PTR lr$[rsp+4], r10b
	je	SHORT $LN22@OmfFixGenF@2
	or	r8b, 4
$LN22@OmfFixGenF@2:
	movzx	ecx, BYTE PTR lr$[rsp]
	lea	rdx, QWORD PTR [r9+1]
	movzx	eax, cl
	shl	al, 4
	or	al, r8b
	cmp	cl, 2
	mov	BYTE PTR [r9], al
	ja	SHORT $LN26@OmfFixGenF@2
	movzx	eax, WORD PTR lr$[rsp+2]
	cmp	ax, 127					; 0000007fH
	jbe	SHORT $LN30@OmfFixGenF@2
	shr	ax, 8
	or	al, 128					; 00000080H
	inc	rdx
	mov	BYTE PTR [rdx-1], al
$LN30@OmfFixGenF@2:
	movzx	eax, BYTE PTR lr$[rsp+2]
	inc	rdx
	mov	BYTE PTR [rdx-1], al
$LN26@OmfFixGenF@2:
	movzx	eax, WORD PTR lr$[rsp+6]
	cmp	ax, 127					; 0000007fH
	jbe	SHORT $LN35@OmfFixGenF@2
	shr	ax, 8
	or	al, 128					; 00000080H
	inc	rdx
	mov	BYTE PTR [rdx-1], al
$LN35@OmfFixGenF@2:
	test	r8b, 4
	movzx	eax, BYTE PTR lr$[rsp+6]
	mov	BYTE PTR [rdx], al
	lea	rax, QWORD PTR [rdx+1]
	jne	SHORT $LN19@OmfFixGenF@2
	cmp	ebp, 1
	jne	SHORT $LN20@OmfFixGenF@2
	mov	DWORD PTR [rax], r10d
	add	rax, 4
	sub	eax, r9d
	add	eax, 2
	jmp	SHORT $LN15@OmfFixGenF@2
$LN20@OmfFixGenF@2:
	movzx	ecx, WORD PTR lr$[rsp+8]
	add	rax, 2
	mov	WORD PTR [rax-2], cx
$LN19@OmfFixGenF@2:
	sub	eax, r9d
	add	eax, 2
	jmp	SHORT $LN15@OmfFixGenF@2
$LN2@OmfFixGenF@2:

; 413  :         break;
; 414  :     default: /* shouldn't happen. Check for valid fixup has already happened */
; 415  :         EmitErr( UNSUPPORTED_FIXUP_TYPE,
; 416  :                ModuleInfo.fmtopt->formatname,
; 417  :                fixup->sym ? fixup->sym->name : szNull );

	mov	rax, QWORD PTR [rdi+56]
	test	rax, rax
	je	SHORT $LN17@OmfFixGenF@2
	mov	r8, QWORD PTR [rax+8]
	jmp	SHORT $LN18@OmfFixGenF@2
$LN17@OmfFixGenF@2:
	lea	r8, OFFSET FLAT:szNull
$LN18@OmfFixGenF@2:
	mov	rdx, QWORD PTR ModuleInfo+344
	mov	ecx, 197				; 000000c5H
	add	rdx, 10
	call	EmitErr
$LN43@OmfFixGenF@2:

; 418  :         return( 0 );

	xor	eax, eax
$LN15@OmfFixGenF@2:
	mov	r13, QWORD PTR [rsp+56]
	mov	r12, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]

; 435  : }

	add	rsp, 72					; 00000048H
	ret	0
$LN42@OmfFixGenF@2:
	DD	$LN12@OmfFixGenF@2
	DD	$LN10@OmfFixGenF@2
	DD	$LN8@OmfFixGenF@2
	DD	$LN11@OmfFixGenF@2
	DD	$LN9@OmfFixGenF@2
	DD	$LN7@OmfFixGenF@2
	DD	$LN2@OmfFixGenF@2
	DD	$LN5@OmfFixGenF@2
	DD	$LN4@OmfFixGenF@2
	DD	$LN3@OmfFixGenF@2
	DD	$LN6@OmfFixGenF@2
OmfFixGenFix ENDP
_TEXT	ENDS
END
