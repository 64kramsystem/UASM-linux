; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
$SG2597	DB	'omfint.c', 00H
	ORG $+7
$SG2704	DB	'omfint.c', 00H
_DATA	ENDS
CONST	SEGMENT
myFuncs	DQ	FLAT:writeUnexp
	DQ	FLAT:writeMisc
	DQ	FLAT:writeMisc32
	DQ	FLAT:writeSegdef
	DQ	FLAT:writeLedata
	DQ	FLAT:writeComent
	DQ	FLAT:writeTheadr
	DQ	FLAT:writeModend
	DQ	FLAT:writePubdef
	DQ	FLAT:writeLinnum
	DQ	FLAT:writeComdat
	DQ	FLAT:writeLinsym
func_index DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	05H
	DB	07H
	DB	01H
	DB	00H
	DB	08H
	DB	00H
	DB	09H
	DB	01H
	DB	03H
	DB	01H
	DB	02H
	DB	00H
	DB	04H
	DB	04H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	02H
	DB	01H
	DB	08H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	0aH
	DB	0bH
	DB	01H
	DB	02H
	DB	01H
CONST	ENDS
EXTRN	WriteError:NEAR
EXTRN	fwrite:NEAR
xdata	SEGMENT
$unwind$safeWrite DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$safeWrite DD @imagerel(safeWrite#)
	DD	@imagerel(safeWrite#+47)
	DD	@imagerel($unwind$safeWrite#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\omfint.c
pdata	ENDS
_TEXT	SEGMENT
file$ = 48
buf$ = 56
len$ = 64
safeWrite PROC NEAR

; 56   : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, rdx

; 57   :     if( fwrite( buf, 1, len, file ) != len )

	mov	ebx, r8d
	mov	r9, rcx
	mov	r8d, r8d
	mov	edx, 1
	mov	rcx, rax
	call	fwrite
	cmp	rax, rbx
	je	SHORT $LN1@safeWrite

; 58   :         WriteError();

	call	WriteError
$LN1@safeWrite:

; 59   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
safeWrite ENDP
; Function compile flags: /Ogtpy
out$ = 8
command$ = 16
WBegRec	PROC NEAR

; 79   :     out->in_buf = 0;

	mov	DWORD PTR [rcx], 0

; 80   :     out->cmd = command;

	mov	BYTE PTR [rcx+4], dl

; 81   : }

	ret	0
WBegRec	ENDP
_TEXT	ENDS
EXTRN	ModuleInfo:BYTE
xdata	SEGMENT
$unwind$WEndRec DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$WEndRec DD @imagerel(WEndRec#)
	DD	@imagerel(WEndRec#+35)
	DD	@imagerel($unwind$WEndRec#)
pdata	ENDS
xdata	SEGMENT
$chain$1$WEndRec DD 045421H
	DD	083454H
	DD	097405H
	DD	@imagerel(WEndRec#)
	DD	@imagerel(WEndRec#+35)
	DD	@imagerel($unwind$WEndRec#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$WEndRec DD @imagerel(WEndRec#+35)
	DD	@imagerel(WEndRec#+171)
	DD	@imagerel($chain$1$WEndRec#)
pdata	ENDS
xdata	SEGMENT
$chain$2$WEndRec DD 021H
	DD	@imagerel(WEndRec#)
	DD	@imagerel(WEndRec#+35)
	DD	@imagerel($unwind$WEndRec#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$WEndRec DD @imagerel(WEndRec#+171)
	DD	@imagerel(WEndRec#+181)
	DD	@imagerel($chain$2$WEndRec#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
out$ = 48
WEndRec	PROC NEAR

; 91   : {

	sub	rsp, 40					; 00000028H

; 92   :     uint_8  checksum;
; 93   :     uint_8  *p;
; 94   :     uint_8  *end;
; 95   : 
; 96   :     /**/myassert( out && out->cmd );
; 97   : 
; 98   :     out->reclen = out->in_buf + 1; /* add 1 for checksum byte */

	movzx	r10d, WORD PTR [rcx]

; 99   :     checksum = out->cmd + ( out->reclen & 0xff ) + (( out->reclen ) >> 8);
; 100  :     for( p = out->buffer, end = p + out->in_buf; p < end; ) {

	lea	rdx, QWORD PTR [rcx+7]
	mov	r11, rcx
	inc	r10w
	xor	r8b, r8b
	xor	r9b, r9b
	mov	WORD PTR [rcx+5], r10w
	shr	r10w, 8
	mov	QWORD PTR [rsp+72], rdi
	add	r10b, BYTE PTR [rcx+5]
	add	r10b, BYTE PTR [rcx+4]
	mov	ecx, DWORD PTR [rcx]
	add	rcx, rdx
	mov	rax, rcx
	sub	rax, rdx
	cmp	rax, 2
	jl	SHORT $LC11@WEndRec
	lea	rax, QWORD PTR [rcx-1]
	npad	11
$LL12@WEndRec:

; 101  :         checksum += *p++;

	add	r8b, BYTE PTR [rdx]
	add	r9b, BYTE PTR [rdx+1]
	add	rdx, 2
	cmp	rdx, rax
	jl	SHORT $LL12@WEndRec
$LC11@WEndRec:

; 99   :     checksum = out->cmd + ( out->reclen & 0xff ) + (( out->reclen ) >> 8);
; 100  :     for( p = out->buffer, end = p + out->in_buf; p < end; ) {

	cmp	rdx, rcx
	jae	SHORT $LN10@WEndRec

; 101  :         checksum += *p++;

	add	r10b, BYTE PTR [rdx]
	inc	rdx
$LN10@WEndRec:
	add	r8b, r9b

; 102  :     }
; 103  :     checksum = - checksum;
; 104  :     *p = checksum; /* store chksum in buffer */
; 105  : 
; 106  :     /* write buffer + 4 extra bytes (1 cmd, 2 length, 1 chksum) */
; 107  :     safeWrite( CurrFile[OBJ], &out->cmd, out->in_buf + 4 );

	lea	rcx, QWORD PTR [r11+4]
	mov	QWORD PTR [rsp+64], rbx
	add	r8b, r10b
	neg	r8b
	mov	BYTE PTR [rdx], r8b
	mov	eax, DWORD PTR [r11]
	mov	r9, QWORD PTR ModuleInfo+104
	add	eax, 4
	mov	edx, 1
	mov	r8d, eax
	mov	ebx, eax
	call	fwrite
	mov	rdi, QWORD PTR [rsp+72]
	cmp	rax, rbx
	mov	rbx, QWORD PTR [rsp+64]
	je	SHORT $LN5@WEndRec
	call	WriteError
$LN5@WEndRec:

; 108  : 
; 109  : #if 0 //def DEBUG_OUT
; 110  :     p = &out->cmd;
; 111  :     DebugMsg1(("WEndRec: %X %X %X %X\n", *p, *(p+1), *(p+2), *(p+3) ));
; 112  :     //printf( "WEndRec: %X %X %X %X (ofs cmd=%u ofs reclen=%u)\n", *p, *(p+1), *(p+2), *(p+3), offsetof( struct outbuff, cmd ), offsetof( struct outbuff, reclen ) );
; 113  : #endif
; 114  : 
; 115  : }

	add	rsp, 40					; 00000028H
	ret	0
WEndRec	ENDP
; Function compile flags: /Ogtpy
out$ = 8
value$ = 16
PutByte	PROC NEAR

; 122  :     out->buffer[ out->in_buf++ ] = value;

	mov	eax, DWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx+7], dl
	inc	DWORD PTR [rcx]

; 123  : }

	ret	0
PutByte	ENDP
; Function compile flags: /Ogtpy
out$ = 8
index$ = 16
PutIndex PROC NEAR

; 130  :     if( index > 0x7f ) {

	cmp	dx, 127					; 0000007fH
	jbe	SHORT $LN4@PutIndex

; 131  :         PutByte( out, 0x80 | ( index >> 8 ) );

	mov	eax, DWORD PTR [rcx]
	movzx	r8d, dx
	shr	r8w, 8
	or	r8b, 128				; 00000080H
	mov	BYTE PTR [rax+rcx+7], r8b
	inc	DWORD PTR [rcx]
$LN4@PutIndex:

; 132  :     }
; 133  :     PutByte( out, index & 0xff );

	mov	eax, DWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx+7], dl
	inc	DWORD PTR [rcx]

; 134  : }

	ret	0
PutIndex ENDP
; Function compile flags: /Ogtpy
out$ = 8
value$ = 16
PutWord	PROC NEAR

; 141  :     WriteU16( out->buffer + out->in_buf, value );

	mov	eax, DWORD PTR [rcx]
	mov	WORD PTR [rax+rcx+7], dx

; 142  :     out->in_buf += sizeof( uint_16 );

	add	DWORD PTR [rcx], 2

; 143  : }

	ret	0
PutWord	ENDP
; Function compile flags: /Ogtpy
out$ = 8
value$ = 16
PutDword PROC NEAR

; 150  :     WriteU32( out->buffer + out->in_buf, value );

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rax+rcx+7], edx

; 151  :     out->in_buf += sizeof( uint_32 );

	add	DWORD PTR [rcx], 4

; 152  : }

	ret	0
PutDword ENDP
_TEXT	ENDS
EXTRN	Fatal:NEAR
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$PutMem DD 051801H
	DD	097418H
	DD	083409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$PutMem DD @imagerel(PutMem#)
	DD	@imagerel(PutMem#+100)
	DD	@imagerel($unwind$PutMem#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
out$ = 48
buf$ = 56
length$ = 64
PutMem	PROC NEAR

; 158  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rbx
	mov	rbx, rcx

; 159  :     /* ensure that there is enough free space in the buffer,
; 160  :      * and also 1 byte left for the chksum!
; 161  :      */
; 162  :     if( length <= OBJ_BUFFER_SIZE - 1 - out->in_buf ) {

	mov	ecx, DWORD PTR [rcx]
	mov	eax, 4079				; 00000fefH
	mov	QWORD PTR [rsp+72], rdi
	mov	edi, r8d
	sub	eax, ecx
	cmp	r8d, eax
	ja	SHORT $LN2@PutMem

; 163  :         memcpy( &out->buffer[ out->in_buf ], buf, length );

	lea	rcx, QWORD PTR [rcx+rbx+7]
	mov	r8, rdi
	call	memcpy

; 164  :         out->in_buf += length;

	add	DWORD PTR [rbx], edi
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 169  :     }
; 170  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@PutMem:

; 165  :     } else {
; 166  :         /* this "shouldn't happen". */
; 167  :         DebugMsg(("PutMem: buffer overflow error [length=%u, free=%u]\n", length, OBJ_BUFFER_SIZE - 1 - out->in_buf ));
; 168  :         Fatal( INTERNAL_ERROR, __FILE__, __LINE__ );

	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG2597
	lea	ecx, QWORD PTR [r8-58]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 169  :     }
; 170  : }

	add	rsp, 40					; 00000028H
	jmp	Fatal
PutMem	ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$writeMisc DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$writeMisc DD @imagerel(writeMisc#)
	DD	@imagerel(writeMisc#+8)
	DD	@imagerel($unwind$writeMisc#)
pdata	ENDS
xdata	SEGMENT
$chain$1$writeMisc DD 040a21H
	DD	08640aH
	DD	073405H
	DD	@imagerel(writeMisc#)
	DD	@imagerel(writeMisc#+8)
	DD	@imagerel($unwind$writeMisc#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$writeMisc DD @imagerel(writeMisc#+8)
	DD	@imagerel(writeMisc#+22)
	DD	@imagerel($chain$1$writeMisc#)
pdata	ENDS
xdata	SEGMENT
$chain$2$writeMisc DD 020521H
	DD	097405H
	DD	@imagerel(writeMisc#+8)
	DD	@imagerel(writeMisc#+22)
	DD	@imagerel($chain$1$writeMisc#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$writeMisc DD @imagerel(writeMisc#+22)
	DD	@imagerel(writeMisc#+147)
	DD	@imagerel($chain$2$writeMisc#)
pdata	ENDS
xdata	SEGMENT
$chain$3$writeMisc DD 021H
	DD	@imagerel(writeMisc#+8)
	DD	@imagerel(writeMisc#+22)
	DD	@imagerel($chain$1$writeMisc#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$writeMisc DD @imagerel(writeMisc#+147)
	DD	@imagerel(writeMisc#+244)
	DD	@imagerel($chain$3$writeMisc#)
pdata	ENDS
xdata	SEGMENT
$chain$4$writeMisc DD 021H
	DD	@imagerel(writeMisc#)
	DD	@imagerel(writeMisc#+8)
	DD	@imagerel($unwind$writeMisc#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$writeMisc DD @imagerel(writeMisc#+244)
	DD	@imagerel(writeMisc#+256)
	DD	@imagerel($chain$4$writeMisc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeMisc PROC NEAR

; 178  : {

	sub	rsp, 40					; 00000028H

; 179  :     /**/myassert( objr->data != NULL );
; 180  : 
; 181  :     WBegRec( out, objr->command );

	movzx	eax, BYTE PTR [rdx+16]
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi
	lea	rsi, QWORD PTR [rcx+4]
	mov	QWORD PTR [rsp+72], rdi
	mov	DWORD PTR [rcx], 0
	mov	BYTE PTR [rsi], al

; 182  :     PutMem( out, objr->data, objr->length );

	mov	edi, DWORD PTR [rdx]
	mov	rbx, rcx
	cmp	edi, 4079				; 00000fefH
	ja	SHORT $LN6@writeMisc
	mov	rdx, QWORD PTR [rdx+8]
	mov	r8, rdi
	add	rcx, 7
	call	memcpy
	add	DWORD PTR [rbx], edi
	jmp	SHORT $LN5@writeMisc
$LN6@writeMisc:
	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG2597
	lea	ecx, QWORD PTR [r8-58]
	call	Fatal
$LN5@writeMisc:

; 183  :     WEndRec( out );

	movzx	r10d, WORD PTR [rbx]
	mov	ecx, DWORD PTR [rbx]
	mov	rdi, QWORD PTR [rsp+72]
	inc	r10w
	lea	rdx, QWORD PTR [rbx+7]
	xor	r9b, r9b
	mov	WORD PTR [rbx+5], r10w
	shr	r10w, 8
	add	rcx, rdx
	add	r10b, BYTE PTR [rbx+5]
	mov	rax, rcx
	xor	r8b, r8b
	add	r10b, BYTE PTR [rsi]
	sub	rax, rdx
	cmp	rax, 2
	jl	SHORT $LC19@writeMisc
	lea	rax, QWORD PTR [rcx-1]
	npad	9
$LL20@writeMisc:
	add	r9b, BYTE PTR [rdx]
	add	r8b, BYTE PTR [rdx+1]
	add	rdx, 2
	cmp	rdx, rax
	jl	SHORT $LL20@writeMisc
$LC19@writeMisc:
	cmp	rdx, rcx
	jae	SHORT $LN18@writeMisc
	add	r10b, BYTE PTR [rdx]
	inc	rdx
$LN18@writeMisc:
	add	r8b, r9b
	mov	rcx, rsi
	add	r8b, r10b
	neg	r8b
	mov	BYTE PTR [rdx], r8b
	mov	eax, DWORD PTR [rbx]
	mov	r9, QWORD PTR ModuleInfo+104
	add	eax, 4
	mov	edx, 1
	mov	r8d, eax
	mov	ebx, eax
	call	fwrite
	mov	rsi, QWORD PTR [rsp+64]
	cmp	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	je	SHORT $LN21@writeMisc
	call	WriteError
$LN21@writeMisc:

; 184  :     return( 0 );

	xor	eax, eax

; 185  : }

	add	rsp, 40					; 00000028H
	ret	0
writeMisc ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$writeMisc32 DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$writeMisc32 DD @imagerel(writeMisc32#)
	DD	@imagerel(writeMisc32#+8)
	DD	@imagerel($unwind$writeMisc32#)
pdata	ENDS
xdata	SEGMENT
$chain$1$writeMisc32 DD 040a21H
	DD	08640aH
	DD	073405H
	DD	@imagerel(writeMisc32#)
	DD	@imagerel(writeMisc32#+8)
	DD	@imagerel($unwind$writeMisc32#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$writeMisc32 DD @imagerel(writeMisc32#+8)
	DD	@imagerel(writeMisc32#+25)
	DD	@imagerel($chain$1$writeMisc32#)
pdata	ENDS
xdata	SEGMENT
$chain$2$writeMisc32 DD 020521H
	DD	097405H
	DD	@imagerel(writeMisc32#+8)
	DD	@imagerel(writeMisc32#+25)
	DD	@imagerel($chain$1$writeMisc32#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$writeMisc32 DD @imagerel(writeMisc32#+25)
	DD	@imagerel(writeMisc32#+150)
	DD	@imagerel($chain$2$writeMisc32#)
pdata	ENDS
xdata	SEGMENT
$chain$3$writeMisc32 DD 021H
	DD	@imagerel(writeMisc32#+8)
	DD	@imagerel(writeMisc32#+25)
	DD	@imagerel($chain$1$writeMisc32#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$writeMisc32 DD @imagerel(writeMisc32#+150)
	DD	@imagerel(writeMisc32#+244)
	DD	@imagerel($chain$3$writeMisc32#)
pdata	ENDS
xdata	SEGMENT
$chain$4$writeMisc32 DD 021H
	DD	@imagerel(writeMisc32#)
	DD	@imagerel(writeMisc32#+8)
	DD	@imagerel($unwind$writeMisc32#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$writeMisc32 DD @imagerel(writeMisc32#+244)
	DD	@imagerel(writeMisc32#+256)
	DD	@imagerel($chain$4$writeMisc32#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeMisc32 PROC NEAR

; 191  : {

	sub	rsp, 40					; 00000028H

; 192  :     /**/myassert( objr->data != NULL );
; 193  : 
; 194  :     WBegRec( out, objr->command | objr->is_32 );

	movzx	eax, BYTE PTR [rdx+17]
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi
	or	al, BYTE PTR [rdx+16]
	lea	rsi, QWORD PTR [rcx+4]
	mov	QWORD PTR [rsp+72], rdi
	mov	DWORD PTR [rcx], 0
	mov	BYTE PTR [rsi], al

; 195  :     PutMem( out, objr->data, objr->length );

	mov	edi, DWORD PTR [rdx]
	cmp	edi, 4079				; 00000fefH
	mov	rbx, rcx
	ja	SHORT $LN6@writeMisc3
	mov	rdx, QWORD PTR [rdx+8]
	mov	r8, rdi
	add	rcx, 7
	call	memcpy
	add	DWORD PTR [rbx], edi
	jmp	SHORT $LN5@writeMisc3
$LN6@writeMisc3:
	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG2597
	lea	ecx, QWORD PTR [r8-58]
	call	Fatal
$LN5@writeMisc3:

; 196  :     WEndRec( out );

	movzx	r10d, WORD PTR [rbx]
	mov	ecx, DWORD PTR [rbx]
	mov	rdi, QWORD PTR [rsp+72]
	inc	r10w
	lea	rdx, QWORD PTR [rbx+7]
	xor	r9b, r9b
	mov	WORD PTR [rbx+5], r10w
	shr	r10w, 8
	add	rcx, rdx
	add	r10b, BYTE PTR [rbx+5]
	mov	rax, rcx
	xor	r8b, r8b
	add	r10b, BYTE PTR [rsi]
	sub	rax, rdx
	cmp	rax, 2
	jl	SHORT $LC19@writeMisc3
	lea	rax, QWORD PTR [rcx-1]
	npad	6
$LL20@writeMisc3:
	add	r9b, BYTE PTR [rdx]
	add	r8b, BYTE PTR [rdx+1]
	add	rdx, 2
	cmp	rdx, rax
	jl	SHORT $LL20@writeMisc3
$LC19@writeMisc3:
	cmp	rdx, rcx
	jae	SHORT $LN18@writeMisc3
	add	r10b, BYTE PTR [rdx]
	inc	rdx
$LN18@writeMisc3:
	add	r8b, r9b
	mov	rcx, rsi
	add	r8b, r10b
	neg	r8b
	mov	BYTE PTR [rdx], r8b
	mov	eax, DWORD PTR [rbx]
	mov	r9, QWORD PTR ModuleInfo+104
	add	eax, 4
	mov	edx, 1
	mov	r8d, eax
	mov	ebx, eax
	call	fwrite
	mov	rsi, QWORD PTR [rsp+64]
	cmp	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	je	SHORT $LN21@writeMisc3
	call	WriteError
$LN21@writeMisc3:

; 197  :     return( 0 );

	xor	eax, eax

; 198  : }

	add	rsp, 40					; 00000028H
	ret	0
writeMisc32 ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$writeComent DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$writeComent DD @imagerel(writeComent#)
	DD	@imagerel(writeComent#+30)
	DD	@imagerel($unwind$writeComent#)
pdata	ENDS
xdata	SEGMENT
$chain$1$writeComent DD 041521H
	DD	075415H
	DD	063405H
	DD	@imagerel(writeComent#)
	DD	@imagerel(writeComent#+30)
	DD	@imagerel($unwind$writeComent#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$writeComent DD @imagerel(writeComent#+30)
	DD	@imagerel(writeComent#+51)
	DD	@imagerel($chain$1$writeComent#)
pdata	ENDS
xdata	SEGMENT
$chain$3$writeComent DD 040c21H
	DD	09740cH
	DD	086405H
	DD	@imagerel(writeComent#+30)
	DD	@imagerel(writeComent#+51)
	DD	@imagerel($chain$1$writeComent#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$writeComent DD @imagerel(writeComent#+51)
	DD	@imagerel(writeComent#+175)
	DD	@imagerel($chain$3$writeComent#)
pdata	ENDS
xdata	SEGMENT
$chain$4$writeComent DD 020021H
	DD	097400H
	DD	@imagerel(writeComent#+30)
	DD	@imagerel(writeComent#+51)
	DD	@imagerel($chain$1$writeComent#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$writeComent DD @imagerel(writeComent#+175)
	DD	@imagerel(writeComent#+279)
	DD	@imagerel($chain$4$writeComent#)
pdata	ENDS
xdata	SEGMENT
$chain$5$writeComent DD 021H
	DD	@imagerel(writeComent#)
	DD	@imagerel(writeComent#+30)
	DD	@imagerel($unwind$writeComent#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$writeComent DD @imagerel(writeComent#+279)
	DD	@imagerel(writeComent#+291)
	DD	@imagerel($chain$5$writeComent#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeComent PROC NEAR

; 202  : {

	sub	rsp, 40					; 00000028H

; 203  :     /**/myassert( objr->data != NULL );
; 204  : 
; 205  :     WBegRec( out, CMD_COMENT );

	mov	DWORD PTR [rcx], 0
	mov	BYTE PTR [rcx+4], 136			; 00000088H

; 206  :     PutByte( out, objr->d.coment.attr );

	movzx	eax, BYTE PTR [rdx+20]
	mov	BYTE PTR [rcx+7], al
	inc	DWORD PTR [rcx]
	mov	r8d, DWORD PTR [rcx]

; 207  :     PutByte( out, objr->d.coment.cmt_class );

	movzx	eax, BYTE PTR [rdx+21]
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rcx+7]
	mov	BYTE PTR [r8+rcx+7], al
	inc	DWORD PTR [rcx]
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi

; 208  :     PutMem( out, objr->data, objr->length );

	mov	esi, DWORD PTR [rdx]
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx
	mov	ecx, DWORD PTR [rcx]
	mov	eax, 4079				; 00000fefH
	sub	eax, ecx
	cmp	esi, eax
	ja	SHORT $LN10@writeComen
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, QWORD PTR [rcx+rdi+7]
	mov	r8, rsi
	call	memcpy
	add	DWORD PTR [rdi], esi
	jmp	SHORT $LN9@writeComen
$LN10@writeComen:
	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG2597
	lea	ecx, QWORD PTR [r8-58]
	call	Fatal
$LN9@writeComen:

; 209  :     WEndRec( out );

	movzx	r9d, WORD PTR [rdi]
	mov	ecx, DWORD PTR [rdi]
	mov	rsi, QWORD PTR [rsp+64]
	inc	r9w
	add	rcx, rbx
	xor	r8b, r8b
	mov	WORD PTR [rdi+5], r9w
	shr	r9w, 8
	mov	rax, rcx
	add	r9b, BYTE PTR [rdi+5]
	sub	rax, rbx
	xor	dl, dl
	add	r9b, BYTE PTR [rdi+4]
	cmp	rax, 2
	jl	SHORT $LC23@writeComen
	lea	rax, QWORD PTR [rcx-1]
	npad	13
$LL24@writeComen:
	add	r8b, BYTE PTR [rbx]
	add	dl, BYTE PTR [rbx+1]
	add	rbx, 2
	cmp	rbx, rax
	jl	SHORT $LL24@writeComen
$LC23@writeComen:
	cmp	rbx, rcx
	jae	SHORT $LN22@writeComen
	add	r9b, BYTE PTR [rbx]
	inc	rbx
$LN22@writeComen:
	add	dl, r8b
	lea	rcx, QWORD PTR [rdi+4]
	add	dl, r9b
	neg	dl
	mov	BYTE PTR [rbx], dl
	mov	eax, DWORD PTR [rdi]
	mov	r9, QWORD PTR ModuleInfo+104
	add	eax, 4
	mov	edx, 1
	mov	r8d, eax
	mov	ebx, eax
	call	fwrite
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+56]
	cmp	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	je	SHORT $LN25@writeComen
	call	WriteError
$LN25@writeComen:

; 210  :     return( 0 );

	xor	eax, eax

; 211  : }

	add	rsp, 40					; 00000028H
	ret	0
writeComent ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$writeSegdef DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$writeSegdef DD @imagerel(writeSegdef#)
	DD	@imagerel(writeSegdef#+15)
	DD	@imagerel($unwind$writeSegdef#)
pdata	ENDS
xdata	SEGMENT
$chain$1$writeSegdef DD 04ef21H
	DD	0834efH
	DD	097405H
	DD	@imagerel(writeSegdef#)
	DD	@imagerel(writeSegdef#+15)
	DD	@imagerel($unwind$writeSegdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$writeSegdef DD @imagerel(writeSegdef#+15)
	DD	@imagerel(writeSegdef#+453)
	DD	@imagerel($chain$1$writeSegdef#)
pdata	ENDS
xdata	SEGMENT
$chain$2$writeSegdef DD 021H
	DD	@imagerel(writeSegdef#)
	DD	@imagerel(writeSegdef#+15)
	DD	@imagerel($unwind$writeSegdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$writeSegdef DD @imagerel(writeSegdef#+453)
	DD	@imagerel(writeSegdef#+465)
	DD	@imagerel($chain$2$writeSegdef#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeSegdef PROC NEAR

; 215  : {

	sub	rsp, 40					; 00000028H

; 216  :     int         is32;
; 217  :     uint_8      acbp;
; 218  :     uint_8      align;
; 219  : 
; 220  :     /**/myassert( objr->command == CMD_SEGDEF );
; 221  : 
; 222  :     //is32 = objr->d.segdef.use_32;
; 223  :     is32 = objr->is_32;

	movzx	r11d, BYTE PTR [rdx+17]

; 224  :     WBegRec( out, CMD_SEGDEF + is32 );

	mov	DWORD PTR [rcx], 0
	mov	QWORD PTR [rsp+72], rdi
	lea	rdi, QWORD PTR [rcx+4]
	lea	eax, DWORD PTR [r11-104]
	mov	r8, rcx
	mov	BYTE PTR [rdi], al

; 225  : 
; 226  :     /* ACBP: bits=AAACCCBP
; 227  :      * AAA=alignment
; 228  :      * CCC=combination
; 229  :      * B=big
; 230  :      * P=32bit
; 231  :      */
; 232  :     acbp = ( objr->d.segdef.combine << 2 ) | objr->d.segdef.use_32;
; 233  :     align = objr->d.segdef.align;

	movzx	ecx, BYTE PTR [rdx+23]
	mov	r9, rdx

; 234  : #if 1
; 235  :     acbp |= align << 5;

	movzx	eax, cl
	shl	al, 3
	or	al, BYTE PTR [rdx+24]
	shl	al, 2
	or	al, BYTE PTR [rdx+22]

; 236  : #else
; 237  :     switch( align ) {
; 238  :     case SEGDEF_ALIGN_ABS:      acbp |= ALIGN_ABS << 5;     break;
; 239  :     case SEGDEF_ALIGN_BYTE:     acbp |= ALIGN_BYTE << 5;    break;
; 240  :     case SEGDEF_ALIGN_WORD:     acbp |= ALIGN_WORD << 5;    break;
; 241  :     case SEGDEF_ALIGN_PARA:     acbp |= ALIGN_PARA << 5;    break;
; 242  :     case SEGDEF_ALIGN_PAGE:     acbp |= ALIGN_PAGE << 5;    break;
; 243  :     case SEGDEF_ALIGN_DWORD:    acbp |= ALIGN_DWORD << 5;   break;
; 244  : #if PAGE4K
; 245  :     case SEGDEF_ALIGN_4KPAGE:   acbp |= ALIGN_4KPAGE << 5;  break;
; 246  : #endif
; 247  :     default: /**/myassert( 0 );
; 248  :     }
; 249  : #endif
; 250  :     /* set BIG bit. should also be done for 32-bit segments
; 251  :      * if their size is exactly 4 GB. Currently HJWasm won't
; 252  :      * support segments with size 4 GB.
; 253  :      */
; 254  :     if( is32 == 0 && objr->d.segdef.seg_length == 0x10000 ) {

	test	r11d, r11d
	jne	SHORT $LN4@writeSegde
	cmp	DWORD PTR [rdx+36], 65536		; 00010000H
	jne	SHORT $LN4@writeSegde

; 255  :         acbp |= 0x02;

	or	al, 2
$LN4@writeSegde:

; 256  :     }
; 257  : 
; 258  :     /* the segdef record is small (16bit: size 6 - 9 ):
; 259  :      * - byte acbp
; 260  :      * - word (32bit:dword) length
; 261  :      * - index seg name
; 262  :      * - index class name
; 263  :      * - index ovl name
; 264  :      * ABS segdefs are 3 bytes longer
; 265  :     */
; 266  : 
; 267  :     PutByte( out, acbp );

	mov	BYTE PTR [r8+7], al
	inc	DWORD PTR [r8]

; 268  :     if( align == SEGDEF_ALIGN_ABS ) {

	test	cl, cl
	mov	r10d, DWORD PTR [r8]
	lea	rdx, QWORD PTR [r8+7]
	jne	SHORT $LN13@writeSegde

; 269  :         /* absolut segment has frame=word and offset=byte
; 270  :          * it isn't fixupp physical reference
; 271  :          * and doesn't depend on segment size (16/32bit)
; 272  :          */
; 273  :         PutWord( out, objr->d.segdef.abs.frame );

	movzx	eax, WORD PTR [r9+28]
	mov	WORD PTR [r10+r8+7], ax
	add	DWORD PTR [r8], 2
	mov	ecx, DWORD PTR [r8]

; 274  :         PutByte( out, objr->d.segdef.abs.offset );

	movzx	eax, BYTE PTR [r9+32]
	mov	BYTE PTR [rcx+r8+7], al
	inc	DWORD PTR [r8]
	mov	r10d, DWORD PTR [r8]
$LN13@writeSegde:

; 275  :     }
; 276  :     if( is32 ) {

	test	r11d, r11d
	je	SHORT $LN2@writeSegde

; 277  :         PutDword( out, objr->d.segdef.seg_length );

	mov	eax, DWORD PTR [r9+36]
	mov	ecx, r10d
	mov	DWORD PTR [rcx+r8+7], eax
	add	DWORD PTR [r8], 4

; 278  :     } else {

	jmp	SHORT $LN17@writeSegde
$LN2@writeSegde:

; 279  :         PutWord( out, objr->d.segdef.seg_length );

	movzx	eax, WORD PTR [r9+36]
	mov	ecx, r10d
	mov	WORD PTR [rcx+r8+7], ax
	add	DWORD PTR [r8], 2
$LN17@writeSegde:

; 280  :     }
; 281  : 
; 282  :     PutIndex( out, objr->d.segdef.seg_lname_idx );

	movzx	r10d, WORD PTR [r9+40]
	cmp	r10w, 127				; 0000007fH
	jbe	SHORT $LN22@writeSegde
	mov	eax, DWORD PTR [r8]
	movzx	ecx, r10w
	shr	cx, 8
	or	cl, 128					; 00000080H
	mov	BYTE PTR [rax+r8+7], cl
	inc	DWORD PTR [r8]
$LN22@writeSegde:
	mov	eax, DWORD PTR [r8]
	mov	BYTE PTR [rax+r8+7], r10b
	inc	DWORD PTR [r8]

; 283  :     PutIndex( out, objr->d.segdef.class_lname_idx );

	movzx	r10d, WORD PTR [r9+42]
	cmp	r10w, 127				; 0000007fH
	mov	r11d, DWORD PTR [r8]
	jbe	SHORT $LN29@writeSegde
	movzx	ecx, r10w
	shr	cx, 8
	or	cl, 128					; 00000080H
	mov	BYTE PTR [r11+r8+7], cl
	inc	DWORD PTR [r8]
	mov	r11d, DWORD PTR [r8]
$LN29@writeSegde:
	mov	eax, r11d
	mov	QWORD PTR [rsp+64], rbx
	mov	BYTE PTR [rax+r8+7], r10b
	inc	DWORD PTR [r8]

; 284  :     PutIndex( out, objr->d.segdef.ovl_lname_idx );

	movzx	ebx, WORD PTR [r9+44]
	cmp	bx, 127					; 0000007fH
	mov	r11d, DWORD PTR [r8]
	jbe	SHORT $LN36@writeSegde
	movzx	ecx, bx
	shr	cx, 8
	or	cl, 128					; 00000080H
	mov	BYTE PTR [r11+r8+7], cl
	inc	DWORD PTR [r8]
	mov	r11d, DWORD PTR [r8]
$LN36@writeSegde:
	mov	eax, r11d
	xor	r9b, r9b
	xor	r10b, r10b
	mov	BYTE PTR [rax+r8+7], bl
	inc	DWORD PTR [r8]

; 285  :     //if( objr->d.segdef.access_valid ) {
; 286  :     //    EmitError( ACCESS_CLASSES_NOT_SUPPORTED );
; 287  :     //}
; 288  :     WEndRec( out );

	movzx	r11d, WORD PTR [r8]
	mov	ecx, DWORD PTR [r8]
	inc	r11w
	mov	WORD PTR [r8+5], r11w
	shr	r11w, 8
	add	rcx, rdx
	add	r11b, BYTE PTR [rdi]
	mov	rax, rcx
	add	r11b, BYTE PTR [r8+5]
	sub	rax, rdx
	cmp	rax, 2
	jl	SHORT $LC50@writeSegde
	lea	rax, QWORD PTR [rcx-1]
	npad	7
$LL51@writeSegde:
	add	r9b, BYTE PTR [rdx]
	add	r10b, BYTE PTR [rdx+1]
	add	rdx, 2
	cmp	rdx, rax
	jl	SHORT $LL51@writeSegde
$LC50@writeSegde:
	cmp	rdx, rcx
	jae	SHORT $LN49@writeSegde
	add	r11b, BYTE PTR [rdx]
	inc	rdx
$LN49@writeSegde:
	add	r9b, r10b
	mov	rcx, rdi
	add	r9b, r11b
	neg	r9b
	mov	BYTE PTR [rdx], r9b
	mov	eax, DWORD PTR [r8]
	mov	r9, QWORD PTR ModuleInfo+104
	add	eax, 4
	mov	edx, 1
	mov	r8d, eax
	mov	ebx, eax
	call	fwrite
	mov	rdi, QWORD PTR [rsp+72]
	cmp	rax, rbx
	mov	rbx, QWORD PTR [rsp+64]
	je	SHORT $LN52@writeSegde
	call	WriteError
$LN52@writeSegde:

; 289  :     return( 0 );

	xor	eax, eax

; 290  : }

	add	rsp, 40					; 00000028H
	ret	0
writeSegdef ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$writeLedata DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$writeLedata DD @imagerel(writeLedata#)
	DD	@imagerel(writeLedata#+8)
	DD	@imagerel($unwind$writeLedata#)
pdata	ENDS
xdata	SEGMENT
$chain$1$writeLedata DD 040a21H
	DD	08640aH
	DD	073405H
	DD	@imagerel(writeLedata#)
	DD	@imagerel(writeLedata#+8)
	DD	@imagerel($unwind$writeLedata#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$writeLedata DD @imagerel(writeLedata#+8)
	DD	@imagerel(writeLedata#+108)
	DD	@imagerel($chain$1$writeLedata#)
pdata	ENDS
xdata	SEGMENT
$chain$2$writeLedata DD 020521H
	DD	097405H
	DD	@imagerel(writeLedata#+8)
	DD	@imagerel(writeLedata#+108)
	DD	@imagerel($chain$1$writeLedata#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$writeLedata DD @imagerel(writeLedata#+108)
	DD	@imagerel(writeLedata#+226)
	DD	@imagerel($chain$2$writeLedata#)
pdata	ENDS
xdata	SEGMENT
$chain$3$writeLedata DD 021H
	DD	@imagerel(writeLedata#+8)
	DD	@imagerel(writeLedata#+108)
	DD	@imagerel($chain$1$writeLedata#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$writeLedata DD @imagerel(writeLedata#+226)
	DD	@imagerel(writeLedata#+324)
	DD	@imagerel($chain$3$writeLedata#)
pdata	ENDS
xdata	SEGMENT
$chain$4$writeLedata DD 021H
	DD	@imagerel(writeLedata#)
	DD	@imagerel(writeLedata#+8)
	DD	@imagerel($unwind$writeLedata#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$writeLedata DD @imagerel(writeLedata#+324)
	DD	@imagerel(writeLedata#+336)
	DD	@imagerel($chain$4$writeLedata#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeLedata PROC NEAR

; 311  : {

	sub	rsp, 40					; 00000028H

; 312  :     /**/myassert( objr->command == CMD_LEDATA || objr->command == CMD_LIDATA );
; 313  : 
; 314  :     WBegRec( out, objr->command + objr->is_32 );

	movzx	eax, BYTE PTR [rdx+16]
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi
	add	al, BYTE PTR [rdx+17]
	lea	rsi, QWORD PTR [rcx+4]
	mov	rbx, rcx
	mov	BYTE PTR [rsi], al
	mov	DWORD PTR [rcx], 0

; 315  :     PutIndex( out, objr->d.ledata.idx );

	movzx	ecx, WORD PTR [rdx+20]
	cmp	cx, 127					; 0000007fH
	jbe	SHORT $LN10@writeLedat
	movzx	eax, cx
	shr	ax, 8
	or	al, 128					; 00000080H
	mov	BYTE PTR [rbx+7], al
	inc	DWORD PTR [rbx]
$LN10@writeLedat:
	mov	eax, DWORD PTR [rbx]
	mov	BYTE PTR [rax+rbx+7], cl
	inc	DWORD PTR [rbx]

; 316  :     if( objr->is_32 ) {

	cmp	BYTE PTR [rdx+17], 0
	mov	eax, DWORD PTR [rbx]
	je	SHORT $LN2@writeLedat

; 317  :         PutDword( out, objr->d.ledata.offset );

	mov	rcx, rax
	mov	eax, DWORD PTR [rdx+24]
	mov	DWORD PTR [rcx+rbx+7], eax
	add	DWORD PTR [rbx], 4

; 318  :     } else {

	jmp	SHORT $LN16@writeLedat
$LN2@writeLedat:

; 319  :         PutWord( out, objr->d.ledata.offset );

	mov	rcx, rax
	movzx	eax, WORD PTR [rdx+24]
	mov	WORD PTR [rcx+rbx+7], ax
	add	DWORD PTR [rbx], 2
$LN16@writeLedat:

; 320  :     }
; 321  :     PutMem( out, objr->data, objr->length );

	mov	ecx, DWORD PTR [rbx]
	mov	QWORD PTR [rsp+72], rdi
	mov	edi, DWORD PTR [rdx]
	mov	eax, 4079				; 00000fefH
	sub	eax, ecx
	cmp	edi, eax
	ja	SHORT $LN19@writeLedat
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, QWORD PTR [rcx+rbx+7]
	mov	r8, rdi
	call	memcpy
	add	DWORD PTR [rbx], edi
	jmp	SHORT $LN18@writeLedat
$LN19@writeLedat:
	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG2597
	lea	ecx, QWORD PTR [r8-58]
	call	Fatal
$LN18@writeLedat:

; 322  :     WEndRec( out );

	movzx	r10d, WORD PTR [rbx]
	mov	ecx, DWORD PTR [rbx]
	mov	rdi, QWORD PTR [rsp+72]
	inc	r10w
	lea	rdx, QWORD PTR [rbx+7]
	xor	r8b, r8b
	mov	WORD PTR [rbx+5], r10w
	shr	r10w, 8
	add	rcx, rdx
	add	r10b, BYTE PTR [rbx+5]
	mov	rax, rcx
	xor	r9b, r9b
	add	r10b, BYTE PTR [rsi]
	sub	rax, rdx
	cmp	rax, 2
	jl	SHORT $LC32@writeLedat
	lea	rax, QWORD PTR [rcx-1]
	npad	10
$LL33@writeLedat:
	add	r8b, BYTE PTR [rdx]
	add	r9b, BYTE PTR [rdx+1]
	add	rdx, 2
	cmp	rdx, rax
	jl	SHORT $LL33@writeLedat
$LC32@writeLedat:
	cmp	rdx, rcx
	jae	SHORT $LN31@writeLedat
	add	r10b, BYTE PTR [rdx]
	inc	rdx
$LN31@writeLedat:
	add	r8b, r9b
	mov	rcx, rsi
	add	r8b, r10b
	neg	r8b
	mov	BYTE PTR [rdx], r8b
	mov	eax, DWORD PTR [rbx]
	mov	r9, QWORD PTR ModuleInfo+104
	add	eax, 4
	mov	edx, 1
	mov	r8d, eax
	mov	ebx, eax
	call	fwrite
	mov	rsi, QWORD PTR [rsp+64]
	cmp	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	je	SHORT $LN34@writeLedat
	call	WriteError
$LN34@writeLedat:

; 323  :     return( 0 );

	xor	eax, eax

; 324  : }

	add	rsp, 40					; 00000028H
	ret	0
writeLedata ENDP
; Function compile flags: /Ogtpy
out$ = 8
objr$ = 16
writeTheadr PROC NEAR

; 329  :     /**/myassert( objr->command == CMD_THEADR );
; 330  : 
; 331  :     return( writeMisc( out, objr ) );
; 332  : }

	jmp	writeMisc
writeTheadr ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$writeModend DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$writeModend DD @imagerel(writeModend#)
	DD	@imagerel(writeModend#+8)
	DD	@imagerel($unwind$writeModend#)
pdata	ENDS
xdata	SEGMENT
$chain$2$writeModend DD 063221H
	DD	075432H
	DD	063426H
	DD	097405H
	DD	@imagerel(writeModend#)
	DD	@imagerel(writeModend#+8)
	DD	@imagerel($unwind$writeModend#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$writeModend DD @imagerel(writeModend#+8)
	DD	@imagerel(writeModend#+60)
	DD	@imagerel($chain$2$writeModend#)
pdata	ENDS
xdata	SEGMENT
$chain$3$writeModend DD 020521H
	DD	086405H
	DD	@imagerel(writeModend#+8)
	DD	@imagerel(writeModend#+60)
	DD	@imagerel($chain$2$writeModend#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$writeModend DD @imagerel(writeModend#+60)
	DD	@imagerel(writeModend#+209)
	DD	@imagerel($chain$3$writeModend#)
pdata	ENDS
xdata	SEGMENT
$chain$4$writeModend DD 021H
	DD	@imagerel(writeModend#+8)
	DD	@imagerel(writeModend#+60)
	DD	@imagerel($chain$2$writeModend#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$writeModend DD @imagerel(writeModend#+209)
	DD	@imagerel(writeModend#+314)
	DD	@imagerel($chain$4$writeModend#)
pdata	ENDS
xdata	SEGMENT
$chain$5$writeModend DD 021H
	DD	@imagerel(writeModend#)
	DD	@imagerel(writeModend#+8)
	DD	@imagerel($unwind$writeModend#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$writeModend DD @imagerel(writeModend#+314)
	DD	@imagerel(writeModend#+326)
	DD	@imagerel($chain$5$writeModend#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeModend PROC NEAR

; 336  : {

	sub	rsp, 40					; 00000028H

; 337  :     int     is32;
; 338  :     //uint_8  is_log;
; 339  :     uint_8  mtype;
; 340  : 
; 341  :     /**/myassert( objr->command == CMD_MODEND );
; 342  : 
; 343  :     is32 = ( ( objr->is_32 && objr->d.modend.start_addrs ) ? TRUE : FALSE );

	cmp	BYTE PTR [rdx+17], 0
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx
	je	SHORT $LN5@writeModen
	cmp	BYTE PTR [rdx+21], 0
	je	SHORT $LN5@writeModen
	mov	eax, 1
	jmp	SHORT $LN6@writeModen
$LN5@writeModen:
	xor	eax, eax
$LN6@writeModen:

; 344  :     WBegRec( out, CMD_MODEND + is32 );

	sub	al, 118					; 00000076H
	mov	DWORD PTR [rcx], 0
	mov	QWORD PTR [rsp+48], rbx
	mov	BYTE PTR [rcx+4], al

; 345  :     /* first byte is Module Type:
; 346  :      * bit 7: 1=main program module
; 347  :      * bit 6: 1=contains start address
; 348  :      * bit 5: Segment bit ( according to OMF, this bit should be 1 )
; 349  :      * bit 1-4: must be 0
; 350  :      * bit 0: start address contains relocatable address ( according to OMF, this bit should be 1 )
; 351  :      * Masm does set bit 0, but does not set bit 5!
; 352  :      */
; 353  :     mtype = objr->d.modend.main_module ? 0x80 : 0;

	movzx	eax, BYTE PTR [rdx+20]
	mov	QWORD PTR [rsp+56], rbp
	neg	al
	mov	QWORD PTR [rsp+64], rsi
	sbb	cl, cl
	and	cl, 128					; 00000080H

; 354  :     if( objr->d.modend.start_addrs ) {

	cmp	BYTE PTR [rdx+21], 0
	je	SHORT $LN2@writeModen

; 355  :         //is_log = objr->d.modend.is_logical;
; 356  :         //mtype |= 0x40 | is_log;
; 357  :         mtype |= 0x41;

	or	cl, 65					; 00000041H

; 358  :         PutByte( out, mtype );

	lea	rbx, QWORD PTR [rdi+7]

; 359  :         PutMem( out, objr->data, objr->length );

	mov	eax, 4079				; 00000fefH
	mov	BYTE PTR [rbx], cl
	inc	DWORD PTR [rdi]
	mov	ecx, DWORD PTR [rdi]
	mov	esi, DWORD PTR [rdx]
	sub	eax, ecx
	cmp	esi, eax
	ja	SHORT $LN12@writeModen
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, QWORD PTR [rcx+rdi+7]
	mov	r8, rsi
	call	memcpy
	add	DWORD PTR [rdi], esi
	jmp	SHORT $LN15@writeModen
$LN12@writeModen:
	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG2597
	lea	ecx, QWORD PTR [r8-58]
	call	Fatal

; 360  :     } else

	jmp	SHORT $LN15@writeModen
$LN2@writeModen:

; 361  :         PutByte( out, mtype );

	lea	rbx, QWORD PTR [rdi+7]
	mov	BYTE PTR [rbx], cl
	inc	DWORD PTR [rdi]
$LN15@writeModen:

; 362  : 
; 363  :     WEndRec( out );

	movzx	r10d, WORD PTR [rdi]
	mov	ecx, DWORD PTR [rdi]
	mov	rsi, QWORD PTR [rsp+64]
	inc	r10w
	add	rcx, rbx
	xor	r8b, r8b
	mov	WORD PTR [rdi+5], r10w
	shr	r10w, 8
	mov	rax, rcx
	add	r10b, BYTE PTR [rdi+5]
	sub	rax, rbx
	xor	r9b, r9b
	add	r10b, BYTE PTR [rdi+4]
	cmp	rax, 2
	jl	SHORT $LC27@writeModen
	lea	rax, QWORD PTR [rcx-1]
	npad	11
$LL28@writeModen:
	add	r8b, BYTE PTR [rbx]
	add	r9b, BYTE PTR [rbx+1]
	add	rbx, 2
	cmp	rbx, rax
	jl	SHORT $LL28@writeModen
$LC27@writeModen:
	cmp	rbx, rcx
	jae	SHORT $LN26@writeModen
	add	r10b, BYTE PTR [rbx]
	inc	rbx
$LN26@writeModen:
	add	r8b, r9b
	lea	rcx, QWORD PTR [rdi+4]
	mov	edx, 1
	add	r8b, r10b
	neg	r8b
	mov	BYTE PTR [rbx], r8b
	mov	eax, DWORD PTR [rdi]
	mov	r9, QWORD PTR ModuleInfo+104
	add	eax, 4
	mov	r8d, eax
	mov	ebx, eax
	call	fwrite
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+56]
	cmp	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	je	SHORT $LN29@writeModen
	call	WriteError
$LN29@writeModen:

; 364  :     return( 0 );

	xor	eax, eax

; 365  : }

	add	rsp, 40					; 00000028H
	ret	0
writeModend ENDP
; Function compile flags: /Ogtpy
out$ = 8
base$ = 16
PutBase	PROC NEAR

; 371  : {

	mov	r9, rcx

; 372  :     PutIndex( out, base->grp_idx );

	movzx	ecx, WORD PTR [rdx]
	cmp	cx, 127					; 0000007fH
	jbe	SHORT $LN7@PutBase
	mov	eax, DWORD PTR [r9]
	movzx	r8d, cx
	shr	r8w, 8
	or	r8b, 128				; 00000080H
	mov	BYTE PTR [rax+r9+7], r8b
	inc	DWORD PTR [r9]
$LN7@PutBase:
	mov	eax, DWORD PTR [r9]
	mov	BYTE PTR [rax+r9+7], cl
	inc	DWORD PTR [r9]

; 373  :     PutIndex( out, base->seg_idx );

	movzx	r8d, WORD PTR [rdx+2]
	cmp	r8w, 127				; 0000007fH
	mov	eax, DWORD PTR [r9]
	jbe	SHORT $LN14@PutBase
	movzx	ecx, r8w
	shr	cx, 8
	or	cl, 128					; 00000080H
	mov	BYTE PTR [rax+r9+7], cl
	inc	DWORD PTR [r9]
	mov	eax, DWORD PTR [r9]
$LN14@PutBase:
	mov	BYTE PTR [rax+r9+7], r8b
	inc	DWORD PTR [r9]

; 374  :     if( base->grp_idx == 0 && base->seg_idx == 0 ) {

	cmp	WORD PTR [rdx], 0
	jne	SHORT $LN18@PutBase
	cmp	WORD PTR [rdx+2], 0
	jne	SHORT $LN18@PutBase

; 375  :         PutWord( out, base->frame );

	mov	ecx, DWORD PTR [r9]
	movzx	eax, WORD PTR [rdx+4]
	mov	WORD PTR [rcx+r9+7], ax
	add	DWORD PTR [r9], 2
$LN18@PutBase:

; 376  :     }
; 377  : }

	ret	0
PutBase	ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$writePubdef DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$writePubdef DD @imagerel(writePubdef#)
	DD	@imagerel(writePubdef#+8)
	DD	@imagerel($unwind$writePubdef#)
pdata	ENDS
xdata	SEGMENT
$chain$1$writePubdef DD 040a21H
	DD	08640aH
	DD	073405H
	DD	@imagerel(writePubdef#)
	DD	@imagerel(writePubdef#+8)
	DD	@imagerel($unwind$writePubdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$writePubdef DD @imagerel(writePubdef#+8)
	DD	@imagerel(writePubdef#+138)
	DD	@imagerel($chain$1$writePubdef#)
pdata	ENDS
xdata	SEGMENT
$chain$2$writePubdef DD 020521H
	DD	097405H
	DD	@imagerel(writePubdef#+8)
	DD	@imagerel(writePubdef#+138)
	DD	@imagerel($chain$1$writePubdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$writePubdef DD @imagerel(writePubdef#+138)
	DD	@imagerel(writePubdef#+256)
	DD	@imagerel($chain$2$writePubdef#)
pdata	ENDS
xdata	SEGMENT
$chain$3$writePubdef DD 021H
	DD	@imagerel(writePubdef#+8)
	DD	@imagerel(writePubdef#+138)
	DD	@imagerel($chain$1$writePubdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$writePubdef DD @imagerel(writePubdef#+256)
	DD	@imagerel(writePubdef#+356)
	DD	@imagerel($chain$3$writePubdef#)
pdata	ENDS
xdata	SEGMENT
$chain$4$writePubdef DD 021H
	DD	@imagerel(writePubdef#)
	DD	@imagerel(writePubdef#+8)
	DD	@imagerel($unwind$writePubdef#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$writePubdef DD @imagerel(writePubdef#+356)
	DD	@imagerel(writePubdef#+368)
	DD	@imagerel($chain$4$writePubdef#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writePubdef PROC NEAR

; 381  : {

	sub	rsp, 40					; 00000028H

; 382  :     /**/myassert( objr->command == CMD_PUBDEF || objr->command == CMD_LPUBDEF );
; 383  : 
; 384  :     WBegRec( out, objr->command + objr->is_32 );

	movzx	eax, BYTE PTR [rdx+17]
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi
	add	al, BYTE PTR [rdx+16]
	lea	rsi, QWORD PTR [rcx+4]
	mov	rbx, rcx
	mov	BYTE PTR [rsi], al
	mov	DWORD PTR [rcx], 0

; 385  :     PutBase( out, &objr->d.pubdef.base );

	movzx	ecx, WORD PTR [rdx+20]
	cmp	cx, 127					; 0000007fH
	jbe	SHORT $LN11@writePubde
	movzx	eax, cx
	shr	ax, 8
	or	al, 128					; 00000080H
	mov	BYTE PTR [rbx+7], al
	inc	DWORD PTR [rbx]
$LN11@writePubde:
	mov	eax, DWORD PTR [rbx]
	mov	BYTE PTR [rax+rbx+7], cl
	inc	DWORD PTR [rbx]
	movzx	r8d, WORD PTR [rdx+22]
	cmp	r8w, 127				; 0000007fH
	mov	eax, DWORD PTR [rbx]
	jbe	SHORT $LN18@writePubde
	movzx	ecx, r8w
	shr	cx, 8
	or	cl, 128					; 00000080H
	mov	BYTE PTR [rax+rbx+7], cl
	inc	DWORD PTR [rbx]
	mov	eax, DWORD PTR [rbx]
$LN18@writePubde:
	mov	BYTE PTR [rax+rbx+7], r8b
	inc	DWORD PTR [rbx]
	cmp	WORD PTR [rdx+20], 0
	jne	SHORT $LN22@writePubde
	cmp	WORD PTR [rdx+22], 0
	jne	SHORT $LN22@writePubde
	mov	ecx, DWORD PTR [rbx]
	movzx	eax, WORD PTR [rdx+24]
	mov	WORD PTR [rcx+rbx+7], ax
	add	DWORD PTR [rbx], 2
$LN22@writePubde:

; 386  :     PutMem( out, objr->data, objr->length );

	mov	ecx, DWORD PTR [rbx]
	mov	QWORD PTR [rsp+72], rdi
	mov	edi, DWORD PTR [rdx]
	mov	eax, 4079				; 00000fefH
	sub	eax, ecx
	cmp	edi, eax
	ja	SHORT $LN25@writePubde
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, QWORD PTR [rcx+rbx+7]
	mov	r8, rdi
	call	memcpy
	add	DWORD PTR [rbx], edi
	jmp	SHORT $LN24@writePubde
$LN25@writePubde:
	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG2597
	lea	ecx, QWORD PTR [r8-58]
	call	Fatal
$LN24@writePubde:

; 387  :     WEndRec( out );

	movzx	r10d, WORD PTR [rbx]
	mov	ecx, DWORD PTR [rbx]
	mov	rdi, QWORD PTR [rsp+72]
	inc	r10w
	lea	rdx, QWORD PTR [rbx+7]
	xor	r8b, r8b
	mov	WORD PTR [rbx+5], r10w
	shr	r10w, 8
	add	rcx, rdx
	add	r10b, BYTE PTR [rbx+5]
	mov	rax, rcx
	xor	r9b, r9b
	add	r10b, BYTE PTR [rsi]
	sub	rax, rdx
	cmp	rax, 2
	jl	SHORT $LC38@writePubde
	lea	rax, QWORD PTR [rcx-1]
	npad	12
$LL39@writePubde:
	add	r8b, BYTE PTR [rdx]
	add	r9b, BYTE PTR [rdx+1]
	add	rdx, 2
	cmp	rdx, rax
	jl	SHORT $LL39@writePubde
$LC38@writePubde:
	cmp	rdx, rcx
	jae	SHORT $LN37@writePubde
	add	r10b, BYTE PTR [rdx]
	inc	rdx
$LN37@writePubde:
	add	r8b, r9b
	mov	rcx, rsi
	add	r8b, r10b
	neg	r8b
	mov	BYTE PTR [rdx], r8b
	mov	eax, DWORD PTR [rbx]
	mov	r9, QWORD PTR ModuleInfo+104
	add	eax, 4
	mov	edx, 1
	mov	r8d, eax
	mov	ebx, eax
	call	fwrite
	mov	rsi, QWORD PTR [rsp+64]
	cmp	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	je	SHORT $LN40@writePubde
	call	WriteError
$LN40@writePubde:

; 388  :     return( 0 );

	xor	eax, eax

; 389  : }

	add	rsp, 40					; 00000028H
	ret	0
writePubdef ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$writeLinnum DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$writeLinnum DD @imagerel(writeLinnum#)
	DD	@imagerel(writeLinnum#+8)
	DD	@imagerel($unwind$writeLinnum#)
pdata	ENDS
xdata	SEGMENT
$chain$1$writeLinnum DD 040a21H
	DD	08640aH
	DD	073405H
	DD	@imagerel(writeLinnum#)
	DD	@imagerel(writeLinnum#+8)
	DD	@imagerel($unwind$writeLinnum#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$writeLinnum DD @imagerel(writeLinnum#+8)
	DD	@imagerel(writeLinnum#+137)
	DD	@imagerel($chain$1$writeLinnum#)
pdata	ENDS
xdata	SEGMENT
$chain$2$writeLinnum DD 020521H
	DD	097405H
	DD	@imagerel(writeLinnum#+8)
	DD	@imagerel(writeLinnum#+137)
	DD	@imagerel($chain$1$writeLinnum#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$writeLinnum DD @imagerel(writeLinnum#+137)
	DD	@imagerel(writeLinnum#+255)
	DD	@imagerel($chain$2$writeLinnum#)
pdata	ENDS
xdata	SEGMENT
$chain$3$writeLinnum DD 021H
	DD	@imagerel(writeLinnum#+8)
	DD	@imagerel(writeLinnum#+137)
	DD	@imagerel($chain$1$writeLinnum#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$writeLinnum DD @imagerel(writeLinnum#+255)
	DD	@imagerel(writeLinnum#+356)
	DD	@imagerel($chain$3$writeLinnum#)
pdata	ENDS
xdata	SEGMENT
$chain$4$writeLinnum DD 021H
	DD	@imagerel(writeLinnum#)
	DD	@imagerel(writeLinnum#+8)
	DD	@imagerel($unwind$writeLinnum#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$writeLinnum DD @imagerel(writeLinnum#+356)
	DD	@imagerel(writeLinnum#+368)
	DD	@imagerel($chain$4$writeLinnum#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeLinnum PROC NEAR

; 393  : {

	sub	rsp, 40					; 00000028H

; 394  : 
; 395  :     /**/myassert( objr->command == CMD_LINNUM );
; 396  : 
; 397  :     WBegRec( out, CMD_LINNUM + objr->is_32 );

	movzx	eax, BYTE PTR [rdx+17]
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi
	lea	rsi, QWORD PTR [rcx+4]
	sub	al, 108					; 0000006cH
	mov	rbx, rcx
	mov	BYTE PTR [rsi], al
	mov	DWORD PTR [rcx], 0

; 398  :     PutBase( out, &objr->d.linnum.base );

	movzx	ecx, WORD PTR [rdx+20]
	cmp	cx, 127					; 0000007fH
	jbe	SHORT $LN11@writeLinnu
	movzx	eax, cx
	shr	ax, 8
	or	al, 128					; 00000080H
	mov	BYTE PTR [rbx+7], al
	inc	DWORD PTR [rbx]
$LN11@writeLinnu:
	mov	eax, DWORD PTR [rbx]
	mov	BYTE PTR [rax+rbx+7], cl
	inc	DWORD PTR [rbx]
	movzx	r8d, WORD PTR [rdx+22]
	cmp	r8w, 127				; 0000007fH
	mov	eax, DWORD PTR [rbx]
	jbe	SHORT $LN18@writeLinnu
	movzx	ecx, r8w
	shr	cx, 8
	or	cl, 128					; 00000080H
	mov	BYTE PTR [rax+rbx+7], cl
	inc	DWORD PTR [rbx]
	mov	eax, DWORD PTR [rbx]
$LN18@writeLinnu:
	mov	BYTE PTR [rax+rbx+7], r8b
	inc	DWORD PTR [rbx]
	cmp	WORD PTR [rdx+20], 0
	jne	SHORT $LN22@writeLinnu
	cmp	WORD PTR [rdx+22], 0
	jne	SHORT $LN22@writeLinnu
	mov	ecx, DWORD PTR [rbx]
	movzx	eax, WORD PTR [rdx+24]
	mov	WORD PTR [rcx+rbx+7], ax
	add	DWORD PTR [rbx], 2
$LN22@writeLinnu:

; 399  :     PutMem( out, objr->data, objr->length );

	mov	ecx, DWORD PTR [rbx]
	mov	QWORD PTR [rsp+72], rdi
	mov	edi, DWORD PTR [rdx]
	mov	eax, 4079				; 00000fefH
	sub	eax, ecx
	cmp	edi, eax
	ja	SHORT $LN25@writeLinnu
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, QWORD PTR [rcx+rbx+7]
	mov	r8, rdi
	call	memcpy
	add	DWORD PTR [rbx], edi
	jmp	SHORT $LN24@writeLinnu
$LN25@writeLinnu:
	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG2597
	lea	ecx, QWORD PTR [r8-58]
	call	Fatal
$LN24@writeLinnu:

; 400  :     WEndRec( out );

	movzx	r10d, WORD PTR [rbx]
	mov	ecx, DWORD PTR [rbx]
	mov	rdi, QWORD PTR [rsp+72]
	inc	r10w
	lea	rdx, QWORD PTR [rbx+7]
	xor	r8b, r8b
	mov	WORD PTR [rbx+5], r10w
	shr	r10w, 8
	add	rcx, rdx
	add	r10b, BYTE PTR [rsi]
	mov	rax, rcx
	xor	r9b, r9b
	add	r10b, BYTE PTR [rbx+5]
	sub	rax, rdx
	cmp	rax, 2
	jl	SHORT $LC38@writeLinnu
	lea	rax, QWORD PTR [rcx-1]
	npad	13
$LL39@writeLinnu:
	add	r8b, BYTE PTR [rdx]
	add	r9b, BYTE PTR [rdx+1]
	add	rdx, 2
	cmp	rdx, rax
	jl	SHORT $LL39@writeLinnu
$LC38@writeLinnu:
	cmp	rdx, rcx
	jae	SHORT $LN37@writeLinnu
	add	r10b, BYTE PTR [rdx]
	inc	rdx
$LN37@writeLinnu:
	add	r8b, r9b
	mov	rcx, rsi
	add	r8b, r10b
	neg	r8b
	mov	BYTE PTR [rdx], r8b
	mov	eax, DWORD PTR [rbx]
	mov	r9, QWORD PTR ModuleInfo+104
	add	eax, 4
	mov	edx, 1
	mov	r8d, eax
	mov	ebx, eax
	call	fwrite
	mov	rsi, QWORD PTR [rsp+64]
	cmp	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	je	SHORT $LN40@writeLinnu
	call	WriteError
$LN40@writeLinnu:

; 401  :     return( 0 );

	xor	eax, eax

; 402  : }

	add	rsp, 40					; 00000028H
	ret	0
writeLinnum ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$writeComdat DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$writeComdat DD @imagerel(writeComdat#)
	DD	@imagerel(writeComdat#+11)
	DD	@imagerel($unwind$writeComdat#)
pdata	ENDS
xdata	SEGMENT
$chain$2$writeComdat DD 063221H
	DD	097432H
	DD	07541dH
	DD	063405H
	DD	@imagerel(writeComdat#)
	DD	@imagerel(writeComdat#+11)
	DD	@imagerel($unwind$writeComdat#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$writeComdat DD @imagerel(writeComdat#+11)
	DD	@imagerel(writeComdat#+316)
	DD	@imagerel($chain$2$writeComdat#)
pdata	ENDS
xdata	SEGMENT
$chain$3$writeComdat DD 020521H
	DD	086405H
	DD	@imagerel(writeComdat#+11)
	DD	@imagerel(writeComdat#+316)
	DD	@imagerel($chain$2$writeComdat#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$writeComdat DD @imagerel(writeComdat#+316)
	DD	@imagerel(writeComdat#+439)
	DD	@imagerel($chain$3$writeComdat#)
pdata	ENDS
xdata	SEGMENT
$chain$4$writeComdat DD 021H
	DD	@imagerel(writeComdat#+11)
	DD	@imagerel(writeComdat#+316)
	DD	@imagerel($chain$2$writeComdat#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$writeComdat DD @imagerel(writeComdat#+439)
	DD	@imagerel(writeComdat#+534)
	DD	@imagerel($chain$4$writeComdat#)
pdata	ENDS
xdata	SEGMENT
$chain$5$writeComdat DD 021H
	DD	@imagerel(writeComdat#)
	DD	@imagerel(writeComdat#+11)
	DD	@imagerel($unwind$writeComdat#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$writeComdat DD @imagerel(writeComdat#+534)
	DD	@imagerel(writeComdat#+546)
	DD	@imagerel($chain$5$writeComdat#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeComdat PROC NEAR

; 412  : {

	sub	rsp, 40					; 00000028H

; 413  :     /**/myassert( objr->command == CMD_COMDAT );
; 414  : 
; 415  :     /* write CMD_COMDAT/CMD_COMD32 */
; 416  :     WBegRec( out, objr->command + objr->is_32 );

	movzx	eax, BYTE PTR [rdx+16]
	mov	r9, rdx
	mov	QWORD PTR [rsp+48], rbx
	add	al, BYTE PTR [rdx+17]
	mov	DWORD PTR [rcx], 0
	mov	rbx, rcx
	mov	BYTE PTR [rcx+4], al

; 417  :     PutByte( out, objr->d.comdat.flags );

	movzx	eax, BYTE PTR [rdx+20]
	mov	QWORD PTR [rsp+56], rbp
	mov	BYTE PTR [rcx+7], al
	inc	DWORD PTR [rcx]

; 418  :     PutByte( out, objr->d.comdat.attributes );

	movzx	eax, BYTE PTR [r9+21]
	mov	edx, DWORD PTR [rcx]
	lea	rbp, QWORD PTR [rcx+4]
	mov	QWORD PTR [rsp+72], rdi
	mov	BYTE PTR [rdx+rcx+7], al
	inc	DWORD PTR [rcx]

; 419  :     PutByte( out, objr->d.comdat.align );

	movzx	eax, BYTE PTR [r9+22]
	lea	rdi, QWORD PTR [rcx+7]
	mov	ecx, DWORD PTR [rcx]
	mov	BYTE PTR [rcx+rbx+7], al
	inc	DWORD PTR [rbx]

; 420  :     if( objr->is_32 ) {

	cmp	BYTE PTR [r9+17], 0
	mov	eax, DWORD PTR [rbx]
	je	SHORT $LN3@writeComda

; 421  :         PutDword( out, objr->d.comdat.offset );

	mov	rcx, rax
	mov	eax, DWORD PTR [r9+24]
	mov	DWORD PTR [rcx+rbx+7], eax
	add	DWORD PTR [rbx], 4

; 422  :     } else {

	jmp	SHORT $LN16@writeComda
$LN3@writeComda:

; 423  :         PutWord( out, objr->d.comdat.offset );

	mov	rcx, rax
	movzx	eax, WORD PTR [r9+24]
	mov	WORD PTR [rcx+rbx+7], ax
	add	DWORD PTR [rbx], 2
$LN16@writeComda:

; 424  :     }
; 425  :     PutIndex( out, objr->d.comdat.type_idx );

	movzx	edx, WORD PTR [r9+28]
	cmp	dx, 127					; 0000007fH
	jbe	SHORT $LN21@writeComda
	mov	eax, DWORD PTR [rbx]
	movzx	ecx, dx
	shr	cx, 8
	or	cl, 128					; 00000080H
	mov	BYTE PTR [rax+rbx+7], cl
	inc	DWORD PTR [rbx]
$LN21@writeComda:
	mov	eax, DWORD PTR [rbx]
	mov	BYTE PTR [rax+rbx+7], dl
	inc	DWORD PTR [rbx]

; 426  :     if( ( objr->d.comdat.attributes & COMDAT_ALLOC_MASK ) == COMDAT_EXPLICIT ) {

	test	BYTE PTR [r9+21], 15
	mov	r8d, DWORD PTR [rbx]
	jne	SHORT $LN42@writeComda

; 427  :         PutBase( out, &objr->d.comdat.base );

	movzx	edx, WORD PTR [r9+30]
	cmp	dx, 127					; 0000007fH
	jbe	SHORT $LN31@writeComda
	movzx	ecx, dx
	shr	cx, 8
	or	cl, 128					; 00000080H
	mov	BYTE PTR [r8+rbx+7], cl
	inc	DWORD PTR [rbx]
	mov	r8d, DWORD PTR [rbx]
$LN31@writeComda:
	mov	eax, r8d
	mov	BYTE PTR [rax+rbx+7], dl
	inc	DWORD PTR [rbx]
	movzx	r8d, WORD PTR [r9+32]
	cmp	r8w, 127				; 0000007fH
	mov	edx, DWORD PTR [rbx]
	jbe	SHORT $LN38@writeComda
	movzx	ecx, r8w
	shr	cx, 8
	or	cl, 128					; 00000080H
	mov	BYTE PTR [rdx+rbx+7], cl
	inc	DWORD PTR [rbx]
	mov	edx, DWORD PTR [rbx]
$LN38@writeComda:
	mov	eax, edx
	mov	BYTE PTR [rax+rbx+7], r8b
	inc	DWORD PTR [rbx]
	cmp	WORD PTR [r9+30], 0
	jne	SHORT $LN42@writeComda
	cmp	WORD PTR [r9+32], 0
	jne	SHORT $LN42@writeComda
	mov	ecx, DWORD PTR [rbx]
	movzx	eax, WORD PTR [r9+34]
	mov	WORD PTR [rcx+rbx+7], ax
	add	DWORD PTR [rbx], 2
$LN42@writeComda:

; 428  :     }
; 429  :     PutIndex( out, objr->d.comdat.public_lname_idx );

	movzx	edx, WORD PTR [r9+36]
	cmp	dx, 127					; 0000007fH
	jbe	SHORT $LN47@writeComda
	mov	eax, DWORD PTR [rbx]
	movzx	ecx, dx
	shr	cx, 8
	or	cl, 128					; 00000080H
	mov	BYTE PTR [rax+rbx+7], cl
	inc	DWORD PTR [rbx]
$LN47@writeComda:
	mov	eax, DWORD PTR [rbx]
	mov	QWORD PTR [rsp+64], rsi
	mov	BYTE PTR [rax+rbx+7], dl
	inc	DWORD PTR [rbx]
	mov	ecx, DWORD PTR [rbx]

; 430  :     /* record is already in ms omf format */
; 431  :     PutMem( out, objr->data, objr->length );

	mov	esi, DWORD PTR [r9]
	mov	eax, 4079				; 00000fefH
	sub	eax, ecx
	cmp	esi, eax
	ja	SHORT $LN52@writeComda
	mov	rdx, QWORD PTR [r9+8]
	lea	rcx, QWORD PTR [rcx+rbx+7]
	mov	r8, rsi
	call	memcpy
	add	DWORD PTR [rbx], esi
	jmp	SHORT $LN51@writeComda
$LN52@writeComda:
	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG2597
	lea	ecx, QWORD PTR [r8-58]
	call	Fatal
$LN51@writeComda:

; 432  :     WEndRec( out );

	movzx	r9d, WORD PTR [rbx]
	mov	ecx, DWORD PTR [rbx]
	mov	rsi, QWORD PTR [rsp+64]
	inc	r9w
	add	rcx, rdi
	xor	dl, dl
	mov	WORD PTR [rbx+5], r9w
	shr	r9w, 8
	mov	rax, rcx
	add	r9b, BYTE PTR [rbx+5]
	sub	rax, rdi
	xor	r8b, r8b
	add	r9b, BYTE PTR [rbp]
	cmp	rax, 2
	jl	SHORT $LC65@writeComda
	lea	rax, QWORD PTR [rcx-1]
	npad	5
$LL66@writeComda:
	add	dl, BYTE PTR [rdi]
	add	r8b, BYTE PTR [rdi+1]
	add	rdi, 2
	cmp	rdi, rax
	jl	SHORT $LL66@writeComda
$LC65@writeComda:
	cmp	rdi, rcx
	jae	SHORT $LN64@writeComda
	add	r9b, BYTE PTR [rdi]
	inc	rdi
$LN64@writeComda:
	add	dl, r8b
	mov	rcx, rbp
	add	dl, r9b
	neg	dl
	mov	BYTE PTR [rdi], dl
	mov	eax, DWORD PTR [rbx]
	mov	r9, QWORD PTR ModuleInfo+104
	add	eax, 4
	mov	edx, 1
	mov	r8d, eax
	mov	ebx, eax
	call	fwrite
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+56]
	cmp	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	je	SHORT $LN67@writeComda
	call	WriteError
$LN67@writeComda:

; 433  :     return( 0 );

	xor	eax, eax

; 434  : }

	add	rsp, 40					; 00000028H
	ret	0
writeComdat ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$writeLinsym DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$writeLinsym DD @imagerel(writeLinsym#)
	DD	@imagerel(writeLinsym#+14)
	DD	@imagerel($unwind$writeLinsym#)
pdata	ENDS
xdata	SEGMENT
$chain$2$writeLinsym DD 061c21H
	DD	09741cH
	DD	075410H
	DD	063405H
	DD	@imagerel(writeLinsym#)
	DD	@imagerel(writeLinsym#+14)
	DD	@imagerel($unwind$writeLinsym#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$writeLinsym DD @imagerel(writeLinsym#+14)
	DD	@imagerel(writeLinsym#+91)
	DD	@imagerel($chain$2$writeLinsym#)
pdata	ENDS
xdata	SEGMENT
$chain$3$writeLinsym DD 020521H
	DD	086405H
	DD	@imagerel(writeLinsym#+14)
	DD	@imagerel(writeLinsym#+91)
	DD	@imagerel($chain$2$writeLinsym#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$writeLinsym DD @imagerel(writeLinsym#+91)
	DD	@imagerel(writeLinsym#+205)
	DD	@imagerel($chain$3$writeLinsym#)
pdata	ENDS
xdata	SEGMENT
$chain$4$writeLinsym DD 021H
	DD	@imagerel(writeLinsym#+14)
	DD	@imagerel(writeLinsym#+91)
	DD	@imagerel($chain$2$writeLinsym#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$writeLinsym DD @imagerel(writeLinsym#+205)
	DD	@imagerel(writeLinsym#+296)
	DD	@imagerel($chain$4$writeLinsym#)
pdata	ENDS
xdata	SEGMENT
$chain$5$writeLinsym DD 021H
	DD	@imagerel(writeLinsym#)
	DD	@imagerel(writeLinsym#+14)
	DD	@imagerel($unwind$writeLinsym#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$writeLinsym DD @imagerel(writeLinsym#+296)
	DD	@imagerel(writeLinsym#+308)
	DD	@imagerel($chain$5$writeLinsym#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeLinsym PROC NEAR

; 440  : {

	sub	rsp, 40					; 00000028H

; 441  : 
; 442  :     /**/myassert( objr->command == CMD_LINSYM );
; 443  : 
; 444  :     WBegRec( out, CMD_LINSYM + objr->is_32 );

	movzx	eax, BYTE PTR [rdx+17]
	mov	DWORD PTR [rcx], 0
	mov	QWORD PTR [rsp+48], rbx
	sub	al, 60					; 0000003cH

; 445  :     PutByte( out, objr->d.linsym.flags );

	lea	rbx, QWORD PTR [rcx+7]
	mov	QWORD PTR [rsp+56], rbp
	mov	BYTE PTR [rcx+4], al
	movzx	eax, BYTE PTR [rdx+20]
	mov	QWORD PTR [rsp+72], rdi
	mov	BYTE PTR [rbx], al
	inc	DWORD PTR [rcx]

; 446  :     PutIndex( out, objr->d.linsym.public_lname_idx );

	movzx	r8d, WORD PTR [rdx+22]
	cmp	r8w, 127				; 0000007fH
	mov	eax, DWORD PTR [rcx]
	mov	rdi, rcx
	jbe	SHORT $LN10@writeLinsy
	movzx	ecx, r8w
	shr	cx, 8
	or	cl, 128					; 00000080H
	mov	BYTE PTR [rax+rdi+7], cl
	inc	DWORD PTR [rdi]
	mov	eax, DWORD PTR [rdi]
$LN10@writeLinsy:
	mov	BYTE PTR [rax+rdi+7], r8b
	inc	DWORD PTR [rdi]
	mov	ecx, DWORD PTR [rdi]
	mov	QWORD PTR [rsp+64], rsi

; 447  :     PutMem( out, objr->data, objr->length );

	mov	esi, DWORD PTR [rdx]
	mov	eax, 4079				; 00000fefH
	sub	eax, ecx
	cmp	esi, eax
	ja	SHORT $LN15@writeLinsy
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, QWORD PTR [rcx+rdi+7]
	mov	r8, rsi
	call	memcpy
	add	DWORD PTR [rdi], esi
	jmp	SHORT $LN14@writeLinsy
$LN15@writeLinsy:
	mov	r8d, 168				; 000000a8H
	lea	rdx, OFFSET FLAT:$SG2597
	lea	ecx, QWORD PTR [r8-58]
	call	Fatal
$LN14@writeLinsy:

; 448  :     WEndRec( out );

	movzx	r9d, WORD PTR [rdi]
	mov	ecx, DWORD PTR [rdi]
	mov	rsi, QWORD PTR [rsp+64]
	inc	r9w
	add	rcx, rbx
	xor	dl, dl
	mov	WORD PTR [rdi+5], r9w
	shr	r9w, 8
	mov	rax, rcx
	add	r9b, BYTE PTR [rdi+5]
	sub	rax, rbx
	xor	r8b, r8b
	add	r9b, BYTE PTR [rdi+4]
	cmp	rax, 2
	jl	SHORT $LC28@writeLinsy
	lea	rax, QWORD PTR [rcx-1]
$LL29@writeLinsy:
	add	dl, BYTE PTR [rbx]
	add	r8b, BYTE PTR [rbx+1]
	add	rbx, 2
	cmp	rbx, rax
	jl	SHORT $LL29@writeLinsy
$LC28@writeLinsy:
	cmp	rbx, rcx
	jae	SHORT $LN27@writeLinsy
	add	r9b, BYTE PTR [rbx]
	inc	rbx
$LN27@writeLinsy:
	add	dl, r8b
	lea	rcx, QWORD PTR [rdi+4]
	add	dl, r9b
	neg	dl
	mov	BYTE PTR [rbx], dl
	mov	eax, DWORD PTR [rdi]
	mov	r9, QWORD PTR ModuleInfo+104
	add	eax, 4
	mov	edx, 1
	mov	r8d, eax
	mov	ebx, eax
	call	fwrite
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+56]
	cmp	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	je	SHORT $LN30@writeLinsy
	call	WriteError
$LN30@writeLinsy:

; 449  :     return( 0 );

	xor	eax, eax

; 450  : }

	add	rsp, 40					; 00000028H
	ret	0
writeLinsym ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$writeUnexp DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$writeUnexp DD @imagerel(writeUnexp#)
	DD	@imagerel(writeUnexp#+34)
	DD	@imagerel($unwind$writeUnexp#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
out$ = 48
objr$ = 56
writeUnexp PROC NEAR

; 456  : {

	sub	rsp, 40					; 00000028H

; 457  :     DebugMsg(("unexpected OMF record type 0x%02X\n", objr->command ));
; 458  :     Fatal( INTERNAL_ERROR, __FILE__, __LINE__ );

	lea	rdx, OFFSET FLAT:$SG2704
	mov	r8d, 458				; 000001caH
	mov	ecx, 110				; 0000006eH
	call	Fatal

; 459  :     /* this is never reached, since Fatal() won't return */
; 460  :     return( 0 );

	xor	eax, eax

; 461  : }

	add	rsp, 40					; 00000028H
	ret	0
writeUnexp ENDP
_TEXT	ENDS
PUBLIC	omf_write_record
EXTRN	__ImageBase:BYTE
EXTRN	__chkstk:NEAR
xdata	SEGMENT
$unwind$omf_write_record DD 020d01H
	DD	0205010dH
xdata	ENDS
pdata	SEGMENT
$pdata$omf_write_record DD @imagerel($LN3#)
	DD	@imagerel($LN3#+66)
	DD	@imagerel($unwind$omf_write_record#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
out$ = 32
objr$ = 4144
omf_write_record PROC NEAR

; 522  : {

$LN3:
	mov	eax, 4136				; 00001028H
	call	__chkstk
	sub	rsp, rax

; 523  :     struct outbuff out;
; 524  : 
; 525  :     /**/myassert( objr != NULL && objr->command >= CMD_MIN_CMD && objr->command <= CMD_MAX_CMD + 1 );
; 526  :     DebugMsg1(("omf_write_record( cmd=%X data=%p length=%u )\n", objr->command, objr->data, objr->length ));
; 527  :     myFuncs[ func_index[JUMP_INDEX(objr->command) ] ] ( &out, objr );

	movzx	eax, BYTE PTR [rcx+16]
	lea	r8, OFFSET FLAT:__ImageBase
	add	eax, -128				; ffffffffffffff80H
	movsxd	rdx, eax
	sar	rdx, 1
	movzx	eax, BYTE PTR func_index[rdx+r8]
	mov	rdx, rcx
	lea	rcx, QWORD PTR out$[rsp]
	call	QWORD PTR myFuncs[r8+rax*8]

; 528  : }

	add	rsp, 4136				; 00001028H
	ret	0
omf_write_record ENDP
_TEXT	ENDS
END
