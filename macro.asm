; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
$SG5525	DB	'%X', 00H
	ORG $+1
$SG5596	DB	'<>"''', 00H
	ORG $+3
$SG5652	DB	'REQ', 00H
$SG5661	DB	'VARARGML', 00H
	ORG $+3
$SG5809	DB	'REQ', 00H
$SG5818	DB	'VARARGML', 00H
	ORG $+3
$SG5966	DB	'REQ', 00H
$SG5975	DB	'VARARGML', 00H
	ORG $+7
$SG6137	DB	'macro name', 00H
	ORG $+5
$SG6159	DB	'@Environ', 00H
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\macro.c
_DATA	ENDS
_TEXT	SEGMENT
x$ = 8
HexDigit PROC NEAR

; 69   :     x &= 0xF;

	and	cl, 15

; 70   :     return((x > 9) ? (x - 10 + 'A') : (x + '0'));

	cmp	cl, 9
	movsx	eax, cl
	jle	SHORT $LN3@HexDigit
	add	eax, 55					; 00000037H

; 71   : }

	ret	0
$LN3@HexDigit:

; 70   :     return((x > 9) ? (x - 10 + 'A') : (x + '0'));

	add	eax, 48					; 00000030H

; 71   : }

	ret	0
HexDigit ENDP
_TEXT	ENDS
PUBLIC	fill_placeholders
EXTRN	sprintf:NEAR
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$fill_placeholders DD 091b01H
	DD	05d41bH
	DD	086416H
	DD	095411H
	DD	0a340cH
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$fill_placeholders DD @imagerel($LN30#)
	DD	@imagerel($LN30#+45)
	DD	@imagerel($unwind$fill_placeholders#)
pdata	ENDS
xdata	SEGMENT
$chain$5$fill_placeholders DD 041221H
	DD	077412H
	DD	06c405H
	DD	@imagerel($LN30#)
	DD	@imagerel($LN30#+45)
	DD	@imagerel($unwind$fill_placeholders#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$fill_placeholders DD @imagerel($LN30#+45)
	DD	@imagerel($LN30#+348)
	DD	@imagerel($chain$5$fill_placeholders#)
pdata	ENDS
xdata	SEGMENT
$chain$6$fill_placeholders DD 021H
	DD	@imagerel($LN30#)
	DD	@imagerel($LN30#+45)
	DD	@imagerel($unwind$fill_placeholders#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$fill_placeholders DD @imagerel($LN30#+348)
	DD	@imagerel($LN30#+376)
	DD	@imagerel($chain$6$fill_placeholders#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
dst$ = 96
src$ = 104
argc$ = 112
localstart$ = 120
argv$ = 128
fill_placeholders PROC NEAR

; 79   : {

$LN30:
	sub	rsp, 88					; 00000058H

; 80   :     uint_32 i;
; 81   :     const char *p;
; 82   :     unsigned parmno;
; 83   : 
; 84   :     /* scan the string, replace the placeholders #nn */
; 85   :     for( p = src ;*p != NULLC; ) {

	cmp	BYTE PTR [rdx], 0
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+40], r13
	mov	ebp, r8d
	mov	r13d, r9d
	mov	rsi, rdx
	mov	rbx, rcx
	je	$LN29@fill_place
	mov	QWORD PTR [rsp+48], r12
	mov	r12, QWORD PTR argv$[rsp]
	mov	QWORD PTR [rsp+56], rdi
	npad	1
$LL9@fill_place:

; 86   :         if (*p == PLACEHOLDER_CHAR ) {

	movzx	eax, BYTE PTR [rsi]
	cmp	al, 10
	jne	$LN7@fill_place

; 87   :             p++;
; 88   :             /* we found a placeholder, get the index part! */
; 89   :             parmno = *(unsigned char *)p - 1; /* index is one-based! */

	movzx	eax, BYTE PTR [rsi+1]

; 90   :             p++;

	add	rsi, 2
	dec	eax

; 91   :             /* if parmno > argc, then it's a macro local */
; 92   :             if ( parmno >= argc ) {

	cmp	eax, ebp
	jb	$LN6@fill_place

; 93   :                 *dst++ = '?';
; 94   :                 *dst++ = '?';
; 95   :                 i = localstart + parmno - argc;

	sub	eax, ebp
	mov	BYTE PTR [rbx], 63			; 0000003fH
	mov	BYTE PTR [rbx+1], 63			; 0000003fH
	add	eax, r13d
	add	rbx, 2

; 96   :                 if ( i > 0xFFFF ) {

	cmp	eax, 65535				; 0000ffffH
	jbe	SHORT $LN5@fill_place

; 97   :                     i = sprintf( dst, "%X", i );

	lea	rdx, OFFSET FLAT:$SG5525
	mov	r8d, eax
	mov	rcx, rbx
	call	sprintf
	mov	edx, eax

; 98   :                     dst += i;

	add	rbx, rdx

; 99   :                 } else {

	jmp	$LN1@fill_place
$LN5@fill_place:

; 100  :                     *dst++ = HexDigit( i >> 12 );

	mov	ecx, eax
	shr	ecx, 12
	and	cl, 15
	cmp	cl, 9
	jle	SHORT $LN14@fill_place
	movsx	edx, cl
	add	edx, 55					; 00000037H
	jmp	SHORT $LN15@fill_place
$LN14@fill_place:
	movsx	edx, cl
	add	edx, 48					; 00000030H
$LN15@fill_place:

; 101  :                     *dst++ = HexDigit( i >> 8 );

	mov	ecx, eax
	mov	BYTE PTR [rbx], dl
	shr	ecx, 8
	and	cl, 15
	cmp	cl, 9
	jle	SHORT $LN18@fill_place
	movsx	edx, cl
	add	edx, 55					; 00000037H
	jmp	SHORT $LN19@fill_place
$LN18@fill_place:
	movsx	edx, cl
	add	edx, 48					; 00000030H
$LN19@fill_place:

; 102  :                     *dst++ = HexDigit( i >> 4 );

	mov	ecx, eax
	mov	BYTE PTR [rbx+1], dl
	shr	ecx, 4
	and	cl, 15
	cmp	cl, 9
	jle	SHORT $LN22@fill_place
	movsx	edx, cl
	add	edx, 55					; 00000037H
	jmp	SHORT $LN23@fill_place
$LN22@fill_place:
	movsx	edx, cl
	add	edx, 48					; 00000030H
$LN23@fill_place:

; 103  :                     *dst++ = HexDigit( i );

	and	al, 15
	mov	BYTE PTR [rbx+2], dl
	cmp	al, 9
	jle	SHORT $LN26@fill_place
	movsx	ecx, al
	add	ecx, 55					; 00000037H
	add	rbx, 4
	mov	BYTE PTR [rbx-1], cl

; 104  :                 }

	jmp	SHORT $LN1@fill_place

; 103  :                     *dst++ = HexDigit( i );

$LN26@fill_place:
	movsx	ecx, al
	add	ecx, 48					; 00000030H
	add	rbx, 4
	mov	BYTE PTR [rbx-1], cl

; 104  :                 }

	jmp	SHORT $LN1@fill_place
$LN6@fill_place:

; 105  :             } else if ( argv[parmno] ) {  /* actual parameter might be empty (=NULL) */

	mov	rdx, QWORD PTR [r12+rax*8]
	test	rdx, rdx
	je	SHORT $LN1@fill_place

; 106  :                 i = strlen( argv[parmno] );

	xor	eax, eax
	mov	rdi, rdx
	mov	rcx, -1
	repne scasb
	not	rcx
	dec	rcx

; 107  :                 memcpy( dst, argv[parmno], i );

	mov	edi, ecx
	mov	r8d, ecx
	mov	rcx, rbx
	call	memcpy

; 108  :                 dst += i;

	add	rbx, rdi

; 109  :             }
; 110  :         } else {

	jmp	SHORT $LN1@fill_place
$LN7@fill_place:

; 111  :             *dst++ = *p++;

	mov	BYTE PTR [rbx], al
	inc	rbx
	inc	rsi
$LN1@fill_place:

; 80   :     uint_32 i;
; 81   :     const char *p;
; 82   :     unsigned parmno;
; 83   : 
; 84   :     /* scan the string, replace the placeholders #nn */
; 85   :     for( p = src ;*p != NULLC; ) {

	cmp	BYTE PTR [rsi], 0
	jne	$LL9@fill_place
	mov	r12, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+56]

; 112  :         }
; 113  :     }
; 114  :     *dst = NULLC;

	mov	BYTE PTR [rbx], 0
	jmp	SHORT $LN8@fill_place
$LN29@fill_place:
	mov	BYTE PTR [rcx], 0
$LN8@fill_place:
	mov	r13, QWORD PTR [rsp+40]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+80]

; 115  :     return;
; 116  : }

	add	rsp, 88					; 00000058H
	ret	0
fill_placeholders ENDP
_TEXT	ENDS
EXTRN	memmove:NEAR
EXTRN	EmitError:NEAR
EXTRN	SymCmpFunc:QWORD
xdata	SEGMENT
$unwind$replace_parm DD 0b2601H
	DD	04c426H
	DD	097418H
	DD	086413H
	DD	07540eH
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$replace_parm DD @imagerel(replace_parm#)
	DD	@imagerel(replace_parm#+294)
	DD	@imagerel($unwind$replace_parm#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
line$ = 48
start$ = 56
len$ = 64
mnames$ = 72
replace_parm PROC NEAR

; 120  : {

	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	mov	rbx, rdx

; 121  :     /* scan list of macro paras/locals if current word is found.
; 122  :      * - line: current line
; 123  :      * - start: start 'current word' in line
; 124  :      * - len: size current word
; 125  :      * - mnames: list of macro params+locals
; 126  :      * if found, the 'current word' is replaced by a placeholder.
; 127  :      * format of placeholders is <placeholder_char><index>
; 128  :      * <placeholder_char> is an escape character whose hex-code is
; 129  :      * "impossible" to occur in a source line, <index> has type uint_8,
; 130  :      * value 00 isn't used - this restricts the total of parameters
; 131  :      * and locals for a macro to 255.
; 132  :      */
; 133  :     char       *rest;
; 134  :     unsigned   count;
; 135  : 
; 136  : //  DebugMsg(("replace_parm(%s) enter, len=%u\n", start, len ));
; 137  : 
; 138  :     for( count = 1; mnames->label; count++, mnames++ ) {

	mov	rdx, QWORD PTR [r9]
	test	rdx, rdx
	mov	QWORD PTR [rsp+32], r12
	mov	rdi, r9
	movsxd	rbp, r8d
	mov	esi, 1
	mov	r12, rcx
	je	SHORT $LN9@replace_pa
$LL11@replace_pa:

; 139  :         if( mnames->len == len && SymCmpFunc( start, mnames->label, len ) == 0 ) {

	movzx	eax, WORD PTR [rdi+8]
	cmp	eax, ebp
	jne	SHORT $LN10@replace_pa
	mov	r8, rbp
	mov	rcx, rbx
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	SHORT $LN16@replace_pa
$LN10@replace_pa:

; 121  :     /* scan list of macro paras/locals if current word is found.
; 122  :      * - line: current line
; 123  :      * - start: start 'current word' in line
; 124  :      * - len: size current word
; 125  :      * - mnames: list of macro params+locals
; 126  :      * if found, the 'current word' is replaced by a placeholder.
; 127  :      * format of placeholders is <placeholder_char><index>
; 128  :      * <placeholder_char> is an escape character whose hex-code is
; 129  :      * "impossible" to occur in a source line, <index> has type uint_8,
; 130  :      * value 00 isn't used - this restricts the total of parameters
; 131  :      * and locals for a macro to 255.
; 132  :      */
; 133  :     char       *rest;
; 134  :     unsigned   count;
; 135  : 
; 136  : //  DebugMsg(("replace_parm(%s) enter, len=%u\n", start, len ));
; 137  : 
; 138  :     for( count = 1; mnames->label; count++, mnames++ ) {

	mov	rdx, QWORD PTR [rdi+16]
	add	rdi, 16
	inc	esi
	test	rdx, rdx
	jne	SHORT $LL11@replace_pa
$LN9@replace_pa:

; 171  :         }
; 172  :     }
; 173  :     return( NULL );

	xor	eax, eax
$LN12@replace_pa:
	mov	r12, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 174  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN16@replace_pa:

; 140  : 
; 141  :             /* found a macro parameter/local! */
; 142  : 
; 143  :             if ( count >= MAX_PLACEHOLDERS ) {

	cmp	esi, 256				; 00000100H
	jb	SHORT $LN7@replace_pa

; 144  :                 EmitError( TOO_MANY_MACRO_PLACEHOLDERS );

	mov	ecx, 219				; 000000dbH
	call	EmitError

; 145  :                 break;

	jmp	SHORT $LN9@replace_pa
$LN7@replace_pa:

; 146  :             }
; 147  : 
; 148  :             /* handle substitution operator '&' */
; 149  :             rest = start + len;
; 150  :             if ( start != line && *(start-1) == '&' )

	cmp	rbx, r12
	lea	rdx, QWORD PTR [rbx+rbp]
	je	SHORT $LN6@replace_pa
	cmp	BYTE PTR [rbx-1], 38			; 00000026H
	lea	rax, QWORD PTR [rbx-1]
	cmove	rbx, rax
$LN6@replace_pa:

; 151  :                 start--;
; 152  :             if (*rest == '&')

	cmp	BYTE PTR [rdx], 38			; 00000026H
	jne	SHORT $LN5@replace_pa

; 153  :                 rest++;

	inc	rdx
$LN5@replace_pa:

; 154  : 
; 155  :             *start++ = PLACEHOLDER_CHAR;

	mov	BYTE PTR [rbx], 10
	inc	rbx

; 156  : 
; 157  :             /* additional space needed for the placeholder? */
; 158  :             if ( start >= rest ) {

	cmp	rbx, rdx
	jb	SHORT $LN4@replace_pa

; 159  :                 char *end = rest + strlen(rest);

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rdx
	repne scasb
	not	rcx
	dec	rcx
	add	rcx, rdx

; 160  :                 char *dst = end + 1;
; 161  :                 while ( end >= rest )

	cmp	rcx, rdx
	lea	rdi, QWORD PTR [rcx+1]
	jb	SHORT $LN2@replace_pa
	npad	7
$LL3@replace_pa:

; 162  :                     *dst-- = *end--;

	movzx	eax, BYTE PTR [rcx]
	dec	rcx
	dec	rdi
	cmp	rcx, rdx
	mov	BYTE PTR [rdi+1], al
	jae	SHORT $LL3@replace_pa
$LN2@replace_pa:

; 163  :                 *start = count;

	mov	BYTE PTR [rbx], sil

; 169  :             }
; 170  :             return( start ); /* word has been replaced */

	mov	rax, rbx
	jmp	$LN12@replace_pa
$LN4@replace_pa:

; 164  :             } else {
; 165  :                 *start++ = count;

	mov	BYTE PTR [rbx], sil

; 166  :                 /* v2.10: strcpy should not be used if strings overlap */
; 167  :                 //strcpy( start, rest );
; 168  :                 memmove( start, rest, strlen( rest) + 1 );

	xor	eax, eax
	mov	rdi, rdx
	inc	rbx
	mov	rcx, -1
	repne scasb
	not	rcx
	mov	r8, rcx
	mov	rcx, rbx
	call	memmove

; 169  :             }
; 170  :             return( start ); /* word has been replaced */

	mov	rax, rbx
	jmp	$LN12@replace_pa
replace_parm ENDP
_TEXT	ENDS
EXTRN	strchr:NEAR
EXTRN	ModuleInfo:BYTE
EXTRN	isalnum:NEAR
EXTRN	isdigit:NEAR
xdata	SEGMENT
$unwind$store_placeholders DD 0113601H
	DD	07f436H
	DD	08e42aH
	DD	09d426H
	DD	0ac422H
	DD	0b741eH
	DD	0c641aH
	DD	0115414H
	DD	0103410H
	DD	0c20cH
xdata	ENDS
pdata	SEGMENT
$pdata$store_placeholders DD @imagerel(store_placeholders#)
	DD	@imagerel(store_placeholders#+867)
	DD	@imagerel($unwind$store_placeholders#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
qlevel$1$ = 32
params$1$ = 112
line$ = 112
mnames$ = 120
store_placeholders PROC NEAR

; 178  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	rax, rsp
	sub	rsp, 104				; 00000068H
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax+32], rbp

; 179  :     /* scan a macro source line for parameter and local names.
; 180  :      * - line: the source line
; 181  :      * - mnames: list of macro params + locals
; 182  :      * if a param/local is found, replace the name by a 2-byte placeholder.
; 183  :      */
; 184  :     char *p;
; 185  :     char *start;
; 186  :     char quote = NULLC;
; 187  :     int brlevel = 0;

	xor	ebp, ebp
	mov	QWORD PTR [rax-8], rsi
	mov	QWORD PTR [rax-16], rdi
	mov	QWORD PTR [rax-24], r12
	mov	QWORD PTR [rax-32], r13
	mov	QWORD PTR [rax-40], r14

; 188  :     int params = 0; /* number of replacements in this line */
; 189  :     int qlevel = 0;

	mov	esi, ebp
	xor	r13b, r13b

; 190  :     bool substprf;  /* substitution character before ID? */
; 191  : 
; 192  :     for( p = line; *p != NULLC; ) {

	cmp	BYTE PTR [rcx], sil
	mov	QWORD PTR [rax-48], r15
	mov	r12, rdx
	mov	r15, rcx
	mov	r14d, ebp
	mov	edi, ebp
	mov	DWORD PTR params$1$[rsp], ebp
	mov	DWORD PTR qlevel$1$[rsp], ebp
	mov	rbx, rcx
	je	$LN59@store_plac
$LL29@store_plac:

; 193  :         if ( isdigit( *p) ) {

	movsx	ecx, BYTE PTR [rbx]
	call	isdigit
	test	eax, eax
	je	SHORT $LN27@store_plac
	npad	2
$LL26@store_plac:

; 194  :             /* skip numbers (they may contain alphas)
; 195  :              * this is not exactly what masm does. Masm
; 196  :              * stops at the first non-digit.
; 197  :              */
; 198  :             while ( is_valid_id_char( *p )) p++;

	movsx	ecx, BYTE PTR [rbx]
	call	isalnum
	test	eax, eax
	jne	SHORT $LN24@store_plac
	movzx	eax, BYTE PTR [rbx]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN24@store_plac
	cmp	al, 64					; 00000040H
	je	SHORT $LN24@store_plac
	cmp	al, 36					; 00000024H
	je	SHORT $LN24@store_plac
	cmp	al, 63					; 0000003fH
	jne	$LN14@store_plac
$LN24@store_plac:
	inc	rbx
	jmp	SHORT $LL26@store_plac
$LN27@store_plac:

; 199  :         } else if ( ( is_valid_id_char( *p ) ) ||
; 200  :                    ( *p == '.' &&
; 201  :                     ModuleInfo.dotname &&
; 202  :                     //is_valid_id_char(*(p+1)) && /* v2.05: masm allows a single dot as param/local name */
; 203  :                     ( p == line ||
; 204  :                      ( *(p-1) != ']' && ( is_valid_id_char( *(p-1) ) == FALSE ) ) ) ) ) {

	movsx	ecx, BYTE PTR [rbx]
	call	isalnum
	test	eax, eax
	jne	$LN20@store_plac
	movzx	eax, BYTE PTR [rbx]
	cmp	al, 95					; 0000005fH
	je	$LN20@store_plac
	cmp	al, 64					; 00000040H
	je	$LN20@store_plac
	cmp	al, 36					; 00000024H
	je	$LN20@store_plac
	cmp	al, 63					; 0000003fH
	je	$LN20@store_plac
	cmp	al, 46					; 0000002eH
	jne	SHORT $LN32@store_plac
	test	BYTE PTR ModuleInfo+408, 32		; 00000020H
	je	SHORT $LN32@store_plac
	cmp	rbx, r15
	je	$LN20@store_plac
	movzx	eax, BYTE PTR [rbx-1]
	cmp	al, 93					; 0000005dH
	je	SHORT $LN32@store_plac
	movsx	ecx, al
	call	isalnum
	test	eax, eax
	jne	SHORT $LN32@store_plac
	movzx	eax, BYTE PTR [rbx-1]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN32@store_plac
	cmp	al, 64					; 00000040H
	je	SHORT $LN32@store_plac
	cmp	al, 36					; 00000024H
	je	SHORT $LN32@store_plac
	cmp	al, 63					; 0000003fH
	jne	$LN20@store_plac
$LN32@store_plac:

; 215  :                 }
; 216  :             }
; 217  :         } else {
; 218  :             switch (*p) {

	movsx	edx, BYTE PTR [rbx]
	mov	ecx, edx
	sub	ecx, 33					; 00000021H
	je	SHORT $LN10@store_plac
	dec	ecx
	je	SHORT $LN4@store_plac
	sub	ecx, 5
	je	SHORT $LN4@store_plac
	sub	ecx, 21
	je	SHORT $LN8@store_plac
	cmp	ecx, 2
	jne	SHORT $LN9@store_plac

; 227  :                 break;
; 228  :             case '>':
; 229  :                 if (brlevel) {

	test	r14d, r14d
	je	SHORT $LN9@store_plac

; 230  :                     if (qlevel == brlevel)

	cmp	esi, r14d
	movzx	r13d, r13b
	cmove	r13d, ebp

; 231  :                         quote = NULLC;
; 232  :                     brlevel--;

	dec	r14d

; 243  :                 }
; 244  :             }
; 245  :             p++;

	inc	rbx
	jmp	$LN14@store_plac
$LN8@store_plac:

; 223  :                     p++;
; 224  :                 break;
; 225  :             case '<':
; 226  :                 brlevel++;

	inc	r14d

; 243  :                 }
; 244  :             }
; 245  :             p++;

	inc	rbx
	jmp	$LN14@store_plac
$LN4@store_plac:

; 233  :                 }
; 234  :                 break;
; 235  :             case '"':
; 236  :             case '\'':
; 237  :                 if ( quote ) {

	test	r13b, r13b
	je	SHORT $LN3@store_plac

; 238  :                     if ( quote == *p )

	cmp	r13b, dl
	jne	SHORT $LN9@store_plac

; 239  :                         quote = NULLC;

	xor	r13b, r13b

; 243  :                 }
; 244  :             }
; 245  :             p++;

	inc	rbx
	jmp	$LN14@store_plac
$LN3@store_plac:

; 240  :                 } else {
; 241  :                     quote = *p;

	mov	r13b, dl

; 242  :                     qlevel = brlevel;

	mov	DWORD PTR qlevel$1$[rsp], r14d

; 243  :                 }
; 244  :             }
; 245  :             p++;

	inc	rbx
	jmp	$LN14@store_plac
$LN10@store_plac:

; 219  :             case '!':
; 220  :                 /* v2.11: skip next char only if it is a "special" one; see expans40.asm */
; 221  :                 //if ( quote == NULLC && *(p+1) != NULLC )
; 222  :                 if ( quote == NULLC && strchr( "<>\"'", *(p+1) ) )

	test	r13b, r13b
	jne	SHORT $LN9@store_plac
	movsx	edx, BYTE PTR [rbx+1]
	lea	rdi, QWORD PTR [rbx+1]
	lea	rcx, OFFSET FLAT:$SG5596
	call	strchr
	test	rax, rax
	cmovne	rbx, rdi
	mov	edi, DWORD PTR params$1$[rsp]
$LN9@store_plac:

; 243  :                 }
; 244  :             }
; 245  :             p++;

	inc	rbx
	jmp	$LN14@store_plac
$LN20@store_plac:

; 205  :             DebugMsg1(("store_placeholders: found ID: %s\n", p));
; 206  :             start = p++;

	mov	rbp, rbx
	inc	rbx
$LL19@store_plac:

; 207  :             while ( is_valid_id_char( *p )) p++;

	movsx	ecx, BYTE PTR [rbx]
	call	isalnum
	test	eax, eax
	jne	SHORT $LN17@store_plac
	movzx	eax, BYTE PTR [rbx]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN17@store_plac
	cmp	al, 64					; 00000040H
	je	SHORT $LN17@store_plac
	cmp	al, 36					; 00000024H
	je	SHORT $LN17@store_plac
	cmp	al, 63					; 0000003fH
	jne	SHORT $LN18@store_plac
$LN17@store_plac:
	inc	rbx
	jmp	SHORT $LL19@store_plac
$LN18@store_plac:

; 208  :             /* v2.08: both a '&' before AND after the name trigger substitution (and disappear) */
; 209  :             substprf = ( ( start > line && *(start-1) == '&') || *p == '&' );

	cmp	rbp, r15
	jbe	SHORT $LN34@store_plac
	cmp	BYTE PTR [rbp-1], 38			; 00000026H
	je	SHORT $LN35@store_plac
$LN34@store_plac:
	cmp	BYTE PTR [rbx], 38			; 00000026H
	je	SHORT $LN35@store_plac
	xor	al, al
	jmp	SHORT $LN36@store_plac
$LN35@store_plac:
	mov	al, 1
$LN36@store_plac:

; 210  :             if ( quote == NULLC || substprf ) {

	test	r13b, r13b
	je	SHORT $LN15@store_plac
	test	al, al
	je	$LN62@store_plac
$LN15@store_plac:

; 211  :                 /* look for this word in the macro parms, and replace it if it is */
; 212  :                 if ( start = replace_parm( line, start, p - start, mnames ) ) {

	mov	rax, QWORD PTR mnames$[rsp]
	mov	esi, ebx
	mov	rdi, r12
	sub	esi, ebp
	cmp	QWORD PTR [rax], 0
	mov	r12d, 1
	je	$LN60@store_plac
	npad	6
$LL47@store_plac:
	movzx	eax, WORD PTR [rdi+8]
	cmp	eax, esi
	jne	SHORT $LN46@store_plac
	mov	rdx, QWORD PTR [rdi]
	movsxd	r8, esi
	mov	rcx, rbp
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	SHORT $LN56@store_plac
$LN46@store_plac:
	add	rdi, 16
	inc	r12d
	cmp	QWORD PTR [rdi], 0
	jne	SHORT $LL47@store_plac
	mov	edi, DWORD PTR params$1$[rsp]
	mov	r12, QWORD PTR mnames$[rsp]
	xor	ebp, ebp
	jmp	$LN14@store_plac
$LN56@store_plac:
	cmp	r12d, 256				; 00000100H
	jb	SHORT $LN43@store_plac
	mov	ecx, 219				; 000000dbH
	call	EmitError
	mov	edi, DWORD PTR params$1$[rsp]
	mov	r12, QWORD PTR mnames$[rsp]
	xor	ebp, ebp
	jmp	$LN14@store_plac
$LN43@store_plac:
	movsxd	rdx, esi
	add	rdx, rbp
	cmp	rbp, r15
	je	SHORT $LN42@store_plac
	cmp	BYTE PTR [rbp-1], 38			; 00000026H
	lea	rax, QWORD PTR [rbp-1]
	cmove	rbp, rax
$LN42@store_plac:
	cmp	BYTE PTR [rdx], 38			; 00000026H
	jne	SHORT $LN41@store_plac
	inc	rdx
$LN41@store_plac:
	mov	BYTE PTR [rbp], 10
	inc	rbp
	cmp	rbp, rdx
	jb	SHORT $LN40@store_plac
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rdx
	repne scasb
	not	rcx
	dec	rcx
	add	rcx, rdx
	cmp	rcx, rdx
	lea	rdi, QWORD PTR [rcx+1]
	jb	SHORT $LN38@store_plac
	npad	10
$LL39@store_plac:
	movzx	eax, BYTE PTR [rcx]
	dec	rcx
	dec	rdi
	cmp	rcx, rdx
	mov	BYTE PTR [rdi+1], al
	jae	SHORT $LL39@store_plac
$LN38@store_plac:
	mov	BYTE PTR [rbp], r12b
	jmp	SHORT $LN48@store_plac
$LN40@store_plac:
	mov	BYTE PTR [rbp], r12b
	xor	eax, eax
	mov	rdi, rdx
	inc	rbp
	mov	rcx, -1
	repne scasb
	not	rcx
	mov	r8, rcx
	mov	rcx, rbp
	call	memmove
$LN48@store_plac:
	test	rbp, rbp
	je	SHORT $LN61@store_plac

; 213  :                     params++;

	mov	edi, DWORD PTR params$1$[rsp]

; 214  :                     p = start;

	mov	r12, QWORD PTR mnames$[rsp]
	mov	rbx, rbp
	inc	edi
	xor	ebp, ebp
	mov	DWORD PTR params$1$[rsp], edi
	jmp	SHORT $LN14@store_plac
$LN60@store_plac:

; 213  :                     params++;

	mov	edi, DWORD PTR params$1$[rsp]
	mov	r12, QWORD PTR mnames$[rsp]
	xor	ebp, ebp
	jmp	SHORT $LN14@store_plac
$LN61@store_plac:

; 211  :                 /* look for this word in the macro parms, and replace it if it is */
; 212  :                 if ( start = replace_parm( line, start, p - start, mnames ) ) {

	mov	edi, DWORD PTR params$1$[rsp]
	mov	r12, QWORD PTR mnames$[rsp]
	xor	ebp, ebp
	jmp	SHORT $LN14@store_plac
$LN62@store_plac:
	xor	ebp, ebp
$LN14@store_plac:

; 190  :     bool substprf;  /* substitution character before ID? */
; 191  : 
; 192  :     for( p = line; *p != NULLC; ) {

	cmp	BYTE PTR [rbx], 0
	mov	esi, DWORD PTR qlevel$1$[rsp]
	jne	$LL29@store_plac
$LN59@store_plac:
	mov	r15, QWORD PTR [rsp+56]
	mov	r14, QWORD PTR [rsp+64]
	mov	r13, QWORD PTR [rsp+72]
	mov	r12, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+136]
	mov	rbx, QWORD PTR [rsp+128]

; 246  :         }
; 247  :     }
; 248  :     return( params );

	mov	eax, edi
	mov	rdi, QWORD PTR [rsp+88]

; 249  : }

	add	rsp, 104				; 00000068H
	ret	0
store_placeholders ENDP
_TEXT	ENDS
PUBLIC	StoreMacro
EXTRN	GetToken:NEAR
EXTRN	isspace:NEAR
EXTRN	LstWrite:NEAR
EXTRN	Fatal:NEAR
EXTRN	GetTextLine:NEAR
EXTRN	EmitErr:NEAR
EXTRN	Options:BYTE
EXTRN	_stricmp:NEAR
EXTRN	EmitWarn:NEAR
EXTRN	isalpha:NEAR
EXTRN	LclAlloc:NEAR
EXTRN	__chkstk:NEAR
xdata	SEGMENT
$unwind$StoreMacro DD 025125401H
	DD	0293f454H
	DD	0294e446H
	DD	0295d43bH
	DD	0296c434H
	DD	0297742dH
	DD	02986426H
	DD	0299341fH
	DD	01132318H
	DD	05006029aH
xdata	ENDS
pdata	SEGMENT
$pdata$StoreMacro DD @imagerel($LN158#)
	DD	@imagerel($LN158#+2353)
	DD	@imagerel($unwind$StoreMacro#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
mindex$1$ = 0
nesting_depth$1$ = 4
ls$ = 8
info$1$ = 40
tok$ = 48
buffer$ = 112
mnames$ = 1136
locals_done$1$ = 5312
macro$ = 5312
i$ = 5320
tokenarray$ = 5328
mindex$ = 5336
store_data$ = 5336
StoreMacro PROC NEAR

; 287  : {

$LN158:
	mov	BYTE PTR [rsp+32], r9b
	push	rbp
	mov	eax, 5328				; 000014d0H
	call	__chkstk
	sub	rsp, rax
	lea	rbp, QWORD PTR [rsp+32]
	mov	QWORD PTR [rbp+5288], rbx
	mov	QWORD PTR [rbp+5280], rsi
	mov	QWORD PTR [rbp+5272], rdi
	mov	QWORD PTR [rbp+5264], r12
	mov	QWORD PTR [rbp+5256], r13

; 288  :     struct macro_info   *info;
; 289  :     char                *src;
; 290  :     char                *token;
; 291  :     int                 mindex;
; 292  :     struct mparm_list   *paranode;
; 293  :     struct srcline      **nextline;
; 294  : #ifdef DEBUG_OUT
; 295  :     int lineno = 0;
; 296  : #endif
; 297  :     unsigned            nesting_depth = 0;
; 298  :     bool                locals_done;
; 299  :     struct line_status  ls;
; 300  :     struct asm_tok      tok[2];
; 301  :     struct mname_list   mnames[MAX_PLACEHOLDERS]; /* there are max 255 placeholders */
; 302  :     char                buffer[MAX_LINE_LEN];
; 303  : 
; 304  :     DebugMsg1(("StoreMacro(%s, i=%u, store_data=%u) enter, params=>%s<\n", macro->sym.name, i, store_data, tokenarray[i].tokpos ));
; 305  :     info = macro->e.macroinfo;

	mov	r13, QWORD PTR [rcx+104]
	mov	QWORD PTR [rbp+5248], r14
	mov	ebx, edx
	xor	edx, edx

; 306  : 
; 307  :     if( store_data ) {

	test	r9b, r9b
	mov	QWORD PTR [rbp+5240], r15
	mov	QWORD PTR info$1$[rbp], r13
	mov	rsi, r8
	mov	r15, rcx
	mov	r14d, edx
	mov	DWORD PTR nesting_depth$1$[rbp], edx
	je	$LN142@StoreMacro

; 308  :         int j;
; 309  : 
; 310  :         if ( i < Token_Count ) {

	cmp	ebx, DWORD PTR ModuleInfo+496
	jge	SHORT $LN98@StoreMacro

; 311  :             for ( j = i, info->parmcnt = 1; j < Token_Count; j++ )

	mov	WORD PTR [r13], 1
	mov	edx, DWORD PTR ModuleInfo+496
	mov	ecx, ebx
	cmp	ebx, edx
	jge	SHORT $LN95@StoreMacro
	npad	11
$LL97@StoreMacro:

; 312  :                 if ( tokenarray[j].token == T_COMMA )

	movsxd	rax, ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+r8], 44			; 0000002cH
	jne	SHORT $LN96@StoreMacro

; 313  :                     info->parmcnt++;

	inc	WORD PTR [r13]
	mov	edx, DWORD PTR ModuleInfo+496
$LN96@StoreMacro:
	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LL97@StoreMacro
$LN95@StoreMacro:

; 314  :             info->parmlist = LclAlloc( info->parmcnt * sizeof(struct mparm_list));

	movzx	ecx, WORD PTR [r13]
	shl	rcx, 4
	call	LclAlloc

; 315  :         } else {

	xor	edx, edx
	mov	QWORD PTR [r13+8], rax
	jmp	SHORT $LN93@StoreMacro
$LN98@StoreMacro:

; 316  :             info->parmcnt = 0;

	mov	WORD PTR [r13], dx

; 317  :             info->parmlist = NULL;

	mov	QWORD PTR [r13+8], rdx
$LN93@StoreMacro:

; 318  :         }
; 319  : 
; 320  :         for( paranode = info->parmlist, mindex = 0; i < Token_Count ; paranode++ ) {

	cmp	ebx, DWORD PTR ModuleInfo+496
	mov	r12, QWORD PTR [r13+8]
	mov	DWORD PTR mindex$1$[rbp], edx
	mov	r13d, edx
	jge	$LN90@StoreMacro
	lea	r14, QWORD PTR mnames$[rbp]
	npad	5
$LL92@StoreMacro:

; 321  : 
; 322  :             token = tokenarray[i].string_ptr;

	movsxd	r13, ebx
	shl	r13, 5
	mov	rdi, QWORD PTR [r13+rsi+8]

; 323  :             /* Masm accepts reserved words and instructions as parameter
; 324  :              * names! So just check that the token is a valid id.
; 325  :              */
; 326  :             if ( !is_valid_id_first_char( *token ) || tokenarray[i].token == T_STRING ) {

	movsx	ecx, BYTE PTR [rdi]
	call	isalpha
	test	eax, eax
	jne	SHORT $LN87@StoreMacro
	movzx	eax, BYTE PTR [rdi]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN87@StoreMacro
	cmp	al, 64					; 00000040H
	je	SHORT $LN87@StoreMacro
	cmp	al, 36					; 00000024H
	je	SHORT $LN87@StoreMacro
	cmp	al, 63					; 0000003fH
	je	SHORT $LN87@StoreMacro
	cmp	al, 46					; 0000002eH
	jne	$LN88@StoreMacro
	test	BYTE PTR ModuleInfo+408, 32		; 00000020H
	je	$LN88@StoreMacro
$LN87@StoreMacro:
	movzx	eax, BYTE PTR [r13+rsi]
	cmp	al, 9
	je	$LN88@StoreMacro

; 328  :                 break;
; 329  :             } else if ( tokenarray[i].token != T_ID )

	cmp	al, 8
	je	SHORT $LN85@StoreMacro

; 330  :                 EmitWarn( 4, PARAM_IS_RESERVED_WORD, tokenarray[i].string_ptr );

	mov	r8, QWORD PTR [r13+rsi+8]
	mov	edx, 270				; 0000010eH
	mov	ecx, 4
	call	EmitWarn
$LN85@StoreMacro:

; 331  : 
; 332  :             paranode->deflt = NULL;
; 333  :             paranode->required = FALSE;

	and	BYTE PTR [r12+8], 254			; 000000feH

; 334  : 
; 335  :             /* first get the parm. name */
; 336  :             j = strlen( token );
; 337  :             mnames[mindex].label = token;
; 338  :             mnames[mindex].len = j;
; 339  :             mindex++;

	mov	r13d, DWORD PTR mindex$1$[rbp]
	xor	eax, eax
	xor	edx, edx
	mov	QWORD PTR [r14], rdi

; 340  :             mnames[mindex].label = NULL; /* init next entry */
; 341  :             i++;

	inc	ebx
	mov	QWORD PTR [r12], rdx
	add	r14, 16
	inc	r13d
	mov	rcx, -1
	mov	DWORD PTR mindex$1$[rbp], r13d
	repne scasb

; 342  : 
; 343  :             /* now see if it has a default value or is required */
; 344  :             if( tokenarray[i].token == T_COLON ) {

	movsxd	rax, ebx
	not	rcx
	shl	rax, 5
	dec	rcx
	cmp	BYTE PTR [rax+rsi], 58			; 0000003aH
	mov	WORD PTR [r14-8], cx
	mov	QWORD PTR [r14], rdx
	jne	$LN69@StoreMacro

; 345  :                 i++;

	inc	ebx

; 346  :                 if( tokenarray[i].token == T_DIRECTIVE && tokenarray[i].dirtype == DRT_EQUALSGN ) {

	movsxd	r13, ebx
	mov	rdi, r13
	shl	rdi, 5
	cmp	BYTE PTR [rdi+rsi], 3
	jne	SHORT $LN83@StoreMacro
	cmp	BYTE PTR [rdi+rsi+1], 48		; 00000030H
	jne	SHORT $LN83@StoreMacro

; 347  :                     i++;

	inc	ebx

; 348  :                     /* allowed syntax is parm:=<literal> */
; 349  :                     if( tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<' ) {

	movsxd	rdi, ebx
	shl	rdi, 5
	cmp	BYTE PTR [rdi+rsi], 9
	jne	$LN119@StoreMacro
	cmp	BYTE PTR [rdi+rsi+1], 60		; 0000003cH
	jne	$LN119@StoreMacro

; 352  :                     }
; 353  :                     paranode->deflt = LclAlloc( tokenarray[i].stringlen + 1 );

	mov	ecx, DWORD PTR [rdi+rsi+16]
	inc	ecx
	call	LclAlloc
	mov	QWORD PTR [r12], rax

; 354  :                     memcpy( paranode->deflt, tokenarray[i].string_ptr, tokenarray[i].stringlen + 1 );

	mov	r8d, DWORD PTR [rdi+rsi+16]
	mov	rdx, QWORD PTR [rdi+rsi+8]
	inc	r8d
	mov	rcx, rax
	call	memcpy

; 355  :                     i++;

	jmp	$LN153@StoreMacro
$LN83@StoreMacro:

; 356  :                 } else if( _stricmp( tokenarray[i].string_ptr, "REQ" ) == 0 ) {

	mov	rcx, QWORD PTR [rdi+rsi+8]
	lea	rdx, OFFSET FLAT:$SG5652
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN79@StoreMacro

; 357  :                     /* required parameter */
; 358  :                     paranode->required = TRUE;

	or	BYTE PTR [r12+8], 1

; 359  :                     i++;

	jmp	SHORT $LN153@StoreMacro
$LN79@StoreMacro:

; 360  :                 } else if( tokenarray[i].token == T_RES_ID && tokenarray[i].tokval == T_VARARG ) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	al, 7
	jne	SHORT $LN77@StoreMacro
	cmp	DWORD PTR [rdi+rsi+16], 262		; 00000106H
	jne	SHORT $LN77@StoreMacro

; 361  :                     /* more parameters can follow */
; 362  :                     macro->sym.mac_vararg = TRUE;

	or	BYTE PTR [r15+52], 1

; 363  :                     if ( tokenarray[i+1].token != T_FINAL ) {
; 364  :                         EmitError( VARARG_PARAMETER_MUST_BE_LAST );
; 365  :                         break;
; 366  :                     }
; 367  :                     i++;
; 368  : #if MACROLABEL
; 369  :                 } else if( tokenarray[i].token == T_DIRECTIVE &&

	jmp	SHORT $LN157@StoreMacro
$LN77@StoreMacro:

; 370  :                           tokenarray[i].tokval == T_LABEL &&
; 371  :                           Options.strict_masm_compat == FALSE ) { /* parm:LABEL? */

	cmp	al, 3
	jne	SHORT $LN74@StoreMacro
	cmp	DWORD PTR [rdi+rsi+16], 436		; 000001b4H
	jne	SHORT $LN74@StoreMacro
	cmp	BYTE PTR Options+136, 0
	jne	SHORT $LN74@StoreMacro

; 372  :                     /* LABEL attribute for first param only! */
; 373  :                     if ( paranode != info->parmlist ) {

	mov	rax, QWORD PTR info$1$[rbp]
	cmp	r12, QWORD PTR [rax+8]
	jne	$LN121@StoreMacro

; 376  :                     }
; 377  :                     macro->sym.label = TRUE;

	or	BYTE PTR [r15+52], 4

; 378  :                     i++;

	jmp	SHORT $LN153@StoreMacro
$LN74@StoreMacro:

; 379  : #endif
; 380  : #if VARARGML
; 381  :                 } else if( _stricmp( tokenarray[i].string_ptr, "VARARGML" ) == 0 ) {

	mov	rcx, QWORD PTR [rdi+rsi+8]
	lea	rdx, OFFSET FLAT:$SG5661
	call	_stricmp
	test	eax, eax
	jne	$LN71@StoreMacro

; 382  :                     /* more parameters can follow, multi lines possible */
; 383  :                     macro->sym.mac_vararg = TRUE;
; 384  :                     macro->sym.mac_multiline = TRUE;

	or	BYTE PTR [r15+52], 9
$LN157@StoreMacro:

; 385  :                     if ( tokenarray[i+1].token != T_FINAL ) {

	lea	rax, QWORD PTR [r13+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 0
	jne	SHORT $LN122@StoreMacro
$LN153@StoreMacro:
	mov	r13d, DWORD PTR mindex$1$[rbp]

; 388  :                     }
; 389  :                     i++;

	inc	ebx
$LN69@StoreMacro:

; 394  :                 }
; 395  :             }
; 396  :             DebugMsg1(("StoreMacro(%s): param=>%s< found\n", macro->sym.name, mnames[mindex].label));
; 397  :             if( i < Token_Count && tokenarray[i].token != T_COMMA ) {

	mov	ecx, DWORD PTR ModuleInfo+496
	cmp	ebx, ecx
	jge	SHORT $LN68@StoreMacro
	movsxd	rax, ebx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 44			; 0000002cH
	jne	SHORT $LN123@StoreMacro
$LN68@StoreMacro:

; 399  :                 break; // return( ERROR );
; 400  :             }
; 401  :             /* go past comma */
; 402  :             i++;

	inc	ebx
	add	r12, 16
	cmp	ebx, ecx
	jl	$LL92@StoreMacro

; 566  :                     break;
; 567  :                 if ( ( tok[0].token == T_INSTRUCTION || tok[0].token == T_DIRECTIVE ) &&
; 568  :                     oldc != '&' && *ls.input != '&' )

	mov	r14d, DWORD PTR nesting_depth$1$[rbp]
	jmp	$LN90@StoreMacro
$LN88@StoreMacro:

; 327  :                 EmitErr( SYNTAX_ERROR_EX, token );

	mov	rdx, rdi
	jmp	SHORT $LN154@StoreMacro
$LN119@StoreMacro:

; 350  :                         EmitError( LITERAL_EXPECTED_AFTER_EQ );

	mov	ecx, 185				; 000000b9H
	call	EmitError

; 351  :                         break; // return( ERROR );

	mov	r13d, DWORD PTR mindex$1$[rbp]
	mov	r14d, DWORD PTR nesting_depth$1$[rbp]
	jmp	SHORT $LN90@StoreMacro
$LN121@StoreMacro:

; 374  :                         EmitError( LABEL_PARAMETER_MUST_BE_FIRST );

	mov	ecx, 148				; 00000094H
	call	EmitError

; 375  :                         break;

	mov	r13d, DWORD PTR mindex$1$[rbp]
	mov	r14d, DWORD PTR nesting_depth$1$[rbp]
	jmp	SHORT $LN90@StoreMacro
$LN122@StoreMacro:

; 386  :                         EmitError( VARARG_PARAMETER_MUST_BE_LAST );

	mov	ecx, 147				; 00000093H
	call	EmitError

; 387  :                         break;

	mov	r13d, DWORD PTR mindex$1$[rbp]
	mov	r14d, DWORD PTR nesting_depth$1$[rbp]
	jmp	SHORT $LN90@StoreMacro
$LN71@StoreMacro:

; 390  : #endif
; 391  :                 } else {
; 392  :                     EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	movsxd	rdx, ebx
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+8]
$LN154@StoreMacro:
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 393  :                     break;

	mov	r13d, DWORD PTR mindex$1$[rbp]
	mov	r14d, DWORD PTR nesting_depth$1$[rbp]
	jmp	SHORT $LN90@StoreMacro
$LN123@StoreMacro:

; 398  :                 EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos );

	movsxd	rdx, ebx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]
	call	EmitErr
	mov	r14d, DWORD PTR nesting_depth$1$[rbp]
	jmp	SHORT $LN90@StoreMacro
$LN142@StoreMacro:
	mov	r13d, DWORD PTR mindex$[rbp]
	mov	DWORD PTR mindex$1$[rbp], r13d
$LN90@StoreMacro:

; 403  : 
; 404  :         } /* end for() */
; 405  :         DebugMsg1(("StoreMacro(%s): macro parameters done\n", macro->sym.name));
; 406  :     }
; 407  : 
; 408  :     locals_done = FALSE;
; 409  :     nextline = &info->data;

	mov	r12, QWORD PTR info$1$[rbp]
	xor	bl, bl
	add	r12, 16
	mov	BYTE PTR locals_done$1$[rbp], bl
	npad	6
$LL67@StoreMacro:

; 410  : 
; 411  :     /* now read in the lines of the macro, and store them if store_data is TRUE */
; 412  :     for( ; ; ) {
; 413  :         char *ptr;
; 414  : 
; 415  :         src = GetTextLine( buffer );

	lea	rcx, QWORD PTR buffer$[rbp]
	call	GetTextLine

; 416  :         if( src == NULL ) {

	test	rax, rax
	mov	rsi, rax
	jne	SHORT $LN65@StoreMacro

; 417  :             /* v2.11: fatal error if source ends without an ENDM found */
; 418  :             //EmitError( UNMATCHED_MACRO_NESTING );
; 419  :             //ModuleInfo.EndDirFound = TRUE; /* avoid error "END not found" */
; 420  :             //return( ERROR );
; 421  :             Fatal( UNMATCHED_MACRO_NESTING );

	mov	ecx, 162				; 000000a2H
	call	Fatal
$LN65@StoreMacro:

; 422  :         }
; 423  : 
; 424  :         /* add the macro line to the listing file */
; 425  :         /* v2.09: don't make listing depend on store_data */
; 426  :         //if ( ModuleInfo.list && store_data ) {
; 427  :         if ( ModuleInfo.list ) {

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN64@StoreMacro

; 428  :             ModuleInfo.line_flags &= ~LOF_LISTED;

	and	BYTE PTR ModuleInfo+398, 254		; 000000feH

; 429  :             LstWrite( LSTTYPE_MACROLINE, 0, buffer );

	xor	edx, edx
	lea	r8, QWORD PTR buffer$[rbp]
	lea	ecx, QWORD PTR [rdx+8]
	call	LstWrite
$LN64@StoreMacro:

; 430  :         }
; 431  :         ls.input = src;

	mov	rdi, rsi
	mov	QWORD PTR ls$[rbp], rsi

; 432  :         ls.start = src;

	mov	QWORD PTR ls$[rbp+16], rsi

; 433  :         ls.index = 0;

	mov	DWORD PTR ls$[rbp+24], 0
	npad	4
$continue_scan$5672:

; 434  :     continue_scan:
; 435  :         while ( isspace(*ls.input) ) ls.input++;

	movsx	ecx, BYTE PTR [rdi]
	call	isspace
	test	eax, eax
	je	SHORT $LN62@StoreMacro
	npad	4
$LL63@StoreMacro:
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL63@StoreMacro
$LN62@StoreMacro:

; 436  : 
; 437  :         /* skip empty lines! */
; 438  :         if ( *ls.input == NULLC || *ls.input == ';' ) {

	mov	rax, QWORD PTR ls$[rbp]
	movzx	ecx, BYTE PTR [rax]
	test	cl, cl
	je	$LN60@StoreMacro
	cmp	cl, 59					; 0000003bH
	je	$LN60@StoreMacro

; 449  :         }
; 450  : 
; 451  :         /* get first token */
; 452  :         ls.output = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488

; 453  :         //ls.last_token = T_FINAL;
; 454  :         ls.flags = TOK_DEFAULT;
; 455  :         ls.flags2 = 0;
; 456  :         tok[0].token = T_FINAL;
; 457  :         if ( GetToken( &tok[0], &ls ) == ERROR )

	lea	rdx, QWORD PTR ls$[rbp]
	lea	rcx, QWORD PTR tok$[rbp]
	mov	BYTE PTR ls$[rbp+28], 0
	mov	BYTE PTR ls$[rbp+29], 0
	mov	BYTE PTR tok$[rbp], 0
	mov	QWORD PTR ls$[rbp+8], rax
	call	GetToken
	cmp	eax, -1
	je	$LN125@StoreMacro

; 459  : 
; 460  :         /* v2.05: GetTextLine() doesn't concat lines anymore.
; 461  :          * So if a backslash is found in the current source line,
; 462  :          * tokenize it to get possible concatenated lines.
; 463  :          */
; 464  :         if ( strchr( ls.input, '\\' ) ) {

	mov	rcx, QWORD PTR ls$[rbp]
	mov	edx, 92					; 0000005cH
	call	strchr

; 465  :             ptr = ls.input;

	mov	rdi, QWORD PTR ls$[rbp]
	test	rax, rax
	je	$LN57@StoreMacro

; 466  :             while ( *ls.input && *ls.input != ';' ) {

	movzx	eax, BYTE PTR [rdi]
	test	al, al
	je	SHORT $LN55@StoreMacro
	npad	2
$LL56@StoreMacro:
	cmp	al, 59					; 0000003bH
	je	SHORT $LN55@StoreMacro

; 467  :                 ls.flags3 = 0;
; 468  :                 GetToken( &tok[1], &ls );

	lea	rdx, QWORD PTR ls$[rbp]
	lea	rcx, QWORD PTR tok$[rbp+32]
	mov	BYTE PTR ls$[rbp+30], 0
	call	GetToken

; 469  :                 /* v2.09: don't query store_data */
; 470  :                 //if ( ( ls.flags3 & TF3_ISCONCAT ) && ModuleInfo.list && store_data ) {
; 471  :                 if ( ( ls.flags3 & TF3_ISCONCAT ) && ModuleInfo.list ) {

	test	BYTE PTR ls$[rbp+30], 1
	je	SHORT $LN112@StoreMacro
	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN112@StoreMacro

; 472  :                     ModuleInfo.line_flags &= ~LOF_LISTED;
; 473  :                     LstWrite( LSTTYPE_MACROLINE, 0, ls.input );

	mov	r8, QWORD PTR ls$[rbp]
	and	BYTE PTR ModuleInfo+398, 254		; 000000feH
	xor	edx, edx
	lea	ecx, QWORD PTR [rdx+8]
	call	LstWrite
$LN112@StoreMacro:

; 474  :                 }
; 475  :                 while( isspace( *ls.input ) ) ls.input++;

	mov	rax, QWORD PTR ls$[rbp]
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	je	SHORT $LN52@StoreMacro
	npad	6
$LL53@StoreMacro:
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL53@StoreMacro
$LN52@StoreMacro:

; 466  :             while ( *ls.input && *ls.input != ';' ) {

	mov	rax, QWORD PTR ls$[rbp]
	mov	al, BYTE PTR [rax]
	test	al, al
	jne	SHORT $LL56@StoreMacro
$LN55@StoreMacro:

; 476  :             }
; 477  :             ls.input = ptr;

	mov	QWORD PTR ls$[rbp], rdi
$LN57@StoreMacro:

; 478  :         }
; 479  :         if ( tok[0].token == T_FINAL ) {/* did GetToken() return EMPTY? */

	movzx	eax, BYTE PTR tok$[rbp]
	test	al, al

; 480  :             DebugMsg1(("StoreMacro(%s): no token\n", macro->sym.name));
; 481  :             goto continue_scan;

	je	$continue_scan$5672

; 482  :         }
; 483  :         /* handle LOCAL directive(s) */
; 484  :         if( locals_done == FALSE && tok[0].token == T_DIRECTIVE && tok[0].tokval == T_LOCAL ) {

	test	bl, bl
	mov	ecx, DWORD PTR tok$[rbp+16]
	jne	$LN50@StoreMacro
	cmp	al, 3
	jne	$LN50@StoreMacro
	cmp	ecx, 435				; 000001b3H
	jne	$LN50@StoreMacro

; 485  :             if( !store_data )

	cmp	BYTE PTR store_data$[rbp], bl
	je	$LL67@StoreMacro
	xor	esi, esi
	npad	2
$LL48@StoreMacro:

; 486  :                 continue;
; 487  :             for ( ;; ) {
; 488  :                 int size;
; 489  :                 while( isspace( *ls.input ) ) ls.input++;

	movsx	ecx, BYTE PTR [rdi]
	call	isspace
	test	eax, eax
	je	SHORT $LN45@StoreMacro
	npad	4
$LL46@StoreMacro:
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL46@StoreMacro
$LN45@StoreMacro:

; 490  :                 if ( *ls.input == NULLC || *ls.input == ';' ) /* 0 locals are ok */

	mov	rax, QWORD PTR ls$[rbp]
	movzx	ebx, BYTE PTR locals_done$1$[rbp]
	movzx	ecx, BYTE PTR [rax]
	test	cl, cl
	je	$LL67@StoreMacro
	cmp	cl, 59					; 0000003bH
	je	$LL67@StoreMacro

; 491  :                     break;
; 492  :                 ls.output = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488

; 493  :                 GetToken( &tok[0], &ls );

	lea	rdx, QWORD PTR ls$[rbp]
	lea	rcx, QWORD PTR tok$[rbp]
	mov	QWORD PTR ls$[rbp+8], rax
	call	GetToken

; 494  :                 if ( !is_valid_id_first_char( *StringBufferEnd ) ) {

	mov	rdx, QWORD PTR ModuleInfo+488
	movsx	ecx, BYTE PTR [rdx]
	call	isalpha
	mov	rdx, QWORD PTR ModuleInfo+488
	test	eax, eax
	jne	SHORT $LN42@StoreMacro
	movzx	eax, BYTE PTR [rdx]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN42@StoreMacro
	cmp	al, 64					; 00000040H
	je	SHORT $LN42@StoreMacro
	cmp	al, 36					; 00000024H
	je	SHORT $LN42@StoreMacro
	cmp	al, 63					; 0000003fH
	je	SHORT $LN42@StoreMacro
	cmp	al, 46					; 0000002eH
	jne	$LN41@StoreMacro
	test	BYTE PTR ModuleInfo+408, 32		; 00000020H
	je	$LN41@StoreMacro
$LN42@StoreMacro:

; 495  :                     EmitErr( SYNTAX_ERROR_EX, StringBufferEnd );
; 496  :                     break;
; 497  :                 } else if ( tok[0].token != T_ID )

	cmp	BYTE PTR tok$[rbp], 8
	je	SHORT $LN39@StoreMacro

; 498  :                     EmitWarn( 4, PARAM_IS_RESERVED_WORD, StringBufferEnd );

	mov	r8, rdx
	mov	ecx, 4
	mov	edx, 270				; 0000010eH
	call	EmitWarn
	mov	rdx, QWORD PTR ModuleInfo+488
$LN39@StoreMacro:

; 499  : 
; 500  :                 if ( mindex == ( MAX_PLACEHOLDERS - 1 ) ) {

	cmp	r13d, 255				; 000000ffH
	je	$LN127@StoreMacro

; 503  :                 }
; 504  :                 size = strlen( StringBufferEnd );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rdx
	repne scasb
	not	rcx
	dec	rcx

; 505  :                 mnames[mindex].label = myalloca( size );

	movsxd	r8, ecx
	mov	rbx, rcx
	lea	rax, QWORD PTR [r8+15]
	and	rax, -16
	call	__chkstk
	sub	rsp, rax
	movsxd	rdi, r13d
	lea	rcx, QWORD PTR [rsp+32]
	add	rdi, rdi
	mov	QWORD PTR mnames$[rbp+rdi*8], rcx

; 506  :                 memcpy( mnames[mindex].label, StringBufferEnd, size );

	call	memcpy

; 507  :                 mnames[mindex].len = size;
; 508  :                 mindex++;

	inc	r13d

; 509  :                 mnames[mindex].label = NULL; /* mark end of placeholder array */

	movsxd	rax, r13d
	mov	WORD PTR mnames$[rbp+rdi*8+8], bx
	mov	DWORD PTR mindex$1$[rbp], r13d
	add	rax, rax
	mov	QWORD PTR mnames$[rbp+rax*8], rsi

; 510  :                 info->localcnt++;

	mov	rax, QWORD PTR info$1$[rbp]
	inc	WORD PTR [rax+2]

; 511  :                 DebugMsg1(("StoreMacro(%s, %u): local=>%s< added, rest=%s\n", macro->sym.name, nesting_depth, mnames[mindex].label, ls.input ));
; 512  :                 while( isspace( *ls.input ) ) ls.input++;

	mov	rax, QWORD PTR ls$[rbp]
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	je	SHORT $LN36@StoreMacro
	npad	13
$LL37@StoreMacro:
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL37@StoreMacro
$LN36@StoreMacro:

; 513  :                 if ( *ls.input == ',' ) {

	mov	rdi, QWORD PTR ls$[rbp]
	movzx	eax, BYTE PTR [rdi]
	cmp	al, 44					; 0000002cH
	jne	SHORT $LN35@StoreMacro

; 514  :                     ls.input++;

	inc	rdi
	mov	QWORD PTR ls$[rbp], rdi
	jmp	$LL48@StoreMacro
$LN35@StoreMacro:

; 515  :                 } else if ( is_valid_id_first_char( *ls.input ) ) {

	movsx	ecx, al
	call	isalpha
	mov	rdi, QWORD PTR ls$[rbp]
	test	eax, eax
	jne	SHORT $LN128@StoreMacro
	movzx	eax, BYTE PTR [rdi]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN128@StoreMacro
	cmp	al, 64					; 00000040H
	je	SHORT $LN128@StoreMacro
	cmp	al, 36					; 00000024H
	je	SHORT $LN128@StoreMacro
	cmp	al, 63					; 0000003fH
	je	SHORT $LN128@StoreMacro
	cmp	al, 46					; 0000002eH
	jne	$LL48@StoreMacro
	test	BYTE PTR ModuleInfo+408, 32		; 00000020H
	je	$LL48@StoreMacro
$LN128@StoreMacro:

; 516  :                     EmitErr( SYNTAX_ERROR_EX, ls.input );

	mov	rdx, rdi
$LN41@StoreMacro:
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 517  :                     break;
; 518  :                 }
; 519  :             }
; 520  :             continue;

	mov	bl, BYTE PTR locals_done$1$[rbp]
	jmp	$LL67@StoreMacro
$LN127@StoreMacro:

; 501  :                     EmitError( TOO_MANY_MACRO_PLACEHOLDERS );

	mov	ecx, 219				; 000000dbH
	call	EmitError

; 502  :                     break;

	mov	bl, BYTE PTR locals_done$1$[rbp]
	jmp	$LL67@StoreMacro
$LN50@StoreMacro:

; 521  :         }
; 522  :         locals_done = TRUE;
; 523  : 
; 524  :         /* handle macro labels, EXITM, ENDM and macro loop directives.
; 525  :          * this must be done always, even if store_data is false,
; 526  :          * to find the matching ENDM that terminates the macro.
; 527  :          */
; 528  :         if ( tok[0].token == T_COLON ) { /* macro label? */

	cmp	al, 58					; 0000003aH
	mov	bl, 1
	mov	BYTE PTR locals_done$1$[rbp], bl
	jne	SHORT $LN31@StoreMacro

; 529  :             /* skip leading spaces for macro labels! In RunMacro(),
; 530  :              * the label search routine expects no spaces before ':'.
; 531  :              */
; 532  :             src = ls.input - 1;

	lea	rsi, QWORD PTR [rdi-1]
	jmp	$LN4@StoreMacro
$LN31@StoreMacro:

; 533  :         } else if( tok[0].token == T_DIRECTIVE ) {

	cmp	al, 3
	jne	$LN29@StoreMacro

; 534  :             if ( tok[0].tokval == T_EXITM ) {

	cmp	ecx, 398				; 0000018eH
	jne	SHORT $LN28@StoreMacro

; 535  :                 DebugMsg1(("StoreMacro(%s): exitm found, lvl=%u, >%s<\n", macro->sym.name, nesting_depth, ls.input ));
; 536  :                 if ( nesting_depth == 0 ) {

	test	r14d, r14d
	jne	$LN4@StoreMacro

; 537  :                     ptr = ls.input;
; 538  :                     while( isspace( *ptr ) ) ptr++;

	movsx	ecx, BYTE PTR [rdi]
	call	isspace
	test	eax, eax
	je	SHORT $LN25@StoreMacro
	npad	3
$LL26@StoreMacro:
	movsx	ecx, BYTE PTR [rdi+1]
	inc	rdi
	call	isspace
	test	eax, eax
	jne	SHORT $LL26@StoreMacro
$LN25@StoreMacro:

; 539  :                     if ( *ptr && *ptr != ';' )

	movzx	eax, BYTE PTR [rdi]
	test	al, al
	je	$LN4@StoreMacro
	cmp	al, 59					; 0000003bH
	je	$LN4@StoreMacro

; 540  :                         macro->sym.isfunc = TRUE;

	or	BYTE PTR [r15+52], 2

; 541  :                     //macro->sym.runsync = TRUE;
; 542  :                 }

	jmp	$LN4@StoreMacro
$LN28@StoreMacro:

; 543  :             } else if( tok[0].tokval == T_ENDM ) {

	cmp	ecx, 399				; 0000018fH
	jne	SHORT $LN22@StoreMacro

; 544  :                 DebugMsg1(("StoreMacro(%s): endm found, lvl=%u\n", macro->sym.name, nesting_depth ));
; 545  :                 if( nesting_depth ) {

	test	r14d, r14d
	je	$LN21@StoreMacro

; 546  :                     nesting_depth--;

	add	r14d, -1				; ffffffffH
	mov	DWORD PTR nesting_depth$1$[rbp], r14d

; 547  :                 } else {
; 548  :                     break; /* exit the for() loop */
; 549  :                 }

	jmp	$LN4@StoreMacro
$LN22@StoreMacro:

; 550  :             } else if( tok[0].dirtype == DRT_LOOPDIR ) {

	cmp	BYTE PTR tok$[rbp+1], 1
	jne	$LN4@StoreMacro

; 551  :                 nesting_depth++; /* FOR[C], IRP[C], REP[EA]T, WHILE */

	inc	r14d
	mov	DWORD PTR nesting_depth$1$[rbp], r14d

; 552  :             }

	jmp	$LN4@StoreMacro
$LN29@StoreMacro:

; 553  :         } else if ( tok[0].token != T_INSTRUCTION || *ls.input == '&' ) {

	cmp	al, 1
	jne	SHORT $LL14@StoreMacro
	cmp	BYTE PTR [rdi], 38			; 00000026H
	jne	$LN4@StoreMacro
	jmp	SHORT $LL14@StoreMacro
$LL144@StoreMacro:
	mov	rdi, QWORD PTR ls$[rbp]
$LL14@StoreMacro:

; 554  :             /* Skip any token != directive or instruction (and no '&' attached)
; 555  :              * might be text macro ids, macro function calls,
; 556  :              * code labels, ...
; 557  :              */
; 558  :             for (;;) {
; 559  :                 char oldc;
; 560  :                 tok[0].token = T_FINAL;

	mov	BYTE PTR tok$[rbp], 0

; 561  :                 while ( isspace( *ls.input ) ) ls.input++;

	movsx	ecx, BYTE PTR [rdi]
	call	isspace
	test	eax, eax
	je	SHORT $LN11@StoreMacro
	npad	12
$LL12@StoreMacro:
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL12@StoreMacro
$LN11@StoreMacro:

; 562  :                 if ( *ls.input == NULLC || *ls.input == ';' )

	mov	rcx, QWORD PTR ls$[rbp]
	movzx	eax, BYTE PTR [rcx]
	test	al, al
	je	SHORT $LN145@StoreMacro
	cmp	al, 59					; 0000003bH
	je	SHORT $LN145@StoreMacro

; 563  :                     break;
; 564  :                 oldc = *(ls.input-1);

	movzx	edi, BYTE PTR [rcx-1]

; 565  :                 if ( GetToken( &tok[0], &ls ) == ERROR )

	lea	rdx, QWORD PTR ls$[rbp]
	lea	rcx, QWORD PTR tok$[rbp]
	call	GetToken
	cmp	eax, -1
	je	SHORT $LN145@StoreMacro

; 566  :                     break;
; 567  :                 if ( ( tok[0].token == T_INSTRUCTION || tok[0].token == T_DIRECTIVE ) &&
; 568  :                     oldc != '&' && *ls.input != '&' )

	movzx	eax, BYTE PTR tok$[rbp]
	cmp	al, 1
	je	SHORT $LN6@StoreMacro
	cmp	al, 3
	jne	SHORT $LL144@StoreMacro
$LN6@StoreMacro:
	cmp	dil, 38					; 00000026H
	je	SHORT $LL144@StoreMacro
	mov	rdi, QWORD PTR ls$[rbp]
	cmp	BYTE PTR [rdi], 38			; 00000026H

; 569  :                     break;
; 570  :             }

	je	SHORT $LL14@StoreMacro
	jmp	SHORT $LN129@StoreMacro
$LN145@StoreMacro:
	mov	al, BYTE PTR tok$[rbp]
$LN129@StoreMacro:

; 571  :             if ( tok[0].token == T_DIRECTIVE ) {

	cmp	al, 3
	jne	SHORT $LN152@StoreMacro

; 572  :                 /* MACRO or loop directive? */
; 573  :                 if ( tok[0].tokval == T_MACRO || tok[0].dirtype == DRT_LOOPDIR )

	cmp	DWORD PTR tok$[rbp+16], 397		; 0000018dH
	je	SHORT $LN3@StoreMacro
	cmp	BYTE PTR tok$[rbp+1], 1
	jne	SHORT $LN152@StoreMacro
$LN3@StoreMacro:

; 574  :                     nesting_depth++;

	mov	r14d, DWORD PTR nesting_depth$1$[rbp]
	inc	r14d
	mov	DWORD PTR nesting_depth$1$[rbp], r14d
	jmp	SHORT $LN155@StoreMacro
$LN152@StoreMacro:
	mov	r14d, DWORD PTR nesting_depth$1$[rbp]
$LN155@StoreMacro:
	mov	bl, BYTE PTR locals_done$1$[rbp]
$LN4@StoreMacro:

; 575  :             }
; 576  :         }
; 577  : 
; 578  :         /* store the line, but first check for placeholders!
; 579  :          * this is to be improved. store_placeholders() is too
; 580  :          * primitive. It's necessary to use the tokenizer.
; 581  :          */
; 582  :         if( store_data ) {

	cmp	BYTE PTR store_data$[rbp], 0
	mov	r13d, DWORD PTR mindex$1$[rbp]
	je	$LL67@StoreMacro

; 583  :             int j;
; 584  :             uint_8 phs = 0;

	xor	bl, bl

; 585  :             if ( mindex )

	test	r13d, r13d
	je	SHORT $LN1@StoreMacro

; 586  :                 phs = store_placeholders( src, mnames );

	lea	rdx, QWORD PTR mnames$[rbp]
	mov	rcx, rsi
	call	store_placeholders
	mov	ebx, eax
$LN1@StoreMacro:

; 587  :             j = strlen( src );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rsi
	repne scasb
	not	rcx
	dec	rcx
	mov	rdi, rcx

; 588  :             *nextline = LclAlloc( sizeof( struct srcline ) + j );

	movsxd	rcx, ecx
	add	rcx, 16
	call	LclAlloc

; 589  :             (*nextline)->next = NULL;
; 590  :             (*nextline)->ph_count = phs;
; 591  :             memcpy( (*nextline)->line, src, j + 1 );

	mov	rdx, rsi
	mov	QWORD PTR [r12], rax
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR [r12]
	mov	BYTE PTR [rax+8], bl
	mov	rcx, QWORD PTR [r12]
	lea	eax, DWORD PTR [rdi+1]
	add	rcx, 9
	movsxd	r8, eax
	call	memcpy

; 592  :             nextline = &(*nextline)->next;

	mov	r12, QWORD PTR [r12]

; 593  :             DebugMsg1(("StoreMacro(%s, %u): cnt=%u, %u. line >%s<\n", macro->sym.name, nesting_depth, phs, ++lineno, RenderMacroLine( src ) ));
; 594  :         }
; 595  :     } /* end for */

	mov	bl, BYTE PTR locals_done$1$[rbp]
	jmp	$LL67@StoreMacro
$LN60@StoreMacro:

; 439  : #if STORE_EMPTY_LINES
; 440  :             if( store_data ) {

	cmp	BYTE PTR store_data$[rbp], 0
	je	$LL67@StoreMacro

; 441  :                 *nextline = LclAlloc( sizeof( struct srcline ) );

	mov	ecx, 16
	call	LclAlloc
	mov	QWORD PTR [r12], rax

; 442  :                 (*nextline)->next = NULL;

	mov	QWORD PTR [rax], 0

; 443  :                 (*nextline)->ph_count = 0;

	mov	rax, QWORD PTR [r12]
	mov	BYTE PTR [rax+8], 0

; 444  :                 (*nextline)->line[0] = NULLC;

	mov	rax, QWORD PTR [r12]
	mov	BYTE PTR [rax+9], 0

; 445  :                 nextline = &(*nextline)->next;

	mov	r12, QWORD PTR [r12]

; 446  :             }
; 447  : #endif
; 448  :             continue;

	jmp	$LL67@StoreMacro
$LN125@StoreMacro:

; 458  :             return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN100@StoreMacro
$LN21@StoreMacro:

; 596  :     macro->sym.isdefined = TRUE;

	or	BYTE PTR [r15+48], 2

; 597  :     macro->sym.purged = FALSE;

	and	BYTE PTR [r15+52], 239			; 000000efH

; 598  :     DebugMsg1(("StoreMacro(%s): exit, no error, isfunc=%u\n", macro->sym.name, macro->sym.isfunc));
; 599  :     return( NOT_ERROR );

	xor	eax, eax
$LN100@StoreMacro:

; 600  : }

	mov	rbx, QWORD PTR [rbp+5288]
	mov	rsi, QWORD PTR [rbp+5280]
	mov	rdi, QWORD PTR [rbp+5272]
	mov	r12, QWORD PTR [rbp+5264]
	mov	r13, QWORD PTR [rbp+5256]
	mov	r14, QWORD PTR [rbp+5248]
	mov	r15, QWORD PTR [rbp+5240]
	lea	rsp, QWORD PTR [rbp+5296]
	pop	rbp
	ret	0
StoreMacro ENDP
_TEXT	ENDS
PUBLIC	StoreAutoMacro
xdata	SEGMENT
$unwind$StoreAutoMacro DD 025125401H
	DD	0293f454H
	DD	0294e44dH
	DD	0295d43bH
	DD	0296c434H
	DD	0297742dH
	DD	02986426H
	DD	0299341fH
	DD	01132318H
	DD	05006029aH
xdata	ENDS
pdata	SEGMENT
$pdata$StoreAutoMacro DD @imagerel($LN161#)
	DD	@imagerel($LN161#+2343)
	DD	@imagerel($unwind$StoreAutoMacro#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
mindex$1$ = 0
nesting_depth$1$ = 4
ls$ = 8
info$1$ = 40
tok$ = 48
mnames$ = 112
buffer$ = 4208
locals_done$1$ = 5312
macro$ = 5312
i$ = 5320
tokenarray$ = 5328
mindex$ = 5336
store_data$ = 5336
macCode$ = 5344
macLine$ = 5352
macLen$ = 5360
StoreAutoMacro PROC NEAR

; 605  : {

$LN161:
	mov	BYTE PTR [rsp+32], r9b
	push	rbp
	mov	eax, 5328				; 000014d0H
	call	__chkstk
	sub	rsp, rax
	lea	rbp, QWORD PTR [rsp+32]
	mov	QWORD PTR [rbp+5288], rbx
	mov	QWORD PTR [rbp+5280], rsi
	mov	QWORD PTR [rbp+5272], rdi
	mov	QWORD PTR [rbp+5264], r12
	mov	QWORD PTR [rbp+5256], r13

; 606  : 	struct macro_info   *info;
; 607  : 	char                *src;
; 608  : 	char                *token;
; 609  : 	int                 mindex;
; 610  : 	struct mparm_list   *paranode;
; 611  : 	struct srcline      **nextline;
; 612  : #ifdef DEBUG_OUT
; 613  : 	int lineno = 0;
; 614  : #endif
; 615  : 	unsigned            nesting_depth = 0;
; 616  : 	bool                locals_done;
; 617  : 	struct line_status  ls;
; 618  : 	struct asm_tok      tok[2];
; 619  : 	struct mname_list   mnames[MAX_PLACEHOLDERS]; /* there are max 255 placeholders */
; 620  : 	char                buffer[MAX_LINE_LEN];
; 621  : 	int					macCurLine = macLine;
; 622  : 	int					macCnt = macLen;
; 623  : 
; 624  : 	DebugMsg1(("StoreAutoMacro(%s, i=%u, store_data=%u) enter, params=>%s<\n", macro->sym.name, i, store_data, tokenarray[i].tokpos));
; 625  : 	info = macro->e.macroinfo;

	mov	r13, QWORD PTR [rcx+104]
	mov	ebx, edx
	xor	edx, edx

; 626  : 
; 627  : 	if (store_data) {

	test	r9b, r9b
	mov	QWORD PTR [rbp+5248], r14
	mov	QWORD PTR [rbp+5240], r15
	mov	QWORD PTR info$1$[rbp], r13
	mov	rsi, r8
	mov	r15, rcx
	mov	DWORD PTR nesting_depth$1$[rbp], edx
	je	$LN144@StoreAutoM

; 628  : 		int j;
; 629  : 
; 630  : 		if (i < Token_Count) {

	cmp	ebx, DWORD PTR ModuleInfo+496
	jge	SHORT $LN98@StoreAutoM

; 631  : 			for (j = i, info->parmcnt = 1; j < Token_Count; j++)

	mov	WORD PTR [r13], 1
	mov	edx, DWORD PTR ModuleInfo+496
	mov	ecx, ebx
	cmp	ebx, edx
	jge	SHORT $LN95@StoreAutoM
$LL97@StoreAutoM:

; 632  : 				if (tokenarray[j].token == T_COMMA)

	movsxd	rax, ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+r8], 44			; 0000002cH
	jne	SHORT $LN96@StoreAutoM

; 633  : 					info->parmcnt++;

	inc	WORD PTR [r13]
	mov	edx, DWORD PTR ModuleInfo+496
$LN96@StoreAutoM:
	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LL97@StoreAutoM
$LN95@StoreAutoM:

; 634  : 			info->parmlist = LclAlloc(info->parmcnt * sizeof(struct mparm_list));

	movzx	ecx, WORD PTR [r13]
	shl	rcx, 4
	call	LclAlloc

; 635  : 		}
; 636  : 		else {

	xor	edx, edx
	mov	QWORD PTR [r13+8], rax
	jmp	SHORT $LN93@StoreAutoM
$LN98@StoreAutoM:

; 637  : 			info->parmcnt = 0;

	mov	WORD PTR [r13], dx

; 638  : 			info->parmlist = NULL;

	mov	QWORD PTR [r13+8], rdx
$LN93@StoreAutoM:

; 639  : 		}
; 640  : 
; 641  : 		for (paranode = info->parmlist, mindex = 0; i < Token_Count; paranode++) {

	cmp	ebx, DWORD PTR ModuleInfo+496
	mov	r12, QWORD PTR [r13+8]
	mov	DWORD PTR mindex$1$[rbp], edx
	mov	r13d, edx
	jge	$LN90@StoreAutoM
	lea	r14, QWORD PTR mnames$[rbp]
	npad	6
$LL92@StoreAutoM:

; 642  : 
; 643  : 			token = tokenarray[i].string_ptr;

	movsxd	r13, ebx
	shl	r13, 5
	mov	rdi, QWORD PTR [r13+rsi+8]

; 644  : 			/* Masm accepts reserved words and instructions as parameter
; 645  : 			* names! So just check that the token is a valid id.
; 646  : 			*/
; 647  : 			if (!is_valid_id_first_char(*token) || tokenarray[i].token == T_STRING) {

	movsx	ecx, BYTE PTR [rdi]
	call	isalpha
	test	eax, eax
	jne	SHORT $LN87@StoreAutoM
	movzx	eax, BYTE PTR [rdi]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN87@StoreAutoM
	cmp	al, 64					; 00000040H
	je	SHORT $LN87@StoreAutoM
	cmp	al, 36					; 00000024H
	je	SHORT $LN87@StoreAutoM
	cmp	al, 63					; 0000003fH
	je	SHORT $LN87@StoreAutoM
	cmp	al, 46					; 0000002eH
	jne	$LN88@StoreAutoM
	test	BYTE PTR ModuleInfo+408, 32		; 00000020H
	je	$LN88@StoreAutoM
$LN87@StoreAutoM:
	movzx	eax, BYTE PTR [r13+rsi]
	cmp	al, 9
	je	$LN88@StoreAutoM

; 649  : 				break;
; 650  : 			}
; 651  : 			else if (tokenarray[i].token != T_ID)

	cmp	al, 8
	je	SHORT $LN85@StoreAutoM

; 652  : 				EmitWarn(4, PARAM_IS_RESERVED_WORD, tokenarray[i].string_ptr);

	mov	r8, QWORD PTR [r13+rsi+8]
	mov	edx, 270				; 0000010eH
	mov	ecx, 4
	call	EmitWarn
$LN85@StoreAutoM:

; 653  : 
; 654  : 			paranode->deflt = NULL;
; 655  : 			paranode->required = FALSE;

	and	BYTE PTR [r12+8], 254			; 000000feH

; 656  : 
; 657  : 			/* first get the parm. name */
; 658  : 			j = strlen(token);
; 659  : 			mnames[mindex].label = token;
; 660  : 			mnames[mindex].len = j;
; 661  : 			mindex++;

	mov	r13d, DWORD PTR mindex$1$[rbp]
	xor	eax, eax
	xor	edx, edx
	mov	QWORD PTR [r14], rdi

; 662  : 			mnames[mindex].label = NULL; /* init next entry */
; 663  : 			i++;

	inc	ebx
	mov	QWORD PTR [r12], rdx
	add	r14, 16
	inc	r13d
	mov	rcx, -1
	mov	DWORD PTR mindex$1$[rbp], r13d
	repne scasb

; 664  : 
; 665  : 			/* now see if it has a default value or is required */
; 666  : 			if (tokenarray[i].token == T_COLON) {

	movsxd	rax, ebx
	not	rcx
	shl	rax, 5
	dec	rcx
	cmp	BYTE PTR [rax+rsi], 58			; 0000003aH
	mov	WORD PTR [r14-8], cx
	mov	QWORD PTR [r14], rdx
	jne	$LN69@StoreAutoM

; 667  : 				i++;

	inc	ebx

; 668  : 				if (tokenarray[i].token == T_DIRECTIVE && tokenarray[i].dirtype == DRT_EQUALSGN) {

	movsxd	r13, ebx
	mov	rdi, r13
	shl	rdi, 5
	cmp	BYTE PTR [rdi+rsi], 3
	jne	SHORT $LN83@StoreAutoM
	cmp	BYTE PTR [rdi+rsi+1], 48		; 00000030H
	jne	SHORT $LN83@StoreAutoM

; 669  : 					i++;

	inc	ebx

; 670  : 					/* allowed syntax is parm:=<literal> */
; 671  : 					if (tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<') {

	movsxd	rdi, ebx
	shl	rdi, 5
	cmp	BYTE PTR [rdi+rsi], 9
	jne	$LN118@StoreAutoM
	cmp	BYTE PTR [rdi+rsi+1], 60		; 0000003cH
	jne	$LN118@StoreAutoM

; 674  : 					}
; 675  : 					paranode->deflt = LclAlloc(tokenarray[i].stringlen + 1);

	mov	ecx, DWORD PTR [rdi+rsi+16]
	inc	ecx
	call	LclAlloc
	mov	QWORD PTR [r12], rax

; 676  : 					memcpy(paranode->deflt, tokenarray[i].string_ptr, tokenarray[i].stringlen + 1);

	mov	r8d, DWORD PTR [rdi+rsi+16]
	mov	rdx, QWORD PTR [rdi+rsi+8]
	inc	r8d
	mov	rcx, rax
	call	memcpy

; 677  : 					i++;

	jmp	$LN158@StoreAutoM
$LN83@StoreAutoM:

; 678  : 				}
; 679  : 				else if (_stricmp(tokenarray[i].string_ptr, "REQ") == 0) {

	mov	rcx, QWORD PTR [rdi+rsi+8]
	lea	rdx, OFFSET FLAT:$SG5809
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN79@StoreAutoM

; 680  : 					/* required parameter */
; 681  : 					paranode->required = TRUE;

	or	BYTE PTR [r12+8], 1

; 682  : 					i++;

	jmp	SHORT $LN158@StoreAutoM
$LN79@StoreAutoM:

; 683  : 				}
; 684  : 				else if (tokenarray[i].token == T_RES_ID && tokenarray[i].tokval == T_VARARG) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	al, 7
	jne	SHORT $LN77@StoreAutoM
	cmp	DWORD PTR [rdi+rsi+16], 262		; 00000106H
	jne	SHORT $LN77@StoreAutoM

; 685  : 					/* more parameters can follow */
; 686  : 					macro->sym.mac_vararg = TRUE;

	or	BYTE PTR [r15+52], 1

; 687  : 					if (tokenarray[i + 1].token != T_FINAL) {
; 688  : 						EmitError(VARARG_PARAMETER_MUST_BE_LAST);
; 689  : 						break;
; 690  : 					}
; 691  : 					i++;
; 692  : #if MACROLABEL
; 693  : 				}
; 694  : 				else if (tokenarray[i].token == T_DIRECTIVE &&

	jmp	SHORT $LN160@StoreAutoM
$LN77@StoreAutoM:

; 695  : 					tokenarray[i].tokval == T_LABEL &&
; 696  : 					Options.strict_masm_compat == FALSE) { /* parm:LABEL? */

	cmp	al, 3
	jne	SHORT $LN74@StoreAutoM
	cmp	DWORD PTR [rdi+rsi+16], 436		; 000001b4H
	jne	SHORT $LN74@StoreAutoM
	cmp	BYTE PTR Options+136, 0
	jne	SHORT $LN74@StoreAutoM

; 697  : 														   /* LABEL attribute for first param only! */
; 698  : 					if (paranode != info->parmlist) {

	mov	rax, QWORD PTR info$1$[rbp]
	cmp	r12, QWORD PTR [rax+8]
	jne	$LN120@StoreAutoM

; 701  : 					}
; 702  : 					macro->sym.label = TRUE;

	or	BYTE PTR [r15+52], 4

; 703  : 					i++;

	jmp	SHORT $LN158@StoreAutoM
$LN74@StoreAutoM:

; 704  : #endif
; 705  : #if VARARGML
; 706  : 				}
; 707  : 				else if (_stricmp(tokenarray[i].string_ptr, "VARARGML") == 0) {

	mov	rcx, QWORD PTR [rdi+rsi+8]
	lea	rdx, OFFSET FLAT:$SG5818
	call	_stricmp
	test	eax, eax
	jne	$LN71@StoreAutoM

; 708  : 					/* more parameters can follow, multi lines possible */
; 709  : 					macro->sym.mac_vararg = TRUE;
; 710  : 					macro->sym.mac_multiline = TRUE;

	or	BYTE PTR [r15+52], 9
$LN160@StoreAutoM:

; 711  : 					if (tokenarray[i + 1].token != T_FINAL) {

	lea	rax, QWORD PTR [r13+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 0
	jne	SHORT $LN121@StoreAutoM
$LN158@StoreAutoM:
	mov	r13d, DWORD PTR mindex$1$[rbp]

; 714  : 					}
; 715  : 					i++;

	inc	ebx
$LN69@StoreAutoM:

; 721  : 				}
; 722  : 			}
; 723  : 			DebugMsg1(("StoreMacro(%s): param=>%s< found\n", macro->sym.name, mnames[mindex].label));
; 724  : 			if (i < Token_Count && tokenarray[i].token != T_COMMA) {

	mov	ecx, DWORD PTR ModuleInfo+496
	cmp	ebx, ecx
	jge	SHORT $LN68@StoreAutoM
	movsxd	rax, ebx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 44			; 0000002cH
	jne	SHORT $LN122@StoreAutoM
$LN68@StoreAutoM:

; 726  : 				break; // return( ERROR );
; 727  : 			}
; 728  : 			/* go past comma */
; 729  : 			i++;

	inc	ebx
	add	r12, 16
	cmp	ebx, ecx
	jl	$LL92@StoreAutoM

; 900  : 					break;
; 901  : 				if ((tok[0].token == T_INSTRUCTION || tok[0].token == T_DIRECTIVE) &&
; 902  : 					oldc != '&' && *ls.input != '&')

	jmp	$LN90@StoreAutoM
$LN88@StoreAutoM:

; 648  : 				EmitErr(SYNTAX_ERROR_EX, token);

	mov	rdx, rdi
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	mov	r13d, DWORD PTR mindex$1$[rbp]
	jmp	SHORT $LN90@StoreAutoM
$LN118@StoreAutoM:

; 672  : 						EmitError(LITERAL_EXPECTED_AFTER_EQ);

	mov	ecx, 185				; 000000b9H
	call	EmitError

; 673  : 						break; // return( ERROR );

	mov	r13d, DWORD PTR mindex$1$[rbp]
	jmp	SHORT $LN90@StoreAutoM
$LN120@StoreAutoM:

; 699  : 						EmitError(LABEL_PARAMETER_MUST_BE_FIRST);

	mov	ecx, 148				; 00000094H
	call	EmitError

; 700  : 						break;

	mov	r13d, DWORD PTR mindex$1$[rbp]
	jmp	SHORT $LN90@StoreAutoM
$LN121@StoreAutoM:

; 712  : 						EmitError(VARARG_PARAMETER_MUST_BE_LAST);

	mov	ecx, 147				; 00000093H
	call	EmitError

; 713  : 						break;

	mov	r13d, DWORD PTR mindex$1$[rbp]
	jmp	SHORT $LN90@StoreAutoM
$LN71@StoreAutoM:

; 716  : #endif
; 717  : 				}
; 718  : 				else {
; 719  : 					EmitErr(SYNTAX_ERROR_EX, tokenarray[i].string_ptr);

	movsxd	rdx, ebx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+8]
	call	EmitErr

; 720  : 					break;

	mov	r13d, DWORD PTR mindex$1$[rbp]
	jmp	SHORT $LN90@StoreAutoM
$LN122@StoreAutoM:

; 725  : 				EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos);

	movsxd	rdx, ebx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]
	call	EmitErr
	jmp	SHORT $LN90@StoreAutoM
$LN144@StoreAutoM:
	mov	r13d, DWORD PTR mindex$[rbp]
	mov	DWORD PTR mindex$1$[rbp], r13d
$LN90@StoreAutoM:

; 730  : 
; 731  : 		} /* end for() */
; 732  : 		DebugMsg1(("StoreMacro(%s): macro parameters done\n", macro->sym.name));
; 733  : 	}
; 734  : 
; 735  : 	locals_done = FALSE;
; 736  : 	nextline = &info->data;

	mov	r12, QWORD PTR info$1$[rbp]

; 737  : 
; 738  : 	/* now read in the lines of the macro, and store them if store_data is TRUE */
; 739  : 	while (macCnt-- >= 0) {

	mov	eax, DWORD PTR macLen$[rbp]
	movsxd	rcx, DWORD PTR macLine$[rbp]
	xor	bl, bl
	add	r12, 16
	test	eax, eax
	mov	BYTE PTR locals_done$1$[rbp], bl
	mov	r14, rcx
	js	$LN21@StoreAutoM
	npad	8
$LL67@StoreAutoM:
	dec	eax

; 740  : 		char *ptr;
; 741  : 
; 742  : 		src = macCode[macCurLine++];

	inc	ecx
	inc	r14
	mov	DWORD PTR macLen$[rbp], eax
	mov	rax, QWORD PTR macCode$[rbp]
	mov	DWORD PTR macLine$[rbp], ecx
	mov	rsi, QWORD PTR [rax+r14*8-8]

; 743  : 		if (src == NULL) {

	test	rsi, rsi
	jne	SHORT $LN65@StoreAutoM

; 744  : 			/* v2.11: fatal error if source ends without an ENDM found */
; 745  : 			//EmitError( UNMATCHED_MACRO_NESTING );
; 746  : 			//ModuleInfo.EndDirFound = TRUE; /* avoid error "END not found" */
; 747  : 			//return( ERROR );
; 748  : 			Fatal(UNMATCHED_MACRO_NESTING);

	mov	ecx, 162				; 000000a2H
	call	Fatal
$LN65@StoreAutoM:

; 749  : 		}
; 750  : 
; 751  : 		/* add the macro line to the listing file */
; 752  : 		/* v2.09: don't make listing depend on store_data */
; 753  : 		//if ( ModuleInfo.list && store_data ) {
; 754  : 		if (ModuleInfo.list) {

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN64@StoreAutoM

; 755  : 			ModuleInfo.line_flags &= ~LOF_LISTED;

	and	BYTE PTR ModuleInfo+398, 254		; 000000feH

; 756  : 			LstWrite(LSTTYPE_MACROLINE, 0, buffer);

	xor	edx, edx
	lea	r8, QWORD PTR buffer$[rbp]
	lea	ecx, QWORD PTR [rdx+8]
	call	LstWrite
$LN64@StoreAutoM:

; 757  : 		}
; 758  : 		ls.input = src;

	mov	rdi, rsi
	mov	QWORD PTR ls$[rbp], rsi

; 759  : 		ls.start = src;

	mov	QWORD PTR ls$[rbp+16], rsi

; 760  : 		ls.index = 0;

	mov	DWORD PTR ls$[rbp+24], 0
$continue_scan$5829:

; 761  : 	continue_scan:
; 762  : 		while (isspace(*ls.input)) ls.input++;

	movsx	ecx, BYTE PTR [rdi]
	call	isspace
	test	eax, eax
	je	SHORT $LN62@StoreAutoM
	npad	2
$LL63@StoreAutoM:
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL63@StoreAutoM
$LN62@StoreAutoM:

; 763  : 
; 764  : 		/* skip empty lines! */
; 765  : 		if (*ls.input == NULLC || *ls.input == ';') {

	mov	rax, QWORD PTR ls$[rbp]
	movzx	ecx, BYTE PTR [rax]
	test	cl, cl
	je	$LN60@StoreAutoM
	cmp	cl, 59					; 0000003bH
	je	$LN60@StoreAutoM

; 773  : 			}
; 774  : #endif
; 775  : 			continue;
; 776  : 		}
; 777  : 
; 778  : 		/* get first token */
; 779  : 		ls.output = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488

; 780  : 		//ls.last_token = T_FINAL;
; 781  : 		ls.flags = TOK_DEFAULT;
; 782  : 		ls.flags2 = 0;
; 783  : 		tok[0].token = T_FINAL;
; 784  : 		if (GetToken(&tok[0], &ls) == ERROR)

	lea	rdx, QWORD PTR ls$[rbp]
	lea	rcx, QWORD PTR tok$[rbp]
	mov	BYTE PTR ls$[rbp+28], 0
	mov	BYTE PTR ls$[rbp+29], 0
	mov	BYTE PTR tok$[rbp], 0
	mov	QWORD PTR ls$[rbp+8], rax
	call	GetToken
	cmp	eax, -1
	je	$LN124@StoreAutoM

; 786  : 
; 787  : 		/* v2.05: GetTextLine() doesn't concat lines anymore.
; 788  : 		* So if a backslash is found in the current source line,
; 789  : 		* tokenize it to get possible concatenated lines.
; 790  : 		*/
; 791  : 		if (strchr(ls.input, '\\')) {

	mov	rcx, QWORD PTR ls$[rbp]
	mov	edx, 92					; 0000005cH
	call	strchr

; 792  : 			ptr = ls.input;

	mov	rdi, QWORD PTR ls$[rbp]
	test	rax, rax
	je	$LN57@StoreAutoM

; 793  : 			while (*ls.input && *ls.input != ';') {

	movzx	eax, BYTE PTR [rdi]
	test	al, al
	je	SHORT $LN55@StoreAutoM
	npad	2
$LL56@StoreAutoM:
	cmp	al, 59					; 0000003bH
	je	SHORT $LN55@StoreAutoM

; 794  : 				ls.flags3 = 0;
; 795  : 				GetToken(&tok[1], &ls);

	lea	rdx, QWORD PTR ls$[rbp]
	lea	rcx, QWORD PTR tok$[rbp+32]
	mov	BYTE PTR ls$[rbp+30], 0
	call	GetToken

; 796  : 				/* v2.09: don't query store_data */
; 797  : 				//if ( ( ls.flags3 & TF3_ISCONCAT ) && ModuleInfo.list && store_data ) {
; 798  : 				if ((ls.flags3 & TF3_ISCONCAT) && ModuleInfo.list) {

	test	BYTE PTR ls$[rbp+30], 1
	je	SHORT $LN111@StoreAutoM
	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN111@StoreAutoM

; 799  : 					ModuleInfo.line_flags &= ~LOF_LISTED;
; 800  : 					LstWrite(LSTTYPE_MACROLINE, 0, ls.input);

	mov	r8, QWORD PTR ls$[rbp]
	and	BYTE PTR ModuleInfo+398, 254		; 000000feH
	xor	edx, edx
	lea	ecx, QWORD PTR [rdx+8]
	call	LstWrite
$LN111@StoreAutoM:

; 801  : 				}
; 802  : 				while (isspace(*ls.input)) ls.input++;

	mov	rax, QWORD PTR ls$[rbp]
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	je	SHORT $LN52@StoreAutoM
	npad	6
$LL53@StoreAutoM:
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL53@StoreAutoM
$LN52@StoreAutoM:

; 793  : 			while (*ls.input && *ls.input != ';') {

	mov	rax, QWORD PTR ls$[rbp]
	mov	al, BYTE PTR [rax]
	test	al, al
	jne	SHORT $LL56@StoreAutoM
$LN55@StoreAutoM:

; 803  : 			}
; 804  : 			ls.input = ptr;

	mov	QWORD PTR ls$[rbp], rdi
$LN57@StoreAutoM:

; 805  : 		}
; 806  : 		if (tok[0].token == T_FINAL) {/* did GetToken() return EMPTY? */

	movzx	eax, BYTE PTR tok$[rbp]
	test	al, al

; 807  : 			DebugMsg1(("StoreMacro(%s): no token\n", macro->sym.name));
; 808  : 			goto continue_scan;

	je	$continue_scan$5829

; 809  : 		}
; 810  : 		/* handle LOCAL directive(s) */
; 811  : 		if (locals_done == FALSE && tok[0].token == T_DIRECTIVE && tok[0].tokval == T_LOCAL) {

	test	bl, bl
	mov	ecx, DWORD PTR tok$[rbp+16]
	jne	$LN50@StoreAutoM
	cmp	al, 3
	jne	$LN50@StoreAutoM
	cmp	ecx, 435				; 000001b3H
	jne	$LN50@StoreAutoM

; 812  : 			if (!store_data)

	cmp	BYTE PTR store_data$[rbp], bl
	je	$LN59@StoreAutoM
	xor	esi, esi
	npad	2
$LL48@StoreAutoM:

; 813  : 				continue;
; 814  : 			for (;; ) {
; 815  : 				int size;
; 816  : 				while (isspace(*ls.input)) ls.input++;

	movsx	ecx, BYTE PTR [rdi]
	call	isspace
	test	eax, eax
	je	SHORT $LN45@StoreAutoM
	npad	4
$LL46@StoreAutoM:
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL46@StoreAutoM
$LN45@StoreAutoM:

; 817  : 				if (*ls.input == NULLC || *ls.input == ';') /* 0 locals are ok */

	mov	rax, QWORD PTR ls$[rbp]
	movzx	ecx, BYTE PTR [rax]
	test	cl, cl
	je	$LN155@StoreAutoM
	cmp	cl, 59					; 0000003bH
	je	$LN155@StoreAutoM

; 818  : 					break;
; 819  : 				ls.output = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488

; 820  : 				GetToken(&tok[0], &ls);

	lea	rdx, QWORD PTR ls$[rbp]
	lea	rcx, QWORD PTR tok$[rbp]
	mov	QWORD PTR ls$[rbp+8], rax
	call	GetToken

; 821  : 				if (!is_valid_id_first_char(*StringBufferEnd)) {

	mov	rdx, QWORD PTR ModuleInfo+488
	movsx	ecx, BYTE PTR [rdx]
	call	isalpha
	mov	rdx, QWORD PTR ModuleInfo+488
	test	eax, eax
	jne	SHORT $LN42@StoreAutoM
	movzx	eax, BYTE PTR [rdx]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN42@StoreAutoM
	cmp	al, 64					; 00000040H
	je	SHORT $LN42@StoreAutoM
	cmp	al, 36					; 00000024H
	je	SHORT $LN42@StoreAutoM
	cmp	al, 63					; 0000003fH
	je	SHORT $LN42@StoreAutoM
	cmp	al, 46					; 0000002eH
	jne	$LN41@StoreAutoM
	test	BYTE PTR ModuleInfo+408, 32		; 00000020H
	je	$LN41@StoreAutoM
$LN42@StoreAutoM:

; 822  : 					EmitErr(SYNTAX_ERROR_EX, StringBufferEnd);
; 823  : 					break;
; 824  : 				}
; 825  : 				else if (tok[0].token != T_ID)

	cmp	BYTE PTR tok$[rbp], 8
	je	SHORT $LN39@StoreAutoM

; 826  : 					EmitWarn(4, PARAM_IS_RESERVED_WORD, StringBufferEnd);

	mov	r8, rdx
	mov	ecx, 4
	mov	edx, 270				; 0000010eH
	call	EmitWarn
	mov	rdx, QWORD PTR ModuleInfo+488
$LN39@StoreAutoM:

; 827  : 
; 828  : 				if (mindex == (MAX_PLACEHOLDERS - 1)) {

	cmp	r13d, 255				; 000000ffH
	je	$LN126@StoreAutoM

; 831  : 				}
; 832  : 				size = strlen(StringBufferEnd);

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rdx
	repne scasb
	not	rcx
	dec	rcx

; 833  : 				mnames[mindex].label = myalloca(size);

	movsxd	r8, ecx
	mov	rbx, rcx
	lea	rax, QWORD PTR [r8+15]
	and	rax, -16
	call	__chkstk
	sub	rsp, rax
	movsxd	rdi, r13d
	lea	rcx, QWORD PTR [rsp+32]
	add	rdi, rdi
	mov	QWORD PTR mnames$[rbp+rdi*8], rcx

; 834  : 				memcpy(mnames[mindex].label, StringBufferEnd, size);

	call	memcpy

; 835  : 				mnames[mindex].len = size;
; 836  : 				mindex++;

	inc	r13d

; 837  : 				mnames[mindex].label = NULL; /* mark end of placeholder array */

	movsxd	rax, r13d
	mov	WORD PTR mnames$[rbp+rdi*8+8], bx
	mov	DWORD PTR mindex$1$[rbp], r13d
	add	rax, rax
	mov	QWORD PTR mnames$[rbp+rax*8], rsi

; 838  : 				info->localcnt++;

	mov	rax, QWORD PTR info$1$[rbp]
	inc	WORD PTR [rax+2]

; 839  : 				DebugMsg1(("StoreMacro(%s, %u): local=>%s< added, rest=%s\n", macro->sym.name, nesting_depth, mnames[mindex].label, ls.input));
; 840  : 				while (isspace(*ls.input)) ls.input++;

	mov	rax, QWORD PTR ls$[rbp]
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	je	SHORT $LN36@StoreAutoM
	npad	13
$LL37@StoreAutoM:
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL37@StoreAutoM
$LN36@StoreAutoM:

; 841  : 				if (*ls.input == ',') {

	mov	rdi, QWORD PTR ls$[rbp]
	movzx	eax, BYTE PTR [rdi]
	cmp	al, 44					; 0000002cH
	jne	SHORT $LN35@StoreAutoM

; 842  : 					ls.input++;

	inc	rdi
	mov	QWORD PTR ls$[rbp], rdi
	jmp	$LL48@StoreAutoM
$LN35@StoreAutoM:

; 843  : 				}
; 844  : 				else if (is_valid_id_first_char(*ls.input)) {

	movsx	ecx, al
	call	isalpha
	mov	rdi, QWORD PTR ls$[rbp]
	test	eax, eax
	jne	SHORT $LN127@StoreAutoM
	movzx	eax, BYTE PTR [rdi]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN127@StoreAutoM
	cmp	al, 64					; 00000040H
	je	SHORT $LN127@StoreAutoM
	cmp	al, 36					; 00000024H
	je	SHORT $LN127@StoreAutoM
	cmp	al, 63					; 0000003fH
	je	SHORT $LN127@StoreAutoM
	cmp	al, 46					; 0000002eH
	jne	$LL48@StoreAutoM
	test	BYTE PTR ModuleInfo+408, 32		; 00000020H
	je	$LL48@StoreAutoM
$LN127@StoreAutoM:

; 845  : 					EmitErr(SYNTAX_ERROR_EX, ls.input);

	mov	rdx, rdi
$LN41@StoreAutoM:
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN155@StoreAutoM:

; 830  : 					break;

	movzx	ebx, BYTE PTR locals_done$1$[rbp]
$LN59@StoreAutoM:

; 737  : 
; 738  : 	/* now read in the lines of the macro, and store them if store_data is TRUE */
; 739  : 	while (macCnt-- >= 0) {

	mov	eax, DWORD PTR macLen$[rbp]
	mov	ecx, DWORD PTR macLine$[rbp]
	test	eax, eax
	jns	$LL67@StoreAutoM
$LN21@StoreAutoM:

; 930  : 	macro->sym.isdefined = TRUE;

	or	BYTE PTR [r15+48], 2

; 931  : 	macro->sym.purged = FALSE;

	and	BYTE PTR [r15+52], 239			; 000000efH

; 932  : 	DebugMsg1(("StoreMacro(%s): exit, no error, isfunc=%u\n", macro->sym.name, macro->sym.isfunc));
; 933  : 	return(NOT_ERROR);

	xor	eax, eax
$LN100@StoreAutoM:

; 934  : }

	mov	rbx, QWORD PTR [rbp+5288]
	mov	rsi, QWORD PTR [rbp+5280]
	mov	rdi, QWORD PTR [rbp+5272]
	mov	r12, QWORD PTR [rbp+5264]
	mov	r13, QWORD PTR [rbp+5256]
	mov	r14, QWORD PTR [rbp+5248]
	mov	r15, QWORD PTR [rbp+5240]
	lea	rsp, QWORD PTR [rbp+5296]
	pop	rbp
	ret	0
$LN126@StoreAutoM:

; 829  : 					EmitError(TOO_MANY_MACRO_PLACEHOLDERS);

	mov	ecx, 219				; 000000dbH
	call	EmitError

; 830  : 					break;

	jmp	SHORT $LN155@StoreAutoM
$LN50@StoreAutoM:

; 846  : 					break;
; 847  : 				}
; 848  : 			}
; 849  : 			continue;
; 850  : 		}
; 851  : 		locals_done = TRUE;
; 852  : 
; 853  : 		/* handle macro labels, EXITM, ENDM and macro loop directives.
; 854  : 		* this must be done always, even if store_data is false,
; 855  : 		* to find the matching ENDM that terminates the macro.
; 856  : 		*/
; 857  : 		if (tok[0].token == T_COLON) { /* macro label? */

	cmp	al, 58					; 0000003aH
	mov	bl, 1
	mov	BYTE PTR locals_done$1$[rbp], bl
	jne	SHORT $LN31@StoreAutoM

; 858  : 									   /* skip leading spaces for macro labels! In RunMacro(),
; 859  : 									   * the label search routine expects no spaces before ':'.
; 860  : 									   */
; 861  : 			src = ls.input - 1;

	lea	rsi, QWORD PTR [rdi-1]
	jmp	$LN4@StoreAutoM
$LN31@StoreAutoM:

; 862  : 		}
; 863  : 		else if (tok[0].token == T_DIRECTIVE) {

	cmp	al, 3
	jne	$LN29@StoreAutoM

; 864  : 			if (tok[0].tokval == T_EXITM) {

	cmp	ecx, 398				; 0000018eH
	jne	SHORT $LN28@StoreAutoM

; 865  : 				DebugMsg1(("StoreMacro(%s): exitm found, lvl=%u, >%s<\n", macro->sym.name, nesting_depth, ls.input));
; 866  : 				if (nesting_depth == 0) {

	cmp	DWORD PTR nesting_depth$1$[rbp], 0
	jne	$LN4@StoreAutoM

; 867  : 					ptr = ls.input;
; 868  : 					while (isspace(*ptr)) ptr++;

	movsx	ecx, BYTE PTR [rdi]
	call	isspace
	test	eax, eax
	je	SHORT $LN25@StoreAutoM
	npad	5
$LL26@StoreAutoM:
	movsx	ecx, BYTE PTR [rdi+1]
	inc	rdi
	call	isspace
	test	eax, eax
	jne	SHORT $LL26@StoreAutoM
$LN25@StoreAutoM:

; 869  : 					if (*ptr && *ptr != ';')

	movzx	eax, BYTE PTR [rdi]
	test	al, al
	je	$LN4@StoreAutoM
	cmp	al, 59					; 0000003bH
	je	$LN4@StoreAutoM

; 870  : 						macro->sym.isfunc = TRUE;

	or	BYTE PTR [r15+52], 2

; 871  : 					//macro->sym.runsync = TRUE;
; 872  : 				}

	jmp	$LN4@StoreAutoM
$LN28@StoreAutoM:

; 873  : 			}
; 874  : 			else if (tok[0].tokval == T_ENDM) {

	cmp	ecx, 399				; 0000018fH
	jne	SHORT $LN22@StoreAutoM

; 875  : 				DebugMsg1(("StoreMacro(%s): endm found, lvl=%u\n", macro->sym.name, nesting_depth));
; 876  : 				if (nesting_depth) {

	mov	eax, DWORD PTR nesting_depth$1$[rbp]
	test	eax, eax
	je	$LN21@StoreAutoM

; 877  : 					nesting_depth--;

	add	eax, -1					; ffffffffH
	mov	DWORD PTR nesting_depth$1$[rbp], eax

; 878  : 				}
; 879  : 				else {
; 880  : 					break; /* exit the for() loop */
; 881  : 				}

	jmp	$LN4@StoreAutoM
$LN22@StoreAutoM:

; 882  : 			}
; 883  : 			else if (tok[0].dirtype == DRT_LOOPDIR) {

	cmp	BYTE PTR tok$[rbp+1], 1
	jne	$LN4@StoreAutoM

; 884  : 				nesting_depth++; /* FOR[C], IRP[C], REP[EA]T, WHILE */

	inc	DWORD PTR nesting_depth$1$[rbp]

; 885  : 			}

	jmp	$LN4@StoreAutoM
$LN29@StoreAutoM:

; 886  : 		}
; 887  : 		else if (tok[0].token != T_INSTRUCTION || *ls.input == '&') {

	cmp	al, 1
	jne	SHORT $LL14@StoreAutoM
	cmp	BYTE PTR [rdi], 38			; 00000026H
	jne	$LN4@StoreAutoM
	jmp	SHORT $LL14@StoreAutoM
	npad	4
$LL146@StoreAutoM:
	mov	rdi, QWORD PTR ls$[rbp]
$LL14@StoreAutoM:

; 888  : 			/* Skip any token != directive or instruction (and no '&' attached)
; 889  : 			* might be text macro ids, macro function calls,
; 890  : 			* code labels, ...
; 891  : 			*/
; 892  : 			for (;;) {
; 893  : 				char oldc;
; 894  : 				tok[0].token = T_FINAL;

	mov	BYTE PTR tok$[rbp], 0

; 895  : 				while (isspace(*ls.input)) ls.input++;

	movsx	ecx, BYTE PTR [rdi]
	call	isspace
	test	eax, eax
	je	SHORT $LN11@StoreAutoM
	npad	12
$LL12@StoreAutoM:
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL12@StoreAutoM
$LN11@StoreAutoM:

; 896  : 				if (*ls.input == NULLC || *ls.input == ';')

	mov	rcx, QWORD PTR ls$[rbp]
	movzx	eax, BYTE PTR [rcx]
	test	al, al
	je	SHORT $LN147@StoreAutoM
	cmp	al, 59					; 0000003bH
	je	SHORT $LN147@StoreAutoM

; 897  : 					break;
; 898  : 				oldc = *(ls.input - 1);

	movzx	edi, BYTE PTR [rcx-1]

; 899  : 				if (GetToken(&tok[0], &ls) == ERROR)

	lea	rdx, QWORD PTR ls$[rbp]
	lea	rcx, QWORD PTR tok$[rbp]
	call	GetToken
	cmp	eax, -1
	je	SHORT $LN147@StoreAutoM

; 900  : 					break;
; 901  : 				if ((tok[0].token == T_INSTRUCTION || tok[0].token == T_DIRECTIVE) &&
; 902  : 					oldc != '&' && *ls.input != '&')

	movzx	eax, BYTE PTR tok$[rbp]
	cmp	al, 1
	je	SHORT $LN6@StoreAutoM
	cmp	al, 3
	jne	SHORT $LL146@StoreAutoM
$LN6@StoreAutoM:
	cmp	dil, 38					; 00000026H
	je	SHORT $LL146@StoreAutoM
	mov	rdi, QWORD PTR ls$[rbp]
	cmp	BYTE PTR [rdi], 38			; 00000026H

; 903  : 					break;
; 904  : 			}

	je	SHORT $LL14@StoreAutoM
	jmp	SHORT $LN128@StoreAutoM
$LN147@StoreAutoM:
	mov	al, BYTE PTR tok$[rbp]
$LN128@StoreAutoM:

; 905  : 			if (tok[0].token == T_DIRECTIVE) {

	cmp	al, 3
	jne	SHORT $LN157@StoreAutoM

; 906  : 				/* MACRO or loop directive? */
; 907  : 				if (tok[0].tokval == T_MACRO || tok[0].dirtype == DRT_LOOPDIR)

	cmp	DWORD PTR tok$[rbp+16], 397		; 0000018dH
	je	SHORT $LN3@StoreAutoM
	cmp	BYTE PTR tok$[rbp+1], 1
	jne	SHORT $LN157@StoreAutoM
$LN3@StoreAutoM:

; 908  : 					nesting_depth++;

	inc	DWORD PTR nesting_depth$1$[rbp]
$LN157@StoreAutoM:

; 927  : 			DebugMsg1(("StoreMacro(%s, %u): cnt=%u, %u. line >%s<\n", macro->sym.name, nesting_depth, phs, ++lineno, RenderMacroLine(src)));
; 928  : 		}
; 929  : 	} /* end for */

	mov	bl, BYTE PTR locals_done$1$[rbp]
$LN4@StoreAutoM:

; 909  : 			}
; 910  : 		}
; 911  : 
; 912  : 		/* store the line, but first check for placeholders!
; 913  : 		* this is to be improved. store_placeholders() is too
; 914  : 		* primitive. It's necessary to use the tokenizer.
; 915  : 		*/
; 916  : 		if (store_data) {

	cmp	BYTE PTR store_data$[rbp], 0

; 917  : 			int j;
; 918  : 			uint_8 phs = 0;
; 919  : 			if (mindex)

	mov	r13d, DWORD PTR mindex$1$[rbp]
	je	$LN59@StoreAutoM
	xor	bl, bl
	test	r13d, r13d
	je	SHORT $LN1@StoreAutoM

; 920  : 				phs = store_placeholders(src, mnames);

	lea	rdx, QWORD PTR mnames$[rbp]
	mov	rcx, rsi
	call	store_placeholders
	mov	ebx, eax
$LN1@StoreAutoM:

; 921  : 			j = strlen(src);

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rsi
	repne scasb
	not	rcx
	dec	rcx
	mov	rdi, rcx

; 922  : 			*nextline = LclAlloc(sizeof(struct srcline) + j);

	movsxd	rcx, ecx
	add	rcx, 16
	call	LclAlloc

; 923  : 			(*nextline)->next = NULL;
; 924  : 			(*nextline)->ph_count = phs;
; 925  : 			memcpy((*nextline)->line, src, j + 1);

	mov	rdx, rsi
	mov	QWORD PTR [r12], rax
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR [r12]
	mov	BYTE PTR [rax+8], bl
	mov	rcx, QWORD PTR [r12]
	lea	eax, DWORD PTR [rdi+1]
	add	rcx, 9
	movsxd	r8, eax
	call	memcpy

; 926  : 			nextline = &(*nextline)->next;

	mov	r12, QWORD PTR [r12]

; 927  : 			DebugMsg1(("StoreMacro(%s, %u): cnt=%u, %u. line >%s<\n", macro->sym.name, nesting_depth, phs, ++lineno, RenderMacroLine(src)));
; 928  : 		}
; 929  : 	} /* end for */

	jmp	$LN155@StoreAutoM
$LN60@StoreAutoM:

; 766  : #if STORE_EMPTY_LINES
; 767  : 			if (store_data) {

	cmp	BYTE PTR store_data$[rbp], 0
	je	$LN59@StoreAutoM

; 768  : 				*nextline = LclAlloc(sizeof(struct srcline));

	mov	ecx, 16
	call	LclAlloc
	mov	QWORD PTR [r12], rax

; 769  : 				(*nextline)->next = NULL;

	mov	QWORD PTR [rax], 0

; 770  : 				(*nextline)->ph_count = 0;

	mov	rax, QWORD PTR [r12]
	mov	BYTE PTR [rax+8], 0

; 771  : 				(*nextline)->line[0] = NULLC;

	mov	rax, QWORD PTR [r12]
	mov	BYTE PTR [rax+9], 0

; 772  : 				nextline = &(*nextline)->next;

	mov	r12, QWORD PTR [r12]
	jmp	$LN59@StoreAutoM
$LN124@StoreAutoM:

; 785  : 			return(ERROR);

	mov	eax, -1
	jmp	$LN100@StoreAutoM
StoreAutoMacro ENDP
_TEXT	ENDS
PUBLIC	StoreAutoMacroRebuild
xdata	SEGMENT
$unwind$StoreAutoMacroRebuild DD 025125401H
	DD	0293f454H
	DD	0294e44dH
	DD	0295d43bH
	DD	0296c434H
	DD	0297742dH
	DD	02986426H
	DD	0299341fH
	DD	01132318H
	DD	05006029aH
xdata	ENDS
pdata	SEGMENT
$pdata$StoreAutoMacroRebuild DD @imagerel($LN161#)
	DD	@imagerel($LN161#+2343)
	DD	@imagerel($unwind$StoreAutoMacroRebuild#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
mindex$1$ = 0
nesting_depth$1$ = 4
ls$ = 8
info$1$ = 40
tok$ = 48
mnames$ = 112
buffer$ = 4208
locals_done$1$ = 5312
macro$ = 5312
i$ = 5320
tokenarray$ = 5328
mindex$ = 5336
store_data$ = 5336
macCode$ = 5344
macLine$ = 5352
macLen$ = 5360
StoreAutoMacroRebuild PROC NEAR

; 939  : {

$LN161:
	mov	BYTE PTR [rsp+32], r9b
	push	rbp
	mov	eax, 5328				; 000014d0H
	call	__chkstk
	sub	rsp, rax
	lea	rbp, QWORD PTR [rsp+32]
	mov	QWORD PTR [rbp+5288], rbx
	mov	QWORD PTR [rbp+5280], rsi
	mov	QWORD PTR [rbp+5272], rdi
	mov	QWORD PTR [rbp+5264], r12
	mov	QWORD PTR [rbp+5256], r13

; 940  : 	struct macro_info   *info;
; 941  : 	char                *src;
; 942  : 	char                *token;
; 943  : 	int                 mindex;
; 944  : 	struct mparm_list   *paranode;
; 945  : 	struct srcline      **nextline;
; 946  : #ifdef DEBUG_OUT
; 947  : 	int lineno = 0;
; 948  : #endif
; 949  : 	unsigned            nesting_depth = 0;
; 950  : 	bool                locals_done;
; 951  : 	struct line_status  ls;
; 952  : 	struct asm_tok      tok[2];
; 953  : 	struct mname_list   mnames[MAX_PLACEHOLDERS]; /* there are max 255 placeholders */
; 954  : 	char                buffer[MAX_LINE_LEN];
; 955  : 	int					macCurLine = macLine;
; 956  : 	int					macCnt = macLen;
; 957  : 
; 958  : 	DebugMsg1(("StoreAutoMacroRebuild(%s, i=%u, store_data=%u) enter, params=>%s<\n", macro->sym.name, i, store_data, tokenarray[i].tokpos));
; 959  : 	info = macro->e.macroinfo;

	mov	r13, QWORD PTR [rcx+104]
	mov	ebx, edx
	xor	edx, edx

; 960  : 
; 961  : 	if (store_data) {

	test	r9b, r9b
	mov	QWORD PTR [rbp+5248], r14
	mov	QWORD PTR [rbp+5240], r15
	mov	QWORD PTR info$1$[rbp], r13
	mov	rsi, r8
	mov	r15, rcx
	mov	DWORD PTR nesting_depth$1$[rbp], edx
	je	$LN144@StoreAutoM@2

; 962  : 		int j;
; 963  : 
; 964  : 		if (i < Token_Count) {

	cmp	ebx, DWORD PTR ModuleInfo+496
	jge	SHORT $LN98@StoreAutoM@2

; 965  : 			for (j = i, info->parmcnt = 1; j < Token_Count; j++)

	mov	WORD PTR [r13], 1
	mov	edx, DWORD PTR ModuleInfo+496
	mov	ecx, ebx
	cmp	ebx, edx
	jge	SHORT $LN95@StoreAutoM@2
$LL97@StoreAutoM@2:

; 966  : 				if (tokenarray[j].token == T_COMMA)

	movsxd	rax, ecx
	shl	rax, 5
	cmp	BYTE PTR [rax+r8], 44			; 0000002cH
	jne	SHORT $LN96@StoreAutoM@2

; 967  : 					info->parmcnt++;

	inc	WORD PTR [r13]
	mov	edx, DWORD PTR ModuleInfo+496
$LN96@StoreAutoM@2:
	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LL97@StoreAutoM@2
$LN95@StoreAutoM@2:

; 968  : 			info->parmlist = LclAlloc(info->parmcnt * sizeof(struct mparm_list));

	movzx	ecx, WORD PTR [r13]
	shl	rcx, 4
	call	LclAlloc

; 969  : 		}
; 970  : 		else {

	xor	edx, edx
	mov	QWORD PTR [r13+8], rax
	jmp	SHORT $LN93@StoreAutoM@2
$LN98@StoreAutoM@2:

; 971  : 			info->parmcnt = 0;

	mov	WORD PTR [r13], dx

; 972  : 			info->parmlist = NULL;

	mov	QWORD PTR [r13+8], rdx
$LN93@StoreAutoM@2:

; 973  : 		}
; 974  : 
; 975  : 		for (paranode = info->parmlist, mindex = 0; i < Token_Count; paranode++) {

	cmp	ebx, DWORD PTR ModuleInfo+496
	mov	r12, QWORD PTR [r13+8]
	mov	DWORD PTR mindex$1$[rbp], edx
	mov	r13d, edx
	jge	$LN90@StoreAutoM@2
	lea	r14, QWORD PTR mnames$[rbp]
	npad	6
$LL92@StoreAutoM@2:

; 976  : 
; 977  : 			token = tokenarray[i].string_ptr;

	movsxd	r13, ebx
	shl	r13, 5
	mov	rdi, QWORD PTR [r13+rsi+8]

; 978  : 			/* Masm accepts reserved words and instructions as parameter
; 979  : 			* names! So just check that the token is a valid id.
; 980  : 			*/
; 981  : 			if (!is_valid_id_first_char(*token) || tokenarray[i].token == T_STRING) {

	movsx	ecx, BYTE PTR [rdi]
	call	isalpha
	test	eax, eax
	jne	SHORT $LN87@StoreAutoM@2
	movzx	eax, BYTE PTR [rdi]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN87@StoreAutoM@2
	cmp	al, 64					; 00000040H
	je	SHORT $LN87@StoreAutoM@2
	cmp	al, 36					; 00000024H
	je	SHORT $LN87@StoreAutoM@2
	cmp	al, 63					; 0000003fH
	je	SHORT $LN87@StoreAutoM@2
	cmp	al, 46					; 0000002eH
	jne	$LN88@StoreAutoM@2
	test	BYTE PTR ModuleInfo+408, 32		; 00000020H
	je	$LN88@StoreAutoM@2
$LN87@StoreAutoM@2:
	movzx	eax, BYTE PTR [r13+rsi]
	cmp	al, 9
	je	$LN88@StoreAutoM@2

; 983  : 				break;
; 984  : 			}
; 985  : 			else if (tokenarray[i].token != T_ID)

	cmp	al, 8
	je	SHORT $LN85@StoreAutoM@2

; 986  : 				EmitWarn(4, PARAM_IS_RESERVED_WORD, tokenarray[i].string_ptr);

	mov	r8, QWORD PTR [r13+rsi+8]
	mov	edx, 270				; 0000010eH
	mov	ecx, 4
	call	EmitWarn
$LN85@StoreAutoM@2:

; 987  : 
; 988  : 			paranode->deflt = NULL;
; 989  : 			paranode->required = FALSE;

	and	BYTE PTR [r12+8], 254			; 000000feH

; 990  : 
; 991  : 			/* first get the parm. name */
; 992  : 			j = strlen(token);
; 993  : 			mnames[mindex].label = token;
; 994  : 			mnames[mindex].len = j;
; 995  : 			mindex++;

	mov	r13d, DWORD PTR mindex$1$[rbp]
	xor	eax, eax
	xor	edx, edx
	mov	QWORD PTR [r14], rdi

; 996  : 			mnames[mindex].label = NULL; /* init next entry */
; 997  : 			i++;

	inc	ebx
	mov	QWORD PTR [r12], rdx
	add	r14, 16
	inc	r13d
	mov	rcx, -1
	mov	DWORD PTR mindex$1$[rbp], r13d
	repne scasb

; 998  : 
; 999  : 			/* now see if it has a default value or is required */
; 1000 : 			if (tokenarray[i].token == T_COLON) {

	movsxd	rax, ebx
	not	rcx
	shl	rax, 5
	dec	rcx
	cmp	BYTE PTR [rax+rsi], 58			; 0000003aH
	mov	WORD PTR [r14-8], cx
	mov	QWORD PTR [r14], rdx
	jne	$LN69@StoreAutoM@2

; 1001 : 				i++;

	inc	ebx

; 1002 : 				if (tokenarray[i].token == T_DIRECTIVE && tokenarray[i].dirtype == DRT_EQUALSGN) {

	movsxd	r13, ebx
	mov	rdi, r13
	shl	rdi, 5
	cmp	BYTE PTR [rdi+rsi], 3
	jne	SHORT $LN83@StoreAutoM@2
	cmp	BYTE PTR [rdi+rsi+1], 48		; 00000030H
	jne	SHORT $LN83@StoreAutoM@2

; 1003 : 					i++;

	inc	ebx

; 1004 : 					/* allowed syntax is parm:=<literal> */
; 1005 : 					if (tokenarray[i].token != T_STRING || tokenarray[i].string_delim != '<') {

	movsxd	rdi, ebx
	shl	rdi, 5
	cmp	BYTE PTR [rdi+rsi], 9
	jne	$LN118@StoreAutoM@2
	cmp	BYTE PTR [rdi+rsi+1], 60		; 0000003cH
	jne	$LN118@StoreAutoM@2

; 1008 : 					}
; 1009 : 					paranode->deflt = LclAlloc(tokenarray[i].stringlen + 1);

	mov	ecx, DWORD PTR [rdi+rsi+16]
	inc	ecx
	call	LclAlloc
	mov	QWORD PTR [r12], rax

; 1010 : 					memcpy(paranode->deflt, tokenarray[i].string_ptr, tokenarray[i].stringlen + 1);

	mov	r8d, DWORD PTR [rdi+rsi+16]
	mov	rdx, QWORD PTR [rdi+rsi+8]
	inc	r8d
	mov	rcx, rax
	call	memcpy

; 1011 : 					i++;

	jmp	$LN158@StoreAutoM@2
$LN83@StoreAutoM@2:

; 1012 : 				}
; 1013 : 				else if (_stricmp(tokenarray[i].string_ptr, "REQ") == 0) {

	mov	rcx, QWORD PTR [rdi+rsi+8]
	lea	rdx, OFFSET FLAT:$SG5966
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN79@StoreAutoM@2

; 1014 : 					/* required parameter */
; 1015 : 					paranode->required = TRUE;

	or	BYTE PTR [r12+8], 1

; 1016 : 					i++;

	jmp	SHORT $LN158@StoreAutoM@2
$LN79@StoreAutoM@2:

; 1017 : 				}
; 1018 : 				else if (tokenarray[i].token == T_RES_ID && tokenarray[i].tokval == T_VARARG) {

	movzx	eax, BYTE PTR [rdi+rsi]
	cmp	al, 7
	jne	SHORT $LN77@StoreAutoM@2
	cmp	DWORD PTR [rdi+rsi+16], 262		; 00000106H
	jne	SHORT $LN77@StoreAutoM@2

; 1019 : 					/* more parameters can follow */
; 1020 : 					macro->sym.mac_vararg = TRUE;

	or	BYTE PTR [r15+52], 1

; 1021 : 					if (tokenarray[i + 1].token != T_FINAL) {
; 1022 : 						EmitError(VARARG_PARAMETER_MUST_BE_LAST);
; 1023 : 						break;
; 1024 : 					}
; 1025 : 					i++;
; 1026 : #if MACROLABEL
; 1027 : 				}
; 1028 : 				else if (tokenarray[i].token == T_DIRECTIVE &&

	jmp	SHORT $LN160@StoreAutoM@2
$LN77@StoreAutoM@2:

; 1029 : 					tokenarray[i].tokval == T_LABEL &&
; 1030 : 					Options.strict_masm_compat == FALSE) { /* parm:LABEL? */

	cmp	al, 3
	jne	SHORT $LN74@StoreAutoM@2
	cmp	DWORD PTR [rdi+rsi+16], 436		; 000001b4H
	jne	SHORT $LN74@StoreAutoM@2
	cmp	BYTE PTR Options+136, 0
	jne	SHORT $LN74@StoreAutoM@2

; 1031 : 														   /* LABEL attribute for first param only! */
; 1032 : 					if (paranode != info->parmlist) {

	mov	rax, QWORD PTR info$1$[rbp]
	cmp	r12, QWORD PTR [rax+8]
	jne	$LN120@StoreAutoM@2

; 1035 : 					}
; 1036 : 					macro->sym.label = TRUE;

	or	BYTE PTR [r15+52], 4

; 1037 : 					i++;

	jmp	SHORT $LN158@StoreAutoM@2
$LN74@StoreAutoM@2:

; 1038 : #endif
; 1039 : #if VARARGML
; 1040 : 				}
; 1041 : 				else if (_stricmp(tokenarray[i].string_ptr, "VARARGML") == 0) {

	mov	rcx, QWORD PTR [rdi+rsi+8]
	lea	rdx, OFFSET FLAT:$SG5975
	call	_stricmp
	test	eax, eax
	jne	$LN71@StoreAutoM@2

; 1042 : 					/* more parameters can follow, multi lines possible */
; 1043 : 					macro->sym.mac_vararg = TRUE;
; 1044 : 					macro->sym.mac_multiline = TRUE;

	or	BYTE PTR [r15+52], 9
$LN160@StoreAutoM@2:

; 1045 : 					if (tokenarray[i + 1].token != T_FINAL) {

	lea	rax, QWORD PTR [r13+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 0
	jne	SHORT $LN121@StoreAutoM@2
$LN158@StoreAutoM@2:
	mov	r13d, DWORD PTR mindex$1$[rbp]

; 1048 : 					}
; 1049 : 					i++;

	inc	ebx
$LN69@StoreAutoM@2:

; 1055 : 				}
; 1056 : 			}
; 1057 : 			DebugMsg1(("StoreMacro(%s): param=>%s< found\n", macro->sym.name, mnames[mindex].label));
; 1058 : 			if (i < Token_Count && tokenarray[i].token != T_COMMA) {

	mov	ecx, DWORD PTR ModuleInfo+496
	cmp	ebx, ecx
	jge	SHORT $LN68@StoreAutoM@2
	movsxd	rax, ebx
	shl	rax, 5
	cmp	BYTE PTR [rax+rsi], 44			; 0000002cH
	jne	SHORT $LN122@StoreAutoM@2
$LN68@StoreAutoM@2:

; 1060 : 				break; // return( ERROR );
; 1061 : 			}
; 1062 : 			/* go past comma */
; 1063 : 			i++;

	inc	ebx
	add	r12, 16
	cmp	ebx, ecx
	jl	$LL92@StoreAutoM@2

; 1234 : 					break;
; 1235 : 				if ((tok[0].token == T_INSTRUCTION || tok[0].token == T_DIRECTIVE) &&
; 1236 : 					oldc != '&' && *ls.input != '&')

	jmp	$LN90@StoreAutoM@2
$LN88@StoreAutoM@2:

; 982  : 				EmitErr(SYNTAX_ERROR_EX, token);

	mov	rdx, rdi
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	mov	r13d, DWORD PTR mindex$1$[rbp]
	jmp	SHORT $LN90@StoreAutoM@2
$LN118@StoreAutoM@2:

; 1006 : 						EmitError(LITERAL_EXPECTED_AFTER_EQ);

	mov	ecx, 185				; 000000b9H
	call	EmitError

; 1007 : 						break; // return( ERROR );

	mov	r13d, DWORD PTR mindex$1$[rbp]
	jmp	SHORT $LN90@StoreAutoM@2
$LN120@StoreAutoM@2:

; 1033 : 						EmitError(LABEL_PARAMETER_MUST_BE_FIRST);

	mov	ecx, 148				; 00000094H
	call	EmitError

; 1034 : 						break;

	mov	r13d, DWORD PTR mindex$1$[rbp]
	jmp	SHORT $LN90@StoreAutoM@2
$LN121@StoreAutoM@2:

; 1046 : 						EmitError(VARARG_PARAMETER_MUST_BE_LAST);

	mov	ecx, 147				; 00000093H
	call	EmitError

; 1047 : 						break;

	mov	r13d, DWORD PTR mindex$1$[rbp]
	jmp	SHORT $LN90@StoreAutoM@2
$LN71@StoreAutoM@2:

; 1050 : #endif
; 1051 : 				}
; 1052 : 				else {
; 1053 : 					EmitErr(SYNTAX_ERROR_EX, tokenarray[i].string_ptr);

	movsxd	rdx, ebx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+8]
	call	EmitErr

; 1054 : 					break;

	mov	r13d, DWORD PTR mindex$1$[rbp]
	jmp	SHORT $LN90@StoreAutoM@2
$LN122@StoreAutoM@2:

; 1059 : 				EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos);

	movsxd	rdx, ebx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]
	call	EmitErr
	jmp	SHORT $LN90@StoreAutoM@2
$LN144@StoreAutoM@2:
	mov	r13d, DWORD PTR mindex$[rbp]
	mov	DWORD PTR mindex$1$[rbp], r13d
$LN90@StoreAutoM@2:

; 1064 : 
; 1065 : 		} /* end for() */
; 1066 : 		DebugMsg1(("StoreMacro(%s): macro parameters done\n", macro->sym.name));
; 1067 : 	}
; 1068 : 
; 1069 : 	locals_done = FALSE;
; 1070 : 	nextline = &info->data;

	mov	r12, QWORD PTR info$1$[rbp]

; 1071 : 
; 1072 : 	/* now read in the lines of the macro, and store them if store_data is TRUE */
; 1073 : 	while (macCnt-- >= 0) {

	mov	eax, DWORD PTR macLen$[rbp]
	movsxd	rcx, DWORD PTR macLine$[rbp]
	xor	bl, bl
	add	r12, 16
	test	eax, eax
	mov	BYTE PTR locals_done$1$[rbp], bl
	mov	r14, rcx
	js	$LN21@StoreAutoM@2
	npad	8
$LL67@StoreAutoM@2:
	dec	eax

; 1074 : 		char *ptr;
; 1075 : 
; 1076 : 		src = macCode[macCurLine++];

	inc	ecx
	inc	r14
	mov	DWORD PTR macLen$[rbp], eax
	mov	rax, QWORD PTR macCode$[rbp]
	mov	DWORD PTR macLine$[rbp], ecx
	mov	rsi, QWORD PTR [rax+r14*8-8]

; 1077 : 		if (src == NULL) {

	test	rsi, rsi
	jne	SHORT $LN65@StoreAutoM@2

; 1078 : 			/* v2.11: fatal error if source ends without an ENDM found */
; 1079 : 			//EmitError( UNMATCHED_MACRO_NESTING );
; 1080 : 			//ModuleInfo.EndDirFound = TRUE; /* avoid error "END not found" */
; 1081 : 			//return( ERROR );
; 1082 : 			Fatal(UNMATCHED_MACRO_NESTING);

	mov	ecx, 162				; 000000a2H
	call	Fatal
$LN65@StoreAutoM@2:

; 1083 : 		}
; 1084 : 
; 1085 : 		/* add the macro line to the listing file */
; 1086 : 		/* v2.09: don't make listing depend on store_data */
; 1087 : 		//if ( ModuleInfo.list && store_data ) {
; 1088 : 		if (ModuleInfo.list) {

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN64@StoreAutoM@2

; 1089 : 			ModuleInfo.line_flags &= ~LOF_LISTED;

	and	BYTE PTR ModuleInfo+398, 254		; 000000feH

; 1090 : 			LstWrite(LSTTYPE_MACROLINE, 0, buffer);

	xor	edx, edx
	lea	r8, QWORD PTR buffer$[rbp]
	lea	ecx, QWORD PTR [rdx+8]
	call	LstWrite
$LN64@StoreAutoM@2:

; 1091 : 		}
; 1092 : 		ls.input = src;

	mov	rdi, rsi
	mov	QWORD PTR ls$[rbp], rsi

; 1093 : 		ls.start = src;

	mov	QWORD PTR ls$[rbp+16], rsi

; 1094 : 		ls.index = 0;

	mov	DWORD PTR ls$[rbp+24], 0
$continue_scan$5986:

; 1095 : 	continue_scan:
; 1096 : 		while (isspace(*ls.input)) ls.input++;

	movsx	ecx, BYTE PTR [rdi]
	call	isspace
	test	eax, eax
	je	SHORT $LN62@StoreAutoM@2
	npad	2
$LL63@StoreAutoM@2:
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL63@StoreAutoM@2
$LN62@StoreAutoM@2:

; 1097 : 
; 1098 : 		/* skip empty lines! */
; 1099 : 		if (*ls.input == NULLC || *ls.input == ';') {

	mov	rax, QWORD PTR ls$[rbp]
	movzx	ecx, BYTE PTR [rax]
	test	cl, cl
	je	$LN60@StoreAutoM@2
	cmp	cl, 59					; 0000003bH
	je	$LN60@StoreAutoM@2

; 1107 : 			}
; 1108 : #endif
; 1109 : 			continue;
; 1110 : 		}
; 1111 : 
; 1112 : 		/* get first token */
; 1113 : 		ls.output = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488

; 1114 : 		//ls.last_token = T_FINAL;
; 1115 : 		ls.flags = TOK_DEFAULT;
; 1116 : 		ls.flags2 = 0;
; 1117 : 		tok[0].token = T_FINAL;
; 1118 : 		if (GetToken(&tok[0], &ls) == ERROR)

	lea	rdx, QWORD PTR ls$[rbp]
	lea	rcx, QWORD PTR tok$[rbp]
	mov	BYTE PTR ls$[rbp+28], 0
	mov	BYTE PTR ls$[rbp+29], 0
	mov	BYTE PTR tok$[rbp], 0
	mov	QWORD PTR ls$[rbp+8], rax
	call	GetToken
	cmp	eax, -1
	je	$LN124@StoreAutoM@2

; 1120 : 
; 1121 : 		/* v2.05: GetTextLine() doesn't concat lines anymore.
; 1122 : 		* So if a backslash is found in the current source line,
; 1123 : 		* tokenize it to get possible concatenated lines.
; 1124 : 		*/
; 1125 : 		if (strchr(ls.input, '\\')) {

	mov	rcx, QWORD PTR ls$[rbp]
	mov	edx, 92					; 0000005cH
	call	strchr

; 1126 : 			ptr = ls.input;

	mov	rdi, QWORD PTR ls$[rbp]
	test	rax, rax
	je	$LN57@StoreAutoM@2

; 1127 : 			while (*ls.input && *ls.input != ';') {

	movzx	eax, BYTE PTR [rdi]
	test	al, al
	je	SHORT $LN55@StoreAutoM@2
	npad	2
$LL56@StoreAutoM@2:
	cmp	al, 59					; 0000003bH
	je	SHORT $LN55@StoreAutoM@2

; 1128 : 				ls.flags3 = 0;
; 1129 : 				GetToken(&tok[1], &ls);

	lea	rdx, QWORD PTR ls$[rbp]
	lea	rcx, QWORD PTR tok$[rbp+32]
	mov	BYTE PTR ls$[rbp+30], 0
	call	GetToken

; 1130 : 				/* v2.09: don't query store_data */
; 1131 : 				//if ( ( ls.flags3 & TF3_ISCONCAT ) && ModuleInfo.list && store_data ) {
; 1132 : 				if ((ls.flags3 & TF3_ISCONCAT) && ModuleInfo.list) {

	test	BYTE PTR ls$[rbp+30], 1
	je	SHORT $LN111@StoreAutoM@2
	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN111@StoreAutoM@2

; 1133 : 					ModuleInfo.line_flags &= ~LOF_LISTED;
; 1134 : 					LstWrite(LSTTYPE_MACROLINE, 0, ls.input);

	mov	r8, QWORD PTR ls$[rbp]
	and	BYTE PTR ModuleInfo+398, 254		; 000000feH
	xor	edx, edx
	lea	ecx, QWORD PTR [rdx+8]
	call	LstWrite
$LN111@StoreAutoM@2:

; 1135 : 				}
; 1136 : 				while (isspace(*ls.input)) ls.input++;

	mov	rax, QWORD PTR ls$[rbp]
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	je	SHORT $LN52@StoreAutoM@2
	npad	6
$LL53@StoreAutoM@2:
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL53@StoreAutoM@2
$LN52@StoreAutoM@2:

; 1127 : 			while (*ls.input && *ls.input != ';') {

	mov	rax, QWORD PTR ls$[rbp]
	mov	al, BYTE PTR [rax]
	test	al, al
	jne	SHORT $LL56@StoreAutoM@2
$LN55@StoreAutoM@2:

; 1137 : 			}
; 1138 : 			ls.input = ptr;

	mov	QWORD PTR ls$[rbp], rdi
$LN57@StoreAutoM@2:

; 1139 : 		}
; 1140 : 		if (tok[0].token == T_FINAL) {/* did GetToken() return EMPTY? */

	movzx	eax, BYTE PTR tok$[rbp]
	test	al, al

; 1141 : 			DebugMsg1(("StoreMacro(%s): no token\n", macro->sym.name));
; 1142 : 			goto continue_scan;

	je	$continue_scan$5986

; 1143 : 		}
; 1144 : 		/* handle LOCAL directive(s) */
; 1145 : 		if (locals_done == FALSE && tok[0].token == T_DIRECTIVE && tok[0].tokval == T_LOCAL) {

	test	bl, bl
	mov	ecx, DWORD PTR tok$[rbp+16]
	jne	$LN50@StoreAutoM@2
	cmp	al, 3
	jne	$LN50@StoreAutoM@2
	cmp	ecx, 435				; 000001b3H
	jne	$LN50@StoreAutoM@2

; 1146 : 			if (!store_data)

	cmp	BYTE PTR store_data$[rbp], bl
	je	$LN59@StoreAutoM@2
	xor	esi, esi
	npad	2
$LL48@StoreAutoM@2:

; 1147 : 				continue;
; 1148 : 			for (;; ) {
; 1149 : 				int size;
; 1150 : 				while (isspace(*ls.input)) ls.input++;

	movsx	ecx, BYTE PTR [rdi]
	call	isspace
	test	eax, eax
	je	SHORT $LN45@StoreAutoM@2
	npad	4
$LL46@StoreAutoM@2:
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL46@StoreAutoM@2
$LN45@StoreAutoM@2:

; 1151 : 				if (*ls.input == NULLC || *ls.input == ';') /* 0 locals are ok */

	mov	rax, QWORD PTR ls$[rbp]
	movzx	ecx, BYTE PTR [rax]
	test	cl, cl
	je	$LN155@StoreAutoM@2
	cmp	cl, 59					; 0000003bH
	je	$LN155@StoreAutoM@2

; 1152 : 					break;
; 1153 : 				ls.output = StringBufferEnd;

	mov	rax, QWORD PTR ModuleInfo+488

; 1154 : 				GetToken(&tok[0], &ls);

	lea	rdx, QWORD PTR ls$[rbp]
	lea	rcx, QWORD PTR tok$[rbp]
	mov	QWORD PTR ls$[rbp+8], rax
	call	GetToken

; 1155 : 				if (!is_valid_id_first_char(*StringBufferEnd)) {

	mov	rdx, QWORD PTR ModuleInfo+488
	movsx	ecx, BYTE PTR [rdx]
	call	isalpha
	mov	rdx, QWORD PTR ModuleInfo+488
	test	eax, eax
	jne	SHORT $LN42@StoreAutoM@2
	movzx	eax, BYTE PTR [rdx]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN42@StoreAutoM@2
	cmp	al, 64					; 00000040H
	je	SHORT $LN42@StoreAutoM@2
	cmp	al, 36					; 00000024H
	je	SHORT $LN42@StoreAutoM@2
	cmp	al, 63					; 0000003fH
	je	SHORT $LN42@StoreAutoM@2
	cmp	al, 46					; 0000002eH
	jne	$LN41@StoreAutoM@2
	test	BYTE PTR ModuleInfo+408, 32		; 00000020H
	je	$LN41@StoreAutoM@2
$LN42@StoreAutoM@2:

; 1156 : 					EmitErr(SYNTAX_ERROR_EX, StringBufferEnd);
; 1157 : 					break;
; 1158 : 				}
; 1159 : 				else if (tok[0].token != T_ID)

	cmp	BYTE PTR tok$[rbp], 8
	je	SHORT $LN39@StoreAutoM@2

; 1160 : 					EmitWarn(4, PARAM_IS_RESERVED_WORD, StringBufferEnd);

	mov	r8, rdx
	mov	ecx, 4
	mov	edx, 270				; 0000010eH
	call	EmitWarn
	mov	rdx, QWORD PTR ModuleInfo+488
$LN39@StoreAutoM@2:

; 1161 : 
; 1162 : 				if (mindex == (MAX_PLACEHOLDERS - 1)) {

	cmp	r13d, 255				; 000000ffH
	je	$LN126@StoreAutoM@2

; 1165 : 				}
; 1166 : 				size = strlen(StringBufferEnd);

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rdx
	repne scasb
	not	rcx
	dec	rcx

; 1167 : 				mnames[mindex].label = myalloca(size);

	movsxd	r8, ecx
	mov	rbx, rcx
	lea	rax, QWORD PTR [r8+15]
	and	rax, -16
	call	__chkstk
	sub	rsp, rax
	movsxd	rdi, r13d
	lea	rcx, QWORD PTR [rsp+32]
	add	rdi, rdi
	mov	QWORD PTR mnames$[rbp+rdi*8], rcx

; 1168 : 				memcpy(mnames[mindex].label, StringBufferEnd, size);

	call	memcpy

; 1169 : 				mnames[mindex].len = size;
; 1170 : 				mindex++;

	inc	r13d

; 1171 : 				mnames[mindex].label = NULL; /* mark end of placeholder array */

	movsxd	rax, r13d
	mov	WORD PTR mnames$[rbp+rdi*8+8], bx
	mov	DWORD PTR mindex$1$[rbp], r13d
	add	rax, rax
	mov	QWORD PTR mnames$[rbp+rax*8], rsi

; 1172 : 				info->localcnt++;

	mov	rax, QWORD PTR info$1$[rbp]
	inc	WORD PTR [rax+2]

; 1173 : 				DebugMsg1(("StoreMacro(%s, %u): local=>%s< added, rest=%s\n", macro->sym.name, nesting_depth, mnames[mindex].label, ls.input));
; 1174 : 				while (isspace(*ls.input)) ls.input++;

	mov	rax, QWORD PTR ls$[rbp]
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	je	SHORT $LN36@StoreAutoM@2
	npad	13
$LL37@StoreAutoM@2:
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL37@StoreAutoM@2
$LN36@StoreAutoM@2:

; 1175 : 				if (*ls.input == ',') {

	mov	rdi, QWORD PTR ls$[rbp]
	movzx	eax, BYTE PTR [rdi]
	cmp	al, 44					; 0000002cH
	jne	SHORT $LN35@StoreAutoM@2

; 1176 : 					ls.input++;

	inc	rdi
	mov	QWORD PTR ls$[rbp], rdi
	jmp	$LL48@StoreAutoM@2
$LN35@StoreAutoM@2:

; 1177 : 				}
; 1178 : 				else if (is_valid_id_first_char(*ls.input)) {

	movsx	ecx, al
	call	isalpha
	mov	rdi, QWORD PTR ls$[rbp]
	test	eax, eax
	jne	SHORT $LN127@StoreAutoM@2
	movzx	eax, BYTE PTR [rdi]
	cmp	al, 95					; 0000005fH
	je	SHORT $LN127@StoreAutoM@2
	cmp	al, 64					; 00000040H
	je	SHORT $LN127@StoreAutoM@2
	cmp	al, 36					; 00000024H
	je	SHORT $LN127@StoreAutoM@2
	cmp	al, 63					; 0000003fH
	je	SHORT $LN127@StoreAutoM@2
	cmp	al, 46					; 0000002eH
	jne	$LL48@StoreAutoM@2
	test	BYTE PTR ModuleInfo+408, 32		; 00000020H
	je	$LL48@StoreAutoM@2
$LN127@StoreAutoM@2:

; 1179 : 					EmitErr(SYNTAX_ERROR_EX, ls.input);

	mov	rdx, rdi
$LN41@StoreAutoM@2:
	mov	ecx, 209				; 000000d1H
	call	EmitErr
$LN155@StoreAutoM@2:

; 1164 : 					break;

	movzx	ebx, BYTE PTR locals_done$1$[rbp]
$LN59@StoreAutoM@2:

; 1071 : 
; 1072 : 	/* now read in the lines of the macro, and store them if store_data is TRUE */
; 1073 : 	while (macCnt-- >= 0) {

	mov	eax, DWORD PTR macLen$[rbp]
	mov	ecx, DWORD PTR macLine$[rbp]
	test	eax, eax
	jns	$LL67@StoreAutoM@2
$LN21@StoreAutoM@2:

; 1264 : 	macro->sym.isdefined = TRUE;

	or	BYTE PTR [r15+48], 2

; 1265 : 	macro->sym.purged = FALSE;

	and	BYTE PTR [r15+52], 239			; 000000efH

; 1266 : 	DebugMsg1(("StoreMacro(%s): exit, no error, isfunc=%u\n", macro->sym.name, macro->sym.isfunc));
; 1267 : 	return(NOT_ERROR);

	xor	eax, eax
$LN100@StoreAutoM@2:

; 1268 : }

	mov	rbx, QWORD PTR [rbp+5288]
	mov	rsi, QWORD PTR [rbp+5280]
	mov	rdi, QWORD PTR [rbp+5272]
	mov	r12, QWORD PTR [rbp+5264]
	mov	r13, QWORD PTR [rbp+5256]
	mov	r14, QWORD PTR [rbp+5248]
	mov	r15, QWORD PTR [rbp+5240]
	lea	rsp, QWORD PTR [rbp+5296]
	pop	rbp
	ret	0
$LN126@StoreAutoM@2:

; 1163 : 					EmitError(TOO_MANY_MACRO_PLACEHOLDERS);

	mov	ecx, 219				; 000000dbH
	call	EmitError

; 1164 : 					break;

	jmp	SHORT $LN155@StoreAutoM@2
$LN50@StoreAutoM@2:

; 1180 : 					break;
; 1181 : 				}
; 1182 : 			}
; 1183 : 			continue;
; 1184 : 		}
; 1185 : 		locals_done = TRUE;
; 1186 : 
; 1187 : 		/* handle macro labels, EXITM, ENDM and macro loop directives.
; 1188 : 		* this must be done always, even if store_data is false,
; 1189 : 		* to find the matching ENDM that terminates the macro.
; 1190 : 		*/
; 1191 : 		if (tok[0].token == T_COLON) { /* macro label? */

	cmp	al, 58					; 0000003aH
	mov	bl, 1
	mov	BYTE PTR locals_done$1$[rbp], bl
	jne	SHORT $LN31@StoreAutoM@2

; 1192 : 									   /* skip leading spaces for macro labels! In RunMacro(),
; 1193 : 									   * the label search routine expects no spaces before ':'.
; 1194 : 									   */
; 1195 : 			src = ls.input - 1;

	lea	rsi, QWORD PTR [rdi-1]
	jmp	$LN4@StoreAutoM@2
$LN31@StoreAutoM@2:

; 1196 : 		}
; 1197 : 		else if (tok[0].token == T_DIRECTIVE) {

	cmp	al, 3
	jne	$LN29@StoreAutoM@2

; 1198 : 			if (tok[0].tokval == T_EXITM) {

	cmp	ecx, 398				; 0000018eH
	jne	SHORT $LN28@StoreAutoM@2

; 1199 : 				DebugMsg1(("StoreMacro(%s): exitm found, lvl=%u, >%s<\n", macro->sym.name, nesting_depth, ls.input));
; 1200 : 				if (nesting_depth == 0) {

	cmp	DWORD PTR nesting_depth$1$[rbp], 0
	jne	$LN4@StoreAutoM@2

; 1201 : 					ptr = ls.input;
; 1202 : 					while (isspace(*ptr)) ptr++;

	movsx	ecx, BYTE PTR [rdi]
	call	isspace
	test	eax, eax
	je	SHORT $LN25@StoreAutoM@2
	npad	5
$LL26@StoreAutoM@2:
	movsx	ecx, BYTE PTR [rdi+1]
	inc	rdi
	call	isspace
	test	eax, eax
	jne	SHORT $LL26@StoreAutoM@2
$LN25@StoreAutoM@2:

; 1203 : 					if (*ptr && *ptr != ';')

	movzx	eax, BYTE PTR [rdi]
	test	al, al
	je	$LN4@StoreAutoM@2
	cmp	al, 59					; 0000003bH
	je	$LN4@StoreAutoM@2

; 1204 : 						macro->sym.isfunc = TRUE;

	or	BYTE PTR [r15+52], 2

; 1205 : 					//macro->sym.runsync = TRUE;
; 1206 : 				}

	jmp	$LN4@StoreAutoM@2
$LN28@StoreAutoM@2:

; 1207 : 			}
; 1208 : 			else if (tok[0].tokval == T_ENDM) {

	cmp	ecx, 399				; 0000018fH
	jne	SHORT $LN22@StoreAutoM@2

; 1209 : 				DebugMsg1(("StoreMacro(%s): endm found, lvl=%u\n", macro->sym.name, nesting_depth));
; 1210 : 				if (nesting_depth) {

	mov	eax, DWORD PTR nesting_depth$1$[rbp]
	test	eax, eax
	je	$LN21@StoreAutoM@2

; 1211 : 					nesting_depth--;

	add	eax, -1					; ffffffffH
	mov	DWORD PTR nesting_depth$1$[rbp], eax

; 1212 : 				}
; 1213 : 				else {
; 1214 : 					break; /* exit the for() loop */
; 1215 : 				}

	jmp	$LN4@StoreAutoM@2
$LN22@StoreAutoM@2:

; 1216 : 			}
; 1217 : 			else if (tok[0].dirtype == DRT_LOOPDIR) {

	cmp	BYTE PTR tok$[rbp+1], 1
	jne	$LN4@StoreAutoM@2

; 1218 : 				nesting_depth++; /* FOR[C], IRP[C], REP[EA]T, WHILE */

	inc	DWORD PTR nesting_depth$1$[rbp]

; 1219 : 			}

	jmp	$LN4@StoreAutoM@2
$LN29@StoreAutoM@2:

; 1220 : 		}
; 1221 : 		else if (tok[0].token != T_INSTRUCTION || *ls.input == '&') {

	cmp	al, 1
	jne	SHORT $LL14@StoreAutoM@2
	cmp	BYTE PTR [rdi], 38			; 00000026H
	jne	$LN4@StoreAutoM@2
	jmp	SHORT $LL14@StoreAutoM@2
	npad	4
$LL146@StoreAutoM@2:
	mov	rdi, QWORD PTR ls$[rbp]
$LL14@StoreAutoM@2:

; 1222 : 			/* Skip any token != directive or instruction (and no '&' attached)
; 1223 : 			* might be text macro ids, macro function calls,
; 1224 : 			* code labels, ...
; 1225 : 			*/
; 1226 : 			for (;;) {
; 1227 : 				char oldc;
; 1228 : 				tok[0].token = T_FINAL;

	mov	BYTE PTR tok$[rbp], 0

; 1229 : 				while (isspace(*ls.input)) ls.input++;

	movsx	ecx, BYTE PTR [rdi]
	call	isspace
	test	eax, eax
	je	SHORT $LN11@StoreAutoM@2
	npad	12
$LL12@StoreAutoM@2:
	mov	rax, QWORD PTR ls$[rbp]
	inc	rax
	mov	QWORD PTR ls$[rbp], rax
	movsx	ecx, BYTE PTR [rax]
	call	isspace
	test	eax, eax
	jne	SHORT $LL12@StoreAutoM@2
$LN11@StoreAutoM@2:

; 1230 : 				if (*ls.input == NULLC || *ls.input == ';')

	mov	rcx, QWORD PTR ls$[rbp]
	movzx	eax, BYTE PTR [rcx]
	test	al, al
	je	SHORT $LN147@StoreAutoM@2
	cmp	al, 59					; 0000003bH
	je	SHORT $LN147@StoreAutoM@2

; 1231 : 					break;
; 1232 : 				oldc = *(ls.input - 1);

	movzx	edi, BYTE PTR [rcx-1]

; 1233 : 				if (GetToken(&tok[0], &ls) == ERROR)

	lea	rdx, QWORD PTR ls$[rbp]
	lea	rcx, QWORD PTR tok$[rbp]
	call	GetToken
	cmp	eax, -1
	je	SHORT $LN147@StoreAutoM@2

; 1234 : 					break;
; 1235 : 				if ((tok[0].token == T_INSTRUCTION || tok[0].token == T_DIRECTIVE) &&
; 1236 : 					oldc != '&' && *ls.input != '&')

	movzx	eax, BYTE PTR tok$[rbp]
	cmp	al, 1
	je	SHORT $LN6@StoreAutoM@2
	cmp	al, 3
	jne	SHORT $LL146@StoreAutoM@2
$LN6@StoreAutoM@2:
	cmp	dil, 38					; 00000026H
	je	SHORT $LL146@StoreAutoM@2
	mov	rdi, QWORD PTR ls$[rbp]
	cmp	BYTE PTR [rdi], 38			; 00000026H

; 1237 : 					break;
; 1238 : 			}

	je	SHORT $LL14@StoreAutoM@2
	jmp	SHORT $LN128@StoreAutoM@2
$LN147@StoreAutoM@2:
	mov	al, BYTE PTR tok$[rbp]
$LN128@StoreAutoM@2:

; 1239 : 			if (tok[0].token == T_DIRECTIVE) {

	cmp	al, 3
	jne	SHORT $LN157@StoreAutoM@2

; 1240 : 				/* MACRO or loop directive? */
; 1241 : 				if (tok[0].tokval == T_MACRO || tok[0].dirtype == DRT_LOOPDIR)

	cmp	DWORD PTR tok$[rbp+16], 397		; 0000018dH
	je	SHORT $LN3@StoreAutoM@2
	cmp	BYTE PTR tok$[rbp+1], 1
	jne	SHORT $LN157@StoreAutoM@2
$LN3@StoreAutoM@2:

; 1242 : 					nesting_depth++;

	inc	DWORD PTR nesting_depth$1$[rbp]
$LN157@StoreAutoM@2:

; 1261 : 			DebugMsg1(("StoreMacro(%s, %u): cnt=%u, %u. line >%s<\n", macro->sym.name, nesting_depth, phs, ++lineno, RenderMacroLine(src)));
; 1262 : 		}
; 1263 : 	} /* end for */

	mov	bl, BYTE PTR locals_done$1$[rbp]
$LN4@StoreAutoM@2:

; 1243 : 			}
; 1244 : 		}
; 1245 : 
; 1246 : 		/* store the line, but first check for placeholders!
; 1247 : 		* this is to be improved. store_placeholders() is too
; 1248 : 		* primitive. It's necessary to use the tokenizer.
; 1249 : 		*/
; 1250 : 		if (store_data) {

	cmp	BYTE PTR store_data$[rbp], 0

; 1251 : 			int j;
; 1252 : 			uint_8 phs = 0;
; 1253 : 			if (mindex)

	mov	r13d, DWORD PTR mindex$1$[rbp]
	je	$LN59@StoreAutoM@2
	xor	bl, bl
	test	r13d, r13d
	je	SHORT $LN1@StoreAutoM@2

; 1254 : 				phs = store_placeholders(src, mnames);

	lea	rdx, QWORD PTR mnames$[rbp]
	mov	rcx, rsi
	call	store_placeholders
	mov	ebx, eax
$LN1@StoreAutoM@2:

; 1255 : 			j = strlen(src);

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rsi
	repne scasb
	not	rcx
	dec	rcx
	mov	rdi, rcx

; 1256 : 			*nextline = LclAlloc(sizeof(struct srcline) + j);

	movsxd	rcx, ecx
	add	rcx, 16
	call	LclAlloc

; 1257 : 			(*nextline)->next = NULL;
; 1258 : 			(*nextline)->ph_count = phs;
; 1259 : 			memcpy((*nextline)->line, src, j + 1);

	mov	rdx, rsi
	mov	QWORD PTR [r12], rax
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR [r12]
	mov	BYTE PTR [rax+8], bl
	mov	rcx, QWORD PTR [r12]
	lea	eax, DWORD PTR [rdi+1]
	add	rcx, 9
	movsxd	r8, eax
	call	memcpy

; 1260 : 			nextline = &(*nextline)->next;

	mov	r12, QWORD PTR [r12]

; 1261 : 			DebugMsg1(("StoreMacro(%s, %u): cnt=%u, %u. line >%s<\n", macro->sym.name, nesting_depth, phs, ++lineno, RenderMacroLine(src)));
; 1262 : 		}
; 1263 : 	} /* end for */

	jmp	$LN155@StoreAutoM@2
$LN60@StoreAutoM@2:

; 1100 : #if STORE_EMPTY_LINES
; 1101 : 			if (store_data) {

	cmp	BYTE PTR store_data$[rbp], 0
	je	$LN59@StoreAutoM@2

; 1102 : 				*nextline = LclAlloc(sizeof(struct srcline));

	mov	ecx, 16
	call	LclAlloc
	mov	QWORD PTR [r12], rax

; 1103 : 				(*nextline)->next = NULL;

	mov	QWORD PTR [rax], 0

; 1104 : 				(*nextline)->ph_count = 0;

	mov	rax, QWORD PTR [r12]
	mov	BYTE PTR [rax+8], 0

; 1105 : 				(*nextline)->line[0] = NULLC;

	mov	rax, QWORD PTR [r12]
	mov	BYTE PTR [rax+9], 0

; 1106 : 				nextline = &(*nextline)->next;

	mov	r12, QWORD PTR [r12]
	jmp	$LN59@StoreAutoM@2
$LN124@StoreAutoM@2:

; 1119 : 			return(ERROR);

	mov	eax, -1
	jmp	$LN100@StoreAutoM@2
StoreAutoMacroRebuild ENDP
_TEXT	ENDS
PUBLIC	CreateMacro
EXTRN	SymCreate:NEAR
xdata	SEGMENT
$unwind$CreateMacro DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$CreateMacro DD @imagerel($LN5#)
	DD	@imagerel($LN5#+93)
	DD	@imagerel($unwind$CreateMacro#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
CreateMacro PROC NEAR

; 1273 : {

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1274 :     struct dsym *macro;
; 1275 :     if ( macro = (struct dsym *)SymCreate( name ) ) {

	call	SymCreate
	test	rax, rax
	mov	rbx, rax
	je	SHORT $LN1@CreateMacr

; 1276 :         macro->sym.state = SYM_MACRO;
; 1277 :         macro->e.macroinfo = LclAlloc( sizeof( struct macro_info ) );

	mov	ecx, 32					; 00000020H
	mov	DWORD PTR [rax+40], 9
	call	LclAlloc

; 1278 :         macro->e.macroinfo->parmcnt  = 0;
; 1279 :         macro->e.macroinfo->localcnt = 0;
; 1280 :         macro->e.macroinfo->parmlist = NULL;

	xor	edx, edx
	mov	QWORD PTR [rbx+104], rax
	mov	WORD PTR [rax], 0
	mov	rcx, QWORD PTR [rbx+104]
	mov	WORD PTR [rcx+2], 0
	mov	rcx, QWORD PTR [rbx+104]
	mov	QWORD PTR [rcx+8], rdx

; 1281 :         macro->e.macroinfo->data     = NULL;

	mov	rax, QWORD PTR [rbx+104]
	mov	QWORD PTR [rax+16], rdx

; 1282 : #ifdef DEBUG_OUT
; 1283 :         macro->e.macroinfo->count = 0;
; 1284 : #endif
; 1285 :         macro->e.macroinfo->srcfile  = 0;

	mov	rax, QWORD PTR [rbx+104]
	mov	DWORD PTR [rax+24], edx

; 1286 :         macro->sym.mac_vararg = FALSE;
; 1287 :         macro->sym.isfunc = FALSE;

	and	BYTE PTR [rbx+52], 252			; 000000fcH

; 1288 :     }
; 1289 :     return( macro );

	mov	rax, rbx
$LN1@CreateMacr:

; 1290 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
CreateMacro ENDP
_TEXT	ENDS
PUBLIC	ReuseMacro
EXTRN	SymFind:NEAR
xdata	SEGMENT
$unwind$ReuseMacro DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$ReuseMacro DD @imagerel($LN3#)
	DD	@imagerel($LN3#+88)
	DD	@imagerel($unwind$ReuseMacro#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
ReuseMacro PROC NEAR

; 1295 : {

$LN3:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1296 : 	struct dsym *macro;
; 1297 : 	macro = (struct dsym *)SymFind(name);

	call	SymFind

; 1298 : 
; 1299 : 	macro->sym.state = SYM_MACRO;
; 1300 : 	macro->e.macroinfo = LclAlloc(sizeof(struct macro_info));

	mov	ecx, 32					; 00000020H
	mov	DWORD PTR [rax+40], 9
	mov	rbx, rax
	call	LclAlloc
	mov	QWORD PTR [rbx+104], rax

; 1301 : 	macro->e.macroinfo->parmcnt = 0;

	mov	WORD PTR [rax], 0

; 1302 : 	macro->e.macroinfo->localcnt = 0;

	mov	rcx, QWORD PTR [rbx+104]
	mov	WORD PTR [rcx+2], 0

; 1303 : 	macro->e.macroinfo->parmlist = NULL;

	mov	rcx, QWORD PTR [rbx+104]
	xor	edx, edx
	mov	QWORD PTR [rcx+8], rdx

; 1304 : 	macro->e.macroinfo->data = NULL;

	mov	rcx, QWORD PTR [rbx+104]
	mov	QWORD PTR [rcx+16], rdx

; 1305 : #ifdef DEBUG_OUT
; 1306 : 	macro->e.macroinfo->count = 0;
; 1307 : #endif
; 1308 : 	macro->e.macroinfo->srcfile = 0;

	mov	rax, QWORD PTR [rbx+104]
	mov	DWORD PTR [rax+24], edx

; 1309 : 	macro->sym.mac_vararg = FALSE;
; 1310 : 	macro->sym.isfunc = FALSE;

	and	BYTE PTR [rbx+52], 252			; 000000fcH

; 1311 : 
; 1312 : 	return(macro);

	mov	rax, rbx

; 1313 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ReuseMacro ENDP
_TEXT	ENDS
PUBLIC	ReleaseMacroData
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
macro$ = 8
ReleaseMacroData PROC NEAR

; 1319 :     int             i;
; 1320 :     struct srcline  *datacurr;
; 1321 :     struct srcline  *datanext;
; 1322 : 
; 1323 :     DebugMsg1(("ReleaseMacroData(%s) enter\n", macro->sym.name));
; 1324 :     /* free the parm list */
; 1325 :     for( i = 0 ; i < macro->e.macroinfo->parmcnt; i++ ) {

	mov	rax, QWORD PTR [rcx+104]

; 1326 :         /*
; 1327 :          for predefined macros, don't free the param labels,
; 1328 :          the items are stored in static memory
; 1329 :          */
; 1330 :         //if ( macro->sym.predefined == FALSE )
; 1331 :         //    LclFree( (void *)macro->e.macroinfo->parmlist[i].label );
; 1332 :         LclFree( macro->e.macroinfo->parmlist[i].deflt );
; 1333 :     }
; 1334 : 
; 1335 :     macro->e.macroinfo->parmcnt = 0;
; 1336 :     macro->e.macroinfo->localcnt = 0;
; 1337 : 
; 1338 :     if( macro->e.macroinfo->parmlist ) {

	xor	r8d, r8d
	mov	WORD PTR [rax], 0
	mov	rax, QWORD PTR [rcx+104]
	mov	WORD PTR [rax+2], 0
	mov	rax, QWORD PTR [rcx+104]
	cmp	QWORD PTR [rax+8], r8
	je	SHORT $LN3@ReleaseMac

; 1339 :         LclFree( macro->e.macroinfo->parmlist );
; 1340 :         macro->e.macroinfo->parmlist = NULL;

	mov	QWORD PTR [rax+8], r8
$LN3@ReleaseMac:

; 1341 :     }
; 1342 : 
; 1343 :     /* free the lines list */
; 1344 :     for( datacurr = macro->e.macroinfo->data ;datacurr; ) {

	mov	rdx, QWORD PTR [rcx+104]
	mov	rax, QWORD PTR [rdx+16]
	test	rax, rax
	je	SHORT $LN1@ReleaseMac
$LL2@ReleaseMac:

; 1345 :         datanext = datacurr->next;
; 1346 :         LclFree( datacurr );
; 1347 :         datacurr = datanext;

	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL2@ReleaseMac
$LN1@ReleaseMac:

; 1348 :     }
; 1349 :     macro->e.macroinfo->data = NULL;

	mov	QWORD PTR [rdx+16], r8

; 1350 :     macro->e.macroinfo->srcfile = 0;

	mov	rax, QWORD PTR [rcx+104]
	mov	DWORD PTR [rax+24], r8d

; 1351 :     macro->sym.mac_vararg = FALSE;

	and	BYTE PTR [rcx+52], 254			; 000000feH

; 1352 :     /* v2.07: the macro type should not change if a macro is
; 1353 :      * PURGEd.
; 1354 :      */
; 1355 :     //macro->sym.isfunc = FALSE;
; 1356 :     return;
; 1357 : }

	ret	0
ReleaseMacroData ENDP
_TEXT	ENDS
PUBLIC	MacroDir
EXTRN	LstWriteSrcLine:NEAR
EXTRN	Parse_Pass:DWORD
EXTRN	get_curr_srcfile:NEAR
EXTRN	sym_remove_table:NEAR
EXTRN	SymTables:BYTE
xdata	SEGMENT
$unwind$MacroDir DD 0b2601H
	DD	04c426H
	DD	097418H
	DD	086413H
	DD	07540eH
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$MacroDir DD @imagerel($LN27#)
	DD	@imagerel($LN27#+400)
	DD	@imagerel($unwind$MacroDir#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
MacroDir PROC NEAR

; 1364 : {

$LN27:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi

; 1365 :     char                *name;
; 1366 :     bool                store_data;
; 1367 :     struct dsym         *macro;
; 1368 : 
; 1369 :     name = tokenarray[0].string_ptr;

	mov	rdi, QWORD PTR [rdx+8]
	mov	ebp, ecx

; 1370 :     DebugMsg1(("MacroDir(%s) enter, i=%u\n", name, i ));
; 1371 : 
; 1372 :     macro = (struct dsym *)SymSearch( name );

	mov	rcx, rdi
	mov	QWORD PTR [rsp+32], r12
	mov	rsi, rdx
	call	SymFind

; 1373 :     if( macro == NULL ) {

	xor	r12d, r12d
	test	rax, rax
	mov	rbx, rax
	jne	SHORT $LN9@MacroDir

; 1374 :         macro = CreateMacro( name );

	mov	rcx, rdi
	call	SymCreate
	test	rax, rax
	mov	rbx, rax
	je	$LN7@MacroDir
	lea	ecx, QWORD PTR [r12+32]
	mov	DWORD PTR [rax+40], 9
	call	LclAlloc
	mov	QWORD PTR [rbx+104], rax
	mov	WORD PTR [rax], r12w
	mov	rax, QWORD PTR [rbx+104]
	mov	WORD PTR [rax+2], r12w
	mov	rax, QWORD PTR [rbx+104]
	mov	QWORD PTR [rax+8], r12
	mov	rax, QWORD PTR [rbx+104]
	mov	QWORD PTR [rax+16], r12
	mov	rax, QWORD PTR [rbx+104]
	mov	DWORD PTR [rax+24], r12d
	and	BYTE PTR [rbx+52], 252			; 000000fcH
	jmp	SHORT $LN7@MacroDir
$LN9@MacroDir:

; 1375 :     } else if( macro->sym.state != SYM_MACRO ) {

	mov	eax, DWORD PTR [rax+40]
	cmp	eax, 9
	je	SHORT $LN7@MacroDir

; 1376 :         if ( macro->sym.state != SYM_UNDEFINED ) {

	test	eax, eax
	je	SHORT $LN6@MacroDir

; 1377 :             return( EmitErr( SYMBOL_REDEFINITION, name ) );

	mov	rdx, rdi
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN10@MacroDir
$LN6@MacroDir:

; 1378 :         }
; 1379 :         /* the macro was used before it's defined. That's
; 1380 :          * a severe error. Nevertheless define the macro now,
; 1381 :          * error msg 'invalid symbol type in expression' will
; 1382 :          * be displayed in second pass when the (unexpanded)
; 1383 :          * macro name is found by the expression evaluator.
; 1384 :          */
; 1385 :         sym_remove_table( &SymTables[TAB_UNDEF], macro );

	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rbx
	call	sym_remove_table

; 1386 :         macro->sym.state = SYM_MACRO;
; 1387 :         macro->e.macroinfo = LclAlloc( sizeof( struct macro_info ) );

	mov	ecx, 32					; 00000020H
	mov	DWORD PTR [rbx+40], 9
	call	LclAlloc

; 1388 :         memset( macro->e.macroinfo, 0, sizeof( struct macro_info ) );

	xor	ecx, ecx
	mov	QWORD PTR [rbx+104], rax
	mov	QWORD PTR [rax], rcx
	mov	QWORD PTR [rax+8], rcx
	mov	QWORD PTR [rax+16], rcx
	mov	QWORD PTR [rax+24], rcx
$LN7@MacroDir:

; 1389 :     }
; 1390 :     macro->e.macroinfo->srcfile = get_curr_srcfile();

	call	get_curr_srcfile
	mov	rcx, QWORD PTR [rbx+104]
	mov	DWORD PTR [rcx+24], eax

; 1391 : 
; 1392 :     if ( ( Parse_Pass == PASS_1 ) || ( macro->sym.variable ) ) {

	cmp	DWORD PTR Parse_Pass, r12d
	je	SHORT $LN4@MacroDir
	test	BYTE PTR [rbx+48], 64			; 00000040H
	jne	SHORT $LN4@MacroDir

; 1407 :     } else
; 1408 :         store_data = FALSE;

	xor	dil, dil
	jmp	SHORT $LN2@MacroDir
$LN4@MacroDir:

; 1393 :         /* is the macro redefined? */
; 1394 :         if ( macro->e.macroinfo->data != NULL ) {

	mov	rax, QWORD PTR [rbx+104]
	cmp	QWORD PTR [rax+16], r12
	je	SHORT $LN3@MacroDir

; 1395 :             DebugMsg(("MacroDir(%s): macro already defined\n", name));
; 1396 : #if FASTMEM==0
; 1397 :             /* don't free memory of macro data lines if macro is in use */
; 1398 :             if ( MacroInUse( macro ) )
; 1399 :                 macro->e.macroinfo->data = NULL;
; 1400 : #endif
; 1401 :             ReleaseMacroData( macro );

	mov	WORD PTR [rax], r12w
	mov	rax, QWORD PTR [rbx+104]
	mov	WORD PTR [rax+2], r12w
	mov	rax, QWORD PTR [rbx+104]
	cmp	QWORD PTR [rax+8], r12
	je	SHORT $LN17@MacroDir
	mov	QWORD PTR [rax+8], r12
$LN17@MacroDir:
	mov	rcx, QWORD PTR [rbx+104]
	mov	rax, QWORD PTR [rcx+16]
	test	rax, rax
	je	SHORT $LN15@MacroDir
$LL16@MacroDir:
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL16@MacroDir
$LN15@MacroDir:
	mov	QWORD PTR [rcx+16], r12
	mov	rax, QWORD PTR [rbx+104]
	mov	DWORD PTR [rax+24], r12d

; 1402 :             /* v2.07: isfunc isn't reset anymore in ReleaseMacroData() */
; 1403 :             macro->sym.isfunc = FALSE;

	and	BYTE PTR [rbx+52], 252			; 000000fcH

; 1404 :             macro->sym.variable = TRUE;

	or	BYTE PTR [rbx+48], 64			; 00000040H
$LN3@MacroDir:

; 1405 :         }
; 1406 :         store_data = TRUE;

	mov	dil, 1
$LN2@MacroDir:

; 1409 : 
; 1410 :     if ( ModuleInfo.list )

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN1@MacroDir

; 1411 :         LstWriteSrcLine();

	call	LstWriteSrcLine
$LN1@MacroDir:

; 1412 : 
; 1413 :     return( StoreMacro( macro, ++i, tokenarray, store_data ) );

	lea	edx, DWORD PTR [rbp+1]
	movzx	r9d, dil
	mov	r8, rsi
	mov	rcx, rbx
	call	StoreMacro
$LN10@MacroDir:
	mov	r12, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 1414 : }

	add	rsp, 40					; 00000028H
	ret	0
MacroDir ENDP
_TEXT	ENDS
PUBLIC	PurgeDirective
xdata	SEGMENT
$unwind$PurgeDirective DD 091801H
	DD	097418H
	DD	086413H
	DD	07540eH
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$PurgeDirective DD @imagerel($LN30#)
	DD	@imagerel($LN30#+319)
	DD	@imagerel($unwind$PurgeDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 48
tokenarray$ = 56
PurgeDirective PROC NEAR

; 1425 : {

$LN30:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi

; 1426 :     struct asym *sym;
; 1427 : 
; 1428 :     i++; /* skip directive */

	lea	edi, DWORD PTR [rcx+1]
	mov	rsi, rdx
	movsxd	rbx, edi
	shl	rbx, 5
	add	rbx, rdx
	xor	ebp, ebp
	npad	6
$LL9@PurgeDirec:

; 1429 :     do {
; 1430 :         if ( tokenarray[i].token != T_ID ) {

	cmp	BYTE PTR [rbx], 8
	jne	$LN23@PurgeDirec

; 1432 :         }
; 1433 :         sym = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rbx+8]
	call	SymFind

; 1434 :         if ( sym == NULL ) {

	test	rax, rax
	mov	r11, rax
	je	$LN25@PurgeDirec

; 1436 :         }
; 1437 :         if ( sym->state != SYM_MACRO ) {

	cmp	DWORD PTR [rax+40], 9
	jne	$LN26@PurgeDirec

; 1439 :         }
; 1440 : #if TRUEPURGE
; 1441 :         sym->defined = FALSE;
; 1442 : #else
; 1443 : #if FASTMEM==0
; 1444 :         /* don't free memory of macro data lines if macro is in use */
; 1445 :         if ( MacroInUse( (struct dsym *)sym ) ) {
; 1446 :             DebugMsg1(("PurgeDirective(%s): macro is in use\n", sym->name ));
; 1447 :             ((struct dsym *)sym)->e.macroinfo->data = NULL;
; 1448 :         }
; 1449 : #endif
; 1450 :         ReleaseMacroData( (struct dsym *)sym );

	mov	rcx, QWORD PTR [rax+104]
	mov	WORD PTR [rcx], bp
	mov	rcx, QWORD PTR [rax+104]
	mov	WORD PTR [rcx+2], bp
	mov	rax, QWORD PTR [rax+104]
	cmp	QWORD PTR [rax+8], rbp
	je	SHORT $LN14@PurgeDirec
	mov	QWORD PTR [rax+8], rbp
$LN14@PurgeDirec:
	mov	rcx, QWORD PTR [r11+104]
	mov	rax, QWORD PTR [rcx+16]
	test	rax, rax
	je	SHORT $LN12@PurgeDirec
$LL13@PurgeDirec:
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL13@PurgeDirec
$LN12@PurgeDirec:
	mov	QWORD PTR [rcx+16], rbp
	mov	rax, QWORD PTR [r11+104]

; 1451 :         sym->variable = TRUE;
; 1452 :         sym->purged = TRUE;
; 1453 : #endif
; 1454 :         i++;

	inc	edi
	mov	DWORD PTR [rax+24], ebp
	and	BYTE PTR [r11+52], 254			; 000000feH
	or	BYTE PTR [r11+52], 16
	or	BYTE PTR [r11+48], 64			; 00000040H

; 1455 :         if ( i < Token_Count ) {

	mov	eax, DWORD PTR ModuleInfo+496
	cmp	edi, eax
	jge	SHORT $LN24@PurgeDirec

; 1456 :             if ( tokenarray[i].token != T_COMMA || tokenarray[i+1].token == T_FINAL ) {

	cmp	BYTE PTR [rbx+32], 44			; 0000002cH
	jne	SHORT $LN27@PurgeDirec

; 1458 :             }
; 1459 :             i++;
; 1460 :         }
; 1461 :     } while ( i < Token_Count );

	add	rbx, 64					; 00000040H
	cmp	BYTE PTR [rbx], bpl
	je	SHORT $LN27@PurgeDirec
	inc	edi
	cmp	edi, eax
	jl	$LL9@PurgeDirec
$LN24@PurgeDirec:

; 1462 : 
; 1463 :     return( NOT_ERROR );

	xor	eax, eax
$LN10@PurgeDirec:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 1464 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN23@PurgeDirec:

; 1431 :             return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, edi
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+8]
	call	EmitErr
	jmp	SHORT $LN10@PurgeDirec
$LN25@PurgeDirec:

; 1435 :             return( EmitErr( SYMBOL_NOT_DEFINED, tokenarray[i].string_ptr ) );

	movsxd	rdx, edi
	mov	ecx, 102				; 00000066H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+8]
	call	EmitErr
	jmp	SHORT $LN10@PurgeDirec
$LN26@PurgeDirec:

; 1438 :             return( EmitErr( EXPECTED, "macro name" ) );

	lea	rdx, OFFSET FLAT:$SG6137
	mov	ecx, 230				; 000000e6H
	call	EmitErr
	jmp	SHORT $LN10@PurgeDirec
$LN27@PurgeDirec:

; 1457 :                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	movsxd	rdx, edi
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+24]
	call	EmitErr
	jmp	SHORT $LN10@PurgeDirec
PurgeDirective ENDP
_TEXT	ENDS
EXTRN	getenv:NEAR
xdata	SEGMENT
$unwind$EnvironFunc DD 030d01H
	DD	09340dH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$EnvironFunc DD @imagerel(EnvironFunc#)
	DD	@imagerel(EnvironFunc#+37)
	DD	@imagerel($unwind$EnvironFunc#)
pdata	ENDS
xdata	SEGMENT
$chain$1$EnvironFunc DD 020521H
	DD	047405H
	DD	@imagerel(EnvironFunc#)
	DD	@imagerel(EnvironFunc#+37)
	DD	@imagerel($unwind$EnvironFunc#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$EnvironFunc DD @imagerel(EnvironFunc#+37)
	DD	@imagerel(EnvironFunc#+97)
	DD	@imagerel($chain$1$EnvironFunc#)
pdata	ENDS
xdata	SEGMENT
$chain$2$EnvironFunc DD 021H
	DD	@imagerel(EnvironFunc#)
	DD	@imagerel(EnvironFunc#+37)
	DD	@imagerel($unwind$EnvironFunc#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$EnvironFunc DD @imagerel(EnvironFunc#+97)
	DD	@imagerel(EnvironFunc#+109)
	DD	@imagerel($chain$2$EnvironFunc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
mi$ = 48
buffer$ = 56
tokenarray$ = 64
EnvironFunc PROC NEAR

; 1471 : {

	sub	rsp, 40					; 00000028H

; 1472 :     char *p = getenv( mi->parm_array[0] );

	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+72], rbx
	mov	rbx, rdx
	mov	rcx, QWORD PTR [rcx]
	call	getenv

; 1473 :     int i;
; 1474 : 
; 1475 :     buffer[0] = NULLC;

	mov	BYTE PTR [rbx], 0

; 1476 :     if ( p ) {

	test	rax, rax
	mov	rdx, rax
	je	SHORT $LN5@EnvironFun

; 1477 :         i = strlen( p );

	xor	eax, eax
	mov	QWORD PTR [rsp+32], rdi
	mov	rdi, rdx
	mov	rcx, -1
	repne scasb

; 1478 :         if ( i >= MAX_LINE_LEN )

	mov	eax, 1023				; 000003ffH
	not	rcx
	dec	rcx
	cmp	ecx, 1024				; 00000400H
	cmovge	ecx, eax

; 1479 :             i = MAX_LINE_LEN - 1;
; 1480 :         memcpy( buffer, p, i );

	movsxd	rdi, ecx
	mov	rcx, rbx
	mov	r8, rdi
	call	memcpy

; 1481 :         buffer[i] = NULLC;

	mov	BYTE PTR [rdi+rbx], 0
	mov	rdi, QWORD PTR [rsp+32]
$LN5@EnvironFun:

; 1482 :     }
; 1483 :     return( NOT_ERROR );

	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+72]

; 1484 : }

	add	rsp, 40					; 00000028H
	ret	0
EnvironFunc ENDP
_TEXT	ENDS
PUBLIC	MacroInit
EXTRN	StringInit:NEAR
EXTRN	MacroLevel:BYTE
EXTRN	MacroLocals:DWORD
xdata	SEGMENT
$unwind$MacroInit DD 030901H
	DD	097409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$MacroInit DD @imagerel($LN8#)
	DD	@imagerel($LN8#+32)
	DD	@imagerel($unwind$MacroInit#)
pdata	ENDS
xdata	SEGMENT
$chain$1$MacroInit DD 020521H
	DD	083405H
	DD	@imagerel($LN8#)
	DD	@imagerel($LN8#+32)
	DD	@imagerel($unwind$MacroInit#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$MacroInit DD @imagerel($LN8#+32)
	DD	@imagerel($LN8#+193)
	DD	@imagerel($chain$1$MacroInit#)
pdata	ENDS
xdata	SEGMENT
$chain$2$MacroInit DD 021H
	DD	@imagerel($LN8#)
	DD	@imagerel($LN8#+32)
	DD	@imagerel($unwind$MacroInit#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$MacroInit DD @imagerel($LN8#+193)
	DD	@imagerel($LN8#+205)
	DD	@imagerel($chain$2$MacroInit#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pass$ = 48
MacroInit PROC NEAR

; 1491 : {

$LN8:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+72], rdi

; 1492 :     struct dsym *macro;
; 1493 : 
; 1494 :     DebugMsg(( "MacroInit(%u)\n", pass ));
; 1495 : 
; 1496 :     MacroLevel = 0;
; 1497 :     MacroLocals = 0;

	xor	edi, edi

; 1498 :     if (pass == PASS_1) {

	test	ecx, ecx
	mov	DWORD PTR MacroLocals, edi
	mov	BYTE PTR MacroLevel, 0
	jne	$LN7@MacroInit
	mov	QWORD PTR [rsp+64], rbx

; 1499 : 
; 1500 :         StringInit();

	call	StringInit

; 1501 : 
; 1502 :         /* add @Environ() macro func */
; 1503 : 
; 1504 :         macro = CreateMacro( "@Environ" );

	lea	rcx, OFFSET FLAT:$SG6159
	call	SymCreate
	test	rax, rax
	mov	rbx, rax
	je	SHORT $LN4@MacroInit
	lea	ecx, QWORD PTR [rdi+32]
	mov	DWORD PTR [rax+40], 9
	call	LclAlloc
	mov	QWORD PTR [rbx+104], rax
	mov	WORD PTR [rax], di
	mov	rcx, QWORD PTR [rbx+104]
	mov	WORD PTR [rcx+2], di
	mov	rcx, QWORD PTR [rbx+104]
	mov	QWORD PTR [rcx+8], rdi
	mov	rax, QWORD PTR [rbx+104]
	mov	QWORD PTR [rax+16], rdi
	mov	rax, QWORD PTR [rbx+104]
	mov	DWORD PTR [rax+24], edi
	and	BYTE PTR [rbx+52], 252			; 000000fcH
$LN4@MacroInit:

; 1505 :         macro->sym.isdefined = TRUE;
; 1506 :         macro->sym.predefined = TRUE;

	or	BYTE PTR [rbx+48], 34			; 00000022H

; 1507 :         macro->sym.func_ptr = EnvironFunc;
; 1508 :         macro->sym.isfunc = TRUE;

	or	BYTE PTR [rbx+52], 2
	lea	rax, OFFSET FLAT:EnvironFunc
	mov	QWORD PTR [rbx+16], rax

; 1509 :         macro->e.macroinfo->parmcnt = 1;

	mov	rax, QWORD PTR [rbx+104]

; 1510 :         macro->e.macroinfo->parmlist = LclAlloc(sizeof(struct mparm_list));

	mov	ecx, 16
	mov	WORD PTR [rax], 1
	call	LclAlloc
	mov	rcx, QWORD PTR [rbx+104]
	mov	QWORD PTR [rcx+8], rax

; 1511 :         macro->e.macroinfo->parmlist->deflt = NULL;

	mov	rax, QWORD PTR [rbx+104]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx], rdi

; 1512 :         macro->e.macroinfo->parmlist->required = TRUE;

	mov	rax, QWORD PTR [rbx+104]
	mov	rbx, QWORD PTR [rsp+64]
	mov	rcx, QWORD PTR [rax+8]
	or	BYTE PTR [rcx+8], 1
$LN7@MacroInit:

; 1513 :     }
; 1514 :     return( NOT_ERROR );

	xor	eax, eax
	mov	rdi, QWORD PTR [rsp+72]

; 1515 : }

	add	rsp, 40					; 00000028H
	ret	0
MacroInit ENDP
_TEXT	ENDS
END
