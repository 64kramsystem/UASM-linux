; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
fcmanglers DQ	FLAT:ms32_decorate
	DQ	FLAT:ow_decorate
	DQ	FLAT:ms64_decorate
CONST	ENDS
_DATA	SEGMENT
$SG5305	DB	'_%s@%d', 00H
	ORG $+1
$SG5313	DB	'@%s@%u', 00H
_DATA	ENDS
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$VoidMangler DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$VoidMangler DD @imagerel(VoidMangler#)
	DD	@imagerel(VoidMangler#+43)
	DD	@imagerel($unwind$VoidMangler#)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\mangle.c
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
buffer$ = 56
VoidMangler PROC NEAR

; 73   : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 74   :     memcpy( buffer, sym->name, sym->name_size + 1 );

	movzx	eax, BYTE PTR [rcx+80]
	mov	r9, rdx
	mov	rdx, QWORD PTR [rcx+8]
	inc	eax
	mov	rbx, rcx
	mov	rcx, r9
	movsxd	r8, eax
	call	memcpy

; 75   :     return( sym->name_size );

	movzx	eax, BYTE PTR [rbx+80]

; 76   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
VoidMangler ENDP
_TEXT	ENDS
EXTRN	_strupr:NEAR
xdata	SEGMENT
$unwind$UCaseMangler DD 051b01H
	DD	09741bH
	DD	08340dH
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$UCaseMangler DD @imagerel(UCaseMangler#)
	DD	@imagerel(UCaseMangler#+68)
	DD	@imagerel($unwind$UCaseMangler#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
buffer$ = 56
UCaseMangler PROC NEAR

; 82   : {

	sub	rsp, 40					; 00000028H

; 83   :     memcpy( buffer, sym->name, sym->name_size + 1 );

	movzx	eax, BYTE PTR [rcx+80]
	mov	QWORD PTR [rsp+64], rbx
	mov	rbx, rdx
	mov	rdx, QWORD PTR [rcx+8]
	inc	eax
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx
	movsxd	r8, eax
	mov	rcx, rbx
	call	memcpy

; 84   :     _strupr( buffer );

	mov	rcx, rbx
	call	_strupr

; 85   :     return( sym->name_size );

	movzx	eax, BYTE PTR [rdi+80]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 86   : }

	add	rsp, 40					; 00000028H
	ret	0
UCaseMangler ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$UScoreMangler DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$UScoreMangler DD @imagerel(UScoreMangler#)
	DD	@imagerel(UScoreMangler#+46)
	DD	@imagerel($unwind$UScoreMangler#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
buffer$ = 56
UScoreMangler PROC NEAR

; 92   : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 93   :     buffer[0] = '_';

	mov	BYTE PTR [rdx], 95			; 0000005fH

; 94   :     memcpy( buffer+1, sym->name, sym->name_size + 1 );

	movzx	eax, BYTE PTR [rcx+80]
	mov	rbx, rcx
	lea	rcx, QWORD PTR [rdx+1]
	mov	rdx, QWORD PTR [rbx+8]
	inc	eax
	movsxd	r8, eax
	call	memcpy

; 95   :     return( sym->name_size + 1 );

	movzx	eax, BYTE PTR [rbx+80]
	inc	eax

; 96   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
UScoreMangler ENDP
_TEXT	ENDS
EXTRN	sprintf:NEAR
EXTRN	Options:BYTE
xdata	SEGMENT
$unwind$StdcallMangler DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$StdcallMangler DD @imagerel(StdcallMangler#)
	DD	@imagerel(StdcallMangler#+96)
	DD	@imagerel($unwind$StdcallMangler#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
buffer$ = 56
StdcallMangler PROC NEAR

; 103  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 104  :     const struct dsym *dir = (struct dsym *)sym;
; 105  : 
; 106  :     if( Options.stdcall_decoration == STDCALL_FULL && sym->isproc ) {

	cmp	BYTE PTR Options+126, 0
	mov	r10, rdx
	mov	rbx, rcx
	jne	SHORT $LN2@StdcallMan
	test	BYTE PTR [rcx+49], 8
	je	SHORT $LN2@StdcallMan

; 107  :         return( sprintf( buffer, "_%s@%d", sym->name, dir->e.procinfo->parasize ) );

	mov	rax, QWORD PTR [rcx+104]
	mov	r8, QWORD PTR [rcx+8]
	lea	rdx, OFFSET FLAT:$SG5305
	mov	r9d, DWORD PTR [rax+32]
	mov	rcx, r10

; 110  :     }
; 111  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	sprintf
$LN2@StdcallMan:

; 108  :     } else {
; 109  :         return( UScoreMangler( sym, buffer ) );

	mov	BYTE PTR [rdx], 95			; 0000005fH
	movzx	eax, BYTE PTR [rcx+80]
	lea	rcx, QWORD PTR [rdx+1]
	mov	rdx, QWORD PTR [rbx+8]
	inc	eax
	movsxd	r8, eax
	call	memcpy
	movzx	eax, BYTE PTR [rbx+80]
	inc	eax

; 110  :     }
; 111  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
StdcallMangler ENDP
; Function compile flags: /Ogtpy
sym$ = 8
buffer$ = 16
ms32_decorate PROC NEAR

; 118  :     return ( sprintf( buffer, "@%s@%u", sym->name, ((struct dsym *)sym)->e.procinfo->parasize ) );

	mov	rax, QWORD PTR [rcx+104]
	mov	r8, QWORD PTR [rcx+8]
	mov	r10, rdx
	mov	r9d, DWORD PTR [rax+32]
	lea	rdx, OFFSET FLAT:$SG5313
	mov	rcx, r10

; 119  : }

	jmp	sprintf
ms32_decorate ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$ow_decorate DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$ow_decorate DD @imagerel(ow_decorate#)
	DD	@imagerel(ow_decorate#+8)
	DD	@imagerel($unwind$ow_decorate#)
pdata	ENDS
xdata	SEGMENT
$chain$3$ow_decorate DD 084b21H
	DD	06344bH
	DD	09740fH
	DD	08640aH
	DD	075405H
	DD	@imagerel(ow_decorate#)
	DD	@imagerel(ow_decorate#+8)
	DD	@imagerel($unwind$ow_decorate#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$ow_decorate DD @imagerel(ow_decorate#+8)
	DD	@imagerel(ow_decorate#+140)
	DD	@imagerel($chain$3$ow_decorate#)
pdata	ENDS
xdata	SEGMENT
$chain$4$ow_decorate DD 040021H
	DD	086400H
	DD	063400H
	DD	@imagerel(ow_decorate#)
	DD	@imagerel(ow_decorate#+8)
	DD	@imagerel($unwind$ow_decorate#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$ow_decorate DD @imagerel(ow_decorate#+140)
	DD	@imagerel(ow_decorate#+169)
	DD	@imagerel($chain$4$ow_decorate#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
buffer$ = 56
ow_decorate PROC NEAR

; 137  : {

	sub	rsp, 40					; 00000028H

; 138  :     char                *name;
; 139  :     enum changes        changes = NORMAL;
; 140  : 
; 141  :     if( sym->isproc ) {

	test	BYTE PTR [rcx+49], 8
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi
	mov	rsi, rdx
	mov	rbp, rcx
	je	SHORT $LN8@ow_decorat

; 142  :         changes |= USCORE_BACK;

	mov	edi, 2

; 143  :     } else {

	jmp	SHORT $LN5@ow_decorat
$LN8@ow_decorat:

; 144  :         switch( sym->mem_type ) {

	mov	eax, DWORD PTR [rcx+44]
	cmp	eax, 129				; 00000081H
	jl	SHORT $LN3@ow_decorat
	cmp	eax, 130				; 00000082H
	jle	SHORT $LN4@ow_decorat
	cmp	eax, 192				; 000000c0H
	jne	SHORT $LN3@ow_decorat
$LN4@ow_decorat:

; 145  :         case MT_NEAR:
; 146  :         case MT_FAR:
; 147  :         case MT_EMPTY:
; 148  :             changes |= USCORE_BACK;

	mov	edi, 2

; 149  :             break;

	jmp	SHORT $LN5@ow_decorat
$LN3@ow_decorat:

; 150  :         default:
; 151  :             changes |= USCORE_FRONT;

	mov	edi, 1
$LN5@ow_decorat:

; 152  :         }
; 153  :     }
; 154  : 
; 155  :     name = buffer;
; 156  : 
; 157  :     if( changes & USCORE_FRONT )

	test	dil, 1
	mov	QWORD PTR [rsp+48], rbx
	mov	rbx, rdx
	je	SHORT $LN2@ow_decorat

; 158  :         *name++ = '_';

	mov	BYTE PTR [rdx], 95			; 0000005fH
	lea	rbx, QWORD PTR [rdx+1]
$LN2@ow_decorat:

; 159  :     memcpy( name, sym->name, sym->name_size + 1 );

	movzx	eax, BYTE PTR [rcx+80]
	mov	rdx, QWORD PTR [rcx+8]
	mov	rcx, rbx
	inc	eax
	movsxd	r8, eax
	call	memcpy

; 160  :     name += sym->name_size;

	movzx	r11d, BYTE PTR [rbp+80]
	mov	rbp, QWORD PTR [rsp+56]
	add	rbx, r11

; 161  :     if( changes & USCORE_BACK ) {

	test	dil, 2
	mov	rdi, QWORD PTR [rsp+72]
	je	SHORT $LN1@ow_decorat

; 162  :         *name++ = '_';

	mov	BYTE PTR [rbx], 95			; 0000005fH
	inc	rbx

; 163  :         *name = NULLC;

	mov	BYTE PTR [rbx], 0
$LN1@ow_decorat:

; 164  :     }
; 165  :     return( name - buffer );

	sub	rbx, rsi
	mov	rsi, QWORD PTR [rsp+64]
	mov	eax, ebx
	mov	rbx, QWORD PTR [rsp+48]

; 166  : }

	add	rsp, 40					; 00000028H
	ret	0
ow_decorate ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$ms64_decorate DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$ms64_decorate DD @imagerel(ms64_decorate#)
	DD	@imagerel(ms64_decorate#+43)
	DD	@imagerel($unwind$ms64_decorate#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
buffer$ = 56
ms64_decorate PROC NEAR

; 175  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 176  :     memcpy( buffer, sym->name, sym->name_size + 1 );

	movzx	eax, BYTE PTR [rcx+80]
	mov	r9, rdx
	mov	rdx, QWORD PTR [rcx+8]
	inc	eax
	mov	rbx, rcx
	mov	rcx, r9
	movsxd	r8, eax
	call	memcpy

; 177  :     return( sym->name_size );

	movzx	eax, BYTE PTR [rbx+80]

; 178  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
ms64_decorate ENDP
_TEXT	ENDS
PUBLIC	Mangle
EXTRN	ModuleInfo:BYTE
EXTRN	__ImageBase:BYTE
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
sym$ = 8
buffer$ = 16
Mangle	PROC NEAR

; 213  :     mangle_func mangler;
; 214  : 
; 215  :     switch( sym->langtype ) {

	mov	eax, DWORD PTR [rcx+84]
	mov	r8, rcx
	dec	eax
	cmp	eax, 6
	ja	SHORT $LN1@Mangle
	lea	rcx, OFFSET FLAT:__ImageBase
	cdqe
	mov	eax, DWORD PTR $LN11@Mangle[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN6@Mangle:

; 216  :     case LANG_C:
; 217  :         /* leading underscore for C? */
; 218  :         mangler = Options.no_cdecl_decoration ? VoidMangler : UScoreMangler;

	cmp	BYTE PTR Options+125, 0
	lea	rcx, OFFSET FLAT:VoidMangler
	lea	rax, OFFSET FLAT:UScoreMangler
	cmovne	rax, rcx

; 242  :         break;
; 243  :     }
; 244  : #if MANGLERSUPP
; 245  :     sym->mangler = mangler;
; 246  : #endif
; 247  :     return( mangler( sym, buffer ) );

	mov	rcx, r8

; 248  : }

	rex_jmp	rax
$LN4@Mangle:

; 219  :         break;
; 220  :     case LANG_SYSCALL:
; 221  :         mangler = VoidMangler;
; 222  :         break;
; 223  :     case LANG_STDCALL:
; 224  :         mangler = ( Options.stdcall_decoration == STDCALL_NONE ) ? VoidMangler : StdcallMangler;

	cmp	BYTE PTR Options+126, 1
	lea	rcx, OFFSET FLAT:VoidMangler
	lea	rax, OFFSET FLAT:StdcallMangler
	cmove	rax, rcx

; 242  :         break;
; 243  :     }
; 244  : #if MANGLERSUPP
; 245  :     sym->mangler = mangler;
; 246  : #endif
; 247  :     return( mangler( sym, buffer ) );

	mov	rcx, r8

; 248  : }

	rex_jmp	rax
$LN3@Mangle:

; 225  :         break;
; 226  :     case LANG_PASCAL:
; 227  :     case LANG_FORTRAN:
; 228  :     case LANG_BASIC:
; 229  :         mangler = UCaseMangler;

	lea	rax, OFFSET FLAT:UCaseMangler

; 242  :         break;
; 243  :     }
; 244  : #if MANGLERSUPP
; 245  :     sym->mangler = mangler;
; 246  : #endif
; 247  :     return( mangler( sym, buffer ) );

	mov	rcx, r8

; 248  : }

	rex_jmp	rax
$LN2@Mangle:

; 230  :         break;
; 231  :     case LANG_FASTCALL:          /* registers passing parameters */
; 232  :         mangler = fcmanglers[ModuleInfo.fctype];

	movsxd	rax, DWORD PTR ModuleInfo+376
	mov	rax, QWORD PTR fcmanglers[rcx+rax*8]

; 242  :         break;
; 243  :     }
; 244  : #if MANGLERSUPP
; 245  :     sym->mangler = mangler;
; 246  : #endif
; 247  :     return( mangler( sym, buffer ) );

	mov	rcx, r8

; 248  : }

	rex_jmp	rax
$LN1@Mangle:

; 233  :         break;
; 234  :     default: /* LANG_NONE */
; 235  : #if MANGLERSUPP
; 236  :         mangler = sym->mangler;
; 237  :         if( mangler == NULL )
; 238  :             mangler = GetMangler( Options.default_name_mangler );
; 239  :         if( mangler == NULL )
; 240  : #endif
; 241  :             mangler = VoidMangler;

	lea	rax, OFFSET FLAT:VoidMangler

; 242  :         break;
; 243  :     }
; 244  : #if MANGLERSUPP
; 245  :     sym->mangler = mangler;
; 246  : #endif
; 247  :     return( mangler( sym, buffer ) );

	mov	rcx, r8

; 248  : }

	rex_jmp	rax
	npad	1
$LN11@Mangle:
	DD	$LN6@Mangle
	DD	$LN1@Mangle
	DD	$LN4@Mangle
	DD	$LN3@Mangle
	DD	$LN3@Mangle
	DD	$LN3@Mangle
	DD	$LN2@Mangle
Mangle	ENDP
_TEXT	ENDS
PUBLIC	SetMangler
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
sym$ = 8
langtype$ = 16
mangle_type$ = 24
SetMangler PROC NEAR

; 256  : #if MANGLERSUPP
; 257  :     mangle_func mangler;
; 258  : #endif
; 259  : 
; 260  :     if( langtype != LANG_NONE )

	test	edx, edx
	je	SHORT $LN1@SetMangler

; 261  :         sym->langtype = langtype;

	mov	DWORD PTR [rcx+84], edx
$LN1@SetMangler:

; 262  : 
; 263  : #if MANGLERSUPP
; 264  :     mangler = GetMangler( mangle_type );
; 265  :     if( mangler == NULL ) {
; 266  :         /* nothing to do */
; 267  :     } else if( sym->mangler == NULL ) {
; 268  :         sym->mangler = mangler;
; 269  :     } else if( sym->mangler != mangler ) {
; 270  :         EmitErr( CONFLICTING_MANGLER, sym->name );
; 271  :     }
; 272  : #endif
; 273  : }

	ret	0
SetMangler ENDP
_TEXT	ENDS
END
