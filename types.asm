; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG6080	DB	01H DUP (?)
	ALIGN	4

$SG5938	DB	01H DUP (?)
	ALIGN	4

$SG5921	DB	01H DUP (?)
	ALIGN	4

$SG5845	DB	01H DUP (?)
	ALIGN	4

$SG5828	DB	01H DUP (?)
	ALIGN	4

$SG5742	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	CurrStruct:QWORD
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
_DATA	ENDS
CONST	SEGMENT
szStructure DB	'structure', 00H
	ORG $+2
szRecord DB	'record', 00H
	ORG $+5
szNonUnique DB	'NONUNIQUE', 00H
CONST	ENDS
PUBLIC	TypesInit
_BSS	SEGMENT
	ALIGN	8

redef_struct DQ	01H DUP (?)
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\types.c
_BSS	ENDS
_TEXT	SEGMENT
TypesInit PROC NEAR

; 49   :     CurrStruct   = NULL;

	xor	eax, eax
	mov	QWORD PTR CurrStruct, rax

; 50   :     redef_struct = NULL;

	mov	QWORD PTR redef_struct, rax

; 51   : }

	ret	0
TypesInit ENDP
_TEXT	ENDS
PUBLIC	CreateTypeSymbol
EXTRN	LclAlloc:NEAR
EXTRN	SymAlloc:NEAR
EXTRN	SymCreate:NEAR
EXTRN	sym_remove_table:NEAR
EXTRN	SymTables:BYTE
xdata	SEGMENT
$unwind$CreateTypeSymbol DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$CreateTypeSymbol DD @imagerel($LN10#)
	DD	@imagerel($LN10#+108)
	DD	@imagerel($unwind$CreateTypeSymbol#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
name$ = 56
global$ = 64
CreateTypeSymbol PROC NEAR

; 61   : {

$LN10:
	push	rbx
	sub	rsp, 32					; 00000020H

; 62   :     struct struct_info *si;
; 63   : 
; 64   :     if ( sym )

	test	rcx, rcx
	mov	rbx, rcx
	je	SHORT $LN3@CreateType

; 65   :         sym_remove_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );

	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:SymTables
	call	sym_remove_table

; 66   :     else

	jmp	SHORT $LN7@CreateType
$LN3@CreateType:

; 67   :         sym = ( global ? SymCreate( name ) : SymAlloc( name ) );

	test	r8b, r8b
	mov	rcx, rdx
	je	SHORT $LN6@CreateType
	call	SymCreate
	jmp	SHORT $LN9@CreateType
$LN6@CreateType:
	call	SymAlloc
$LN9@CreateType:
	mov	rbx, rax
$LN7@CreateType:

; 68   : 
; 69   :     if ( sym ) {

	test	rbx, rbx
	je	SHORT $LN8@CreateType

; 70   :         sym->state = SYM_TYPE;
; 71   :         sym->typekind = TYPE_NONE;
; 72   :         ((struct dsym *)sym)->e.structinfo = si = LclAlloc( sizeof( struct struct_info ) );

	mov	ecx, 32					; 00000020H
	mov	DWORD PTR [rbx+40], 7
	mov	BYTE PTR [rbx+74], 0
	call	LclAlloc

; 73   :         si->head = NULL;

	xor	ecx, ecx
	mov	QWORD PTR [rbx+104], rax
	mov	QWORD PTR [rax], rcx

; 74   :         si->tail = NULL;

	mov	QWORD PTR [rax+8], rcx

; 75   :         si->alignment = 0;

	mov	BYTE PTR [rax+28], cl

; 76   :         si->flags = 0;

	mov	BYTE PTR [rax+29], cl
$LN8@CreateType:

; 77   :     }
; 78   :     return( sym );

	mov	rax, rbx

; 79   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
CreateTypeSymbol ENDP
_TEXT	ENDS
PUBLIC	SearchNameInStruct
EXTRN	SymCmpFunc:QWORD
EXTRN	EmitError:NEAR
xdata	SEGMENT
$unwind$SearchNameInStruct DD 092201H
	DD	057422H
	DD	06641dH
	DD	075416H
	DD	083411H
	DD	08209H
xdata	ENDS
pdata	SEGMENT
$pdata$SearchNameInStruct DD @imagerel($LN20#)
	DD	@imagerel($LN20#+300)
	DD	@imagerel($unwind$SearchNameInStruct#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
tv68 = 80
tstruct$ = 80
name$ = 88
poffset$ = 96
level$ = 104
SearchNameInStruct PROC NEAR

; 85   : {

$LN20:
	mov	QWORD PTR [rsp+16], rdx
	sub	rsp, 72					; 00000048H
	mov	r10, rcx
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+56], rbp

; 86   :     int len = strlen( name );

	xor	eax, eax
	mov	QWORD PTR [rsp+48], rsi
	mov	QWORD PTR [rsp+40], rdi
	mov	rdi, rdx
	mov	rcx, -1

; 87   :     struct sfield *fl = ((struct dsym *)tstruct)->e.structinfo->head;
; 88   :     struct asym *sym = NULL;

	xor	ebx, ebx
	repne scasb
	mov	rax, QWORD PTR [r10+104]
	mov	ebp, r9d
	mov	rdi, QWORD PTR [rax]
	not	rcx
	mov	rsi, r8
	dec	rcx

; 89   : 
; 90   :     //if (ModuleInfo.oldstructs == TRUE) {
; 91   :     //    return( SymSearch( name ) );
; 92   :     //}
; 93   :     if ( level >= MAX_STRUCT_NESTING ) {

	cmp	r9d, 32					; 00000020H
	mov	r11, rdx
	mov	QWORD PTR tv68[rsp], rcx
	jl	SHORT $LN12@SearchName

; 94   :         EmitError( NESTING_LEVEL_TOO_DEEP );

	lea	ecx, QWORD PTR [rbx+100]
	call	EmitError

; 95   :         return( NULL );

	xor	eax, eax
	jmp	$LN13@SearchName
$LN12@SearchName:

; 96   :     }
; 97   :     level++;
; 98   :     for ( ; fl; fl = fl->next ) {

	test	rdi, rdi
	je	$LN9@SearchName
	npad	7
$LL11@SearchName:

; 99   :         /* recursion: if member has no name, check if it is a structure
; 100  :          and scan this structure's fieldlist then */
; 101  :         if ( *( fl->sym.name ) == NULLC ) {

	mov	rdx, QWORD PTR [rdi+8]
	cmp	BYTE PTR [rdx], 0
	jne	SHORT $LN8@SearchName

; 102  :             /* there are 2 cases: an anonymous inline struct ... */
; 103  :             if ( fl->sym.state == SYM_TYPE ) {

	cmp	DWORD PTR [rdi+40], 7
	jne	SHORT $LN7@SearchName

; 104  :                 if ( sym = SearchNameInStruct( &fl->sym, name, poffset, level ) ) {

	lea	r9d, DWORD PTR [rbp+1]
	mov	r8, rsi
	mov	rdx, r11
	mov	rcx, rdi
	call	SearchNameInStruct
	test	rax, rax
	mov	rbx, rax
	jne	SHORT $LN17@SearchName

; 105  :                     *poffset += fl->sym.offset;
; 106  :                     break;
; 107  :                 }

	mov	r11, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR tv68[rsp]
	jmp	SHORT $LN10@SearchName
$LN7@SearchName:

; 108  :             /* or an anonymous structured field */
; 109  :             } else if ( fl->sym.mem_type == MT_TYPE ) {

	cmp	DWORD PTR [rdi+44], 196			; 000000c4H
	jne	SHORT $LN10@SearchName

; 110  :                 if ( sym = SearchNameInStruct( fl->sym.type, name, poffset, level ) ) {

	mov	rcx, QWORD PTR [rdi+88]
	lea	r9d, DWORD PTR [rbp+1]
	mov	r8, rsi
	mov	rdx, r11
	call	SearchNameInStruct
	test	rax, rax
	mov	rbx, rax
	jne	SHORT $LN17@SearchName

; 113  :                 }
; 114  :             }

	mov	r11, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR tv68[rsp]
	jmp	SHORT $LN10@SearchName
$LN8@SearchName:

; 115  :         } else if ( len == fl->sym.name_size && SymCmpFunc( name, fl->sym.name, len ) == 0 ) {

	movzx	eax, BYTE PTR [rdi+80]
	cmp	ecx, eax
	jne	SHORT $LN10@SearchName
	movsxd	r8, ecx
	mov	rcx, r11
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	SHORT $LN18@SearchName
	mov	r11, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR tv68[rsp]
$LN10@SearchName:
	mov	rdi, QWORD PTR [rdi+104]
	test	rdi, rdi
	jne	$LL11@SearchName
	jmp	SHORT $LN9@SearchName
$LN17@SearchName:

; 111  :                     *poffset += fl->sym.offset;

	mov	eax, DWORD PTR [rdi+16]
	add	DWORD PTR [rsi], eax

; 112  :                     break;

	jmp	SHORT $LN9@SearchName
$LN18@SearchName:

; 116  :             DebugMsg(("SearchNameInStruct: '%s' found in struct %s\n", name, tstruct->name ));
; 117  :             sym = &fl->sym;

	mov	rbx, rdi
$LN9@SearchName:

; 118  :             break;
; 119  :         }
; 120  :     }
; 121  :     return( sym );

	mov	rax, rbx
$LN13@SearchName:
	mov	rdi, QWORD PTR [rsp+40]
	mov	rsi, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+64]

; 122  : }

	add	rsp, 72					; 00000048H
	ret	0
SearchNameInStruct ENDP
_TEXT	ENDS
EXTRN	ModuleInfo:BYTE
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
newstr$ = 8
oldstr$ = 16
AreStructsEqual PROC NEAR

; 129  :     struct sfield *fold = oldstr->e.structinfo->head;

	mov	rax, QWORD PTR [rdx+104]
	mov	r9, QWORD PTR [rax]

; 130  :     struct sfield *fnew = newstr->e.structinfo->head;

	mov	rax, QWORD PTR [rcx+104]
	mov	r8, QWORD PTR [rax]

; 131  : 
; 132  :     DebugMsg(("AreStructsEqual(%s) enter\n", oldstr->sym.name ));
; 133  : 
; 134  :     /* kind of structs must be identical */
; 135  :     if ( oldstr->sym.typekind != newstr->sym.typekind )

	movzx	eax, BYTE PTR [rcx+74]
	cmp	BYTE PTR [rdx+74], al
	je	SHORT $LN11@AreStructs
$LN15@AreStructs:

; 136  :         return( FALSE );

	xor	al, al

; 160  :         return( FALSE );
; 161  :     return( TRUE );
; 162  : }

	ret	0
$LN11@AreStructs:

; 137  : 
; 138  :     for ( ; fold; fold = fold->next, fnew = fnew->next ) {

	test	r9, r9
	je	SHORT $LN8@AreStructs
	mov	r11d, DWORD PTR ModuleInfo+408
$LL10@AreStructs:

; 139  :         if ( !fnew ) {

	test	r8, r8
	je	SHORT $LN15@AreStructs

; 140  :             DebugMsg(("AreStructsEqual: fields don't match\n"));
; 141  :             return( FALSE );
; 142  :         }
; 143  :         /* for global member names, don't check the name if it's "" */
; 144  :         if ( ModuleInfo.oldstructs && *fnew->sym.name == NULLC )

	bt	r11d, 9
	jae	SHORT $LN6@AreStructs
	mov	rax, QWORD PTR [r8+8]
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN4@AreStructs
$LN6@AreStructs:

; 145  :             ;
; 146  :         else if ( 0 != strcmp( fold->sym.name, fnew->sym.name ) ) {

	mov	rax, QWORD PTR [r9+8]
	mov	r10, QWORD PTR [r8+8]
	sub	r10, rax
	npad	10
$LL20@AreStructs:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r10]
	sub	edx, ecx
	jne	SHORT $LN21@AreStructs
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL20@AreStructs
$LN21@AreStructs:
	test	edx, edx
	jne	SHORT $LN15@AreStructs
$LN4@AreStructs:

; 147  :             DebugMsg(("AreStructsEqual: type name of field changed\n"));
; 148  :             return( FALSE );
; 149  :         }
; 150  :         if ( fold->sym.offset != fnew->sym.offset ) {

	mov	eax, DWORD PTR [r8+16]
	cmp	DWORD PTR [r9+16], eax
	jne	SHORT $LN15@AreStructs

; 151  :             DebugMsg(("AreStructsEqual: offset of field %s changed: %u - %u\n", fold->sym.name, fold->sym.offset, fnew->sym.offset));
; 152  :             return( FALSE );
; 153  :         }
; 154  :         if ( fold->sym.total_size != fnew->sym.total_size ) {

	mov	eax, DWORD PTR [r8+64]
	cmp	DWORD PTR [r9+64], eax
	jne	SHORT $LN15@AreStructs
	mov	r9, QWORD PTR [r9+104]
	mov	r8, QWORD PTR [r8+104]
	test	r9, r9
	jne	SHORT $LL10@AreStructs
$LN8@AreStructs:

; 155  :             DebugMsg(("AreStructsEqual: total_size of field changed\n"));
; 156  :             return( FALSE );
; 157  :         }
; 158  :     }
; 159  :     if ( fnew )

	test	r8, r8
	sete	al

; 160  :         return( FALSE );
; 161  :     return( TRUE );
; 162  : }

	ret	0
AreStructsEqual ENDP
_TEXT	ENDS
PUBLIC	StructDirective
EXTRN	Parse_Pass:DWORD
EXTRN	LstWrite:NEAR
EXTRN	SymFind:NEAR
EXTRN	EmitWarn:NEAR
EXTRN	_stricmp:NEAR
EXTRN	EvalOperand:NEAR
EXTRN	EmitErr:NEAR
xdata	SEGMENT
$unwind$StructDirective DD 062001H
	DD	014c420H
	DD	0157419H
	DD	017010eH
xdata	ENDS
pdata	SEGMENT
$pdata$StructDirective DD @imagerel($LN82#)
	DD	@imagerel($LN82#+75)
	DD	@imagerel($unwind$StructDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$4$StructDirective DD 062021H
	DD	0166420H
	DD	01b5410H
	DD	01a3408H
	DD	@imagerel($LN82#)
	DD	@imagerel($LN82#+75)
	DD	@imagerel($unwind$StructDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$StructDirective DD @imagerel($LN82#+75)
	DD	@imagerel($LN82#+150)
	DD	@imagerel($chain$4$StructDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$5$StructDirective DD 021H
	DD	@imagerel($LN82#)
	DD	@imagerel($LN82#+75)
	DD	@imagerel($unwind$StructDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$StructDirective DD @imagerel($LN82#+150)
	DD	@imagerel($LN82#+174)
	DD	@imagerel($chain$5$StructDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$6$StructDirective DD 060021H
	DD	0166400H
	DD	01b5400H
	DD	01a3400H
	DD	@imagerel($LN82#)
	DD	@imagerel($LN82#+75)
	DD	@imagerel($unwind$StructDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$StructDirective DD @imagerel($LN82#+174)
	DD	@imagerel($LN82#+1121)
	DD	@imagerel($chain$6$StructDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$7$StructDirective DD 021H
	DD	@imagerel($LN82#)
	DD	@imagerel($LN82#+75)
	DD	@imagerel($unwind$StructDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$StructDirective DD @imagerel($LN82#+1121)
	DD	@imagerel($LN82#+1145)
	DD	@imagerel($chain$7$StructDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
opndx$5747 = 48
i$ = 192
offset$ = 200
tokenarray$ = 200
StructDirective PROC NEAR

; 169  : {

$LN82:
	mov	DWORD PTR [rsp+8], ecx
	mov	rax, rsp
	sub	rsp, 184				; 000000b8H

; 170  :     char *name;
; 171  :     unsigned alignment;
; 172  :     uint_32 offset;
; 173  :     uint_8 typekind = ( tokenarray[i].tokval == T_UNION ? TYPE_UNION : TYPE_STRUCT );
; 174  :     //unsigned int size;
; 175  :     struct asym *sym;
; 176  :     struct dsym *dir;
; 177  : 
; 178  :     DebugMsg1(("StructDirective(%s) enter, i=%u, CurrStruct=%s\n", tokenarray[i].string_ptr, i, CurrStruct ? CurrStruct->sym.name : "NULL" ));
; 179  : 
; 180  :     /* top level structs/unions must have an identifier at pos 0.
; 181  :      * for embedded structs, the directive must be at pos 0,
; 182  :      * an identifier is optional then.
; 183  :      */
; 184  :     if (( CurrStruct == NULL && i != 1 ) ||
; 185  :         ( CurrStruct != NULL && i != 0 ) ) {

	mov	r10, QWORD PTR CurrStruct
	mov	QWORD PTR [rax-16], rdi
	mov	rdi, rdx
	mov	QWORD PTR [rax-24], r12
	movsxd	r8, ecx
	mov	rdx, r8
	shl	rdx, 5
	cmp	DWORD PTR [rdx+rdi+16], 424		; 000001a8H
	sete	r12b
	inc	r12b
	test	r10, r10
	jne	SHORT $LN74@StructDire
	cmp	r8d, 1
	jne	SHORT $LN47@StructDire
$LN48@StructDire:

; 188  :     }
; 189  : 
; 190  :     alignment = ( 1 << ModuleInfo.fieldalign );

	movzx	ecx, BYTE PTR ModuleInfo+397
	mov	QWORD PTR [rsp+208], rbx
	mov	QWORD PTR [rsp+216], rbp
	mov	ebx, 1

; 191  : 
; 192  :     i++; /* go past STRUCT/UNION */

	inc	r8d
	mov	QWORD PTR [rsp+176], rsi
	mov	ebp, ebx
	mov	DWORD PTR i$[rsp], r8d
	shl	ebp, cl

; 193  : 
; 194  :     if ( i == 1 ) { /* embedded struct? */

	cmp	r8d, ebx
	jne	SHORT $LN45@StructDire

; 195  :         /* scan for the optional name */
; 196  : #if ANYNAME
; 197  :         /* the name might be a reserved word!
; 198  :          * Masm won't allow those.
; 199  :          */
; 200  :         //if ( tokenarray[i].token != T_FINAL && is_valid_id_first_char(*(tokenarray[i].string_ptr) ) ) {
; 201  : #else
; 202  :         if ( tokenarray[i].token == T_ID ) {

	cmp	BYTE PTR [rdi+32], 8
	jne	SHORT $LN44@StructDire

; 203  : #endif
; 204  :             name = tokenarray[i].string_ptr;

	mov	rsi, QWORD PTR [rdi+40]

; 205  :             i++;

	mov	r8d, 2
	mov	DWORD PTR i$[rsp], r8d

; 206  :         } else {

	jmp	SHORT $LN42@StructDire
$LN74@StructDire:

; 170  :     char *name;
; 171  :     unsigned alignment;
; 172  :     uint_32 offset;
; 173  :     uint_8 typekind = ( tokenarray[i].tokval == T_UNION ? TYPE_UNION : TYPE_STRUCT );
; 174  :     //unsigned int size;
; 175  :     struct asym *sym;
; 176  :     struct dsym *dir;
; 177  : 
; 178  :     DebugMsg1(("StructDirective(%s) enter, i=%u, CurrStruct=%s\n", tokenarray[i].string_ptr, i, CurrStruct ? CurrStruct->sym.name : "NULL" ));
; 179  : 
; 180  :     /* top level structs/unions must have an identifier at pos 0.
; 181  :      * for embedded structs, the directive must be at pos 0,
; 182  :      * an identifier is optional then.
; 183  :      */
; 184  :     if (( CurrStruct == NULL && i != 1 ) ||
; 185  :         ( CurrStruct != NULL && i != 0 ) ) {

	test	ecx, ecx
	je	SHORT $LN48@StructDire
$LN47@StructDire:

; 186  :         DebugMsg(("StructDirective(%s): error: either currstruct or i must be 0\n", tokenarray[i].string_ptr ));
; 187  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+rdi+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	$LN49@StructDire
$LN44@StructDire:

; 207  :             name = "";

	lea	rsi, OFFSET FLAT:$SG5742

; 208  :         }
; 209  :     } else {

	jmp	SHORT $LN42@StructDire
$LN45@StructDire:

; 210  :         name = tokenarray[0].string_ptr;

	mov	rsi, QWORD PTR [rdi+8]
$LN42@StructDire:

; 211  :     }
; 212  : 
; 213  :     /* get an optional alignment argument: 1,2,4,8,16 or 32 */
; 214  :     if ( CurrStruct == NULL && tokenarray[i].token != T_FINAL ) {

	test	r10, r10
	jne	$LN25@StructDire
	movsxd	rax, r8d
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], r10b
	je	$LN25@StructDire

; 215  :         int power;
; 216  :         struct expr opndx;
; 217  :         /* get the optional alignment parameter.
; 218  :          * forward references aren't accepted, but EXPF_NOUNDEF isn't used here!
; 219  :          */
; 220  :         if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) != ERROR ) {

	mov	r8d, DWORD PTR ModuleInfo+496
	lea	r9, QWORD PTR opndx$5747[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rdi
	mov	BYTE PTR [rsp+32], r10b
	call	EvalOperand
	cmp	eax, -1
	je	SHORT $LN27@StructDire

; 221  :             /* an empty expression is accepted */
; 222  :             if ( opndx.kind == EXPR_EMPTY ) {

	mov	eax, DWORD PTR opndx$5747[rsp+60]
	cmp	eax, -2
	je	SHORT $LN27@StructDire

; 223  :                 ;
; 224  :             } else if ( opndx.kind != EXPR_CONST ) {

	test	eax, eax
	je	SHORT $LN37@StructDire

; 225  :                 /* v2.09: better error msg */
; 226  :                 if ( opndx.sym && opndx.sym->state == SYM_UNDEFINED )

	mov	rdx, QWORD PTR opndx$5747[rsp+80]
	test	rdx, rdx
	je	SHORT $LN36@StructDire
	cmp	DWORD PTR [rdx+40], 0
	jne	SHORT $LN36@StructDire

; 227  :                     EmitErr( SYMBOL_NOT_DEFINED, opndx.sym->name );

	mov	rdx, QWORD PTR [rdx+8]
	mov	ecx, 102				; 00000066H
	call	EmitErr

; 228  :                 else

	jmp	SHORT $LN27@StructDire
$LN36@StructDire:

; 229  :                     EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 230  :             } else if( opndx.value > MAX_STRUCT_ALIGN ) {

	jmp	SHORT $LN27@StructDire
$LN37@StructDire:
	mov	eax, DWORD PTR opndx$5747[rsp]
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN33@StructDire

; 231  :                 EmitError( STRUCT_ALIGN_TOO_HIGH );

	mov	ecx, 214				; 000000d6H
	call	EmitError

; 232  :             } else {

	jmp	SHORT $LN27@StructDire
$LN33@StructDire:

; 233  :                 for( power = 1; power < opndx.value; power <<= 1 );

	cmp	eax, ebx
	jle	SHORT $LN29@StructDire
$LL31@StructDire:
	add	ebx, ebx
	cmp	ebx, eax
	jl	SHORT $LL31@StructDire
$LN29@StructDire:

; 234  :                 if( power != opndx.value ) {

	cmp	ebx, eax
	je	SHORT $LN28@StructDire

; 235  :                     EmitErr( POWER_OF_2, opndx.value );

	mov	edx, eax
	mov	ecx, 129				; 00000081H
	call	EmitErr

; 236  :                 } else

	jmp	SHORT $LN27@StructDire
$LN28@StructDire:

; 237  :                     alignment = opndx.value;

	mov	ebp, eax
$LN27@StructDire:

; 238  :             }
; 239  :             DebugMsg1(("StructDirective(%s) alignment=%u\n", name, alignment));
; 240  :         }
; 241  :         /* there might also be the NONUNIQUE parameter */
; 242  :         if ( tokenarray[i].token == T_COMMA ) {

	movsxd	r8, DWORD PTR i$[rsp]
	mov	rax, r8
	shl	rax, 5
	cmp	BYTE PTR [rax+rdi], 44			; 0000002cH
	jne	SHORT $LN77@StructDire

; 243  :             i++;

	inc	r8d

; 244  :             if ( tokenarray[i].token == T_ID &&
; 245  :                 (_stricmp( tokenarray[i].string_ptr, szNonUnique ) == 0 ) ) {

	movsxd	rcx, r8d
	mov	DWORD PTR i$[rsp], r8d
	shl	rcx, 5
	cmp	BYTE PTR [rcx+rdi], 8
	jne	SHORT $LN75@StructDire
	mov	rcx, QWORD PTR [rcx+rdi+8]
	lea	rdx, OFFSET FLAT:szNonUnique
	call	_stricmp
	test	eax, eax
	jne	SHORT $LN76@StructDire

; 246  :                 /* currently NONUNIQUE is ignored */
; 247  :                 EmitWarn( 2, TOKEN_IGNORED, szNonUnique );

	lea	r8, OFFSET FLAT:szNonUnique
	lea	ecx, QWORD PTR [rax+2]
	mov	edx, 250				; 000000faH
	call	EmitWarn

; 248  :                 i++;

	mov	r8d, DWORD PTR i$[rsp]
	mov	r10, QWORD PTR CurrStruct
	inc	r8d
	mov	DWORD PTR i$[rsp], r8d
	jmp	SHORT $LN25@StructDire
$LN75@StructDire:
	mov	r10, QWORD PTR CurrStruct
	jmp	SHORT $LN25@StructDire
$LN76@StructDire:
	mov	r8d, DWORD PTR i$[rsp]
	mov	r10, QWORD PTR CurrStruct
	jmp	SHORT $LN25@StructDire
$LN77@StructDire:
	mov	r10, QWORD PTR CurrStruct
$LN25@StructDire:

; 249  :             }
; 250  :         }
; 251  :     }
; 252  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, r8d
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rdi], 0
	je	SHORT $LN24@StructDire

; 253  :         DebugMsg(("StructDirective(%s): error: unexpected token %u >%s<\n", tokenarray[i].token, tokenarray[i].tokpos ));
; 254  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );

	mov	rdx, QWORD PTR [rdx+rdi+24]
	mov	ecx, 209				; 000000d1H
	jmp	$LN81@StructDire
$LN24@StructDire:

; 255  :     }
; 256  : 
; 257  :     /* does struct have a name? */
; 258  :     if ( *name ) {

	xor	edi, edi
	cmp	BYTE PTR [rsi], dil
	je	SHORT $LN23@StructDire

; 259  :         if ( CurrStruct == NULL ) {

	test	r10, r10
	jne	SHORT $LN22@StructDire

; 260  :             /* the "top-level" struct is part of the global namespace */
; 261  :             sym = SymSearch( name );

	mov	rcx, rsi
	call	SymFind

; 262  :             DebugMsg1(("StructDirective: SymSearch (%s)=%X (curr struct=%X)\n", name, sym, CurrStruct ));
; 263  :         } else {

	mov	r10, QWORD PTR CurrStruct
	mov	rbx, rax
	jmp	SHORT $LN20@StructDire
$LN22@StructDire:

; 264  :             sym = SearchNameInStruct( (struct asym *)CurrStruct, name, &offset, 0 );

	lea	r8, QWORD PTR offset$[rsp]
	xor	r9d, r9d
	mov	rdx, rsi
	mov	rcx, r10
	call	SearchNameInStruct

; 265  :             DebugMsg1(("StructDirective(%s): SearchNameInStruc()=%X\n", name, sym));
; 266  :         }
; 267  :     } else {

	mov	r10, QWORD PTR CurrStruct
	mov	rbx, rax
	jmp	SHORT $LN20@StructDire
$LN23@StructDire:

; 268  :         sym = NULL;   /* anonymous struct */

	mov	rbx, rdi
$LN20@StructDire:

; 269  :     }
; 270  : 
; 271  :     if ( ModuleInfo.list ) {

	bt	DWORD PTR ModuleInfo+408, 12
	jae	SHORT $LN17@StructDire

; 272  :         if ( CurrStruct )

	test	r10, r10
	je	SHORT $LN18@StructDire

; 273  :             LstWrite( LSTTYPE_STRUCT, CurrStruct->sym.total_size, NULL );

	mov	edx, DWORD PTR [r10+64]
	xor	r8d, r8d
	lea	ecx, QWORD PTR [r8+6]
	call	LstWrite

; 274  :         else

	mov	r10, QWORD PTR CurrStruct
	jmp	SHORT $LN17@StructDire
$LN18@StructDire:

; 275  :             LstWrite( LSTTYPE_STRUCT, 0, NULL );

	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+6]
	call	LstWrite
	mov	r10, QWORD PTR CurrStruct
$LN17@StructDire:

; 276  :     }
; 277  : 
; 278  :     /* if pass is > 1, update struct stack + CurrStruct.offset and exit */
; 279  :     if ( Parse_Pass > PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, edi
	jbe	SHORT $LN16@StructDire

; 280  :         /* v2.04 changed. the previous implementation was insecure.
; 281  :          * See also change in data.c, behind CreateStructField().
; 282  :          */
; 283  :         if ( CurrStruct ) {

	test	r10, r10
	je	SHORT $LN15@StructDire

; 284  :             sym = CurrStruct->e.structinfo->tail->sym.type;

	mov	rcx, QWORD PTR [r10+104]
	mov	rax, QWORD PTR [rcx+8]
	mov	rbx, QWORD PTR [rax+88]

; 285  :             /**/myassert( sym );
; 286  :             CurrStruct->e.structinfo->tail = CurrStruct->e.structinfo->tail->next;

	mov	rax, QWORD PTR [rax+104]
	mov	QWORD PTR [rcx+8], rax
$LN15@StructDire:

; 287  :         }
; 288  :         /**/myassert( sym );
; 289  :         dir = (struct dsym *)sym;
; 290  :         dir->e.structinfo->tail = dir->e.structinfo->head;

	mov	rcx, QWORD PTR [rbx+104]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 291  :         sym->offset = 0;
; 292  :         sym->isdefined = TRUE;

	or	BYTE PTR [rbx+48], 2
	mov	DWORD PTR [rbx+16], edi

; 293  :         ((struct dsym *)sym)->next = CurrStruct;

	mov	rax, QWORD PTR CurrStruct
	mov	QWORD PTR [rbx+112], rax

; 294  :         CurrStruct = (struct dsym *)sym;

	mov	QWORD PTR CurrStruct, rbx

; 295  :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN80@StructDire
$LN16@StructDire:

; 296  :     }
; 297  : 
; 298  :     if( sym == NULL ) {

	test	rbx, rbx
	jne	$LN14@StructDire

; 299  : 
; 300  :         /* embedded or global STRUCT? */
; 301  :         if ( CurrStruct == NULL )

	test	r10, r10
	jne	SHORT $LN13@StructDire

; 302  :             sym = CreateTypeSymbol( NULL, name, TRUE );

	mov	rcx, rsi
	call	SymCreate
	test	rax, rax
	mov	rbx, rax
	je	$LN4@StructDire
	mov	ecx, 32					; 00000020H
	mov	DWORD PTR [rax+40], 7
	mov	BYTE PTR [rax+74], dil
	call	LclAlloc
	mov	QWORD PTR [rbx+104], rax
	mov	QWORD PTR [rax], rdi
	mov	QWORD PTR [rax+8], rdi
	mov	BYTE PTR [rax+28], dil
	mov	BYTE PTR [rax+29], dil

; 303  :         else {

	jmp	$LN4@StructDire
$LN13@StructDire:

; 304  :             /* an embedded struct is split in an anonymous STRUCT type
; 305  :              * and a struct field with/without name
; 306  :              */
; 307  :             sym = CreateTypeSymbol( NULL, name, FALSE );

	mov	rcx, rsi
	call	SymAlloc
	test	rax, rax
	mov	rbx, rax
	je	SHORT $LN58@StructDire
	mov	ecx, 32					; 00000020H
	mov	DWORD PTR [rax+40], 7
	mov	BYTE PTR [rax+74], dil
	call	LclAlloc
	mov	QWORD PTR [rbx+104], rax
	mov	QWORD PTR [rax], rdi
	mov	QWORD PTR [rax+8], rdi
	mov	BYTE PTR [rax+28], dil
	mov	BYTE PTR [rax+29], dil
$LN58@StructDire:

; 308  :             /* v2: don't create the struct field here. First the
; 309  :              * structure must be read in ( because of alignment issues
; 310  :              */
; 311  :             // sym = CreateStructField( name_loc, -1, MT_TYPE, dir, 0 );
; 312  : 
; 313  :             alignment = CurrStruct->e.structinfo->alignment;

	mov	rax, QWORD PTR CurrStruct
	mov	rcx, QWORD PTR [rax+104]
	movzx	ebp, BYTE PTR [rcx+28]

; 314  :         }

	jmp	SHORT $LN4@StructDire
$LN14@StructDire:

; 315  : 
; 316  :     } else if( sym->state == SYM_UNDEFINED ) {

	mov	eax, DWORD PTR [rbx+40]
	test	eax, eax
	jne	SHORT $LN10@StructDire

; 317  : 
; 318  :         /* forward reference */
; 319  :         CreateTypeSymbol( sym, NULL, CurrStruct == NULL );

	test	r10, r10
	mov	rcx, rbx
	sete	r8b
	xor	edx, edx
	call	CreateTypeSymbol
	jmp	SHORT $LN4@StructDire
$LN10@StructDire:

; 320  : 
; 321  :     } else if( sym->state == SYM_TYPE && CurrStruct == NULL ) {

	cmp	eax, 7
	jne	$LN8@StructDire
	test	r10, r10
	jne	$LN8@StructDire

; 322  : 
; 323  :         switch ( sym->typekind ) {

	mov	al, BYTE PTR [rbx+74]
	test	al, al
	je	SHORT $LN4@StructDire
	dec	al
	cmp	al, 1
	ja	$LN8@StructDire

; 324  :         case TYPE_STRUCT:
; 325  :         case TYPE_UNION:
; 326  :             /* if a struct is redefined as a union ( or vice versa )
; 327  :              * do accept the directive and just check if the redefinition
; 328  :              * is compatible (usually it isn't) */
; 329  :             redef_struct = (struct dsym *)sym;
; 330  :             sym = CreateTypeSymbol( NULL, name, FALSE );

	mov	rcx, rsi
	mov	QWORD PTR redef_struct, rbx
	call	SymAlloc
	test	rax, rax
	mov	rbx, rax
	je	SHORT $LN4@StructDire
	mov	ecx, 32					; 00000020H
	mov	DWORD PTR [rax+40], 7
	mov	BYTE PTR [rax+74], dil
	call	LclAlloc
	mov	QWORD PTR [rbx+104], rax
	mov	QWORD PTR [rax], rdi
	mov	QWORD PTR [rax+8], rdi
	mov	BYTE PTR [rax+28], dil
	mov	BYTE PTR [rax+29], dil
$LN4@StructDire:

; 340  :     }
; 341  : 
; 342  :     sym->offset = 0;
; 343  :     sym->typekind = typekind;
; 344  :     dir = (struct dsym *)sym;
; 345  :     dir->e.structinfo->alignment = alignment;

	mov	rax, QWORD PTR [rbx+104]
	mov	DWORD PTR [rbx+16], edi
	mov	BYTE PTR [rbx+74], r12b
	mov	BYTE PTR [rax+28], bpl

; 346  :     dir->e.structinfo->isOpen = TRUE;

	mov	rax, QWORD PTR [rbx+104]
	or	BYTE PTR [rax+29], 2

; 347  :     if ( CurrStruct )

	mov	rax, QWORD PTR CurrStruct
	test	rax, rax
	je	SHORT $LN1@StructDire

; 348  :         dir->e.structinfo->isInline = TRUE;

	mov	rax, QWORD PTR [rbx+104]
	or	BYTE PTR [rax+29], 1
	mov	rax, QWORD PTR CurrStruct
$LN1@StructDire:

; 349  : 
; 350  :     dir->next = CurrStruct;

	mov	QWORD PTR [rbx+112], rax

; 351  :     CurrStruct = dir;

	mov	QWORD PTR CurrStruct, rbx

; 352  : 
; 353  : #if 0 //def DEBUG_OUT
; 354  :     {
; 355  :         struct dsym *struc;
; 356  :         for ( struc = CurrStruct; struc; struc = struc->next ) {
; 357  :             DebugMsg(("StructDirective stack: %X, name=>%s<\n", struc, struc->sym.name ));
; 358  :         }
; 359  :     }
; 360  : #endif
; 361  : 
; 362  :     return( NOT_ERROR );

	xor	eax, eax
	jmp	SHORT $LN80@StructDire
$LN8@StructDire:

; 331  :             break;
; 332  :         case TYPE_NONE:  /* TYPE_NONE is forward reference */
; 333  :             break;
; 334  :         default:
; 335  :             return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );
; 336  :         }
; 337  : 
; 338  :     } else {
; 339  :         return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 143				; 0000008fH
$LN81@StructDire:
	call	EmitErr
$LN80@StructDire:
	mov	rbp, QWORD PTR [rsp+216]
	mov	rbx, QWORD PTR [rsp+208]
	mov	rsi, QWORD PTR [rsp+176]
$LN49@StructDire:
	mov	r12, QWORD PTR [rsp+160]
	mov	rdi, QWORD PTR [rsp+168]

; 363  : }

	add	rsp, 184				; 000000b8H
	ret	0
StructDirective ENDP
_TEXT	ENDS
xdata	SEGMENT
$unwind$CheckAnonymousStruct DD 091f01H
	DD	0b741fH
	DD	0a641aH
	DD	095412H
	DD	08340dH
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$CheckAnonymousStruct DD @imagerel(CheckAnonymousStruct#)
	DD	@imagerel(CheckAnonymousStruct#+375)
	DD	@imagerel($unwind$CheckAnonymousStruct#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
disp$ = 32
tv131 = 40
type$ = 64
CheckAnonymousStruct PROC NEAR

; 518  : {

	sub	rsp, 56					; 00000038H

; 519  :     uint_32 disp;
; 520  :     struct asym  *sym;
; 521  :     struct sfield *f;
; 522  : 
; 523  :     for ( f = type->e.structinfo->head; f; f = f->next ) {

	mov	rax, QWORD PTR [rcx+104]
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rbp
	mov	rbp, QWORD PTR [rax]
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+88], rdi
	test	rbp, rbp
	je	$LN8@CheckAnony
	npad	8
$LL10@CheckAnony:

; 524  :         if ( *f->sym.name ) {

	mov	rsi, QWORD PTR [rbp+8]
	cmp	BYTE PTR [rsi], 0
	je	$LN7@CheckAnony

; 525  :             sym = SearchNameInStruct((struct asym *)CurrStruct, f->sym.name, &disp, 0 );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rsi
	repne scasb
	mov	rax, QWORD PTR CurrStruct
	xor	ebx, ebx
	mov	rdx, QWORD PTR [rax+104]
	not	rcx
	mov	rdi, QWORD PTR [rdx]
	dec	rcx
	test	rdi, rdi
	mov	QWORD PTR tv131[rsp], rcx
	je	$LN9@CheckAnony
	npad	1
$LL23@CheckAnony:
	mov	rdx, QWORD PTR [rdi+8]
	cmp	BYTE PTR [rdx], 0
	jne	SHORT $LN20@CheckAnony
	cmp	DWORD PTR [rdi+40], 7
	jne	SHORT $LN19@CheckAnony
	lea	r8, QWORD PTR disp$[rsp]
	mov	r9d, 1
	mov	rdx, rsi
	mov	rcx, rdi
	call	SearchNameInStruct
	test	rax, rax
	mov	rbx, rax
	jne	SHORT $LN29@CheckAnony
	mov	rcx, QWORD PTR tv131[rsp]
	jmp	SHORT $LN22@CheckAnony
$LN19@CheckAnony:
	cmp	DWORD PTR [rdi+44], 196			; 000000c4H
	jne	SHORT $LN22@CheckAnony
	mov	rcx, QWORD PTR [rdi+88]
	lea	r8, QWORD PTR disp$[rsp]
	mov	r9d, 1
	mov	rdx, rsi
	call	SearchNameInStruct
	test	rax, rax
	mov	rbx, rax
	jne	SHORT $LN30@CheckAnony
	mov	rcx, QWORD PTR tv131[rsp]
	jmp	SHORT $LN22@CheckAnony
$LN20@CheckAnony:
	movzx	eax, BYTE PTR [rdi+80]
	cmp	ecx, eax
	jne	SHORT $LN22@CheckAnony
	movsxd	r8, ecx
	mov	rcx, rsi
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	SHORT $LN31@CheckAnony
	mov	rcx, QWORD PTR tv131[rsp]
$LN22@CheckAnony:
	mov	rdi, QWORD PTR [rdi+104]
	test	rdi, rdi
	jne	$LL23@CheckAnony

; 533  :             if ( CheckAnonymousStruct( stype ) == ERROR )

	jmp	SHORT $LN21@CheckAnony
$LN29@CheckAnony:

; 525  :             sym = SearchNameInStruct((struct asym *)CurrStruct, f->sym.name, &disp, 0 );

	mov	eax, DWORD PTR [rdi+16]
	add	DWORD PTR disp$[rsp], eax
	jmp	SHORT $LN21@CheckAnony
$LN30@CheckAnony:
	mov	eax, DWORD PTR [rdi+16]
	add	DWORD PTR disp$[rsp], eax
	jmp	SHORT $LN21@CheckAnony
$LN31@CheckAnony:
	mov	rbx, rdi
$LN21@CheckAnony:

; 526  :             if ( sym ) {

	test	rbx, rbx
	je	SHORT $LN9@CheckAnony

; 527  :                 return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	SHORT $LN11@CheckAnony
$LN7@CheckAnony:

; 528  :             }
; 529  :         } else if ( f->sym.type ) {

	mov	rcx, QWORD PTR [rbp+88]
	test	rcx, rcx
	je	SHORT $LN9@CheckAnony

; 530  :             struct dsym *stype = (struct dsym *)f->sym.type;
; 531  :             if ( stype->sym.typekind == TYPE_STRUCT ||
; 532  :                 stype->sym.typekind == TYPE_UNION ) {

	movzx	eax, BYTE PTR [rcx+74]
	cmp	al, 1
	je	SHORT $LN2@CheckAnony
	cmp	al, 2
	jne	SHORT $LN9@CheckAnony
$LN2@CheckAnony:

; 533  :             if ( CheckAnonymousStruct( stype ) == ERROR )

	call	CheckAnonymousStruct
	cmp	eax, -1
	je	SHORT $LN33@CheckAnony
$LN9@CheckAnony:

; 519  :     uint_32 disp;
; 520  :     struct asym  *sym;
; 521  :     struct sfield *f;
; 522  : 
; 523  :     for ( f = type->e.structinfo->head; f; f = f->next ) {

	mov	rbp, QWORD PTR [rbp+104]
	test	rbp, rbp
	jne	$LL10@CheckAnony
$LN8@CheckAnony:

; 535  :             }
; 536  :         }
; 537  :     }
; 538  :     return( NOT_ERROR );

	xor	eax, eax
$LN11@CheckAnony:
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 539  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN33@CheckAnony:

; 534  :                 return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN11@CheckAnony
CheckAnonymousStruct ENDP
_TEXT	ENDS
PUBLIC	CreateStructField
EXTRN	SymLookup:NEAR
EXTRN	myltoa:NEAR
EXTRN	memset:NEAR
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$CreateStructField DD 0123201H
	DD	09f432H
	DD	0ae42eH
	DD	0bd42aH
	DD	0cc426H
	DD	0d7422H
	DD	0e641eH
	DD	0f541aH
	DD	0103416H
	DD	011010fH
xdata	ENDS
pdata	SEGMENT
$pdata$CreateStructField DD @imagerel($LN63#)
	DD	@imagerel($LN63#+1129)
	DD	@imagerel($unwind$CreateStructField#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
si$1$ = 48
loc$ = 144
tokenarray$ = 152
disp$ = 160
name$ = 160
mem_type$ = 168
vartype$ = 176
size$ = 184
CreateStructField PROC NEAR

; 551  : {

$LN63:
	mov	DWORD PTR [rsp+32], r9d
	mov	rax, rsp
	sub	rsp, 136				; 00000088H

; 552  :     int_32 offset;
; 553  :     //int count;
; 554  :     int i;
; 555  :     int len;
; 556  :     uint_32 disp;
; 557  :     char *init;
; 558  :     struct struct_info *si;
; 559  :     struct sfield *f;
; 560  :     struct asym  *gsym;
; 561  : 
; 562  :     si = CurrStruct->e.structinfo;
; 563  :     offset = CurrStruct->sym.offset;
; 564  : 
; 565  :     DebugMsg1(("CreateStructField(%s): name=%s, curr ofs=%" I32_SPEC "u, vartype=%s, size=%" I32_SPEC "u\n",
; 566  :                CurrStruct->sym.name, name ? name : "<anonymous>", offset,
; 567  :                vartype ? vartype->name : "NULL", size ));
; 568  : 
; 569  :     if ( name ) {

	test	r8, r8
	mov	QWORD PTR [rax-8], rbx
	mov	QWORD PTR [rax-16], rbp
	mov	QWORD PTR [rax-24], rsi
	mov	QWORD PTR [rax-32], rdi
	mov	QWORD PTR [rax-40], r12
	mov	QWORD PTR [rax-48], r13
	mov	QWORD PTR [rax-56], r14
	mov	QWORD PTR [rax-64], r15
	mov	rax, QWORD PTR CurrStruct
	mov	r15, r8
	mov	r13, rdx
	mov	rbp, QWORD PTR [rax+104]
	mov	r12d, DWORD PTR [rax+16]
	mov	esi, ecx
	mov	QWORD PTR si$1$[rsp], rbp
	je	$LN33@CreateStru

; 570  :         struct asym  *sym;
; 571  :         len = strlen( name );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, r8
	repne scasb
	not	rcx
	dec	rcx

; 572  :         if( len > MAX_ID_LEN ) {

	cmp	ecx, 247				; 000000f7H
	mov	r14, rcx
	jle	SHORT $LN32@CreateStru

; 573  :             EmitError( IDENTIFIER_TOO_LONG );

	lea	ecx, QWORD PTR [rax+70]
	call	EmitError

; 574  :             return( NULL );

	xor	eax, eax
	jmp	$LN34@CreateStru
$LN32@CreateStru:

; 575  :         }
; 576  :         sym = SearchNameInStruct((struct asym *)CurrStruct, name, &disp, 0 );

	mov	rdi, QWORD PTR [rbp]
	xor	ebx, ebx
	test	rdi, rdi
	je	$LN30@CreateStru
$LL47@CreateStru:
	mov	rdx, QWORD PTR [rdi+8]
	cmp	BYTE PTR [rdx], 0
	jne	SHORT $LN44@CreateStru
	cmp	DWORD PTR [rdi+40], 7
	jne	SHORT $LN43@CreateStru
	lea	r8, QWORD PTR disp$[rsp]
	mov	r9d, 1
	mov	rdx, r15
	mov	rcx, rdi
	call	SearchNameInStruct
	test	rax, rax
	mov	rbx, rax
	je	SHORT $LN46@CreateStru
	mov	eax, DWORD PTR [rdi+16]
	add	DWORD PTR disp$[rsp], eax
	jmp	SHORT $LN45@CreateStru
$LN43@CreateStru:
	cmp	DWORD PTR [rdi+44], 196			; 000000c4H
	jne	SHORT $LN46@CreateStru
	mov	rcx, QWORD PTR [rdi+88]
	lea	r8, QWORD PTR disp$[rsp]
	mov	r9d, 1
	mov	rdx, r15
	call	SearchNameInStruct
	test	rax, rax
	mov	rbx, rax
	je	SHORT $LN46@CreateStru
	mov	eax, DWORD PTR [rdi+16]
	add	DWORD PTR disp$[rsp], eax
	jmp	SHORT $LN45@CreateStru
$LN44@CreateStru:
	movzx	eax, BYTE PTR [rdi+80]
	cmp	r14d, eax
	jne	SHORT $LN46@CreateStru
	movsxd	r8, r14d
	mov	rcx, r15
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	SHORT $LN57@CreateStru
$LN46@CreateStru:
	mov	rdi, QWORD PTR [rdi+104]
	test	rdi, rdi
	jne	$LL47@CreateStru
	jmp	SHORT $LN45@CreateStru
$LN57@CreateStru:
	mov	rbx, rdi
$LN45@CreateStru:

; 577  :         if ( sym ) {

	test	rbx, rbx
	je	SHORT $LN30@CreateStru

; 578  :             EmitErr( SYMBOL_ALREADY_DEFINED, sym->name );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 56					; 00000038H
	call	EmitErr

; 579  :             return( NULL );

	xor	eax, eax
	jmp	$LN34@CreateStru
$LN33@CreateStru:

; 580  :         }
; 581  :     } else {
; 582  :         /* v2.06: check fields of anonymous struct member */
; 583  :         if ( vartype &&
; 584  :             ( vartype->typekind == TYPE_STRUCT ||
; 585  :              vartype->typekind == TYPE_UNION ) ) {

	mov	rcx, QWORD PTR vartype$[rsp]
	test	rcx, rcx
	je	SHORT $LN29@CreateStru
	movzx	eax, BYTE PTR [rcx+74]
	cmp	al, 1
	je	SHORT $LN28@CreateStru
	cmp	al, 2
	jne	SHORT $LN29@CreateStru
$LN28@CreateStru:

; 586  :             CheckAnonymousStruct( (struct dsym *)vartype );

	call	CheckAnonymousStruct
$LN29@CreateStru:

; 587  :         }
; 588  :         name = "";

	lea	r15, OFFSET FLAT:$SG5921

; 589  :         len = 0;

	xor	r14d, r14d
$LN30@CreateStru:

; 590  :     }
; 591  : 
; 592  :     if ( loc != -1 ) {

	cmp	esi, -1
	je	$LN27@CreateStru

; 593  : 
; 594  :         //i = strlen( tokenarray[loc].string_ptr ) + 1;
; 595  :         //DebugMsg1(("CreateStructField(%s): type=>%s<\n", CurrStruct->sym.name, tokenarray[loc].string_ptr ));
; 596  :         //f->init_dir = LclAlloc( i );
; 597  :         //memcpy( f->init_dir, tokenarray[loc].string_ptr, i );
; 598  : 
; 599  :         /* now add the value to initialize the struct to */
; 600  : 
; 601  :         /* v2.03: the initializer value may contain assembly time
; 602  :          * variables ( $ inside structs is also one ). It's crucial that
; 603  :          * the variable's CURRENT value is used then.
; 604  :          * v2.08: modified. avoid usage of token->string_ptr,
; 605  :          * and prefer to use token->tokpos.
; 606  :          */
; 607  :         init = StringBufferEnd;

	mov	rbp, QWORD PTR ModuleInfo+488

; 608  :         for ( i = loc+1; tokenarray[i].token != T_FINAL; i++ ) {

	lea	eax, DWORD PTR [rsi+1]
	movsxd	rcx, eax
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+r13], 0
	je	$LN24@CreateStru
	shl	rcx, 5
	lea	rsi, QWORD PTR [rcx+r13]
	mov	rbx, rsi
$LL26@CreateStru:

; 609  :             if ( tokenarray[i].token == T_ID ) {

	cmp	BYTE PTR [rsi], 8
	jne	SHORT $LN22@CreateStru

; 610  :                 struct asym *sym2 = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rsi+8]
	call	SymFind

; 611  :                 if ( sym2 && sym2->variable ) {

	test	rax, rax
	mov	rdi, rax
	je	SHORT $LN22@CreateStru
	movzx	eax, BYTE PTR [rax+48]
	test	al, 64					; 00000040H
	je	SHORT $LN22@CreateStru

; 612  :                     if ( sym2->predefined && sym2->sfunc_ptr )

	test	al, 32					; 00000020H
	je	SHORT $LN21@CreateStru
	mov	rax, QWORD PTR [rdi+72]
	test	rax, rax
	je	SHORT $LN21@CreateStru

; 613  :                         sym2->sfunc_ptr( sym2, NULL );

	xor	edx, edx
	mov	rcx, rdi
	call	rax
$LN21@CreateStru:

; 614  :                     myltoa( sym2->uvalue, init, ModuleInfo.radix, sym2->value3264 < 0, TRUE );

	cmp	DWORD PTR [rdi+64], 0
	movzx	r8d, BYTE PTR ModuleInfo+396
	mov	ecx, DWORD PTR [rdi+16]
	setl	r9b
	mov	rdx, rbp
	mov	BYTE PTR [rsp+32], 1
	call	myltoa

; 615  :                     init += strlen( init );

	mov	rdi, rbp
	xor	eax, eax
	mov	rcx, -1
	repne scasb
	not	rcx
	dec	rcx
	add	rbp, rcx

; 616  :                     *init++= ' ';

	inc	rbp
	mov	BYTE PTR [rbp-1], 32			; 00000020H

; 617  :                     continue;

	jmp	SHORT $LN25@CreateStru
$LN22@CreateStru:

; 618  :                 }
; 619  :             }
; 620  :             memcpy( init, tokenarray[i].tokpos, tokenarray[i+1].tokpos - tokenarray[i].tokpos );

	mov	rdx, QWORD PTR [rsi+24]
	mov	r8, QWORD PTR [rbx+56]
	mov	rcx, rbp
	sub	r8, rdx
	call	memcpy

; 621  :             init += tokenarray[i+1].tokpos - tokenarray[i].tokpos;

	mov	rax, QWORD PTR [rbx+56]
	sub	rax, QWORD PTR [rsi+24]
	add	rbp, rax
$LN25@CreateStru:
	add	rbx, 32					; 00000020H
	mov	rsi, rbx
	cmp	BYTE PTR [rbx], 0
	jne	$LL26@CreateStru
$LN24@CreateStru:

; 622  :         }
; 623  :         *init = NULLC;

	mov	BYTE PTR [rbp], 0

; 624  :         f = LclAlloc( sizeof( struct sfield ) + ( init - StringBufferEnd ) );

	sub	rbp, QWORD PTR ModuleInfo+488
	lea	rcx, QWORD PTR [rbp+120]
	call	LclAlloc

; 625  :         //f->value = LclAlloc( init - StringBufferEnd + 1 );
; 626  :         memset( f, 0, sizeof( struct sfield ) );

	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+120]
	mov	rcx, rax
	mov	rbx, rax
	call	memset

; 627  :         strcpy( f->ivalue, StringBufferEnd );

	mov	rdx, QWORD PTR ModuleInfo+488
	lea	rax, QWORD PTR [rbx+112]
	npad	12
$LL36@CreateStru:
	movzx	ecx, BYTE PTR [rdx]
	inc	rax
	inc	rdx
	test	cl, cl
	mov	BYTE PTR [rax-1], cl
	jne	SHORT $LL36@CreateStru

; 628  :         DebugMsg1(("CreateStructField(%s): initializer=>%s<\n", CurrStruct->sym.name, f->ivalue ));
; 629  : 
; 630  :     } else {

	mov	rbp, QWORD PTR si$1$[rsp]
	jmp	SHORT $LN20@CreateStru
$LN27@CreateStru:

; 631  :         f = LclAlloc( sizeof( struct sfield ) );

	mov	ecx, 120				; 00000078H
	call	LclAlloc

; 632  :         memset( f, 0, sizeof( struct sfield ) );

	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+120]
	mov	rcx, rax
	mov	rbx, rax
	call	memset

; 633  :         DebugMsg1(("CreateStructField(%s): no initializer<\n", CurrStruct->sym.name ));
; 634  :         //f->init_dir = NULL;
; 635  :         f->ivalue[0] = NULLC;

	mov	BYTE PTR [rbx+112], 0
$LN20@CreateStru:

; 636  :     }
; 637  : 
; 638  :     /* create the struct field symbol */
; 639  : 
; 640  :     //sym = SymAlloc( name );
; 641  :     f->sym.name_size = len;
; 642  :     if ( len ) {

	test	r14d, r14d
	mov	BYTE PTR [rbx+80], r14b
	je	SHORT $LN19@CreateStru

; 643  :         f->sym.name = LclAlloc( len + 1 );

	lea	eax, DWORD PTR [r14+1]
	movsxd	rcx, eax
	call	LclAlloc

; 644  :         memcpy( f->sym.name, name, len );

	movsxd	rdi, r14d
	mov	rdx, r15
	mov	rcx, rax
	mov	r8, rdi
	mov	QWORD PTR [rbx+8], rax
	call	memcpy

; 645  :         f->sym.name[len] = NULLC;

	mov	rdx, QWORD PTR [rbx+8]
	mov	BYTE PTR [rdi+rdx], 0

; 646  :     } else

	jmp	SHORT $LN18@CreateStru
$LN19@CreateStru:

; 647  :         f->sym.name = "";

	lea	rax, OFFSET FLAT:$SG5938
	mov	QWORD PTR [rbx+8], rax
$LN18@CreateStru:

; 648  :     f->sym.state = SYM_STRUCT_FIELD;
; 649  :     f->sym.list = ModuleInfo.cref;
; 650  :     f->sym.isdefined = TRUE;
; 651  :     f->sym.mem_type = mem_type;

	mov	esi, DWORD PTR mem_type$[rsp]

; 652  :     f->sym.type = vartype;

	mov	rdi, QWORD PTR vartype$[rsp]
	mov	DWORD PTR [rbx+40], 6
	mov	eax, DWORD PTR ModuleInfo+408
	or	BYTE PTR [rbx+48], 2
	mov	DWORD PTR [rbx+44], esi
	shr	eax, 13
	mov	QWORD PTR [rbx+88], rdi

; 653  :     /* fields total/first_size, total/first_length are set in data_item() */
; 654  :     // sym->total_size = SizeFromMemtype( mem_type, ModuleInfo.Ofssize );
; 655  : 
; 656  :     f->next = NULL;

	mov	QWORD PTR [rbx+104], 0
	xor	al, BYTE PTR [rbx+49]
	and	al, 1
	xor	BYTE PTR [rbx+49], al

; 657  :     //f->sym = sym;
; 658  : 
; 659  :     if( si->head == NULL ) {

	cmp	QWORD PTR [rbp], 0
	jne	SHORT $LN17@CreateStru

; 660  :         si->head = si->tail = f;

	mov	QWORD PTR [rbp+8], rbx
	mov	QWORD PTR [rbp], rbx

; 661  :     } else {

	jmp	SHORT $LN16@CreateStru
$LN17@CreateStru:

; 662  :         si->tail->next = f;

	mov	rax, QWORD PTR [rbp+8]
	mov	QWORD PTR [rax+104], rbx

; 663  :         si->tail = f;

	mov	QWORD PTR [rbp+8], rbx
$LN16@CreateStru:

; 664  :     }
; 665  : 
; 666  : #if 1
; 667  :     /* v2.0: for STRUCTs, don't use the struct's size for alignment calculations,
; 668  :      * instead use the size of the "max" member!
; 669  :      */
; 670  :     if ( mem_type == MT_TYPE &&
; 671  :         ( vartype->typekind == TYPE_STRUCT ||
; 672  :          vartype->typekind == TYPE_UNION ) ) {

	cmp	esi, 196				; 000000c4H
	jne	SHORT $LN61@CreateStru
	movzx	eax, BYTE PTR [rdi+74]
	cmp	al, 1
	je	SHORT $LN14@CreateStru
	cmp	al, 2
	jne	SHORT $LN61@CreateStru
$LN14@CreateStru:

; 673  :         size = vartype->max_mbr_size;

	mov	ecx, DWORD PTR [rdi+56]
	jmp	SHORT $LN15@CreateStru
$LN61@CreateStru:
	mov	ecx, DWORD PTR size$[rsp]
$LN15@CreateStru:

; 674  :     }
; 675  : #endif
; 676  :     /* align the field if an alignment argument was given */
; 677  :     if ( si->alignment > 1 ) {

	movzx	eax, BYTE PTR [rbp+28]
	cmp	al, 1
	jbe	SHORT $LN62@CreateStru

; 678  :         //enum memtype mt;
; 679  :         //struct dsym *tdir;
; 680  :         DebugMsg1(("CreateStructField(%s): align=%u, size=%u, ofs=%u\n", CurrStruct->sym.name, si->alignment, size, offset ));
; 681  :         /* if it's the first field to add, use offset of the parent's current field */
; 682  : #if 0
; 683  :         /* v2: removed. An embedded struct is now added AFTER it has
; 684  :          * been parsed. */
; 685  :         if ( offset == 0 && CurrStruct->next ) {
; 686  :             struct dsym *parent = CurrStruct->next;
; 687  :             if ( si->alignment < size )
; 688  :                 parent->e.structinfo->tail->sym->offset =
; 689  :                     (parent->e.structinfo->tail->sym->offset + (si->alignment - 1)) & ( - si->alignment);
; 690  :             else if ( size )
; 691  :                 parent->e.structinfo->tail->sym->offset =
; 692  :                     (parent->e.structinfo->tail->sym->offset + (size - 1)) & (-size);
; 693  :         } else
; 694  : #endif
; 695  :         {
; 696  :             if ( si->alignment < size )

	movzx	eax, al
	cmp	eax, ecx
	jae	SHORT $LN12@CreateStru

; 697  :                 offset = (offset + (si->alignment - 1)) & ( - si->alignment);

	lea	r12d, DWORD PTR [rax+r12-1]
	neg	eax
	and	r12d, eax
	jmp	SHORT $LN10@CreateStru
$LN12@CreateStru:

; 698  :             else if ( size )

	test	ecx, ecx
	je	SHORT $LN10@CreateStru

; 699  :                 offset = (offset + (size - 1)) & (-size);

	mov	eax, ecx
	lea	r12d, DWORD PTR [r12+rcx-1]
	neg	eax
	and	r12d, eax
$LN10@CreateStru:

; 700  :         }
; 701  :         /* adjust the struct's current offset + size.
; 702  :          The field's size is added in UpdateStructSize()
; 703  :          */
; 704  :         if ( CurrStruct->sym.typekind != TYPE_UNION ) {

	mov	rax, QWORD PTR CurrStruct
	cmp	BYTE PTR [rax+74], 2
	je	SHORT $LN8@CreateStru

; 705  :             CurrStruct->sym.offset = offset;

	mov	DWORD PTR [rax+16], r12d

; 706  :             if ( offset > CurrStruct->sym.total_size )

	mov	rax, QWORD PTR CurrStruct
	cmp	r12d, DWORD PTR [rax+64]
	jbe	SHORT $LN8@CreateStru

; 707  :                 CurrStruct->sym.total_size = offset;

	mov	DWORD PTR [rax+64], r12d
	mov	rax, QWORD PTR CurrStruct
	jmp	SHORT $LN8@CreateStru
$LN62@CreateStru:
	mov	rax, QWORD PTR CurrStruct
$LN8@CreateStru:

; 708  :         }
; 709  :     }
; 710  :     /* v2.0: for padding, save the max member size */
; 711  :     if ( size > CurrStruct->sym.max_mbr_size ) {

	cmp	ecx, DWORD PTR [rax+56]
	jbe	SHORT $LN7@CreateStru

; 712  :         DebugMsg1(("CreateStructField(%s): max_mbr_size set to %u\n", CurrStruct->sym.name, size ));
; 713  :         CurrStruct->sym.max_mbr_size = size;

	mov	DWORD PTR [rax+56], ecx
$LN7@CreateStru:

; 714  :     }
; 715  :     f->sym.offset = offset;

	mov	DWORD PTR [rbx+16], r12d

; 716  : 
; 717  :     /* if -Zm is on, create a global symbol */
; 718  :     if ( ModuleInfo.oldstructs == TRUE && *name != NULLC ) {

	bt	DWORD PTR ModuleInfo+408, 9
	jae	SHORT $LN4@CreateStru
	cmp	BYTE PTR [r15], 0
	je	SHORT $LN4@CreateStru

; 719  :         DebugMsg(("CreateStructField(%s): Masm51 compat on, lookup %s in global symbol table\n", CurrStruct->sym.name, name ));
; 720  :         gsym  = SymLookup( name );

	mov	rcx, r15
	call	SymLookup
	mov	rdx, rax

; 721  :         /* v2.11: cannot fail */
; 722  :         //if ( gsym ) {
; 723  :             if ( gsym->state == SYM_UNDEFINED )

	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN5@CreateStru

; 724  :                 gsym->state = SYM_STRUCT_FIELD;

	mov	DWORD PTR [rax+40], 6
$LN5@CreateStru:

; 725  :             if ( gsym->state == SYM_STRUCT_FIELD ) {

	cmp	DWORD PTR [rax+40], 6
	jne	SHORT $LN4@CreateStru

; 726  :                 struct dsym *dir;
; 727  :                 gsym->mem_type = mem_type;

	mov	DWORD PTR [rax+44], esi

; 728  :                 gsym->type = vartype;

	mov	QWORD PTR [rax+88], rdi

; 729  :                 gsym->offset = offset; /* added v2.0 */

	mov	DWORD PTR [rax+16], r12d

; 730  :                 /* v2.01: must be the full offset.
; 731  :                  * (there's still a problem if alignment is > 1!)
; 732  :                  */
; 733  :                 for ( dir = CurrStruct->next; dir; dir = dir->next )

	mov	rax, QWORD PTR CurrStruct
	mov	rcx, QWORD PTR [rax+112]
	test	rcx, rcx
	je	SHORT $LN1@CreateStru
	npad	2
$LL3@CreateStru:

; 734  :                     gsym->offset += dir->sym.offset;

	mov	eax, DWORD PTR [rcx+16]
	add	DWORD PTR [rdx+16], eax
	mov	rcx, QWORD PTR [rcx+112]
	test	rcx, rcx
	jne	SHORT $LL3@CreateStru
$LN1@CreateStru:

; 735  :                 gsym->isdefined = TRUE;

	or	BYTE PTR [rdx+48], 2
$LN4@CreateStru:

; 736  :             }
; 737  :         //}
; 738  :     }
; 739  : 
; 740  :     return( &f->sym );

	mov	rax, rbx
$LN34@CreateStru:
	mov	r15, QWORD PTR [rsp+72]
	mov	r14, QWORD PTR [rsp+80]
	mov	r13, QWORD PTR [rsp+88]
	mov	r12, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+120]
	mov	rbx, QWORD PTR [rsp+128]

; 741  : }

	add	rsp, 136				; 00000088H
	ret	0
CreateStructField ENDP
_TEXT	ENDS
PUBLIC	AlignInStruct
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
value$ = 8
AlignInStruct PROC NEAR

; 749  :     if ( CurrStruct->sym.typekind != TYPE_UNION ) {

	mov	rdx, QWORD PTR CurrStruct
	cmp	BYTE PTR [rdx+74], 2
	je	SHORT $LN6@AlignInStr

; 750  :         int offset;
; 751  :         offset = CurrStruct->sym.offset;
; 752  :         offset = (offset + (value - 1)) & (-value);

	mov	eax, DWORD PTR [rdx+16]
	lea	r8d, DWORD PTR [rcx+rax-1]
	neg	ecx
	and	r8d, ecx

; 753  :         CurrStruct->sym.offset = offset;

	mov	DWORD PTR [rdx+16], r8d

; 754  :         if ( offset > CurrStruct->sym.total_size )

	mov	rax, QWORD PTR CurrStruct
	cmp	r8d, DWORD PTR [rax+64]
	jbe	SHORT $LN6@AlignInStr

; 755  :             CurrStruct->sym.total_size = offset;

	mov	DWORD PTR [rax+64], r8d
$LN6@AlignInStr:

; 756  :     }
; 757  :     return( NOT_ERROR );

	xor	eax, eax

; 758  : }

	ret	0
AlignInStruct ENDP
_TEXT	ENDS
PUBLIC	UpdateStructSize
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
sym$ = 8
UpdateStructSize PROC NEAR

; 765  :     if ( CurrStruct->sym.typekind == TYPE_UNION ) {

	mov	rdx, QWORD PTR CurrStruct

; 766  :         //if ( no_of_bytes > CurrStruct->sym.total_size )
; 767  :         //    CurrStruct->sym.total_size = no_of_bytes;
; 768  :         if ( sym->total_size > CurrStruct->sym.total_size )

	mov	eax, DWORD PTR [rcx+64]
	cmp	BYTE PTR [rdx+74], 2
	jne	SHORT $LN4@UpdateStru
	cmp	eax, DWORD PTR [rdx+64]
	jbe	SHORT $LN1@UpdateStru

; 769  :             CurrStruct->sym.total_size = sym->total_size;

	mov	DWORD PTR [rdx+64], eax

; 774  :     }
; 775  :     DebugMsg1(("UpdateStructSize(%s.%s): %s, curr mbr size=%u curr struc/union size=%u\n",
; 776  :                CurrStruct->sym.name,
; 777  :                sym->name,
; 778  :                CurrStruct->sym.typekind == TYPE_UNION ? "union" : "struct",
; 779  :                sym->total_size,
; 780  :                CurrStruct->sym.total_size));
; 781  :     return;
; 782  : }

	ret	0
$LN4@UpdateStru:

; 770  :     } else {
; 771  :         CurrStruct->sym.offset += sym->total_size;

	add	DWORD PTR [rdx+16], eax

; 772  :         if ( CurrStruct->sym.offset > (int_32)CurrStruct->sym.total_size )

	mov	rax, QWORD PTR CurrStruct
	mov	ecx, DWORD PTR [rax+16]
	cmp	ecx, DWORD PTR [rax+64]
	jle	SHORT $LN1@UpdateStru

; 773  :             CurrStruct->sym.total_size = CurrStruct->sym.offset;

	mov	DWORD PTR [rax+64], ecx
$LN1@UpdateStru:

; 774  :     }
; 775  :     DebugMsg1(("UpdateStructSize(%s.%s): %s, curr mbr size=%u curr struc/union size=%u\n",
; 776  :                CurrStruct->sym.name,
; 777  :                sym->name,
; 778  :                CurrStruct->sym.typekind == TYPE_UNION ? "union" : "struct",
; 779  :                sym->total_size,
; 780  :                CurrStruct->sym.total_size));
; 781  :     return;
; 782  : }

	ret	0
UpdateStructSize ENDP
_TEXT	ENDS
PUBLIC	SetStructCurrentOffset
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
offset$ = 8
SetStructCurrentOffset PROC NEAR

; 789  :     if ( CurrStruct->sym.typekind == TYPE_UNION ) {

	mov	rax, QWORD PTR CurrStruct
	mov	edx, ecx
	cmp	BYTE PTR [rax+74], 2
	jne	SHORT $LN2@SetStructC

; 790  :         return( EmitError( ORG_NOT_ALLOWED_IN_UNIONS ) );

	mov	ecx, 213				; 000000d5H

; 799  : }

	jmp	EmitError
$LN2@SetStructC:

; 791  :     }
; 792  :     CurrStruct->sym.offset = offset;

	mov	DWORD PTR [rax+16], ecx

; 793  :     /* if an ORG is inside the struct, it cannot be instanced anymore */
; 794  :     CurrStruct->e.structinfo->OrgInside = TRUE;

	mov	rax, QWORD PTR CurrStruct
	mov	rcx, QWORD PTR [rax+104]
	or	BYTE PTR [rcx+29], 4

; 795  :     if ( offset > (int_32)CurrStruct->sym.total_size )

	mov	rax, QWORD PTR CurrStruct
	cmp	edx, DWORD PTR [rax+64]
	jle	SHORT $LN1@SetStructC

; 796  :         CurrStruct->sym.total_size = offset;

	mov	DWORD PTR [rax+64], edx
$LN1@SetStructC:

; 797  : 
; 798  :     return( NOT_ERROR );

	xor	eax, eax

; 799  : }

	ret	0
SetStructCurrentOffset ENDP
_TEXT	ENDS
PUBLIC	GetQualifiedType
EXTRN	SizeFromMemtype:NEAR
EXTRN	SpecialTable:BYTE
xdata	SEGMENT
$unwind$GetQualifiedType DD 0f9f01H
	DD	05e49fH
	DD	04f42dH
	DD	06d425H
	DD	07c420H
	DD	09641bH
	DD	0a5413H
	DD	0f340eH
	DD	0a209H
xdata	ENDS
pdata	SEGMENT
$pdata$GetQualifiedType DD @imagerel($LN77#)
	DD	@imagerel($LN77#+339)
	DD	@imagerel($unwind$GetQualifiedType#)
pdata	ENDS
xdata	SEGMENT
$chain$7$GetQualifiedType DD 020521H
	DD	087405H
	DD	@imagerel($LN77#)
	DD	@imagerel($LN77#+339)
	DD	@imagerel($unwind$GetQualifiedType#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$GetQualifiedType DD @imagerel($LN77#+339)
	DD	@imagerel($LN77#+1168)
	DD	@imagerel($chain$7$GetQualifiedType#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
pi$ = 96
tokenarray$ = 104
pti$ = 112
GetQualifiedType PROC NEAR

; 812  : {

$LN77:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H
	mov	QWORD PTR [rsp+120], rbx
	mov	QWORD PTR [rsp+80], rbp

; 813  :     int             type;
; 814  :     int             tmp;
; 815  :     enum memtype    mem_type;
; 816  :     int             i = *pi;

	movsxd	rbp, DWORD PTR [rcx]
	mov	QWORD PTR [rsp+72], rsi
	mov	QWORD PTR [rsp+56], r12
	mov	QWORD PTR [rsp+48], r13

; 817  :     int             distance = FALSE;
; 818  :     struct asym     *sym;
; 819  : 
; 820  :     /* convert PROC token to a type qualifier */
; 821  :     for ( tmp = i; tokenarray[tmp].token != T_FINAL && tokenarray[tmp].token != T_COMMA; tmp++ )

	mov	rax, rbp
	mov	QWORD PTR [rsp+32], r15
	xor	r15d, r15d
	shl	rax, 5
	mov	r13d, r15d
	mov	rbx, r8
	cmp	BYTE PTR [rax+rdx], r13b
	mov	r12, rdx
	mov	rsi, rcx
	mov	r9, rbp
	je	SHORT $LN74@GetQualifi
	mov	rax, rbp
	shl	rax, 5
	add	rdx, rax
	mov	r8, rdx
$LL57@GetQualifi:
	movzx	eax, BYTE PTR [rdx]
	cmp	al, 44					; 0000002cH
	je	SHORT $LN74@GetQualifi

; 822  :         if ( tokenarray[tmp].token == T_DIRECTIVE && tokenarray[tmp].tokval == T_PROC ) {

	cmp	al, 3
	jne	SHORT $LN56@GetQualifi
	cmp	DWORD PTR [rdx+16], 433			; 000001b1H
	jne	SHORT $LN56@GetQualifi

; 823  :             tokenarray[tmp].token = T_STYPE;

	mov	BYTE PTR [rdx], 6

; 824  :             /* v2.06: avoid to use ST_PROC */
; 825  :             tokenarray[tmp].tokval = ( ( SIZE_CODEPTR & ( 1 << ModuleInfo.model ) ) ? T_FAR : T_NEAR );

	mov	ecx, DWORD PTR ModuleInfo+360
	mov	eax, 1
	shl	eax, cl
	test	al, 112					; 00000070H
	mov	eax, r15d
	setne	al
	add	eax, 221				; 000000ddH
	mov	DWORD PTR [rdx+16], eax
$LN56@GetQualifi:
	add	r8, 32					; 00000020H
	mov	rdx, r8
	cmp	BYTE PTR [r8], r13b
	jne	SHORT $LL57@GetQualifi
$LN74@GetQualifi:

; 826  :         }
; 827  :     /* with NEAR/FAR, there are several syntax variants allowed:
; 828  :      * 1. NEARxx | FARxx
; 829  :      * 2. PTR NEARxx | FARxx
; 830  :      * 3. NEARxx | FARxx PTR [<type>]
; 831  :      */
; 832  :     /* read qualified type */
; 833  :     for ( type = ERROR; tokenarray[i].token == T_STYPE || tokenarray[i].token == T_BINARY_OPERATOR; i++ ) {

	shl	r9, 5
	mov	QWORD PTR [rsp+40], r14
	lea	r8, OFFSET FLAT:SpecialTable
	add	r9, r12
	mov	r14d, -1
	npad	1
$LL53@GetQualifi:
	movzx	eax, BYTE PTR [r9]
	cmp	al, 6
	je	SHORT $LN73@GetQualifi
	cmp	al, 5
	jne	$LN71@GetQualifi

; 852  :                 break;
; 853  :             }
; 854  :         } else if ( tokenarray[i].tokval == T_PTR ) {

	cmp	DWORD PTR [r9+16], 258			; 00000102H
	jne	$LN71@GetQualifi

; 855  :             /* v2.06: avoid to use ST_PTR */
; 856  :             //type = ST_PTR;
; 857  :             type = EMPTY;
; 858  :             pti->is_ptr++;

	inc	BYTE PTR [rbx+20]
	inc	ebp
	mov	r14d, -2
	add	r9, 32					; 00000020H
	jmp	SHORT $LL53@GetQualifi
$LN73@GetQualifi:

; 834  :         if ( tokenarray[i].token == T_STYPE ) {
; 835  :             tmp = tokenarray[i].tokval;

	movsxd	rax, DWORD PTR [r9+16]

; 836  :             if ( type == ERROR )

	cmp	r14d, -1
	cmove	r14d, eax

; 837  :                 type = tmp;
; 838  :             mem_type = GetMemtypeSp( tmp );

	lea	rcx, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR [r8+rcx*4+10]

; 839  :             if ( mem_type == MT_FAR || mem_type == MT_NEAR ) {

	cmp	eax, 130				; 00000082H
	je	SHORT $LN46@GetQualifi
	cmp	eax, 129				; 00000081H
	jne	SHORT $LN47@GetQualifi
$LN46@GetQualifi:

; 840  :                 if ( distance == FALSE ) {

	test	r13d, r13d
	jne	SHORT $LN45@GetQualifi

; 841  :                     uint_8 Ofssize = GetSflagsSp( tmp );

	movzx	ecx, BYTE PTR [r8+rcx*4+4]

; 842  :                     pti->is_far = ( mem_type == MT_FAR );

	cmp	eax, 130				; 00000082H
	sete	al

; 843  :                     if ( Ofssize != USE_EMPTY )

	cmp	cl, 254					; 000000feH
	mov	BYTE PTR [rbx+21], al
	je	SHORT $LN44@GetQualifi

; 844  :                         pti->Ofssize = Ofssize;

	mov	BYTE PTR [rbx+22], cl
$LN44@GetQualifi:

; 826  :         }
; 827  :     /* with NEAR/FAR, there are several syntax variants allowed:
; 828  :      * 1. NEARxx | FARxx
; 829  :      * 2. PTR NEARxx | FARxx
; 830  :      * 3. NEARxx | FARxx PTR [<type>]
; 831  :      */
; 832  :     /* read qualified type */
; 833  :     for ( type = ERROR; tokenarray[i].token == T_STYPE || tokenarray[i].token == T_BINARY_OPERATOR; i++ ) {

	inc	ebp

; 845  :                     distance = TRUE;

	mov	r13d, 1
	add	r9, 32					; 00000020H
	jmp	SHORT $LL53@GetQualifi
$LN45@GetQualifi:

; 846  :                 } else if ( tokenarray[i-1].tokval != T_PTR )

	cmp	DWORD PTR [r9-16], 258			; 00000102H
	jne	SHORT $LN71@GetQualifi
	inc	ebp
	add	r9, 32					; 00000020H
	jmp	$LL53@GetQualifi
$LN47@GetQualifi:

; 847  :                     break;
; 848  :             } else {
; 849  :                 if ( pti->is_ptr )

	cmp	BYTE PTR [rbx+20], r15b
	je	SHORT $LN40@GetQualifi

; 850  :                     pti->ptr_memtype = mem_type;

	mov	DWORD PTR [rbx+24], eax
$LN40@GetQualifi:

; 851  :                 i++;

	inc	ebp
$LN71@GetQualifi:

; 859  :         } else
; 860  :             break;
; 861  :     }
; 862  : 
; 863  :     /* v2.06: don't use ST_PTR anymore! */
; 864  :     //if ( type == ST_PTR ) {
; 865  :     if ( type == EMPTY ) {

	cmp	r14d, -2
	mov	QWORD PTR [rsp+64], rdi
	jne	$LN35@GetQualifi

; 866  :         if ( tokenarray[i].token == T_ID && tokenarray[i-1].tokval == T_PTR ) {

	movsxd	rax, ebp
	mov	rsi, rax
	shl	rsi, 5
	cmp	BYTE PTR [rsi+r12], 8
	jne	$LN76@GetQualifi
	shl	rax, 5
	cmp	DWORD PTR [rax+r12-16], 258		; 00000102H
	jne	$LN75@GetQualifi

; 867  :             pti->symtype = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rsi+r12+8]
	call	SymFind

; 868  :             if ( pti->symtype == NULL || pti->symtype->state == SYM_UNDEFINED )

	test	rax, rax
	mov	rdi, rax
	mov	QWORD PTR [rbx+8], rax
	je	$LN33@GetQualifi
	mov	eax, DWORD PTR [rax+40]
	test	eax, eax
	je	$LN33@GetQualifi

; 870  :             else if ( pti->symtype->state != SYM_TYPE ) {

	cmp	eax, 7
	je	SHORT $LN31@GetQualifi

; 871  :                 return( EmitErr( INVALID_QUALIFIED_TYPE, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rsi+r12+8]
	lea	ecx, QWORD PTR [r14+87]
	call	EmitErr
	jmp	$LN58@GetQualifi
$LN31@GetQualifi:

; 872  :             } else {
; 873  :                 sym = pti->symtype;
; 874  :                 /* if it's a typedef, simplify the info */
; 875  :                 if ( sym->typekind == TYPE_TYPEDEF ) {

	cmp	BYTE PTR [rdi+74], 3
	jne	$LN20@GetQualifi

; 876  :                     pti->is_ptr     += sym->is_ptr;

	movzx	eax, BYTE PTR [rdi+53]
	add	BYTE PTR [rbx+20], al

; 877  :                     if ( sym->is_ptr == 0 ) {

	cmp	BYTE PTR [rdi+53], r15b
	jne	SHORT $LN28@GetQualifi

; 878  :                         /* v2.06b: alias types have MT_TYPE, dont use for ptr_memtype! */
; 879  :                         //pti->ptr_memtype = sym->mem_type;
; 880  :                         pti->ptr_memtype = ( sym->mem_type != MT_TYPE ? sym->mem_type : MT_EMPTY );

	mov	eax, DWORD PTR [rdi+44]
	mov	ecx, 192				; 000000c0H
	cmp	eax, 196				; 000000c4H
	cmovne	ecx, eax

; 881  :                         if ( distance == FALSE && pti->is_ptr == 1 &&
; 882  :                             ( sym->mem_type == MT_NEAR ||
; 883  :                              sym->mem_type == MT_PROC ||
; 884  :                              sym->mem_type == MT_FAR ) )

	test	r13d, r13d
	mov	DWORD PTR [rbx+24], ecx
	jne	SHORT $LN27@GetQualifi
	cmp	BYTE PTR [rbx+20], 1
	jne	SHORT $LN27@GetQualifi
	mov	eax, DWORD PTR [rdi+44]
	cmp	eax, 129				; 00000081H
	je	SHORT $LN26@GetQualifi
	cmp	eax, 128				; 00000080H
	je	SHORT $LN26@GetQualifi
	cmp	eax, 130				; 00000082H
	jne	SHORT $LN27@GetQualifi
$LN26@GetQualifi:

; 885  :                             pti->is_far = sym->isfar;

	movzx	eax, BYTE PTR [rdi+55]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR [rbx+21], al
$LN27@GetQualifi:

; 886  :                             if ( sym->Ofssize != USE_EMPTY )

	movzx	eax, BYTE PTR [rdi+52]
	cmp	al, 254					; 000000feH
	je	SHORT $LN22@GetQualifi

; 887  :                                 pti->Ofssize = sym->Ofssize;

	mov	BYTE PTR [rbx+22], al

; 888  :                     } else {

	jmp	SHORT $LN22@GetQualifi
$LN28@GetQualifi:

; 889  :                         pti->ptr_memtype = sym->ptr_memtype;
; 890  :                         if ( distance == FALSE && pti->is_ptr == 1 ) {

	test	r13d, r13d
	movzx	eax, BYTE PTR [rdi+54]
	mov	DWORD PTR [rbx+24], eax
	jne	SHORT $LN22@GetQualifi
	cmp	BYTE PTR [rbx+20], 1
	jne	SHORT $LN22@GetQualifi

; 891  :                             pti->is_far = sym->isfar;

	movzx	eax, BYTE PTR [rdi+55]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR [rbx+21], al

; 892  :                             if ( sym->Ofssize != USE_EMPTY )

	movzx	eax, BYTE PTR [rdi+52]
	cmp	al, 254					; 000000feH
	je	SHORT $LN22@GetQualifi

; 893  :                                 pti->Ofssize = sym->Ofssize;

	mov	BYTE PTR [rbx+22], al
$LN22@GetQualifi:

; 894  :                         }
; 895  :                     }
; 896  :                     if ( sym->mem_type == MT_TYPE )

	cmp	DWORD PTR [rdi+44], 196			; 000000c4H
	jne	SHORT $LN21@GetQualifi

; 897  :                         pti->symtype  = sym->type;

	mov	rax, QWORD PTR [rdi+88]

; 901  :                     }
; 902  :                 }
; 903  :             }
; 904  :             i++;
; 905  :         }
; 906  :     }
; 907  : 
; 908  :     if( type == ERROR ) {

	mov	rsi, QWORD PTR pi$[rsp]
	inc	ebp
	mov	QWORD PTR [rbx+8], rax
	lea	r8, OFFSET FLAT:SpecialTable
	jmp	$LN19@GetQualifi
$LN21@GetQualifi:

; 898  :                     else {
; 899  :                         DebugMsg1(("GetQualifiedType: memtype=%X, symtype set by target_type\n", sym->mem_type ));
; 900  :                         pti->symtype  = sym->target_type;

	mov	rax, QWORD PTR [rdi+56]

; 901  :                     }
; 902  :                 }
; 903  :             }
; 904  :             i++;
; 905  :         }
; 906  :     }
; 907  : 
; 908  :     if( type == ERROR ) {

	mov	rsi, QWORD PTR pi$[rsp]
	inc	ebp
	mov	QWORD PTR [rbx+8], rax
	lea	r8, OFFSET FLAT:SpecialTable
	jmp	$LN19@GetQualifi
$LN33@GetQualifi:

; 869  :                 pti->symtype = CreateTypeSymbol( pti->symtype, tokenarray[i].string_ptr, TRUE );

	test	rdi, rdi
	je	SHORT $LN64@GetQualifi
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rdi
	call	sym_remove_table
	jmp	SHORT $LN63@GetQualifi
$LN64@GetQualifi:
	mov	rcx, QWORD PTR [rsi+r12+8]
	call	SymCreate
	mov	rdi, rax
$LN63@GetQualifi:
	test	rdi, rdi
	je	SHORT $LN62@GetQualifi
	mov	ecx, 32					; 00000020H
	mov	DWORD PTR [rdi+40], 7
	mov	BYTE PTR [rdi+74], r15b
	call	LclAlloc
	mov	QWORD PTR [rdi+104], rax
	mov	QWORD PTR [rax], r15
	mov	QWORD PTR [rax+8], r15
	mov	BYTE PTR [rax+28], r15b
	mov	BYTE PTR [rax+29], r15b
$LN62@GetQualifi:
	mov	QWORD PTR [rbx+8], rdi
$LN20@GetQualifi:

; 901  :                     }
; 902  :                 }
; 903  :             }
; 904  :             i++;
; 905  :         }
; 906  :     }
; 907  : 
; 908  :     if( type == ERROR ) {

	mov	rsi, QWORD PTR pi$[rsp]
	inc	ebp
	lea	r8, OFFSET FLAT:SpecialTable
	jmp	$LN19@GetQualifi
$LN35@GetQualifi:
	cmp	r14d, -1
	jne	$LN19@GetQualifi

; 909  :         if ( tokenarray[i].token != T_ID ) {

	movsxd	rdi, ebp
	shl	rdi, 5
	movzx	eax, BYTE PTR [rdi+r12]
	cmp	al, 8
	je	SHORT $LN18@GetQualifi

; 910  :             if ( tokenarray[i].token == T_FINAL || tokenarray[i].token == T_COMMA )

	test	al, al
	je	SHORT $LN16@GetQualifi
	cmp	al, 44					; 0000002cH
	je	SHORT $LN16@GetQualifi

; 912  :             else {
; 913  :                 EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	mov	rdx, QWORD PTR [rdi+r12+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr

; 914  :                 i++;
; 915  :             }
; 916  :             return( ERROR );

	mov	eax, r14d
	jmp	$LN58@GetQualifi
$LN16@GetQualifi:

; 911  :                 EmitError( QUALIFIED_TYPE_EXPECTED );

	mov	ecx, 86					; 00000056H
	call	EmitError

; 914  :                 i++;
; 915  :             }
; 916  :             return( ERROR );

	mov	eax, -1
	jmp	$LN58@GetQualifi
$LN18@GetQualifi:

; 917  :         }
; 918  :         pti->symtype = SymSearch( tokenarray[i].string_ptr );

	mov	rcx, QWORD PTR [rdi+r12+8]
	call	SymFind

; 919  :         if( pti->symtype == NULL || pti->symtype->state != SYM_TYPE ) {

	test	rax, rax
	mov	r11, rax
	mov	QWORD PTR [rbx+8], rax
	je	$LN11@GetQualifi
	mov	eax, DWORD PTR [rax+40]
	cmp	eax, 7
	jne	SHORT $LN13@GetQualifi

; 926  :         }
; 927  :         sym = pti->symtype;
; 928  :         if ( sym->typekind == TYPE_TYPEDEF ) {

	cmp	BYTE PTR [r11+74], 3
	jne	SHORT $LN9@GetQualifi

; 929  :             pti->mem_type = sym->mem_type;

	mov	eax, DWORD PTR [r11+44]
	mov	DWORD PTR [rbx+16], eax

; 930  :             pti->is_far   = sym->isfar;

	movzx	eax, BYTE PTR [r11+55]
	shr	al, 4
	and	al, 1
	mov	BYTE PTR [rbx+21], al

; 931  :             pti->is_ptr   = sym->is_ptr;

	movzx	eax, BYTE PTR [r11+53]
	mov	BYTE PTR [rbx+20], al

; 932  :             pti->Ofssize  = sym->Ofssize;

	movzx	eax, BYTE PTR [r11+52]
	mov	BYTE PTR [rbx+22], al

; 933  :             pti->size     = sym->total_size;

	mov	eax, DWORD PTR [r11+64]
	mov	DWORD PTR [rbx], eax

; 934  :             pti->ptr_memtype = sym->ptr_memtype;

	movzx	eax, BYTE PTR [r11+54]
	mov	DWORD PTR [rbx+24], eax

; 935  :             if ( sym->mem_type == MT_TYPE )

	cmp	DWORD PTR [r11+44], 196			; 000000c4H
	jne	SHORT $LN8@GetQualifi

; 936  :                 pti->symtype  = sym->type;

	mov	rax, QWORD PTR [r11+88]

; 944  :         }
; 945  :         i++;

	inc	ebp
	mov	QWORD PTR [rbx+8], rax

; 946  :     } else {

	jmp	$LN1@GetQualifi
$LN8@GetQualifi:

; 937  :             else {
; 938  :                 DebugMsg1(("GetQualifiedType: memtype=%X, symtype set by target_type\n", sym->mem_type ));
; 939  :                 pti->symtype  = sym->target_type;

	mov	rax, QWORD PTR [r11+56]

; 944  :         }
; 945  :         i++;

	inc	ebp
	mov	QWORD PTR [rbx+8], rax

; 946  :     } else {

	jmp	$LN1@GetQualifi
$LN9@GetQualifi:

; 940  :             }
; 941  :         } else {
; 942  :             pti->mem_type = MT_TYPE;

	mov	DWORD PTR [rbx+16], 196			; 000000c4H

; 943  :             pti->size = sym->total_size;

	mov	eax, DWORD PTR [r11+64]

; 944  :         }
; 945  :         i++;

	inc	ebp
	mov	DWORD PTR [rbx], eax

; 946  :     } else {

	jmp	$LN1@GetQualifi
$LN13@GetQualifi:

; 920  :             DebugMsg(("GetQualifiedType: invalid type : %s\n", tokenarray[i].string_ptr ));
; 921  :             if ( pti->symtype == NULL || pti->symtype ->state == SYM_UNDEFINED )

	test	eax, eax
	je	SHORT $LN11@GetQualifi

; 923  :             else
; 924  :                 EmitErr( INVALID_QUALIFIED_TYPE, tokenarray[i].string_ptr );

	mov	rdx, QWORD PTR [rdi+r12+8]
	mov	ecx, 85					; 00000055H
	call	EmitErr

; 925  :             return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN58@GetQualifi
$LN11@GetQualifi:

; 922  :                 EmitErr( SYMBOL_NOT_DEFINED, tokenarray[i].string_ptr );

	mov	rdx, QWORD PTR [rdi+r12+8]
	mov	ecx, 102				; 00000066H
	call	EmitErr

; 925  :             return( ERROR );

	mov	eax, -1
	jmp	SHORT $LN58@GetQualifi
$LN75@GetQualifi:

; 901  :                     }
; 902  :                 }
; 903  :             }
; 904  :             i++;
; 905  :         }
; 906  :     }
; 907  : 
; 908  :     if( type == ERROR ) {

	mov	rsi, QWORD PTR pi$[rsp]
	jmp	SHORT $LN19@GetQualifi
$LN76@GetQualifi:
	mov	rsi, QWORD PTR pi$[rsp]
$LN19@GetQualifi:

; 947  :         if ( pti->is_ptr )

	cmp	BYTE PTR [rbx+20], r15b
	je	SHORT $LN4@GetQualifi

; 948  :             pti->mem_type = MT_PTR;

	mov	DWORD PTR [rbx+16], 195			; 000000c3H

; 949  :         else

	jmp	SHORT $LN3@GetQualifi
$LN4@GetQualifi:

; 950  :             pti->mem_type = GetMemtypeSp( type );

	movsxd	rax, r14d
	lea	rdx, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR [r8+rdx*4+10]
	mov	DWORD PTR [rbx+16], eax
$LN3@GetQualifi:

; 951  :         if ( pti->mem_type == MT_PTR )

	mov	ecx, DWORD PTR [rbx+16]
	cmp	ecx, 195				; 000000c3H
	jne	SHORT $LN2@GetQualifi

; 952  :             pti->size = SizeFromMemtype( pti->is_far ? MT_FAR : MT_NEAR, pti->Ofssize, NULL );

	cmp	BYTE PTR [rbx+21], r15b
	setne	r15b
	lea	ecx, DWORD PTR [r15+129]
$LN2@GetQualifi:

; 953  :         else
; 954  :             pti->size = SizeFromMemtype( pti->mem_type, pti->Ofssize, NULL );

	movzx	edx, BYTE PTR [rbx+22]
	xor	r8d, r8d
	call	SizeFromMemtype
	mov	DWORD PTR [rbx], eax
$LN1@GetQualifi:

; 955  :     }
; 956  :     *pi = i;

	mov	DWORD PTR [rsi], ebp

; 957  :     DebugMsg1(("GetQualifiedType: i=%u, memtype=%Xh, ptr=%u, far=%u, ofssize=%d, arbtype=%s:%X\n",
; 958  :                i, pti->mem_type, pti->is_ptr, pti->is_far, pti->Ofssize,
; 959  :                pti->symtype ? pti->symtype->name : "NULL",
; 960  :                pti->symtype ? pti->symtype->mem_type : 0 ));
; 961  :     return( NOT_ERROR );

	xor	eax, eax
$LN58@GetQualifi:
	mov	r15, QWORD PTR [rsp+32]
	mov	r14, QWORD PTR [rsp+40]
	mov	r13, QWORD PTR [rsp+48]
	mov	r12, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+120]

; 962  : }

	add	rsp, 88					; 00000058H
	ret	0
GetQualifiedType ENDP
_TEXT	ENDS
PUBLIC	TypedefDirective
EXTRN	ParseProc:NEAR
EXTRN	CreateProc:NEAR
xdata	SEGMENT
$unwind$TypedefDirective DD 0d4f01H
	DD	0be44fH
	DD	0cc44aH
	DD	0d7445H
	DD	0135440H
	DD	0123438H
	DD	0e640cH
	DD	0e204H
xdata	ENDS
pdata	SEGMENT
$pdata$TypedefDirective DD @imagerel($LN64#)
	DD	@imagerel($LN64#+476)
	DD	@imagerel($unwind$TypedefDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$6$TypedefDirective DD 020521H
	DD	0af405H
	DD	@imagerel($LN64#)
	DD	@imagerel($LN64#+476)
	DD	@imagerel($unwind$TypedefDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$TypedefDirective DD @imagerel($LN64#+476)
	DD	@imagerel($LN64#+872)
	DD	@imagerel($chain$6$TypedefDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$7$TypedefDirective DD 021H
	DD	@imagerel($LN64#)
	DD	@imagerel($LN64#+476)
	DD	@imagerel($unwind$TypedefDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$TypedefDirective DD @imagerel($LN64#+872)
	DD	@imagerel($LN64#+913)
	DD	@imagerel($chain$7$TypedefDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
ti$ = 48
i$ = 128
tokenarray$ = 136
TypedefDirective PROC NEAR

; 969  : {

$LN64:
	sub	rsp, 120				; 00000078H

; 970  :     struct asym         *sym;
; 971  :     char                *name;
; 972  :     struct qualified_type ti;
; 973  : 
; 974  :     DebugMsg1(("TypedefDirective(%d) enter\n", i));
; 975  : 
; 976  :     if( i != 1 ) {

	cmp	ecx, 1
	mov	QWORD PTR [rsp+112], rsi
	mov	rsi, rdx
	je	SHORT $LN33@TypedefDir

; 977  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rsi+8]
	mov	rsi, QWORD PTR [rsp+112]

; 1106 : }

	add	rsp, 120				; 00000078H
	jmp	EmitErr
$LN33@TypedefDir:
	mov	QWORD PTR [rsp+144], rbx
	mov	QWORD PTR [rsp+152], rbp
	mov	QWORD PTR [rsp+104], rdi
	mov	QWORD PTR [rsp+96], r12
	mov	QWORD PTR [rsp+88], r14

; 978  :     }
; 979  :     name = tokenarray[0].string_ptr;

	mov	r14, QWORD PTR [rdx+8]

; 980  : 
; 981  :     i++; /* go past TYPEDEF */

	mov	ebp, 2

; 982  : 
; 983  :     sym = SymSearch( name );

	mov	rcx, r14
	mov	DWORD PTR i$[rsp], ebp
	call	SymFind

; 984  :     if ( sym == NULL || sym->state == SYM_UNDEFINED ) {

	xor	r12d, r12d
	test	rax, rax
	mov	rbx, rax
	je	SHORT $LN31@TypedefDir
	mov	eax, DWORD PTR [rax+40]
	test	eax, eax
	je	SHORT $LN31@TypedefDir

; 988  : #if TYPEOPT
; 989  :         /* release the structinfo data extension */
; 990  :         LclFree( ((struct dsym *)sym)->e.structinfo );
; 991  :         ((struct dsym *)sym)->e.structinfo = NULL;
; 992  : #endif
; 993  :     } else {
; 994  :         /* MASM allows to have the TYPEDEF included multiple times */
; 995  :         /* but the types must be identical! */
; 996  :         if ( ( sym->state != SYM_TYPE ) ||
; 997  :             ( sym->typekind != TYPE_TYPEDEF &&
; 998  :              sym->typekind != TYPE_NONE ) ) {

	cmp	eax, 7
	jne	SHORT $LN27@TypedefDir
	movzx	eax, BYTE PTR [rbx+74]
	cmp	al, 3
	je	SHORT $LN30@TypedefDir
	test	al, al
	je	SHORT $LN30@TypedefDir
$LN27@TypedefDir:

; 999  :             return( EmitErr( SYMBOL_REDEFINITION, sym->name ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN60@TypedefDir
$LN31@TypedefDir:

; 985  :         sym = CreateTypeSymbol( sym, name, TRUE );

	test	rbx, rbx
	mov	rdi, rbx
	je	SHORT $LN44@TypedefDir
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rbx
	call	sym_remove_table
	jmp	SHORT $LN43@TypedefDir
$LN44@TypedefDir:
	mov	rcx, r14
	call	SymCreate
	mov	rdi, rax
$LN43@TypedefDir:
	test	rdi, rdi
	je	SHORT $LN42@TypedefDir
	mov	ecx, 32					; 00000020H
	mov	DWORD PTR [rdi+40], 7
	mov	BYTE PTR [rdi+74], r12b
	call	LclAlloc
	mov	QWORD PTR [rdi+104], rax
	mov	QWORD PTR [rax], r12
	mov	QWORD PTR [rax+8], r12
	mov	BYTE PTR [rax+28], r12b
	mov	BYTE PTR [rax+29], r12b
$LN42@TypedefDir:

; 986  :         if ( sym == NULL )

	test	rdi, rdi
	mov	rbx, rdi
	jne	SHORT $LN30@TypedefDir
$LN62@TypedefDir:

; 987  :             return( ERROR );

	mov	eax, -1
	jmp	$LN60@TypedefDir
$LN30@TypedefDir:

; 1000 :         }
; 1001 :     }
; 1002 : 
; 1003 :     sym->isdefined = TRUE;

	or	BYTE PTR [rbx+48], bpl

; 1004 :     if ( Parse_Pass > PASS_1 )

	cmp	DWORD PTR Parse_Pass, r12d

; 1005 :         return( NOT_ERROR );

	ja	$LN63@TypedefDir

; 1006 :     sym->typekind = TYPE_TYPEDEF;

	mov	BYTE PTR [rbx+74], 3

; 1007 : 
; 1008 :     /* PROTO is special */
; 1009 :     if ( tokenarray[i].token == T_DIRECTIVE && tokenarray[i].tokval == T_PROTO ) {

	movzx	eax, BYTE PTR [rsi+64]
	cmp	al, 3
	jne	$LN25@TypedefDir
	cmp	DWORD PTR [rsi+80], 432			; 000001b0H
	jne	$LN25@TypedefDir

; 1010 :         struct dsym *proto;  /* create a PROTOtype item without name */
; 1011 :         /* v2.04: added check if prototype is set already */
; 1012 :         if ( sym->target_type == NULL && sym->mem_type == MT_EMPTY ) {

	mov	rdi, QWORD PTR [rbx+56]
	test	rdi, rdi
	jne	SHORT $LN24@TypedefDir
	cmp	DWORD PTR [rbx+44], 192			; 000000c0H
	jne	SHORT $LN24@TypedefDir

; 1013 :             proto = (struct dsym *)CreateProc( NULL, "", SYM_TYPE );

	lea	r8d, QWORD PTR [rdi+7]
	lea	rdx, OFFSET FLAT:$SG6080
	xor	ecx, ecx
	call	CreateProc
	mov	rdi, rax
	jmp	SHORT $LN21@TypedefDir
$LN24@TypedefDir:

; 1014 :             DebugMsg1(("TypedefDirective PROTO, created new unnamed prototype %p\n", proto ));
; 1015 :         } else if ( sym->mem_type == MT_PROC ) {

	cmp	DWORD PTR [rbx+44], 128			; 00000080H
	jne	SHORT $LN22@TypedefDir
$LN21@TypedefDir:

; 1019 :         }
; 1020 :         i++;
; 1021 :         DebugMsg1(("TypedefDirective PROTO, call ParseProc(sym=%p i=%d, 0)\n", proto, i));
; 1022 :         if( ParseProc( proto, i, tokenarray, FALSE, ModuleInfo.langtype ) == ERROR )

	mov	eax, DWORD PTR ModuleInfo+364
	xor	r9d, r9d
	mov	r8, rsi
	lea	edx, QWORD PTR [r9+3]
	mov	rcx, rdi
	mov	DWORD PTR [rsp+32], eax
	call	ParseProc
	cmp	eax, -1

; 1023 :             return ( ERROR );

	je	$LN62@TypedefDir

; 1024 :         DebugMsg1(("TypedefDirective PROTO, ParseProc() returned status ok\n"));
; 1025 :         sym->mem_type = MT_PROC;

	mov	DWORD PTR [rbx+44], 128			; 00000080H

; 1026 :         /* v2.11: member isproc was set inside ParseProc() */
; 1027 :         //proto->sym.isproc = TRUE; /* v2.05: added */
; 1028 :         sym->Ofssize = proto->sym.seg_ofssize;

	movzx	ecx, BYTE PTR [rdi+55]
	and	cl, 3

; 1029 :         /* v2.03: set value of field total_size (previously was 0) */
; 1030 :         sym->total_size = ( 2 << sym->Ofssize );

	shl	ebp, cl
	mov	BYTE PTR [rbx+52], cl
	mov	DWORD PTR [rbx+64], ebp

; 1031 :         if( proto->sym.mem_type != MT_NEAR ) {

	cmp	DWORD PTR [rdi+44], 129			; 00000081H
	je	SHORT $LN19@TypedefDir

; 1032 :             sym->isfar = TRUE; /* v2.04: added */

	or	BYTE PTR [rbx+55], 16

; 1033 :             sym->total_size += 2;

	add	DWORD PTR [rbx+64], 2
$LN19@TypedefDir:

; 1034 :         }
; 1035 :         sym->target_type = (struct asym *)proto;

	mov	QWORD PTR [rbx+56], rdi
$LN63@TypedefDir:

; 1036 :         DebugMsg1(("TypedefDirective(%s) ok, mem_type=%Xh, ofssize=%u\n", sym->name, sym->mem_type, sym->Ofssize ));
; 1037 :         return( NOT_ERROR );

	xor	eax, eax
	jmp	$LN60@TypedefDir
$LN22@TypedefDir:

; 1016 :             proto = (struct dsym *)sym->target_type;
; 1017 :         } else {
; 1018 :             return( EmitErr( SYMBOL_TYPE_CONFLICT, sym->name ) );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 136				; 00000088H
	call	EmitErr
	jmp	$LN60@TypedefDir
$LN25@TypedefDir:

; 1038 :     }
; 1039 :     ti.size = 0;
; 1040 :     ti.is_ptr = 0;
; 1041 :     ti.is_far = FALSE;
; 1042 :     ti.mem_type = MT_EMPTY;
; 1043 :     ti.ptr_memtype = MT_EMPTY;
; 1044 :     ti.symtype = NULL;
; 1045 :     ti.Ofssize = ModuleInfo.Ofssize;

	movzx	r11d, BYTE PTR ModuleInfo+404
	xor	r8b, r8b

; 1046 : 
; 1047 :     /* "empty" type is ok for TYPEDEF */
; 1048 :     if ( tokenarray[i].token == T_FINAL || tokenarray[i].token == T_COMMA )

	test	al, al
	mov	edi, 192				; 000000c0H
	mov	QWORD PTR [rsp+80], r15
	mov	DWORD PTR ti$[rsp], r12d
	movzx	r15d, r11b
	mov	BYTE PTR ti$[rsp+22], r11b
	mov	BYTE PTR ti$[rsp+20], r12b
	mov	BYTE PTR ti$[rsp+21], r8b
	mov	DWORD PTR ti$[rsp+16], edi
	mov	DWORD PTR ti$[rsp+24], edi
	mov	r9, r12
	mov	QWORD PTR ti$[rsp+8], r12
	je	SHORT $LN17@TypedefDir
	cmp	al, 44					; 0000002cH
	je	SHORT $LN17@TypedefDir

; 1049 :         ;
; 1050 :     else if ( GetQualifiedType( &i, tokenarray, &ti ) == ERROR )

	lea	r8, QWORD PTR ti$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	rdx, rsi
	call	GetQualifiedType
	cmp	eax, -1
	jne	SHORT $LN53@TypedefDir

; 1051 :         return( ERROR );

	jmp	$LN61@TypedefDir
$LN53@TypedefDir:
	mov	ebp, DWORD PTR i$[rsp]
	mov	r15b, BYTE PTR ti$[rsp+22]
	movzx	r8d, BYTE PTR ti$[rsp+21]
	mov	edi, DWORD PTR ti$[rsp+16]
	mov	r9, QWORD PTR ti$[rsp+8]
	mov	r12d, DWORD PTR ti$[rsp]
	mov	r11b, BYTE PTR ModuleInfo+404
$LN17@TypedefDir:

; 1052 : 
; 1053 :     /* if type did exist already, check for type conflicts
; 1054 :      * v2.05: this code has been rewritten */
; 1055 :     if ( sym->mem_type != MT_EMPTY ) {

	cmp	DWORD PTR [rbx+44], 192			; 000000c0H
	je	SHORT $LN7@TypedefDir

; 1056 :         struct asym *to;
; 1057 :         struct asym *tn;
; 1058 :         char oo;
; 1059 :         char on;
; 1060 :         for( tn = ti.symtype; tn && tn->type; tn = tn->type );

	test	r9, r9
	mov	rdx, r9
	je	SHORT $LN54@TypedefDir
$LL13@TypedefDir:
	mov	rax, QWORD PTR [rdx+88]
	test	rax, rax
	je	SHORT $LN54@TypedefDir
	test	rax, rax
	mov	rdx, rax
	jne	SHORT $LL13@TypedefDir
$LN54@TypedefDir:

; 1061 :         to = ( sym->mem_type == MT_TYPE ) ? sym->type : sym->target_type;

	cmp	DWORD PTR [rbx+44], 196			; 000000c4H
	jne	SHORT $LN36@TypedefDir
	mov	rcx, QWORD PTR [rbx+88]
	jmp	SHORT $LN37@TypedefDir
$LN36@TypedefDir:
	mov	rcx, QWORD PTR [rbx+56]
$LN37@TypedefDir:

; 1062 :         for( ; to && to->type; to = to->type );

	test	rcx, rcx
	je	SHORT $LN55@TypedefDir
	npad	1
$LL10@TypedefDir:
	mov	rax, QWORD PTR [rcx+88]
	test	rax, rax
	je	SHORT $LN55@TypedefDir
	test	rax, rax
	mov	rcx, rax
	jne	SHORT $LL10@TypedefDir
$LN55@TypedefDir:

; 1063 :         oo = ( sym->Ofssize != USE_EMPTY ) ? sym->Ofssize : ModuleInfo.Ofssize;

	movzx	eax, BYTE PTR [rbx+52]
	movzx	r10d, r11b
	cmp	al, 254					; 000000feH
	cmovne	r10d, eax

; 1064 :         on = ( ti.Ofssize != USE_EMPTY ) ? ti.Ofssize : ModuleInfo.Ofssize;

	cmp	r15b, 254				; 000000feH
	movzx	eax, r15b
	cmovne	r11d, eax

; 1065 :         if ( ti.mem_type != sym->mem_type ||
; 1066 :             ( ti.mem_type == MT_TYPE && tn != to ) ||
; 1067 :             ( ti.mem_type == MT_PTR &&
; 1068 :              ( ti.is_far != sym->isfar ||
; 1069 :               on != oo ||
; 1070 :               ti.ptr_memtype != sym->ptr_memtype ||
; 1071 :               tn != to ))) {

	cmp	edi, DWORD PTR [rbx+44]
	jne	SHORT $LN4@TypedefDir
	cmp	edi, 196				; 000000c4H
	jne	SHORT $LN5@TypedefDir
	cmp	rdx, rcx
	jne	SHORT $LN4@TypedefDir
$LN7@TypedefDir:

; 1082 :         }
; 1083 :     }
; 1084 : 
; 1085 :     sym->mem_type = ti.mem_type;
; 1086 :     sym->Ofssize = ti.Ofssize;
; 1087 :     sym->total_size = ti.size;
; 1088 :     sym->is_ptr = ti.is_ptr;
; 1089 :     sym->isfar = ti.is_far;

	and	BYTE PTR [rbx+55], 239			; 000000efH
	movzx	eax, BYTE PTR ti$[rsp+20]
	and	r8b, 1
	shl	r8b, 4
	mov	DWORD PTR [rbx+44], edi
	mov	BYTE PTR [rbx+52], r15b
	or	BYTE PTR [rbx+55], r8b

; 1090 :     if ( ti.mem_type == MT_TYPE )

	cmp	edi, 196				; 000000c4H
	mov	DWORD PTR [rbx+64], r12d
	mov	BYTE PTR [rbx+53], al
	jne	SHORT $LN3@TypedefDir

; 1091 :         sym->type = ti.symtype;

	mov	QWORD PTR [rbx+88], r9

; 1092 :     else

	jmp	SHORT $LN2@TypedefDir
$LN5@TypedefDir:

; 1065 :         if ( ti.mem_type != sym->mem_type ||
; 1066 :             ( ti.mem_type == MT_TYPE && tn != to ) ||
; 1067 :             ( ti.mem_type == MT_PTR &&
; 1068 :              ( ti.is_far != sym->isfar ||
; 1069 :               on != oo ||
; 1070 :               ti.ptr_memtype != sym->ptr_memtype ||
; 1071 :               tn != to ))) {

	cmp	edi, 195				; 000000c3H
	jne	SHORT $LN7@TypedefDir
	movzx	eax, BYTE PTR [rbx+55]
	shr	al, 4
	and	al, 1
	cmp	r8b, al
	jne	SHORT $LN4@TypedefDir
	cmp	r11b, r10b
	jne	SHORT $LN4@TypedefDir
	movzx	eax, BYTE PTR [rbx+54]
	cmp	DWORD PTR ti$[rsp+24], eax
	jne	SHORT $LN4@TypedefDir
	cmp	rdx, rcx
	je	SHORT $LN7@TypedefDir
$LN4@TypedefDir:

; 1072 :             DebugMsg(("TypedefDirective: old-new memtype=%X-%X type=%X(%s)-%X(%s) far=%u-%u ind=%u-%u ofss=%d-%d pmt=%X-%X\n",
; 1073 :                       sym->mem_type, ti.mem_type,
; 1074 :                       (sym->mem_type == MT_TYPE) ? sym->type : sym->target_type,
; 1075 :                       (sym->mem_type == MT_TYPE) ? sym->type->name : sym->target_type ? sym->target_type->name : "",
; 1076 :                       ti.symtype, ti.symtype ? ti.symtype->name : "",
; 1077 :                       sym->isfar, ti.is_far,
; 1078 :                       sym->is_ptr, ti.is_ptr,
; 1079 :                       sym->Ofssize, ti.Ofssize,
; 1080 :                       sym->ptr_memtype, ti.ptr_memtype ));
; 1081 :             return( EmitErr( SYMBOL_TYPE_CONFLICT, name ) );

	mov	rdx, r14
	mov	ecx, 136				; 00000088H
	call	EmitErr
	jmp	SHORT $LN61@TypedefDir
$LN3@TypedefDir:

; 1093 :         sym->target_type = ti.symtype;

	mov	QWORD PTR [rbx+56], r9
$LN2@TypedefDir:

; 1094 :     sym->ptr_memtype = ti.ptr_memtype;

	movzx	eax, BYTE PTR ti$[rsp+24]

; 1095 :     DebugMsg1(("TypedefDirective(%s) ok, mem_type=MT_TYPE, size=%" I32_SPEC "u, type=%p type.memtype=%X\n",
; 1096 :                sym->name, sym->total_size, sym->type, ti.symtype ? ti.symtype->mem_type : 0 ));
; 1097 : 
; 1098 :     DebugMsg1(("TypedefDirective(%s) ok, mem_type=%Xh, size=%u, indirection=%u target=%p\n", sym->name, sym->mem_type, ti.size, ti.is_ptr, ti.symtype ));
; 1099 : 
; 1100 :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, ebp
	shl	rdx, 5
	mov	BYTE PTR [rbx+54], al
	cmp	BYTE PTR [rdx+rsi], 0
	je	SHORT $LN1@TypedefDir

; 1101 :         DebugMsg(("TypedefDirective: unexpected token %u, idx=%u\n", tokenarray[i].token, i));
; 1102 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+rsi+8]
	mov	ecx, 209				; 000000d1H
	call	EmitErr
	jmp	SHORT $LN61@TypedefDir
$LN1@TypedefDir:

; 1103 :     }
; 1104 : 
; 1105 :     return( NOT_ERROR );

	xor	eax, eax
$LN61@TypedefDir:
	mov	r15, QWORD PTR [rsp+80]
$LN60@TypedefDir:
	mov	r12, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+152]
	mov	rbx, QWORD PTR [rsp+144]
	mov	r14, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+112]

; 1106 : }

	add	rsp, 120				; 00000078H
	ret	0
TypedefDirective ENDP
_TEXT	ENDS
PUBLIC	RecordDirective
EXTRN	SymFree:NEAR
EXTRN	SymAddGlobal:NEAR
xdata	SEGMENT
$unwind$RecordDirective DD 061601H
	DD	01ae416H
	DD	0223412H
	DD	01f010eH
xdata	ENDS
pdata	SEGMENT
$pdata$RecordDirective DD @imagerel($LN110#)
	DD	@imagerel($LN110#+65)
	DD	@imagerel($unwind$RecordDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$3$RecordDirective DD 041021H
	DD	01d7410H
	DD	01e6408H
	DD	@imagerel($LN110#)
	DD	@imagerel($LN110#+65)
	DD	@imagerel($unwind$RecordDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$RecordDirective DD @imagerel($LN110#+65)
	DD	@imagerel($LN110#+371)
	DD	@imagerel($chain$3$RecordDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$7$RecordDirective DD 084221H
	DD	019f442H
	DD	023542fH
	DD	01bd422H
	DD	01cc408H
	DD	@imagerel($LN110#+65)
	DD	@imagerel($LN110#+371)
	DD	@imagerel($chain$3$RecordDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$RecordDirective DD @imagerel($LN110#+371)
	DD	@imagerel($LN110#+1375)
	DD	@imagerel($chain$7$RecordDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$8$RecordDirective DD 020021H
	DD	01bd400H
	DD	@imagerel($LN110#+65)
	DD	@imagerel($LN110#+371)
	DD	@imagerel($chain$3$RecordDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$RecordDirective DD @imagerel($LN110#+1375)
	DD	@imagerel($LN110#+1506)
	DD	@imagerel($chain$8$RecordDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$9$RecordDirective DD 021H
	DD	@imagerel($LN110#+65)
	DD	@imagerel($LN110#+371)
	DD	@imagerel($chain$3$RecordDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$9$RecordDirective DD @imagerel($LN110#+1506)
	DD	@imagerel($LN110#+1692)
	DD	@imagerel($chain$9$RecordDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$10$RecordDirective DD 021H
	DD	@imagerel($LN110#)
	DD	@imagerel($LN110#+65)
	DD	@imagerel($unwind$RecordDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$10$RecordDirective DD @imagerel($LN110#+1692)
	DD	@imagerel($LN110#+1716)
	DD	@imagerel($chain$10$RecordDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
redef_err$1$ = 48
oldr$1$ = 56
init_loc$ = 64
tv67 = 72
opndx$ = 80
redef_err$ = 256
i$ = 256
tokenarray$ = 264
RecordDirective PROC NEAR

; 1116 : {

$LN110:
	mov	DWORD PTR [rsp+8], ecx
	mov	rax, rsp
	sub	rsp, 248				; 000000f8H
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax-40], r14

; 1117 :     char *name;
; 1118 :     struct asym *sym;
; 1119 :     struct dsym *newr;
; 1120 :     struct dsym *oldr = NULL;

	xor	r14d, r14d

; 1121 :     struct sfield *f;
; 1122 :     int cntBits;
; 1123 :     int define;
; 1124 :     int len;
; 1125 :     int redef_err;
; 1126 :     int count;
; 1127 :     //int value;
; 1128 :     int name_loc;
; 1129 :     int init_loc;
; 1130 :     struct expr opndx;
; 1131 : 
; 1132 :     DebugMsg1(("RecordDirective(%d) enter\n", i));
; 1133 :     if ( i != 1 ) {

	cmp	ecx, 1
	mov	rbx, rdx
	mov	QWORD PTR oldr$1$[rsp], r14
	je	SHORT $LN51@RecordDire

; 1134 :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	movsxd	rdx, ecx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbx+8]
	call	EmitErr
	jmp	$LN52@RecordDire
$LN51@RecordDire:
	mov	QWORD PTR [rsp+240], rsi
	mov	QWORD PTR [rsp+232], rdi

; 1135 :     }
; 1136 : 
; 1137 :     name = tokenarray[0].string_ptr;

	mov	rdi, QWORD PTR [rdx+8]

; 1138 :     sym = SymSearch( name );

	mov	rcx, rdi
	call	SymFind

; 1139 :     if ( sym == NULL || sym->state == SYM_UNDEFINED ) {

	test	rax, rax
	mov	rsi, rax
	je	$LN49@RecordDire
	mov	eax, DWORD PTR [rax+40]
	test	eax, eax
	je	$LN49@RecordDire

; 1141 :     } else if ( sym->state == SYM_TYPE &&
; 1142 :                ( sym->typekind == TYPE_RECORD ||
; 1143 :                sym->typekind == TYPE_NONE ) ) {

	cmp	eax, 7
	jne	SHORT $LN47@RecordDire
	movzx	eax, BYTE PTR [rsi+74]
	cmp	al, 4
	je	SHORT $LN46@RecordDire
	test	al, al
	jne	SHORT $LN47@RecordDire
$LN46@RecordDire:

; 1144 :         /* v2.04: allow redefinition of record and forward references.
; 1145 :          * the record redefinition may have different initial values,
; 1146 :          * but those new values are IGNORED! ( Masm bug? )
; 1147 :          */
; 1148 :         if ( Parse_Pass == PASS_1 && sym->typekind == TYPE_RECORD ) {

	cmp	DWORD PTR Parse_Pass, r14d
	jne	$LN105@RecordDire
	cmp	al, 4
	jne	$LN105@RecordDire

; 1150 :             sym = CreateTypeSymbol( NULL, name, FALSE );

	mov	rcx, rdi
	mov	r14, rsi
	mov	QWORD PTR oldr$1$[rsp], rsi
	call	SymAlloc
	test	rax, rax
	mov	rsi, rax
	je	SHORT $LN61@RecordDire
	mov	ecx, 32					; 00000020H
	mov	DWORD PTR [rax+40], 7
	mov	BYTE PTR [rax+74], 0
	call	LclAlloc
	mov	QWORD PTR [rsi+104], rax
	mov	QWORD PTR [rax], 0
	mov	QWORD PTR [rax+8], 0
	mov	BYTE PTR [rax+28], 0
	mov	BYTE PTR [rax+29], 0
$LN61@RecordDire:

; 1151 :             redef_err = 0;

	xor	eax, eax
	mov	DWORD PTR redef_err$1$[rsp], eax

; 1152 :         }
; 1153 :     } else {

	jmp	SHORT $LN44@RecordDire
$LN47@RecordDire:

; 1154 :         return( EmitErr( SYMBOL_REDEFINITION, name ) );

	mov	rdx, rdi
	mov	ecx, 143				; 0000008fH
	call	EmitErr
	jmp	$LN109@RecordDire
$LN49@RecordDire:

; 1140 :         sym = CreateTypeSymbol( sym, name, TRUE );

	test	rsi, rsi
	je	SHORT $LN56@RecordDire
	lea	rcx, OFFSET FLAT:SymTables
	mov	rdx, rsi
	call	sym_remove_table
	jmp	SHORT $LN55@RecordDire
$LN56@RecordDire:
	mov	rcx, rdi
	call	SymCreate
	mov	rsi, rax
$LN55@RecordDire:
	test	rsi, rsi
	je	SHORT $LN54@RecordDire
	mov	ecx, 32					; 00000020H
	mov	DWORD PTR [rsi+40], 7
	mov	BYTE PTR [rsi+74], r14b
	call	LclAlloc
	mov	QWORD PTR [rsi+104], rax
	mov	QWORD PTR [rax], r14
	mov	QWORD PTR [rax+8], r14
	mov	BYTE PTR [rax+28], r14b
	mov	BYTE PTR [rax+29], r14b
$LN54@RecordDire:
	mov	eax, DWORD PTR redef_err$[rsp]
	mov	DWORD PTR redef_err$1$[rsp], eax
	jmp	SHORT $LN44@RecordDire
$LN105@RecordDire:
	mov	eax, DWORD PTR redef_err$[rsp]
	mov	DWORD PTR redef_err$1$[rsp], eax
$LN44@RecordDire:

; 1155 :     }
; 1156 :     sym->isdefined = TRUE;

	or	BYTE PTR [rsi+48], 2

; 1157 : 
; 1158 :     if ( Parse_Pass > PASS_1 )

	cmp	DWORD PTR Parse_Pass, 0

; 1159 :         return( NOT_ERROR );

	ja	$LN3@RecordDire
	mov	QWORD PTR [rsp+224], r12

; 1160 : 
; 1161 :     newr = (struct dsym *)sym;
; 1162 :     newr->sym.typekind = TYPE_RECORD;

	mov	BYTE PTR [rsi+74], 4

; 1163 : 
; 1164 :     i++; /* go past RECORD */

	mov	edx, DWORD PTR i$[rsp]

; 1165 : 
; 1166 :     cntBits = 0; /* counter for total of bits in record */

	mov	r8d, DWORD PTR ModuleInfo+496
	mov	QWORD PTR [rsp+216], r13
	inc	edx
	xor	r13d, r13d
	mov	QWORD PTR [rsp+280], rbp
	mov	DWORD PTR i$[rsp], edx
	lea	r12d, QWORD PTR [r13+64]
	mov	QWORD PTR [rsp+200], r15
$LL42@RecordDire:

; 1167 :     /* parse bitfields */
; 1168 :     do {
; 1169 :         if ( tokenarray[i].token != T_ID ) {

	movsxd	rdi, edx
	shl	rdi, 5
	cmp	BYTE PTR [rdi+rbx], 8
	jne	$LN85@RecordDire

; 1172 :         }
; 1173 :         len = strlen( tokenarray[i].string_ptr );

	mov	rdi, QWORD PTR [rdi+rbx+8]
	xor	eax, eax
	mov	rcx, -1
	repne scasb
	not	rcx
	dec	rcx

; 1174 :         if( len > MAX_ID_LEN ) {

	cmp	ecx, 247				; 000000f7H
	mov	rdi, rcx
	mov	QWORD PTR tv67[rsp], rcx
	jg	$LN86@RecordDire

; 1177 :         }
; 1178 :         name_loc = i;

	movsxd	rbp, edx

; 1179 :         i++;

	inc	edx

; 1180 :         if ( tokenarray[i].token != T_COLON ) {

	movsxd	rax, edx
	mov	DWORD PTR i$[rsp], edx
	shl	rax, 5
	cmp	BYTE PTR [rax+rbx], 58			; 0000003aH
	jne	$LN87@RecordDire

; 1183 :         }
; 1184 :         i++;

	inc	edx

; 1185 :         /* get width */
; 1186 :         if ( EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 ) == ERROR )

	lea	r9, QWORD PTR opndx$[rsp]
	lea	rcx, QWORD PTR i$[rsp]
	mov	DWORD PTR i$[rsp], edx
	mov	rdx, rbx
	mov	BYTE PTR [rsp+32], 0
	call	EvalOperand
	cmp	eax, -1
	je	$LN40@RecordDire

; 1187 :             break;
; 1188 :         if ( opndx.kind != EXPR_CONST ) {

	cmp	DWORD PTR opndx$[rsp+60], 0
	je	SHORT $LN35@RecordDire

; 1189 :             EmitError( CONSTANT_EXPECTED );

	mov	ecx, 65					; 00000041H
	call	EmitError

; 1190 :             opndx.value = 1;

	mov	edx, 1
	mov	DWORD PTR opndx$[rsp], edx

; 1191 :         }
; 1192 :         if ( opndx.value == 0 ) {

	jmp	SHORT $LN101@RecordDire
$LN35@RecordDire:
	mov	edx, DWORD PTR opndx$[rsp]
	test	edx, edx
	je	$LN89@RecordDire
$LN101@RecordDire:

; 1194 :             break;
; 1195 :         } else if ( ( opndx.value + cntBits ) > MAXRECBITS ) {

	cmp	BYTE PTR ModuleInfo+404, 2
	mov	ecx, 32					; 00000020H
	lea	eax, DWORD PTR [rdx+r13]
	cmove	ecx, r12d
	cmp	eax, ecx
	jg	$LN90@RecordDire

; 1198 :         }
; 1199 :         count = 0;
; 1200 :         /* is there an initializer? ('=') */
; 1201 :         if ( tokenarray[i].token == T_DIRECTIVE &&
; 1202 :             tokenarray[i].dirtype == DRT_EQUALSGN ) {

	movsxd	rcx, DWORD PTR i$[rsp]
	xor	r15d, r15d
	mov	rax, rcx
	shl	rax, 5
	cmp	BYTE PTR [rax+rbx], 3
	jne	SHORT $LN26@RecordDire
	cmp	BYTE PTR [rax+rbx+1], 48		; 00000030H
	jne	SHORT $LN26@RecordDire

; 1203 :             i++;

	inc	ecx

; 1204 :             for( init_loc = i; tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA; i++ );

	movsxd	rdi, ecx
	mov	DWORD PTR i$[rsp], ecx
	mov	r8d, ecx
	mov	rax, rdi
	mov	DWORD PTR init_loc$[rsp], ecx
	shl	rax, 5
	movzx	edx, BYTE PTR [rax+rbx]
	test	dl, dl
	je	$LN91@RecordDire
$LL30@RecordDire:
	cmp	dl, 44					; 0000002cH
	je	SHORT $LN28@RecordDire
	inc	ecx
	movsxd	rax, ecx
	mov	DWORD PTR i$[rsp], ecx
	shl	rax, 5
	mov	dl, BYTE PTR [rax+rbx]
	test	dl, dl
	jne	SHORT $LL30@RecordDire
$LN28@RecordDire:

; 1205 :             /* no value? */
; 1206 :             if ( init_loc == i ) {

	cmp	r8d, ecx
	je	$LN91@RecordDire

; 1209 :             }
; 1210 :             /* v2.09: initial values of record redefinitions are ignored! */
; 1211 :             if ( oldr == NULL )

	test	r14, r14
	jne	SHORT $LN106@RecordDire

; 1212 :                 count = tokenarray[i].tokpos - tokenarray[init_loc].tokpos;

	shl	rdi, 5
	movsxd	rax, ecx
	shl	rax, 5
	mov	r15d, DWORD PTR [rax+rbx+24]
	sub	r15d, DWORD PTR [rdi+rbx+24]
	mov	rdi, QWORD PTR tv67[rsp]
	jmp	SHORT $LN26@RecordDire
$LN106@RecordDire:

; 1172 :         }
; 1173 :         len = strlen( tokenarray[i].string_ptr );

	mov	rdi, QWORD PTR tv67[rsp]
$LN26@RecordDire:

; 1213 :         }
; 1214 :         /* record field names are global! (Masm design flaw) */
; 1215 :         sym = SymSearch( tokenarray[name_loc].string_ptr );

	mov	r12, rbp
	shl	r12, 5
	mov	rcx, QWORD PTR [r12+rbx+8]
	call	SymFind

; 1216 :         define = TRUE;
; 1217 :         if ( oldr ) {

	test	r14, r14
	mov	ecx, DWORD PTR opndx$[rsp]
	je	SHORT $LN25@RecordDire

; 1218 :             if ( sym == NULL ||
; 1219 :                 sym->state != SYM_STRUCT_FIELD ||
; 1220 :                 sym->mem_type != MT_BITS ||
; 1221 :                 sym->total_size != opndx.value ) {

	test	rax, rax
	je	SHORT $LN23@RecordDire
	cmp	DWORD PTR [rax+40], 6
	jne	SHORT $LN23@RecordDire
	cmp	DWORD PTR [rax+44], 193			; 000000c1H
	jne	SHORT $LN23@RecordDire
	cmp	DWORD PTR [rax+64], ecx
	je	SHORT $LN102@RecordDire
$LN23@RecordDire:

; 1222 :                 EmitErr( NON_BENIGN_XXX_REDEFINITION, szRecord, tokenarray[name_loc].string_ptr );

	mov	r8, QWORD PTR [r12+rbx+8]
	lea	rdx, OFFSET FLAT:szRecord
	mov	ecx, 139				; 0000008bH
	call	EmitErr

; 1223 :                 redef_err++;

	inc	DWORD PTR redef_err$1$[rsp]

; 1224 :                 define = FALSE; /* v2.06: added */
; 1225 :             }
; 1226 :         } else {

	jmp	$LN16@RecordDire
$LN25@RecordDire:

; 1227 :             if ( sym ) {

	test	rax, rax
	jne	$LN92@RecordDire
$LN102@RecordDire:

; 1230 :             }
; 1231 :         }
; 1232 : 
; 1233 :         if ( define ) { /* v2.06: don't add field if there was an error */
; 1234 :             cntBits += opndx.value;

	add	r13d, ecx

; 1235 :             f = LclAlloc( sizeof( struct sfield ) + count );

	movsxd	r14, r15d
	lea	rcx, QWORD PTR [r14+120]
	call	LclAlloc

; 1236 :             memset( f, 0, sizeof( struct sfield ) );

	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+120]
	mov	rcx, rax
	mov	rbp, rax
	call	memset

; 1237 :             f->sym.name_size = len;
; 1238 :             f->sym.name = LclAlloc( len + 1 );

	lea	ecx, DWORD PTR [rdi+1]
	mov	BYTE PTR [rbp+80], dil
	movsxd	rdi, ecx
	mov	rcx, rdi
	call	LclAlloc

; 1239 :             memcpy( f->sym.name, tokenarray[name_loc].string_ptr, len + 1 );

	mov	r8, rdi
	mov	QWORD PTR [rbp+8], rax
	mov	rdx, QWORD PTR [r12+rbx+8]
	mov	rcx, rax
	call	memcpy

; 1240 :             f->sym.list = ModuleInfo.cref;

	mov	eax, DWORD PTR ModuleInfo+408

; 1241 :             f->sym.state = SYM_STRUCT_FIELD;

	mov	DWORD PTR [rbp+40], 6
	shr	eax, 13

; 1242 :             f->sym.mem_type = MT_BITS;

	mov	DWORD PTR [rbp+44], 193			; 000000c1H
	xor	al, BYTE PTR [rbp+49]
	and	al, 1
	xor	BYTE PTR [rbp+49], al

; 1243 :             f->sym.total_size = opndx.value;
; 1244 :             if ( !oldr ) {

	cmp	QWORD PTR oldr$1$[rsp], 0
	mov	eax, DWORD PTR opndx$[rsp]
	mov	DWORD PTR [rbp+64], eax
	jne	SHORT $LN19@RecordDire

; 1245 :                 SymAddGlobal( &f->sym );

	mov	rcx, rbp
	call	SymAddGlobal
$LN19@RecordDire:

; 1246 :             }
; 1247 :             f->next = NULL;
; 1248 :             //f->sym = sym;
; 1249 :             f->ivalue[0] = NULLC;

	mov	BYTE PTR [rbp+112], 0
	mov	QWORD PTR [rbp+104], 0

; 1250 :             //f->init_dir = NULL;
; 1251 :             if( newr->e.structinfo->head == NULL ) {

	mov	rax, QWORD PTR [rsi+104]
	cmp	QWORD PTR [rax], 0
	lea	rcx, QWORD PTR [rbp+112]
	jne	SHORT $LN18@RecordDire

; 1252 :                 newr->e.structinfo->head = newr->e.structinfo->tail = f;

	mov	QWORD PTR [rax+8], rbp
	mov	rax, QWORD PTR [rsi+104]
	mov	QWORD PTR [rax], rbp

; 1253 :             } else {

	jmp	SHORT $LN17@RecordDire
$LN18@RecordDire:

; 1254 :                 newr->e.structinfo->tail->next = f;

	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rax+104], rbp

; 1255 :                 newr->e.structinfo->tail = f;

	mov	rax, QWORD PTR [rsi+104]
	mov	QWORD PTR [rax+8], rbp
$LN17@RecordDire:

; 1256 :             }
; 1257 :             if ( count ) {

	test	r15d, r15d
	je	SHORT $LN107@RecordDire

; 1258 :                 //f->value = LclAlloc( count + 1 );
; 1259 :                 memcpy( f->ivalue, tokenarray[init_loc].tokpos, count );

	movsxd	rdx, DWORD PTR init_loc$[rsp]
	mov	r8, r14
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbx+24]
	call	memcpy

; 1260 :                 f->ivalue[count] = NULLC;

	mov	BYTE PTR [r14+rbp+112], 0
	mov	r14, QWORD PTR oldr$1$[rsp]
	jmp	SHORT $LN16@RecordDire
$LN107@RecordDire:

; 1149 :             oldr = (struct dsym *)sym;

	mov	r14, QWORD PTR oldr$1$[rsp]
$LN16@RecordDire:

; 1261 :             }
; 1262 :         }
; 1263 : 
; 1264 :         if ( i < Token_Count ) {

	movsxd	rdx, DWORD PTR i$[rsp]
	mov	r8d, DWORD PTR ModuleInfo+496
	cmp	edx, r8d
	jge	$LN40@RecordDire

; 1265 :             if ( tokenarray[i].token != T_COMMA || tokenarray[i+1].token == T_FINAL ) {

	mov	rax, rdx
	shl	rax, 5
	cmp	BYTE PTR [rax+rbx], 44			; 0000002cH
	jne	$LN93@RecordDire
	lea	rax, QWORD PTR [rdx+1]
	shl	rax, 5
	cmp	BYTE PTR [rax+rbx], 0
	je	$LN93@RecordDire

; 1267 :                 break;
; 1268 :             }
; 1269 :             i++;

	inc	edx

; 1270 :         }
; 1271 : 
; 1272 :     } while ( i < Token_Count );

	cmp	edx, r8d
	mov	DWORD PTR i$[rsp], edx
	jge	$LN40@RecordDire
	mov	r12d, 64				; 00000040H
	jmp	$LL42@RecordDire
$LN85@RecordDire:

; 1170 :             EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );

	movsxd	rdx, edx
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbx+8]
	call	EmitErr

; 1171 :             break;

	jmp	$LN40@RecordDire
$LN86@RecordDire:

; 1175 :             EmitError( IDENTIFIER_TOO_LONG );

	mov	ecx, 70					; 00000046H
	call	EmitError

; 1176 :             break;

	jmp	SHORT $LN40@RecordDire
$LN87@RecordDire:

; 1181 :             EmitError( COLON_EXPECTED );

	mov	ecx, 84					; 00000054H
	call	EmitError

; 1182 :             break;

	jmp	SHORT $LN40@RecordDire
$LN89@RecordDire:

; 1193 :             EmitErr( TOO_FEW_BITS_IN_RECORD, tokenarray[name_loc].string_ptr );

	mov	rdx, rbp
	mov	ecx, 35					; 00000023H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbx+8]
	call	EmitErr
	jmp	SHORT $LN40@RecordDire
$LN90@RecordDire:

; 1196 :             EmitErr( TOO_MANY_BITS_IN_RECORD, tokenarray[name_loc].string_ptr );

	mov	rdx, rbp
	mov	ecx, 140				; 0000008cH
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbx+8]
	call	EmitErr

; 1197 :             break;

	jmp	SHORT $LN40@RecordDire
$LN91@RecordDire:

; 1207 :                 EmitErr( SYNTAX_ERROR_EX, tokenarray[name_loc].tokpos );

	mov	rdx, rbp
	mov	ecx, 209				; 000000d1H
	shl	rdx, 5
	mov	rdx, QWORD PTR [rdx+rbx+24]
	call	EmitErr

; 1208 :                 break;

	jmp	SHORT $LN40@RecordDire
$LN92@RecordDire:

; 1228 :                 EmitErr( SYMBOL_REDEFINITION, sym->name );

	mov	rdx, QWORD PTR [rax+8]
	mov	ecx, 143				; 0000008fH
	call	EmitErr

; 1229 :                 break;

	jmp	SHORT $LN40@RecordDire
$LN93@RecordDire:

; 1266 :                 EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos );

	shl	rdx, 5
	mov	ecx, 209				; 000000d1H
	mov	rdx, QWORD PTR [rdx+rbx+24]
	call	EmitErr
$LN40@RecordDire:

; 1273 : 
; 1274 :     /* now calc size in bytes and set the bit positions */
; 1275 : 
; 1276 :     if ( cntBits > 16 ) {

	cmp	r13d, 16
	mov	r15, QWORD PTR [rsp+200]
	mov	r12, QWORD PTR [rsp+224]
	mov	rbp, QWORD PTR [rsp+280]
	jle	SHORT $LN12@RecordDire

; 1277 : #if AMD64_SUPPORT
; 1278 :         if ( cntBits > 32 ) {

	cmp	r13d, 32				; 00000020H
	jle	SHORT $LN11@RecordDire

; 1279 :             newr->sym.total_size = sizeof( uint_64 );

	mov	DWORD PTR [rsi+64], 8

; 1280 :             newr->sym.mem_type = MT_QWORD;

	mov	DWORD PTR [rsi+44], 7

; 1281 :         } else {

	jmp	SHORT $LN7@RecordDire
$LN11@RecordDire:

; 1282 : #endif
; 1283 :             newr->sym.total_size = sizeof( uint_32 );

	mov	DWORD PTR [rsi+64], 4

; 1284 :             newr->sym.mem_type = MT_DWORD;

	mov	DWORD PTR [rsi+44], 3

; 1285 : #if AMD64_SUPPORT
; 1286 :         }

	jmp	SHORT $LN7@RecordDire
$LN12@RecordDire:

; 1287 : #endif
; 1288 :     } else if ( cntBits > 8 ) {

	cmp	r13d, 8
	jle	SHORT $LN8@RecordDire

; 1289 :         newr->sym.total_size = sizeof( uint_16 );

	mov	DWORD PTR [rsi+64], 2

; 1290 :         newr->sym.mem_type = MT_WORD;

	mov	DWORD PTR [rsi+44], 1

; 1291 :     } else {

	jmp	SHORT $LN7@RecordDire
$LN8@RecordDire:

; 1292 :         newr->sym.total_size = sizeof( uint_8 );

	mov	DWORD PTR [rsi+64], 1

; 1293 :         newr->sym.mem_type = MT_BYTE;

	mov	DWORD PTR [rsi+44], 0
$LN7@RecordDire:

; 1294 :     }
; 1295 :     /* if the BYTE/WORD/DWORD isn't used fully, shift bits to the right! */
; 1296 :     // cntBits = dir->sym.total_size * 8;
; 1297 : 
; 1298 :     /* set the bit position */
; 1299 :     for ( f = newr->e.structinfo->head; f; f = f->next ) {

	mov	rax, QWORD PTR [rsi+104]
	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN4@RecordDire
	npad	11
$LL6@RecordDire:

; 1300 :         cntBits = cntBits - f->sym.total_size;

	sub	r13d, DWORD PTR [rcx+64]

; 1301 :         f->sym.offset = cntBits;

	mov	DWORD PTR [rcx+16], r13d
	mov	rcx, QWORD PTR [rcx+104]
	test	rcx, rcx
	jne	SHORT $LL6@RecordDire
$LN4@RecordDire:

; 1302 :     }
; 1303 :     if ( oldr ) {

	test	r14, r14
	mov	r13, QWORD PTR [rsp+216]
	je	$LN3@RecordDire

; 1304 :         if ( redef_err > 0 ||
; 1305 :             AreStructsEqual( newr, oldr ) == FALSE )

	mov	eax, DWORD PTR redef_err$1$[rsp]
	test	eax, eax
	jg	$LN1@RecordDire
	mov	rax, QWORD PTR [r14+104]
	mov	r9, QWORD PTR [rax]
	mov	rax, QWORD PTR [rsi+104]
	mov	rdi, QWORD PTR [rax]
	movzx	eax, BYTE PTR [rsi+74]
	cmp	BYTE PTR [r14+74], al
	jne	SHORT $LN1@RecordDire
	test	r9, r9
	je	SHORT $LN75@RecordDire
	mov	r10d, DWORD PTR ModuleInfo+408
$LL77@RecordDire:
	test	rdi, rdi
	je	SHORT $LN1@RecordDire
	bt	r10d, 9
	jae	SHORT $LN73@RecordDire
	mov	rax, QWORD PTR [rdi+8]
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN71@RecordDire
$LN73@RecordDire:
	mov	rax, QWORD PTR [r9+8]
	mov	r8, QWORD PTR [rdi+8]
	sub	r8, rax
$LL103@RecordDire:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN104@RecordDire
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL103@RecordDire
$LN104@RecordDire:
	test	edx, edx
	jne	SHORT $LN1@RecordDire
$LN71@RecordDire:
	mov	eax, DWORD PTR [rdi+16]
	cmp	DWORD PTR [r9+16], eax
	jne	SHORT $LN1@RecordDire
	mov	eax, DWORD PTR [rdi+64]
	cmp	DWORD PTR [r9+64], eax
	jne	SHORT $LN1@RecordDire
	mov	r9, QWORD PTR [r9+104]
	mov	rdi, QWORD PTR [rdi+104]
	test	r9, r9
	jne	SHORT $LL77@RecordDire
$LN75@RecordDire:
	test	rdi, rdi
	je	SHORT $LN2@RecordDire
$LN1@RecordDire:

; 1306 :             EmitErr( NON_BENIGN_XXX_REDEFINITION, szRecord, newr->sym.name );

	mov	r8, QWORD PTR [rsi+8]
	lea	rdx, OFFSET FLAT:szRecord
	mov	ecx, 139				; 0000008bH
	call	EmitErr
$LN2@RecordDire:

; 1307 :         /* record can be freed, because the record's fields are global items.
; 1308 :          * And initial values of the new definition are ignored!
; 1309 :          */
; 1310 :         SymFree( (struct asym *)newr );

	mov	rcx, rsi
	call	SymFree
$LN3@RecordDire:

; 1311 :     }
; 1312 :     DebugMsg(("RecordDirective(%s) exit, no error\n", name ));
; 1313 :     return( NOT_ERROR );

	xor	eax, eax
$LN109@RecordDire:
	mov	rsi, QWORD PTR [rsp+240]
	mov	rdi, QWORD PTR [rsp+232]
$LN52@RecordDire:
	mov	r14, QWORD PTR [rsp+208]
	mov	rbx, QWORD PTR [rsp+272]

; 1314 : }

	add	rsp, 248				; 000000f8H
	ret	0
RecordDirective ENDP
_TEXT	ENDS
PUBLIC	DeleteType
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
dir$ = 8
DeleteType PROC NEAR

; 1319 :     struct sfield      *curr;
; 1320 :     struct sfield      *next;
; 1321 : 
; 1322 :     DebugMsg(("DeleteType(%s) enter, typekind=%u, memtype=%Xh\n", dir->sym.name, dir->sym.typekind, dir->sym.mem_type ));
; 1323 : #if FASTMEM==0
; 1324 :     /* release prototype in target_type if typedef is PROTO */
; 1325 :     if ( dir->sym.mem_type == MT_PROC ) {
; 1326 :         /* v2.11: change the prototype type to an external, because SymFree()
; 1327 :          * doesn't expect a prototype in a type.
; 1328 :          */
; 1329 :         dir->sym.target_type->state = SYM_EXTERNAL;
; 1330 :         SymFree( dir->sym.target_type );
; 1331 :     }
; 1332 : #endif
; 1333 : #if TYPEOPT
; 1334 :     if ( dir->sym.typekind == TYPE_TYPEDEF )
; 1335 :         return;
; 1336 : #endif
; 1337 :     /* bitfields field names are global, don't free them here! */
; 1338 :     if ( dir->sym.typekind != TYPE_RECORD )

	cmp	BYTE PTR [rcx+74], 4
	je	SHORT $LN1@DeleteType

; 1339 :         for( curr = dir->e.structinfo->head; curr != NULL; curr = next ) {

	mov	rax, QWORD PTR [rcx+104]
	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN1@DeleteType
$LL3@DeleteType:
	mov	rcx, QWORD PTR [rcx+104]
	test	rcx, rcx
	jne	SHORT $LL3@DeleteType
$LN1@DeleteType:

; 1340 :             next = curr->next;
; 1341 : #if FASTMEM==0
; 1342 :             if ( curr->sym.name_size ) LclFree( curr->sym.name );
; 1343 : #endif
; 1344 :             LclFree( curr );
; 1345 :         }
; 1346 :     LclFree( dir->e.structinfo );
; 1347 :     return;
; 1348 : }

	ret	0
DeleteType ENDP
_TEXT	ENDS
PUBLIC	EndstructDirective
EXTRN	SymSimd:NEAR
xdata	SEGMENT
$unwind$EndstructDirective DD 072101H
	DD	0a6421H
	DD	09541cH
	DD	083410H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$EndstructDirective DD @imagerel($LN58#)
	DD	@imagerel($LN58#+265)
	DD	@imagerel($unwind$EndstructDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$3$EndstructDirective DD 020521H
	DD	06d405H
	DD	@imagerel($LN58#)
	DD	@imagerel($LN58#+265)
	DD	@imagerel($unwind$EndstructDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$EndstructDirective DD @imagerel($LN58#+265)
	DD	@imagerel($LN58#+328)
	DD	@imagerel($chain$3$EndstructDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$4$EndstructDirective DD 020521H
	DD	0bc405H
	DD	@imagerel($LN58#+265)
	DD	@imagerel($LN58#+328)
	DD	@imagerel($chain$3$EndstructDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$EndstructDirective DD @imagerel($LN58#+328)
	DD	@imagerel($LN58#+454)
	DD	@imagerel($chain$4$EndstructDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$5$EndstructDirective DD 021H
	DD	@imagerel($LN58#+265)
	DD	@imagerel($LN58#+328)
	DD	@imagerel($chain$3$EndstructDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$EndstructDirective DD @imagerel($LN58#+454)
	DD	@imagerel($LN58#+482)
	DD	@imagerel($chain$5$EndstructDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$6$EndstructDirective DD 021H
	DD	@imagerel($LN58#)
	DD	@imagerel($LN58#+265)
	DD	@imagerel($unwind$EndstructDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$EndstructDirective DD @imagerel($LN58#+482)
	DD	@imagerel($LN58#+518)
	DD	@imagerel($chain$6$EndstructDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$7$EndstructDirective DD 020021H
	DD	06d400H
	DD	@imagerel($LN58#)
	DD	@imagerel($LN58#+265)
	DD	@imagerel($unwind$EndstructDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$EndstructDirective DD @imagerel($LN58#+518)
	DD	@imagerel($LN58#+575)
	DD	@imagerel($chain$7$EndstructDirective#)
pdata	ENDS
xdata	SEGMENT
$chain$8$EndstructDirective DD 021H
	DD	@imagerel($LN58#)
	DD	@imagerel($LN58#+265)
	DD	@imagerel($unwind$EndstructDirective#)
xdata	ENDS
pdata	SEGMENT
$pdata$8$EndstructDirective DD @imagerel($LN58#+575)
	DD	@imagerel($LN58#+789)
	DD	@imagerel($chain$8$EndstructDirective#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
i$ = 64
tokenarray$ = 72
EndstructDirective PROC NEAR

; 369  : {

$LN58:
	sub	rsp, 56					; 00000038H

; 370  :     //char *name;
; 371  :     //unsigned int offset;
; 372  :     unsigned int size;
; 373  :     //struct asym *sym;
; 374  :     //memtype mem_type;
; 375  :     struct dsym *dir;
; 376  : 
; 377  :     dir = CurrStruct; /* cannot be NULL */
; 378  : 
; 379  :     DebugMsg1(("EndstructDirective(%s), ofs=%" I32_SPEC "u, struct size=%" I32_SPEC "u, max_mbr=%" I32_SPEC "u, alignment=%u\n",
; 380  :               dir->sym.name,
; 381  :               dir->sym.offset,
; 382  :               dir->sym.total_size,
; 383  :               dir->sym.max_mbr_size,
; 384  :               dir->e.structinfo->alignment));
; 385  : 
; 386  :     /* if pass is > 1 just do minimal work */
; 387  :     if ( Parse_Pass > PASS_1 ) {

	cmp	DWORD PTR Parse_Pass, 0
	mov	QWORD PTR [rsp+64], rbx
	mov	rbx, QWORD PTR CurrStruct
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+80], rsi
	mov	esi, ecx
	mov	rbp, rdx
	jbe	SHORT $LN34@EndstructD

; 388  :         CurrStruct->sym.offset = 0;

	mov	DWORD PTR [rbx+16], 0

; 389  :         size = CurrStruct->sym.total_size;

	mov	rax, QWORD PTR CurrStruct

; 390  :         CurrStruct = CurrStruct->next;

	mov	rcx, QWORD PTR [rax+112]
	mov	edx, DWORD PTR [rax+64]

; 391  :         if ( CurrStruct )

	test	rcx, rcx
	mov	QWORD PTR CurrStruct, rcx
	je	SHORT $LN41@EndstructD

; 392  :             UpdateStructSize( (struct asym *)dir );

	cmp	BYTE PTR [rcx+74], 2
	jne	SHORT $LN44@EndstructD
	mov	eax, DWORD PTR [rbx+64]
	cmp	eax, DWORD PTR [rcx+64]
	jbe	SHORT $LN41@EndstructD
	mov	DWORD PTR [rcx+64], eax
	jmp	SHORT $LN41@EndstructD
$LN44@EndstructD:
	mov	eax, DWORD PTR [rbx+64]
	add	DWORD PTR [rcx+16], eax
	mov	rax, QWORD PTR CurrStruct
	mov	ecx, DWORD PTR [rax+16]
	cmp	ecx, DWORD PTR [rax+64]
	jle	SHORT $LN41@EndstructD
	mov	DWORD PTR [rax+64], ecx
$LN41@EndstructD:

; 393  :         if ( CurrFile[LST] )

	cmp	QWORD PTR ModuleInfo+112, 0
	je	SHORT $LN32@EndstructD

; 394  :             LstWrite( LSTTYPE_STRUCT, size, dir );

	mov	r8, rbx
	mov	ecx, 6
	call	LstWrite
$LN32@EndstructD:

; 395  :         return( NOT_ERROR );

	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 510  :     }
; 511  :     return( NOT_ERROR );
; 512  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN34@EndstructD:

; 396  :     }
; 397  : 
; 398  :     /* syntax is either "<name> ENDS" (i=1) or "ENDS" (i=0).
; 399  :      * first case must be top level (next=NULL), latter case must NOT be top level (next!=NULL)
; 400  :      */
; 401  :     if ( ( i == 1 && dir->next == NULL ) ||
; 402  :         ( i == 0 && dir->next != NULL ) ) {

	cmp	ecx, 1
	jne	SHORT $LN29@EndstructD
	cmp	QWORD PTR [rbx+112], 0
	je	$LN55@EndstructD

; 403  :         ;
; 404  :     } else {
; 405  :         /* v2.04: error msg improved */
; 406  :         //EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );
; 407  :         return( EmitErr( UNMATCHED_BLOCK_NESTING, i == 1 ? tokenarray[0].string_ptr : "" ) );

	mov	rdx, QWORD PTR [rdx+8]
	jmp	$LN38@EndstructD
$LN29@EndstructD:

; 396  :     }
; 397  : 
; 398  :     /* syntax is either "<name> ENDS" (i=1) or "ENDS" (i=0).
; 399  :      * first case must be top level (next=NULL), latter case must NOT be top level (next!=NULL)
; 400  :      */
; 401  :     if ( ( i == 1 && dir->next == NULL ) ||
; 402  :         ( i == 0 && dir->next != NULL ) ) {

	test	ecx, ecx
	jne	$LN37@EndstructD
	cmp	QWORD PTR [rbx+112], 0
	je	$LN37@EndstructD
$LN26@EndstructD:

; 415  :         }
; 416  :     }
; 417  : 
; 418  :     i++; /* go past ENDS */
; 419  : 
; 420  :     /* v2.07: if ORG was used inside the struct, the struct's size
; 421  :      * has to be calculated now - there may exist negative offsets.
; 422  :      */
; 423  :     if ( dir->e.structinfo->OrgInside ) {

	mov	r8, QWORD PTR [rbx+104]
	inc	esi
	test	BYTE PTR [r8+29], 4
	je	SHORT $LN25@EndstructD

; 424  :         struct sfield *f;
; 425  :         int_32 min = 0;
; 426  :         for ( f = dir->e.structinfo->head; f; f = f->next )

	mov	rdx, QWORD PTR [r8]
	xor	ecx, ecx
	test	rdx, rdx
	je	SHORT $LN22@EndstructD
	npad	12
$LL24@EndstructD:

; 427  :             if ( f->sym.offset < min )

	mov	eax, DWORD PTR [rdx+16]
	mov	rdx, QWORD PTR [rdx+104]
	cmp	eax, ecx
	cmovl	ecx, eax
	test	rdx, rdx
	jne	SHORT $LL24@EndstructD
$LN22@EndstructD:

; 428  :                 min = f->sym.offset;
; 429  :         dir->sym.total_size = dir->sym.total_size - min;

	sub	DWORD PTR [rbx+64], ecx
$LN25@EndstructD:

; 430  :     }
; 431  : 
; 432  :     /* Pad bytes at the end of the structure. */
; 433  : #if 1
; 434  :     /* v2.02: this is to be done in any case, whether -Zg is set or not */
; 435  :     //if ( dir->e.structinfo->alignment > 1 && Options.masm_compat_gencode == FALSE ) {
; 436  :     if ( dir->e.structinfo->alignment > 1 ) {

	movzx	eax, BYTE PTR [r8+28]
	mov	QWORD PTR [rsp+48], r13
	mov	r13d, 1
	cmp	al, r13b
	jbe	SHORT $LN20@EndstructD

; 437  :         size = dir->sym.max_mbr_size;

	mov	edx, DWORD PTR [rbx+56]

; 438  :         if ( size == 0 )
; 439  :             size++;
; 440  :         if ( size > dir->e.structinfo->alignment )

	movzx	eax, al
	test	edx, edx
	cmove	edx, r13d
	cmp	edx, eax
	cmova	edx, eax

; 441  :             size = dir->e.structinfo->alignment;
; 442  :         dir->sym.total_size = (dir->sym.total_size + size - 1) & (-size);

	mov	eax, DWORD PTR [rbx+64]
	lea	ecx, DWORD PTR [rax+rdx-1]
	neg	edx
	and	ecx, edx
	mov	DWORD PTR [rbx+64], ecx
$LN20@EndstructD:

; 443  :         DebugMsg1(("EndstructDirective:, struct size after final alignment=%" I32_SPEC "u\n", dir->sym.total_size));
; 444  :     }
; 445  : #endif
; 446  :     dir->e.structinfo->isOpen = FALSE;

	and	BYTE PTR [r8+29], 253			; 000000fdH

; 447  :     dir->sym.isdefined = TRUE;

	or	BYTE PTR [rbx+48], 2

; 448  : 
; 449  :     /* if there's a negative offset, size will be wrong! */
; 450  :     size = dir->sym.total_size;
; 451  : 
; 452  :     /* reset offset, it's just used during the definition */
; 453  :     dir->sym.offset = 0;
; 454  : 
; 455  :     CurrStruct = dir->next;
; 456  :     /* v2.0: add the embedded struct AFTER it has been parsed! */
; 457  :     if ( i == 1 ) {

	cmp	esi, r13d
	mov	rax, QWORD PTR [rbx+112]
	mov	QWORD PTR [rsp+88], r12
	mov	r12d, DWORD PTR [rbx+64]
	mov	DWORD PTR [rbx+16], 0
	mov	QWORD PTR CurrStruct, rax
	jne	SHORT $LN17@EndstructD

; 458  :         struct asym *sym;
; 459  :         /* v2.06: the struct name is needed for checks */
; 460  :         sym = CreateStructField( -1, NULL, *dir->sym.name ? dir->sym.name : NULL, MT_TYPE, &dir->sym, dir->sym.total_size );

	mov	rax, QWORD PTR [rbx+8]
	xor	r8d, r8d
	mov	r9d, 196				; 000000c4H
	cmp	BYTE PTR [rax], r8b
	cmovne	r8, rax
	mov	eax, DWORD PTR [rbx+64]
	xor	edx, edx
	mov	DWORD PTR [rsp+40], eax
	lea	ecx, QWORD PTR [rdx-1]
	mov	QWORD PTR [rsp+32], rbx
	call	CreateStructField

; 461  :         /* the member name was stored in the type name */
; 462  :         //sym->name = dir->sym.name;
; 463  :         //sym->name_size = strlen( dir->sym.name );
; 464  :         sym->total_size = dir->sym.total_size;

	mov	ecx, DWORD PTR [rbx+64]
	mov	DWORD PTR [rax+64], ecx

; 465  :         dir->sym.name = ""; /* the type becomes anonymous */

	lea	rax, OFFSET FLAT:$SG5845

; 466  :         dir->sym.name_size = 0;

	mov	BYTE PTR [rbx+80], 0
	mov	QWORD PTR [rbx+8], rax
$LN17@EndstructD:

; 467  :     }
; 468  : 
; 469  :     if ( CurrFile[LST] ) {

	cmp	QWORD PTR ModuleInfo+112, 0
	je	SHORT $LN16@EndstructD

; 470  :         LstWrite( LSTTYPE_STRUCT, size, dir );

	mov	r8, rbx
	mov	edx, r12d
	mov	ecx, 6
	call	LstWrite
$LN16@EndstructD:

; 471  :     }
; 472  : #if 1
; 473  :     /* to allow direct structure access */
; 474  :     switch ( dir->sym.total_size ) {

	mov	eax, DWORD PTR [rbx+64]
	mov	r12, QWORD PTR [rsp+88]
	dec	eax
	je	SHORT $LN13@EndstructD
	dec	eax
	je	SHORT $LN12@EndstructD
	sub	eax, 2
	je	SHORT $LN11@EndstructD
	sub	eax, 2
	je	SHORT $LN10@EndstructD
	cmp	eax, 2
	je	SHORT $LN9@EndstructD

; 480  :     //case 16:  dir->sym.mem_type = MT_OWORD;  break;
; 481  :     default: dir->sym.mem_type = MT_EMPTY;

	mov	DWORD PTR [rbx+44], 192			; 000000c0H
	jmp	SHORT $LN14@EndstructD
$LN55@EndstructD:

; 408  :     }
; 409  : 
; 410  :     if ( i == 1 ) { /* an global struct ends with <name ENDS> */
; 411  :         if ( SymCmpFunc( tokenarray[0].string_ptr, dir->sym.name, dir->sym.name_size ) != 0 ) {

	movzx	r8d, BYTE PTR [rbx+80]
	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rbp+8]
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	$LN26@EndstructD

; 412  :             /* names don't match */
; 413  :             DebugMsg(("EndstructDirective: names don't match, i=%u, name=%s - %s\n", i, tokenarray[0].string_ptr, dir->sym.name));
; 414  :             return( EmitErr( UNMATCHED_BLOCK_NESTING, tokenarray[0].string_ptr ) );

	mov	rdx, QWORD PTR [rbp+8]
	jmp	$LN38@EndstructD
$LN9@EndstructD:

; 479  :     case 8:  dir->sym.mem_type = MT_QWORD;  break;

	mov	DWORD PTR [rbx+44], 7
	jmp	SHORT $LN14@EndstructD
$LN10@EndstructD:

; 478  :     case 6:  dir->sym.mem_type = MT_FWORD;  break;

	mov	DWORD PTR [rbx+44], 5
	jmp	SHORT $LN14@EndstructD
$LN11@EndstructD:

; 477  :     case 4:  dir->sym.mem_type = MT_DWORD;  break;

	mov	DWORD PTR [rbx+44], 3
	jmp	SHORT $LN14@EndstructD
$LN12@EndstructD:

; 476  :     case 2:  dir->sym.mem_type = MT_WORD;   break;

	mov	DWORD PTR [rbx+44], r13d
	jmp	SHORT $LN14@EndstructD
$LN13@EndstructD:

; 475  :     case 1:  dir->sym.mem_type = MT_BYTE;   break;

	mov	DWORD PTR [rbx+44], 0
$LN14@EndstructD:

; 482  :     }
; 483  : #endif
; 484  :     /* reset redefine */
; 485  :     if ( CurrStruct == NULL ) {

	mov	rcx, QWORD PTR CurrStruct
	mov	r13, QWORD PTR [rsp+48]
	test	rcx, rcx
	jne	SHORT $LN7@EndstructD

; 486  :         if ( redef_struct ) {

	mov	rdx, QWORD PTR redef_struct
	test	rdx, rdx
	je	SHORT $LN47@EndstructD

; 487  :             if ( AreStructsEqual( dir, redef_struct) == FALSE ) {

	mov	rcx, rbx
	call	AreStructsEqual
	test	al, al
	jne	SHORT $LN5@EndstructD

; 488  :                 EmitErr( NON_BENIGN_XXX_REDEFINITION, szStructure, dir->sym.name );

	mov	r8, QWORD PTR [rbx+8]
	lea	rdx, OFFSET FLAT:szStructure
	mov	ecx, 139				; 0000008bH
	call	EmitErr
$LN5@EndstructD:

; 489  :             }
; 490  :             DebugMsg(("EndstructDirective: delete the redefinition of %s\n", dir->sym.name ));
; 491  :             SymFree( (struct asym *)dir );

	mov	rcx, rbx
	call	SymFree

; 492  :             redef_struct = NULL;

	mov	QWORD PTR redef_struct, 0

; 493  :         }
; 494  :     } else {

	jmp	SHORT $LN47@EndstructD
$LN7@EndstructD:

; 495  : 
; 496  :         if ( dir->sym.max_mbr_size > CurrStruct->sym.max_mbr_size )

	mov	eax, DWORD PTR [rbx+56]
	cmp	eax, DWORD PTR [rcx+56]
	jbe	SHORT $LN3@EndstructD

; 497  :             CurrStruct->sym.max_mbr_size = dir->sym.max_mbr_size;

	mov	DWORD PTR [rcx+56], eax
	mov	rcx, QWORD PTR CurrStruct
$LN3@EndstructD:

; 498  : 
; 499  :         UpdateStructSize( (struct asym *)dir );

	cmp	BYTE PTR [rcx+74], 2
	jne	SHORT $LN50@EndstructD
	mov	eax, DWORD PTR [rbx+64]
	cmp	eax, DWORD PTR [rcx+64]
	jbe	SHORT $LN47@EndstructD
	mov	DWORD PTR [rcx+64], eax
	jmp	SHORT $LN47@EndstructD
$LN50@EndstructD:
	mov	eax, DWORD PTR [rbx+64]
	add	DWORD PTR [rcx+16], eax
	mov	rax, QWORD PTR CurrStruct
	mov	ecx, DWORD PTR [rax+16]
	cmp	ecx, DWORD PTR [rax+64]
	jle	SHORT $LN47@EndstructD
	mov	DWORD PTR [rax+64], ecx
$LN47@EndstructD:

; 500  :         DebugMsg1(("EndstructDirective: new size of restored structure=%u\n", CurrStruct->sym.total_size));
; 501  :     }
; 502  :     //dir->sym.max_mbr_size = 0;
; 503  :     if (dir->sym.state == SYM_TYPE)

	cmp	DWORD PTR [rbx+40], 7
	jne	SHORT $LN2@EndstructD

; 504  :     {  
; 505  :            dir->e.structinfo->isHomogenous = 0;

	mov	rax, QWORD PTR [rbx+104]

; 506  :            SymSimd(dir);

	mov	rcx, rbx
	mov	BYTE PTR [rax+20], 0
	call	SymSimd
$LN2@EndstructD:

; 507  :     }
; 508  :     if ( tokenarray[i].token != T_FINAL ) {

	movsxd	rdx, esi
	shl	rdx, 5
	cmp	BYTE PTR [rdx+rbp], 0
	je	$LN32@EndstructD

; 509  :         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );

	mov	rdx, QWORD PTR [rdx+rbp+8]
	mov	ecx, 209				; 000000d1H
	jmp	SHORT $LN57@EndstructD
$LN37@EndstructD:

; 403  :         ;
; 404  :     } else {
; 405  :         /* v2.04: error msg improved */
; 406  :         //EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr );
; 407  :         return( EmitErr( UNMATCHED_BLOCK_NESTING, i == 1 ? tokenarray[0].string_ptr : "" ) );

	lea	rdx, OFFSET FLAT:$SG5828
$LN38@EndstructD:
	mov	ecx, 142				; 0000008eH
$LN57@EndstructD:
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 510  :     }
; 511  :     return( NOT_ERROR );
; 512  : }

	add	rsp, 56					; 00000038H
	jmp	EmitErr
EndstructDirective ENDP
_TEXT	ENDS
END
