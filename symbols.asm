; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.40310.41 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

EXTRN	UpdateWordSize:NEAR
EXTRN	LineCur:QWORD
EXTRN	UpdateLineNumber:NEAR
EXTRN	UpdateCurPC:NEAR
EXTRN	symCurSeg:QWORD
EXTRN	FileCur:QWORD
EXTRN	ModuleInfo:BYTE
_BSS	SEGMENT
$SG5762	DB	01H DUP (?)
	ALIGN	8

symPC	DQ	01H DUP (?)
$SG5695	DB	01H DUP (?)
	ALIGN	4

szTime	DB	0cH DUP (?)
szDate	DB	0cH DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	decoflags:BYTE
COMM	SymCmpFunc:QWORD
COMM	MODULEARCH:BYTE
COMM	broadflags:BYTE
COMM	ZEROLOCALS:BYTE
COMM	evex:BYTE
$SG5683	DB	'@Version', 00H
	ORG $+3
$SG5684	DB	'800', 00H
$SG5686	DB	'@Date', 00H
	ORG $+2
$SG5688	DB	'@Time', 00H
	ORG $+2
$SG5690	DB	'@FileName', 00H
	ORG $+6
$SG5692	DB	'@FileCur', 00H
	ORG $+7
$SG5694	DB	'@CurSeg', 00H
_DATA	ENDS
CONST	SEGMENT
tmtab	DQ	FLAT:$SG5683
	DQ	FLAT:$SG5684
	DQ	0000000000000000H
	DQ	FLAT:$SG5686
	DQ	FLAT:szDate
	DQ	0000000000000000H
	DQ	FLAT:$SG5688
	DQ	FLAT:szTime
	DQ	0000000000000000H
	DQ	FLAT:$SG5690
	DQ	FLAT:ModuleInfo+512
	DQ	0000000000000000H
	DQ	FLAT:$SG5692
	DQ	0000000000000000H
	DQ	FLAT:FileCur
	DQ	FLAT:$SG5694
	DQ	FLAT:$SG5695
	DQ	FLAT:symCurSeg
CONST	ENDS
_DATA	SEGMENT
$SG5704	DB	'__HJWASM__', 00H
	ORG $+5
$SG5707	DB	'__JWASM__', 00H
	ORG $+2
$SG5710	DB	'$', 00H
	ORG $+2
$SG5711	DB	'@Line', 00H
	ORG $+2
$SG5712	DB	'@ProcLine', 00H
	ORG $+6
$SG5715	DB	'@WordSize', 00H
_DATA	ENDS
CONST	SEGMENT
eqtab	DQ	FLAT:$SG5704
	DD	0deH
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:$SG5707
	DD	0d4H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:$SG5710
	DD	00H
	ORG $+4
	DQ	FLAT:UpdateCurPC
	DQ	FLAT:symPC
	DQ	FLAT:$SG5711
	DD	00H
	ORG $+4
	DQ	FLAT:UpdateLineNumber
	DQ	FLAT:LineCur
	DQ	FLAT:$SG5712
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:$SG5715
	DD	00H
	ORG $+4
	DQ	FLAT:UpdateWordSize
	DQ	0000000000000000H
CONST	ENDS
_DATA	SEGMENT
	ORG $+6
$SG5884	DB	'%02u/%02u/%02u', 00H
	ORG $+1
$SG5885	DB	'%02u:%02u:%02u', 00H
	ORG $+1
$SG5969	DB	'__m128', 00H
	ORG $+1
$SG5970	DB	'__m256', 00H
	ORG $+1
$SG6035	DB	'wb', 00H
	ORG $+1
$SG6045	DB	'S', 00H
	ORG $+2
$SG6048	DB	'T', 00H
	ORG $+2
$SG6051	DB	'P', 00H
	ORG $+2
$SG6053	DB	'L', 00H
; Function compile flags: /Ogtpy
; File d:\hjwasm\hjwasm2.13.1s\hjwasm2.13.1s\symbols.c
_DATA	ENDS
_TEXT	SEGMENT
s$ = 8
hashpjw	PROC NEAR

; 151  :     unsigned h;
; 152  :     unsigned g;
; 153  : 
; 154  : #if HASH_MAGNITUDE==12
; 155  :     for( h = 0; *s; ++s ) {
; 156  :         h = (h << 4) + (*s | ' ');
; 157  :         g = h & ~0x0fff;
; 158  :         h ^= g;
; 159  :         h ^= g >> 12;
; 160  :     }
; 161  : #else
; 162  :     for( h = 0; *s; ++s ) {

	movzx	eax, BYTE PTR [rcx]
	xor	r8d, r8d
	mov	r9, rcx
	test	al, al
	je	SHORT $LN8@hashpjw
	npad	3
$LL3@hashpjw:

; 163  :         h = (h << 5) + (*s | ' ');

	movsx	edx, al
	mov	eax, r8d
	inc	r9
	or	edx, 32					; 00000020H
	shl	eax, 5
	lea	r8d, DWORD PTR [rax+rdx]
	mov	al, BYTE PTR [r9]

; 164  :         g = h & ~0x7fff;

	mov	edx, r8d
	and	edx, -32768				; ffff8000H

; 165  :         h ^= g;
; 166  :         h ^= g >> 15;

	mov	ecx, edx
	shr	ecx, 15
	xor	ecx, edx
	xor	r8d, ecx
	test	al, al
	jne	SHORT $LL3@hashpjw
$LN8@hashpjw:

; 167  :     }
; 168  : #endif
; 169  :     return( h );

	mov	eax, r8d

; 170  : }

	ret	0
hashpjw	ENDP
_TEXT	ENDS
PUBLIC	SymSetCmpFunc
EXTRN	memcmp:NEAR
EXTRN	_memicmp:NEAR
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
SymSetCmpFunc PROC NEAR

; 175  :     SymCmpFunc = ( ModuleInfo.case_sensitive == TRUE ? memcmp : (StrCmpFunc)_memicmp );

	mov	eax, DWORD PTR ModuleInfo+408
	lea	rcx, OFFSET FLAT:_memicmp
	lea	rdx, OFFSET FLAT:memcmp
	and	al, 2
	cmp	al, 2
	cmove	rcx, rdx
	mov	QWORD PTR SymCmpFunc, rcx

; 176  :     return;
; 177  : }

	ret	0
SymSetCmpFunc ENDP
_TEXT	ENDS
PUBLIC	SymClearLocal
EXTRN	memset:NEAR
_BSS	SEGMENT
	ALIGN	8

lsym_table DQ	07fH DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
_TEXT	SEGMENT
SymClearLocal PROC NEAR

; 184  :     memset( &lsym_table, 0, sizeof( lsym_table ) );

	lea	rcx, OFFSET FLAT:lsym_table
	xor	edx, edx
	mov	r8d, 1016				; 000003f8H

; 185  :     return;
; 186  : }

	jmp	memset
SymClearLocal ENDP
_TEXT	ENDS
PUBLIC	SymGetLocal
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
proc$ = 8
SymGetLocal PROC NEAR

; 193  :     int i;
; 194  :     struct dsym  **l = &((struct dsym *)proc)->e.procinfo->labellist;

	mov	rdx, QWORD PTR [rcx+104]
	lea	rax, OFFSET FLAT:lsym_table
	lea	r8, OFFSET FLAT:lsym_table+1016
	add	rdx, 24
$LL4@SymGetLoca:

; 195  : 
; 196  :     for ( i = 0; i < LHASH_TABLE_SIZE; i++ ) {
; 197  :         if ( lsym_table[i] ) {

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN3@SymGetLoca

; 198  :             *l = (struct dsym *)lsym_table[i];

	mov	QWORD PTR [rdx], rcx

; 199  :             l = &(*l)->e.nextll;

	lea	rdx, QWORD PTR [rcx+104]
$LN3@SymGetLoca:
	add	rax, 8
	cmp	rax, r8
	jl	SHORT $LL4@SymGetLoca

; 200  :         }
; 201  :     }
; 202  :     *l = NULL;

	mov	QWORD PTR [rdx], 0

; 203  : 
; 204  :     return;
; 205  : }

	ret	0
SymGetLocal ENDP
_TEXT	ENDS
PUBLIC	SymSetLocal
xdata	SEGMENT
$unwind$SymSetLocal DD 010401H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SymSetLocal DD @imagerel($LN17#)
	DD	@imagerel($LN17#+4)
	DD	@imagerel($unwind$SymSetLocal#)
pdata	ENDS
xdata	SEGMENT
$chain$1$SymSetLocal DD 040d21H
	DD	09740dH
	DD	083405H
	DD	@imagerel($LN17#)
	DD	@imagerel($LN17#+4)
	DD	@imagerel($unwind$SymSetLocal#)
xdata	ENDS
pdata	SEGMENT
$pdata$1$SymSetLocal DD @imagerel($LN17#+4)
	DD	@imagerel($LN17#+64)
	DD	@imagerel($chain$1$SymSetLocal#)
pdata	ENDS
xdata	SEGMENT
$chain$2$SymSetLocal DD 020021H
	DD	097400H
	DD	@imagerel($LN17#)
	DD	@imagerel($LN17#+4)
	DD	@imagerel($unwind$SymSetLocal#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$SymSetLocal DD @imagerel($LN17#+64)
	DD	@imagerel($LN17#+174)
	DD	@imagerel($chain$2$SymSetLocal#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
proc$ = 48
SymSetLocal PROC NEAR

; 215  : {

$LN17:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rbx
	mov	rbx, rcx
	mov	QWORD PTR [rsp+72], rdi

; 216  :     int i;
; 217  :     struct dsym *l;
; 218  : 
; 219  :     SymClearLocal();

	lea	rdi, OFFSET FLAT:lsym_table
	xor	edx, edx
	mov	r8d, 1016				; 000003f8H
	mov	rcx, rdi
	call	memset

; 220  :     for ( l = ((struct dsym *)proc)->e.procinfo->labellist; l; l = l->e.nextll ) {

	mov	r11, QWORD PTR [rbx+104]
	mov	rbx, QWORD PTR [rsp+64]
	mov	r9, QWORD PTR [r11+24]
	test	r9, r9
	je	SHORT $LN1@SymSetLoca
	npad	6
$LL3@SymSetLoca:

; 221  :         DebugMsg1(("SymSetLocal(%s): label=%s\n", proc->name, l->sym.name ));
; 222  :         i = hashpjw( l->sym.name ) % LHASH_TABLE_SIZE;

	mov	rdx, QWORD PTR [r9+8]
	xor	r8d, r8d
	movzx	eax, BYTE PTR [rdx]
	test	al, al
	je	SHORT $LN8@SymSetLoca
	npad	2
$LL10@SymSetLoca:
	movsx	ecx, al
	shl	r8d, 5
	inc	rdx
	or	ecx, 32					; 00000020H
	add	r8d, ecx
	mov	ecx, r8d
	and	ecx, -32768				; ffff8000H
	mov	eax, ecx
	shr	eax, 15
	xor	eax, ecx
	xor	r8d, eax
	mov	al, BYTE PTR [rdx]
	test	al, al
	jne	SHORT $LL10@SymSetLoca
$LN8@SymSetLoca:
	mov	eax, 33818641				; 02040811H

; 223  :         lsym_table[i] = &l->sym;

	movsxd	rcx, r8d
	mul	r8d
	mov	eax, r8d
	sub	eax, edx
	shr	eax, 1
	add	eax, edx
	shr	eax, 6
	imul	rax, 127				; 0000007fH
	sub	rcx, rax
	mov	QWORD PTR [rdi+rcx*8], r9
	mov	r9, QWORD PTR [r9+104]
	test	r9, r9
	jne	SHORT $LL3@SymSetLoca
$LN1@SymSetLoca:
	mov	rdi, QWORD PTR [rsp+72]

; 224  :     }
; 225  :     return;
; 226  : }

	add	rsp, 40					; 00000028H
	ret	0
SymSetLocal ENDP
_TEXT	ENDS
PUBLIC	SymAlloc
EXTRN	EmitError:NEAR
EXTRN	LclAlloc:NEAR
EXTRN	memcpy:NEAR
xdata	SEGMENT
$unwind$SymAlloc DD 071601H
	DD	097416H
	DD	08640eH
	DD	073409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SymAlloc DD @imagerel($LN7#)
	DD	@imagerel($LN7#+203)
	DD	@imagerel($unwind$SymAlloc#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
SymAlloc PROC NEAR

; 230  : {

$LN7:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, rcx
	mov	QWORD PTR [rsp+72], rdi

; 231  :     int len = strlen( name );

	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rsi
	repne scasb
	not	rcx
	lea	rdi, QWORD PTR [rcx-1]

; 232  :     struct asym *sym;
; 233  : 
; 234  :     sym = LclAlloc( sizeof( struct dsym ) );

	mov	ecx, 128				; 00000080H
	call	LclAlloc

; 235  :     memset( sym, 0, sizeof( struct dsym ) );

	xor	edx, edx
	mov	r8d, 128				; 00000080H
	mov	rcx, rax
	mov	rbx, rax
	call	memset

; 236  : #if 1
; 237  :     /* the tokenizer ensures that identifiers are within limits, so
; 238  :      * this check probably is redundant */
; 239  :     if( len > MAX_ID_LEN ) {

	cmp	edi, 247				; 000000f7H
	jle	SHORT $LN3@SymAlloc

; 240  :         EmitError( IDENTIFIER_TOO_LONG );

	mov	ecx, 70					; 00000046H
	call	EmitError

; 241  :         len = MAX_ID_LEN;

	mov	edi, 247				; 000000f7H
$LN3@SymAlloc:

; 242  :     }
; 243  : #endif
; 244  :     sym->name_size = len;

	mov	BYTE PTR [rbx+80], dil

; 245  :     sym->list = ModuleInfo.cref;

	mov	eax, DWORD PTR ModuleInfo+408

; 246  :     sym->mem_type = MT_EMPTY;

	mov	DWORD PTR [rbx+44], 192			; 000000c0H
	shr	eax, 13
	xor	al, BYTE PTR [rbx+49]
	and	al, 1
	xor	BYTE PTR [rbx+49], al

; 247  :     if ( len ) {

	test	edi, edi
	je	SHORT $LN2@SymAlloc

; 248  :         sym->name = LclAlloc( len + 1 );

	lea	eax, DWORD PTR [rdi+1]
	movsxd	rcx, eax
	call	LclAlloc

; 249  :         memcpy( sym->name, name, len );

	movsxd	rdi, edi
	mov	rdx, rsi
	mov	rcx, rax
	mov	r8, rdi
	mov	QWORD PTR [rbx+8], rax
	call	memcpy

; 250  :         sym->name[len] = NULLC;

	mov	rdx, QWORD PTR [rbx+8]
	mov	BYTE PTR [rdi+rdx], 0

; 251  :     } else

	jmp	SHORT $LN6@SymAlloc
$LN2@SymAlloc:

; 252  :         sym->name = "";

	lea	rax, OFFSET FLAT:$SG5762
	mov	QWORD PTR [rbx+8], rax
$LN6@SymAlloc:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]

; 253  :     return( sym );

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]

; 254  : }

	add	rsp, 40					; 00000028H
	ret	0
SymAlloc ENDP
_TEXT	ENDS
PUBLIC	SymFind
EXTRN	__ImageBase:BYTE
EXTRN	CurrProc:QWORD
_BSS	SEGMENT
gsym	DQ	01H DUP (?)
gsym_table DQ	01f49H DUP (?)
lsym	DQ	01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$SymFind DD 097301H
	DD	075473H
	DD	097418H
	DD	086410H
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SymFind DD @imagerel($LN25#)
	DD	@imagerel($LN25#+399)
	DD	@imagerel($unwind$SymFind#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
SymFind	PROC NEAR

; 264  : {

$LN25:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx

; 265  :     int i;
; 266  :     int len;
; 267  : 
; 268  :     len = strlen( name );

	xor	eax, eax
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, rcx
	mov	QWORD PTR [rsp+72], rdi
	mov	rcx, -1
	mov	rdi, rsi

; 269  :     i = hashpjw( name );

	xor	ebx, ebx
	mov	r8, rsi
	repne scasb
	movzx	eax, BYTE PTR [rsi]
	test	al, al
	not	rcx
	lea	rdi, QWORD PTR [rcx-1]
	je	SHORT $LN12@SymFind
	npad	9
$LL14@SymFind:
	movsx	edx, al
	shl	ebx, 5
	inc	r8
	or	edx, 32					; 00000020H
	add	ebx, edx
	mov	ecx, ebx
	and	ecx, -32768				; ffff8000H
	mov	eax, ecx
	shr	eax, 15
	xor	eax, ecx
	xor	ebx, eax
	mov	al, BYTE PTR [r8]
	test	al, al
	jne	SHORT $LL14@SymFind
$LN12@SymFind:

; 270  : 
; 271  :     if ( CurrProc ) {

	cmp	QWORD PTR CurrProc, 0
	mov	QWORD PTR [rsp+56], rbp
	lea	rbp, OFFSET FLAT:__ImageBase
	je	SHORT $LN6@SymFind

; 272  :         for( lsym = &lsym_table[ i % LHASH_TABLE_SIZE ]; *lsym; lsym = &((*lsym)->nextitem ) ) {

	mov	eax, -2130574327			; ffffffff81020409H
	imul	ebx
	add	edx, ebx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	mov	eax, ebx
	imul	edx, 127				; 0000007fH
	sub	eax, edx
	movsxd	rcx, eax
	lea	rcx, QWORD PTR lsym_table[rbp+rcx*8]
	mov	QWORD PTR lsym, rcx
	mov	rdx, QWORD PTR [rcx]
	test	rdx, rdx
	je	SHORT $LN6@SymFind
$LL8@SymFind:

; 273  :             if ( len == (*lsym)->name_size && SYMCMP( name, (*lsym)->name, len ) == 0 ) {

	movzx	eax, BYTE PTR [rdx+80]
	cmp	edi, eax
	jne	SHORT $LN7@SymFind
	mov	rdx, QWORD PTR [rdx+8]
	movsxd	r8, edi
	mov	rcx, rsi
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	$LN20@SymFind
	mov	rcx, QWORD PTR lsym
$LN7@SymFind:

; 272  :         for( lsym = &lsym_table[ i % LHASH_TABLE_SIZE ]; *lsym; lsym = &((*lsym)->nextitem ) ) {

	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR lsym, rcx
	mov	rdx, QWORD PTR [rcx]
	test	rdx, rdx
	jne	SHORT $LL8@SymFind
$LN6@SymFind:

; 277  :             }
; 278  :         }
; 279  :     }
; 280  : 
; 281  :     for( gsym = &gsym_table[ i % GHASH_TABLE_SIZE ]; *gsym; gsym = &((*gsym)->nextitem ) ) {

	mov	eax, -2098415161			; ffffffff82ecb9c7H
	imul	ebx
	add	edx, ebx
	sar	edx, 12
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	imul	edx, 8009				; 00001f49H
	sub	ebx, edx
	movsxd	rax, ebx
	lea	rcx, QWORD PTR gsym_table[rbp+rax*8]
	mov	QWORD PTR gsym, rcx
	mov	rdx, QWORD PTR [rcx]
	test	rdx, rdx
	je	SHORT $LN2@SymFind
	npad	2
$LL4@SymFind:

; 282  :         if ( len == (*gsym)->name_size && SYMCMP( name, (*gsym)->name, len ) == 0 ) {

	movzx	eax, BYTE PTR [rdx+80]
	cmp	edi, eax
	jne	SHORT $LN3@SymFind
	mov	rdx, QWORD PTR [rdx+8]
	movsxd	r8, edi
	mov	rcx, rsi
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	SHORT $LN21@SymFind
	mov	rcx, QWORD PTR gsym
$LN3@SymFind:

; 277  :             }
; 278  :         }
; 279  :     }
; 280  : 
; 281  :     for( gsym = &gsym_table[ i % GHASH_TABLE_SIZE ]; *gsym; gsym = &((*gsym)->nextitem ) ) {

	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR gsym, rcx
	mov	rdx, QWORD PTR [rcx]
	test	rdx, rdx
	jne	SHORT $LL4@SymFind
$LN2@SymFind:

; 285  :         }
; 286  :     }
; 287  : 
; 288  :     return( NULL );

	xor	eax, eax
$LN10@SymFind:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 289  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN20@SymFind:

; 274  :                 DebugMsg1(("SymFind(%s): found in local table, state=%u, local=%u\n", name, (*lsym)->state, (*lsym)->scoped ));  			
; 275  : 				(*lsym)->used = TRUE;

	mov	rax, QWORD PTR lsym
	mov	rcx, QWORD PTR [rax]
	or	BYTE PTR [rcx+48], 1

; 276  :                 return( *lsym );

	mov	rax, QWORD PTR [rax]
	jmp	SHORT $LN10@SymFind
$LN21@SymFind:

; 283  :             DebugMsg1(("SymFind(%s): found, state=%u memtype=%X lang=%u\n", name, (*gsym)->state, (*gsym)->mem_type, (*gsym)->langtype ));
; 284  :             return( *gsym );

	mov	rax, QWORD PTR gsym
	mov	rax, QWORD PTR [rax]
	jmp	SHORT $LN10@SymFind
SymFind	ENDP
_TEXT	ENDS
PUBLIC	SymFindDeclare
xdata	SEGMENT
$unwind$SymFindDeclare DD 097301H
	DD	075473H
	DD	097418H
	DD	086410H
	DD	063409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SymFindDeclare DD @imagerel($LN25#)
	DD	@imagerel($LN25#+392)
	DD	@imagerel($unwind$SymFindDeclare#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
SymFindDeclare PROC NEAR

; 300  : {

$LN25:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+48], rbx

; 301  : 	int i;
; 302  : 	int len;
; 303  : 
; 304  : 	len = strlen(name);

	xor	eax, eax
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, rcx
	mov	QWORD PTR [rsp+72], rdi
	mov	rcx, -1
	mov	rdi, rsi

; 305  : 	i = hashpjw(name);

	xor	ebx, ebx
	mov	r8, rsi
	repne scasb
	movzx	eax, BYTE PTR [rsi]
	test	al, al
	not	rcx
	lea	rdi, QWORD PTR [rcx-1]
	je	SHORT $LN12@SymFindDec
	npad	9
$LL14@SymFindDec:
	movsx	edx, al
	shl	ebx, 5
	inc	r8
	or	edx, 32					; 00000020H
	add	ebx, edx
	mov	ecx, ebx
	and	ecx, -32768				; ffff8000H
	mov	eax, ecx
	shr	eax, 15
	xor	eax, ecx
	xor	ebx, eax
	mov	al, BYTE PTR [r8]
	test	al, al
	jne	SHORT $LL14@SymFindDec
$LN12@SymFindDec:

; 306  : 
; 307  : 	if (CurrProc) {

	cmp	QWORD PTR CurrProc, 0
	mov	QWORD PTR [rsp+56], rbp
	lea	rbp, OFFSET FLAT:__ImageBase
	je	SHORT $LN6@SymFindDec

; 308  : 		for (lsym = &lsym_table[i % LHASH_TABLE_SIZE]; *lsym; lsym = &((*lsym)->nextitem)) {

	mov	eax, -2130574327			; ffffffff81020409H
	imul	ebx
	add	edx, ebx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	mov	eax, ebx
	imul	edx, 127				; 0000007fH
	sub	eax, edx
	movsxd	rcx, eax
	lea	rcx, QWORD PTR lsym_table[rbp+rcx*8]
	mov	QWORD PTR lsym, rcx
	mov	rdx, QWORD PTR [rcx]
	test	rdx, rdx
	je	SHORT $LN6@SymFindDec
$LL8@SymFindDec:

; 309  : 			if (len == (*lsym)->name_size && SYMCMP(name, (*lsym)->name, len) == 0) {

	movzx	eax, BYTE PTR [rdx+80]
	cmp	edi, eax
	jne	SHORT $LN7@SymFindDec
	mov	rdx, QWORD PTR [rdx+8]
	movsxd	r8, edi
	mov	rcx, rsi
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	$LN20@SymFindDec
	mov	rcx, QWORD PTR lsym
$LN7@SymFindDec:

; 308  : 		for (lsym = &lsym_table[i % LHASH_TABLE_SIZE]; *lsym; lsym = &((*lsym)->nextitem)) {

	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR lsym, rcx
	mov	rdx, QWORD PTR [rcx]
	test	rdx, rdx
	jne	SHORT $LL8@SymFindDec
$LN6@SymFindDec:

; 312  : 			}
; 313  : 		}
; 314  : 	}
; 315  : 
; 316  : 	for (gsym = &gsym_table[i % GHASH_TABLE_SIZE]; *gsym; gsym = &((*gsym)->nextitem)) {

	mov	eax, -2098415161			; ffffffff82ecb9c7H
	imul	ebx
	add	edx, ebx
	sar	edx, 12
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	imul	edx, 8009				; 00001f49H
	sub	ebx, edx
	movsxd	rax, ebx
	lea	rcx, QWORD PTR gsym_table[rbp+rax*8]
	mov	QWORD PTR gsym, rcx
	mov	rdx, QWORD PTR [rcx]
	test	rdx, rdx
	je	SHORT $LN2@SymFindDec
	npad	2
$LL4@SymFindDec:

; 317  : 		if (len == (*gsym)->name_size && SYMCMP(name, (*gsym)->name, len) == 0) {

	movzx	eax, BYTE PTR [rdx+80]
	cmp	edi, eax
	jne	SHORT $LN3@SymFindDec
	mov	rdx, QWORD PTR [rdx+8]
	movsxd	r8, edi
	mov	rcx, rsi
	call	QWORD PTR SymCmpFunc
	test	eax, eax
	je	SHORT $LN21@SymFindDec
	mov	rcx, QWORD PTR gsym
$LN3@SymFindDec:

; 312  : 			}
; 313  : 		}
; 314  : 	}
; 315  : 
; 316  : 	for (gsym = &gsym_table[i % GHASH_TABLE_SIZE]; *gsym; gsym = &((*gsym)->nextitem)) {

	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR gsym, rcx
	mov	rdx, QWORD PTR [rcx]
	test	rdx, rdx
	jne	SHORT $LL4@SymFindDec
$LN2@SymFindDec:

; 320  : 		}
; 321  : 	}
; 322  : 
; 323  : 	return(NULL);

	xor	eax, eax
$LN10@SymFindDec:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]

; 324  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN20@SymFindDec:

; 310  : 				DebugMsg1(("SymFind(%s): found in local table, state=%u, local=%u\n", name, (*lsym)->state, (*lsym)->scoped));
; 311  : 				return(*lsym);

	mov	rax, QWORD PTR lsym
	mov	rax, QWORD PTR [rax]
	jmp	SHORT $LN10@SymFindDec
$LN21@SymFindDec:

; 318  : 			DebugMsg1(("SymFind(%s): found, state=%u memtype=%X lang=%u\n", name, (*gsym)->state, (*gsym)->mem_type, (*gsym)->langtype));
; 319  : 			return(*gsym);

	mov	rax, QWORD PTR gsym
	mov	rax, QWORD PTR [rax]
	jmp	SHORT $LN10@SymFindDec
SymFindDeclare ENDP
_TEXT	ENDS
PUBLIC	SymLookup
_BSS	SEGMENT
SymCount DD	01H DUP (?)
_BSS	ENDS
xdata	SEGMENT
$unwind$SymLookup DD 030901H
	DD	086409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SymLookup DD @imagerel($LN10#)
	DD	@imagerel($LN10#+26)
	DD	@imagerel($unwind$SymLookup#)
pdata	ENDS
xdata	SEGMENT
$chain$2$SymLookup DD 040a21H
	DD	09740aH
	DD	073405H
	DD	@imagerel($LN10#)
	DD	@imagerel($LN10#+26)
	DD	@imagerel($unwind$SymLookup#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$SymLookup DD @imagerel($LN10#+26)
	DD	@imagerel($LN10#+221)
	DD	@imagerel($chain$2$SymLookup#)
pdata	ENDS
xdata	SEGMENT
$chain$3$SymLookup DD 021H
	DD	@imagerel($LN10#)
	DD	@imagerel($LN10#+26)
	DD	@imagerel($unwind$SymLookup#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$SymLookup DD @imagerel($LN10#+221)
	DD	@imagerel($LN10#+231)
	DD	@imagerel($chain$3$SymLookup#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
SymLookup PROC NEAR

; 340  : {

$LN10:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, rcx

; 341  :     struct asym      *sym;
; 342  : 
; 343  :     sym = SymFind( name );

	call	SymFind

; 344  :     if( sym == NULL ) {

	test	rax, rax
	jne	$LN9@SymLookup
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+72], rdi

; 345  :         sym = SymAlloc( name );

	mov	rcx, -1
	mov	rdi, rsi
	repne scasb
	not	rcx
	lea	rdi, QWORD PTR [rcx-1]
	mov	ecx, 128				; 00000080H
	call	LclAlloc
	xor	edx, edx
	mov	r8d, 128				; 00000080H
	mov	rcx, rax
	mov	rbx, rax
	call	memset
	cmp	edi, 247				; 000000f7H
	jle	SHORT $LN6@SymLookup
	mov	ecx, 70					; 00000046H
	call	EmitError
	mov	edi, 247				; 000000f7H
$LN6@SymLookup:
	mov	BYTE PTR [rbx+80], dil
	mov	eax, DWORD PTR ModuleInfo+408
	mov	DWORD PTR [rbx+44], 192			; 000000c0H
	shr	eax, 13
	xor	al, BYTE PTR [rbx+49]
	and	al, 1
	xor	BYTE PTR [rbx+49], al
	test	edi, edi
	je	SHORT $LN5@SymLookup
	lea	eax, DWORD PTR [rdi+1]
	movsxd	rcx, eax
	call	LclAlloc
	movsxd	rdi, edi
	mov	rdx, rsi
	mov	rcx, rax
	mov	r8, rdi
	mov	QWORD PTR [rbx+8], rax
	call	memcpy
	mov	rdx, QWORD PTR [rbx+8]
	mov	BYTE PTR [rdi+rdx], 0
	jmp	SHORT $LN4@SymLookup
$LN5@SymLookup:
	lea	rax, OFFSET FLAT:$SG5762
	mov	QWORD PTR [rbx+8], rax
$LN4@SymLookup:

; 346  :         DebugMsg1(("SymLookup(%s): created new symbol, CurrProc=%s\n", name, CurrProc ? CurrProc->sym.name : "NULL" ));
; 347  :         //sym->next = *gsym;
; 348  :         *gsym = sym;

	mov	rcx, QWORD PTR gsym

; 349  :         ++SymCount;

	inc	DWORD PTR SymCount
	mov	rdi, QWORD PTR [rsp+72]
	mov	QWORD PTR [rcx], rbx

; 350  :     }
; 351  : 
; 352  :     DebugMsg1(("SymLookup(%s): found, state=%u, defined=%u\n", name, sym->state, sym->isdefined));
; 353  : 
; 354  :     return( sym );

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
$LN9@SymLookup:
	mov	rsi, QWORD PTR [rsp+64]

; 355  : }

	add	rsp, 40					; 00000028H
	ret	0
SymLookup ENDP
_TEXT	ENDS
PUBLIC	SymLookupLocal
xdata	SEGMENT
$unwind$SymLookupLocal DD 030901H
	DD	086409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SymLookupLocal DD @imagerel($LN13#)
	DD	@imagerel($LN13#+29)
	DD	@imagerel($unwind$SymLookupLocal#)
pdata	ENDS
xdata	SEGMENT
$chain$2$SymLookupLocal DD 040a21H
	DD	09740aH
	DD	073405H
	DD	@imagerel($LN13#)
	DD	@imagerel($LN13#+29)
	DD	@imagerel($unwind$SymLookupLocal#)
xdata	ENDS
pdata	SEGMENT
$pdata$2$SymLookupLocal DD @imagerel($LN13#+29)
	DD	@imagerel($LN13#+232)
	DD	@imagerel($chain$2$SymLookupLocal#)
pdata	ENDS
xdata	SEGMENT
$chain$3$SymLookupLocal DD 021H
	DD	@imagerel($LN13#)
	DD	@imagerel($LN13#+29)
	DD	@imagerel($unwind$SymLookupLocal#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$SymLookupLocal DD @imagerel($LN13#+232)
	DD	@imagerel($LN13#+298)
	DD	@imagerel($chain$3$SymLookupLocal#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
SymLookupLocal PROC NEAR

; 362  : {

$LN13:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, rcx

; 363  :     //struct asym      **sym_ptr;
; 364  :     struct asym      *sym;
; 365  : 
; 366  :     sym = SymFind( name );

	call	SymFind

; 367  :     if ( sym == NULL ) {

	test	rax, rax
	mov	rdx, rax
	jne	$LN3@SymLookupL
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+72], rdi

; 368  :         sym = SymAlloc( name );

	mov	rcx, -1
	mov	rdi, rsi
	repne scasb
	not	rcx
	lea	rdi, QWORD PTR [rcx-1]
	mov	ecx, 128				; 00000080H
	call	LclAlloc
	xor	edx, edx
	mov	r8d, 128				; 00000080H
	mov	rcx, rax
	mov	rbx, rax
	call	memset
	cmp	edi, 247				; 000000f7H
	jle	SHORT $LN8@SymLookupL
	mov	ecx, 70					; 00000046H
	call	EmitError
	mov	edi, 247				; 000000f7H
$LN8@SymLookupL:
	mov	BYTE PTR [rbx+80], dil
	mov	eax, DWORD PTR ModuleInfo+408
	mov	DWORD PTR [rbx+44], 192			; 000000c0H
	shr	eax, 13
	xor	al, BYTE PTR [rbx+49]
	and	al, 1
	xor	BYTE PTR [rbx+49], al
	test	edi, edi
	je	SHORT $LN7@SymLookupL
	lea	eax, DWORD PTR [rdi+1]
	movsxd	rcx, eax
	call	LclAlloc
	movsxd	rdi, edi
	mov	rdx, rsi
	mov	rcx, rax
	mov	r8, rdi
	mov	QWORD PTR [rbx+8], rax
	call	memcpy
	mov	rdx, QWORD PTR [rbx+8]
	mov	BYTE PTR [rdi+rdx], 0
	jmp	SHORT $LN6@SymLookupL
$LN7@SymLookupL:
	lea	rax, OFFSET FLAT:$SG5762
	mov	QWORD PTR [rbx+8], rax
$LN6@SymLookupL:

; 369  :         sym->scoped = TRUE;

	or	BYTE PTR [rbx+48], 4

; 370  :         /* add the label to the local hash table */
; 371  :         //sym->next = *lsym;
; 372  :         *lsym = sym;

	mov	rcx, QWORD PTR lsym
	mov	rdi, QWORD PTR [rsp+72]
	mov	QWORD PTR [rcx], rbx

; 386  :         DebugMsg1(("SymLookupLocal(%s): label moved into %s's local namespace\n", sym->name, CurrProc->sym.name ));
; 387  :     }
; 388  : 
; 389  :     DebugMsg1(("SymLookupLocal(%s): found, state=%u, defined=%u\n", name, sym->state, sym->isdefined));
; 390  :     return( sym );

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]

; 391  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@SymLookupL:

; 373  :         DebugMsg1(("SymLookupLocal(%s): local symbol created in %s\n", name, CurrProc->sym.name));
; 374  :     } else if( sym->state == SYM_UNDEFINED && sym->scoped == FALSE ) {

	cmp	DWORD PTR [rax+40], 0
	jne	SHORT $LN1@SymLookupL
	test	BYTE PTR [rax+48], 4
	jne	SHORT $LN1@SymLookupL

; 375  :         /* if the label was defined due to a FORWARD reference,
; 376  :          * its scope is to be changed from global to local.
; 377  :          */
; 378  :         /* remove the label from the global hash table */
; 379  :         *gsym = sym->nextitem;

	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR gsym

; 380  :         SymCount--;

	add	DWORD PTR SymCount, -1			; ffffffffH
	mov	QWORD PTR [rax], rcx

; 381  :         sym->scoped = TRUE;
; 382  :         /* add the label to the local hash table */
; 383  :         //sym->next = *lsym;
; 384  :         sym->nextitem = NULL;
; 385  :         *lsym = sym;

	mov	rax, QWORD PTR lsym
	or	BYTE PTR [rdx+48], 4
	mov	QWORD PTR [rdx], 0
	mov	QWORD PTR [rax], rdx

; 386  :         DebugMsg1(("SymLookupLocal(%s): label moved into %s's local namespace\n", sym->name, CurrProc->sym.name ));
; 387  :     }
; 388  : 
; 389  :     DebugMsg1(("SymLookupLocal(%s): found, state=%u, defined=%u\n", name, sym->state, sym->isdefined));
; 390  :     return( sym );

	mov	rax, rdx
$LN1@SymLookupL:
	mov	rsi, QWORD PTR [rsp+64]

; 391  : }

	add	rsp, 40					; 00000028H
	ret	0
SymLookupLocal ENDP
_TEXT	ENDS
EXTRN	ReleaseMacroData:NEAR
EXTRN	DeleteType:NEAR
EXTRN	DeleteGroup:NEAR
EXTRN	DeleteProc:NEAR
xdata	SEGMENT
$unwind$free_ext DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$free_ext DD @imagerel(free_ext#)
	DD	@imagerel(free_ext#+168)
	DD	@imagerel($unwind$free_ext#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
free_ext PROC NEAR

; 397  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 398  :     DebugMsg(("free_ext: item=%p name=%s state=%u\n", sym, sym->name, sym->state ));
; 399  :     switch( sym->state ) {

	mov	eax, DWORD PTR [rcx+40]
	mov	rbx, rcx
	dec	eax
	cmp	eax, 9
	ja	SHORT $LN2@free_ext
	lea	rcx, OFFSET FLAT:__ImageBase
	cdqe
	mov	edx, DWORD PTR $LN16@free_ext[rcx+rax*4]
	add	rdx, rcx
	jmp	rdx
$LN11@free_ext:

; 400  :     case SYM_INTERNAL:
; 401  :         if ( sym->isproc )

	test	BYTE PTR [rbx+49], 8
	je	SHORT $LN2@free_ext

; 402  :             DeleteProc( (struct dsym *)sym );

	mov	rcx, rbx

; 431  :         LclFree( ((struct dsym *)sym)->e.macroinfo );
; 432  :         break;
; 433  :     case SYM_TMACRO:
; 434  :         if ( sym->predefined == FALSE )
; 435  :             LclFree( sym->string_ptr );
; 436  :         break;
; 437  : #ifdef DEBUG_OUT 
; 438  :     case SYM_STACK:
; 439  :         /* to be removed, this can't happen anymore. */
; 440  :         if ( sym->mem_type == MT_TYPE && *sym->type->name == NULLC ) { 
; 441  :             DebugMsg(( "free_ext: case SYM_STACK, sym=%s with private type\n", sym->name ));
; 442  :             /* symbol has a "private" type */
; 443  :             SymFree( sym->type );
; 444  :         }
; 445  :         break;
; 446  : #endif
; 447  :     }
; 448  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	DeleteProc
$LN9@free_ext:

; 403  :         break;
; 404  :     case SYM_EXTERNAL:
; 405  :         if ( sym->isproc )

	test	BYTE PTR [rbx+49], 8
	je	SHORT $LN8@free_ext

; 406  :             DeleteProc( (struct dsym *)sym );

	mov	rcx, rbx
	call	DeleteProc
$LN8@free_ext:

; 407  :         sym->first_size = 0;

	mov	DWORD PTR [rbx+52], 0

; 431  :         LclFree( ((struct dsym *)sym)->e.macroinfo );
; 432  :         break;
; 433  :     case SYM_TMACRO:
; 434  :         if ( sym->predefined == FALSE )
; 435  :             LclFree( sym->string_ptr );
; 436  :         break;
; 437  : #ifdef DEBUG_OUT 
; 438  :     case SYM_STACK:
; 439  :         /* to be removed, this can't happen anymore. */
; 440  :         if ( sym->mem_type == MT_TYPE && *sym->type->name == NULLC ) { 
; 441  :             DebugMsg(( "free_ext: case SYM_STACK, sym=%s with private type\n", sym->name ));
; 442  :             /* symbol has a "private" type */
; 443  :             SymFree( sym->type );
; 444  :         }
; 445  :         break;
; 446  : #endif
; 447  :     }
; 448  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN5@free_ext:

; 408  :         /* The altname field may contain a symbol (if weak == FALSE).
; 409  :          * However, this is an independant item and must not be released here
; 410  :          */
; 411  : #ifdef DEBUG_OUT /* to be removed, this can't happen anymore. */
; 412  :         if ( sym->mem_type == MT_TYPE && *sym->type->name == NULLC ) {
; 413  :             DebugMsg(( "free_ext: external with private type: %s\n", sym->name ));
; 414  :             SymFree( sym->type );
; 415  :         }
; 416  : #endif
; 417  :         break;
; 418  :     case SYM_SEG:
; 419  :         if ( ((struct dsym *)sym)->e.seginfo->internal )
; 420  :             LclFree( ((struct dsym *)sym)->e.seginfo->CodeBuffer );
; 421  :         LclFree( ((struct dsym *)sym)->e.seginfo );
; 422  :         break;
; 423  :     case SYM_GRP:
; 424  :         DeleteGroup( (struct dsym *)sym );

	mov	rcx, rbx

; 431  :         LclFree( ((struct dsym *)sym)->e.macroinfo );
; 432  :         break;
; 433  :     case SYM_TMACRO:
; 434  :         if ( sym->predefined == FALSE )
; 435  :             LclFree( sym->string_ptr );
; 436  :         break;
; 437  : #ifdef DEBUG_OUT 
; 438  :     case SYM_STACK:
; 439  :         /* to be removed, this can't happen anymore. */
; 440  :         if ( sym->mem_type == MT_TYPE && *sym->type->name == NULLC ) { 
; 441  :             DebugMsg(( "free_ext: case SYM_STACK, sym=%s with private type\n", sym->name ));
; 442  :             /* symbol has a "private" type */
; 443  :             SymFree( sym->type );
; 444  :         }
; 445  :         break;
; 446  : #endif
; 447  :     }
; 448  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	DeleteGroup
$LN4@free_ext:

; 425  :         break;
; 426  :     case SYM_TYPE:
; 427  :         DeleteType( (struct dsym *)sym );

	mov	rcx, rbx

; 431  :         LclFree( ((struct dsym *)sym)->e.macroinfo );
; 432  :         break;
; 433  :     case SYM_TMACRO:
; 434  :         if ( sym->predefined == FALSE )
; 435  :             LclFree( sym->string_ptr );
; 436  :         break;
; 437  : #ifdef DEBUG_OUT 
; 438  :     case SYM_STACK:
; 439  :         /* to be removed, this can't happen anymore. */
; 440  :         if ( sym->mem_type == MT_TYPE && *sym->type->name == NULLC ) { 
; 441  :             DebugMsg(( "free_ext: case SYM_STACK, sym=%s with private type\n", sym->name ));
; 442  :             /* symbol has a "private" type */
; 443  :             SymFree( sym->type );
; 444  :         }
; 445  :         break;
; 446  : #endif
; 447  :     }
; 448  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	DeleteType
$LN3@free_ext:

; 428  :         break;
; 429  :     case SYM_MACRO:
; 430  :         ReleaseMacroData( (struct dsym *)sym );

	mov	rcx, rbx
	call	ReleaseMacroData
$LN2@free_ext:

; 431  :         LclFree( ((struct dsym *)sym)->e.macroinfo );
; 432  :         break;
; 433  :     case SYM_TMACRO:
; 434  :         if ( sym->predefined == FALSE )
; 435  :             LclFree( sym->string_ptr );
; 436  :         break;
; 437  : #ifdef DEBUG_OUT 
; 438  :     case SYM_STACK:
; 439  :         /* to be removed, this can't happen anymore. */
; 440  :         if ( sym->mem_type == MT_TYPE && *sym->type->name == NULLC ) { 
; 441  :             DebugMsg(( "free_ext: case SYM_STACK, sym=%s with private type\n", sym->name ));
; 442  :             /* symbol has a "private" type */
; 443  :             SymFree( sym->type );
; 444  :         }
; 445  :         break;
; 446  : #endif
; 447  :     }
; 448  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
	npad	2
$LN16@free_ext:
	DD	$LN11@free_ext
	DD	$LN9@free_ext
	DD	$LN2@free_ext
	DD	$LN5@free_ext
	DD	$LN2@free_ext
	DD	$LN2@free_ext
	DD	$LN4@free_ext
	DD	$LN2@free_ext
	DD	$LN3@free_ext
	DD	$LN2@free_ext
free_ext ENDP
_TEXT	ENDS
PUBLIC	SymFree
xdata	SEGMENT
$unwind$SymFree DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$SymFree DD @imagerel($LN19#)
	DD	@imagerel($LN19#+168)
	DD	@imagerel($unwind$SymFree#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
SymFree	PROC NEAR

; 458  : {

$LN19:
	push	rbx
	sub	rsp, 32					; 00000020H

; 459  :     //DebugMsg(("SymFree: free %X, name=%s, state=%X\n", sym, sym->name, sym->state));
; 460  :     free_ext( sym );

	mov	eax, DWORD PTR [rcx+40]
	mov	rbx, rcx
	dec	eax
	cmp	eax, 9
	ja	SHORT $LN4@SymFree
	lea	rcx, OFFSET FLAT:__ImageBase
	cdqe
	mov	edx, DWORD PTR $LN18@SymFree[rcx+rax*4]
	add	rdx, rcx
	jmp	rdx
$LN13@SymFree:
	test	BYTE PTR [rbx+49], 8
	je	SHORT $LN4@SymFree
	mov	rcx, rbx

; 461  : #if FASTMEM==0
; 462  :     if ( sym->state != SYM_EXTERNAL ) {
; 463  :         struct fixup *fix;
; 464  :         for( fix = sym->bp_fixup ; fix; ) {
; 465  :             struct fixup *next = fix->nextbp;
; 466  :             DebugMsg(("SymFree: free bp fixup %p\n", fix ));
; 467  :             LclFree( fix );
; 468  :             fix = next;
; 469  :         }
; 470  :     }
; 471  :     if ( sym->name_size ) LclFree( sym->name );
; 472  : #endif
; 473  :     LclFree( sym );
; 474  :     return;
; 475  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	DeleteProc

; 459  :     //DebugMsg(("SymFree: free %X, name=%s, state=%X\n", sym, sym->name, sym->state));
; 460  :     free_ext( sym );

$LN11@SymFree:
	test	BYTE PTR [rbx+49], 8
	je	SHORT $LN10@SymFree
	mov	rcx, rbx
	call	DeleteProc
$LN10@SymFree:
	mov	DWORD PTR [rbx+52], 0

; 461  : #if FASTMEM==0
; 462  :     if ( sym->state != SYM_EXTERNAL ) {
; 463  :         struct fixup *fix;
; 464  :         for( fix = sym->bp_fixup ; fix; ) {
; 465  :             struct fixup *next = fix->nextbp;
; 466  :             DebugMsg(("SymFree: free bp fixup %p\n", fix ));
; 467  :             LclFree( fix );
; 468  :             fix = next;
; 469  :         }
; 470  :     }
; 471  :     if ( sym->name_size ) LclFree( sym->name );
; 472  : #endif
; 473  :     LclFree( sym );
; 474  :     return;
; 475  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0

; 459  :     //DebugMsg(("SymFree: free %X, name=%s, state=%X\n", sym, sym->name, sym->state));
; 460  :     free_ext( sym );

$LN7@SymFree:
	mov	rcx, rbx

; 461  : #if FASTMEM==0
; 462  :     if ( sym->state != SYM_EXTERNAL ) {
; 463  :         struct fixup *fix;
; 464  :         for( fix = sym->bp_fixup ; fix; ) {
; 465  :             struct fixup *next = fix->nextbp;
; 466  :             DebugMsg(("SymFree: free bp fixup %p\n", fix ));
; 467  :             LclFree( fix );
; 468  :             fix = next;
; 469  :         }
; 470  :     }
; 471  :     if ( sym->name_size ) LclFree( sym->name );
; 472  : #endif
; 473  :     LclFree( sym );
; 474  :     return;
; 475  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	DeleteGroup

; 459  :     //DebugMsg(("SymFree: free %X, name=%s, state=%X\n", sym, sym->name, sym->state));
; 460  :     free_ext( sym );

$LN6@SymFree:
	mov	rcx, rbx

; 461  : #if FASTMEM==0
; 462  :     if ( sym->state != SYM_EXTERNAL ) {
; 463  :         struct fixup *fix;
; 464  :         for( fix = sym->bp_fixup ; fix; ) {
; 465  :             struct fixup *next = fix->nextbp;
; 466  :             DebugMsg(("SymFree: free bp fixup %p\n", fix ));
; 467  :             LclFree( fix );
; 468  :             fix = next;
; 469  :         }
; 470  :     }
; 471  :     if ( sym->name_size ) LclFree( sym->name );
; 472  : #endif
; 473  :     LclFree( sym );
; 474  :     return;
; 475  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	DeleteType

; 459  :     //DebugMsg(("SymFree: free %X, name=%s, state=%X\n", sym, sym->name, sym->state));
; 460  :     free_ext( sym );

$LN5@SymFree:
	mov	rcx, rbx
	call	ReleaseMacroData
$LN4@SymFree:

; 461  : #if FASTMEM==0
; 462  :     if ( sym->state != SYM_EXTERNAL ) {
; 463  :         struct fixup *fix;
; 464  :         for( fix = sym->bp_fixup ; fix; ) {
; 465  :             struct fixup *next = fix->nextbp;
; 466  :             DebugMsg(("SymFree: free bp fixup %p\n", fix ));
; 467  :             LclFree( fix );
; 468  :             fix = next;
; 469  :         }
; 470  :     }
; 471  :     if ( sym->name_size ) LclFree( sym->name );
; 472  : #endif
; 473  :     LclFree( sym );
; 474  :     return;
; 475  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
	npad	2
$LN18@SymFree:
	DD	$LN13@SymFree
	DD	$LN11@SymFree
	DD	$LN4@SymFree
	DD	$LN7@SymFree
	DD	$LN4@SymFree
	DD	$LN4@SymFree
	DD	$LN6@SymFree
	DD	$LN4@SymFree
	DD	$LN5@SymFree
	DD	$LN4@SymFree
SymFree	ENDP
_TEXT	ENDS
PUBLIC	SymAddLocal
EXTRN	EmitErr:NEAR
xdata	SEGMENT
$unwind$SymAddLocal DD 074c01H
	DD	09744cH
	DD	08640eH
	DD	073409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SymAddLocal DD @imagerel($LN4#)
	DD	@imagerel($LN4#+174)
	DD	@imagerel($unwind$SymAddLocal#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
name$ = 56
SymAddLocal PROC NEAR

; 484  : {

$LN4:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, rcx

; 485  :     struct asym *sym2;
; 486  :     /* v2.10: ignore symbols with state SYM_UNDEFINED! */
; 487  :     //if( SymFind( name ) ) {
; 488  :     if( ( sym2 = SymFind( name ) ) && sym2->state != SYM_UNDEFINED ) {

	mov	rcx, rdx
	mov	rbx, rdx
	call	SymFind
	test	rax, rax
	je	SHORT $LN1@SymAddLoca
	cmp	DWORD PTR [rax+40], 0
	je	SHORT $LN1@SymAddLoca

; 489  :         /* shouldn't happen */
; 490  :         EmitErr( SYMBOL_ALREADY_DEFINED, name );

	mov	rdx, rbx
	mov	ecx, 56					; 00000038H
	call	EmitErr

; 491  :         return( NULL );

	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 502  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN1@SymAddLoca:

; 492  :     }
; 493  : #if FASTMEM==0
; 494  :     if ( sym->name_size ) LclFree( sym->name );
; 495  : #endif
; 496  :     sym->name_size = strlen( name );

	xor	eax, eax
	mov	QWORD PTR [rsp+72], rdi
	mov	rcx, -1
	mov	rdi, rbx
	repne scasb
	not	rcx
	dec	rcx

; 497  :     sym->name = LclAlloc( sym->name_size + 1 );

	movzx	eax, cl
	mov	BYTE PTR [rsi+80], cl
	inc	eax
	movsxd	rcx, eax
	call	LclAlloc

; 498  :     memcpy( sym->name, name, sym->name_size + 1 );

	movzx	ecx, BYTE PTR [rsi+80]
	mov	rdx, rbx
	inc	ecx
	mov	QWORD PTR [rsi+8], rax
	movsxd	r8, ecx
	mov	rcx, rax
	call	memcpy

; 499  :     sym->nextitem = NULL;
; 500  :     *lsym = sym;

	mov	rax, QWORD PTR lsym
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+56]
	mov	QWORD PTR [rsi], 0
	mov	QWORD PTR [rax], rsi

; 501  :     return( sym );

	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+64]

; 502  : }

	add	rsp, 40					; 00000028H
	ret	0
SymAddLocal ENDP
_TEXT	ENDS
PUBLIC	SymAddGlobal
xdata	SEGMENT
$unwind$SymAddGlobal DD 020601H
	DD	030023206H
xdata	ENDS
pdata	SEGMENT
$pdata$SymAddGlobal DD @imagerel($LN4#)
	DD	@imagerel($LN4#+77)
	DD	@imagerel($unwind$SymAddGlobal#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
SymAddGlobal PROC NEAR

; 511  : {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 512  :     if( SymFind( sym->name ) ) {

	mov	rcx, QWORD PTR [rcx+8]
	call	SymFind
	test	rax, rax
	je	SHORT $LN1@SymAddGlob

; 513  :         EmitErr( SYMBOL_ALREADY_DEFINED, sym->name );

	mov	rdx, QWORD PTR [rbx+8]
	mov	ecx, 56					; 00000038H
	call	EmitErr

; 514  :         return( NULL );

	xor	eax, eax

; 520  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN1@SymAddGlob:

; 515  :     }
; 516  :     sym->nextitem = NULL;
; 517  :     *gsym = sym;

	mov	rax, QWORD PTR gsym

; 518  :     SymCount++;

	inc	DWORD PTR SymCount
	mov	QWORD PTR [rbx], 0
	mov	QWORD PTR [rax], rbx

; 519  :     return( sym );

	mov	rax, rbx

; 520  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
SymAddGlobal ENDP
_TEXT	ENDS
PUBLIC	SymCreate
xdata	SEGMENT
$unwind$SymCreate DD 073b01H
	DD	09743bH
	DD	073436H
	DD	086409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SymCreate DD @imagerel($LN9#)
	DD	@imagerel($LN9#+254)
	DD	@imagerel($unwind$SymCreate#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
SymCreate PROC NEAR

; 525  : {

$LN9:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, rcx

; 526  :     struct asym *sym;
; 527  : 
; 528  :     if( SymFind( name ) ) {

	call	SymFind
	test	rax, rax
	je	SHORT $LN1@SymCreate

; 529  :         EmitErr( SYMBOL_ALREADY_DEFINED, name );

	mov	rdx, rsi
	mov	ecx, 56					; 00000038H
	call	EmitErr

; 530  :         return( NULL );

	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+64]

; 536  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN1@SymCreate:

; 531  :     }
; 532  :     sym = SymAlloc( name );

	xor	eax, eax
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rsi
	mov	rcx, -1
	repne scasb
	not	rcx
	lea	rdi, QWORD PTR [rcx-1]
	mov	ecx, 128				; 00000080H
	call	LclAlloc
	xor	edx, edx
	mov	r8d, 128				; 00000080H
	mov	rcx, rax
	mov	rbx, rax
	call	memset
	cmp	edi, 247				; 000000f7H
	jle	SHORT $LN6@SymCreate
	mov	ecx, 70					; 00000046H
	call	EmitError
	mov	edi, 247				; 000000f7H
$LN6@SymCreate:
	mov	BYTE PTR [rbx+80], dil
	mov	eax, DWORD PTR ModuleInfo+408
	mov	DWORD PTR [rbx+44], 192			; 000000c0H
	shr	eax, 13
	xor	al, BYTE PTR [rbx+49]
	and	al, 1
	xor	BYTE PTR [rbx+49], al
	test	edi, edi
	je	SHORT $LN5@SymCreate
	lea	eax, DWORD PTR [rdi+1]
	movsxd	rcx, eax
	call	LclAlloc
	movsxd	rdi, edi
	mov	rdx, rsi
	mov	rcx, rax
	mov	r8, rdi
	mov	QWORD PTR [rbx+8], rax
	call	memcpy
	mov	rdx, QWORD PTR [rbx+8]
	mov	BYTE PTR [rdi+rdx], 0
	jmp	SHORT $LN4@SymCreate
$LN5@SymCreate:
	lea	rax, OFFSET FLAT:$SG5762
	mov	QWORD PTR [rbx+8], rax
$LN4@SymCreate:

; 533  :     *gsym = sym;

	mov	rax, QWORD PTR gsym

; 534  :     SymCount++;

	inc	DWORD PTR SymCount
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rax], rbx

; 535  :     return( sym );

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]

; 536  : }

	add	rsp, 40					; 00000028H
	ret	0
SymCreate ENDP
_TEXT	ENDS
PUBLIC	SymLCreate
xdata	SEGMENT
$unwind$SymLCreate DD 074101H
	DD	097441H
	DD	07343cH
	DD	086409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SymLCreate DD @imagerel($LN9#)
	DD	@imagerel($LN9#+254)
	DD	@imagerel($unwind$SymLCreate#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
name$ = 48
SymLCreate PROC NEAR

; 544  : {

$LN9:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, rcx

; 545  :     struct asym *sym;
; 546  : 
; 547  :     /* v2.10: ignore symbols with state SYM_UNDEFINED */
; 548  :     //if( SymFind( name ) ) {
; 549  :     if( ( sym = SymFindDeclare( name ) ) && sym->state != SYM_UNDEFINED ) {

	call	SymFindDeclare
	test	rax, rax
	je	SHORT $LN1@SymLCreate
	cmp	DWORD PTR [rax+40], 0
	je	SHORT $LN1@SymLCreate

; 550  :         EmitErr( SYMBOL_ALREADY_DEFINED, name );

	mov	rdx, rsi
	mov	ecx, 56					; 00000038H
	call	EmitErr

; 551  :         return( NULL );

	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+64]

; 556  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN1@SymLCreate:

; 552  :     }
; 553  :     sym = SymAlloc( name );

	xor	eax, eax
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rsi
	mov	rcx, -1
	repne scasb
	not	rcx
	lea	rdi, QWORD PTR [rcx-1]
	mov	ecx, 128				; 00000080H
	call	LclAlloc
	xor	edx, edx
	mov	r8d, 128				; 00000080H
	mov	rcx, rax
	mov	rbx, rax
	call	memset
	cmp	edi, 247				; 000000f7H
	jle	SHORT $LN6@SymLCreate
	mov	ecx, 70					; 00000046H
	call	EmitError
	mov	edi, 247				; 000000f7H
$LN6@SymLCreate:
	mov	BYTE PTR [rbx+80], dil
	mov	eax, DWORD PTR ModuleInfo+408
	mov	DWORD PTR [rbx+44], 192			; 000000c0H
	shr	eax, 13
	xor	al, BYTE PTR [rbx+49]
	and	al, 1
	xor	BYTE PTR [rbx+49], al
	test	edi, edi
	je	SHORT $LN5@SymLCreate
	lea	eax, DWORD PTR [rdi+1]
	movsxd	rcx, eax
	call	LclAlloc
	movsxd	rdi, edi
	mov	rdx, rsi
	mov	rcx, rax
	mov	r8, rdi
	mov	QWORD PTR [rbx+8], rax
	call	memcpy
	mov	rdx, QWORD PTR [rbx+8]
	mov	BYTE PTR [rdi+rdx], 0
	jmp	SHORT $LN4@SymLCreate
$LN5@SymLCreate:
	lea	rax, OFFSET FLAT:$SG5762
	mov	QWORD PTR [rbx+8], rax
$LN4@SymLCreate:

; 554  :     *lsym = sym;

	mov	rax, QWORD PTR lsym
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rax], rbx

; 555  :     return( sym );

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]

; 556  : }

	add	rsp, 40					; 00000028H
	ret	0
SymLCreate ENDP
_TEXT	ENDS
PUBLIC	SymMakeAllSymbolsPublic
EXTRN	AddPublicData:NEAR
xdata	SEGMENT
$unwind$SymMakeAllSymbolsPublic DD 071a01H
	DD	07341aH
	DD	09740eH
	DD	086409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SymMakeAllSymbolsPublic DD @imagerel($LN14#)
	DD	@imagerel($LN14#+139)
	DD	@imagerel($unwind$SymMakeAllSymbolsPublic#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
SymMakeAllSymbolsPublic PROC NEAR

; 560  : {

$LN14:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], rdi

; 561  :     int i;
; 562  :     struct asym  *sym;
; 563  : 
; 564  :     for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {

	lea	rdi, OFFSET FLAT:gsym_table
	mov	QWORD PTR [rsp+56], rbx
	lea	rsi, OFFSET FLAT:gsym_table+64072
$LL7@SymMakeAll:

; 565  :         for( sym = gsym_table[i]; sym; sym = sym->nextitem ) {

	mov	rbx, QWORD PTR [rdi]
	test	rbx, rbx
	je	SHORT $LN6@SymMakeAll
	npad	7
$LL4@SymMakeAll:

; 566  :             if ( sym->state == SYM_INTERNAL &&
; 567  :                 /* v2.07: MT_ABS is obsolete */
; 568  :                 //sym->mem_type != MT_ABS &&  /* no EQU or '=' constants */
; 569  :                 sym->isequate == FALSE &&     /* no EQU or '=' constants */
; 570  :                 sym->predefined == FALSE && /* no predefined symbols ($) */
; 571  :                 sym->included == FALSE && /* v2.09: symbol already added to public queue? */
; 572  :                 //sym->scoped == FALSE && /* v2.09: no procs that are marked as "private" */
; 573  :                 sym->name[1] != '&' && /* v2.10: no @@ code labels */
; 574  :                 sym->ispublic == FALSE ) {

	cmp	DWORD PTR [rbx+40], 1
	jne	SHORT $LN3@SymMakeAll
	movzx	ecx, BYTE PTR [rbx+48]
	test	cl, 16
	jne	SHORT $LN3@SymMakeAll
	test	cl, 32					; 00000020H
	jne	SHORT $LN3@SymMakeAll
	test	BYTE PTR [rbx+49], 64			; 00000040H
	jne	SHORT $LN3@SymMakeAll
	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax+1], 38			; 00000026H
	je	SHORT $LN3@SymMakeAll
	test	cl, cl
	js	SHORT $LN3@SymMakeAll

; 575  :                 sym->ispublic = TRUE;

	or	cl, 128					; 00000080H
	mov	BYTE PTR [rbx+48], cl

; 576  :                 AddPublicData( sym );

	mov	rcx, rbx
	call	AddPublicData
$LN3@SymMakeAll:
	mov	rbx, QWORD PTR [rbx]
	test	rbx, rbx
	jne	SHORT $LL4@SymMakeAll
$LN6@SymMakeAll:

; 561  :     int i;
; 562  :     struct asym  *sym;
; 563  : 
; 564  :     for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {

	add	rdi, 8
	cmp	rdi, rsi
	jl	SHORT $LL7@SymMakeAll
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]

; 577  :             }
; 578  :         }
; 579  :     }
; 580  : }

	add	rsp, 40					; 00000028H
	ret	0
SymMakeAllSymbolsPublic ENDP
_TEXT	ENDS
PUBLIC	SymFini
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
SymFini	PROC NEAR

; 589  : #if FASTMEM==0 || defined( DEBUG_OUT )
; 590  :     unsigned i;
; 591  : #endif
; 592  : 
; 593  : #ifdef DEBUG_OUT
; 594  :     if ( Options.dump_symbols_hash ) {
; 595  :         for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {
; 596  :             struct asym  *sym = gsym_table[i];
; 597  :             if ( sym ) {
; 598  :                 printf("%4u ", i );
; 599  :                 for( ; sym; sym = sym->nextitem ) {
; 600  :                     printf("%-16s ", sym->name );
; 601  :                 }
; 602  :                 printf("\n" );
; 603  :             }
; 604  :         }
; 605  :     }
; 606  :     DumpSymbols();
; 607  : #endif
; 608  : 
; 609  : #if FASTMEM==0 || defined( DEBUG_OUT )
; 610  :     /* free the symbol table */
; 611  :     for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {
; 612  :         struct asym  *sym;
; 613  :         struct asym  *next;
; 614  :         for( sym = gsym_table[i]; sym; ) {
; 615  :             next = sym->nextitem;
; 616  :             SymFree( sym );
; 617  :             SymCount--;
; 618  :             sym = next;
; 619  :         }
; 620  :     }
; 621  :     /**/myassert( SymCount == 0 );
; 622  : #endif
; 623  : 
; 624  : }

	ret	0
SymFini	ENDP
_TEXT	ENDS
PUBLIC	SymInit
EXTRN	sprintf:NEAR
EXTRN	localtime:NEAR
EXTRN	time:NEAR
xdata	SEGMENT
$unwind$SymInit DD 071301H
	DD	0f7413H
	DD	0e640eH
	DD	0c3409H
	DD	0a204H
xdata	ENDS
pdata	SEGMENT
$pdata$SymInit DD @imagerel($LN31#)
	DD	@imagerel($LN31#+19)
	DD	@imagerel($unwind$SymInit#)
pdata	ENDS
xdata	SEGMENT
$chain$6$SymInit DD 08c921H
	DD	0d54c9H
	DD	08e428H
	DD	09d419H
	DD	0ac405H
	DD	@imagerel($LN31#)
	DD	@imagerel($LN31#+19)
	DD	@imagerel($unwind$SymInit#)
xdata	ENDS
pdata	SEGMENT
$pdata$6$SymInit DD @imagerel($LN31#+19)
	DD	@imagerel($LN31#+483)
	DD	@imagerel($chain$6$SymInit#)
pdata	ENDS
xdata	SEGMENT
$chain$7$SymInit DD 060021H
	DD	08e400H
	DD	09d400H
	DD	0d5400H
	DD	@imagerel($LN31#)
	DD	@imagerel($LN31#+19)
	DD	@imagerel($unwind$SymInit#)
xdata	ENDS
pdata	SEGMENT
$pdata$7$SymInit DD @imagerel($LN31#+483)
	DD	@imagerel($LN31#+808)
	DD	@imagerel($chain$7$SymInit#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
time_of_day$ = 48
SymInit	PROC NEAR

; 630  : {

$LN31:
	sub	rsp, 88					; 00000058H
	mov	QWORD PTR [rsp+96], rbx
	mov	QWORD PTR [rsp+112], rsi
	mov	QWORD PTR [rsp+120], rdi
	mov	QWORD PTR [rsp+80], r12

; 631  :     struct asym *sym;
; 632  :     int i;
; 633  :     time_t    time_of_day;
; 634  :     struct tm *now;
; 635  : 
; 636  :     DebugMsg(("SymInit() enter\n"));
; 637  :     SymCount = 0;
; 638  : 
; 639  :     /* v2.11: ensure CurrProc is NULL - might be a problem if multiple files are assembled */
; 640  :     CurrProc = NULL;
; 641  : 
; 642  :     memset( gsym_table, 0, sizeof(gsym_table) );

	lea	rcx, OFFSET FLAT:gsym_table
	xor	edx, edx
	mov	r8d, 64072				; 0000fa48H
	mov	QWORD PTR [rsp+72], r13
	mov	DWORD PTR SymCount, 0
	mov	QWORD PTR [rsp+64], r14
	mov	QWORD PTR CurrProc, 0
	call	memset

; 643  : 
; 644  :     time_of_day = time( NULL );

	xor	ecx, ecx
	call	time

; 645  :     now = localtime( &time_of_day );

	lea	rcx, QWORD PTR time_of_day$[rsp]
	mov	QWORD PTR time_of_day$[rsp], rax
	call	localtime

; 646  : #if USESTRFTIME
; 647  :     strftime( szDate, 9, szDateFmt, now );
; 648  :     strftime( szTime, 9, szTimeFmt, now );
; 649  : #else
; 650  :     sprintf( szDate, "%02u/%02u/%02u", now->tm_mon + 1, now->tm_mday, now->tm_year % 100 );

	mov	edi, DWORD PTR [rax+20]
	mov	rbx, rax
	mov	eax, 1374389535				; 51eb851fH
	mov	r8d, DWORD PTR [rbx+16]
	mov	r9d, DWORD PTR [rbx+12]
	imul	edi
	sar	edx, 5
	inc	r8d
	mov	ecx, edx
	shr	ecx, 31
	add	edx, ecx
	lea	rcx, OFFSET FLAT:szDate
	imul	edx, 100				; 00000064H
	sub	edi, edx
	lea	rdx, OFFSET FLAT:$SG5884
	mov	DWORD PTR [rsp+32], edi
	call	sprintf

; 651  :     sprintf( szTime, "%02u:%02u:%02u", now->tm_hour, now->tm_min, now->tm_sec );

	mov	edx, DWORD PTR [rbx]
	mov	r9d, DWORD PTR [rbx+4]
	mov	r8d, DWORD PTR [rbx+8]
	mov	DWORD PTR [rsp+32], edx
	lea	rdx, OFFSET FLAT:$SG5885
	lea	rcx, OFFSET FLAT:szTime
	call	sprintf
	mov	r13d, 6
	lea	rsi, OFFSET FLAT:tmtab+16
	mov	r12, r13
	lea	r14, OFFSET FLAT:$SG5762
	mov	QWORD PTR [rsp+104], rbp
	npad	4
$LL8@SymInit:

; 655  :         sym = SymCreate( tmtab[i].name );

	mov	rbp, QWORD PTR [rsi-16]
	mov	rcx, rbp
	call	SymFind
	test	rax, rax
	je	SHORT $LN11@SymInit
	mov	rdx, rbp
	mov	ecx, 56					; 00000038H
	call	EmitErr
	xor	ebx, ebx
	jmp	$LN12@SymInit
$LN11@SymInit:
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbp
	repne scasb
	not	rcx
	lea	rdi, QWORD PTR [rcx-1]
	mov	ecx, 128				; 00000080H
	call	LclAlloc
	xor	edx, edx
	mov	r8d, 128				; 00000080H
	mov	rcx, rax
	mov	rbx, rax
	call	memset
	cmp	edi, 247				; 000000f7H
	jle	SHORT $LN16@SymInit
	mov	ecx, 70					; 00000046H
	call	EmitError
	mov	edi, 247				; 000000f7H
$LN16@SymInit:
	mov	BYTE PTR [rbx+80], dil
	mov	eax, DWORD PTR ModuleInfo+408
	mov	DWORD PTR [rbx+44], 192			; 000000c0H
	shr	eax, 13
	xor	al, BYTE PTR [rbx+49]
	and	al, 1
	xor	BYTE PTR [rbx+49], al
	test	edi, edi
	je	SHORT $LN15@SymInit
	lea	eax, DWORD PTR [rdi+1]
	movsxd	rcx, eax
	call	LclAlloc
	movsxd	rdi, edi
	mov	rdx, rbp
	mov	rcx, rax
	mov	r8, rdi
	mov	QWORD PTR [rbx+8], rax
	call	memcpy
	mov	rdx, QWORD PTR [rbx+8]
	mov	BYTE PTR [rdi+rdx], 0
	jmp	SHORT $LN14@SymInit
$LN15@SymInit:
	mov	QWORD PTR [rbx+8], r14
$LN14@SymInit:
	mov	rax, QWORD PTR gsym
	inc	DWORD PTR SymCount
	mov	QWORD PTR [rax], rbx
$LN12@SymInit:

; 656  :         sym->state = SYM_TMACRO;
; 657  :         sym->isdefined = TRUE;
; 658  :         sym->predefined = TRUE;

	or	BYTE PTR [rbx+48], 34			; 00000022H
	mov	DWORD PTR [rbx+40], 10

; 659  :         sym->string_ptr = tmtab[i].value;

	mov	rax, QWORD PTR [rsi-8]
	mov	QWORD PTR [rbx+16], rax

; 660  :         if ( tmtab[i].store )

	mov	rax, QWORD PTR [rsi]
	test	rax, rax
	je	SHORT $LN7@SymInit

; 661  :             *tmtab[i].store = sym;

	mov	QWORD PTR [rax], rbx
$LN7@SymInit:

; 652  : #endif
; 653  : 
; 654  :     for( i = 0; i < sizeof(tmtab) / sizeof(tmtab[0]); i++ ) {

	add	rsi, 24
	dec	r12
	jne	$LL8@SymInit
	mov	r12, QWORD PTR [rsp+80]

; 662  :     }
; 663  : 
; 664  :     for( i = 0; i < sizeof(eqtab) / sizeof(eqtab[0]); i++ ) {

	lea	rsi, OFFSET FLAT:eqtab+8
$LL4@SymInit:

; 665  :         sym = SymCreate( eqtab[i].name );

	mov	rbp, QWORD PTR [rsi-8]
	mov	rcx, rbp
	call	SymFind
	test	rax, rax
	je	SHORT $LN19@SymInit
	mov	rdx, rbp
	mov	ecx, 56					; 00000038H
	call	EmitErr
	xor	ebx, ebx
	jmp	$LN20@SymInit
$LN19@SymInit:
	xor	eax, eax
	mov	rcx, -1
	mov	rdi, rbp
	repne scasb
	not	rcx
	lea	rdi, QWORD PTR [rcx-1]
	mov	ecx, 128				; 00000080H
	call	LclAlloc
	xor	edx, edx
	mov	r8d, 128				; 00000080H
	mov	rcx, rax
	mov	rbx, rax
	call	memset
	cmp	edi, 247				; 000000f7H
	jle	SHORT $LN24@SymInit
	mov	ecx, 70					; 00000046H
	call	EmitError
	mov	edi, 247				; 000000f7H
$LN24@SymInit:
	mov	BYTE PTR [rbx+80], dil
	mov	eax, DWORD PTR ModuleInfo+408
	mov	DWORD PTR [rbx+44], 192			; 000000c0H
	shr	eax, 13
	xor	al, BYTE PTR [rbx+49]
	and	al, 1
	xor	BYTE PTR [rbx+49], al
	test	edi, edi
	je	SHORT $LN23@SymInit
	lea	eax, DWORD PTR [rdi+1]
	movsxd	rcx, eax
	call	LclAlloc
	movsxd	rdi, edi
	mov	rdx, rbp
	mov	rcx, rax
	mov	r8, rdi
	mov	QWORD PTR [rbx+8], rax
	call	memcpy
	mov	rdx, QWORD PTR [rbx+8]
	mov	BYTE PTR [rdi+rdx], 0
	jmp	SHORT $LN22@SymInit
$LN23@SymInit:
	mov	QWORD PTR [rbx+8], r14
$LN22@SymInit:
	mov	rax, QWORD PTR gsym
	inc	DWORD PTR SymCount
	mov	QWORD PTR [rax], rbx
$LN20@SymInit:

; 666  :         sym->state = SYM_INTERNAL;
; 667  :         /* v2.07: MT_ABS is obsolete */
; 668  :         //sym->mem_type = MT_ABS;
; 669  :         sym->isdefined = TRUE;
; 670  :         sym->predefined = TRUE;

	or	BYTE PTR [rbx+48], 34			; 00000022H
	mov	DWORD PTR [rbx+40], 1

; 671  :         sym->offset = eqtab[i].value;

	mov	eax, DWORD PTR [rsi]
	mov	DWORD PTR [rbx+16], eax

; 672  :         sym->sfunc_ptr = eqtab[i].sfunc_ptr;

	mov	rax, QWORD PTR [rsi+8]
	mov	QWORD PTR [rbx+72], rax

; 673  :         //sym->variable = TRUE; /* if fixup must be created */
; 674  :         if ( eqtab[i].store )

	mov	rax, QWORD PTR [rsi+16]
	test	rax, rax
	je	SHORT $LN3@SymInit

; 675  :             *eqtab[i].store = sym;

	mov	QWORD PTR [rax], rbx
$LN3@SymInit:

; 662  :     }
; 663  : 
; 664  :     for( i = 0; i < sizeof(eqtab) / sizeof(eqtab[0]); i++ ) {

	add	rsi, 32					; 00000020H
	dec	r13
	jne	$LL4@SymInit

; 676  :     }
; 677  :     sym->list   = FALSE; /* @WordSize should not be listed */

	and	BYTE PTR [rbx+49], 254			; 000000feH

; 678  :     /* $ is an address (usually). Also, don't add it to the list */
; 679  :     symPC->variable = TRUE;

	mov	rax, QWORD PTR symPC
	mov	r14, QWORD PTR [rsp+64]
	or	BYTE PTR [rax+48], 64			; 00000040H

; 680  :     symPC->list     = FALSE;

	mov	rax, QWORD PTR symPC
	mov	r13, QWORD PTR [rsp+72]
	and	BYTE PTR [rax+49], 254			; 000000feH

; 681  :     LineCur->list   = FALSE;

	mov	rax, QWORD PTR LineCur
	mov	rdi, QWORD PTR [rsp+120]
	and	BYTE PTR [rax+49], 254			; 000000feH
	mov	rsi, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+96]

; 682  : 
; 683  :     DebugMsg(("SymInit() exit\n"));
; 684  :     return;
; 685  : 
; 686  : }

	add	rsp, 88					; 00000058H
	ret	0
SymInit	ENDP
_TEXT	ENDS
PUBLIC	SymPassInit
EXTRN	UseSavedState:BYTE
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
pass$ = 8
SymPassInit PROC NEAR

; 691  :     unsigned            i;
; 692  : 
; 693  :     if ( pass == PASS_1 )

	test	ecx, ecx
	je	SHORT $LN5@SymPassIni

; 694  :         return;
; 695  : 
; 696  : #if FASTPASS
; 697  :     /* No need to reset the "defined" flag if FASTPASS is on.
; 698  :      * Because then the source lines will come from the line store,
; 699  :      * where inactive conditional lines are NOT contained.
; 700  :      */
; 701  :     if ( UseSavedState )

	cmp	BYTE PTR UseSavedState, 0
	jne	SHORT $LN5@SymPassIni

; 702  :         return;
; 703  : #endif
; 704  :     /* mark as "undefined":
; 705  :      * - SYM_INTERNAL - internals
; 706  :      * - SYM_MACRO - macros
; 707  :      * - SYM_TMACRO - text macros
; 708  :      */
; 709  :     for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {

	lea	rdx, OFFSET FLAT:gsym_table
	mov	r8d, 8009				; 00001f49H
	npad	6
$LL7@SymPassIni:

; 710  :         struct asym *sym;
; 711  :         for( sym = gsym_table[i]; sym; sym = sym->nextitem ) {

	mov	rax, QWORD PTR [rdx]
	test	rax, rax
	je	SHORT $LN6@SymPassIni
	npad	8
$LL4@SymPassIni:

; 712  :             if ( sym->predefined == FALSE ) {

	movzx	ecx, BYTE PTR [rax+48]
	test	cl, 32					; 00000020H
	jne	SHORT $LN3@SymPassIni

; 713  :                 /* v2.04: all symbol's "defined" flag is now reset. */
; 714  :                 // if ( sym->state == SYM_TMACRO ||
; 715  :                 //    sym->state == SYM_MACRO  ||
; 716  :                 //    sym->state == SYM_INTERNAL ) {
; 717  :                     sym->isdefined = FALSE;

	and	cl, 253					; 000000fdH
	mov	BYTE PTR [rax+48], cl
$LN3@SymPassIni:
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL4@SymPassIni
$LN6@SymPassIni:

; 702  :         return;
; 703  : #endif
; 704  :     /* mark as "undefined":
; 705  :      * - SYM_INTERNAL - internals
; 706  :      * - SYM_MACRO - macros
; 707  :      * - SYM_TMACRO - text macros
; 708  :      */
; 709  :     for( i = 0; i < GHASH_TABLE_SIZE; i++ ) {

	add	rdx, 8
	dec	r8
	jne	SHORT $LL7@SymPassIni
$LN5@SymPassIni:

; 718  :                 //}
; 719  :             }
; 720  :         }
; 721  :     }
; 722  : }

	ret	0
SymPassInit ENDP
_TEXT	ENDS
PUBLIC	SymGetCount
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
SymGetCount PROC NEAR

; 727  :     return( SymCount );

	mov	eax, DWORD PTR SymCount

; 728  : }

	ret	0
SymGetCount ENDP
_TEXT	ENDS
PUBLIC	SymGetAll
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
syms$ = 8
SymGetAll PROC NEAR

; 735  :     struct asym         *sym;
; 736  :     unsigned            i, j;
; 737  : 
; 738  :     /* copy symbols to table */
; 739  :     for( i = j = 0; i < GHASH_TABLE_SIZE; i++ ) {

	xor	edx, edx
	lea	r8, OFFSET FLAT:gsym_table
	mov	r9d, 8009				; 00001f49H
	npad	1
$LL6@SymGetAll:

; 740  :         for( sym = gsym_table[i]; sym; sym = sym->nextitem ) {

	mov	rax, QWORD PTR [r8]
	test	rax, rax
	je	SHORT $LN5@SymGetAll
	npad	8
$LL3@SymGetAll:

; 741  :             syms[j++] = sym;

	mov	QWORD PTR [rcx+rdx*8], rax
	mov	rax, QWORD PTR [rax]
	inc	rdx
	test	rax, rax
	jne	SHORT $LL3@SymGetAll
$LN5@SymGetAll:

; 735  :     struct asym         *sym;
; 736  :     unsigned            i, j;
; 737  : 
; 738  :     /* copy symbols to table */
; 739  :     for( i = j = 0; i < GHASH_TABLE_SIZE; i++ ) {

	add	r8, 8
	dec	r9
	jne	SHORT $LL6@SymGetAll

; 742  :         }
; 743  :     }
; 744  :     return;
; 745  : }

	ret	0
SymGetAll ENDP
_TEXT	ENDS
PUBLIC	SymEnum
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
sym$ = 8
pi$ = 16
SymEnum	PROC NEAR

; 754  :     if ( sym == NULL ) {

	test	rcx, rcx
	jne	SHORT $LN4@SymEnum

; 755  :         *pi = 0;

	mov	DWORD PTR [rdx], ecx

; 756  :         sym = gsym_table[*pi];

	mov	rax, QWORD PTR gsym_table

; 757  :     } else {

	jmp	SHORT $LN7@SymEnum
$LN4@SymEnum:

; 758  :         sym = sym->nextitem;

	mov	rax, QWORD PTR [rcx]
$LN7@SymEnum:

; 759  :     }
; 760  : 
; 761  :     /* v2.10: changed from for() to while() */
; 762  :     while( sym == NULL && *pi < GHASH_TABLE_SIZE - 1 )

	test	rax, rax
	jne	SHORT $LN10@SymEnum
	lea	r8, OFFSET FLAT:gsym_table
	npad	1
$LL2@SymEnum:
	mov	ecx, DWORD PTR [rdx]
	cmp	ecx, 8008				; 00001f48H
	jge	SHORT $LN10@SymEnum

; 763  :         sym = gsym_table[++(*pi)];

	lea	eax, DWORD PTR [rcx+1]
	movsxd	rcx, eax
	mov	DWORD PTR [rdx], eax
	mov	rax, QWORD PTR [r8+rcx*8]
	test	rax, rax
	je	SHORT $LL2@SymEnum
$LN10@SymEnum:

; 764  : 
; 765  :     //printf("sym=%X, i=%u\n", sym, *pi );
; 766  :     return( sym );
; 767  : }

	ret	0
SymEnum	ENDP
_TEXT	ENDS
PUBLIC	SymSimd
EXTRN	strncmp:NEAR
xdata	SEGMENT
$unwind$SymSimd DD 030901H
	DD	097409H
	DD	04204H
xdata	ENDS
pdata	SEGMENT
$pdata$SymSimd DD @imagerel($LN60#)
	DD	@imagerel($LN60#+45)
	DD	@imagerel($unwind$SymSimd#)
pdata	ENDS
xdata	SEGMENT
$chain$3$SymSimd DD 064321H
	DD	04c443H
	DD	08640aH
	DD	075405H
	DD	@imagerel($LN60#)
	DD	@imagerel($LN60#+45)
	DD	@imagerel($unwind$SymSimd#)
xdata	ENDS
pdata	SEGMENT
$pdata$3$SymSimd DD @imagerel($LN60#+45)
	DD	@imagerel($LN60#+368)
	DD	@imagerel($chain$3$SymSimd#)
pdata	ENDS
xdata	SEGMENT
$chain$4$SymSimd DD 020521H
	DD	063405H
	DD	@imagerel($LN60#+45)
	DD	@imagerel($LN60#+368)
	DD	@imagerel($chain$3$SymSimd#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$SymSimd DD @imagerel($LN60#+368)
	DD	@imagerel($LN60#+1309)
	DD	@imagerel($chain$4$SymSimd#)
pdata	ENDS
xdata	SEGMENT
$chain$5$SymSimd DD 021H
	DD	@imagerel($LN60#)
	DD	@imagerel($LN60#+45)
	DD	@imagerel($unwind$SymSimd#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$SymSimd DD @imagerel($LN60#+1309)
	DD	@imagerel($LN60#+1319)
	DD	@imagerel($chain$5$SymSimd#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
sym$ = 48
SymSimd	PROC NEAR

; 770  : {

$LN60:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR [rsp+72], rdi
	mov	rdi, rcx

; 771  : 	int memberCount = 0;
; 772  : 	int vtotal = 0;
; 773  : 	int msize = 0;
; 774  : 	enum memtype ctype;
; 775  : 	enum memtype htype;
; 776  : 	int c0;
; 777  : 	int c1;
; 778  : 	int c2;
; 779  :     struct sfield *pMember = sym->e.structinfo->head;

	mov	rcx, QWORD PTR [rcx+104]
	mov	rax, QWORD PTR [rcx]

; 780  : 	uint_8 member1Valid = 0;
; 781  : 	uint_8 member2Valid = 0;
; 782  : 	uint_8 member3Valid = 0;
; 783  : 	uint_8 member4Valid = 0;
; 784  : 
; 785  :   if (pMember == NULL && sym->sym.typekind != TYPE_UNION) return;

	test	rax, rax
	jne	SHORT $LN50@SymSimd
	cmp	BYTE PTR [rdi+74], 2
	jne	$LN1@SymSimd
$LN50@SymSimd:

; 786  :   memberCount = 0;
; 787  :   sym->e.structinfo->isHomogenous = 1;

	mov	BYTE PTR [rcx+20], 1

; 788  : 
; 789  :   vtotal = sym->sym.total_size;

	mov	r8d, DWORD PTR [rdi+64]

; 790  :   msize = pMember->sym.total_size;

	mov	edx, DWORD PTR [rax+64]
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi

; 791  :   ctype = pMember->sym.mem_type;

	mov	esi, DWORD PTR [rax+44]
	xor	ebp, ebp
	npad	4
$LL49@SymSimd:

; 792  :   htype = pMember->sym.mem_type;
; 793  : 
; 794  :   while (pMember)
; 795  :   {
; 796  :     if (pMember->sym.total_size != msize && pMember->sym.mem_type != ctype && sym->e.structinfo->isHomogenous == 1)

	cmp	DWORD PTR [rax+64], edx
	je	SHORT $LN47@SymSimd
	cmp	DWORD PTR [rax+44], esi
	je	SHORT $LN47@SymSimd
	mov	rcx, QWORD PTR [rdi+104]
	cmp	BYTE PTR [rcx+20], 1
	jne	SHORT $LN47@SymSimd

; 797  :     {
; 798  :       sym->e.structinfo->isHomogenous = 0;

	mov	BYTE PTR [rcx+20], 0
$LN47@SymSimd:

; 799  :     }
; 800  :     pMember = pMember->next;

	mov	rax, QWORD PTR [rax+104]

; 801  :     memberCount = memberCount + 1;

	inc	ebp
	test	rax, rax
	jne	SHORT $LL49@SymSimd

; 802  :   }
; 803  : 
; 804  : 
; 805  :   sym->e.structinfo->memberCount = memberCount;
; 806  :   if (vtotal == 0x20 && sym->e.structinfo->isHomogenous == 1 && ((sym->sym.typekind == TYPE_UNION) || 
; 807  :     (htype == MT_REAL4 || htype == MT_REAL8 || htype == MT_BYTE || htype == MT_WORD | htype == MT_DWORD || htype == MT_QWORD)))  

	cmp	r8d, 32					; 00000020H
	mov	rax, QWORD PTR [rdi+104]
	mov	QWORD PTR [rsp+32], r12
	mov	DWORD PTR [rax+24], ebp
	mov	r12d, 1
	jne	SHORT $LN46@SymSimd
	mov	rdx, QWORD PTR [rdi+104]
	cmp	BYTE PTR [rdx+20], r12b
	jne	SHORT $LN42@SymSimd
	cmp	BYTE PTR [rdi+74], 2
	je	SHORT $LN44@SymSimd
	cmp	esi, 35					; 00000023H
	je	SHORT $LN44@SymSimd
	cmp	esi, 39					; 00000027H
	je	SHORT $LN44@SymSimd
	test	esi, esi
	je	SHORT $LN44@SymSimd
	xor	ecx, ecx
	cmp	esi, 3
	sete	cl
	xor	eax, eax
	cmp	esi, r12d
	sete	al
	or	ecx, eax
	jne	SHORT $LN44@SymSimd
	cmp	esi, 7
	jne	SHORT $LN42@SymSimd
$LN44@SymSimd:

; 808  :     sym->e.structinfo->stype = MM256;

	mov	DWORD PTR [rdx+16], 2

; 809  :   else if (vtotal == 0x10 && sym->e.structinfo->isHomogenous == 1 && ((sym->sym.typekind == TYPE_UNION) ||

	jmp	SHORT $LN42@SymSimd
$LN46@SymSimd:

; 810  :     (htype == MT_REAL4 || htype == MT_REAL8 || htype == MT_BYTE || htype == MT_WORD | htype == MT_DWORD || htype == MT_QWORD)))

	cmp	r8d, 16
	jne	SHORT $LN42@SymSimd
	mov	rdx, QWORD PTR [rdi+104]
	cmp	BYTE PTR [rdx+20], r12b
	jne	SHORT $LN42@SymSimd
	cmp	BYTE PTR [rdi+74], 2
	je	SHORT $LN40@SymSimd
	cmp	esi, 35					; 00000023H
	je	SHORT $LN40@SymSimd
	cmp	esi, 39					; 00000027H
	je	SHORT $LN40@SymSimd
	test	esi, esi
	je	SHORT $LN40@SymSimd
	xor	ecx, ecx
	cmp	esi, 3
	sete	cl
	xor	eax, eax
	cmp	esi, r12d
	sete	al
	or	ecx, eax
	jne	SHORT $LN40@SymSimd
	cmp	esi, 7
	jne	SHORT $LN42@SymSimd
$LN40@SymSimd:

; 811  :     sym->e.structinfo->stype = MM128;

	mov	DWORD PTR [rdx+16], r12d
$LN42@SymSimd:

; 812  : #if EVEXSUPP
; 813  :   else if (vtotal == 0x40 && sym->e.structinfo->isHomogenous == 1 && ((sym->sym.typekind == TYPE_UNION) ||
; 814  :     (htype == MT_REAL4 || htype == MT_REAL8 || htype == MT_BYTE || htype == MT_WORD | htype == MT_DWORD || htype == MT_QWORD)))
; 815  :     sym->e.structinfo->stype = MM512;
; 816  : #endif
; 817  : 
; 818  :   // Ensure unions of multiple MM128 or MM256 types default to a 4/8 member float arrangement.
; 819  :   if (sym->sym.typekind == TYPE_UNION && sym->e.structinfo->isHomogenous == 1)

	cmp	BYTE PTR [rdi+74], 2
	jne	SHORT $LN37@SymSimd
	mov	rax, QWORD PTR [rdi+104]
	cmp	BYTE PTR [rax+20], r12b
	jne	SHORT $LN37@SymSimd

; 820  :   {
; 821  : 	  if (sym->e.structinfo->stype == MM128) {

	cmp	DWORD PTR [rax+16], r12d
	jne	SHORT $LN38@SymSimd

; 822  : 		  memberCount = 4;

	mov	ebp, 4

; 823  : 		  sym->e.structinfo->memberCount = memberCount;

	mov	DWORD PTR [rax+24], ebp
$LN38@SymSimd:

; 824  : 	  }
; 825  : 	  if (sym->e.structinfo->stype == MM256) {

	mov	rax, QWORD PTR [rdi+104]
	cmp	DWORD PTR [rax+16], 2
	jne	SHORT $LN37@SymSimd

; 826  : 		  memberCount = 8;

	mov	ebp, 8

; 827  : 		  sym->e.structinfo->memberCount = memberCount;

	mov	DWORD PTR [rax+24], ebp
$LN37@SymSimd:

; 828  : 	  }
; 829  :   }
; 830  : 
; 831  :        sym->e.structinfo->isHFA = 0;

	mov	rax, QWORD PTR [rdi+104]
	mov	BYTE PTR [rax+22], 0

; 832  :        if ((memberCount >= 1 && memberCount <= 4) && (htype == MT_REAL4 || htype == MT_REAL8) && sym->e.structinfo->isHomogenous == 1)

	lea	eax, DWORD PTR [rbp-1]
	cmp	eax, 3
	ja	SHORT $LN36@SymSimd
	cmp	esi, 35					; 00000023H
	je	SHORT $LN35@SymSimd
	cmp	esi, 39					; 00000027H
	jne	SHORT $LN36@SymSimd
$LN35@SymSimd:
	mov	rax, QWORD PTR [rdi+104]
	cmp	BYTE PTR [rax+20], r12b
	jne	SHORT $LN36@SymSimd

; 833  :        {
; 834  :               sym->e.structinfo->isHFA = 1;

	mov	BYTE PTR [rax+22], r12b

; 835  : 			  sym->e.structinfo->stype = NOVEC;

	mov	rax, QWORD PTR [rdi+104]
	mov	DWORD PTR [rax+16], 0
$LN36@SymSimd:

; 836  :        }
; 837  : 
; 838  : 	   // Due to vectorcall convention, __m128 which is technically also an HFA (4 floats) must be marked as nonHFA.
; 839  : 	   // And consequently any structure with name __m128/__m256/__m512 must be marked as non-HFA. (This is a bit ugly, but it's the only way to ensure the types are correctly handled by invoke/proc).
; 840  : 
; 841  : 	   c0 = strncmp(sym->sym.name, "__m128", 6);

	mov	rcx, QWORD PTR [rdi+8]
	lea	rdx, OFFSET FLAT:$SG5969
	mov	r8d, 6
	mov	QWORD PTR [rsp+48], rbx
	call	strncmp

; 842  : 	   c1 = strncmp(sym->sym.name, "__m256", 6);

	mov	rcx, QWORD PTR [rdi+8]
	lea	rdx, OFFSET FLAT:$SG5970
	mov	r8d, 6
	mov	ebx, eax
	call	strncmp

; 843  : #if EVEXSUPP
; 844  : 	   c2 = strncmp(sym->sym.name, "__m512", 6);
; 845  : #endif
; 846  : 	   if (c0 == 0)

	test	ebx, ebx
	jne	SHORT $LN34@SymSimd

; 847  : 	   {
; 848  : 		   sym->e.structinfo->isHFA = 0;

	mov	rax, QWORD PTR [rdi+104]
	mov	BYTE PTR [rax+22], bl

; 849  : 		   sym->e.structinfo->stype = MM128;

	mov	rax, QWORD PTR [rdi+104]
	mov	DWORD PTR [rax+16], r12d
	jmp	SHORT $LN32@SymSimd
$LN34@SymSimd:

; 850  : 	   }
; 851  : 	   else if (c1 == 0)

	test	eax, eax
	jne	SHORT $LN32@SymSimd

; 852  : 	   {
; 853  : 		   sym->e.structinfo->isHFA = 0;

	mov	rax, QWORD PTR [rdi+104]
	mov	BYTE PTR [rax+22], 0

; 854  : 		   sym->e.structinfo->stype = MM256;

	mov	rax, QWORD PTR [rdi+104]
	mov	DWORD PTR [rax+16], 2
$LN32@SymSimd:

; 855  : 	   }
; 856  : #if EVEXSUPP
; 857  : 	   else if (c2 == 0)
; 858  : 	   {
; 859  : 		   sym->e.structinfo->isHFA = 0;
; 860  : 		   sym->e.structinfo->stype = MM512;
; 861  : 	   }
; 862  : #endif
; 863  : 
; 864  : 	   sym->e.structinfo->isHVA = 0;
; 865  : 	   if (memberCount == 4 && sym->e.structinfo->isHomogenous == 1 && htype == MT_TYPE && sym->sym.typekind != TYPE_UNION)

	cmp	ebp, 4
	mov	rax, QWORD PTR [rdi+104]
	mov	BYTE PTR [rax+21], 0
	jne	$LN31@SymSimd
	mov	rbx, QWORD PTR [rdi+104]
	cmp	BYTE PTR [rbx+20], r12b
	jne	$LN59@SymSimd
	cmp	esi, 196				; 000000c4H
	jne	$LN59@SymSimd
	cmp	BYTE PTR [rdi+74], 2
	je	$LN59@SymSimd

; 866  : 	   {
; 867  : 		   pMember = sym->e.structinfo->head;

	mov	r11, QWORD PTR [rbx]

; 868  : 		   member1Valid = 0;

	xor	r10b, r10b

; 869  : 		   member2Valid = 0;

	xor	r9b, r9b

; 870  : 		   member3Valid = 0;
; 871  : 		   member4Valid = 0;
; 872  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member1Valid = 1;

	mov	rax, QWORD PTR [r11+88]
	xor	r8b, r8b
	xor	dl, dl
	test	rax, rax
	je	SHORT $LN30@SymSimd
	mov	rax, QWORD PTR [rax+104]
	movzx	r10d, r10b
	cmp	DWORD PTR [rax+16], r12d
	cmove	r10d, r12d
$LN30@SymSimd:

; 873  : 		   pMember = pMember->next;

	mov	rcx, QWORD PTR [r11+104]

; 874  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member2Valid = 1;

	mov	rax, QWORD PTR [rcx+88]
	test	rax, rax
	je	SHORT $LN29@SymSimd
	mov	rax, QWORD PTR [rax+104]
	movzx	r9d, r9b
	cmp	DWORD PTR [rax+16], r12d
	cmove	r9d, r12d
$LN29@SymSimd:

; 875  : 		   pMember = pMember->next;

	mov	rcx, QWORD PTR [rcx+104]

; 876  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member3Valid = 1;

	mov	rax, QWORD PTR [rcx+88]
	test	rax, rax
	je	SHORT $LN28@SymSimd
	mov	rax, QWORD PTR [rax+104]
	movzx	r8d, r8b
	cmp	DWORD PTR [rax+16], r12d
	cmove	r8d, r12d
$LN28@SymSimd:

; 877  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR [rcx+104]

; 878  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member4Valid = 1;

	mov	rax, QWORD PTR [rax+88]
	test	rax, rax
	je	SHORT $LN27@SymSimd
	mov	rax, QWORD PTR [rax+104]
	movzx	edx, dl
	cmp	DWORD PTR [rax+16], r12d
	cmove	edx, r12d
$LN27@SymSimd:

; 879  : 
; 880  : 		   pMember = sym->e.structinfo->head;
; 881  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member1Valid = 1;

	mov	rax, QWORD PTR [r11+88]
	test	rax, rax
	je	SHORT $LN26@SymSimd
	mov	rax, QWORD PTR [rax+104]
	movzx	r10d, r10b
	cmp	DWORD PTR [rax+16], 2
	cmove	r10d, r12d
$LN26@SymSimd:

; 882  : 		   pMember = pMember->next;

	mov	r11, QWORD PTR [r11+104]

; 883  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member2Valid = 1;

	mov	rax, QWORD PTR [r11+88]
	test	rax, rax
	je	SHORT $LN25@SymSimd
	mov	rax, QWORD PTR [rax+104]
	movzx	r9d, r9b
	cmp	DWORD PTR [rax+16], 2
	cmove	r9d, r12d
$LN25@SymSimd:

; 884  : 		   pMember = pMember->next;

	mov	r11, QWORD PTR [r11+104]

; 885  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member3Valid = 1;

	mov	rax, QWORD PTR [r11+88]
	test	rax, rax
	je	SHORT $LN24@SymSimd
	mov	rax, QWORD PTR [rax+104]
	movzx	r8d, r8b
	cmp	DWORD PTR [rax+16], 2
	cmove	r8d, r12d
$LN24@SymSimd:

; 886  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR [r11+104]

; 887  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member4Valid = 1;

	mov	rax, QWORD PTR [rax+88]
	test	rax, rax
	je	SHORT $LN23@SymSimd
	mov	rax, QWORD PTR [rax+104]
	movzx	edx, dl
	cmp	DWORD PTR [rax+16], 2
	cmove	edx, r12d
$LN23@SymSimd:

; 888  : 
; 889  : 		   if (member1Valid == 1 && member2Valid == 1 && member3Valid == 1 && member4Valid == 1)

	cmp	r10b, r12b
	jne	$LN59@SymSimd
	cmp	r9b, r12b
	jne	$LN59@SymSimd
	cmp	r8b, r12b
	jne	$LN59@SymSimd
	cmp	dl, r12b
	jne	$LN59@SymSimd

; 890  : 		   {
; 891  : 			   sym->e.structinfo->isHVA = 1;

	mov	BYTE PTR [rbx+21], r12b

; 892  : 		   }

	jmp	$LN59@SymSimd
$LN31@SymSimd:

; 893  : 	   }
; 894  : 	   else if (memberCount == 3 && sym->e.structinfo->isHomogenous == 1 && htype == MT_TYPE && sym->sym.typekind != TYPE_UNION)

	cmp	ebp, 3
	jne	$LN20@SymSimd
	mov	r11, QWORD PTR [rdi+104]
	cmp	BYTE PTR [r11+20], r12b
	jne	$LN59@SymSimd
	cmp	esi, 196				; 000000c4H
	jne	$LN59@SymSimd
	cmp	BYTE PTR [rdi+74], 2
	je	$LN59@SymSimd

; 895  : 	   {
; 896  : 		   pMember = sym->e.structinfo->head;

	mov	r10, QWORD PTR [r11]

; 897  : 		   member1Valid = 0;

	xor	r9b, r9b

; 898  : 		   member2Valid = 0;

	xor	r8b, r8b

; 899  : 		   member3Valid = 0;
; 900  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member1Valid = 1;

	mov	rax, QWORD PTR [r10+88]
	xor	dl, dl
	test	rax, rax
	je	SHORT $LN19@SymSimd
	mov	rax, QWORD PTR [rax+104]
	movzx	r9d, r9b
	cmp	DWORD PTR [rax+16], r12d
	cmove	r9d, r12d
$LN19@SymSimd:

; 901  : 		   pMember = pMember->next;

	mov	rcx, QWORD PTR [r10+104]

; 902  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member2Valid = 1;

	mov	rax, QWORD PTR [rcx+88]
	test	rax, rax
	je	SHORT $LN18@SymSimd
	mov	rax, QWORD PTR [rax+104]
	movzx	r8d, r8b
	cmp	DWORD PTR [rax+16], r12d
	cmove	r8d, r12d
$LN18@SymSimd:

; 903  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR [rcx+104]

; 904  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member3Valid = 1;

	mov	rax, QWORD PTR [rax+88]
	test	rax, rax
	je	SHORT $LN17@SymSimd
	mov	rax, QWORD PTR [rax+104]
	movzx	edx, dl
	cmp	DWORD PTR [rax+16], r12d
	cmove	edx, r12d
$LN17@SymSimd:

; 905  : 
; 906  : 		   pMember = sym->e.structinfo->head;
; 907  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member1Valid = 1;

	mov	rax, QWORD PTR [r10+88]
	test	rax, rax
	je	SHORT $LN16@SymSimd
	mov	rax, QWORD PTR [rax+104]
	movzx	r9d, r9b
	cmp	DWORD PTR [rax+16], 2
	cmove	r9d, r12d
$LN16@SymSimd:

; 908  : 		   pMember = pMember->next;
; 909  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member2Valid = 1;

	mov	rax, QWORD PTR [rcx+88]
	test	rax, rax
	je	SHORT $LN15@SymSimd
	mov	rax, QWORD PTR [rax+104]
	movzx	r8d, r8b
	cmp	DWORD PTR [rax+16], 2
	cmove	r8d, r12d
$LN15@SymSimd:

; 910  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR [rcx+104]

; 911  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member3Valid = 1;

	mov	rax, QWORD PTR [rax+88]
	test	rax, rax
	je	SHORT $LN14@SymSimd
	mov	rax, QWORD PTR [rax+104]
	movzx	edx, dl
	cmp	DWORD PTR [rax+16], 2
	cmove	edx, r12d
$LN14@SymSimd:

; 912  : 
; 913  : 		   if (member1Valid == 1 && member2Valid == 1 && member3Valid == 1)

	cmp	r9b, r12b
	jne	$LN59@SymSimd
	cmp	r8b, r12b
	jne	$LN59@SymSimd
	cmp	dl, r12b
	jne	$LN59@SymSimd

; 914  : 		   {
; 915  : 			   sym->e.structinfo->isHVA = 1;

	mov	BYTE PTR [r11+21], r12b

; 916  : 		   }

	jmp	$LN59@SymSimd
$LN20@SymSimd:

; 917  : 	   }
; 918  : 	   else if (memberCount == 2 && sym->e.structinfo->isHomogenous == 1 && htype == MT_TYPE && sym->sym.typekind != TYPE_UNION)

	cmp	ebp, 2
	jne	$LN11@SymSimd
	mov	r10, QWORD PTR [rdi+104]
	cmp	BYTE PTR [r10+20], r12b
	jne	$LN59@SymSimd
	cmp	esi, 196				; 000000c4H
	jne	$LN59@SymSimd
	cmp	BYTE PTR [rdi+74], bpl
	je	$LN59@SymSimd

; 919  : 	   {
; 920  : 		   pMember = sym->e.structinfo->head;

	mov	r9, QWORD PTR [r10]

; 921  : 		   member1Valid = 0;

	xor	r8b, r8b

; 922  : 		   member2Valid = 0;

	xor	dl, dl

; 923  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member1Valid = 1;

	mov	rax, QWORD PTR [r9+88]
	test	rax, rax
	je	SHORT $LN10@SymSimd
	mov	rax, QWORD PTR [rax+104]
	movzx	r8d, r8b
	cmp	DWORD PTR [rax+16], r12d
	cmove	r8d, r12d
$LN10@SymSimd:

; 924  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR [r9+104]

; 925  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member2Valid = 1;

	mov	rax, QWORD PTR [rax+88]
	test	rax, rax
	je	SHORT $LN9@SymSimd
	mov	rax, QWORD PTR [rax+104]
	movzx	edx, dl
	cmp	DWORD PTR [rax+16], r12d
	cmove	edx, r12d
$LN9@SymSimd:

; 926  : 
; 927  : 		   pMember = sym->e.structinfo->head;
; 928  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member1Valid = 1;

	mov	rax, QWORD PTR [r9+88]
	test	rax, rax
	je	SHORT $LN8@SymSimd
	mov	rax, QWORD PTR [rax+104]
	movzx	r8d, r8b
	cmp	DWORD PTR [rax+16], 2
	cmove	r8d, r12d
$LN8@SymSimd:

; 929  : 		   pMember = pMember->next;

	mov	rax, QWORD PTR [r9+104]

; 930  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member2Valid = 1;

	mov	rax, QWORD PTR [rax+88]
	test	rax, rax
	je	SHORT $LN7@SymSimd
	mov	rax, QWORD PTR [rax+104]
	movzx	edx, dl
	cmp	DWORD PTR [rax+16], 2
	cmove	edx, r12d
$LN7@SymSimd:

; 931  : 
; 932  : 		   if (member1Valid == 1 && member2Valid == 1)

	cmp	r8b, r12b
	jne	SHORT $LN59@SymSimd
	cmp	dl, r12b
	jne	SHORT $LN59@SymSimd

; 933  : 		   {
; 934  : 			   sym->e.structinfo->isHVA = 1;

	mov	BYTE PTR [r10+21], r12b

; 935  : 		   }

	jmp	SHORT $LN59@SymSimd
$LN11@SymSimd:

; 936  : 	   }
; 937  : 	   else if (memberCount == 1 && sym->e.structinfo->isHomogenous == 1 && htype == MT_TYPE && sym->sym.typekind != TYPE_UNION)

	cmp	ebp, r12d
	jne	SHORT $LN59@SymSimd
	mov	r8, QWORD PTR [rdi+104]
	cmp	BYTE PTR [r8+20], r12b
	jne	SHORT $LN59@SymSimd
	cmp	esi, 196				; 000000c4H
	jne	SHORT $LN59@SymSimd
	cmp	BYTE PTR [rdi+74], 2
	je	SHORT $LN59@SymSimd

; 938  : 	   {
; 939  : 		   pMember = sym->e.structinfo->head;

	mov	rax, QWORD PTR [r8]

; 940  : 		   member1Valid = 0;

	xor	cl, cl

; 941  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM128) member1Valid = 1;

	mov	rdx, QWORD PTR [rax+88]
	test	rdx, rdx
	je	SHORT $LN3@SymSimd
	mov	rax, QWORD PTR [rdx+104]
	movzx	ecx, cl
	cmp	DWORD PTR [rax+16], r12d
	cmove	ecx, r12d
$LN3@SymSimd:

; 942  : 		   if (pMember->sym.ttype != NULL && pMember->sym.ttype->e.structinfo->stype == MM256) member1Valid = 1;

	test	rdx, rdx
	je	SHORT $LN2@SymSimd
	mov	rax, QWORD PTR [rdx+104]
	cmp	DWORD PTR [rax+16], 2

; 943  : 		   if (member1Valid == 1)

	je	SHORT $LN55@SymSimd
$LN2@SymSimd:
	cmp	cl, r12b
	jne	SHORT $LN59@SymSimd
$LN55@SymSimd:

; 944  : 		   {
; 945  : 			   sym->e.structinfo->isHVA = 1;

	mov	BYTE PTR [r8+21], r12b
$LN59@SymSimd:
	mov	rbx, QWORD PTR [rsp+48]
	mov	r12, QWORD PTR [rsp+32]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
$LN1@SymSimd:
	mov	rdi, QWORD PTR [rsp+72]

; 946  : 		   }
; 947  : 	   }
; 948  : 		#ifdef DEBUG_OUT	   
; 949  : 			printf("Symbol VectorCall Settings: %s isHomogenous:%u isHFA:%u isHVA:%u MMType:%u memberCount:%u\n", sym->sym.name, sym->e.structinfo->isHomogenous, sym->e.structinfo->isHFA, sym->e.structinfo->isHVA, sym->e.structinfo->stype, sym->e.structinfo->memberCount);
; 950  : 		#endif
; 951  : 
; 952  : }

	add	rsp, 40					; 00000028H
	ret	0
SymSimd	ENDP
_TEXT	ENDS
PUBLIC	WriteSymbols
EXTRN	fclose:NEAR
EXTRN	fwrite:NEAR
EXTRN	fseek:NEAR
EXTRN	fopen:NEAR
EXTRN	Options:BYTE
xdata	SEGMENT
$unwind$WriteSymbols DD 010401H
	DD	06204H
xdata	ENDS
pdata	SEGMENT
$pdata$WriteSymbols DD @imagerel($LN27#)
	DD	@imagerel($LN27#+40)
	DD	@imagerel($unwind$WriteSymbols#)
pdata	ENDS
xdata	SEGMENT
$chain$4$WriteSymbols DD 0a4321H
	DD	0b7443H
	DD	06c41bH
	DD	0a6416H
	DD	09540aH
	DD	083405H
	DD	@imagerel($LN27#)
	DD	@imagerel($LN27#+40)
	DD	@imagerel($unwind$WriteSymbols#)
xdata	ENDS
pdata	SEGMENT
$pdata$4$WriteSymbols DD @imagerel($LN27#+40)
	DD	@imagerel($LN27#+516)
	DD	@imagerel($chain$4$WriteSymbols#)
pdata	ENDS
xdata	SEGMENT
$chain$5$WriteSymbols DD 021H
	DD	@imagerel($LN27#)
	DD	@imagerel($LN27#+40)
	DD	@imagerel($unwind$WriteSymbols#)
xdata	ENDS
pdata	SEGMENT
$pdata$5$WriteSymbols DD @imagerel($LN27#+516)
	DD	@imagerel($LN27#+521)
	DD	@imagerel($chain$5$WriteSymbols#)
; Function compile flags: /Ogtpy
pdata	ENDS
_TEXT	SEGMENT
count$ = 32
i$ = 36
n$ = 36
WriteSymbols PROC NEAR

; 955  : {

$LN27:
	sub	rsp, 56					; 00000038H

; 956  : 	char *pName;
; 957  : 	uint_32 count = 0;
; 958  : 	int symbolIdx = 0;
; 959  : 	struct asym *sym;
; 960  : 	struct asym cSym;
; 961  : 	int i;
; 962  : 	FILE *ld;
; 963  : 	int n = 0;
; 964  : 
; 965  : 	if (Options.dumpSymbols)

	cmp	BYTE PTR Options+130, 0
	mov	DWORD PTR count$[rsp], 0
	mov	DWORD PTR n$[rsp], 0
	je	$LN13@WriteSymbo

; 966  : 	{
; 967  : 		pName = Options.names[4];
; 968  : 		ld = fopen(pName, "wb");

	mov	rcx, QWORD PTR Options+48
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rbp
	lea	rdx, OFFSET FLAT:$SG6035
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+48], r12
	call	fopen

; 969  : 		sym = NULL;

	xor	ebx, ebx

; 970  : 		fseek(ld, 4, SEEK_SET);

	xor	r8d, r8d
	lea	edx, QWORD PTR [rbx+4]
	mov	rcx, rax
	mov	rbp, rax
	call	fseek
	mov	esi, DWORD PTR i$[rsp]
	lea	r12, OFFSET FLAT:gsym_table
	mov	QWORD PTR [rsp+88], rdi
	npad	5
$LL12@WriteSymbo:

; 971  : 		while (sym = SymEnum(sym, &i)) 

	test	rbx, rbx
	jne	SHORT $LN19@WriteSymbo
	mov	rbx, QWORD PTR gsym_table
	xor	esi, esi
	jmp	SHORT $LN24@WriteSymbo
$LN19@WriteSymbo:
	mov	rbx, QWORD PTR [rbx]
$LN24@WriteSymbo:
	test	rbx, rbx
	jne	SHORT $LN26@WriteSymbo
$LL17@WriteSymbo:
	cmp	esi, 8008				; 00001f48H
	jge	SHORT $LN26@WriteSymbo
	inc	esi
	movsxd	rax, esi
	mov	rbx, QWORD PTR [r12+rax*8]
	test	rbx, rbx
	je	SHORT $LL17@WriteSymbo
$LN26@WriteSymbo:
	test	rbx, rbx
	je	$LN11@WriteSymbo

; 972  : 		{
; 973  : 			if ((sym->state == SYM_INTERNAL && sym->offset==0 && !sym->isproc) || sym->state == SYM_MACRO || sym->state == SYM_TMACRO || sym->state == SYM_GRP) continue;

	mov	eax, DWORD PTR [rbx+40]
	cmp	eax, 1
	jne	SHORT $LN8@WriteSymbo
	cmp	DWORD PTR [rbx+16], 0
	jne	SHORT $LN8@WriteSymbo
	test	BYTE PTR [rbx+49], 8
	je	SHORT $LL12@WriteSymbo
$LN8@WriteSymbo:
	cmp	eax, 9
	je	SHORT $LL12@WriteSymbo
	cmp	eax, 10
	je	SHORT $LL12@WriteSymbo
	cmp	eax, 4
	je	SHORT $LL12@WriteSymbo

; 974  : 			if (sym->state == SYM_TYPE && sym->typekind != TYPE_TYPEDEF && sym->cvtyperef == 0) 
; 975  : 			{
; 976  : 
; 977  : 			}
; 978  : 			if (sym->state == SYM_SEG)

	cmp	eax, 3
	jne	SHORT $LN6@WriteSymbo

; 979  : 				fwrite("S", 1, 1, ld);

	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6045
	mov	r9, rbp
	mov	r8, rdx
	call	fwrite
	jmp	SHORT $LN1@WriteSymbo
$LN6@WriteSymbo:

; 980  : 			else if (sym->state == SYM_TYPE)

	cmp	eax, 7
	jne	SHORT $LN4@WriteSymbo

; 981  : 				fwrite("T", 1, 1, ld);

	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6048
	mov	r9, rbp
	mov	r8, rdx
	call	fwrite
	jmp	SHORT $LN1@WriteSymbo
$LN4@WriteSymbo:

; 982  : 			else if (sym->isproc)

	test	BYTE PTR [rbx+49], 8
	je	SHORT $LN2@WriteSymbo

; 983  : 				fwrite("P", 1, 1, ld);

	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6051
	mov	r9, rbp
	mov	r8, rdx
	call	fwrite

; 984  : 			else

	jmp	SHORT $LN1@WriteSymbo
$LN2@WriteSymbo:

; 985  : 				fwrite("L", 1, 1, ld);

	mov	edx, 1
	lea	rcx, OFFSET FLAT:$SG6053
	mov	r9, rbp
	mov	r8, rdx
	call	fwrite
$LN1@WriteSymbo:

; 986  : 			fwrite(&(sym->offset), 4, 1, ld);

	mov	edx, 4
	lea	rcx, QWORD PTR [rbx+16]
	mov	r9, rbp
	lea	r8d, QWORD PTR [rdx-3]
	call	fwrite

; 987  : 			fwrite(&(sym->total_size), 4, 1, ld);

	mov	edx, 4
	lea	rcx, QWORD PTR [rbx+64]
	lea	r8d, QWORD PTR [rdx-3]
	mov	r9, rbp
	call	fwrite

; 988  : 			fwrite(&(sym->mem_type), 4, 1, ld);

	mov	edx, 4
	lea	rcx, QWORD PTR [rbx+44]
	lea	r8d, QWORD PTR [rdx-3]
	mov	r9, rbp
	call	fwrite

; 989  : 			fwrite(sym->name, 1, strlen(sym->name), ld);

	mov	r11, QWORD PTR [rbx+8]
	xor	eax, eax
	mov	rdi, r11
	mov	rcx, -1
	lea	edx, QWORD PTR [rax+1]
	repne scasb
	mov	r9, rbp
	not	rcx
	lea	r8, QWORD PTR [rcx-1]
	mov	rcx, r11
	call	fwrite

; 990  : 			fwrite(&n, 1, 1, ld);

	mov	edx, 1
	lea	rcx, QWORD PTR n$[rsp]
	mov	r8, rdx
	mov	r9, rbp
	call	fwrite

; 991  : 			count++;

	inc	DWORD PTR count$[rsp]

; 992  : 		}

	jmp	$LL12@WriteSymbo
$LN11@WriteSymbo:

; 993  : 		fseek(ld, 0, SEEK_SET);

	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, rbp
	call	fseek

; 994  : 		fwrite(&count, 4, 1, ld);

	mov	edx, 4
	lea	rcx, QWORD PTR count$[rsp]
	lea	r8d, QWORD PTR [rdx-3]
	mov	r9, rbp
	call	fwrite

; 995  : 		fclose(ld);

	mov	rcx, rbp
	call	fclose
	mov	r12, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]
$LN13@WriteSymbo:

; 996  : 	}
; 997  : }

	add	rsp, 56					; 00000038H
	ret	0
WriteSymbols ENDP
_TEXT	ENDS
END
